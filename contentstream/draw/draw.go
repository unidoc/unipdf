//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_fa "fmt";_f "github.com/unidoc/unipdf/v4/contentstream";_e "github.com/unidoc/unipdf/v4/core";_b "github.com/unidoc/unipdf/v4/internal/precision";_c "github.com/unidoc/unipdf/v4/internal/transform";_cc "github.com/unidoc/unipdf/v4/model";
_fd "math";);

// GetBoundingBox returns the bounding box of the Bezier path.
func (_ea CubicBezierPath )GetBoundingBox ()Rectangle {_df :=Rectangle {};_gg :=0.0;_ade :=0.0;_db :=0.0;_dfc :=0.0;for _be ,_dfb :=range _ea .Curves {_ge :=_dfb .GetBounds ();if _be ==0{_gg =_ge .Llx ;_ade =_ge .Urx ;_db =_ge .Lly ;_dfc =_ge .Ury ;continue ;
};if _ge .Llx < _gg {_gg =_ge .Llx ;};if _ge .Urx > _ade {_ade =_ge .Urx ;};if _ge .Lly < _db {_db =_ge .Lly ;};if _ge .Ury > _dfc {_dfc =_ge .Ury ;};};_df .X =_b .RoundDefault (_gg );_df .Y =_b .RoundDefault (_db );_df .Width =_b .RoundDefault (_ade -_gg );
_df .Height =_b .RoundDefault (_dfc -_db );return _df ;};

// Flip changes the sign of the vector: -vector.
func (_fad Vector )Flip ()Vector {_ddf :=_fad .Magnitude ();_gga :=_fad .GetPolarAngle ();_fad .Dx =_ddf *_fd .Cos (_gga +_fd .Pi );_fad .Dy =_ddf *_fd .Sin (_gga +_fd .Pi );return _fad ;};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;
LineEndingStyleButt LineEndingStyle =2;);

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_cfg Path )GetPointNumber (number int )Point {if number < 1||number > len (_cfg .Points ){return Point {};};return _cfg .Points [number -1];};

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _cc .PdfColor ;BorderEnabled bool ;BorderColor _cc .PdfColor ;BorderWidth float64 ;};

// AppendPoint adds the specified point to the path.
func (_cd Path )AppendPoint (point Point )Path {_cd .Points =append (_cd .Points ,point );return _cd };

// Draw draws the polygon and marked the content using the specified marked content id.
// A graphics state name can be specified for setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty ("").
//
// If mcid is nil, no marked content is added.
//
// Returns the content stream as a byte array and the polygon bounding box.
func (_cade Polygon )MarkedDraw (gsName string ,structureInfo *_cc .StructureTagInfo )([]byte ,*_cc .PdfRectangle ,error ){_agg :=_f .NewContentCreator ();if structureInfo !=nil {_agg .Add_BDC (*_e .MakeName (string (structureInfo .StructureType )),map[string ]_e .PdfObject {"\u004d\u0043\u0049\u0044":_e .MakeInteger (structureInfo .Mcid )});
};_agg .Add_q ();_cade .FillEnabled =_cade .FillEnabled &&_cade .FillColor !=nil ;if _cade .FillEnabled {_agg .SetNonStrokingColor (_cade .FillColor );};_cade .BorderEnabled =_cade .BorderEnabled &&_cade .BorderColor !=nil ;if _cade .BorderEnabled {_agg .SetStrokingColor (_cade .BorderColor );
_agg .Add_w (_cade .BorderWidth );};if len (gsName )> 1{_agg .Add_gs (_e .PdfObjectName (gsName ));};_ecd :=NewPath ();for _ ,_ebf :=range _cade .Points {for _afe ,_aggg :=range _ebf {_ecd =_ecd .AppendPoint (_aggg );if _afe ==0{_agg .Add_m (_aggg .X ,_aggg .Y );
}else {_agg .Add_l (_aggg .X ,_aggg .Y );};};_agg .Add_h ();};if _cade .FillEnabled &&_cade .BorderEnabled {_agg .Add_B ();}else if _cade .FillEnabled {_agg .Add_f ();}else if _cade .BorderEnabled {_agg .Add_S ();};_agg .Add_Q ();if structureInfo !=nil {_agg .Add_EMC ();
};return _agg .Bytes (),_ecd .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the basic line to PDF and marked the content using the specified marked content id.
// Generates the content stream which can be used in page contents or appearance stream of annotation.
//
// If mcid is nil, no marked content is added.
//
// Returns the stream content, XForm bounding box (local), bounding box and an error if one occurred.
func (_gac BasicLine )MarkedDraw (gsName string ,structureInfo *_cc .StructureTagInfo )([]byte ,*_cc .PdfRectangle ,error ){_gbb :=NewPath ();_gbb =_gbb .AppendPoint (NewPoint (_gac .X1 ,_gac .Y1 ));_gbb =_gbb .AppendPoint (NewPoint (_gac .X2 ,_gac .Y2 ));
_fce :=_f .NewContentCreator ();if structureInfo !=nil {_fce .Add_BDC (*_e .MakeName (string (structureInfo .StructureType )),map[string ]_e .PdfObject {"\u004d\u0043\u0049\u0044":_e .MakeInteger (structureInfo .Mcid )});};_fce .Add_q ().Add_w (_gac .LineWidth ).SetStrokingColor (_gac .LineColor );
if _gac .LineStyle ==LineStyleDashed {if _gac .DashArray ==nil {_gac .DashArray =[]int64 {1,1};};_fce .Add_d (_gac .DashArray ,_gac .DashPhase );};if len (gsName )> 1{_fce .Add_gs (_e .PdfObjectName (gsName ));};DrawPathWithCreator (_gbb ,_fce );_fce .Add_S ().Add_Q ();
if structureInfo !=nil {_fce .Add_EMC ();};return _fce .Bytes (),_gbb .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Offset shifts the path with the specified offsets.
func (_gf Path )Offset (offX ,offY float64 )Path {for _dfe ,_cac :=range _gf .Points {_gf .Points [_dfe ]=_cac .Add (offX ,offY );};return _gf ;};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{

// Position and size properties.
X float64 ;Y float64 ;Width float64 ;Height float64 ;

// Fill properties.
FillEnabled bool ;FillColor _cc .PdfColor ;

// Border properties.
BorderEnabled bool ;BorderColor _cc .PdfColor ;BorderWidth float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;

// Shape opacity (0-1 interval).
Opacity float64 ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_bac Polyline )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){return _bac .MarkedDraw (gsName ,nil );};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_egf Path )RemovePoint (number int )Path {if number < 1||number > len (_egf .Points ){return _egf ;};_cad :=number -1;_egf .Points =append (_egf .Points [:_cad ],_egf .Points [_cad +1:]...);return _egf ;};const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;
);

// AddVector adds vector to a point.
func (_afa Point )AddVector (v Vector )Point {_afa .X +=v .Dx ;_afa .Y +=v .Dy ;return _afa };

// Magnitude returns the magnitude of the vector.
func (_edd Vector )Magnitude ()float64 {return _fd .Sqrt (_fd .Pow (_edd .Dx ,2.0)+_fd .Pow (_edd .Dy ,2.0));};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _cc .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;DashArray []int64 ;DashPhase int64 ;};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_gec PolyBezierCurve )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){return _gec .MarkedDraw (gsName ,nil );};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _cc .PdfColor ;BorderEnabled bool ;BorderColor _cc .PdfColor ;BorderWidth float64 ;};

// GetBoundingBox returns the bounding box of the path.
func (_ega Path )GetBoundingBox ()BoundingBox {_ga :=BoundingBox {};_gd :=0.0;_cgg :=0.0;_eef :=0.0;_bf :=0.0;for _da ,_fea :=range _ega .Points {if _da ==0{_gd =_fea .X ;_cgg =_fea .X ;_eef =_fea .Y ;_bf =_fea .Y ;continue ;};if _fea .X < _gd {_gd =_fea .X ;
};if _fea .X > _cgg {_cgg =_fea .X ;};if _fea .Y < _eef {_eef =_fea .Y ;};if _fea .Y > _bf {_bf =_fea .Y ;};};_ga .X =_gd ;_ga .Y =_eef ;_ga .Width =_cgg -_gd ;_ga .Height =_bf -_eef ;return _ga ;};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_fdf :=CubicBezierPath {};_fdf .Curves =[]CubicBezierCurve {};return _fdf ;};

// Rotate rotates the vector by the specified angle.
func (_acba Vector )Rotate (phi float64 )Vector {_fbf :=_acba .Magnitude ();_ed :=_acba .GetPolarAngle ();return NewVectorPolar (_fbf ,_ed +phi );};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_gdb :=Vector {};_gdb .Dx =b .X -a .X ;_gdb .Dy =b .Y -a .Y ;return _gdb ;};

// Draw draws the polyline and marked the content using the specified marked content id..
// A graphics state name can be specified for setting the polyline properties (e.g. setting the opacity).
// Otherwise leave empty ("").
//
// If mcid is nil, no marked content is added.
//
// Returns the content stream as a byte array and the polyline bounding box.
func (_bfge Polyline )MarkedDraw (gsName string ,structureInfo *_cc .StructureTagInfo )([]byte ,*_cc .PdfRectangle ,error ){if _bfge .LineColor ==nil {_bfge .LineColor =_cc .NewPdfColorDeviceRGB (0,0,0);};_cadebc :=NewPath ();for _ ,_abg :=range _bfge .Points {_cadebc =_cadebc .AppendPoint (_abg );
};_ebb :=_f .NewContentCreator ();if structureInfo !=nil {_ebb .Add_BDC (*_e .MakeName (string (structureInfo .StructureType )),map[string ]_e .PdfObject {"\u004d\u0043\u0049\u0044":_e .MakeInteger (structureInfo .Mcid )});};_ebb .Add_q ().SetStrokingColor (_bfge .LineColor ).Add_w (_bfge .LineWidth );
if len (gsName )> 1{_ebb .Add_gs (_e .PdfObjectName (gsName ));};DrawPathWithCreator (_cadebc ,_ebb );_ebb .Add_S ();_ebb .Add_Q ();if structureInfo !=nil {_ebb .Add_EMC ();};return _ebb .Bytes (),_cadebc .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the composite Bezier curve and marked the content using the specified marked content id.
// A graphics state name can be specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty ("").
//
// If mcid is nil, no marked content is added.
//
// Returns the content stream as a byte array and the curve bounding box.
func (_dde PolyBezierCurve )MarkedDraw (gsName string ,structureInfo *_cc .StructureTagInfo )([]byte ,*_cc .PdfRectangle ,error ){if _dde .BorderColor ==nil {_dde .BorderColor =_cc .NewPdfColorDeviceRGB (0,0,0);};_dgb :=NewCubicBezierPath ();for _ ,_fb :=range _dde .Curves {_dgb =_dgb .AppendCurve (_fb );
};_gge :=_f .NewContentCreator ();if structureInfo !=nil {_gge .Add_BDC (*_e .MakeName (string (structureInfo .StructureType )),map[string ]_e .PdfObject {"\u004d\u0043\u0049\u0044":_e .MakeInteger (structureInfo .Mcid )});};_gge .Add_q ();_dde .FillEnabled =_dde .FillEnabled &&_dde .FillColor !=nil ;
if _dde .FillEnabled {_gge .SetNonStrokingColor (_dde .FillColor );};_gge .SetStrokingColor (_dde .BorderColor );_gge .Add_w (_dde .BorderWidth );if len (gsName )> 1{_gge .Add_gs (_e .PdfObjectName (gsName ));};for _ege ,_ggd :=range _dgb .Curves {if _ege ==0{_gge .Add_m (_ggd .P0 .X ,_ggd .P0 .Y );
}else {_gge .Add_l (_ggd .P0 .X ,_ggd .P0 .Y );};_gge .Add_c (_ggd .P1 .X ,_ggd .P1 .Y ,_ggd .P2 .X ,_ggd .P2 .Y ,_ggd .P3 .X ,_ggd .P3 .Y );};if _dde .FillEnabled {_gge .Add_h ();_gge .Add_B ();}else {_gge .Add_S ();};_gge .Add_Q ();if structureInfo !=nil {_gge .Add_EMC ();
};return _gge .Bytes (),_dgb .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_egab Polygon )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){return _egab .MarkedDraw (gsName ,nil );};

// Copy returns a clone of the path.
func (_fgg Path )Copy ()Path {_ag :=Path {};_ag .Points =append (_ag .Points ,_fgg .Points ...);return _ag ;};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_fag :=Vector {};_fag .Dx =dx ;_fag .Dy =dy ;return _fag };

// Draw draws the circle and marked the content using the specified marked content id.
// Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
//
// If mcid is nil, no marked content is added.
//
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_add Circle )MarkedDraw (gsName string ,structureInfo *_cc .StructureTagInfo )([]byte ,*_cc .PdfRectangle ,error ){_gfe :=_add .Width /2;_ffd :=_add .Height /2;if _add .BorderEnabled {_gfe -=_add .BorderWidth /2;_ffd -=_add .BorderWidth /2;};_aed :=0.551784;
_ab :=_gfe *_aed ;_ecf :=_ffd *_aed ;_dbb :=NewCubicBezierPath ();_dbb =_dbb .AppendCurve (NewCubicBezierCurve (-_gfe ,0,-_gfe ,_ecf ,-_ab ,_ffd ,0,_ffd ));_dbb =_dbb .AppendCurve (NewCubicBezierCurve (0,_ffd ,_ab ,_ffd ,_gfe ,_ecf ,_gfe ,0));_dbb =_dbb .AppendCurve (NewCubicBezierCurve (_gfe ,0,_gfe ,-_ecf ,_ab ,-_ffd ,0,-_ffd ));
_dbb =_dbb .AppendCurve (NewCubicBezierCurve (0,-_ffd ,-_ab ,-_ffd ,-_gfe ,-_ecf ,-_gfe ,0));_dbb =_dbb .Offset (_gfe ,_ffd );if _add .BorderEnabled {_dbb =_dbb .Offset (_add .BorderWidth /2,_add .BorderWidth /2);};if _add .X !=0||_add .Y !=0{_dbb =_dbb .Offset (_add .X ,_add .Y );
};_bb :=_f .NewContentCreator ();if structureInfo !=nil {_bb .Add_BDC (*_e .MakeName (string (structureInfo .StructureType )),map[string ]_e .PdfObject {"\u004d\u0043\u0049\u0044":_e .MakeInteger (structureInfo .Mcid )});};_bb .Add_q ();if _add .FillEnabled {_bb .SetNonStrokingColor (_add .FillColor );
};if _add .BorderEnabled {_bb .SetStrokingColor (_add .BorderColor );_bb .Add_w (_add .BorderWidth );};if len (gsName )> 1{_bb .Add_gs (_e .PdfObjectName (gsName ));};DrawBezierPathWithCreator (_dbb ,_bb );_bb .Add_h ();if _add .FillEnabled &&_add .BorderEnabled {_bb .Add_B ();
}else if _add .FillEnabled {_bb .Add_f ();}else if _add .BorderEnabled {_bb .Add_S ();};_bb .Add_Q ();if structureInfo !=nil {_bb .Add_EMC ();};_fed :=_dbb .GetBoundingBox ();if _add .BorderEnabled {_fed .Height +=_add .BorderWidth ;_fed .Width +=_add .BorderWidth ;
_fed .X -=_add .BorderWidth /2;_fed .Y -=_add .BorderWidth /2;};return _bb .Bytes (),_fed .ToPdfRectangle (),nil ;};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_beg CurvePolygon )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){return _beg .MarkedDraw (gsName ,nil );};

// FlipX flips the sign of the Dx component of the vector.
func (_ebfa Vector )FlipX ()Vector {_ebfa .Dx =-_ebfa .Dx ;return _ebfa };

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _cc .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _cc .PdfColor ;Opacity float64 ;};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_f .ContentCreator ){for _fba ,_ffdb :=range path .Points {if _fba ==0{creator .Add_m (_ffdb .X ,_ffdb .Y );}else {creator .Add_l (_ffdb .X ,_ffdb .Y );};};};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// Draw draws the composite curve polygon and marked the content using the specified marked content id.
// A graphics state name can be specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty ("").
//
// If mcid is nil, no marked content is added.
//
// Returns the content stream as a byte array and the bounding box of the polygon.
func (_dae CurvePolygon )MarkedDraw (gsName string ,structureInfo *_cc .StructureTagInfo )([]byte ,*_cc .PdfRectangle ,error ){_gfc :=_f .NewContentCreator ();if structureInfo !=nil {_gfc .Add_BDC (*_e .MakeName (string (structureInfo .StructureType )),map[string ]_e .PdfObject {"\u004d\u0043\u0049\u0044":_e .MakeInteger (structureInfo .Mcid )});
};_gfc .Add_q ();_dae .FillEnabled =_dae .FillEnabled &&_dae .FillColor !=nil ;if _dae .FillEnabled {_gfc .SetNonStrokingColor (_dae .FillColor );};_dae .BorderEnabled =_dae .BorderEnabled &&_dae .BorderColor !=nil ;if _dae .BorderEnabled {_gfc .SetStrokingColor (_dae .BorderColor );
_gfc .Add_w (_dae .BorderWidth );};if len (gsName )> 1{_gfc .Add_gs (_e .PdfObjectName (gsName ));};_cfgc :=NewCubicBezierPath ();for _ ,_gc :=range _dae .Rings {for _bfd ,_ffg :=range _gc {if _bfd ==0{_gfc .Add_m (_ffg .P0 .X ,_ffg .P0 .Y );}else {_gfc .Add_l (_ffg .P0 .X ,_ffg .P0 .Y );
};_gfc .Add_c (_ffg .P1 .X ,_ffg .P1 .Y ,_ffg .P2 .X ,_ffg .P2 .Y ,_ffg .P3 .X ,_ffg .P3 .Y );_cfgc =_cfgc .AppendCurve (_ffg );};_gfc .Add_h ();};if _dae .FillEnabled &&_dae .BorderEnabled {_gfc .Add_B ();}else if _dae .FillEnabled {_gfc .Add_f ();}else if _dae .BorderEnabled {_gfc .Add_S ();
};_gfc .Add_Q ();if structureInfo !=nil {_gfc .Add_EMC ();};return _gfc .Bytes (),_cfgc .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Offset shifts the Bezier path with the specified offsets.
func (_cfc CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _g ,_ad :=range _cfc .Curves {_cfc .Curves [_g ]=_ad .AddOffsetXY (offX ,offY );};return _cfc ;};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_eee Rectangle )ToPdfRectangle ()*_cc .PdfRectangle {return &_cc .PdfRectangle {Llx :_eee .X ,Lly :_eee .Y ,Urx :_eee .X +_eee .Width ,Ury :_eee .Y +_eee .Height };};

// Add adds the specified vector to the current one and returns the result.
func (_caeb Vector )Add (other Vector )Vector {_caeb .Dx +=other .Dx ;_caeb .Dy +=other .Dy ;return _caeb ;};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_ba Point )Rotate (theta float64 )Point {_dab :=_c .NewPoint (_ba .X ,_ba .Y ).Rotate (theta );return NewPoint (_dab .X ,_dab .Y );};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _cc .PdfColor ;FillEnabled bool ;FillColor _cc .PdfColor ;};

// Draw draws the rectangle. A graphics state can be specified for
// setting additional properties (e.g. opacity). Otherwise pass an empty string
// for the `gsName` parameter. The method returns the content stream as a byte
// array and the bounding box of the shape.
func (_adb Rectangle )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){return _adb .MarkedDraw (gsName ,nil );};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_dg BoundingBox )ToPdfRectangle ()*_cc .PdfRectangle {return &_cc .PdfRectangle {Llx :_dg .X ,Lly :_dg .Y ,Urx :_dg .X +_dg .Width ,Ury :_dg .Y +_dg .Height };};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_fecb :=Vector {};_fecb .Dx =length *_fd .Cos (theta );_fecb .Dy =length *_fd .Sin (theta );return _fecb ;};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _cc .PdfColor ;LineWidth float64 ;};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_gde Circle )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){return _gde .MarkedDraw (gsName ,nil );};

// Length returns the number of points in the path.
func (_fdg Path )Length ()int {return len (_fdg .Points )};

// Draw draws the rectangle and marked the content using the specified marked content id.
// A graphics state can be specified for setting additional properties (e.g. opacity).
// Otherwise pass an empty string for the `gsName` parameter.
//
// If `mcid` is nil, no marked content is added.
//
// The method returns the content stream as a byte array and the bounding box of the shape.
func (_gece Rectangle )MarkedDraw (gsName string ,structureInfo *_cc .StructureTagInfo )([]byte ,*_cc .PdfRectangle ,error ){_cbg :=_f .NewContentCreator ();if structureInfo !=nil {_cbg .Add_BDC (*_e .MakeName (string (structureInfo .StructureType )),map[string ]_e .PdfObject {"\u004d\u0043\u0049\u0044":_e .MakeInteger (structureInfo .Mcid )});
};_cbg .Add_q ();if _gece .FillEnabled {_cbg .SetNonStrokingColor (_gece .FillColor );};if _gece .BorderEnabled {_cbg .SetStrokingColor (_gece .BorderColor );_cbg .Add_w (_gece .BorderWidth );};if len (gsName )> 1{_cbg .Add_gs (_e .PdfObjectName (gsName ));
};var (_cgc ,_fbb =_gece .X ,_gece .Y ;_bege ,_gb =_gece .Width ,_gece .Height ;_ef =_fd .Abs (_gece .BorderRadiusTopLeft );_bbe =_fd .Abs (_gece .BorderRadiusTopRight );_fbd =_fd .Abs (_gece .BorderRadiusBottomLeft );_cae =_fd .Abs (_gece .BorderRadiusBottomRight );
_caea =0.4477;);_aa :=Path {Points :[]Point {{X :_cgc +_bege -_cae ,Y :_fbb },{X :_cgc +_bege ,Y :_fbb +_gb -_bbe },{X :_cgc +_ef ,Y :_fbb +_gb },{X :_cgc ,Y :_fbb +_fbd }}};_ada :=[][7]float64 {{_cae ,_cgc +_bege -_cae *_caea ,_fbb ,_cgc +_bege ,_fbb +_cae *_caea ,_cgc +_bege ,_fbb +_cae },{_bbe ,_cgc +_bege ,_fbb +_gb -_bbe *_caea ,_cgc +_bege -_bbe *_caea ,_fbb +_gb ,_cgc +_bege -_bbe ,_fbb +_gb },{_ef ,_cgc +_ef *_caea ,_fbb +_gb ,_cgc ,_fbb +_gb -_ef *_caea ,_cgc ,_fbb +_gb -_ef },{_fbd ,_cgc ,_fbb +_fbd *_caea ,_cgc +_fbd *_caea ,_fbb ,_cgc +_fbd ,_fbb }};
_cbg .Add_m (_cgc +_fbd ,_fbb );for _abc :=0;_abc < 4;_abc ++{_dc :=_aa .Points [_abc ];_cbg .Add_l (_dc .X ,_dc .Y );_eba :=_ada [_abc ];if _dfbc :=_eba [0];_dfbc !=0{_cbg .Add_c (_eba [1],_eba [2],_eba [3],_eba [4],_eba [5],_eba [6]);};};_cbg .Add_h ();
if _gece .FillEnabled &&_gece .BorderEnabled {_cbg .Add_B ();}else if _gece .FillEnabled {_cbg .Add_f ();}else if _gece .BorderEnabled {_cbg .Add_S ();};_cbg .Add_Q ();if structureInfo !=nil {_cbg .Add_EMC ();};return _cbg .Bytes (),_aa .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// AppendCurve appends the specified Bezier curve to the path.
func (_cb CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_cb .Curves =append (_cb .Curves ,curve );return _cb ;};

// Scale scales the vector by the specified factor.
func (_dad Vector )Scale (factor float64 )Vector {_gfb :=_dad .Magnitude ();_cbc :=_dad .GetPolarAngle ();_dad .Dx =factor *_gfb *_fd .Cos (_cbc );_dad .Dy =factor *_gfb *_fd .Sin (_cbc );return _dad ;};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_cef Line )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){_fff ,_fggd :=_cef .X1 ,_cef .X2 ;_cfd ,_gecd :=_cef .Y1 ,_cef .Y2 ;_dbe :=_gecd -_cfd ;_bbf :=_fggd -_fff ;_aca :=_fd .Atan2 (_dbe ,_bbf );L :=_fd .Sqrt (_fd .Pow (_bbf ,2.0)+_fd .Pow (_dbe ,2.0));
_abd :=_cef .LineWidth ;_cdd :=_fd .Pi ;_cgfc :=1.0;if _bbf < 0{_cgfc *=-1.0;};if _dbe < 0{_cgfc *=-1.0;};VsX :=_cgfc *(-_abd /2*_fd .Cos (_aca +_cdd /2));VsY :=_cgfc *(-_abd /2*_fd .Sin (_aca +_cdd /2)+_abd *_fd .Sin (_aca +_cdd /2));V1X :=VsX +_abd /2*_fd .Cos (_aca +_cdd /2);
V1Y :=VsY +_abd /2*_fd .Sin (_aca +_cdd /2);V2X :=VsX +_abd /2*_fd .Cos (_aca +_cdd /2)+L *_fd .Cos (_aca );V2Y :=VsY +_abd /2*_fd .Sin (_aca +_cdd /2)+L *_fd .Sin (_aca );V3X :=VsX +_abd /2*_fd .Cos (_aca +_cdd /2)+L *_fd .Cos (_aca )+_abd *_fd .Cos (_aca -_cdd /2);
V3Y :=VsY +_abd /2*_fd .Sin (_aca +_cdd /2)+L *_fd .Sin (_aca )+_abd *_fd .Sin (_aca -_cdd /2);V4X :=VsX +_abd /2*_fd .Cos (_aca -_cdd /2);V4Y :=VsY +_abd /2*_fd .Sin (_aca -_cdd /2);_dfca :=NewPath ();_dfca =_dfca .AppendPoint (NewPoint (V1X ,V1Y ));_dfca =_dfca .AppendPoint (NewPoint (V2X ,V2Y ));
_dfca =_dfca .AppendPoint (NewPoint (V3X ,V3Y ));_dfca =_dfca .AppendPoint (NewPoint (V4X ,V4Y ));_fgc :=_cef .LineEndingStyle1 ;_ffgc :=_cef .LineEndingStyle2 ;_fec :=3*_abd ;_dfcb :=3*_abd ;_fc :=(_dfcb -_abd )/2;if _ffgc ==LineEndingStyleArrow {_adag :=_dfca .GetPointNumber (2);
_gce :=NewVectorPolar (_fec ,_aca +_cdd );_de :=_adag .AddVector (_gce );_bef :=NewVectorPolar (_dfcb /2,_aca +_cdd /2);_fbe :=NewVectorPolar (_fec ,_aca );_eefe :=NewVectorPolar (_fc ,_aca +_cdd /2);_cadeb :=_de .AddVector (_eefe );_cgce :=_fbe .Add (_bef .Flip ());
_bc :=_cadeb .AddVector (_cgce );_acb :=_bef .Scale (2).Flip ().Add (_cgce .Flip ());_ecfa :=_bc .AddVector (_acb );_dge :=_de .AddVector (NewVectorPolar (_abd ,_aca -_cdd /2));_eag :=NewPath ();_eag =_eag .AppendPoint (_dfca .GetPointNumber (1));_eag =_eag .AppendPoint (_de );
_eag =_eag .AppendPoint (_cadeb );_eag =_eag .AppendPoint (_bc );_eag =_eag .AppendPoint (_ecfa );_eag =_eag .AppendPoint (_dge );_eag =_eag .AppendPoint (_dfca .GetPointNumber (4));_dfca =_eag ;};if _fgc ==LineEndingStyleArrow {_fffe :=_dfca .GetPointNumber (1);
_bgb :=_dfca .GetPointNumber (_dfca .Length ());_fdd :=NewVectorPolar (_abd /2,_aca +_cdd +_cdd /2);_cbe :=_fffe .AddVector (_fdd );_cca :=NewVectorPolar (_fec ,_aca ).Add (NewVectorPolar (_dfcb /2,_aca +_cdd /2));_eae :=_cbe .AddVector (_cca );_acbg :=NewVectorPolar (_fc ,_aca -_cdd /2);
_cfca :=_eae .AddVector (_acbg );_eab :=NewVectorPolar (_fec ,_aca );_eeeb :=_bgb .AddVector (_eab );_dfg :=NewVectorPolar (_fc ,_aca +_cdd +_cdd /2);_fgd :=_eeeb .AddVector (_dfg );_cbgf :=_cbe ;_bfg :=NewPath ();_bfg =_bfg .AppendPoint (_cbe );_bfg =_bfg .AppendPoint (_eae );
_bfg =_bfg .AppendPoint (_cfca );for _ ,_ebe :=range _dfca .Points [1:len (_dfca .Points )-1]{_bfg =_bfg .AppendPoint (_ebe );};_bfg =_bfg .AppendPoint (_eeeb );_bfg =_bfg .AppendPoint (_fgd );_bfg =_bfg .AppendPoint (_cbgf );_dfca =_bfg ;};_ffc :=_f .NewContentCreator ();
_ffc .Add_q ().SetNonStrokingColor (_cef .LineColor );if len (gsName )> 1{_ffc .Add_gs (_e .PdfObjectName (gsName ));};_dfca =_dfca .Offset (_cef .X1 ,_cef .Y1 );_eec :=_dfca .GetBoundingBox ();DrawPathWithCreator (_dfca ,_ffc );if _cef .LineStyle ==LineStyleDashed {_ffc .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_ffc .Add_f ().Add_Q ();};return _ffc .Bytes (),_eec .ToPdfRectangle (),nil ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_cf :=CubicBezierCurve {};_cf .P0 =NewPoint (x0 ,y0 );_cf .P1 =NewPoint (x1 ,y1 );_cf .P2 =NewPoint (x2 ,y2 );_cf .P3 =NewPoint (x3 ,y3 );return _cf ;};func (_ae Point )String ()string {return _fa .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_ae .X ,_ae .Y );
};

// Copy returns a clone of the Bezier path.
func (_fe CubicBezierPath )Copy ()CubicBezierPath {_af :=CubicBezierPath {};_af .Curves =append (_af .Curves ,_fe .Curves ...);return _af ;};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_f .ContentCreator ){for _ccc ,_afac :=range bpath .Curves {if _ccc ==0{creator .Add_m (_afac .P0 .X ,_afac .P0 .Y );};creator .Add_c (_afac .P1 .X ,_afac .P1 .Y ,_afac .P2 .X ,_afac .P2 .Y ,_afac .P3 .X ,_afac .P3 .Y );
};};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_gad BasicLine )Draw (gsName string )([]byte ,*_cc .PdfRectangle ,error ){return _gad .MarkedDraw (gsName ,nil );};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_d CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_d .P0 .X +=offX ;_d .P1 .X +=offX ;_d .P2 .X +=offX ;_d .P3 .X +=offX ;_d .P0 .Y +=offY ;_d .P1 .Y +=offY ;_d .P2 .Y +=offY ;_d .P3 .Y +=offY ;return _d ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _cc .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_ebg Vector )GetPolarAngle ()float64 {return _fd .Atan2 (_ebg .Dy ,_ebg .Dx )};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_dd Point )Add (dx ,dy float64 )Point {_dd .X +=dx ;_dd .Y +=dy ;return _dd };

// FlipY flips the sign of the Dy component of the vector.
func (_ccd Vector )FlipY ()Vector {_ccd .Dy =-_ccd .Dy ;return _ccd };

// GetBounds returns the bounding box of the Bezier curve.
func (_fg CubicBezierCurve )GetBounds ()_cc .PdfRectangle {_ce :=_fg .P0 .X ;_ec :=_fg .P0 .X ;_eb :=_fg .P0 .Y ;_ceb :=_fg .P0 .Y ;for _eg :=0.0;_eg <=1.0;_eg +=0.001{_bg :=1-_eg ;_ee :=_bg *_bg ;_ca :=_ee *_bg ;_ff :=_eg *_eg ;_cg :=_ff *_eg ;Rx :=_fg .P0 .X *_ca +_fg .P1 .X *3*_eg *_ee +_fg .P2 .X *3*_ff *_bg +_fg .P3 .X *_cg ;
Ry :=_fg .P0 .Y *_ca +_fg .P1 .Y *3*_eg *_ee +_fg .P2 .Y *3*_ff *_bg +_fg .P3 .Y *_cg ;if Rx < _ce {_ce =Rx ;};if Rx > _ec {_ec =Rx ;};if Ry < _eb {_eb =Ry ;};if Ry > _ceb {_ceb =Ry ;};};_cebf :=_cc .PdfRectangle {};_cebf .Llx =_ce ;_cebf .Lly =_eb ;_cebf .Urx =_ec ;
_cebf .Ury =_ceb ;return _cebf ;};