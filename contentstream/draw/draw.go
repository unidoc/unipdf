//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_f "fmt";_ba "github.com/unidoc/unipdf/v3/contentstream";_fa "github.com/unidoc/unipdf/v3/core";_cf "github.com/unidoc/unipdf/v3/internal/transform";_a "github.com/unidoc/unipdf/v3/model";_b "math";);

// Magnitude returns the magnitude of the vector.
func (_ddf Vector )Magnitude ()float64 {return _b .Sqrt (_b .Pow (_ddf .Dx ,2.0)+_b .Pow (_ddf .Dy ,2.0))};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_ff BoundingBox )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_ff .X ,Lly :_ff .Y ,Urx :_ff .X +_ff .Width ,Ury :_ff .Y +_ff .Height };};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_dd Circle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_dfb :=_dd .Width /2;_ea :=_dd .Height /2;if _dd .BorderEnabled {_dfb -=_dd .BorderWidth /2;_ea -=_dd .BorderWidth /2;};_bbf :=0.551784;_dfa :=_dfb *_bbf ;_gg :=_ea *_bbf ;_egfe :=NewCubicBezierPath ();
_egfe =_egfe .AppendCurve (NewCubicBezierCurve (-_dfb ,0,-_dfb ,_gg ,-_dfa ,_ea ,0,_ea ));_egfe =_egfe .AppendCurve (NewCubicBezierCurve (0,_ea ,_dfa ,_ea ,_dfb ,_gg ,_dfb ,0));_egfe =_egfe .AppendCurve (NewCubicBezierCurve (_dfb ,0,_dfb ,-_gg ,_dfa ,-_ea ,0,-_ea ));
_egfe =_egfe .AppendCurve (NewCubicBezierCurve (0,-_ea ,-_dfa ,-_ea ,-_dfb ,-_gg ,-_dfb ,0));_egfe =_egfe .Offset (_dfb ,_ea );if _dd .BorderEnabled {_egfe =_egfe .Offset (_dd .BorderWidth /2,_dd .BorderWidth /2);};if _dd .X !=0||_dd .Y !=0{_egfe =_egfe .Offset (_dd .X ,_dd .Y );
};_gdg :=_ba .NewContentCreator ();_gdg .Add_q ();if _dd .FillEnabled {_gdg .SetNonStrokingColor (_dd .FillColor );};if _dd .BorderEnabled {_gdg .SetStrokingColor (_dd .BorderColor );_gdg .Add_w (_dd .BorderWidth );};if len (gsName )> 1{_gdg .Add_gs (_fa .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_egfe ,_gdg );_gdg .Add_h ();if _dd .FillEnabled &&_dd .BorderEnabled {_gdg .Add_B ();}else if _dd .FillEnabled {_gdg .Add_f ();}else if _dd .BorderEnabled {_gdg .Add_S ();};_gdg .Add_Q ();_cfe :=_egfe .GetBoundingBox ();if _dd .BorderEnabled {_cfe .Height +=_dd .BorderWidth ;
_cfe .Width +=_dd .BorderWidth ;_cfe .X -=_dd .BorderWidth /2;_cfe .Y -=_dd .BorderWidth /2;};return _gdg .Bytes (),_cfe .ToPdfRectangle (),nil ;};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{

// Position and size properties.
X float64 ;Y float64 ;Width float64 ;Height float64 ;

// Fill properties.
FillEnabled bool ;FillColor _a .PdfColor ;

// Border properties.
BorderEnabled bool ;BorderColor _a .PdfColor ;BorderWidth float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;

// Shape opacity (0-1 interval).
Opacity float64 ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _a .PdfColor ;Opacity float64 ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_bb Path )RemovePoint (number int )Path {if number < 1||number > len (_bb .Points ){return _bb ;};_gd :=number -1;_bb .Points =append (_bb .Points [:_gd ],_bb .Points [_gd +1:]...);return _bb ;};

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_edf :=Vector {};_edf .Dx =b .X -a .X ;_edf .Dy =b .Y -a .Y ;return _edf ;};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// AddVector adds vector to a point.
func (_ge Point )AddVector (v Vector )Point {_ge .X +=v .Dx ;_ge .Y +=v .Dy ;return _ge };

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_gbd Path )GetPointNumber (number int )Point {if number < 1||number > len (_gbd .Points ){return Point {};};return _gbd .Points [number -1];};func (_acd Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_acd .X ,_acd .Y );
};

// Offset shifts the Bezier path with the specified offsets.
func (_fdf CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _da ,_bd :=range _fdf .Curves {_fdf .Curves [_da ]=_bd .AddOffsetXY (offX ,offY );};return _fdf ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_ad :=CubicBezierCurve {};_ad .P0 =NewPoint (x0 ,y0 );_ad .P1 =NewPoint (x1 ,y1 );_ad .P2 =NewPoint (x2 ,y2 );_ad .P3 =NewPoint (x3 ,y3 );return _ad ;};

// Length returns the number of points in the path.
func (_fda Path )Length ()int {return len (_fda .Points )};

// AppendCurve appends the specified Bezier curve to the path.
func (_cc CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_cc .Curves =append (_cc .Curves ,curve );return _cc ;};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_dc Line )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_fdg ,_gcf :=_dc .X1 ,_dc .X2 ;_gee ,_gba :=_dc .Y1 ,_dc .Y2 ;_dgg :=_gba -_gee ;_dec :=_gcf -_fdg ;_ddc :=_b .Atan2 (_dgg ,_dec );L :=_b .Sqrt (_b .Pow (_dec ,2.0)+_b .Pow (_dgg ,2.0));
_abe :=_dc .LineWidth ;_abg :=_b .Pi ;_eda :=1.0;if _dec < 0{_eda *=-1.0;};if _dgg < 0{_eda *=-1.0;};VsX :=_eda *(-_abe /2*_b .Cos (_ddc +_abg /2));VsY :=_eda *(-_abe /2*_b .Sin (_ddc +_abg /2)+_abe *_b .Sin (_ddc +_abg /2));V1X :=VsX +_abe /2*_b .Cos (_ddc +_abg /2);
V1Y :=VsY +_abe /2*_b .Sin (_ddc +_abg /2);V2X :=VsX +_abe /2*_b .Cos (_ddc +_abg /2)+L *_b .Cos (_ddc );V2Y :=VsY +_abe /2*_b .Sin (_ddc +_abg /2)+L *_b .Sin (_ddc );V3X :=VsX +_abe /2*_b .Cos (_ddc +_abg /2)+L *_b .Cos (_ddc )+_abe *_b .Cos (_ddc -_abg /2);
V3Y :=VsY +_abe /2*_b .Sin (_ddc +_abg /2)+L *_b .Sin (_ddc )+_abe *_b .Sin (_ddc -_abg /2);V4X :=VsX +_abe /2*_b .Cos (_ddc -_abg /2);V4Y :=VsY +_abe /2*_b .Sin (_ddc -_abg /2);_db :=NewPath ();_db =_db .AppendPoint (NewPoint (V1X ,V1Y ));_db =_db .AppendPoint (NewPoint (V2X ,V2Y ));
_db =_db .AppendPoint (NewPoint (V3X ,V3Y ));_db =_db .AppendPoint (NewPoint (V4X ,V4Y ));_fac :=_dc .LineEndingStyle1 ;_gdb :=_dc .LineEndingStyle2 ;_faca :=3*_abe ;_gef :=3*_abe ;_fca :=(_gef -_abe )/2;if _gdb ==LineEndingStyleArrow {_egg :=_db .GetPointNumber (2);
_ccbf :=NewVectorPolar (_faca ,_ddc +_abg );_gec :=_egg .AddVector (_ccbf );_agb :=NewVectorPolar (_gef /2,_ddc +_abg /2);_ca :=NewVectorPolar (_faca ,_ddc );_gge :=NewVectorPolar (_fca ,_ddc +_abg /2);_cca :=_gec .AddVector (_gge );_cad :=_ca .Add (_agb .Flip ());
_agd :=_cca .AddVector (_cad );_dcb :=_agb .Scale (2).Flip ().Add (_cad .Flip ());_fce :=_agd .AddVector (_dcb );_gcc :=_gec .AddVector (NewVectorPolar (_abe ,_ddc -_abg /2));_cab :=NewPath ();_cab =_cab .AppendPoint (_db .GetPointNumber (1));_cab =_cab .AppendPoint (_gec );
_cab =_cab .AppendPoint (_cca );_cab =_cab .AppendPoint (_agd );_cab =_cab .AppendPoint (_fce );_cab =_cab .AppendPoint (_gcc );_cab =_cab .AppendPoint (_db .GetPointNumber (4));_db =_cab ;};if _fac ==LineEndingStyleArrow {_bea :=_db .GetPointNumber (1);
_fbd :=_db .GetPointNumber (_db .Length ());_cgg :=NewVectorPolar (_abe /2,_ddc +_abg +_abg /2);_bf :=_bea .AddVector (_cgg );_ffe :=NewVectorPolar (_faca ,_ddc ).Add (NewVectorPolar (_gef /2,_ddc +_abg /2));_egd :=_bf .AddVector (_ffe );_def :=NewVectorPolar (_fca ,_ddc -_abg /2);
_bgg :=_egd .AddVector (_def );_cb :=NewVectorPolar (_faca ,_ddc );_dfg :=_fbd .AddVector (_cb );_dega :=NewVectorPolar (_fca ,_ddc +_abg +_abg /2);_fdfe :=_dfg .AddVector (_dega );_dcg :=_bf ;_dea :=NewPath ();_dea =_dea .AppendPoint (_bf );_dea =_dea .AppendPoint (_egd );
_dea =_dea .AppendPoint (_bgg );for _ ,_cgd :=range _db .Points [1:len (_db .Points )-1]{_dea =_dea .AppendPoint (_cgd );};_dea =_dea .AppendPoint (_dfg );_dea =_dea .AppendPoint (_fdfe );_dea =_dea .AppendPoint (_dcg );_db =_dea ;};_bc :=_ba .NewContentCreator ();
_bc .Add_q ().SetNonStrokingColor (_dc .LineColor );if len (gsName )> 1{_bc .Add_gs (_fa .PdfObjectName (gsName ));};_db =_db .Offset (_dc .X1 ,_dc .Y1 );_cd :=_db .GetBoundingBox ();DrawPathWithCreator (_db ,_bc );if _dc .LineStyle ==LineStyleDashed {_bc .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_bc .Add_f ().Add_Q ();};return _bc .Bytes (),_cd .ToPdfRectangle (),nil ;};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_egeg Point )Add (dx ,dy float64 )Point {_egeg .X +=dx ;_egeg .Y +=dy ;return _egeg };

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// GetBoundingBox returns the bounding box of the path.
func (_ebe Path )GetBoundingBox ()BoundingBox {_be :=BoundingBox {};_bg :=0.0;_cg :=0.0;_df :=0.0;_baf :=0.0;for _fdc ,_aae :=range _ebe .Points {if _fdc ==0{_bg =_aae .X ;_cg =_aae .X ;_df =_aae .Y ;_baf =_aae .Y ;continue ;};if _aae .X < _bg {_bg =_aae .X ;
};if _aae .X > _cg {_cg =_aae .X ;};if _aae .Y < _df {_df =_aae .Y ;};if _aae .Y > _baf {_baf =_aae .Y ;};};_be .X =_bg ;_be .Y =_df ;_be .Width =_cg -_bg ;_be .Height =_baf -_df ;return _be ;};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_fbc Point )Rotate (theta float64 )Point {_dg :=_cf .NewPoint (_fbc .X ,_fbc .Y ).Rotate (theta );return NewPoint (_dg .X ,_dg .Y );};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_bab Vector )GetPolarAngle ()float64 {return _b .Atan2 (_bab .Dy ,_bab .Dx )};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderColor _a .PdfColor ;BorderWidth float64 ;};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_fbbf Rectangle )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_fbbf .X ,Lly :_fbbf .Y ,Urx :_fbbf .X +_fbbf .Width ,Ury :_fbbf .Y +_fbbf .Height };};

// Copy returns a clone of the Bezier path.
func (_fb CubicBezierPath )Copy ()CubicBezierPath {_ege :=CubicBezierPath {};_ege .Curves =append (_ege .Curves ,_fb .Curves ...);return _ege ;};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_gc PolyBezierCurve )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _gc .BorderColor ==nil {_gc .BorderColor =_a .NewPdfColorDeviceRGB (0,0,0);};_fc :=NewCubicBezierPath ();for _ ,_efc :=range _gc .Curves {_fc =_fc .AppendCurve (_efc );
};_fcc :=_ba .NewContentCreator ();_fcc .Add_q ();_gc .FillEnabled =_gc .FillEnabled &&_gc .FillColor !=nil ;if _gc .FillEnabled {_fcc .SetNonStrokingColor (_gc .FillColor );};_fcc .SetStrokingColor (_gc .BorderColor );_fcc .Add_w (_gc .BorderWidth );if len (gsName )> 1{_fcc .Add_gs (_fa .PdfObjectName (gsName ));
};for _gbb ,_ccb :=range _fc .Curves {if _gbb ==0{_fcc .Add_m (_ccb .P0 .X ,_ccb .P0 .Y );}else {_fcc .Add_l (_ccb .P0 .X ,_ccb .P0 .Y );};_fcc .Add_c (_ccb .P1 .X ,_ccb .P1 .Y ,_ccb .P2 .X ,_ccb .P2 .Y ,_ccb .P3 .X ,_ccb .P3 .Y );};if _gc .FillEnabled {_fcc .Add_h ();
_fcc .Add_B ();}else {_fcc .Add_S ();};_fcc .Add_Q ();return _fcc .Bytes (),_fc .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Flip changes the sign of the vector: -vector.
func (_abb Vector )Flip ()Vector {_fbbc :=_abb .Magnitude ();_dcbe :=_abb .GetPolarAngle ();_abb .Dx =_fbbc *_b .Cos (_dcbe +_b .Pi );_abb .Dy =_fbbc *_b .Sin (_dcbe +_b .Pi );return _abb ;};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;
LineEndingStyleButt LineEndingStyle =2;);

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_d :=CubicBezierPath {};_d .Curves =[]CubicBezierCurve {};return _d ;};

// FlipY flips the sign of the Dy component of the vector.
func (_fcag Vector )FlipY ()Vector {_fcag .Dy =-_fcag .Dy ;return _fcag };

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _a .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;DashArray []int64 ;DashPhase int64 ;};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _a .PdfColor ;LineWidth float64 ;};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_bad BasicLine )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_aac :=NewPath ();_aac =_aac .AppendPoint (NewPoint (_bad .X1 ,_bad .Y1 ));_aac =_aac .AppendPoint (NewPoint (_bad .X2 ,_bad .Y2 ));_dcc :=_ba .NewContentCreator ();_dcc .Add_q ().Add_w (_bad .LineWidth ).SetStrokingColor (_bad .LineColor );
if _bad .LineStyle ==LineStyleDashed {if _bad .DashArray ==nil {_bad .DashArray =[]int64 {1,1};};_dcc .Add_d (_bad .DashArray ,_bad .DashPhase );};if len (gsName )> 1{_dcc .Add_gs (_fa .PdfObjectName (gsName ));};DrawPathWithCreator (_aac ,_dcc );_dcc .Add_S ().Add_Q ();
return _dcc .Bytes (),_aac .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Rotate rotates the vector by the specified angle.
func (_aad Vector )Rotate (phi float64 )Vector {_ddd :=_aad .Magnitude ();_ecg :=_aad .GetPolarAngle ();return NewVectorPolar (_ddd ,_ecg +phi );};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_aa CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_aa .P0 .X +=offX ;_aa .P1 .X +=offX ;_aa .P2 .X +=offX ;_aa .P3 .X +=offX ;_aa .P0 .Y +=offY ;_aa .P1 .Y +=offY ;_aa .P2 .Y +=offY ;_aa .P3 .Y +=offY ;return _aa ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _a .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// FlipX flips the sign of the Dx component of the vector.
func (_bff Vector )FlipX ()Vector {_bff .Dx =-_bff .Dx ;return _bff };

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_geg Polygon )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_ab :=_ba .NewContentCreator ();_ab .Add_q ();_geg .FillEnabled =_geg .FillEnabled &&_geg .FillColor !=nil ;if _geg .FillEnabled {_ab .SetNonStrokingColor (_geg .FillColor );};
_geg .BorderEnabled =_geg .BorderEnabled &&_geg .BorderColor !=nil ;if _geg .BorderEnabled {_ab .SetStrokingColor (_geg .BorderColor );_ab .Add_w (_geg .BorderWidth );};if len (gsName )> 1{_ab .Add_gs (_fa .PdfObjectName (gsName ));};_eae :=NewPath ();
for _ ,_gf :=range _geg .Points {for _bbc ,_egeb :=range _gf {_eae =_eae .AppendPoint (_egeb );if _bbc ==0{_ab .Add_m (_egeb .X ,_egeb .Y );}else {_ab .Add_l (_egeb .X ,_egeb .Y );};};_ab .Add_h ();};if _geg .FillEnabled &&_geg .BorderEnabled {_ab .Add_B ();
}else if _geg .FillEnabled {_ab .Add_f ();}else if _geg .BorderEnabled {_ab .Add_S ();};_ab .Add_Q ();return _ab .Bytes (),_eae .GetBoundingBox ().ToPdfRectangle (),nil ;};const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);

// Scale scales the vector by the specified factor.
func (_ace Vector )Scale (factor float64 )Vector {_gga :=_ace .Magnitude ();_ceb :=_ace .GetPolarAngle ();_ace .Dx =factor *_gga *_b .Cos (_ceb );_ace .Dy =factor *_gga *_b .Sin (_ceb );return _ace ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_cbg Polyline )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _cbg .LineColor ==nil {_cbg .LineColor =_a .NewPdfColorDeviceRGB (0,0,0);};_ggc :=NewPath ();for _ ,_cde :=range _cbg .Points {_ggc =_ggc .AppendPoint (_cde );};_cga :=_ba .NewContentCreator ();
_cga .Add_q ().SetStrokingColor (_cbg .LineColor ).Add_w (_cbg .LineWidth );if len (gsName )> 1{_cga .Add_gs (_fa .PdfObjectName (gsName ));};DrawPathWithCreator (_ggc ,_cga );_cga .Add_S ();_cga .Add_Q ();return _cga .Bytes (),_ggc .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _a .PdfColor ;FillEnabled bool ;FillColor _a .PdfColor ;};

// Draw draws the rectangle. A graphics state can be specified for
// setting additional properties (e.g. opacity). Otherwise pass an empty string
// for the `gsName` parameter. The method returns the content stream as a byte
// array and the bounding box of the shape.
func (_dff Rectangle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_fe :=_ba .NewContentCreator ();_fe .Add_q ();if _dff .FillEnabled {_fe .SetNonStrokingColor (_dff .FillColor );};if _dff .BorderEnabled {_fe .SetStrokingColor (_dff .BorderColor );
_fe .Add_w (_dff .BorderWidth );};if len (gsName )> 1{_fe .Add_gs (_fa .PdfObjectName (gsName ));};var (_bba ,_dfag =_dff .X ,_dff .Y ;_bbe ,_deb =_dff .Width ,_dff .Height ;_eaeb =_b .Abs (_dff .BorderRadiusTopLeft );_ecba =_b .Abs (_dff .BorderRadiusTopRight );
_ecf =_b .Abs (_dff .BorderRadiusBottomLeft );_bec =_b .Abs (_dff .BorderRadiusBottomRight );_deg =0.4477;);_fed :=Path {Points :[]Point {{X :_bba +_bbe -_bec ,Y :_dfag },{X :_bba +_bbe ,Y :_dfag +_deb -_ecba },{X :_bba +_eaeb ,Y :_dfag +_deb },{X :_bba ,Y :_dfag +_ecf }}};
_fdcc :=[][7]float64 {{_bec ,_bba +_bbe -_bec *_deg ,_dfag ,_bba +_bbe ,_dfag +_bec *_deg ,_bba +_bbe ,_dfag +_bec },{_ecba ,_bba +_bbe ,_dfag +_deb -_ecba *_deg ,_bba +_bbe -_ecba *_deg ,_dfag +_deb ,_bba +_bbe -_ecba ,_dfag +_deb },{_eaeb ,_bba +_eaeb *_deg ,_dfag +_deb ,_bba ,_dfag +_deb -_eaeb *_deg ,_bba ,_dfag +_deb -_eaeb },{_ecf ,_bba ,_dfag +_ecf *_deg ,_bba +_ecf *_deg ,_dfag ,_bba +_ecf ,_dfag }};
_fe .Add_m (_bba +_ecf ,_dfag );for _gbbc :=0;_gbbc < 4;_gbbc ++{_ag :=_fed .Points [_gbbc ];_fe .Add_l (_ag .X ,_ag .Y );_ecbb :=_fdcc [_gbbc ];if _ed :=_ecbb [0];_ed !=0{_fe .Add_c (_ecbb [1],_ecbb [2],_ecbb [3],_ecbb [4],_ecbb [5],_ecbb [6]);};};_fe .Add_h ();
if _dff .FillEnabled &&_dff .BorderEnabled {_fe .Add_B ();}else if _dff .FillEnabled {_fe .Add_f ();}else if _dff .BorderEnabled {_fe .Add_S ();};_fe .Add_Q ();return _fe .Bytes (),_fed .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderColor _a .PdfColor ;BorderWidth float64 ;};

// Copy returns a clone of the path.
func (_add Path )Copy ()Path {_bbg :=Path {};_bbg .Points =append (_bbg .Points ,_add .Points ...);return _bbg ;};

// GetBounds returns the bounding box of the Bezier curve.
func (_e CubicBezierCurve )GetBounds ()_a .PdfRectangle {_fd :=_e .P0 .X ;_cfd :=_e .P0 .X ;_eg :=_e .P0 .Y ;_ef :=_e .P0 .Y ;for _ee :=0.0;_ee <=1.0;_ee +=0.001{Rx :=_e .P0 .X *_b .Pow (1-_ee ,3)+_e .P1 .X *3*_ee *_b .Pow (1-_ee ,2)+_e .P2 .X *3*_b .Pow (_ee ,2)*(1-_ee )+_e .P3 .X *_b .Pow (_ee ,3);
Ry :=_e .P0 .Y *_b .Pow (1-_ee ,3)+_e .P1 .Y *3*_ee *_b .Pow (1-_ee ,2)+_e .P2 .Y *3*_b .Pow (_ee ,2)*(1-_ee )+_e .P3 .Y *_b .Pow (_ee ,3);if Rx < _fd {_fd =Rx ;};if Rx > _cfd {_cfd =Rx ;};if Ry < _eg {_eg =Ry ;};if Ry > _ef {_ef =Ry ;};};_g :=_a .PdfRectangle {};
_g .Llx =_fd ;_g .Lly =_eg ;_g .Urx =_cfd ;_g .Ury =_ef ;return _g ;};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_cff :=Vector {};_cff .Dx =dx ;_cff .Dy =dy ;return _cff };

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_gdge CurvePolygon )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_fdfb :=_ba .NewContentCreator ();_fdfb .Add_q ();_gdge .FillEnabled =_gdge .FillEnabled &&_gdge .FillColor !=nil ;if _gdge .FillEnabled {_fdfb .SetNonStrokingColor (_gdge .FillColor );
};_gdge .BorderEnabled =_gdge .BorderEnabled &&_gdge .BorderColor !=nil ;if _gdge .BorderEnabled {_fdfb .SetStrokingColor (_gdge .BorderColor );_fdfb .Add_w (_gdge .BorderWidth );};if len (gsName )> 1{_fdfb .Add_gs (_fa .PdfObjectName (gsName ));};_aba :=NewCubicBezierPath ();
for _ ,_afe :=range _gdge .Rings {for _ccg ,_bgc :=range _afe {if _ccg ==0{_fdfb .Add_m (_bgc .P0 .X ,_bgc .P0 .Y );}else {_fdfb .Add_l (_bgc .P0 .X ,_bgc .P0 .Y );};_fdfb .Add_c (_bgc .P1 .X ,_bgc .P1 .Y ,_bgc .P2 .X ,_bgc .P2 .Y ,_bgc .P3 .X ,_bgc .P3 .Y );
_aba =_aba .AppendCurve (_bgc );};_fdfb .Add_h ();};if _gdge .FillEnabled &&_gdge .BorderEnabled {_fdfb .Add_B ();}else if _gdge .FillEnabled {_fdfb .Add_f ();}else if _gdge .BorderEnabled {_fdfb .Add_S ();};_fdfb .Add_Q ();return _fdfb .Bytes (),_aba .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_ba .ContentCreator ){for _aea ,_bgb :=range bpath .Curves {if _aea ==0{creator .Add_m (_bgb .P0 .X ,_bgb .P0 .Y );};creator .Add_c (_bgb .P1 .X ,_bgb .P1 .Y ,_bgb .P2 .X ,_bgb .P2 .Y ,_bgb .P3 .X ,_bgb .P3 .Y );
};};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_fbb CubicBezierPath )GetBoundingBox ()Rectangle {_ga :=Rectangle {};_gb :=0.0;_fbe :=0.0;_eb :=0.0;_de :=0.0;for _aaf ,_ae :=range _fbb .Curves {_ce :=_ae .GetBounds ();if _aaf ==0{_gb =_ce .Llx ;_fbe =_ce .Urx ;_eb =_ce .Lly ;_de =_ce .Ury ;continue ;
};if _ce .Llx < _gb {_gb =_ce .Llx ;};if _ce .Urx > _fbe {_fbe =_ce .Urx ;};if _ce .Lly < _eb {_eb =_ce .Lly ;};if _ce .Ury > _de {_de =_ce .Ury ;};};_ga .X =_gb ;_ga .Y =_eb ;_ga .Width =_fbe -_gb ;_ga .Height =_de -_eb ;return _ga ;};

// Offset shifts the path with the specified offsets.
func (_ac Path )Offset (offX ,offY float64 )Path {for _bda ,_egf :=range _ac .Points {_ac .Points [_bda ]=_egf .Add (offX ,offY );};return _ac ;};

// AppendPoint adds the specified point to the path.
func (_ec Path )AppendPoint (point Point )Path {_ec .Points =append (_ec .Points ,point );return _ec };

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_bag :=Vector {};_bag .Dx =length *_b .Cos (theta );_bag .Dy =length *_b .Sin (theta );return _bag ;};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// Add adds the specified vector to the current one and returns the result.
func (_gdga Vector )Add (other Vector )Vector {_gdga .Dx +=other .Dx ;_gdga .Dy +=other .Dy ;return _gdga ;};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_ba .ContentCreator ){for _efd ,_bfa :=range path .Points {if _efd ==0{creator .Add_m (_bfa .X ,_bfa .Y );}else {creator .Add_l (_bfa .X ,_bfa .Y );};};};