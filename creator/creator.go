//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_b "bytes";_f "errors";_bb "fmt";_cd "github.com/unidoc/unipdf/v3/common";_bd "github.com/unidoc/unipdf/v3/contentstream";_ba "github.com/unidoc/unipdf/v3/contentstream/draw";_db "github.com/unidoc/unipdf/v3/core";_bg "github.com/unidoc/unipdf/v3/internal/license";
_dcb "github.com/unidoc/unipdf/v3/internal/transform";_a "github.com/unidoc/unipdf/v3/model";_c "image";_g "io";_ec "math";_e "os";_dg "sort";_ff "strconv";_ecg "strings";_dc "unicode";);

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_ffcf *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _cfaec (number ,title ,page ,level ,style );};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_edgg *TOCLine )SetLevelOffset (levelOffset float64 ){_edgg ._egag =levelOffset ;_edgg ._gcgg ._bacc .Left =_edgg ._egcgf +float64 (_edgg ._bdbdd -1)*_edgg ._egag ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_fbfd *Creator )MoveRight (dx float64 ){_fbfd ._aggdc .X +=dx };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// Width returns the width of the Paragraph.
func (_dfdb *Paragraph )Width ()float64 {if _dfdb ._dfed &&int (_dfdb ._agab )> 0{return _dfdb ._agab ;};return _dfdb .getTextWidth ()/1000.0;};

// SetNumber sets the number of the invoice.
func (_gbdfg *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gbdfg ._dbdg [1].Value =number ;return _gbdfg ._dbdg [0],_gbdfg ._dbdg [1];};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_agec *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_agec ._fcb =valign };func (_bba *Block )translate (_gc ,_aeg float64 ){_eed :=_bd .NewContentCreator ().Translate (_gc ,-_aeg ).Operations ();*_bba ._ef =append (*_eed ,*_bba ._ef ...);
_bba ._ef .WrapIfNeeded ();};func (_fg *Block )addContents (_ega *_bd .ContentStreamOperations ){_fg ._ef .WrapIfNeeded ();_ega .WrapIfNeeded ();*_fg ._ef =append (*_fg ._ef ,*_ega ...);};

// SetTitle sets the title of the invoice.
func (_eeef *Invoice )SetTitle (title string ){_eeef ._cagg =title };

// SetAngle sets Image rotation angle in degrees.
func (_baag *Image )SetAngle (angle float64 ){_baag ._aedf =angle };

// SetFillOpacity sets the fill opacity.
func (_abfe *Polygon )SetFillOpacity (opacity float64 ){_abfe ._ebfc =opacity };

// Context returns the current drawing context.
func (_dcbc *Creator )Context ()DrawContext {return _dcbc ._aggdc };func _egef (_eacg string ,_gbcae ,_egcfa TextStyle )*TOC {_ceac :=_egcfa ;_ceac .FontSize =14;_afagf :=_defdf (_ceac );_afagf .SetEnableWrap (true );_afagf .SetTextAlignment (TextAlignmentLeft );
_afagf .SetMargins (0,0,0,5);_gcacd :=_afagf .Append (_eacg );_gcacd .Style =_ceac ;return &TOC {_gfgf :_afagf ,_adge :[]*TOCLine {},_bgcdd :_gbcae ,_gfcf :_gbcae ,_gccf :_gbcae ,_efgcd :_gbcae ,_cgfec :"\u002e",_abcc :10,_eecc :Margins {0,0,2,2},_efafa :PositionRelative ,_ggbg :_gbcae ,_egdd :true };
};func _cgcfe (_affd ,_befa TextStyle )*Invoice {_adfb :=&Invoice {_cagg :"\u0049N\u0056\u004f\u0049\u0043\u0045",_gfee :"\u002c\u0020",_fbdc :_affd ,_abeg :_befa };_adfb ._aegd =&InvoiceAddress {Separator :_adfb ._gfee };_adfb ._dbgg =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_adfb ._gfee };
_ffaf :=ColorRGBFrom8bit (245,245,245);_dgec :=ColorRGBFrom8bit (155,155,155);_adfb ._cead =_befa ;_adfb ._cead .Color =_dgec ;_adfb ._cead .FontSize =20;_adfb ._dfcf =_affd ;_adfb ._fgge =_befa ;_adfb ._ddabf =_affd ;_adfb ._ddbfc =_befa ;_adfb ._gdaf =_adfb .NewCellProps ();
_adfb ._gdaf .BackgroundColor =_ffaf ;_adfb ._gdaf .TextStyle =_befa ;_adfb ._agbg =_adfb .NewCellProps ();_adfb ._agbg .TextStyle =_befa ;_adfb ._agbg .BackgroundColor =_ffaf ;_adfb ._agbg .BorderColor =_ffaf ;_adfb ._aeb =_adfb .NewCellProps ();_adfb ._aeb .BorderColor =_ffaf ;
_adfb ._aeb .BorderSides =[]CellBorderSide {CellBorderSideBottom };_adfb ._aeb .Alignment =CellHorizontalAlignmentRight ;_adfb ._gfac =_adfb .NewCellProps ();_adfb ._gfac .Alignment =CellHorizontalAlignmentRight ;_adfb ._dbdg =[2]*InvoiceCell {_adfb .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_adfb ._gdaf ),_adfb .newCell ("",_adfb ._gdaf )};
_adfb ._ddca =[2]*InvoiceCell {_adfb .newCell ("\u0044\u0061\u0074\u0065",_adfb ._gdaf ),_adfb .newCell ("",_adfb ._gdaf )};_adfb ._dafaa =[2]*InvoiceCell {_adfb .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_adfb ._gdaf ),_adfb .newCell ("",_adfb ._gdaf )};
_adfb ._beag =[2]*InvoiceCell {_adfb .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_adfb ._gfac ),_adfb .newCell ("",_adfb ._gfac )};_ggfd :=_adfb ._gfac ;_ggfd .TextStyle =_befa ;_ggfd .BackgroundColor =_ffaf ;_ggfd .BorderColor =_ffaf ;
_adfb ._bfeb =[2]*InvoiceCell {_adfb .newCell ("\u0054\u006f\u0074a\u006c",_ggfd ),_adfb .newCell ("",_ggfd )};_adfb ._bced =[2]string {"\u004e\u006f\u0074e\u0073",""};_adfb ._dgfg =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_adfb ._afda =[]*InvoiceCell {_adfb .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_adfb .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_adfb .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_adfb .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _adfb ;};

// GetCoords returns coordinates of border.
func (_cgac *border )GetCoords ()(float64 ,float64 ){return _cgac ._ddc ,_cgac ._ecdg };

// AddLine adds a new line with the provided style to the table of contents.
func (_gdbb *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_gdbb ._adge =append (_gdbb ._adge ,line );return line ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_deacd *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_egfac :=&_deacd ._gcgg ._bacc ;return _deacd ._egcgf ,_egfac .Right ,_egfac .Top ,_egfac .Bottom ;};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_eaec *Creator )SetForms (form *_a .PdfAcroForm )error {_eaec ._bea =form ;return nil };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_dgcba *Invoice )TotalLines ()[][2]*InvoiceCell {_gbgd :=[][2]*InvoiceCell {_dgcba ._beag };_gbgd =append (_gbgd ,_dgcba ._dcbe ...);return append (_gbgd ,_dgcba ._bfeb );};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// CurRow returns the currently active cell's row number.
func (_aaag *Table )CurRow ()int {_caff :=(_aaag ._cgdg -1)/_aaag ._ddea +1;return _caff };func (_ebfd *Table )clone ()*Table {_adfc :=*_ebfd ;_adfc ._ebaeg =make ([]float64 ,len (_ebfd ._ebaeg ));copy (_adfc ._ebaeg ,_ebfd ._ebaeg );_adfc ._efbga =make ([]float64 ,len (_ebfd ._efbga ));
copy (_adfc ._efbga ,_ebfd ._efbga );_adfc ._gefca =make ([]*TableCell ,0,len (_ebfd ._gefca ));for _ ,_aagb :=range _ebfd ._gefca {_aecag :=*_aagb ;_aecag ._afdae =&_adfc ;_adfc ._gefca =append (_adfc ._gefca ,&_aecag );};return &_adfc ;};const (CellBorderSideLeft CellBorderSide =iota ;
CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// NewColumn returns a new column for the line items invoice table.
func (_ddfc *Invoice )NewColumn (description string )*InvoiceCell {return _ddfc .newColumn (description ,CellHorizontalAlignmentLeft );};

// Width returns the Block's width.
func (_gea *Block )Width ()float64 {return _gea ._fc };func (_aaeg *Invoice )drawInformation ()*Table {_cffd :=_gadb (2);_efba :=append ([][2]*InvoiceCell {_aaeg ._dbdg ,_aaeg ._ddca ,_aaeg ._dafaa },_aaeg ._bfga ...);for _ ,_becg :=range _efba {_geebf ,_fdcab :=_becg [0],_becg [1];
if _fdcab .Value ==""{continue ;};_ffca :=_cffd .NewCell ();_ffca .SetBackgroundColor (_geebf .BackgroundColor );_aaeg .setCellBorder (_ffca ,_geebf );_ffaag :=_defdf (_geebf .TextStyle );_ffaag .Append (_geebf .Value );_ffaag .SetMargins (0,0,2,1);_ffca .SetContent (_ffaag );
_ffca =_cffd .NewCell ();_ffca .SetBackgroundColor (_fdcab .BackgroundColor );_aaeg .setCellBorder (_ffca ,_fdcab );_ffaag =_defdf (_fdcab .TextStyle );_ffaag .Append (_fdcab .Value );_ffaag .SetMargins (0,0,2,1);_ffca .SetContent (_ffaag );};return _cffd ;
};

// AddTotalLine adds a new line in the invoice totals table.
func (_fbde *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_ecafb :=&InvoiceCell {_fbde ._gfac ,desc };_daed :=&InvoiceCell {_fbde ._gfac ,value };_fbde ._dcbe =append (_fbde ._dcbe ,[2]*InvoiceCell {_ecafb ,_daed });return _ecafb ,_daed ;
};func (_bgaa *Invoice )generateLineBlocks (_ccdcb DrawContext )([]*Block ,DrawContext ,error ){_affg :=_gadb (len (_bgaa ._afda ));_affg .SetMargins (0,0,25,0);for _ ,_bfff :=range _bgaa ._afda {_ggcd :=_defdf (_bfff .TextStyle );_ggcd .SetMargins (0,0,1,0);
_ggcd .Append (_bfff .Value );_dbdc :=_affg .NewCell ();_dbdc .SetHorizontalAlignment (_bfff .Alignment );_dbdc .SetBackgroundColor (_bfff .BackgroundColor );_bgaa .setCellBorder (_dbdc ,_bfff );_dbdc .SetContent (_ggcd );};for _ ,_begda :=range _bgaa ._acdd {for _ ,_agbc :=range _begda {_geac :=_defdf (_agbc .TextStyle );
_geac .SetMargins (0,0,3,2);_geac .Append (_agbc .Value );_eada :=_affg .NewCell ();_eada .SetHorizontalAlignment (_agbc .Alignment );_eada .SetBackgroundColor (_agbc .BackgroundColor );_bgaa .setCellBorder (_eada ,_agbc );_eada .SetContent (_geac );};
};return _affg .GeneratePageBlocks (_ccdcb );};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_cdc *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdfeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eea ,_ggba :=_fdfeg .setOpacity (_cdc ._bag ,_cdc ._eegc );if _ggba !=nil {return nil ,ctx ,_ggba ;};_abed :=_cdc ._dagf ;
_abed .FillEnabled =_abed .FillColor !=nil ;_abed .BorderEnabled =_abed .BorderColor !=nil &&_abed .BorderWidth > 0;var (_edbd =ctx .PageHeight ;_bbab =_abed .Rings ;_fddf =make ([][]_ba .CubicBezierCurve ,0,len (_abed .Rings )););for _ ,_dfeb :=range _bbab {_bfe :=make ([]_ba .CubicBezierCurve ,0,len (_dfeb ));
for _ ,_dcbad :=range _dfeb {_cbea :=_dcbad ;_cbea .P0 .Y =_edbd -_cbea .P0 .Y ;_cbea .P1 .Y =_edbd -_cbea .P1 .Y ;_cbea .P2 .Y =_edbd -_cbea .P2 .Y ;_cbea .P3 .Y =_edbd -_cbea .P3 .Y ;_bfe =append (_bfe ,_cbea );};_fddf =append (_fddf ,_bfe );};_abed .Rings =_fddf ;
defer func (){_abed .Rings =_bbab }();_bbef ,_ ,_ggba :=_abed .Draw (_eea );if _ggba !=nil {return nil ,ctx ,_ggba ;};if _ggba =_fdfeg .addContentsByString (string (_bbef ));_ggba !=nil {return nil ,ctx ,_ggba ;};return []*Block {_fdfeg },ctx ,nil ;};

// Add adds a new Drawable to the chapter.
func (_gfge *Chapter )Add (d Drawable )error {if Drawable (_gfge )==d {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _fbcf :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_gfge ._cgba =append (_gfge ._cgba ,d );case containerDrawable :_afga ,_ebcc :=_fbcf .ContainerComponent (_gfge );if _ebcc !=nil {return _ebcc ;
};_gfge ._cgba =append (_gfge ._cgba ,_afga );default:_cd .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// SkipRows skips over a specified number of rows in the table.
func (_aagg *Table )SkipRows (num int ){_bcbde :=num *_aagg ._ddea -1;if _bcbde < 0{_cd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_aagg ._cgdg +=_bcbde ;};

// Width returns the width of the Paragraph.
func (_cdaaf *StyledParagraph )Width ()float64 {if _cdaaf ._deac &&int (_cdaaf ._afgd )> 0{return _cdaaf ._afgd ;};return _cdaaf .getTextWidth ()/1000.0;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_gf *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ag :=_bd .NewContentCreator ();_cge ,_def :=_gf .Width (),_gf .Height ();if _gf ._ce .IsRelative (){_ag .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_def );}else {_ag .Translate (_gf ._ca ,ctx .PageHeight -_gf ._ac -_def );
};_eca :=_def ;if _gf ._cag !=0{_ag .Translate (_cge /2,_def /2);_ag .RotateDeg (_gf ._cag );_ag .Translate (-_cge /2,-_def /2);_ ,_eca =_gf .RotatedSize ();};if _gf ._ce .IsRelative (){ctx .Y +=_eca ;};_aec :=_gf .duplicate ();_eda :=append (*_ag .Operations (),*_aec ._ef ...);
_eda .WrapIfNeeded ();_aec ._ef =&_eda ;return []*Block {_aec },ctx ,nil ;};func (_ecfbg *StyledParagraph )getTextLineWidth (_cdae []*TextChunk )float64 {var _edfd float64 ;_fgga :=len (_cdae );for _eeedca ,_ecgea :=range _cdae {_bdbd :=&_ecgea .Style ;
_aeaef :=len (_ecgea .Text );for _begfb ,_aebc :=range _ecgea .Text {if _aebc =='\u000A'{continue ;};_gddf ,_abad :=_bdbd .Font .GetRuneMetrics (_aebc );if !_abad {_cd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_aebc );
return -1;};_edfd +=_bdbd .FontSize *_gddf .Wx ;if _aebc !=' '&&(_eeedca !=_fgga -1||_begfb !=_aeaef -1){_edfd +=_bdbd .CharSpacing *1000.0;};};};return _edfd ;};func (_dab cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_cdfd :=_dab ._ecfab ;return 1-(_dab ._bge *(1-_cdfd )+_cdfd ),1-(_dab ._gbdf *(1-_cdfd )+_cdfd ),1-(_dab ._gec *(1-_cdfd )+_cdfd );
};

// Add adds a new line with the default style to the table of contents.
func (_ddgf *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_bagc :=_ddgf .AddLine (_cfaec (TextChunk {Text :number ,Style :_ddgf ._bgcdd },TextChunk {Text :title ,Style :_ddgf ._gfcf },TextChunk {Text :page ,Style :_ddgf ._efgcd },level ,_ddgf ._ggbg ));
if _bagc ==nil {return nil ;};_abcf :=&_ddgf ._eecc ;_bagc .SetMargins (_abcf .Left ,_abcf .Right ,_abcf .Top ,_abcf .Bottom );_bagc .SetLevelOffset (_ddgf ._abcc );_bagc .Separator .Text =_ddgf ._cgfec ;_bagc .Separator .Style =_ddgf ._gccf ;return _bagc ;
};func _eeeeg (_aeeea *_a .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_aeeea ,FontSize :10,OutlineSize :1,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};};

// NewDivision returns a new Division container component.
func (_ggdee *Creator )NewDivision ()*Division {return _gggb ()};

// SetAngle sets the rotation angle of the text.
func (_fagb *StyledParagraph )SetAngle (angle float64 ){_fagb ._gfabc =angle };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_bfabd *Table )NewCell ()*TableCell {return _bfabd .newCell (1)};func _degf (_aaff ,_agagf ,_dedcg float64 )(_gddae ,_effb ,_bdfg ,_accdc float64 ){if _dedcg ==0{return 0,0,_aaff ,_agagf ;};_cdbeb :=_ba .Path {Points :[]_ba .Point {_ba .NewPoint (0,0).Rotate (_dedcg ),_ba .NewPoint (_aaff ,0).Rotate (_dedcg ),_ba .NewPoint (0,_agagf ).Rotate (_dedcg ),_ba .NewPoint (_aaff ,_agagf ).Rotate (_dedcg )}}.GetBoundingBox ();
return _cdbeb .X ,_cdbeb .Y ,_cdbeb .Width ,_cdbeb .Height ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_gcbe *Image )SetMargins (left ,right ,top ,bottom float64 ){_gcbe ._cagbc .Left =left ;_gcbe ._cagbc .Right =right ;_gcbe ._cagbc .Top =top ;_gcbe ._cagbc .Bottom =bottom ;};

// AddLine appends a new line to the invoice line items table.
func (_ccg *Invoice )AddLine (values ...string )[]*InvoiceCell {_aeea :=len (_ccg ._afda );var _agef []*InvoiceCell ;for _agbd ,_cff :=range values {_gagdg :=_ccg .newCell (_cff ,_ccg ._aeb );if _agbd < _aeea {_gagdg .Alignment =_ccg ._afda [_agbd ].Alignment ;
};_agef =append (_agef ,_gagdg );};_ccg ._acdd =append (_ccg ._acdd ,_agef );return _agef ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_fcgf *Paragraph )SetColor (col Color ){_fcgf ._bcdg =col };

// SetFont sets the Paragraph's font.
func (_cfea *Paragraph )SetFont (font *_a .PdfFont ){_cfea ._deed =font };func _bdce ()*PageBreak {return &PageBreak {}};

// CreateFrontPage sets a function to generate a front Page.
func (_aege *Creator )CreateFrontPage (genFrontPageFunc func (_gfd FrontpageFunctionArgs )){_aege ._cgge =genFrontPageFunc ;};func _eggc (_cbbd *_a .PdfAnnotation )*_a .PdfAnnotation {if _cbbd ==nil {return nil ;};var _geg *_a .PdfAnnotation ;switch _ceffa :=_cbbd .GetContext ().(type ){case *_a .PdfAnnotationLink :if _bdde :=_dacge (_ceffa );
_bdde !=nil {_geg =_bdde .PdfAnnotation ;};};return _geg ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_gfec *Creator )NewPolyBezierCurve (curves []_ba .CubicBezierCurve )*PolyBezierCurve {return _fgbdf (curves );};func (_abcde *TableCell )height (_dfbd float64 )float64 {var _cfbge float64 ;switch _bgef :=_abcde ._efcga .(type ){case *Paragraph :if _bgef ._dfed {_bgef .SetWidth (_dfbd -_abcde ._ggabd -_bgef ._fcfba .Left -_bgef ._fcfba .Right );
};_cfbge =_bgef .Height ()+_bgef ._fcfba .Top +_bgef ._fcfba .Bottom +0.5*_bgef ._aabf *_bgef ._eag ;case *StyledParagraph :if _bgef ._deac {_bgef .SetWidth (_dfbd -_abcde ._ggabd -_bgef ._bacc .Left -_bgef ._bacc .Right );};_cfbge =_bgef .Height ()+_bgef ._bacc .Top +_bgef ._bacc .Bottom +0.5*_bgef .getTextHeight ();
case *Image :_cfbge =_bgef .Height ()+_bgef ._cagbc .Top +_bgef ._cagbc .Bottom ;case *Table :_cfbge =_bgef .Height ()+_bgef ._dbbb .Top +_bgef ._dbbb .Bottom ;case *List :_cfbge =_bgef .tableHeight (_dfbd -_abcde ._ggabd )+_bgef ._agag .Top +_bgef ._agag .Bottom ;
case *Division :_cfbge =_bgef .ctxHeight (_dfbd -_abcde ._ggabd )+_bgef ._bbeb .Top +_bgef ._bbeb .Bottom ;};return _cfbge ;};

// SetWidth sets line width.
func (_dad *Curve )SetWidth (width float64 ){_dad ._ecec =width };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cggd *Invoice )NoteHeadingStyle ()TextStyle {return _cggd ._ddbfc };

// GeneratePageBlocks generates a page break block.
func (_gbgbf *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbdec :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_abde :=ctx ;_abde .Y =ctx .Margins .Top ;
_abde .X =ctx .Margins .Left ;_abde .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_abde .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_abde ;return _bbdec ,ctx ,nil ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_ebae []*TextChunk ;_feebgf TextStyle ;_fefb TextStyle ;_dgcgg TextAlignment ;_cdagf float64 ;_deac bool ;_afgd float64 ;_aecg bool ;_aeba TextOverflow ;_gfabc float64 ;_bacc Margins ;_dgac Positioning ;_dgcf float64 ;_ebda float64 ;
_befc float64 ;_gcae float64 ;_gffa [][]*TextChunk ;_cfca func (_febg *StyledParagraph ,_fdfa DrawContext );};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_bfc *List )Marker ()*TextChunk {return &_bfc ._fbfe };func _gdgd (_cbfb *Table ,_fefc DrawContext )([]*Block ,DrawContext ,error ){var _gfga []*Block ;_eeca :=NewBlock (_fefc .PageWidth ,_fefc .PageHeight );_fbaab :=_fefc ;if _cbfb ._gfad .IsAbsolute (){_fefc .X =_cbfb ._gdfef ;
_fefc .Y =_cbfb ._fdfac ;}else {_fefc .X +=_cbfb ._dbbb .Left ;_fefc .Y +=_cbfb ._dbbb .Top ;_fefc .Width -=_cbfb ._dbbb .Left +_cbfb ._dbbb .Right ;_fefc .Height -=_cbfb ._dbbb .Bottom +_cbfb ._dbbb .Top ;};_gfda :=_fefc .Width ;_baae :=_fefc .X ;_gbca :=_fefc .Y ;
_fefc .Height =_fefc .PageHeight -_fefc .Y -_fefc .Margins .Bottom ;_fbeba :=_fefc .Height ;_eadf :=0;_cgddc ,_gcec :=-1,-1;for _fcef ,_dcgg :=range _cbfb ._gefca {_agda :=_dcgg .width (_cbfb ._efbga ,_gfda );if _cbfb ._gefd {if _dcgg ._cbfe >=_cbfb ._cgdb &&_dcgg ._cbfe <=_cbfb ._gace {if _cgddc < 0{_cgddc =_fcef ;
};_gcec =_fcef ;};};_bcfa :=_cbfb ._ebaeg [_dcgg ._cbfe +_dcgg ._fbbb -2];if _eaaff :=_dcgg .height (_agda );_eaaff > _bcfa {_cbfb ._ebaeg [_dcgg ._cbfe +_dcgg ._fbbb -2]=_eaaff ;};};var (_bdbg bool ;_eaeg int ;_aegf int ;_gddg bool ;_ffba int ;_eggeg error ;
);for _fedd :=0;_fedd < len (_cbfb ._gefca );_fedd ++{_cfgg :=_cbfb ._gefca [_fedd ];_gfgc :=_cfgg .width (_cbfb ._efbga ,_gfda );_gbge :=float64 (0.0);for _baf :=0;_baf < _cfgg ._gcbeg -1;_baf ++{_gbge +=_cbfb ._efbga [_baf ]*_gfda ;};_bgbaa :=float64 (0.0);
for _cdfba :=_eadf ;_cdfba < _cfgg ._cbfe -1;_cdfba ++{_bgbaa +=_cbfb ._ebaeg [_cdfba ];};_fefc .Height =_fbeba -_bgbaa ;_ggaeb :=float64 (0.0);for _cafce :=0;_cafce < _cfgg ._fbbb ;_cafce ++{_ggaeb +=_cbfb ._ebaeg [_cfgg ._cbfe +_cafce -1];};_afed :=_gddg &&_cfgg ._cbfe !=_ffba ;
_ffba =_cfgg ._cbfe ;if _afed ||_ggaeb > _fefc .Height {if _cbfb ._eegf &&!_gddg {_gddg ,_eggeg =_cbfb .wrapRow (_fedd ,_fefc ,_gfda );if _eggeg !=nil {return nil ,_fefc ,_eggeg ;};if _gddg {_fedd --;continue ;};};_gfga =append (_gfga ,_eeca );_eeca =NewBlock (_fefc .PageWidth ,_fefc .PageHeight );
_baae =_fefc .Margins .Left ;_gbca =_fefc .Margins .Top ;_fefc .Height =_fefc .PageHeight -_fefc .Margins .Top -_fefc .Margins .Bottom ;_fefc .Page ++;_fbeba =_fefc .Height ;_eadf =_cfgg ._cbfe -1;_bgbaa =0;_gddg =false ;if _cbfb ._gefd &&_cgddc >=0{_eaeg =_fedd ;
_fedd =_cgddc -1;_aegf =_eadf ;_eadf =_cbfb ._cgdb -1;_bdbg =true ;continue ;};if _afed {_fedd --;continue ;};};_fefc .Width =_gfgc ;_fefc .X =_baae +_gbge ;_fefc .Y =_gbca +_bgbaa ;_gccbe :=_egfb (_fefc .X ,_fefc .Y ,_gfgc ,_ggaeb );if _cfgg ._gfbdf !=nil {_gccbe .SetFillColor (_cfgg ._gfbdf );
};_gccbe .LineStyle =_cfgg ._deae ;_gccbe ._bef =_cfgg ._fgdc ;_gccbe ._cca =_cfgg ._bffcb ;_gccbe ._ggf =_cfgg ._dgegd ;_gccbe ._bgdb =_cfgg ._cfeed ;if _cfgg ._accb !=nil {_gccbe .SetColorLeft (_cfgg ._accb );};if _cfgg ._egbe !=nil {_gccbe .SetColorBottom (_cfgg ._egbe );
};if _cfgg ._acga !=nil {_gccbe .SetColorRight (_cfgg ._acga );};if _cfgg ._gdda !=nil {_gccbe .SetColorTop (_cfgg ._gdda );};_gccbe .SetWidthBottom (_cfgg ._bbge );_gccbe .SetWidthLeft (_cfgg ._bedgc );_gccbe .SetWidthRight (_cfgg ._ebge );_gccbe .SetWidthTop (_cfgg ._acbf );
_aebae :=_eeca .Draw (_gccbe );if _aebae !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_aebae );};if _cfgg ._efcga !=nil {_fedf :=_cfgg ._efcga .Width ();_ccga :=_cfgg ._efcga .Height ();_afaf :=0.0;switch _affc :=_cfgg ._efcga .(type ){case *Paragraph :if _affc ._dfed {_fedf =_affc .getMaxLineWidth ()/1000.0;
};_fedf +=_affc ._fcfba .Left +_affc ._fcfba .Right ;_ccga +=_affc ._fcfba .Top +_affc ._fcfba .Bottom ;case *StyledParagraph :if _affc ._deac {_fedf =_affc .getMaxLineWidth ()/1000.0;};_accgg ,_bebcc :=_affc .getLineHeight (0);if len (_affc ._gffa )==1{_ccga =_accgg ;
}else {_ccga =_ccga -_bebcc +_accgg ;};_afaf =_accgg -_bebcc ;switch _cfgg ._fcb {case CellVerticalAlignmentTop :_afaf +=_accgg *0.5;case CellVerticalAlignmentBottom :_afaf -=_accgg *0.5;};_fedf +=_affc ._bacc .Left +_affc ._bacc .Right ;_ccga +=_affc ._bacc .Top +_affc ._bacc .Bottom ;
case *Table :_fedf =_gfgc ;case *List :_fedf =_gfgc ;};switch _cfgg ._bdcg {case CellHorizontalAlignmentLeft :_fefc .X +=_cfgg ._ggabd ;_fefc .Width -=_cfgg ._ggabd ;case CellHorizontalAlignmentCenter :if _caeb :=_gfgc -_fedf ;_caeb > 0{_fefc .X +=_caeb /2;
_fefc .Width -=_caeb /2;};case CellHorizontalAlignmentRight :if _gfgc > _fedf {_fefc .X =_fefc .X +_gfgc -_fedf -_cfgg ._ggabd ;_fefc .Width -=_cfgg ._ggabd ;};};_fefc .Y +=_afaf ;switch _cfgg ._fcb {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _ffcff :=_ggaeb -_ccga ;
_ffcff > 0{_fefc .Y +=_ffcff /2;_fefc .Height -=_ffcff /2;};case CellVerticalAlignmentBottom :if _ggaeb > _ccga {_fefc .Y =_fefc .Y +_ggaeb -_ccga ;_fefc .Height =_ggaeb ;};};_ddgda :=_eeca .DrawWithContext (_cfgg ._efcga ,_fefc );if _ddgda !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ddgda );
};_fefc .Y -=_afaf ;};_fefc .Y +=_ggaeb ;_fefc .Height -=_ggaeb ;if _bdbg &&_fedd +1> _gcec {_gbca +=_bgbaa +_ggaeb ;_fbeba -=_ggaeb +_bgbaa ;_eadf =_aegf ;_fedd =_eaeg -1;_bdbg =false ;};};_gfga =append (_gfga ,_eeca );if _cbfb ._gfad .IsAbsolute (){return _gfga ,_fbaab ,nil ;
};_fefc .X =_fbaab .X ;_fefc .Width =_fbaab .Width ;_fefc .Y +=_cbfb ._dbbb .Bottom ;_fefc .Height -=_cbfb ._dbbb .Bottom ;return _gfga ,_fefc ,nil ;};func (_efecbb *Table )resetColumnWidths (){_efecbb ._efbga =[]float64 {};_dfba :=float64 (1.0)/float64 (_efecbb ._ddea );
for _bgbb :=0;_bgbb < _efecbb ._ddea ;_bgbb ++{_efecbb ._efbga =append (_efecbb ._efbga ,_dfba );};};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ddcb *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _ddcb ._dafaa [0],_ddcb ._dafaa [1]};

// Margins returns the margins of the list: left, right, top, bottom.
func (_bbca *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _bbca ._agag .Left ,_bbca ._agag .Right ,_bbca ._agag .Top ,_bbca ._agag .Bottom ;};

// SetBorderColor sets border color.
func (_fbfc *Rectangle )SetBorderColor (col Color ){_fbfc ._bcbg =col };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_cbfg *Image )SetEncoder (encoder _db .StreamEncoder ){_cbfg ._eadcd =encoder };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_deca *Table )MultiColCell (colspan int )*TableCell {return _deca .newCell (colspan )};func (_dge *Block )setOpacity (_cg float64 ,_cb float64 )(string ,error ){if (_cg < 0||_cg >=1.0)&&(_cb < 0||_cb >=1.0){return "",nil ;};_dbf :=0;_cf :=_bb .Sprintf ("\u0047\u0053\u0025\u0064",_dbf );
for _dge ._dcba .HasExtGState (_db .PdfObjectName (_cf )){_dbf ++;_cf =_bb .Sprintf ("\u0047\u0053\u0025\u0064",_dbf );};_bdc :=_db .MakeDict ();if _cg >=0&&_cg < 1.0{_bdc .Set ("\u0063\u0061",_db .MakeFloat (_cg ));};if _cb >=0&&_cb < 1.0{_bdc .Set ("\u0043\u0041",_db .MakeFloat (_cb ));
};_ab :=_dge ._dcba .AddExtGState (_db .PdfObjectName (_cf ),_bdc );if _ab !=nil {return "",_ab ;};return _cf ,nil ;};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_bge :_ec .Max (_ec .Min (c ,1.0),0.0),_gbdf :_ec .Max (_ec .Min (m ,1.0),0.0),_gec :_ec .Max (_ec .Min (y ,1.0),0.0),_ecfab :_ec .Max (_ec .Min (k ,1.0),0.0)};};

// SetWidthLeft sets border width for left.
func (_edf *border )SetWidthLeft (bw float64 ){_edf ._fbf =bw };

// SetAngle sets the rotation angle of the text.
func (_gddc *Paragraph )SetAngle (angle float64 ){_gddc ._fcfg =angle };type cmykColor struct{_bge ,_gbdf ,_gec ,_ecfab float64 };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_adedc *TOC )SetLineSeparatorStyle (style TextStyle ){_adedc ._gccf =style };func (_fbbc *Invoice )newCell (_gabe string ,_gdfd InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_gdfd ,_gabe };};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};func (_aba *Block )mergeBlocks (_efb *Block )error {_bbf :=_cbb (_aba ._ef ,_aba ._dcba ,_efb ._ef ,_efb ._dcba );if _bbf !=nil {return _bbf ;};for _ ,_aac :=range _efb ._bgg {_aba .AddAnnotation (_aac );
};return nil ;};

// NewImageFromFile creates an Image from a file.
func (_bbdd *Creator )NewImageFromFile (path string )(*Image ,error ){return _eeed (path )};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_faeb *TOC )SetHeading (text string ,style TextStyle ){_cefd :=_faeb .Heading ();_cefd .Reset ();_bggaa :=_cefd .Append (text );_bggaa .Style =style ;};func _gfdd (_abfcb string ,_gdca TextStyle )*Paragraph {_bcf :=&Paragraph {_cgfeg :_abfcb ,_deed :_gdca .Font ,_aabf :_gdca .FontSize ,_eag :1.0,_dfed :true ,_efbd :true ,_gfbfb :TextAlignmentLeft ,_fcfg :0,_dcge :1,_eabae :1,_dfcfe :PositionRelative };
_bcf .SetColor (_gdca .Color );return _bcf ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_ebf *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adf :=ctx ;if _ebf ._ece .IsRelative (){ctx .X +=_ebf ._gca .Left ;ctx .Y +=_ebf ._gca .Top ;ctx .Width -=_ebf ._gca .Left +_ebf ._gca .Right ;ctx .Height -=_ebf ._gca .Top ;
};_gcac ,_fbbd ,_bbegc :=_ebf ._df .GeneratePageBlocks (ctx );if _bbegc !=nil {return _gcac ,ctx ,_bbegc ;};ctx =_fbbd ;_cgbg :=ctx .X ;_ggdg :=ctx .Y -_ebf ._df .Height ();_eabf :=int64 (ctx .Page );_bbc :=_ebf .headingNumber ();_gged :=_ebf .headingText ();
if _ebf ._cdf {_acfc :=_ebf ._ddab .Add (_bbc ,_ebf ._cbe ,_ff .FormatInt (_eabf ,10),_ebf ._geb );if _ebf ._ddab ._egdd {_acfc .SetLink (_eabf ,_cgbg ,_ggdg );};};if _ebf ._bdad ==nil {_ebf ._bdad =_a .NewOutlineItem (_gged ,_a .NewOutlineDest (_eabf -1,_cgbg ,_ggdg ));
if _ebf ._dff !=nil {_ebf ._dff ._bdad .Add (_ebf ._bdad );}else {_ebf ._accg .Add (_ebf ._bdad );};}else {_gcee :=&_ebf ._bdad .Dest ;_gcee .Page =_eabf -1;_gcee .X =_cgbg ;_gcee .Y =_ggdg ;};for _ ,_ggfa :=range _ebf ._cgba {_dbgc ,_fce ,_ddf :=_ggfa .GeneratePageBlocks (ctx );
if _ddf !=nil {return _gcac ,ctx ,_ddf ;};if len (_dbgc )< 1{continue ;};_gcac [len (_gcac )-1].mergeBlocks (_dbgc [0]);_gcac =append (_gcac ,_dbgc [1:]...);ctx =_fce ;};if _ebf ._ece .IsRelative (){ctx .X =_adf .X ;};if _ebf ._ece .IsAbsolute (){return _gcac ,_adf ,nil ;
};return _gcac ,ctx ,nil ;};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_ddbcb *Rectangle )GetCoords ()(float64 ,float64 ){return _ddbcb ._edcaf ,_ddbcb ._dcfc };

// SetTitleStyle sets the style properties of the invoice title.
func (_cgfa *Invoice )SetTitleStyle (style TextStyle ){_cgfa ._cead =style };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_eged *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_babb :=ctx ;var _dceef []*Block ;_bfcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _eged ._dfcfe .IsRelative (){ctx .X +=_eged ._fcfba .Left ;ctx .Y +=_eged ._fcfba .Top ;
ctx .Width -=_eged ._fcfba .Left +_eged ._fcfba .Right ;ctx .Height -=_eged ._fcfba .Top +_eged ._fcfba .Bottom ;_eged .SetWidth (ctx .Width );if _eged .Height ()> ctx .Height {_dceef =append (_dceef ,_bfcg );_bfcg =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_ceag :=ctx ;_ceag .Y =ctx .Margins .Top ;_ceag .X =ctx .Margins .Left +_eged ._fcfba .Left ;_ceag .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_eged ._fcfba .Bottom ;_ceag .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_eged ._fcfba .Left -_eged ._fcfba .Right ;
ctx =_ceag ;};}else {if int (_eged ._agab )<=0{_eged .SetWidth (_eged .getTextWidth ());};ctx .X =_eged ._baac ;ctx .Y =_eged ._eabbd ;};ctx ,_cgcc :=_gbcf (_bfcg ,_eged ,ctx );if _cgcc !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cgcc );
return nil ,ctx ,_cgcc ;};_dceef =append (_dceef ,_bfcg );if _eged ._dfcfe .IsRelative (){ctx .X -=_eged ._fcfba .Left ;ctx .Width =_babb .Width ;return _dceef ,ctx ,nil ;};return _dceef ,_babb ,nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_ggbfd *List )Indent ()float64 {return _ggbfd ._fdfegf };

// AppendCurve appends a Bezier curve to the filled curve.
func (_eef *FilledCurve )AppendCurve (curve _ba .CubicBezierCurve )*FilledCurve {_eef ._fdge =append (_eef ._fdge ,curve );return _eef ;};func (_abc *Block )transform (_ead _dcb .Matrix ){_aff :=_bd .NewContentCreator ().Add_cm (_ead [0],_ead [1],_ead [3],_ead [4],_ead [6],_ead [7]).Operations ();
*_abc ._ef =append (*_aff ,*_abc ._ef ...);_abc ._ef .WrapIfNeeded ();};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_daaf *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abdcb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eaaf ,_degeg :=_abdcb .setOpacity (_daaf ._bee ,_daaf ._bee );if _degeg !=nil {return nil ,ctx ,_degeg ;};
_gddbd :=_daaf ._agdc .Points ;for _bgdd :=range _gddbd {_bdcf :=&_gddbd [_bgdd ];_bdcf .Y =ctx .PageHeight -_bdcf .Y ;};_fbcbg ,_ ,_degeg :=_daaf ._agdc .Draw (_eaaf );if _degeg !=nil {return nil ,ctx ,_degeg ;};if _degeg =_abdcb .addContentsByString (string (_fbcbg ));
_degeg !=nil {return nil ,ctx ,_degeg ;};return []*Block {_abdcb },ctx ,nil ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_aaba *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_aaba ._ddea {_cd .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aaba ._efbga =widths ;return nil ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_bcdgc *TOC )SetLineLevelOffset (levelOffset float64 ){_bcdgc ._abcc =levelOffset };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_ceg *TOC )SetLinePageStyle (style TextStyle ){_ceg ._efgcd =style };

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eeea *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _eeea ._ddca [0],_eeea ._ddca [1]};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_abac *Paragraph )Height ()float64 {_abac .wrapText ();return float64 (len (_abac ._fgff ))*_abac ._eag *_abac ._aabf ;};func (_aagc *Creator )setActivePage (_ggdd *_a .PdfPage ){_aagc ._efgb =_ggdd };

// NewInvoice returns an instance of an empty invoice.
func (_daga *Creator )NewInvoice ()*Invoice {_gacb :=_daga .NewTextStyle ();_gacb .Font =_daga ._ddd ;return _cgcfe (_daga .NewTextStyle (),_gacb );};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_cbcd :_ec .Max (_ec .Min (r ,1.0),0.0),_eadc :_ec .Max (_ec .Min (g ,1.0),0.0),_dbee :_ec .Max (_ec .Min (b ,1.0),0.0)};};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_dfee *TableCell )SetContent (vd VectorDrawable )error {switch _ffee :=vd .(type ){case *Paragraph :if _ffee ._efbd {_ffee ._dfed =true ;};_dfee ._efcga =vd ;case *StyledParagraph :if _ffee ._aecg {_ffee ._deac =true ;};_dfee ._efcga =vd ;case *Image :_dfee ._efcga =vd ;
case *Table :_dfee ._efcga =vd ;case *List :_dfee ._efcga =vd ;case *Division :_dfee ._efcga =vd ;default:_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _db .ErrTypeError ;};return nil ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_ggbae *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbdd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bdb :=_ba .Circle {X :_ggbae ._gfaf -_ggbae ._afde /2,Y :ctx .PageHeight -_ggbae ._gbgf -_ggbae ._ceeaa /2,Width :_ggbae ._afde ,Height :_ggbae ._ceeaa ,Opacity :1.0,BorderWidth :_ggbae ._gda };
if _ggbae ._caaf !=nil {_bdb .FillEnabled =true ;_bdb .FillColor =_gdg (_ggbae ._caaf );};if _ggbae ._gcab !=nil {_bdb .BorderEnabled =true ;_bdb .BorderColor =_gdg (_ggbae ._gcab );_bdb .BorderWidth =_ggbae ._gda ;};_gfeae ,_ ,_gfdg :=_bdb .Draw ("");
if _gfdg !=nil {return nil ,ctx ,_gfdg ;};_gfdg =_gbdd .addContentsByString (string (_gfeae ));if _gfdg !=nil {return nil ,ctx ,_gfdg ;};return []*Block {_gbdd },ctx ,nil ;};func (_baaf *Image )rotatedSize ()(float64 ,float64 ){_gfbb :=_baaf ._bcdb ;_ecad :=_baaf ._agd ;
_bdab :=_baaf ._aedf ;if _bdab ==0{return _gfbb ,_ecad ;};_bgce :=_ba .Path {Points :[]_ba .Point {_ba .NewPoint (0,0).Rotate (_bdab ),_ba .NewPoint (_gfbb ,0).Rotate (_bdab ),_ba .NewPoint (0,_ecad ).Rotate (_bdab ),_ba .NewPoint (_gfbb ,_ecad ).Rotate (_bdab )}}.GetBoundingBox ();
return _bgce .Width ,_bgce .Height ;};func _ceb (_baeag *Chapter ,_bff *TOC ,_gce *_a .Outline ,_feda string ,_aed int ,_ecfa TextStyle )*Chapter {var _cgae uint =1;if _baeag !=nil {_cgae =_baeag ._geb +1;};_bgba :=&Chapter {_bfb :_aed ,_cbe :_feda ,_gag :true ,_cdf :true ,_dff :_baeag ,_ddab :_bff ,_accg :_gce ,_cgba :[]Drawable {},_geb :_cgae };
_bc :=_gfdd (_bgba .headingText (),_ecfa );_bc .SetFont (_ecfa .Font );_bc .SetFontSize (_ecfa .FontSize );_bgba ._df =_bc ;return _bgba ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_dfe *Chapter )GetHeading ()*Paragraph {return _dfe ._df };

// SetFillColor sets the fill color.
func (_fag *Ellipse )SetFillColor (col Color ){_fag ._caaf =col };

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_feee *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_gfgg :=NewTextChunk (text ,_feee ._fefb );_gfgg ._fbdg =_fdac (url );return _feee .appendChunk (_gfgg );};

// Width returns the current page width.
func (_fgg *Creator )Width ()float64 {return _fgg ._ddag };

// SetFillOpacity sets the fill opacity.
func (_agfe *Rectangle )SetFillOpacity (opacity float64 ){_agfe ._cecc =opacity };const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// SetNotes sets the notes section of the invoice.
func (_aged *Invoice )SetNotes (title ,content string ){_aged ._bced =[2]string {title ,content }};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_fbeg *Division )Width ()float64 {return 0};func (_gdba *Block )addContentsByString (_bgga string )error {_efe :=_bd .NewContentStreamParser (_bgga );_cfa ,_edg :=_efe .Parse ();if _edg !=nil {return _edg ;};_gdba ._ef .WrapIfNeeded ();_cfa .WrapIfNeeded ();
*_gdba ._ef =append (*_gdba ._ef ,*_cfa ...);return nil ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_ddga *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _f .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_ddga ._gefd =true ;_ddga ._cgdb =startRow ;_ddga ._gace =endRow ;return nil ;};

// SetLineWidth sets the line width.
func (_egaff *Line )SetLineWidth (lw float64 ){_egaff ._bgbc =lw };

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_cdgfe *Table )EnableRowWrap (enable bool ){_cdgfe ._eegf =enable };func _fdac (_efee string )*_a .PdfAnnotation {_agce :=_a .NewPdfAnnotationLink ();_eddd :=_a .NewBorderStyle ();_eddd .SetBorderWidth (0);_agce .BS =_eddd .ToPdfObject ();_abcdec :=_a .NewPdfActionURI ();
_abcdec .URI =_db .MakeString (_efee );_agce .SetAction (_abcdec .PdfAction );return _agce .PdfAnnotation ;};

// SetBorderColor sets the border color.
func (_gccae *PolyBezierCurve )SetBorderColor (color Color ){_gccae ._babcf .BorderColor =_gdg (color )};

// SetLineOpacity sets the line opacity.
func (_edcg *Polyline )SetLineOpacity (opacity float64 ){_edcg ._bee =opacity };

// SetLineHeight sets the line height (1.0 default).
func (_adca *StyledParagraph )SetLineHeight (lineheight float64 ){_adca ._cdagf =lineheight };

// Rows returns the total number of rows the table has.
func (_gccab *Table )Rows ()int {return _gccab ._bfbe };

// Height returns the Block's height.
func (_afb *Block )Height ()float64 {return _afb ._gd };

// SetLineColor sets the line color.
func (_bddc *Polyline )SetLineColor (color Color ){_bddc ._agdc .LineColor =_gdg (color )};

// SetDueDate sets the due date of the invoice.
func (_dfcg *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_dfcg ._dafaa [1].Value =dueDate ;return _dfcg ._dafaa [0],_dfcg ._dafaa [1];};func _dcaf (_efa [][]_ba .Point )*Polygon {return &Polygon {_gbgg :&_ba .Polygon {Points :_efa },_ebfc :1.0,_effdf :1.0};
};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_feg *Invoice )InfoLines ()[][2]*InvoiceCell {_fgcgd :=[][2]*InvoiceCell {_feg ._dbdg ,_feg ._ddca ,_feg ._dafaa };return append (_fgcgd ,_feg ._bfga ...);};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_eade *Image )SetPos (x ,y float64 ){_eade ._egaf =PositionAbsolute ;_eade ._efda =x ;_eade ._fbad =y ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gggf *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edff :=ctx ;_ebgb ,ctx ,_gfaae :=_gggf ._gcgg .GeneratePageBlocks (ctx );if _gfaae !=nil {return _ebgb ,ctx ,_gfaae ;};if _gggf ._fbed .IsRelative (){ctx .X =_edff .X ;
};if _gggf ._fbed .IsAbsolute (){return _ebgb ,_edff ,nil ;};return _ebgb ,ctx ,nil ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// SetColorTop sets border color for top.
func (_ffbc *border )SetColorTop (col Color ){_ffbc ._age =col };

// LevelOffset returns the amount of space an indentation level occupies.
func (_eddfg *TOCLine )LevelOffset ()float64 {return _eddfg ._egag };func (_afdf *Division )ctxHeight (_cgdd float64 )float64 {var _accd float64 ;for _ ,_ffge :=range _afdf ._ggcgb {switch _dbef :=_ffge .(type ){case *Paragraph :if _dbef ._dfed {_dbef .SetWidth (_cgdd );
};_accd +=_dbef .Height ()+_dbef ._fcfba .Top +_dbef ._fcfba .Bottom ;case *StyledParagraph :if _dbef ._deac {_dbef .SetWidth (_cgdd );};_accd +=_dbef .Height ()+_dbef ._bacc .Top +_dbef ._bacc .Bottom ;default:_accd +=_dbef .Height ();};};return _accd ;
};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_ggcgb []VectorDrawable ;_cbcde Positioning ;_bbeb Margins ;_gfbf bool ;};func (_ddbg *TextChunk )clone ()*TextChunk {_bbfa :=*_ddbg ;_bbfa ._fbdg =_eggc (_ddbg ._fbdg );return &_bbfa ;};

// Lines returns all the rows of the invoice line items table.
func (_ddabd *Invoice )Lines ()[][]*InvoiceCell {return _ddabd ._acdd };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_dfge *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_dceg ,_eeda :=_dfge .Wrap (width );if _eeda !=nil {return nil ,_eeda ;};_afba :=int (height /_dfge .Style .FontSize );if _afba >=len (_dceg ){return nil ,nil ;};_cbge :="\u000a";
_dfge .Text =_ecg .Replace (_ecg .Join (_dceg [:_afba ],"\u0020"),_cbge +"\u0020",_cbge ,-1);_beab :=_ecg .Replace (_ecg .Join (_dceg [_afba :],"\u0020"),_cbge +"\u0020",_cbge ,-1);return NewTextChunk (_beab ,_dfge .Style ),nil ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ef *_bd .ContentStreamOperations ;_dcba *_a .PdfPageResources ;_ce Positioning ;_ca ,_ac float64 ;_fc float64 ;_gd float64 ;_cag float64 ;_cdd Margins ;_bgg []*_a .PdfAnnotation ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ecgbd *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _babgf float64 ;var _dcg []*StyledParagraph ;for _ ,_egg :=range _ecgbd ._bdgga {_dded :=_defdf (_ecgbd ._eaef );_dded .SetEnableWrap (false );_dded .SetTextAlignment (TextAlignmentRight );
_dded .Append (_egg ._eaf .Text ).Style =_egg ._eaf .Style ;_abcb :=_dded .getTextWidth ()/1000.0/ctx .Width ;if _babgf < _abcb {_babgf =_abcb ;};_dcg =append (_dcg ,_dded );};_geff :=_gadb (2);_geff .SetColumnWidths (_babgf ,1-_babgf );_geff .SetMargins (_ecgbd ._fdfegf ,0,0,0);
for _acde ,_gfba :=range _ecgbd ._bdgga {_ccfc :=_geff .NewCell ();_ccfc .SetIndent (0);_ccfc .SetContent (_dcg [_acde ]);_ccfc =_geff .NewCell ();_ccfc .SetIndent (0);_ccfc .SetContent (_gfba ._adgg );};return _geff .GeneratePageBlocks (ctx );};

// SetMargins sets the margins TOC line.
func (_ffeg *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_ffeg ._egcgf =left ;_ddee :=&_ffeg ._gcgg ._bacc ;_ddee .Left =_ffeg ._egcgf +float64 (_ffeg ._bdbdd -1)*_ffeg ._egag ;_ddee .Right =right ;_ddee .Top =top ;_ddee .Bottom =bottom ;};


// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aece *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aece ._bacc .Left ,_aece ._bacc .Right ,_aece ._bacc .Top ,_aece ._bacc .Bottom ;};

// SetFillColor sets the fill color for the path.
func (_fcdf *FilledCurve )SetFillColor (color Color ){_fcdf ._agcf =color };func (_dffef *StyledParagraph )getLineHeight (_acccb int )(_dcdc ,_bcec float64 ){if _dffef ._gffa ==nil ||len (_dffef ._gffa )==0{_dffef .wrapText ();};if _acccb < 0||_acccb > len (_dffef ._gffa )-1{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_acccb );
return 0,0;};_aagf :=_dffef ._gffa [_acccb ];for _ ,_bedg :=range _aagf {_cffb ,_dedg :=_bedg .Style .Font .GetFontDescriptor ();if _dedg !=nil {_cd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _daae float64 ;if _cffb !=nil {if _daae ,_dedg =_cffb .GetCapHeight ();_dedg !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_dedg );
};};if int (_daae )<=0{_cd .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_daae =1000;};_aabb :=_daae /1000.0*_bedg .Style .FontSize *_dffef ._cdagf ;if _aabb > _dcdc {_dcdc =_aabb ;};_aabb =_dffef ._cdagf *_bedg .Style .FontSize ;if _aabb > _bcec {_bcec =_aabb ;};};return _dcdc ,_bcec ;};func (_fbag *TOCLine )getLineLink ()*_a .PdfAnnotation {if _fbag ._fbbe <=0{return nil ;
};return _ggcdb (_fbag ._fbbe -1,_fbag ._gbfe ,_fbag ._cabb ,0);};func (_dgcdf *TableCell )width (_eabc []float64 ,_gfcbf float64 )float64 {_cbdda :=float64 (0.0);for _fbcdf :=0;_fbcdf < _dgcdf ._bbgdc ;_fbcdf ++{_cbdda +=_eabc [_dgcdf ._gcbeg +_fbcdf -1];
};return _cbdda *_gfcbf ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _ebec ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_feb :=&Creator {};_feb ._effg =[]*_a .PdfPage {};_feb ._ggcf =map[*_a .PdfPage ]*Block {};_feb .SetPageSize (PageSizeLetter );_dcf :=0.1*_feb ._ddag ;_feb ._egfg .Left =_dcf ;
_feb ._egfg .Right =_dcf ;_feb ._egfg .Top =_dcf ;_feb ._egfg .Bottom =_dcf ;var _bca error ;_feb ._cfgf ,_bca =_a .NewStandard14Font (_a .HelveticaName );if _bca !=nil {_feb ._cfgf =_a .DefaultFont ();};_feb ._ddd ,_bca =_a .NewStandard14Font (_a .HelveticaBoldName );
if _bca !=nil {_feb ._cfgf =_a .DefaultFont ();};_feb ._bbga =_feb .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_feb .AddOutlines =true ;_feb ._cgcf =_a .NewOutline ();_bg .TrackUse (_ebec );
return _feb ;};

// SetWidthTop sets border width for top.
func (_ebg *border )SetWidthTop (bw float64 ){_ebg ._dae =bw };

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_fecf *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_daff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_degd :=_ba .Rectangle {Opacity :1.0,X :_fecf ._edcaf ,Y :ctx .PageHeight -_fecf ._dcfc -_fecf ._cfad ,Height :_fecf ._cfad ,Width :_fecf ._gaec };
if _fecf ._aadd !=nil {_degd .FillEnabled =true ;_degd .FillColor =_gdg (_fecf ._aadd );};if _fecf ._bcbg !=nil &&_fecf ._aacgg > 0{_degd .BorderEnabled =true ;_degd .BorderColor =_gdg (_fecf ._bcbg );_degd .BorderWidth =_fecf ._aacgg ;};_dddc ,_dagab :=_daff .setOpacity (_fecf ._cecc ,_fecf ._bed );
if _dagab !=nil {return nil ,ctx ,_dagab ;};_bcff ,_ ,_dagab :=_degd .Draw (_dddc );if _dagab !=nil {return nil ,ctx ,_dagab ;};if _dagab =_daff .addContentsByString (string (_bcff ));_dagab !=nil {return nil ,ctx ,_dagab ;};return []*Block {_daff },ctx ,nil ;
};

// SetMargins sets the margins of the paragraph.
func (_adcc *List )SetMargins (left ,right ,top ,bottom float64 ){_adcc ._agag .Left =left ;_adcc ._agag .Right =right ;_adcc ._agag .Top =top ;_adcc ._agag .Bottom =bottom ;};func _gadb (_gdeeg int )*Table {_bgdfd :=&Table {_ddea :_gdeeg ,_fbeb :10.0,_efbga :[]float64 {},_ebaeg :[]float64 {},_gefca :[]*TableCell {}};
_bgdfd .resetColumnWidths ();return _bgdfd ;};

// SetBorderOpacity sets the border opacity.
func (_dade *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_dade ._gefc =opacity };

// WriteToFile writes the Creator output to file specified by path.
func (_egcg *Creator )WriteToFile (outputPath string )error {_bcag ,_ggfe :=_e .Create (outputPath );if _ggfe !=nil {return _ggfe ;};defer _bcag .Close ();return _egcg .Write (_bcag );};func _cbb (_gga *_bd .ContentStreamOperations ,_dbd *_a .PdfPageResources ,_gb *_bd .ContentStreamOperations ,_dgf *_a .PdfPageResources )error {_abf :=map[_db .PdfObjectName ]_db .PdfObjectName {};
_fac :=map[_db .PdfObjectName ]_db .PdfObjectName {};_afab :=map[_db .PdfObjectName ]_db .PdfObjectName {};_eadb :=map[_db .PdfObjectName ]_db .PdfObjectName {};_efec :=map[_db .PdfObjectName ]_db .PdfObjectName {};_gge :=map[_db .PdfObjectName ]_db .PdfObjectName {};
for _ ,_efeb :=range *_gb {switch _efeb .Operand {case "\u0044\u006f":if len (_efeb .Params )==1{if _aae ,_cgg :=_efeb .Params [0].(*_db .PdfObjectName );_cgg {if _ ,_ged :=_abf [*_aae ];!_ged {var _gde _db .PdfObjectName ;_aacg ,_ :=_dgf .GetXObjectByName (*_aae );
if _aacg !=nil {_gde =*_aae ;for {_gdc ,_ :=_dbd .GetXObjectByName (_gde );if _gdc ==nil ||_gdc ==_aacg {break ;};_gde =_gde +"\u0030";};};_dbd .SetXObjectByName (_gde ,_aacg );_abf [*_aae ]=_gde ;};_gfg :=_abf [*_aae ];_efeb .Params [0]=&_gfg ;};};case "\u0054\u0066":if len (_efeb .Params )==2{if _fed ,_aaa :=_efeb .Params [0].(*_db .PdfObjectName );
_aaa {if _ ,_edb :=_fac [*_fed ];!_edb {_ggd ,_dda :=_dgf .GetFontByName (*_fed );_fbc :=*_fed ;if _dda &&_ggd !=nil {_fbc =_bbeg (_fed .String (),_ggd ,_dbd );};_dbd .SetFontByName (_fbc ,_ggd );_fac [*_fed ]=_fbc ;};_caf :=_fac [*_fed ];_efeb .Params [0]=&_caf ;
};};case "\u0043\u0053","\u0063\u0073":if len (_efeb .Params )==1{if _ggde ,_cae :=_efeb .Params [0].(*_db .PdfObjectName );_cae {if _ ,_ecd :=_afab [*_ggde ];!_ecd {var _fef _db .PdfObjectName ;_aga ,_eeb :=_dgf .GetColorspaceByName (*_ggde );if _eeb {_fef =*_ggde ;
for {_ecdd ,_be :=_dbd .GetColorspaceByName (_fef );if !_be ||_aga ==_ecdd {break ;};_fef =_fef +"\u0030";};_dbd .SetColorspaceByName (_fef ,_aga );_afab [*_ggde ]=_fef ;}else {_cd .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");
};};if _ecdf ,_afbd :=_afab [*_ggde ];_afbd {_efeb .Params [0]=&_ecdf ;}else {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_ggde );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_efeb .Params )==1{if _cef ,_egbg :=_efeb .Params [0].(*_db .PdfObjectName );_egbg {if _ ,_efg :=_eadb [*_cef ];!_efg {var _dbag _db .PdfObjectName ;_abd ,_fcd :=_dgf .GetPatternByName (*_cef );
if _fcd {_dbag =*_cef ;for {_dccg ,_ggga :=_dbd .GetPatternByName (_dbag );if !_ggga ||_dccg ==_abd {break ;};_dbag =_dbag +"\u0030";};_gbc :=_dbd .SetPatternByName (_dbag ,_abd .ToPdfObject ());if _gbc !=nil {return _gbc ;};_eadb [*_cef ]=_dbag ;};};if _dgdd ,_ffc :=_eadb [*_cef ];
_ffc {_efeb .Params [0]=&_dgdd ;};};};case "\u0073\u0068":if len (_efeb .Params )==1{if _egf ,_cgb :=_efeb .Params [0].(*_db .PdfObjectName );_cgb {if _ ,_bdgg :=_efec [*_egf ];!_bdgg {var _gcg _db .PdfObjectName ;_fea ,_bgge :=_dgf .GetShadingByName (*_egf );
if _bgge {_gcg =*_egf ;for {_fdg ,_dbad :=_dbd .GetShadingByName (_gcg );if !_dbad ||_fea ==_fdg {break ;};_gcg =_gcg +"\u0030";};_fdf :=_dbd .SetShadingByName (_gcg ,_fea .ToPdfObject ());if _fdf !=nil {_cd .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_fdf );
return _fdf ;};_efec [*_egf ]=_gcg ;}else {_cd .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _fdc ,_abg :=_efec [*_egf ];_abg {_efeb .Params [0]=&_fdc ;}else {_cd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_egf );
};};};case "\u0067\u0073":if len (_efeb .Params )==1{if _ga ,_bab :=_efeb .Params [0].(*_db .PdfObjectName );_bab {if _ ,_gcc :=_gge [*_ga ];!_gcc {var _eeg _db .PdfObjectName ;_cga ,_efecb :=_dgf .GetExtGState (*_ga );if _efecb {_eeg =*_ga ;_bda :=1;for {_bbe ,_bgb :=_dbd .GetExtGState (_eeg );
if !_bgb ||_cga ==_bbe {break ;};_eeg =_db .PdfObjectName (_bb .Sprintf ("\u0047\u0053\u0025\u0064",_bda ));_bda ++;};};_dbd .AddExtGState (_eeg ,_cga );_gge [*_ga ]=_eeg ;};_dga :=_gge [*_ga ];_efeb .Params [0]=&_dga ;};};};*_gga =append (*_gga ,_efeb );
};return nil ;};

// SetColorBottom sets border color for bottom.
func (_ggee *border )SetColorBottom (col Color ){_ggee ._fee =col };func _ebdd (_ecab [][]_ba .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_dagf :&_ba .CurvePolygon {Rings :_ecab },_bag :1.0,_eegc :1.0};};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_bcaa *TOCLine )SetStyle (style TextStyle ){_bcaa .Number .Style =style ;_bcaa .Title .Style =style ;_bcaa .Separator .Style =style ;_bcaa .Page .Style =style ;};

// MoveX moves the drawing context to absolute position x.
func (_baec *Creator )MoveX (x float64 ){_baec ._aggdc .X =x };func (_bceb *Invoice )drawAddress (_eeba *InvoiceAddress )[]*StyledParagraph {var _becae []*StyledParagraph ;if _eeba .Heading !=""{_gbfa :=_defdf (_bceb ._fgge );_gbfa .SetMargins (0,0,0,7);
_gbfa .Append (_eeba .Heading );_becae =append (_becae ,_gbfa );};_cfbg :=_defdf (_bceb ._dfcf );_cfbg .SetLineHeight (1.2);_ddae :=_eeba .Separator ;if _ddae ==""{_ddae =_bceb ._gfee ;};_bebcd :=_eeba .City ;if _eeba .State !=""{if _bebcd !=""{_bebcd +=_ddae ;
};_bebcd +=_eeba .State ;};if _eeba .Zip !=""{if _bebcd !=""{_bebcd +=_ddae ;};_bebcd +=_eeba .Zip ;};if _eeba .Name !=""{_cfbg .Append (_eeba .Name +"\u000a");};if _eeba .Street !=""{_cfbg .Append (_eeba .Street +"\u000a");};if _eeba .Street2 !=""{_cfbg .Append (_eeba .Street2 +"\u000a");
};if _bebcd !=""{_cfbg .Append (_bebcd +"\u000a");};if _eeba .Country !=""{_cfbg .Append (_eeba .Country +"\u000a");};_cbebb :=_defdf (_bceb ._dfcf );_cbebb .SetLineHeight (1.2);_cbebb .SetMargins (0,0,7,0);if _eeba .Phone !=""{_cbebb .Append (_eeba .fmtLine (_eeba .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_eeba .HidePhoneLabel ));
};if _eeba .Email !=""{_cbebb .Append (_eeba .fmtLine (_eeba .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_eeba .HideEmailLabel ));};_becae =append (_becae ,_cfbg ,_cbebb );return _becae ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_gffd *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gfcb :=_gffd ;if _gffd ._eegf {_gfcb =_gffd .clone ();};return _gdgd (_gfcb ,ctx );};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_ffb *Block )SetPos (x ,y float64 ){_ffb ._ce =PositionAbsolute ;_ffb ._ca =x ;_ffb ._ac =y };

// Write output of creator to io.Writer interface.
func (_fedb *Creator )Write (ws _g .Writer )error {if _facg :=_fedb .Finalize ();_facg !=nil {return _facg ;};_cdga :=_a .NewPdfWriter ();_cdga .SetOptimizer (_fedb ._dfc );if _fedb ._bea !=nil {_ccf :=_cdga .SetForms (_fedb ._bea );if _ccf !=nil {_cd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_ccf );
return _ccf ;};};if _fedb ._fba !=nil {_cdga .AddOutlineTree (_fedb ._fba );}else if _fedb ._cgcf !=nil &&_fedb .AddOutlines {_cdga .AddOutlineTree (&_fedb ._cgcf .ToPdfOutline ().PdfOutlineTreeNode );};if _fedb ._gfgbg !=nil {if _geec :=_cdga .SetPageLabels (_fedb ._gfgbg );
_geec !=nil {_cd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_geec );return _geec ;};};if _fedb ._cadg !=nil {for _ ,_aacf :=range _fedb ._cadg {_dbfa :=_aacf .SubsetRegistered ();
if _dbfa !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_dbfa );return _dbfa ;};};};if _fedb ._aegg !=nil {_ebee :=_fedb ._aegg (&_cdga );
if _ebee !=nil {_cd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_ebee );return _ebee ;};};for _ ,_bbffd :=range _fedb ._effg {_eabaf :=_cdga .AddPage (_bbffd );if _eabaf !=nil {_cd .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_eabaf );
return _eabaf ;};};_beg :=_cdga .Write (ws );if _beg !=nil {return _beg ;};return nil ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_fbdg *_a .PdfAnnotation ;_bacgf bool ;};func _debfb (_dfeeg *_a .PdfRectangle ,_bcedc _dcb .Matrix )*_a .PdfRectangle {var _geef _a .PdfRectangle ;_geef .Llx ,_geef .Lly =_bcedc .Transform (_dfeeg .Llx ,_dfeeg .Lly );_geef .Urx ,_geef .Ury =_bcedc .Transform (_dfeeg .Urx ,_dfeeg .Ury );
_geef .Normalize ();return &_geef ;};

// SetPos sets absolute positioning with specified coordinates.
func (_abbb *StyledParagraph )SetPos (x ,y float64 ){_abbb ._dgac =PositionAbsolute ;_abbb ._dgcf =x ;_abbb ._ebda =y ;};

// SetSellerAddress sets the seller address of the invoice.
func (_egdc *Invoice )SetSellerAddress (address *InvoiceAddress ){_egdc ._aegd =address };

// SetBorderWidth sets the border width.
func (_facf *CurvePolygon )SetBorderWidth (borderWidth float64 ){_facf ._dagf .BorderWidth =borderWidth };func _gdaff (_gfab ,_aafg ,_aaead ,_aega float64 )*Rectangle {return &Rectangle {_edcaf :_gfab ,_dcfc :_aafg ,_gaec :_aaead ,_cfad :_aega ,_bcbg :ColorBlack ,_aacgg :1.0,_cecc :1.0,_bed :1.0};
};func (_efgf *Image )makeXObject ()error {_abab :=_efgf ._eadcd ;if _abab ==nil {_abab =_db .NewFlateEncoder ();};_dcca ,_gccb :=_a .NewXObjectImageFromImage (_efgf ._caba ,nil ,_abab );if _gccb !=nil {_cd .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gccb );
return _gccb ;};_efgf ._dgcg =_dcca ;return nil ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_gedgg *Table )SetPos (x ,y float64 ){_gedgg ._gfad =PositionAbsolute ;_gedgg ._gdfef =x ;_gedgg ._fdfac =y ;};func (_edc *Invoice )setCellBorder (_fede *TableCell ,_gdab *InvoiceCell ){for _ ,_dbgd :=range _gdab .BorderSides {_fede .SetBorder (_dbgd ,CellBorderStyleSingle ,_gdab .BorderWidth );
};_fede .SetBorderColor (_gdab .BorderColor );};func (_fccb *InvoiceAddress )fmtLine (_bfba ,_fcag string ,_ffeb bool )string {if _ffeb {_fcag ="";};return _bb .Sprintf ("\u0025\u0073\u0025s\u000a",_fcag ,_bfba );};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_bgebg *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cada :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ecgbg ,_cec :=_cada .setOpacity (_bgebg ._afdfb ,_bgebg ._gefc );if _cec !=nil {return nil ,ctx ,_cec ;
};_caeg :=_bgebg ._babcf ;_caeg .FillEnabled =_caeg .FillColor !=nil ;var (_befde =ctx .PageHeight ;_bdfc =_caeg .Curves ;_dcea =make ([]_ba .CubicBezierCurve ,0,len (_caeg .Curves )););for _cggb :=range _caeg .Curves {_ebfa :=_bdfc [_cggb ];_ebfa .P0 .Y =_befde -_ebfa .P0 .Y ;
_ebfa .P1 .Y =_befde -_ebfa .P1 .Y ;_ebfa .P2 .Y =_befde -_ebfa .P2 .Y ;_ebfa .P3 .Y =_befde -_ebfa .P3 .Y ;_dcea =append (_dcea ,_ebfa );};_caeg .Curves =_dcea ;defer func (){_caeg .Curves =_bdfc }();_abeb ,_ ,_cec :=_caeg .Draw (_ecgbg );if _cec !=nil {return nil ,ctx ,_cec ;
};if _cec =_cada .addContentsByString (string (_abeb ));_cec !=nil {return nil ,ctx ,_cec ;};return []*Block {_cada },ctx ,nil ;};

// Height returns Image's document height.
func (_dcdee *Image )Height ()float64 {return _dcdee ._agd };

// SetText replaces all the text of the paragraph with the specified one.
func (_aaed *StyledParagraph )SetText (text string )*TextChunk {_aaed .Reset ();return _aaed .Append (text );};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_cdfc *Invoice )SetAddressStyle (style TextStyle ){_cdfc ._dfcf =style };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetAngle sets the rotation angle in degrees.
func (_fb *Block )SetAngle (angleDeg float64 ){_fb ._cag =angleDeg };func (_dffb *Creator )newPage ()*_a .PdfPage {_dbaf :=_a .NewPdfPage ();_gaef :=_dffb ._efdd [0];_ceea :=_dffb ._efdd [1];_bbac :=_a .PdfRectangle {Llx :0,Lly :0,Urx :_gaef ,Ury :_ceea };
_dbaf .MediaBox =&_bbac ;_dffb ._ddag =_gaef ;_dffb ._bdgd =_ceea ;_dffb .initContext ();return _dbaf ;};

// SetBackgroundColor sets the cell's background color.
func (_cgfd *TableCell )SetBackgroundColor (col Color ){_cgfd ._gfbdf =col };

// SetTotal sets the total of the invoice.
func (_dcfg *Invoice )SetTotal (value string ){_dcfg ._bfeb [1].Value =value };

// SetPos sets absolute positioning with specified coordinates.
func (_gdgaf *Paragraph )SetPos (x ,y float64 ){_gdgaf ._dfcfe =PositionAbsolute ;_gdgaf ._baac =x ;_gdgaf ._eabbd =y ;};func _fgbdf (_deea []_ba .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_babcf :&_ba .PolyBezierCurve {Curves :_deea ,BorderColor :_a .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_afdfb :1.0,_gefc :1.0};
};

// NewFilledCurve returns a instance of filled curve.
func (_defc *Creator )NewFilledCurve ()*FilledCurve {return _fbec ()};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_gfgf *StyledParagraph ;_adge []*TOCLine ;_bgcdd TextStyle ;_gfcf TextStyle ;_gccf TextStyle ;_efgcd TextStyle ;_cgfec string ;_abcc float64 ;_eecc Margins ;_efafa Positioning ;_ggbg TextStyle ;_egdd bool ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_bf *Block )ScaleToHeight (h float64 ){_daf :=h /_bf ._gd ;_bf .Scale (_daf ,_daf )};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_cdcf *Invoice )Sections ()[][2]string {return _cdcf ._bcg };

// Width returns the cell's width based on the input draw context.
func (_cgeeg *TableCell )Width (ctx DrawContext )float64 {_caae :=float64 (0.0);for _fbdcg :=0;_fbdcg < _cgeeg ._bbgdc ;_fbdcg ++{_caae +=_cgeeg ._afdae ._efbga [_cgeeg ._gcbeg +_fbdcg -1];};_dabge :=ctx .Width *_caae ;return _dabge ;};

// SellerAddress returns the seller address used in the invoice template.
func (_cbee *Invoice )SellerAddress ()*InvoiceAddress {return _cbee ._aegd };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_dagf *_ba .CurvePolygon ;_bag float64 ;_eegc float64 ;};

// SetMargins sets the Paragraph's margins.
func (_babca *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_babca ._fcfba .Left =left ;_babca ._fcfba .Right =right ;_babca ._fcfba .Top =top ;_babca ._fcfba .Bottom =bottom ;};

// Height returns the current page height.
func (_fgce *Creator )Height ()float64 {return _fgce ._bdgd };func (_cdbb *Paragraph )getMaxLineWidth ()float64 {if _cdbb ._fgff ==nil ||len (_cdbb ._fgff )==0{_cdbb .wrapText ();};var _eegb float64 ;for _ ,_edca :=range _cdbb ._fgff {_bged :=_cdbb .getTextLineWidth (_edca );
if _bged > _eegb {_eegb =_bged ;};};return _eegb ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_gdga *Creator )Finalize ()error {if _gdga ._ggbf {return nil ;};_cdaf :=len (_gdga ._effg );_gbf :=0;if _gdga ._cgge !=nil {_gbf ++;};if _gdga .AddTOC {_gdga .initContext ();_gdga ._aggdc .Page =_gbf +1;if _gdga ._cbf !=nil {if _abdc :=_gdga ._cbf (_gdga ._bbga );
_abdc !=nil {return _abdc ;};};_dbgf ,_ ,_adg :=_gdga ._bbga .GeneratePageBlocks (_gdga ._aggdc );if _adg !=nil {_cd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_adg );
return _adg ;};_gbf +=len (_dbgf );_fgba :=_gdga ._bbga .Lines ();for _ ,_cbdc :=range _fgba {_gfe ,_dabc :=_ff .Atoi (_cbdc .Page .Text );if _dabc !=nil {continue ;};_cbdc .Page .Text =_ff .Itoa (_gfe +_gbf );};};_fbccf :=false ;if _gdga ._cgge !=nil {_cdaf ++;
_gff :=_gdga .newPage ();_gdga ._effg =append ([]*_a .PdfPage {_gff },_gdga ._effg ...);_gdga .setActivePage (_gff );_ced :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cdaf };_gdga ._cgge (_ced );_fbccf =true ;};var _bggg []*_a .PdfPage ;if _gdga .AddTOC {_gdga .initContext ();
if _gdga ._cbf !=nil {if _afd :=_gdga ._cbf (_gdga ._bbga );_afd !=nil {_cd .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_afd );return _afd ;};};_cefe :=_gdga ._bbga .Lines ();
for _ ,_cdba :=range _cefe {_cdba ._fbbe +=int64 (_gbf );};_cdag ,_ ,_ :=_gdga ._bbga .GeneratePageBlocks (_gdga ._aggdc );for _ ,_ggdeg :=range _cdag {_ggdeg .SetPos (0,0);_cdaf ++;_gbfb :=_gdga .newPage ();_bggg =append (_bggg ,_gbfb );_gdga .setActivePage (_gbfb );
_gdga .Draw (_ggdeg );};if _fbccf {_eee :=_gdga ._effg [0];_gdce :=_gdga ._effg [1:];_gdga ._effg =append ([]*_a .PdfPage {_eee },_bggg ...);_gdga ._effg =append (_gdga ._effg ,_gdce ...);}else {_gdga ._effg =append (_bggg ,_gdga ._effg ...);};};if _gdga ._cgcf !=nil &&_gdga .AddOutlines {var _dabce func (_aee *_a .OutlineItem );
_dabce =func (_bdgc *_a .OutlineItem ){_bdgc .Dest .Page +=int64 (_gbf );if _dafe :=int (_bdgc .Dest .Page );_dafe >=0&&_dafe < len (_gdga ._effg ){_bdgc .Dest .PageObj =_gdga ._effg [_dafe ].GetPageAsIndirectObject ();}else {_cd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_dafe );
};_bdgc .Dest .Y =_gdga ._bdgd -_bdgc .Dest .Y ;_efbg :=_bdgc .Items ();for _ ,_fgf :=range _efbg {_dabce (_fgf );};};_bce :=_gdga ._cgcf .Items ();for _ ,_aeeb :=range _bce {_dabce (_aeeb );};if _gdga .AddTOC {var _agf int ;if _fbccf {_agf =1;};_fadd :=_a .NewOutlineDest (int64 (_agf ),0,_gdga ._bdgd );
if _agf >=0&&_agf < len (_gdga ._effg ){_fadd .PageObj =_gdga ._effg [_agf ].GetPageAsIndirectObject ();}else {_cd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_agf );
};_gdga ._cgcf .Insert (0,_a .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_fadd ));};};for _dfd ,_gbcg :=range _gdga ._effg {_gdga .setActivePage (_gbcg );if _gdga ._dca !=nil {_egae ,_abe ,_cbeb :=_gbcg .Size ();
if _cbeb !=nil {return _cbeb ;};_baaa :=PageFinalizeFunctionArgs {PageNum :_dfd +1,PageWidth :_egae ,PageHeight :_abe ,TOCPages :len (_bggg ),TotalPages :_cdaf };if _acad :=_gdga ._dca (_baaa );_acad !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_acad );
return _acad ;};};if _gdga ._dgaf !=nil {_caea :=NewBlock (_gdga ._ddag ,_gdga ._egfg .Top );_daec :=HeaderFunctionArgs {PageNum :_dfd +1,TotalPages :_cdaf };_gdga ._dgaf (_caea ,_daec );_caea .SetPos (0,0);if _gabd :=_gdga .Draw (_caea );_gabd !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_gabd );
return _gabd ;};};if _gdga ._aaca !=nil {_dcag :=NewBlock (_gdga ._ddag ,_gdga ._egfg .Bottom );_befb :=FooterFunctionArgs {PageNum :_dfd +1,TotalPages :_cdaf };_gdga ._aaca (_dcag ,_befb );_dcag .SetPos (0,_gdga ._bdgd -_dcag ._gd );if _fbac :=_gdga .Draw (_dcag );
_fbac !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_fbac );return _fbac ;};};_bbed ,_gecf :=_gdga ._ggcf [_gbcg ];if !_gecf {continue ;};if _dgfb ,_dagg :=_gdga ._cagbg [_gbcg ];
_dagg {_bbed .transform (_dgfb );};if _adcf :=_bbed .drawToPage (_gbcg );_adcf !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_dfd +1,_adcf );
return _adcf ;};};_gdga ._ggbf =true ;return nil ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_dgcg *_a .XObjectImage ;_caba *_a .Image ;_aedf float64 ;_bcdb ,_agd float64 ;_ecde ,_afdea float64 ;_egaf Positioning ;_ebcf HorizontalAlignment ;_efda float64 ;_fbad float64 ;_bdga float64 ;_cagbc Margins ;_begd ,_agb float64 ;_eadcd _db .StreamEncoder ;
};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// NewPolygon creates a new polygon.
func (_cafg *Creator )NewPolygon (points [][]_ba .Point )*Polygon {return _dcaf (points )};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_gg :=&Block {};_gg ._ef =&_bd .ContentStreamOperations {};_gg ._dcba =_a .NewPdfPageResources ();_gg ._fc =width ;_gg ._gd =height ;return _gg ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_ccdb *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _degc (number ,title ,page ,level ,_ccdb .NewTextStyle ());};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func _cefg (_cfgda *_e .File )([]*_a .PdfPage ,error ){_cddab ,_fgafe :=_a .NewPdfReader (_cfgda );if _fgafe !=nil {return nil ,_fgafe ;};_dbcdbf ,_fgafe :=_cddab .GetNumPages ();if _fgafe !=nil {return nil ,_fgafe ;};var _fcdg []*_a .PdfPage ;
for _agefe :=0;_agefe < _dbcdbf ;_agefe ++{_cdce ,_ccee :=_cddab .GetPage (_agefe +1);if _ccee !=nil {return nil ,_ccee ;};_fcdg =append (_fcdg ,_cdce );};return _fcdg ,nil ;};func (_fadg *Invoice )newColumn (_ffef string ,_acgf CellHorizontalAlignment )*InvoiceCell {_gbbb :=&InvoiceCell {_fadg ._agbg ,_ffef };
_gbbb .Alignment =_acgf ;return _gbbb ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_becf *Invoice )SetBuyerAddress (address *InvoiceAddress ){_becf ._dbgg =address };type border struct{_ddc float64 ;_ecdg float64 ;_bbd float64 ;_cagb float64 ;_baea Color ;_ebc Color ;_fbf float64 ;_fee Color ;_cac float64 ;_eab Color ;_gccd float64 ;
_age Color ;_dae float64 ;LineStyle _ba .LineStyle ;_bef CellBorderStyle ;_cca CellBorderStyle ;_ggf CellBorderStyle ;_bgdb CellBorderStyle ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_afdc *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _afdc ._ecgb ,_afdc ._effc ,_afdc ._abbg ,_afdc ._dffe ;};

// Lines returns all the lines the table of contents has.
func (_efafb *TOC )Lines ()[]*TOCLine {return _efafb ._adge };

// SetShowLinks sets visibility of links for the TOC lines.
func (_fdgg *TOC )SetShowLinks (showLinks bool ){_fdgg ._egdd =showLinks };

// SetStyleBottom sets border style for bottom side.
func (_acd *border )SetStyleBottom (style CellBorderStyle ){_acd ._bgdb =style };

// NewCellProps returns the default properties of an invoice cell.
func (_geeb *Invoice )NewCellProps ()InvoiceCellProps {_accc :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_geeb ._fbdc ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_accc ,BorderColor :_accc ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_eefg *TableCell )SetBorderLineStyle (style _ba .LineStyle ){_eefg ._deae =style };

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_fbfb *Creator )SetPageSize (size PageSize ){_fbfb ._efdd =size ;_fbfb ._ddag =size [0];_fbfb ._bdgd =size [1];_gba :=0.1*_fbfb ._ddag ;_fbfb ._egfg .Left =_gba ;_fbfb ._egfg .Right =_gba ;_fbfb ._egfg .Top =_gba ;_fbfb ._egfg .Bottom =_gba ;};

// NewTable create a new Table with a specified number of columns.
func (_fcg *Creator )NewTable (cols int )*Table {return _gadb (cols )};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_ecb *Block )AddAnnotation (annotation *_a .PdfAnnotation ){for _ ,_cddc :=range _ecb ._bgg {if _cddc ==annotation {return ;};};_ecb ._bgg =append (_ecb ._bgg ,annotation );};

// NewCell returns a new invoice table cell.
func (_cdec *Invoice )NewCell (value string )*InvoiceCell {return _cdec .newCell (value ,_cdec .NewCellProps ());};

// SetLogo sets the logo of the invoice.
func (_ecee *Invoice )SetLogo (logo *Image ){_ecee ._bgdg =logo };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_eeab *Invoice )SetNoteStyle (style TextStyle ){_eeab ._ddabf =style };

// SetColor sets the line color.
func (_abga *Curve )SetColor (col Color ){_abga ._cdaa =col };

// SetWidthBottom sets border width for bottom.
func (_gfc *border )SetWidthBottom (bw float64 ){_gfc ._cac =bw };func _gdg (_fcdd Color )_a .PdfColor {if _fcdd ==nil {_fcdd =ColorBlack ;};switch _gedgf :=_fcdd .(type ){case cmykColor :return _a .NewPdfColorDeviceCMYK (_gedgf ._bge ,_gedgf ._gbdf ,_gedgf ._gec ,_gedgf ._ecfab );
};return _a .NewPdfColorDeviceRGB (_fcdd .ToRGB ());};

// NewPolyline creates a new polyline.
func (_dgbg *Creator )NewPolyline (points []_ba .Point )*Polyline {return _cdecc (points )};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_edcaf float64 ;_dcfc float64 ;_gaec float64 ;_cfad float64 ;_aadd Color ;_cecc float64 ;_bcbg Color ;_aacgg float64 ;_bed float64 ;};

// AppendColumn appends a column to the line items table.
func (_aeee *Invoice )AppendColumn (description string )*InvoiceCell {_cba :=_aeee .NewColumn (description );_aeee ._afda =append (_aeee ._afda ,_cba );return _cba ;};func _cdecc (_dfb []_ba .Point )*Polyline {return &Polyline {_agdc :&_ba .Polyline {Points :_dfb ,LineColor :_a .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_bee :1.0};
};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_dcce *Block )Draw (d Drawable )error {_dgd :=DrawContext {};_dgd .Width =_dcce ._fc ;_dgd .Height =_dcce ._gd ;_dgd .PageWidth =_dcce ._fc ;_dgd .PageHeight =_dcce ._gd ;_dgd .X =0;_dgd .Y =0;_efc ,_ ,_gef :=d .GeneratePageBlocks (_dgd );if _gef !=nil {return _gef ;
};if len (_efc )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_bfg :=range _efc {if _cgc :=_dcce .mergeBlocks (_bfg );_cgc !=nil {return _cgc ;};};return nil ;
};

// SkipOver skips over a specified number of rows and cols.
func (_acgag *Table )SkipOver (rows ,cols int ){_cbage :=rows *_acgag ._ddea +cols -1;if _cbage < 0{_cd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_acgag ._cgdg +=_cbage ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_dcff *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_dcff ._ebcf =alignment };

// SetWidthRight sets border width for right.
func (_fec *border )SetWidthRight (bw float64 ){_fec ._gccd =bw };

// GetRowHeight returns the height of the specified row.
func (_cfee *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_cfee ._ebaeg ){return 0,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _cfee ._ebaeg [row -1],nil ;
};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_dbce *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_abcdg :=range subtable ._gefca {_bfgf :=&TableCell {};*_bfgf =*_abcdg ;_bfgf ._afdae =_dbce ;_bfgf ._gcbeg +=col -1;if _agfdc :=_dbce ._ddea -(_bfgf ._gcbeg -1);_agfdc < _bfgf ._bbgdc {_dbce ._ddea +=_bfgf ._bbgdc -_agfdc ;
_dbce .resetColumnWidths ();_cd .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_dbce ._ddea );
};_bfgf ._cbfe +=row -1;_fbeab :=subtable ._ebaeg [_abcdg ._cbfe -1];if _bfgf ._cbfe > _dbce ._bfbe {for _bfgf ._cbfe > _dbce ._bfbe {_dbce ._bfbe ++;_dbce ._ebaeg =append (_dbce ._ebaeg ,_dbce ._fbeb );};_dbce ._ebaeg [_bfgf ._cbfe -1]=_fbeab ;}else {_dbce ._ebaeg [_bfgf ._cbfe -1]=_ec .Max (_dbce ._ebaeg [_bfgf ._cbfe -1],_fbeab );
};_dbce ._gefca =append (_dbce ._gefca ,_bfgf );};_dg .Slice (_dbce ._gefca ,func (_gggae ,_fgcf int )bool {_dcaff :=_dbce ._gefca [_gggae ]._cbfe ;_dcffb :=_dbce ._gefca [_fgcf ]._cbfe ;if _dcaff < _dcffb {return true ;};if _dcaff > _dcffb {return false ;
};return _dbce ._gefca [_gggae ]._gcbeg < _dbce ._gefca [_fgcf ]._gcbeg ;});};

// IsRelative checks if the positioning is relative.
func (_eae Positioning )IsRelative ()bool {return _eae ==PositionRelative };

// Length calculates and returns the line length.
func (_aefa *Line )Length ()float64 {return _ec .Sqrt (_ec .Pow (_aefa ._abbg -_aefa ._ecgb ,2.0)+_ec .Pow (_aefa ._dffe -_aefa ._effc ,2.0));};

// DrawWithContext draws the Block using the specified drawing context.
func (_gfb *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_cfd ,_ ,_daa :=d .GeneratePageBlocks (ctx );if _daa !=nil {return _daa ;};if len (_cfd )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_dde :=range _cfd {if _bdg :=_gfb .mergeBlocks (_dde );_bdg !=nil {return _bdg ;};};return nil ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_ffaa *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_adbd *_a .PdfWriter )error ){_ffaa ._aegg =pdfWriterAccessFunc ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetEnableWrap sets the line wrapping enabled flag.
func (_abdf *StyledParagraph )SetEnableWrap (enableWrap bool ){_abdf ._deac =enableWrap ;_abdf ._aecg =false ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_cee *Creator )SetPageLabels (pageLabels _db .PdfObject ){_cee ._gfgbg =pageLabels };

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_eaecf *Image )ConvertToBinary ()error {return _eaecf ._caba .ConvertToBinary ()};

// DrawHeader sets a function to draw a header on created output pages.
func (_aded *Creator )DrawHeader (drawHeaderFunc func (_ffg *Block ,_deg HeaderFunctionArgs )){_aded ._dgaf =drawHeaderFunc ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_fdef *Paragraph )SetEnableWrap (enableWrap bool ){_fdef ._dfed =enableWrap ;_fdef ._efbd =false };func (_cbag *Invoice )generateInformationBlocks (_cafb DrawContext )([]*Block ,DrawContext ,error ){_dgab :=_defdf (_cbag ._fbdc );_dgab .SetMargins (0,0,0,20);
_bcb :=_cbag .drawAddress (_cbag ._aegd );_bcb =append (_bcb ,_dgab );_bcb =append (_bcb ,_cbag .drawAddress (_cbag ._dbgg )...);_dcbec :=_gggb ();for _ ,_ebdc :=range _bcb {_dcbec .Add (_ebdc );};_dabe :=_cbag .drawInformation ();_bcge :=_gadb (2);_bcge .SetMargins (0,0,25,0);
_gdafd :=_bcge .NewCell ();_gdafd .SetIndent (0);_gdafd .SetContent (_dcbec );_gdafd =_bcge .NewCell ();_gdafd .SetContent (_dabe );return _bcge .GeneratePageBlocks (_cafb );};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_efaf *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_efaf ._bdcg =halign };func _defdf (_gbgbg TextStyle )*StyledParagraph {return &StyledParagraph {_ebae :[]*TextChunk {},_feebgf :_gbgbg ,_fefb :_dccee (_gbgbg .Font ),_cdagf :1.0,_dgcgg :TextAlignmentLeft ,_deac :true ,_aecg :true ,_gfabc :0,_befc :1,_gcae :1,_dgac :PositionRelative };
};func _bbeg (_dccea string ,_aggd _db .PdfObject ,_ecaf *_a .PdfPageResources )_db .PdfObjectName {_cgee :=_ecg .TrimRightFunc (_ecg .TrimSpace (_dccea ),func (_egff rune )bool {return _dc .IsNumber (_egff )});if _cgee ==""{_cgee ="\u0046\u006f\u006e\u0074";
};_dcd :=0;_aag :=_db .PdfObjectName (_dccea );for {_cce ,_ffd :=_ecaf .GetFontByName (_aag );if !_ffd ||_cce ==_aggd {break ;};_dcd ++;_aag =_db .PdfObjectName (_bb .Sprintf ("\u0025\u0073\u0025\u0064",_cgee ,_dcd ));};return _aag ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;
CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// GetOptimizer returns current PDF optimizer.
func (_face *Creator )GetOptimizer ()_a .Optimizer {return _face ._dfc };func _dccee (_dgcda *_a .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_dgcda ,FontSize :10,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_afbc *Invoice )AddressHeadingStyle ()TextStyle {return _afbc ._abeg };

// CurCol returns the currently active cell's column number.
func (_eaag *Table )CurCol ()int {_daac :=(_eaag ._cgdg -1)%(_eaag ._ddea )+1;return _daac };

// SetBorderWidth sets the border width.
func (_bgeb *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_bgeb ._babcf .BorderWidth =borderWidth ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_bddg *Line )SetColor (col Color ){_bddg ._gdbag =col };

// Cols returns the total number of columns the table has.
func (_ecae *Table )Cols ()int {return _ecae ._ddea };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_adbg *StyledParagraph )Insert (index uint ,text string )*TextChunk {_agfd :=uint (len (_adbg ._ebae ));if index > _agfd {index =_agfd ;};_fcff :=NewTextChunk (text ,_adbg ._feebgf );_adbg ._ebae =append (_adbg ._ebae [:index ],append ([]*TextChunk {_fcff },_adbg ._ebae [index :]...)...);
_adbg .wrapText ();return _fcff ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_aab :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_cd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _aab ;
};var _cfgd ,_eec ,_gbda int ;if len (hexStr )==4{var _gae ,_bgbd ,_ccad int ;_bbda ,_acfcf :=_bb .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_gae ,&_bgbd ,&_ccad );if _acfcf !=nil {_cd .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_acfcf );
return _aab ;};if _bbda !=3{_cd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _aab ;};_cfgd =_gae *16+_gae ;_eec =_bgbd *16+_bgbd ;_gbda =_ccad *16+_ccad ;}else {_fda ,_ggb :=_bb .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_cfgd ,&_eec ,&_gbda );
if _ggb !=nil {_cd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _aab ;};if _fda !=3{_cd .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_fda );
return _aab ;};};_gcca :=float64 (_cfgd )/255.0;_defa :=float64 (_eec )/255.0;_cfe :=float64 (_gbda )/255.0;_aab ._cbcd =_gcca ;_aab ._eadc =_defa ;_aab ._dbee =_cfe ;return _aab ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_cfef *Invoice )BuyerAddress ()*InvoiceAddress {return _cfef ._dbgg };

// Columns returns all the columns in the invoice line items table.
func (_ecdc *Invoice )Columns ()[]*InvoiceCell {return _ecdc ._afda };func _cgeed (_dbcd *_a .Image )(*Image ,error ){_edeb :=float64 (_dbcd .Width );_bfbb :=float64 (_dbcd .Height );return &Image {_caba :_dbcd ,_ecde :_edeb ,_afdea :_bfbb ,_bcdb :_edeb ,_agd :_bfbb ,_aedf :0,_bdga :1.0,_egaf :PositionRelative },nil ;
};func (_fbea *StyledParagraph )getTextHeight ()float64 {var _fbfca float64 ;for _ ,_gfbc :=range _fbea ._ebae {_dabb :=_gfbc .Style .FontSize *_fbea ._cdagf ;if _dabb > _fbfca {_fbfca =_dabb ;};};return _fbfca ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_cebg *Table )SetMargins (left ,right ,top ,bottom float64 ){_cebg ._dbbb .Left =left ;_cebg ._dbbb .Right =right ;_cebg ._dbbb .Top =top ;_cebg ._dbbb .Bottom =bottom ;};

// Append adds a new text chunk to the paragraph.
func (_deba *StyledParagraph )Append (text string )*TextChunk {_adgc :=NewTextChunk (text ,_deba ._feebgf );return _deba .appendChunk (_adgc );};

// GeneratePageBlocks implements drawable interface.
func (_efcb *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbdb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gab :=_efcb ._ddc ;_fdcf :=ctx .PageHeight -_efcb ._ecdg ;if _efcb ._baea !=nil {_bfad :=_ba .Rectangle {Opacity :1.0,X :_efcb ._ddc ,Y :ctx .PageHeight -_efcb ._ecdg -_efcb ._cagb ,Height :_efcb ._cagb ,Width :_efcb ._bbd };
_bfad .FillEnabled =true ;_bfad .FillColor =_gdg (_efcb ._baea );_bfad .BorderEnabled =false ;_bbea ,_ ,_cdb :=_bfad .Draw ("");if _cdb !=nil {return nil ,ctx ,_cdb ;};_cdb =_cbdb .addContentsByString (string (_bbea ));if _cdb !=nil {return nil ,ctx ,_cdb ;
};};_abdd :=_efcb ._dae ;_gedg :=_efcb ._cac ;_dbc :=_efcb ._fbf ;_acf :=_efcb ._gccd ;_cggf :=_efcb ._dae ;if _efcb ._ggf ==CellBorderStyleDouble {_cggf +=2*_abdd ;};_gbb :=_efcb ._cac ;if _efcb ._bgdb ==CellBorderStyleDouble {_gbb +=2*_gedg ;};_cad :=_efcb ._fbf ;
if _efcb ._bef ==CellBorderStyleDouble {_cad +=2*_dbc ;};_fgc :=_efcb ._gccd ;if _efcb ._cca ==CellBorderStyleDouble {_fgc +=2*_acf ;};if _efcb ._dae !=0{_dccef :=_gab ;_faf :=_fdcf ;if _efcb ._ggf ==CellBorderStyleDouble {_faf -=_abdd ;_bbff :=_ba .BasicLine {};
_bbff .X1 =_dccef -_cggf /2;_bbff .Y1 =_faf +2*_abdd ;_bbff .X2 =_dccef +_efcb ._bbd +_cggf /2;_bbff .Y2 =_faf +2*_abdd ;_bbff .LineColor =_gdg (_efcb ._age );_bbff .LineWidth =_efcb ._dae ;_bbff .LineStyle =_efcb .LineStyle ;_dbg ,_ ,_fafe :=_bbff .Draw ("");
if _fafe !=nil {return nil ,ctx ,_fafe ;};_fafe =_cbdb .addContentsByString (string (_dbg ));if _fafe !=nil {return nil ,ctx ,_fafe ;};};_cfg :=_ba .BasicLine {LineWidth :_efcb ._dae ,Opacity :1.0,LineColor :_gdg (_efcb ._age ),X1 :_dccef -_cggf /2+(_cad -_efcb ._fbf ),Y1 :_faf ,X2 :_dccef +_efcb ._bbd +_cggf /2-(_fgc -_efcb ._gccd ),Y2 :_faf ,LineStyle :_efcb .LineStyle };
_ggdf ,_ ,_daag :=_cfg .Draw ("");if _daag !=nil {return nil ,ctx ,_daag ;};_daag =_cbdb .addContentsByString (string (_ggdf ));if _daag !=nil {return nil ,ctx ,_daag ;};};if _efcb ._cac !=0{_defe :=_gab ;_dgfc :=_fdcf -_efcb ._cagb ;if _efcb ._bgdb ==CellBorderStyleDouble {_dgfc +=_gedg ;
_dbfe :=_ba .BasicLine {LineWidth :_efcb ._cac ,Opacity :1.0,LineColor :_gdg (_efcb ._fee ),X1 :_defe -_gbb /2,Y1 :_dgfc -2*_gedg ,X2 :_defe +_efcb ._bbd +_gbb /2,Y2 :_dgfc -2*_gedg ,LineStyle :_efcb .LineStyle };_acfb ,_ ,_ebdg :=_dbfe .Draw ("");if _ebdg !=nil {return nil ,ctx ,_ebdg ;
};_ebdg =_cbdb .addContentsByString (string (_acfb ));if _ebdg !=nil {return nil ,ctx ,_ebdg ;};};_fge :=_ba .BasicLine {LineWidth :_efcb ._cac ,Opacity :1.0,LineColor :_gdg (_efcb ._fee ),X1 :_defe -_gbb /2+(_cad -_efcb ._fbf ),Y1 :_dgfc ,X2 :_defe +_efcb ._bbd +_gbb /2-(_fgc -_efcb ._gccd ),Y2 :_dgfc ,LineStyle :_efcb .LineStyle };
_dgag ,_ ,_eedc :=_fge .Draw ("");if _eedc !=nil {return nil ,ctx ,_eedc ;};_eedc =_cbdb .addContentsByString (string (_dgag ));if _eedc !=nil {return nil ,ctx ,_eedc ;};};if _efcb ._fbf !=0{_bebc :=_gab ;_ecf :=_fdcf ;if _efcb ._bef ==CellBorderStyleDouble {_bebc +=_dbc ;
_dcbd :=_ba .BasicLine {LineWidth :_efcb ._fbf ,Opacity :1.0,LineColor :_gdg (_efcb ._ebc ),X1 :_bebc -2*_dbc ,Y1 :_ecf +_cad /2,X2 :_bebc -2*_dbc ,Y2 :_ecf -_efcb ._cagb -_cad /2,LineStyle :_efcb .LineStyle };_eddf ,_ ,_agee :=_dcbd .Draw ("");if _agee !=nil {return nil ,ctx ,_agee ;
};_agee =_cbdb .addContentsByString (string (_eddf ));if _agee !=nil {return nil ,ctx ,_agee ;};};_fbfa :=_ba .BasicLine {LineWidth :_efcb ._fbf ,Opacity :1.0,LineColor :_gdg (_efcb ._ebc ),X1 :_bebc ,Y1 :_ecf +_cad /2-(_cggf -_efcb ._dae ),X2 :_bebc ,Y2 :_ecf -_efcb ._cagb -_cad /2+(_gbb -_efcb ._cac ),LineStyle :_efcb .LineStyle };
_gggag ,_ ,_cdg :=_fbfa .Draw ("");if _cdg !=nil {return nil ,ctx ,_cdg ;};_cdg =_cbdb .addContentsByString (string (_gggag ));if _cdg !=nil {return nil ,ctx ,_cdg ;};};if _efcb ._gccd !=0{_egc :=_gab +_efcb ._bbd ;_geed :=_fdcf ;if _efcb ._cca ==CellBorderStyleDouble {_egc -=_acf ;
_gcd :=_ba .BasicLine {LineWidth :_efcb ._gccd ,Opacity :1.0,LineColor :_gdg (_efcb ._eab ),X1 :_egc +2*_acf ,Y1 :_geed +_fgc /2,X2 :_egc +2*_acf ,Y2 :_geed -_efcb ._cagb -_fgc /2,LineStyle :_efcb .LineStyle };_cafe ,_ ,_fecd :=_gcd .Draw ("");if _fecd !=nil {return nil ,ctx ,_fecd ;
};_fecd =_cbdb .addContentsByString (string (_cafe ));if _fecd !=nil {return nil ,ctx ,_fecd ;};};_baa :=_ba .BasicLine {LineWidth :_efcb ._gccd ,Opacity :1.0,LineColor :_gdg (_efcb ._eab ),X1 :_egc ,Y1 :_geed +_fgc /2-(_cggf -_efcb ._dae ),X2 :_egc ,Y2 :_geed -_efcb ._cagb -_fgc /2+(_gbb -_efcb ._cac ),LineStyle :_efcb .LineStyle };
_dccd ,_ ,_bdd :=_baa .Draw ("");if _bdd !=nil {return nil ,ctx ,_bdd ;};_bdd =_cbdb .addContentsByString (string (_dccd ));if _bdd !=nil {return nil ,ctx ,_bdd ;};};return []*Block {_cbdb },ctx ,nil ;};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_feac *Creator )AddPage (page *_a .PdfPage )error {_cea ,_bcac :=page .GetMediaBox ();if _bcac !=nil {_cd .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_bcac );
return _bcac ;};_cea .Normalize ();_dgfd ,_cgga :=_cea .Llx ,_cea .Lly ;_fgcge :=_dcb .IdentityMatrix ();_abcg :=page .Rotate ;_aaef :=_abcg !=nil &&*_abcg %360!=0&&*_abcg %90==0;if _aaef {_aea :=float64 ((360+*page .Rotate %360)%360);if _aea ==90{_fgcge =_fgcge .Translate (_cea .Width (),0);
}else if _aea ==180{_fgcge =_fgcge .Translate (_cea .Width (),_cea .Height ());}else if _aea ==270{_fgcge =_fgcge .Translate (0,_cea .Height ());};_fgcge =_fgcge .Mult (_dcb .RotationMatrix (_aea *_ec .Pi /180));_fgcge =_fgcge .Round (0.000001);_beca :=_debfb (_cea ,_fgcge );
_cea =_beca ;_cea .Normalize ();};if _dgfd !=0||_cgga !=0{_fgcge =_dcb .TranslationMatrix (_dgfd ,_cgga ).Mult (_fgcge );};if !_fgcge .Identity (){if _feac ._cagbg ==nil {_feac ._cagbg =map[*_a .PdfPage ]_dcb .Matrix {};};_fgcge =_fgcge .Round (0.000001);
_feac ._cagbg [page ]=_fgcge ;};_feac ._ddag =_cea .Width ();_feac ._bdgd =_cea .Height ();_feac .initContext ();_feac ._effg =append (_feac ._effg ,page );_feac ._aggdc .Page ++;return nil ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gced *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _gced ._bfeb [0],_gced ._bfeb [1]};func (_fdaee *StyledParagraph )split (_dbba DrawContext )(_fcce ,_afgc *StyledParagraph ,_bdee error ){if _bdee =_fdaee .wrapChunks (false );_bdee !=nil {return nil ,nil ,_bdee ;
};_effgb :=func (_dgcd []*TextChunk ,_afeg []*TextChunk )[]*TextChunk {if len (_afeg )==0{return _dgcd ;};_eaab :=len (_dgcd );if _eaab ==0{return append (_dgcd ,_afeg ...);};_dgcd [_eaab -1].Text +=_afeg [0].Text ;return append (_dgcd ,_afeg [1:]...);
};_deab :=func (_edag *StyledParagraph ,_cdgf []*TextChunk )*StyledParagraph {if len (_cdgf )==0{return nil ;};_afdeb :=*_edag ;_afdeb ._ebae =_cdgf ;return &_afdeb ;};var (_fdga float64 ;_babe []*TextChunk ;_ecbf []*TextChunk ;);for _ ,_dadd :=range _fdaee ._gffa {var _dgfbb float64 ;
_dabg :=make ([]*TextChunk ,0,len (_dadd ));for _ ,_afgae :=range _dadd {if _ggce :=_afgae .Style .FontSize ;_ggce > _dgfbb {_dgfbb =_ggce ;};_dabg =append (_dabg ,_afgae .clone ());};_dgfbb *=_fdaee ._cdagf ;if _fdaee ._dgac .IsRelative (){if _fdga +_dgfbb > _dbba .Height {_ecbf =_effgb (_ecbf ,_dabg );
}else {_babe =_effgb (_babe ,_dabg );};};_fdga +=_dgfbb ;};_fdaee ._gffa =nil ;if len (_ecbf )==0{return _fdaee ,nil ,nil ;};return _deab (_fdaee ,_babe ),_deab (_fdaee ,_ecbf ),nil ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_ebdgc *Creator )NewStyledParagraph ()*StyledParagraph {return _defdf (_ebdgc .NewTextStyle ())};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;func (_dfg *Paragraph )getTextLineWidth (_cbeac string )float64 {var _dcee float64 ;for _ ,_defae :=range _cbeac {if _defae =='\u000A'{continue ;};_ebde ,_egge :=_dfg ._deed .GetRuneMetrics (_defae );if !_egge {_cd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_defae ,_defae );
return -1;};_dcee +=_dfg ._aabf *_ebde .Wx ;};return _dcee ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_gbgg *_ba .Polygon ;_ebfc float64 ;_effdf float64 ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_ffea *Invoice )SetTerms (title ,content string ){_ffea ._dgfg =[2]string {title ,content }};

// Reset removes all the text chunks the paragraph contains.
func (_faefb *StyledParagraph )Reset (){_faefb ._ebae =[]*TextChunk {}};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_ebb *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ebb ._cagbc .Left ,_ebb ._cagbc .Right ,_ebb ._cagbc .Top ,_ebb ._cagbc .Bottom ;};

// NewTOC creates a new table of contents.
func (_gfef *Creator )NewTOC (title string )*TOC {_ccdc :=_gfef .NewTextStyle ();_ccdc .Font =_gfef ._ddd ;return _egef (title ,_gfef .NewTextStyle (),_ccdc );};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;
);

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_gfea *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _dbb (xc ,yc ,width ,height );};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_aca *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_aca ._egfg .Left =left ;_aca ._egfg .Right =right ;_aca ._egfg .Top =top ;_aca ._egfg .Bottom =bottom ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};func _gggb ()*Division {return &Division {_ggcgb :[]VectorDrawable {}}};

// SetFontSize sets the font size in document units (points).
func (_cgad *Paragraph )SetFontSize (fontSize float64 ){_cgad ._aabf =fontSize };func (_aecfb *StyledParagraph )appendChunk (_cdgad *TextChunk )*TextChunk {_aecfb ._ebae =append (_aecfb ._ebae ,_cdgad );_aecfb .wrapText ();return _cdgad ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_effg []*_a .PdfPage ;_ggcf map[*_a .PdfPage ]*Block ;_cagbg map[*_a .PdfPage ]_dcb .Matrix ;_efgb *_a .PdfPage ;_efdd PageSize ;_aggdc DrawContext ;_egfg Margins ;_ddag ,_bdgd float64 ;_egd int ;_cgge func (_fgcg FrontpageFunctionArgs );
_cbf func (_ggcg *TOC )error ;_dgaf func (_bgad *Block ,_ebfb HeaderFunctionArgs );_aaca func (_dafg *Block ,_fad FooterFunctionArgs );_dca func (_egaa PageFinalizeFunctionArgs )error ;_aegg func (_ede *_a .PdfWriter )error ;_ggbf bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_bbga *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_cgcf *_a .Outline ;_fba *_a .PdfOutlineTreeNode ;_bea *_a .PdfAcroForm ;_gfgbg _db .PdfObject ;_dfc _a .Optimizer ;_cadg []*_a .PdfFont ;_cfgf *_a .PdfFont ;_ddd *_a .PdfFont ;};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_cgfe *Creator )PageFinalize (pageFinalizeFunc func (_egcd PageFinalizeFunctionArgs )error ){_cgfe ._dca =pageFinalizeFunc ;};

// Width returns Image's document width.
func (_eabag *Image )Width ()float64 {return _eabag ._bcdb };

// NewPageBreak create a new page break.
func (_fgbe *Creator )NewPageBreak ()*PageBreak {return _bdce ()};

// SetBorderColor sets the border color for the path.
func (_dccca *FilledCurve )SetBorderColor (color Color ){_dccca ._fdeb =color };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_agdc *_ba .Polyline ;_bee float64 ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_feed float64 ;_acfbf float64 ;_bbgc float64 ;_bdcd float64 ;_acfg float64 ;_ccae float64 ;_cdaa Color ;_ecec float64 ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_ccfe *Invoice )AddressStyle ()TextStyle {return _ccfe ._dfcf };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_gcba *Creator )NewPage ()*_a .PdfPage {_gbgb :=_gcba .newPage ();_gcba ._effg =append (_gcba ._effg ,_gbgb );_gcba ._aggdc .Page ++;return _gbgb ;};func _eeed (_gdbc string )(*Image ,error ){_fga ,_egdg :=_e .Open (_gdbc );if _egdg !=nil {return nil ,_egdg ;
};defer _fga .Close ();_adeda ,_egdg :=_a .ImageHandling .Read (_fga );if _egdg !=nil {_cd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_egdg );return nil ,_egdg ;
};return _cgeed (_adeda );};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_gcb *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_gcb ._gca .Left =left ;_gcb ._gca .Right =right ;_gcb ._gca .Top =top ;_gcb ._gca .Bottom =bottom ;};

// Height returns the height of the list.
func (_gddbf *List )Height ()float64 {var _bfgb float64 ;for _ ,_debb :=range _gddbf ._bdgga {_bfgb +=_debb ._adgg .Height ();};return _bfgb ;};

// NewImageFromData creates an Image from image data.
func (_agc *Creator )NewImageFromData (data []byte )(*Image ,error ){return _cdef (data )};func (_bfd *StyledParagraph )wrapText ()error {return _bfd .wrapChunks (true )};

// SetColorLeft sets border color for left.
func (_ebe *border )SetColorLeft (col Color ){_ebe ._ebc =col };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_fdge []_ba .CubicBezierCurve ;FillEnabled bool ;_agcf Color ;BorderEnabled bool ;BorderWidth float64 ;_fdeb Color ;};func _ggdc (_dbcdb *Block ,_ddgd *StyledParagraph ,_bggf [][]*TextChunk ,_gbccb DrawContext )(DrawContext ,[][]*TextChunk ,error ){_cgaea :=1;
_gfag :=_db .PdfObjectName (_bb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cgaea ));for _dbcdb ._dcba .HasFontByName (_gfag ){_cgaea ++;_gfag =_db .PdfObjectName (_bb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cgaea ));};_eegd :=_dbcdb ._dcba .SetFontByName (_gfag ,_ddgd ._feebgf .Font .ToPdfObject ());
if _eegd !=nil {return _gbccb ,nil ,_eegd ;};_cgaea ++;_agdf :=_gfag ;_ceaec :=_ddgd ._feebgf .FontSize ;_agcd :=_ddgd ._dgac .IsRelative ();var _ceeae [][]_db .PdfObjectName ;var _egfa float64 ;var _abcba [][]*TextChunk ;var _ggea float64 ;for _agefd ,_ddbb :=range _bggf {var _fbcd []_db .PdfObjectName ;
var _eead float64 ;for _ ,_fff :=range _ddbb {_bgbcd :=_fff .Style ;if _agefd ==0&&_bgbcd .FontSize > _egfa {_egfa =_bgbcd .FontSize ;};if _bgbcd .FontSize > _eead {_eead =_bgbcd .FontSize ;};_gfag =_db .PdfObjectName (_bb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cgaea ));
_addbb :=_dbcdb ._dcba .SetFontByName (_gfag ,_bgbcd .Font .ToPdfObject ());if _addbb !=nil {return _gbccb ,nil ,_addbb ;};_fbcd =append (_fbcd ,_gfag );_cgaea ++;};_eead *=_ddgd ._cdagf ;if _agcd &&_ggea +_eead > _gbccb .Height {_abcba =_bggf [_agefd :];
_bggf =_bggf [:_agefd ];break ;};_ggea +=_eead ;_ceeae =append (_ceeae ,_fbcd );};_gad :=_bd .NewContentCreator ();_gad .Add_q ();_dgef :=_gbccb .PageHeight -_gbccb .Y -_egfa *_ddgd ._cdagf ;_gad .Translate (_gbccb .X ,_dgef );_ccag :=_dgef ;if _ddgd ._gfabc !=0{_gad .RotateDeg (_ddgd ._gfabc );
};if _ddgd ._aeba ==TextOverflowHidden {_dcdf ,_ :=_ddgd .getLineHeight (0);_gad .Add_re (0,-_ggea +_dcdf +1,_ddgd ._afgd ,_ggea ).Add_W ().Add_n ();};_gad .Add_BT ();var _gbag []*_ba .BasicLine ;for _gffe ,_ddcbf :=range _bggf {_ebfbf :=_gbccb .X ;if _gffe !=0{_gad .Add_Tstar ();
};_bgbaf :=_gffe ==len (_bggf )-1;var (_bceg float64 ;_dbfee float64 ;_accge float64 ;_bagg uint ;);var _eedf []float64 ;for _ ,_ebbf :=range _ddcbf {_addg :=&_ebbf .Style ;if _addg .FontSize > _dbfee {_dbfee =_addg .FontSize ;};_gagf ,_ada :=_addg .Font .GetRuneMetrics (' ');
if !_ada {return _gbccb ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _dbca uint ;var _dacg float64 ;_edcc :=len (_ebbf .Text );
for _eac ,_egeb :=range _ebbf .Text {if _egeb ==' '{_dbca ++;continue ;};if _egeb =='\u000A'{continue ;};_adfd ,_dbed :=_addg .Font .GetRuneMetrics (_egeb );if !_dbed {_cd .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_egeb );
return _gbccb ,nil ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dacg +=_addg .FontSize *_adfd .Wx ;if _eac !=_edcc -1{_dacg +=_addg .CharSpacing *1000.0;};};_eedf =append (_eedf ,_dacg );
_bceg +=_dacg ;_accge +=float64 (_dbca )*_gagf .Wx *_addg .FontSize ;_bagg +=_dbca ;};_dbfee *=_ddgd ._cdagf ;var _dacc []_db .PdfObject ;_eaee :=_ddgd ._afgd *1000.0;if _ddgd ._dgcgg ==TextAlignmentJustify {if _bagg > 0&&!_bgbaf {_accge =(_eaee -_bceg )/float64 (_bagg )/_ceaec ;
};}else if _ddgd ._dgcgg ==TextAlignmentCenter {_dbea :=(_eaee -_bceg -_accge )/2;_ddfcg :=_dbea /_ceaec ;_dacc =append (_dacc ,_db .MakeFloat (-_ddfcg ));_ebfbf +=_dbea /1000.0;}else if _ddgd ._dgcgg ==TextAlignmentRight {_agcc :=(_eaee -_bceg -_accge );
_agdfg :=_agcc /_ceaec ;_dacc =append (_dacc ,_db .MakeFloat (-_agdfg ));_ebfbf +=_agcc /1000.0;};if len (_dacc )> 0{_gad .Add_Tf (_agdf ,_ceaec ).Add_TL (_ceaec *_ddgd ._cdagf ).Add_TJ (_dacc ...);};var _bbegf float64 ;for _fbdce ,_adebd :=range _ddcbf {_bffg :=&_adebd .Style ;
if _bffg .FontSize > _bbegf {_bbegf =_bffg .FontSize ;};_cafc :=_agdf ;_dgdf :=_ceaec ;_dfdc :=_bffg .OutlineColor !=nil ;_bcdcc :=_bffg .OutlineSize !=1;if _bcdcc {_gad .Add_w (_bffg .OutlineSize );};_bdgdg :=_bffg .RenderingMode !=TextRenderingModeFill ;
if _bdgdg {_gad .Add_Tr (int64 (_bffg .RenderingMode ));};_abcd :=_bffg .CharSpacing !=0;if _abcd {_gad .Add_Tc (_bffg .CharSpacing );};_gbdeb :=_bffg .TextRise !=0;if _gbdeb {_gad .Add_Ts (_bffg .TextRise );};if _ddgd ._dgcgg !=TextAlignmentJustify ||_bgbaf {_bacb ,_addbd :=_bffg .Font .GetRuneMetrics (' ');
if !_addbd {return _gbccb ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_cafc =_ceeae [_gffe ][_fbdce ];_dgdf =_bffg .FontSize ;
_accge =_bacb .Wx ;};_acfd :=_bffg .Font .Encoder ();var _feeg []byte ;for _ ,_bcagd :=range _adebd .Text {if _bcagd =='\u000A'{continue ;};if _bcagd ==' '{if len (_feeg )> 0{if _dfdc {_gad .SetStrokingColor (_gdg (_bffg .OutlineColor ));};_gad .SetNonStrokingColor (_gdg (_bffg .Color )).Add_Tf (_ceeae [_gffe ][_fbdce ],_bffg .FontSize ).Add_TJ ([]_db .PdfObject {_db .MakeStringFromBytes (_feeg )}...);
_feeg =nil ;};_gad .Add_Tf (_cafc ,_dgdf ).Add_TJ ([]_db .PdfObject {_db .MakeFloat (-_accge )}...);_eedf [_fbdce ]+=_accge *_dgdf ;}else {if _ ,_egee :=_acfd .RuneToCharcode (_bcagd );!_egee {_cd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bcagd ,_bcagd );
continue ;};_feeg =append (_feeg ,_acfd .Encode (string (_bcagd ))...);};};if len (_feeg )> 0{if _dfdc {_gad .SetStrokingColor (_gdg (_bffg .OutlineColor ));};_gad .SetNonStrokingColor (_gdg (_bffg .Color )).Add_Tf (_ceeae [_gffe ][_fbdce ],_bffg .FontSize ).Add_TJ ([]_db .PdfObject {_db .MakeStringFromBytes (_feeg )}...);
};_bacg :=_eedf [_fbdce ]/1000.0;if _bffg .Underline {_gdafa :=_bffg .UnderlineStyle .Color ;if _gdafa ==nil {_gdafa =_adebd .Style .Color ;};_fcceg ,_ggdde ,_aebd :=_gdafa .ToRGB ();_fdeg :=_ebfbf -_gbccb .X ;_eceg :=_ccag -_dgef +_bffg .TextRise -_bffg .UnderlineStyle .Offset ;
_gbag =append (_gbag ,&_ba .BasicLine {X1 :_fdeg ,Y1 :_eceg ,X2 :_fdeg +_bacg ,Y2 :_eceg ,LineWidth :_adebd .Style .UnderlineStyle .Thickness ,LineColor :_a .NewPdfColorDeviceRGB (_fcceg ,_ggdde ,_aebd )});};if _adebd ._fbdg !=nil {var _eacf *_db .PdfObjectArray ;
if !_adebd ._bacgf {switch _bggeg :=_adebd ._fbdg .GetContext ().(type ){case *_a .PdfAnnotationLink :_eacf =_db .MakeArray ();_bggeg .Rect =_eacf ;_gacbd ,_bedf :=_bggeg .Dest .(*_db .PdfObjectArray );if _bedf &&_gacbd .Len ()==5{_gfae ,_gggd :=_gacbd .Get (1).(*_db .PdfObjectName );
if _gggd &&_gfae .String ()=="\u0058\u0059\u005a"{_fcfgf ,_abgc :=_db .GetNumberAsFloat (_gacbd .Get (3));if _abgc ==nil {_gacbd .Set (3,_db .MakeFloat (_gbccb .PageHeight -_fcfgf ));};};};};_adebd ._bacgf =true ;};if _eacf !=nil {_ebfbfd :=_ba .NewPoint (_ebfbf -_gbccb .X ,_ccag +_bffg .TextRise -_dgef ).Rotate (_ddgd ._gfabc );
_ebfbfd .X +=_gbccb .X ;_ebfbfd .Y +=_dgef ;_dage ,_gfeb ,_cffe ,_bfea :=_degf (_bacg ,_dbfee ,_ddgd ._gfabc );_ebfbfd .X +=_dage ;_ebfbfd .Y +=_gfeb ;_eacf .Clear ();_eacf .Append (_db .MakeFloat (_ebfbfd .X ));_eacf .Append (_db .MakeFloat (_ebfbfd .Y ));
_eacf .Append (_db .MakeFloat (_ebfbfd .X +_cffe ));_eacf .Append (_db .MakeFloat (_ebfbfd .Y +_bfea ));};_dbcdb .AddAnnotation (_adebd ._fbdg );};_ebfbf +=_bacg ;if _bcdcc {_gad .Add_w (1.0);};if _dfdc {_gad .Add_RG (0.0,0.0,0.0);};if _bdgdg {_gad .Add_Tr (int64 (TextRenderingModeFill ));
};if _abcd {_gad .Add_Tc (0);};if _gbdeb {_gad .Add_Ts (0);};};_gad .Add_TL (_bbegf *_ddgd ._cdagf );_ccag -=_dbfee ;};_gad .Add_ET ();for _ ,_gbea :=range _gbag {_gad .SetStrokingColor (_gbea .LineColor ).Add_w (_gbea .LineWidth ).Add_m (_gbea .X1 ,_gbea .Y1 ).Add_l (_gbea .X2 ,_gbea .Y2 ).Add_s ();
};_gad .Add_Q ();_gaeb :=_gad .Operations ();_gaeb .WrapIfNeeded ();_dbcdb .addContents (_gaeb );if _agcd {_fabf :=_ggea +_ddgd ._bacc .Bottom ;_gbccb .Y +=_fabf ;_gbccb .Height -=_fabf ;if _gbccb .Inline {_gbccb .X +=_ddgd .Width ()+_ddgd ._bacc .Right ;
};};return _gbccb ,_abcba ,nil ;};func _fbec ()*FilledCurve {_bdgf :=FilledCurve {};_bdgf ._fdge =[]_ba .CubicBezierCurve {};return &_bdgf ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_ffac *TOC )SetLineNumberStyle (style TextStyle ){_ffac ._bgcdd =style };

// SetLineHeight sets the line height (1.0 default).
func (_fadc *Paragraph )SetLineHeight (lineheight float64 ){_fadc ._eag =lineheight };func _ggcdb (_fccg int64 ,_acda ,_ggfc ,_fgbc float64 )*_a .PdfAnnotation {_bcdgd :=_a .NewPdfAnnotationLink ();_aaae :=_a .NewBorderStyle ();_aaae .SetBorderWidth (0);
_bcdgd .BS =_aaae .ToPdfObject ();if _fccg < 0{_fccg =0;};_bcdgd .Dest =_db .MakeArray (_db .MakeInteger (_fccg ),_db .MakeName ("\u0058\u0059\u005a"),_db .MakeFloat (_acda ),_db .MakeFloat (_ggfc ),_db .MakeFloat (_fgbc ));return _bcdgd .PdfAnnotation ;
};func _egfb (_ffe ,_gfgb ,_ddb ,_edd float64 )*border {_ffcg :=&border {};_ffcg ._ddc =_ffe ;_ffcg ._ecdg =_gfgb ;_ffcg ._bbd =_ddb ;_ffcg ._cagb =_edd ;_ffcg ._age =ColorBlack ;_ffcg ._fee =ColorBlack ;_ffcg ._ebc =ColorBlack ;_ffcg ._eab =ColorBlack ;
_ffcg ._dae =0;_ffcg ._cac =0;_ffcg ._fbf =0;_ffcg ._gccd =0;_ffcg .LineStyle =_ba .LineStyleSolid ;return _ffcg ;};

// Inline returns whether the inline mode of the division is active.
func (_ceec *Division )Inline ()bool {return _ceec ._gfbf };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_aabd *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_aabd ._aeba =textOverflow };

// SetSideBorderColor sets the cell's side border color.
func (_gfefc *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_gfefc ._gdda =col ;case CellBorderSideBottom :_gfefc ._egbe =col ;case CellBorderSideLeft :_gfefc ._accb =col ;case CellBorderSideRight :_gfefc ._acga =col ;
};};func _gbcf (_bbdag *Block ,_cedda *Paragraph ,_gaf DrawContext )(DrawContext ,error ){_dbcf :=1;_ebdde :=_db .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ff .Itoa (_dbcf ));for _bbdag ._dcba .HasFontByName (_ebdde ){_dbcf ++;_ebdde =_db .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ff .Itoa (_dbcf ));
};_cdbg :=_bbdag ._dcba .SetFontByName (_ebdde ,_cedda ._deed .ToPdfObject ());if _cdbg !=nil {return _gaf ,_cdbg ;};_cedda .wrapText ();_fcdc :=_bd .NewContentCreator ();_fcdc .Add_q ();_ecge :=_gaf .PageHeight -_gaf .Y -_cedda ._aabf *_cedda ._eag ;_fcdc .Translate (_gaf .X ,_ecge );
if _cedda ._fcfg !=0{_fcdc .RotateDeg (_cedda ._fcfg );};_fcdc .Add_BT ().SetNonStrokingColor (_gdg (_cedda ._bcdg )).Add_Tf (_ebdde ,_cedda ._aabf ).Add_TL (_cedda ._aabf *_cedda ._eag );for _dadgc ,_fddgg :=range _cedda ._fgff {if _dadgc !=0{_fcdc .Add_Tstar ();
};_fcad :=[]rune (_fddgg );_bfge :=0.0;_fage :=0;for _faa ,_ecfb :=range _fcad {if _ecfb ==' '{_fage ++;continue ;};if _ecfb =='\u000A'{continue ;};_gfbg ,_gaa :=_cedda ._deed .GetRuneMetrics (_ecfb );if !_gaa {_cd .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_faa ,_ecfb ,_ecfb ,_cedda ._deed .BaseFont (),_cedda ._deed .Subtype ());
return _gaf ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bfge +=_cedda ._aabf *_gfbg .Wx ;};var _afae []_db .PdfObject ;_acef ,_dbec :=_cedda ._deed .GetRuneMetrics (' ');
if !_dbec {return _gaf ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_eccf :=_acef .Wx ;switch _cedda ._gfbfb {case TextAlignmentJustify :if _fage > 0&&_dadgc < len (_cedda ._fgff )-1{_eccf =(_cedda ._agab *1000.0-_bfge )/float64 (_fage )/_cedda ._aabf ;
};case TextAlignmentCenter :_gdafb :=_bfge +float64 (_fage )*_eccf *_cedda ._aabf ;_fcdfg :=(_cedda ._agab *1000.0-_gdafb )/2/_cedda ._aabf ;_afae =append (_afae ,_db .MakeFloat (-_fcdfg ));case TextAlignmentRight :_eccd :=_bfge +float64 (_fage )*_eccf *_cedda ._aabf ;
_fdgd :=(_cedda ._agab *1000.0-_eccd )/_cedda ._aabf ;_afae =append (_afae ,_db .MakeFloat (-_fdgd ));};_bgcd :=_cedda ._deed .Encoder ();var _ceae []byte ;for _ ,_ddfcf :=range _fcad {if _ddfcf =='\u000A'{continue ;};if _ddfcf ==' '{if len (_ceae )> 0{_afae =append (_afae ,_db .MakeStringFromBytes (_ceae ));
_ceae =nil ;};_afae =append (_afae ,_db .MakeFloat (-_eccf ));}else {if _ ,_bggd :=_bgcd .RuneToCharcode (_ddfcf );!_bggd {_cd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ddfcf ,_ddfcf );
continue ;};_ceae =append (_ceae ,_bgcd .Encode (string (_ddfcf ))...);};};if len (_ceae )> 0{_afae =append (_afae ,_db .MakeStringFromBytes (_ceae ));};_fcdc .Add_TJ (_afae ...);};_fcdc .Add_ET ();_fcdc .Add_Q ();_bfcc :=_fcdc .Operations ();_bfcc .WrapIfNeeded ();
_bbdag .addContents (_bfcc );if _cedda ._dfcfe .IsRelative (){_bgbdf :=_cedda .Height ()+_cedda ._fcfba .Bottom ;_gaf .Y +=_bgbdf ;_gaf .Height -=_bgbdf ;if _gaf .Inline {_gaf .X +=_cedda .Width ()+_cedda ._fcfba .Right ;};};return _gaf ,nil ;};

// SetText sets the text content of the Paragraph.
func (_adba *Paragraph )SetText (text string ){_adba ._cgfeg =text };

// SetBorderColor sets the border color.
func (_afeee *CurvePolygon )SetBorderColor (color Color ){_afeee ._dagf .BorderColor =_gdg (color )};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_gdbac *Division )Add (d VectorDrawable )error {switch _gbcc :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image :case containerDrawable :_cedd ,_gcbag :=_gbcc .ContainerComponent (_gdbac );if _gcbag !=nil {return _gcbag ;};_bbcb ,_gcag :=_cedd .(VectorDrawable );
if !_gcag {return _bb .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_cedd );
};d =_bbcb ;default:return _f .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gdbac ._ggcgb =append (_gdbac ._ggcgb ,d );return nil ;};const (PositionRelative Positioning =iota ;
PositionAbsolute ;);

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_cbcd :float64 (r )/255.0,_eadc :float64 (g )/255.0,_dbee :float64 (b )/255.0};};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ege *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _ege ._beag [0],_ege ._beag [1]};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SkipCells skips over a specified number of cells in the table.
func (_bcgdg *Table )SkipCells (num int ){if num < 0{_cd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_bcgdg ._cgdg +=num ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_ceaa *Image )SetWidth (w float64 ){_ceaa ._bcdb =w };

// Height returns the total height of all rows.
func (_aagfb *Table )Height ()float64 {_gdbab :=float64 (0.0);for _ ,_fgaa :=range _aagfb ._ebaeg {_gdbab +=_fgaa ;};return _gdbab ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_dege *Invoice )SetColumns (cols []*InvoiceCell ){_dege ._afda =cols };

// SetFillOpacity sets the fill opacity.
func (_fegc *PolyBezierCurve )SetFillOpacity (opacity float64 ){_fegc ._afdfb =opacity };

// SetBorderOpacity sets the border opacity.
func (_gbgdf *Rectangle )SetBorderOpacity (opacity float64 ){_gbgdf ._bed =opacity };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_eba *Invoice )Terms ()(string ,string ){return _eba ._dgfg [0],_eba ._dgfg [1]};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_bcce *TOCLine )SetLink (page int64 ,x ,y float64 ){_bcce ._gbfe =x ;_bcce ._cabb =y ;_bcce ._fbbe =page ;_egdb :=_bcce ._gcgg ._fefb .Color ;_bcce .Number .Style .Color =_egdb ;_bcce .Title .Style .Color =_egdb ;_bcce .Separator .Style .Color =_egdb ;
_bcce .Page .Style .Color =_egdb ;};func (_gbg *Chapter )headingText ()string {_eege :=_gbg ._cbe ;if _add :=_gbg .headingNumber ();_add !=""{_eege =_bb .Sprintf ("\u0025\u0073\u0020%\u0073",_add ,_eege );};return _eege ;};

// SetBorderOpacity sets the border opacity.
func (_bffc *CurvePolygon )SetBorderOpacity (opacity float64 ){_bffc ._eegc =opacity };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_dgdc *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgdc ._fcfba .Left ,_dgdc ._fcfba .Right ,_dgdc ._fcfba .Top ,_dgdc ._fcfba .Bottom ;};

// SetBorderColor sets the cell's border color.
func (_bbgb *TableCell )SetBorderColor (col Color ){_bbgb ._accb =col ;_bbgb ._egbe =col ;_bbgb ._acga =col ;_bbgb ._gdda =col ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_cgfeg string ;_deed *_a .PdfFont ;_aabf float64 ;_eag float64 ;_bcdg Color ;_gfbfb TextAlignment ;_dfed bool ;_agab float64 ;_bage int ;_efbd bool ;_fcfg float64 ;_fcfba Margins ;_dfcfe Positioning ;_baac float64 ;_eabbd float64 ;
_dcge ,_eabae float64 ;_fgff []string ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_fddg *Division )Height ()float64 {var _gfgd float64 ;for _ ,_ffgc :=range _fddg ._ggcgb {switch _eecg :=_ffgc .(type ){case *Paragraph :_gfgd +=_eecg .Height ()+_eecg ._fcfba .Top +_eecg ._fcfba .Bottom ;case *StyledParagraph :_gfgd +=_eecg .Height ()+_eecg ._bacc .Top +_eecg ._bacc .Bottom ;
default:_gfgd +=_eecg .Height ();};};return _gfgd ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_gfbdf Color ;_deae _ba .LineStyle ;_fgdc CellBorderStyle ;_accb Color ;_bedgc float64 ;_cfeed CellBorderStyle ;_egbe Color ;_bbge float64 ;_bffcb CellBorderStyle ;_acga Color ;_ebge float64 ;_dgegd CellBorderStyle ;_gdda Color ;_acbf float64 ;
_cbfe ,_gcbeg int ;_fbbb int ;_bbgdc int ;_efcga VectorDrawable ;_bdcg CellHorizontalAlignment ;_fcb CellVerticalAlignment ;_ggabd float64 ;_afdae *Table ;};type listItem struct{_adgg VectorDrawable ;_eaf TextChunk ;};func _cfaec (_ddfe ,_cfefb ,_cdfg TextChunk ,_adgcd uint ,_faee TextStyle )*TOCLine {_gefcc :=_defdf (_faee );
_gefcc .SetEnableWrap (true );_gefcc .SetTextAlignment (TextAlignmentLeft );_gefcc .SetMargins (0,0,2,2);_cffg :=&TOCLine {_gcgg :_gefcc ,Number :_ddfe ,Title :_cfefb ,Page :_cdfg ,Separator :TextChunk {Text :"\u002e",Style :_faee },_egcgf :0,_bdbdd :_adgcd ,_egag :10,_fbed :PositionRelative };
_gefcc ._bacc .Left =_cffg ._egcgf +float64 (_cffg ._bdbdd -1)*_cffg ._egag ;_gefcc ._cfca =_cffg .prepareParagraph ;return _cffg ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_bfbd *Paragraph )SetMaxLines (maxLines int ){_bfbd ._bage =maxLines ;_bfbd .wrapText ()};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_bggge *StyledParagraph )SetTextAlignment (align TextAlignment ){_bggge ._dgcgg =align };

// SetBorderOpacity sets the border opacity.
func (_ccbd *Polygon )SetBorderOpacity (opacity float64 ){_ccbd ._effdf =opacity };

// SetLevel sets the indentation level of the TOC line.
func (_gdbcc *TOCLine )SetLevel (level uint ){_gdbcc ._bdbdd =level ;_gdbcc ._gcgg ._bacc .Left =_gdbcc ._egcgf +float64 (_gdbcc ._bdbdd -1)*_gdbcc ._egag ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_dabcb *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_cbga :=[2]*InvoiceCell {_dabcb .newCell (description ,_dabcb ._gdaf ),_dabcb .newCell (value ,_dabcb ._gdaf )};_dabcb ._bfga =append (_dabcb ._bfga ,_cbga );return _cbga [0],_cbga [1];
};

// Notes returns the notes section of the invoice as a title-content pair.
func (_acge *Invoice )Notes ()(string ,string ){return _acge ._bced [0],_acge ._bced [1]};

// NewList creates a new list.
func (_eddb *Creator )NewList ()*List {return _edfa (_eddb .NewTextStyle ())};

// SetAnnotation sets a annotation on a TextChunk.
func (_bdec *TextChunk )SetAnnotation (annotation *_a .PdfAnnotation ){_bdec ._fbdg =annotation };

// Heading returns the heading component of the table of contents.
func (_aebaa *TOC )Heading ()*StyledParagraph {return _aebaa ._gfgf };

// SetBorderColor sets the border color.
func (_gcf *Ellipse )SetBorderColor (col Color ){_gcf ._gcab =col };

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_bfbe int ;_ddea int ;_cgdg int ;_efbga []float64 ;_ebaeg []float64 ;_fbeb float64 ;_gefca []*TableCell ;_gfad Positioning ;_gdfef ,_fdfac float64 ;_dbbb Margins ;_gefd bool ;_cgdb int ;_gace int ;_eegf bool ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_gebd *Image )ScaleToWidth (w float64 ){_bac :=_gebd ._agd /_gebd ._bcdb ;_gebd ._bcdb =w ;_gebd ._agd =w *_bac ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_decc *Paragraph )SetWidth (width float64 ){_decc ._agab =width ;_decc .wrapText ()};

// TOC returns the table of contents component of the creator.
func (_aafc *Creator )TOC ()*TOC {return _aafc ._bbga };

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_ace *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egba :=_ba .Line {LineWidth :_ace ._bgbc ,Opacity :1.0,LineColor :_gdg (_ace ._gdbag ),LineEndingStyle1 :_ba .LineEndingStyleNone ,LineEndingStyle2 :_ba .LineEndingStyleNone ,X1 :_ace ._ecgb ,Y1 :ctx .PageHeight -_ace ._effc ,X2 :_ace ._abbg ,Y2 :ctx .PageHeight -_ace ._dffe };
_eefc ,_ ,_cdea :=_egba .Draw ("");if _cdea !=nil {return nil ,ctx ,_cdea ;};_cdea =_bbde .addContentsByString (string (_eefc ));if _cdea !=nil {return nil ,ctx ,_cdea ;};return []*Block {_bbde },ctx ,nil ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_babc *Creator )SetOutlineTree (outlineTree *_a .PdfOutlineTreeNode ){_babc ._fba =outlineTree };func _feecf (_aaee ,_gdf ,_abaac ,_gdeg ,_bcc ,_ffcd float64 )*Curve {_fae :=&Curve {};_fae ._feed =_aaee ;_fae ._acfbf =_gdf ;_fae ._bbgc =_abaac ;_fae ._bdcd =_gdeg ;
_fae ._acfg =_bcc ;_fae ._ccae =_ffcd ;_fae ._cdaa =ColorBlack ;_fae ._ecec =1.0;return _fae ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_dee *Creator )MoveDown (dy float64 ){_dee ._aggdc .Y +=dy };

// NewImage create a new image from a unidoc image (model.Image).
func (_aafb *Creator )NewImage (img *_a .Image )(*Image ,error ){return _cgeed (img )};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_fabe *Creator )NewParagraph (text string )*Paragraph {return _gfdd (text ,_fabe .NewTextStyle ())};

// Angle returns the block rotation angle in degrees.
func (_ea *Block )Angle ()float64 {return _ea ._cag };

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Scale scales Image by a constant factor, both width and height.
func (_bebb *Image )Scale (xFactor ,yFactor float64 ){_bebb ._bcdb =xFactor *_bebb ._bcdb ;_bebb ._agd =yFactor *_bebb ._agd ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bcdf *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _bcdf ._dbdg [0],_bcdf ._dbdg [1]};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_gffeb *TOC )SetLineStyle (style TextStyle ){_gffeb .SetLineNumberStyle (style );_gffeb .SetLineTitleStyle (style );_gffeb .SetLineSeparatorStyle (style );_gffeb .SetLinePageStyle (style );};

// SetFillColor sets the fill color.
func (_abdgd *PolyBezierCurve )SetFillColor (color Color ){_abdgd ._babcf .FillColor =_gdg (color )};

// SetLineWidth sets the line width.
func (_aedfd *Polyline )SetLineWidth (lineWidth float64 ){_aedfd ._agdc .LineWidth =lineWidth };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_fbd *Chapter )SetIncludeInTOC (includeInTOC bool ){_fbd ._cdf =includeInTOC };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_cggbd *StyledParagraph )SetWidth (width float64 ){_cggbd ._afgd =width ;_cggbd .wrapText ()};

// SetDate sets the date of the invoice.
func (_aeac *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_aeac ._ddca [1].Value =date ;return _aeac ._ddca [0],_aeac ._ddca [1];};func (_fccd *Table )newCell (_ceee int )*TableCell {_fccd ._cgdg ++;_gggdg :=(_fccd ._cgdg -1)/_fccd ._ddea +1;
for _gggdg > _fccd ._bfbe {_fccd ._bfbe ++;_fccd ._ebaeg =append (_fccd ._ebaeg ,_fccd ._fbeb );};_afce :=(_fccd ._cgdg -1)%(_fccd ._ddea )+1;_aebdb :=&TableCell {};_aebdb ._cbfe =_gggdg ;_aebdb ._gcbeg =_afce ;_aebdb ._fbbb =1;_aebdb ._ggabd =5;_aebdb ._fgdc =CellBorderStyleNone ;
_aebdb ._deae =_ba .LineStyleSolid ;_aebdb ._bdcg =CellHorizontalAlignmentLeft ;_aebdb ._fcb =CellVerticalAlignmentTop ;_aebdb ._bedgc =0;_aebdb ._bbge =0;_aebdb ._ebge =0;_aebdb ._acbf =0;_ccgb :=ColorBlack ;_aebdb ._accb =_ccgb ;_aebdb ._egbe =_ccgb ;
_aebdb ._acga =_ccgb ;_aebdb ._gdda =_ccgb ;if _ceee < 1{_cd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_ceee );
_ceee =1;};_fgee :=_fccd ._ddea -(_aebdb ._gcbeg -1);if _ceee > _fgee {_cd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_ceee ,_fgee );
_ceee =_fgee ;};_aebdb ._bbgdc =_ceee ;_fccd ._cgdg +=_ceee -1;_fccd ._gefca =append (_fccd ._gefca ,_aebdb );_aebdb ._afdae =_fccd ;return _aebdb ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_eddc *Creator )NewTextStyle ()TextStyle {return _eeeeg (_eddc ._cfgf )};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_acg *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _acg ._cdd .Left ,_acg ._cdd .Right ,_acg ._cdd .Top ,_acg ._cdd .Bottom ;};func (_ggg *Block )drawToPage (_cbd *_a .PdfPage )error {_ggc :=&_bd .ContentStreamOperations {};if _cbd .Resources ==nil {_cbd .Resources =_a .NewPdfPageResources ();
};_eb :=_cbb (_ggc ,_cbd .Resources ,_ggg ._ef ,_ggg ._dcba );if _eb !=nil {return _eb ;};if _eb =_afg (_ggg ._dcba ,_cbd .Resources );_eb !=nil {return _eb ;};if _eb =_cbd .AppendContentBytes (_ggc .Bytes (),true );_eb !=nil {return _eb ;};for _ ,_dba :=range _ggg ._bgg {_cbd .AddAnnotation (_dba );
};return nil ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_bge :_ec .Min (float64 (c ),100)/100.0,_gbdf :_ec .Min (float64 (m ),100)/100.0,_gec :_ec .Min (float64 (y ),100)/100.0,_ecfab :_ec .Min (float64 (k ),100)/100.0};};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_dag *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_dag ._bbga =toc ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_dbde *Creator )NewChapter (title string )*Chapter {_dbde ._egd ++;_ffda :=_dbde .NewTextStyle ();_ffda .FontSize =16;return _ceb (nil ,_dbde ._bbga ,_dbde ._cgcf ,title ,_dbde ._egd ,_ffda );};type rgbColor struct{_cbcd ,_eadc ,_dbee float64 };

// SetSubtotal sets the subtotal of the invoice.
func (_aedg *Invoice )SetSubtotal (value string ){_aedg ._beag [1].Value =value };func _degc (_dbbc ,_baggg ,_edcb string ,_fefdc uint ,_ccfcd TextStyle )*TOCLine {return _cfaec (TextChunk {Text :_dbbc ,Style :_ccfcd },TextChunk {Text :_baggg ,Style :_ccfcd },TextChunk {Text :_edcb ,Style :_ccfcd },_fefdc ,_ccfcd );
};

// SetStyleLeft sets border style for left side.
func (_babg *border )SetStyleLeft (style CellBorderStyle ){_babg ._bef =style };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);
ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););func (_gfgga *StyledParagraph )getTextWidth ()float64 {var _egcf float64 ;_gbad :=len (_gfgga ._ebae );for _bcdgb ,_edbb :=range _gfgga ._ebae {_gbddb :=&_edbb .Style ;
_cdda :=len (_edbb .Text );for _efcg ,_adcd :=range _edbb .Text {if _adcd =='\u000A'{continue ;};_facfe ,_dcec :=_gbddb .Font .GetRuneMetrics (_adcd );if !_dcec {_cd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_adcd );
return -1;};_egcf +=_gbddb .FontSize *_facfe .Wx ;if _adcd !=' '&&(_bcdgb !=_gbad -1||_efcg !=_cdda -1){_egcf +=_gbddb .CharSpacing *1000.0;};};};return _egcf ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;
);func (_ffga *Invoice )drawSection (_fbcg ,_dcdd string )[]*StyledParagraph {var _cbdbd []*StyledParagraph ;if _fbcg !=""{_aef :=_defdf (_ffga ._ddbfc );_aef .SetMargins (0,0,0,5);_aef .Append (_fbcg );_cbdbd =append (_cbdbd ,_aef );};if _dcdd !=""{_cgdc :=_defdf (_ffga ._ddabf );
_cgdc .Append (_dcdd );_cbdbd =append (_cbdbd ,_cgdc );};return _cbdbd ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_cccc *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_eeedc :=uint (len (_cccc ._afda ));if index > _eeedc {index =_eeedc ;};_ggeg :=_cccc .NewColumn (description );_cccc ._afda =append (_cccc ._afda [:index ],append ([]*InvoiceCell {_ggeg },_cccc ._afda [index :]...)...);
return _ggeg ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_a .PdfPage )(*Block ,error ){_ad :=&Block {};_ed ,_de :=page .GetAllContentStreams ();if _de !=nil {return nil ,_de ;};_eg :=_bd .NewContentStreamParser (_ed );_ae ,_de :=_eg .Parse ();if _de !=nil {return nil ,_de ;};_ae .WrapIfNeeded ();
_ad ._ef =_ae ;if page .Resources !=nil {_ad ._dcba =page .Resources ;}else {_ad ._dcba =_a .NewPdfPageResources ();};_af ,_de :=page .GetMediaBox ();if _de !=nil {return nil ,_de ;};if _af .Llx !=0||_af .Lly !=0{_ad .translate (-_af .Llx ,_af .Lly );};
_ad ._fc =_af .Urx -_af .Llx ;_ad ._gd =_af .Ury -_af .Lly ;if page .Rotate !=nil {_ad ._cag =-float64 (*page .Rotate );};return _ad ,nil ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_fdd *Chapter )NewSubchapter (title string )*Chapter {_ade :=_eeeeg (_fdd ._df ._deed );_ade .FontSize =14;_fdd ._fdcc ++;_fbcc :=_ceb (_fdd ,_fdd ._ddab ,_fdd ._accg ,title ,_fdd ._fdcc ,_ade );_fdd .Add (_fbcc );return _fbcc ;};

// SetInline sets the inline mode of the division.
func (_gfdf *Division )SetInline (inline bool ){_gfdf ._gfbf =inline };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_baee *StyledParagraph )Height ()float64 {_baee .wrapText ();var _dccf float64 ;for _ ,_gbgc :=range _baee ._gffa {var _bbag float64 ;for _ ,_ddgc :=range _gbgc {_gceg :=_baee ._cdagf *_ddgc .Style .FontSize ;if _gceg > _bbag {_bbag =_gceg ;};};_dccf +=_bbag ;
};return _dccf ;};

// AddSection adds a new content section at the end of the invoice.
func (_dgbb *Invoice )AddSection (title ,content string ){_dgbb ._bcg =append (_dgbb ._bcg ,[2]string {title ,content });};

// SetStyleTop sets border style for top side.
func (_acc *border )SetStyleTop (style CellBorderStyle ){_acc ._ggf =style };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_eff *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eff ._gca .Left ,_eff ._gca .Right ,_eff ._gca .Top ,_eff ._gca .Bottom ;};

// IsAbsolute checks if the positioning is absolute.
func (_cgd Positioning )IsAbsolute ()bool {return _cgd ==PositionAbsolute };

// SetBorderWidth sets the border width.
func (_bbgf *Rectangle )SetBorderWidth (bw float64 ){_bbgf ._aacgg =bw };

// DrawFooter sets a function to draw a footer on created output pages.
func (_fbe *Creator )DrawFooter (drawFooterFunc func (_efbc *Block ,_fbbf FooterFunctionArgs )){_fbe ._aaca =drawFooterFunc ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_gee *Block )SetMargins (left ,right ,top ,bottom float64 ){_gee ._cdd .Left =left ;_gee ._cdd .Right =right ;_gee ._cdd .Top =top ;_gee ._cdd .Bottom =bottom ;};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_cefbg *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adgb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcfc ,_ebdf :=_adgb .setOpacity (_cefbg ._ebfc ,_cefbg ._effdf );if _ebdf !=nil {return nil ,ctx ,_ebdf ;};
_gaad :=_cefbg ._gbgg ;_gaad .FillEnabled =_gaad .FillColor !=nil ;_gaad .BorderEnabled =_gaad .BorderColor !=nil &&_gaad .BorderWidth > 0;_gdcea :=_gaad .Points ;for _eaff :=range _gdcea {for _ceed :=range _gdcea [_eaff ]{_dcae :=&_gdcea [_eaff ][_ceed ];
_dcae .Y =ctx .PageHeight -_dcae .Y ;};};_bfcb ,_ ,_ebdf :=_gaad .Draw (_bcfc );if _ebdf !=nil {return nil ,ctx ,_ebdf ;};if _ebdf =_adgb .addContentsByString (string (_bfcb ));_ebdf !=nil {return nil ,ctx ,_ebdf ;};return []*Block {_adgb },ctx ,nil ;};


// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_cggdg *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_ccac :=NewTextChunk (text ,_cggdg ._fefb );_ccac ._fbdg =_ggcdb (page -1,x ,y ,zoom );return _cggdg .appendChunk (_ccac );};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_ecgb float64 ;_effc float64 ;_abbg float64 ;_dffe float64 ;_gdbag Color ;_bgbc float64 ;};func (_bbcd *List )tableHeight (_dggd float64 )float64 {var _cdfb float64 ;for _ ,_fbded :=range _bbcd ._bdgga {switch _bgcf :=_fbded ._adgg .(type ){case *Paragraph :_fcfb :=_bgcf ;
if _fcfb ._dfed {_fcfb .SetWidth (_dggd );};_cdfb +=_fcfb .Height ()+_fcfb ._fcfba .Bottom +_fcfb ._fcfba .Bottom ;_cdfb +=0.5*_fcfb ._aabf *_fcfb ._eag ;case *StyledParagraph :_feece :=_bgcf ;if _feece ._deac {_feece .SetWidth (_dggd );};_cdfb +=_feece .Height ()+_feece ._bacc .Top +_feece ._bacc .Bottom ;
_cdfb +=0.5*_feece .getTextHeight ();default:_cdfb +=_fbded ._adgg .Height ();};};return _cdfb ;};

// Scale block by specified factors in the x and y directions.
func (_bgf *Block )Scale (sx ,sy float64 ){_dcc :=_bd .NewContentCreator ().Scale (sx ,sy ).Operations ();*_bgf ._ef =append (*_dcc ,*_bgf ._ef ...);_bgf ._ef .WrapIfNeeded ();_bgf ._fc *=sx ;_bgf ._gd *=sy ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_dcgf *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddcaa :=ctx ;var _acfe []*Block ;_aeca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dcgf ._dgac .IsRelative (){ctx .X +=_dcgf ._bacc .Left ;ctx .Y +=_dcgf ._bacc .Top ;
ctx .Width -=_dcgf ._bacc .Left +_dcgf ._bacc .Right ;ctx .Height -=_dcgf ._bacc .Top +_dcgf ._bacc .Bottom ;_dcgf .SetWidth (ctx .Width );}else {if int (_dcgf ._afgd )<=0{_dcgf .SetWidth (_dcgf .getTextWidth ()/1000.0);};ctx .X =_dcgf ._dgcf ;ctx .Y =_dcgf ._ebda ;
};if _dcgf ._cfca !=nil {_dcgf ._cfca (_dcgf ,ctx );};if _bdadd :=_dcgf .wrapText ();_bdadd !=nil {return nil ,ctx ,_bdadd ;};_bfbbb :=_dcgf ._gffa ;for {_cgadc ,_dabee ,_bdea :=_ggdc (_aeca ,_dcgf ,_bfbbb ,ctx );if _bdea !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bdea );
return nil ,ctx ,_bdea ;};ctx =_cgadc ;_acfe =append (_acfe ,_aeca );if _bfbbb =_dabee ;len (_dabee )==0{break ;};_aeca =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cgadc =ctx ;_cgadc .Y =ctx .Margins .Top ;_cgadc .X =ctx .Margins .Left +_dcgf ._bacc .Left ;
_cgadc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dcgf ._bacc .Bottom ;_cgadc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dcgf ._bacc .Left -_dcgf ._bacc .Right ;ctx =_cgadc ;};if _dcgf ._dgac .IsRelative (){ctx .X -=_dcgf ._bacc .Left ;
ctx .Width =_ddcaa .Width ;return _acfe ,ctx ,nil ;};return _acfe ,_ddcaa ,nil ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_dfeef *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_dfeef .Text },nil ;};var _daca []string ;var _eeee []rune ;var _fagd float64 ;var _gfed []float64 ;_ggfg :=_dfeef .Style ;for _ ,_fgfc :=range _dfeef .Text {if _fgfc =='\u000A'{_daca =append (_daca ,_ecg .TrimRightFunc (string (_eeee ),_dc .IsSpace )+string (_fgfc ));
_eeee =nil ;_fagd =0;_gfed =nil ;continue ;};_ccfa :=_fgfc ==' ';_acbc ,_bgebe :=_ggfg .Font .GetRuneMetrics (_fgfc );if !_bgebe {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_fgfc ,_fgfc ,_ggfg .Font .BaseFont (),_ggfg .Font .Subtype ());
_cd .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ggfg .Font );_cd .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ggfg .Font .Encoder ());return nil ,_f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_aaab :=_ggfg .FontSize *_acbc .Wx ;_daeac :=_aaab ;if !_ccfa {_daeac =_aaab +_ggfg .CharSpacing *1000.0;};if _fagd +_aaab > width *1000.0{_gccbeg :=-1;if !_ccfa {for _edad :=len (_eeee )-1;_edad >=0;_edad --{if _eeee [_edad ]==' '{_gccbeg =_edad ;break ;
};};};_aafgb :=string (_eeee );if _gccbeg > 0{_aafgb =string (_eeee [0:_gccbeg +1]);_eeee =append (_eeee [_gccbeg +1:],_fgfc );_gfed =append (_gfed [_gccbeg +1:],_daeac );_fagd =0;for _ ,_fdcad :=range _gfed {_fagd +=_fdcad ;};}else {if _ccfa {_eeee =[]rune {};
_gfed =[]float64 {};_fagd =0;}else {_eeee =[]rune {_fgfc };_gfed =[]float64 {_daeac };_fagd =_daeac ;};};_daca =append (_daca ,_ecg .TrimRightFunc (_aafgb ,_dc .IsSpace ));}else {_eeee =append (_eeee ,_fgfc );_fagd +=_daeac ;_gfed =append (_gfed ,_daeac );
};};if len (_eeee )> 0{_daca =append (_daca ,string (_eeee ));};return _daca ,nil ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_cfae *Creator )RotateDeg (angleDeg int64 )error {_gbe :=_cfae .getActivePage ();if _gbe ==nil {_cd .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _f .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _ffgf int64 ;if _gbe .Rotate !=nil {_ffgf =*(_gbe .Rotate );};_ffgf +=angleDeg ;_gbe .Rotate =&_ffgf ;return nil ;};func _dbb (_gggc ,_bgggb ,_bagd ,_cdff float64 )*Ellipse {_ggaf :=&Ellipse {};
_ggaf ._gfaf =_gggc ;_ggaf ._gbgf =_bgggb ;_ggaf ._afde =_bagd ;_ggaf ._ceeaa =_cdff ;_ggaf ._gcab =ColorBlack ;_ggaf ._gda =1.0;return _ggaf ;};

// Text sets the text content of the Paragraph.
func (_cgbab *Paragraph )Text ()string {return _cgbab ._cgfeg };

// SetFillColor sets the fill color.
func (_eaa *Polygon )SetFillColor (color Color ){_eaa ._gbgg .FillColor =_gdg (color )};

// SetFillColor sets background color for border.
func (_afe *border )SetFillColor (col Color ){_afe ._baea =col };func _dacge (_ddagb *_a .PdfAnnotationLink )*_a .PdfAnnotationLink {if _ddagb ==nil {return nil ;};_efbdb :=_a .NewPdfAnnotationLink ();_efbdb .BS =_ddagb .BS ;_efbdb .A =_ddagb .A ;if _debf ,_gbfd :=_ddagb .GetAction ();
_gbfd ==nil &&_debf !=nil {_efbdb .SetAction (_debf );};if _fccdb ,_dbcef :=_ddagb .Dest .(*_db .PdfObjectArray );_dbcef {_efbdb .Dest =_db .MakeArray (_fccdb .Elements ()...);};return _efbdb ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_dgcb *Creator )MoveTo (x ,y float64 ){_dgcb ._aggdc .X =x ;_dgcb ._aggdc .Y =y };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_cfdb *List )Add (item VectorDrawable )(*TextChunk ,error ){_cfdf :=&listItem {_adgg :item ,_eaf :_cfdb ._fbfe };switch _cddf :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _cddf ._cfacc {_cddf ._fdfegf =15;};default:return nil ,_f .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_cfdb ._bdgga =append (_cfdb ._bdgga ,_cfdf );return &_cfdf ._eaf ,nil ;};func (_cgcfc *Invoice )generateHeaderBlocks (_dcffg DrawContext )([]*Block ,DrawContext ,error ){_ggae :=_defdf (_cgcfc ._cead );_ggae .SetEnableWrap (true );_ggae .Append (_cgcfc ._cagg );
_dfeg :=_gadb (2);if _cgcfc ._bgdg !=nil {_feebg :=_dfeg .NewCell ();_feebg .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_feebg .SetVerticalAlignment (CellVerticalAlignmentMiddle );_feebg .SetIndent (0);_feebg .SetContent (_cgcfc ._bgdg );_cgcfc ._bgdg .ScaleToHeight (_ggae .Height ()+20);
}else {_dfeg .SkipCells (1);};_cbae :=_dfeg .NewCell ();_cbae .SetHorizontalAlignment (CellHorizontalAlignmentRight );_cbae .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cbae .SetContent (_ggae );return _dfeg .GeneratePageBlocks (_dcffg );};const (CellBorderStyleNone CellBorderStyle =iota ;
CellBorderStyleSingle ;CellBorderStyleDouble ;);

// TitleStyle returns the style properties used to render the invoice title.
func (_gddb *Invoice )TitleStyle ()TextStyle {return _gddb ._cead };type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_dce Drawable )(Drawable ,error );};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// GeneratePageBlocks draws the filled curve on page blocks.
func (_gdcf *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fabea ,_ ,_bbbe :=_gdcf .draw ("");if _bbbe !=nil {return nil ,ctx ,_bbbe ;};_bbbe =_aad .addContentsByString (string (_fabea ));
if _bbbe !=nil {return nil ,ctx ,_bbbe ;};return []*Block {_aad },ctx ,nil ;};

// Level returns the indentation level of the TOC line.
func (_gbdg *TOCLine )Level ()uint {return _gbdg ._bdbdd };

// SetBorder sets the cell's border style.
func (_cefec *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_cefec ._fgdc =CellBorderStyleSingle ;_cefec ._bedgc =width ;_cefec ._cfeed =CellBorderStyleSingle ;
_cefec ._bbge =width ;_cefec ._bffcb =CellBorderStyleSingle ;_cefec ._ebge =width ;_cefec ._dgegd =CellBorderStyleSingle ;_cefec ._acbf =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_cefec ._fgdc =CellBorderStyleDouble ;_cefec ._bedgc =width ;
_cefec ._cfeed =CellBorderStyleDouble ;_cefec ._bbge =width ;_cefec ._bffcb =CellBorderStyleDouble ;_cefec ._ebge =width ;_cefec ._dgegd =CellBorderStyleDouble ;_cefec ._acbf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_cefec ._fgdc =style ;
_cefec ._bedgc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_cefec ._cfeed =style ;_cefec ._bbge =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_cefec ._bffcb =style ;
_cefec ._ebge =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_cefec ._dgegd =style ;_cefec ._acbf =width ;};};func (_abag *Paragraph )getTextWidth ()float64 {_ebdcg :=0.0;for _ ,_ccff :=range _abag ._cgfeg {if _ccff =='\u000A'{continue ;
};_acfgb ,_dac :=_abag ._deed .GetRuneMetrics (_ccff );if !_dac {_cd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_ccff ,_ccff );
return -1;};_ebdcg +=_abag ._aabf *_acfgb .Wx ;};return _ebdcg ;};

// SetIndent sets the cell's left indent.
func (_cdbc *TableCell )SetIndent (indent float64 ){_cdbc ._ggabd =indent };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_bfbg *TOC )SetLineSeparator (separator string ){_bfbg ._cgfec =separator };

// SetHeight sets the Image's document height to specified h.
func (_dgg *Image )SetHeight (h float64 ){_dgg ._agd =h };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_babcf *_ba .PolyBezierCurve ;_afdfb float64 ;_gefc float64 ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dfbb *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfcf :=ctx ;_fggbc ,ctx ,_agdg :=_dfbb ._gfgf .GeneratePageBlocks (ctx );if _agdg !=nil {return _fggbc ,ctx ,_agdg ;};for _ ,_cadbg :=range _dfbb ._adge {_ccce :=_cadbg ._fbbe ;
if !_dfbb ._egdd {_cadbg ._fbbe =0;};_ebgdf ,_dgcab ,_fffa :=_cadbg .GeneratePageBlocks (ctx );_cadbg ._fbbe =_ccce ;if _fffa !=nil {return _fggbc ,ctx ,_fffa ;};if len (_ebgdf )< 1{continue ;};_fggbc [len (_fggbc )-1].mergeBlocks (_ebgdf [0]);_fggbc =append (_fggbc ,_ebgdf [1:]...);
ctx =_dgcab ;};if _dfbb ._efafa .IsRelative (){ctx .X =_bfcf .X ;};if _dfbb ._efafa .IsAbsolute (){return _fggbc ,_bfcf ,nil ;};return _fggbc ,ctx ,nil ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_bdgga []*listItem ;_agag Margins ;_fbfe TextChunk ;_fdfegf float64 ;_cfacc bool ;_cdcc Positioning ;_eaef TextStyle ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_fcgg DrawContext )([]*Block ,DrawContext ,error );};var PPMM =float64 (72*1.0/25.4);func (_aeeg *Table )wrapRow (_gbbbf int ,_acbd DrawContext ,_faefe float64 )(bool ,error ){if !_aeeg ._eegf {return false ,nil ;};var (_fefd =_aeeg ._gefca [_gbbbf ];
_edcgb =-1;_bcgeb []*TableCell ;_fbba float64 ;_cfga bool ;_agdd =make ([]float64 ,0,len (_aeeg ._efbga )););_cdeg :=func (_dbeac *TableCell ,_fcde VectorDrawable ,_eggd bool )*TableCell {_fdb :=*_dbeac ;_fdb ._efcga =_fcde ;if _eggd {_fdb ._cbfe ++;};
return &_fdb ;};_cgdf :=func (_fdfd int ,_fcgd VectorDrawable ){var _ffbcg float64 =-1;if _fcgd ==nil {if _dbae :=_agdd [_fdfd -_gbbbf ];_dbae > _acbd .Height {_fcgd =_aeeg ._gefca [_fdfd ]._efcga ;_aeeg ._gefca [_fdfd ]._efcga =nil ;_agdd [_fdfd -_gbbbf ]=0;
_ffbcg =_dbae ;};};_afdg :=_cdeg (_aeeg ._gefca [_fdfd ],_fcgd ,true );_bcgeb =append (_bcgeb ,_afdg );if _ffbcg < 0{_ffbcg =_afdg .height (_acbd .Width );};if _ffbcg > _fbba {_fbba =_ffbcg ;};};for _dfdg :=_gbbbf ;_dfdg < len (_aeeg ._gefca );_dfdg ++{_eacb :=_aeeg ._gefca [_dfdg ];
if _fefd ._cbfe !=_eacb ._cbfe {_edcgb =_dfdg ;break ;};_acbd .Width =_eacb .width (_aeeg ._efbga ,_faefe );var _ggaa VectorDrawable ;switch _ebeb :=_eacb ._efcga .(type ){case *StyledParagraph :if _bbfb :=_eacb .height (_acbd .Width );_bbfb > _acbd .Height {_fgd :=_acbd ;
_fgd .Height =_ec .Floor (_acbd .Height -_ebeb ._bacc .Top -_ebeb ._bacc .Bottom -0.5*_ebeb .getTextHeight ());_gfaa ,_efdg ,_gcdf :=_ebeb .split (_fgd );if _gcdf !=nil {return false ,_gcdf ;};if _gfaa !=nil &&_efdg !=nil {_ebeb =_gfaa ;_eacb =_cdeg (_eacb ,_gfaa ,false );
_aeeg ._gefca [_dfdg ]=_eacb ;_ggaa =_efdg ;_cfga =true ;};};};_agdd =append (_agdd ,_eacb .height (_acbd .Width ));if _cfga {if _bcgeb ==nil {_bcgeb =make ([]*TableCell ,0,len (_aeeg ._efbga ));for _efgc :=_gbbbf ;_efgc < _dfdg ;_efgc ++{_cgdf (_efgc ,nil );
};};_cgdf (_dfdg ,_ggaa );};};var _geacb float64 ;for _ ,_agfc :=range _agdd {if _agfc > _geacb {_geacb =_agfc ;};};if _cfga &&_geacb < _acbd .Height {if _edcgb < 0{_edcgb =len (_aeeg ._gefca );};_bdbe :=_aeeg ._gefca [_edcgb -1]._cbfe +_aeeg ._gefca [_edcgb -1]._fbbb -1;
for _gfece :=_edcgb ;_gfece < len (_aeeg ._gefca );_gfece ++{_aeeg ._gefca [_gfece ]._cbfe ++;};_aeeg ._gefca =append (_aeeg ._gefca [:_edcgb ],append (_bcgeb ,_aeeg ._gefca [_edcgb :]...)...);_aeeg ._ebaeg =append (_aeeg ._ebaeg [:_bdbe ],append ([]float64 {_fbba },_aeeg ._ebaeg [_bdbe :]...)...);
_aeeg ._ebaeg [_fefd ._cbfe +_fefd ._fbbb -2]=_geacb ;};return _cfga ,nil ;};func (_cfcc *Invoice )generateNoteBlocks (_gdcc DrawContext )([]*Block ,DrawContext ,error ){_ddg :=_gggb ();_acce :=append ([][2]string {_cfcc ._bced ,_cfcc ._dgfg },_cfcc ._bcg ...);
for _ ,_aaea :=range _acce {if _aaea [1]!=""{_eebc :=_cfcc .drawSection (_aaea [0],_aaea [1]);for _ ,_bdca :=range _eebc {_ddg .Add (_bdca );};_aeebg :=_defdf (_cfcc ._fbdc );_aeebg .SetMargins (0,0,10,0);_ddg .Add (_aeebg );};};return _ddg .GeneratePageBlocks (_gdcc );
};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_daea *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bgc []*Block ;_fca :=ctx ;if _daea ._cbcde .IsRelative (){ctx .X +=_daea ._bbeb .Left ;ctx .Y +=_daea ._bbeb .Top ;ctx .Width -=_daea ._bbeb .Left +_daea ._bbeb .Right ;
ctx .Height -=_daea ._bbeb .Top +_daea ._bbeb .Bottom ;};ctx .Inline =_daea ._gfbf ;_dadg :=ctx ;_defd :=ctx ;var _adde float64 ;for _ ,_fbg :=range _daea ._ggcgb {if ctx .Inline {if (ctx .X -_dadg .X )+_fbg .Width ()<=ctx .Width {ctx .Y =_defd .Y ;ctx .Height =_defd .Height ;
}else {ctx .X =_dadg .X ;ctx .Width =_dadg .Width ;_defd .Y +=_adde ;_defd .Height -=_adde ;_adde =0;};};_cfda ,_dgde ,_ddbf :=_fbg .GeneratePageBlocks (ctx );if _ddbf !=nil {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_ddbf );
return nil ,ctx ,_ddbf ;};if len (_cfda )< 1{continue ;};if len (_bgc )> 0{_bgc [len (_bgc )-1].mergeBlocks (_cfda [0]);_bgc =append (_bgc ,_cfda [1:]...);}else {_bgc =append (_bgc ,_cfda [0:]...);};if ctx .Inline {if ctx .Page !=_dgde .Page {_dadg .Y =ctx .Margins .Top ;
_dadg .Height =ctx .PageHeight -ctx .Margins .Top ;_defd .Y =_dadg .Y ;_defd .Height =_dadg .Height ;_adde =_dgde .Height -_dadg .Height ;}else {if _dgff :=ctx .Height -_dgde .Height ;_dgff > _adde {_adde =_dgff ;};};}else {_dgde .X =ctx .X ;};ctx =_dgde ;
};ctx .Inline =_fca .Inline ;if _daea ._cbcde .IsRelative (){ctx .X =_fca .X ;};if _daea ._cbcde .IsAbsolute (){return _bgc ,_fca ,nil ;};return _bgc ,ctx ,nil ;};

// SetBorderWidth sets the border width.
func (_gbbd *Polygon )SetBorderWidth (borderWidth float64 ){_gbbd ._gbgg .BorderWidth =borderWidth };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_bdbca *Paragraph )SetTextAlignment (align TextAlignment ){_bdbca ._gfbfb =align };

// SetFillOpacity sets the fill opacity.
func (_begb *CurvePolygon )SetFillOpacity (opacity float64 ){_begb ._bag =opacity };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_abdb *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_edfad :=&_abdb ._eecc ;_edfad .Left =left ;_edfad .Right =right ;_edfad .Top =top ;_edfad .Bottom =bottom ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_eaba *Creator )SetOptimizer (optimizer _a .Optimizer ){_eaba ._dfc =optimizer };func (_acgd *Paragraph )wrapText ()error {if !_acgd ._dfed ||int (_acgd ._agab )<=0{_acgd ._fgff =[]string {_acgd ._cgfeg };return nil ;};_ceaaa :=NewTextChunk (_acgd ._cgfeg ,TextStyle {Font :_acgd ._deed ,FontSize :_acgd ._aabf });
_gecg ,_caef :=_ceaaa .Wrap (_acgd ._agab );if _caef !=nil {return _caef ;};if _acgd ._bage > 0&&len (_gecg )> _acgd ._bage {_gecg =_gecg [:_acgd ._bage ];};_acgd ._fgff =_gecg ;return nil ;};func (_dd *Block )duplicate ()*Block {_afa :=&Block {};*_afa =*_dd ;
_da :=_bd .ContentStreamOperations {};_da =append (_da ,*_dd ._ef ...);_afa ._ef =&_da ;return _afa ;};func (_fgaf *TOCLine )prepareParagraph (_eegeb *StyledParagraph ,_cage DrawContext ){_gbeaa :=_fgaf .Title .Text ;if _fgaf .Number .Text !=""{_gbeaa ="\u0020"+_gbeaa ;
};_gbeaa +="\u0020";_affga :=_fgaf .Page .Text ;if _affga !=""{_affga ="\u0020"+_affga ;};_eegeb ._ebae =[]*TextChunk {{Text :_fgaf .Number .Text ,Style :_fgaf .Number .Style ,_fbdg :_fgaf .getLineLink ()},{Text :_gbeaa ,Style :_fgaf .Title .Style ,_fbdg :_fgaf .getLineLink ()},{Text :_affga ,Style :_fgaf .Page .Style ,_fbdg :_fgaf .getLineLink ()}};
_eegeb .wrapText ();_febe :=len (_eegeb ._gffa );if _febe ==0{return ;};_fbce :=_cage .Width *1000-_eegeb .getTextLineWidth (_eegeb ._gffa [_febe -1]);_bcea :=_eegeb .getTextLineWidth ([]*TextChunk {&_fgaf .Separator });_fcab :=int (_fbce /_bcea );_afegg :=_ecg .Repeat (_fgaf .Separator .Text ,_fcab );
_cegg :=_fgaf .Separator .Style ;_gggge :=_eegeb .Insert (2,_afegg );_gggge .Style =_cegg ;_gggge ._fbdg =_fgaf .getLineLink ();_fbce =_fbce -float64 (_fcab )*_bcea ;if _fbce > 500{_efgcb ,_bggdf :=_cegg .Font .GetRuneMetrics (' ');if _bggdf &&_fbce > _efgcb .Wx {_ebecc :=int (_fbce /_efgcb .Wx );
if _ebecc > 0{_edefe :=_cegg ;_edefe .FontSize =1;_gggge =_eegeb .Insert (2,_ecg .Repeat ("\u0020",_ebecc ));_gggge .Style =_edefe ;_gggge ._fbdg =_fgaf .getLineLink ();};};};};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_gdgc *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _gdgc ._dgcg ==nil {if _abb :=_gdgc .makeXObject ();_abb !=nil {return nil ,ctx ,_abb ;};};var _gggg []*Block ;_aeec :=ctx ;_ceff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _gdgc ._egaf .IsRelative (){ctx .X +=_gdgc ._cagbc .Left ;ctx .Y +=_gdgc ._cagbc .Top ;ctx .Width -=_gdgc ._cagbc .Left +_gdgc ._cagbc .Right ;ctx .Height -=_gdgc ._cagbc .Top +_gdgc ._cagbc .Bottom ;if _gdgc ._agd > ctx .Height {_gggg =append (_gggg ,_ceff );
_ceff =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_agae :=ctx ;_agae .Y =ctx .Margins .Top +_gdgc ._cagbc .Top ;_agae .X =ctx .Margins .Left +_gdgc ._cagbc .Left ;_agae .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gdgc ._cagbc .Top -_gdgc ._cagbc .Bottom ;
_agae .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gdgc ._cagbc .Left -_gdgc ._cagbc .Right ;ctx =_agae ;_aeec .X =ctx .Margins .Left ;_aeec .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_gdgc ._efda ;
ctx .Y =_gdgc ._fbad ;};ctx ,_bdbc :=_fdff (_ceff ,_gdgc ,ctx );if _bdbc !=nil {return nil ,ctx ,_bdbc ;};_gggg =append (_gggg ,_ceff );if _gdgc ._egaf .IsAbsolute (){ctx =_aeec ;}else {ctx .X =_aeec .X ;ctx .Y +=_gdgc ._cagbc .Bottom ;ctx .Width =_aeec .Width ;
};return _gggg ,ctx ,nil ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_aafa *Table )Width ()float64 {return 0};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_afc *List )Width ()float64 {return 0};

// Invoice represents a configurable invoice template.
type Invoice struct{_cagg string ;_bgdg *Image ;_dbgg *InvoiceAddress ;_aegd *InvoiceAddress ;_gfee string ;_dbdg [2]*InvoiceCell ;_ddca [2]*InvoiceCell ;_dafaa [2]*InvoiceCell ;_bfga [][2]*InvoiceCell ;_afda []*InvoiceCell ;_acdd [][]*InvoiceCell ;_beag [2]*InvoiceCell ;
_bfeb [2]*InvoiceCell ;_dcbe [][2]*InvoiceCell ;_bced [2]string ;_dgfg [2]string ;_bcg [][2]string ;_fbdc TextStyle ;_abeg TextStyle ;_cead TextStyle ;_dfcf TextStyle ;_fgge TextStyle ;_ddabf TextStyle ;_ddbfc TextStyle ;_gdaf InvoiceCellProps ;_agbg InvoiceCellProps ;
_aeb InvoiceCellProps ;_gfac InvoiceCellProps ;_ecfd Positioning ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_a .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetMargins sets the Paragraph's margins.
func (_fdda *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_fdda ._bacc .Left =left ;_fdda ._bacc .Right =right ;_fdda ._bacc .Top =top ;_fdda ._bacc .Bottom =bottom ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_fgcd *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _aede (x1 ,y1 ,x2 ,y2 )};

// SetIndent sets the left offset of the list when nested into another list.
func (_eafb *List )SetIndent (indent float64 ){_eafb ._fdfegf =indent ;_eafb ._cfacc =false };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_ggeee *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _feecf (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bbg *Block )ScaleToWidth (w float64 ){_fa :=w /_bbg ._fc ;_bbg .Scale (_fa ,_fa )};

// Title returns the title of the invoice.
func (_cgbad *Invoice )Title ()string {return _cgbad ._cagg };

// NewCurvePolygon creates a new curve polygon.
func (_afee *Creator )NewCurvePolygon (rings [][]_ba .CubicBezierCurve )*CurvePolygon {return _ebdd (rings );};

// SetStyleRight sets border style for right side.
func (_bfa *border )SetStyleRight (style CellBorderStyle ){_bfa ._cca =style };

// RotatedSize returns the width and height of the rotated block.
func (_fbb *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_cda ,_deb :=_degf (_fbb ._fc ,_fbb ._gd ,_fbb ._cag );return _cda ,_deb ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_bde *Invoice )SetAddressHeadingStyle (style TextStyle ){_bde ._fgge =style };

// MoveY moves the drawing context to absolute position y.
func (_gbde *Creator )MoveY (y float64 ){_gbde ._aggdc .Y =y };

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_ddbd *Ellipse )GetCoords ()(float64 ,float64 ){return _ddbd ._gfaf ,_ddbd ._gbgf };

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_dgdde *Image )GetHorizontalAlignment ()HorizontalAlignment {return _dgdde ._ebcf };

// SetFillColor sets the fill color.
func (_bbcdb *Rectangle )SetFillColor (col Color ){_bbcdb ._aadd =col };func _fggb (_ebgg _c .Image )(*Image ,error ){_bdf ,_faef :=_a .ImageHandling .NewImageFromGoImage (_ebgg );if _faef !=nil {return nil ,_faef ;};return _cgeed (_bdf );};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetOpacity sets opacity for Image.
func (_ebef *Image )SetOpacity (opacity float64 ){_ebef ._bdga =opacity };func _aede (_effd ,_fbcb ,_dfcd ,_bcbd float64 )*Line {_addb :=&Line {};_addb ._ecgb =_effd ;_addb ._effc =_fbcb ;_addb ._abbg =_dfcd ;_addb ._dffe =_bcbd ;_addb ._gdbag =ColorBlack ;
_addb ._bgbc =1.0;return _addb ;};func _cdef (_cefb []byte )(*Image ,error ){_bfec :=_b .NewReader (_cefb );_cabf ,_dccdc :=_a .ImageHandling .Read (_bfec );if _dccdc !=nil {_cd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dccdc );
return nil ,_dccdc ;};return _cgeed (_cabf );};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_ffbf *Creator )NewImageFromGoImage (goimg _c .Image )(*Image ,error ){return _fggb (goimg )};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ggca *TOC )SetLineTitleStyle (style TextStyle ){_ggca ._gfcf =style };

// GetMargins returns the left, right, top, bottom Margins.
func (_aggf *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aggf ._dbbb .Left ,_aggf ._dbbb .Right ,_aggf ._dbbb .Top ,_aggf ._dbbb .Bottom ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_bbb *Chapter )SetShowNumbering (show bool ){_bbb ._gag =show ;_bbb ._df .SetText (_bbb .headingText ());};

// SetBorderWidth sets the border width.
func (_cfb *Ellipse )SetBorderWidth (bw float64 ){_cfb ._gda =bw };

// SetColorRight sets border color for right.
func (_cdab *border )SetColorRight (col Color ){_cdab ._eab =col };

// GeneratePageBlocks draws the curve onto page blocks.
func (_ecc *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eeec :=_bd .NewContentCreator ();_eeec .Add_q ().Add_w (_ecc ._ecec ).SetStrokingColor (_gdg (_ecc ._cdaa )).Add_m (_ecc ._feed ,ctx .PageHeight -_ecc ._acfbf ).Add_v (_ecc ._bbgc ,ctx .PageHeight -_ecc ._bdcd ,_ecc ._acfg ,ctx .PageHeight -_ecc ._ccae ).Add_S ().Add_Q ();
_ddeg :=_edef .addContentsByString (_eeec .String ());if _ddeg !=nil {return nil ,ctx ,_ddeg ;};return []*Block {_edef },ctx ,nil ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_bfb int ;_cbe string ;_df *Paragraph ;_cgba []Drawable ;_fdcc int ;_gag bool ;_cdf bool ;_ece Positioning ;_abfc ,_gbd float64 ;_gca Margins ;_dff *Chapter ;_ddab *TOC ;_accg *_a .Outline ;_bdad *_a .OutlineItem ;_geb uint ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_cfac *Image )ScaleToHeight (h float64 ){_ccb :=_cfac ._bcdb /_cfac ._agd ;_cfac ._agd =h ;_cfac ._bcdb =h *_ccb ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_gagd *Creator )CreateTableOfContents (genTOCFunc func (_fbaa *TOC )error ){_gagd ._cbf =genTOCFunc ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_begf *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_ebbe :=_defdf (_begf ._eaef );_ebbe .Append (text );_ffcge ,_ddcf :=_begf .Add (_ebbe );return _ebbe ,_ffcge ,_ddcf ;};func _fdff (_ecfe *Block ,_aeae *Image ,_ceddd DrawContext )(DrawContext ,error ){_adgd :=_ceddd ;
_dcac :=1;_cbg :=_db .PdfObjectName (_bb .Sprintf ("\u0049\u006d\u0067%\u0064",_dcac ));for _ecfe ._dcba .HasXObjectByName (_cbg ){_dcac ++;_cbg =_db .PdfObjectName (_bb .Sprintf ("\u0049\u006d\u0067%\u0064",_dcac ));};_dafa :=_ecfe ._dcba .SetXObjectImageByName (_cbg ,_aeae ._dgcg );
if _dafa !=nil {return _ceddd ,_dafa ;};_ggab :=0;_bfab :=_db .PdfObjectName (_bb .Sprintf ("\u0047\u0053\u0025\u0064",_ggab ));for _ecfe ._dcba .HasExtGState (_bfab ){_ggab ++;_bfab =_db .PdfObjectName (_bb .Sprintf ("\u0047\u0053\u0025\u0064",_ggab ));
};_eefd :=_db .MakeDict ();_eefd .Set ("\u0042\u004d",_db .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _aeae ._bdga < 1.0{_eefd .Set ("\u0043\u0041",_db .MakeFloat (_aeae ._bdga ));_eefd .Set ("\u0063\u0061",_db .MakeFloat (_aeae ._bdga ));};
_dafa =_ecfe ._dcba .AddExtGState (_bfab ,_db .MakeIndirectObject (_eefd ));if _dafa !=nil {return _ceddd ,_dafa ;};_ddbc :=_aeae .Width ();_eeece :=_aeae .Height ();_ ,_dggf :=_aeae .rotatedSize ();_fdgf :=_ceddd .X ;_dedc :=_ceddd .PageHeight -_ceddd .Y -_eeece ;
if _aeae ._egaf .IsRelative (){_dedc -=(_dggf -_eeece )/2;switch _aeae ._ebcf {case HorizontalAlignmentCenter :_fdgf +=(_ceddd .Width -_ddbc )/2;case HorizontalAlignmentRight :_fdgf =_ceddd .PageWidth -_ceddd .Margins .Right -_aeae ._cagbc .Right -_ddbc ;
};};_aedc :=_aeae ._aedf ;_dbgb :=_bd .NewContentCreator ();_dbgb .Add_gs (_bfab );_dbgb .Translate (_fdgf ,_dedc );if _aedc !=0{_dbgb .Translate (_ddbc /2,_eeece /2);_dbgb .RotateDeg (_aedc );_dbgb .Translate (-_ddbc /2,-_eeece /2);};_dbgb .Scale (_ddbc ,_eeece ).Add_Do (_cbg );
_edac :=_dbgb .Operations ();_edac .WrapIfNeeded ();_ecfe .addContents (_edac );if _aeae ._egaf .IsRelative (){_ceddd .Y +=_dggf ;_ceddd .Height -=_dggf ;return _ceddd ,nil ;};return _adgd ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cbffa *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agac :=ctx ;_dced :=[]func (_befe DrawContext )([]*Block ,DrawContext ,error ){_cbffa .generateHeaderBlocks ,_cbffa .generateInformationBlocks ,_cbffa .generateLineBlocks ,_cbffa .generateTotalBlocks ,_cbffa .generateNoteBlocks };
var _gacc []*Block ;for _ ,_acceb :=range _dced {_bgbf ,_ddbe ,_gdee :=_acceb (ctx );if _gdee !=nil {return _gacc ,ctx ,_gdee ;};if len (_gacc )==0{_gacc =_bgbf ;}else if len (_bgbf )> 0{_gacc [len (_gacc )-1].mergeBlocks (_bgbf [0]);_gacc =append (_gacc ,_bgbf [1:]...);
};ctx =_ddbe ;};if _cbffa ._ecfd .IsRelative (){ctx .X =_agac .X ;};if _cbffa ._ecfd .IsAbsolute (){return _gacc ,_agac ,nil ;};return _gacc ,ctx ,nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_gfaf float64 ;_gbgf float64 ;_afde float64 ;_ceeaa float64 ;_caaf Color ;_gcab Color ;_gda float64 ;};func (_fdca *FilledCurve )draw (_bgdf string )([]byte ,*_a .PdfRectangle ,error ){_edaa :=_ba .NewCubicBezierPath ();for _ ,_abdg :=range _fdca ._fdge {_edaa =_edaa .AppendCurve (_abdg );
};creator :=_bd .NewContentCreator ();creator .Add_q ();if _fdca .FillEnabled &&_fdca ._agcf !=nil {creator .SetNonStrokingColor (_gdg (_fdca ._agcf ));};if _fdca .BorderEnabled {if _fdca ._fdeb !=nil {creator .SetStrokingColor (_gdg (_fdca ._fdeb ));};
creator .Add_w (_fdca .BorderWidth );};if len (_bgdf )> 1{creator .Add_gs (_db .PdfObjectName (_bgdf ));};_ba .DrawBezierPathWithCreator (_edaa ,creator );creator .Add_h ();if _fdca .FillEnabled &&_fdca .BorderEnabled {creator .Add_B ();}else if _fdca .FillEnabled {creator .Add_f ();
}else if _fdca .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_faec :=_edaa .GetBoundingBox ();if _fdca .BorderEnabled {_faec .Height +=_fdca .BorderWidth ;_faec .Width +=_fdca .BorderWidth ;_faec .X -=_fdca .BorderWidth /2;_faec .Y -=_fdca .BorderWidth /2;
};_edaf :=&_a .PdfRectangle {};_edaf .Llx =_faec .X ;_edaf .Lly =_faec .Y ;_edaf .Urx =_faec .X +_faec .Width ;_edaf .Ury =_faec .Y +_faec .Height ;return creator .Bytes (),_edaf ,nil ;};

// SetFillColor sets the fill color.
func (_cbbf *CurvePolygon )SetFillColor (color Color ){_cbbf ._dagf .FillColor =_gdg (color )};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_deeb *Invoice )SetNoteHeadingStyle (style TextStyle ){_deeb ._ddbfc =style };func (_feae *Invoice )generateTotalBlocks (_baeg DrawContext )([]*Block ,DrawContext ,error ){_gbcd :=_gadb (4);_gbcd .SetMargins (0,0,10,10);_bcdc :=[][2]*InvoiceCell {_feae ._beag };
_bcdc =append (_bcdc ,_feae ._dcbe ...);_bcdc =append (_bcdc ,_feae ._bfeb );for _ ,_ggabe :=range _bcdc {_efbec ,_daee :=_ggabe [0],_ggabe [1];if _daee .Value ==""{continue ;};_gbcd .SkipCells (2);_acdc :=_gbcd .NewCell ();_acdc .SetBackgroundColor (_efbec .BackgroundColor );
_acdc .SetHorizontalAlignment (_daee .Alignment );_feae .setCellBorder (_acdc ,_efbec );_fabed :=_defdf (_efbec .TextStyle );_fabed .SetMargins (0,0,2,1);_fabed .Append (_efbec .Value );_acdc .SetContent (_fabed );_acdc =_gbcd .NewCell ();_acdc .SetBackgroundColor (_daee .BackgroundColor );
_acdc .SetHorizontalAlignment (_daee .Alignment );_feae .setCellBorder (_acdc ,_efbec );_fabed =_defdf (_daee .TextStyle );_fabed .SetMargins (0,0,2,1);_fabed .Append (_daee .Value );_acdc .SetContent (_fabed );};return _gbcd .GeneratePageBlocks (_baeg );
};

// SetBorderColor sets the border color.
func (_fdebd *Polygon )SetBorderColor (color Color ){_fdebd ._gbgg .BorderColor =_gdg (color )};func (_cgbd *StyledParagraph )wrapChunks (_baef bool )error {if !_cgbd ._deac ||int (_cgbd ._afgd )<=0{_cgbd ._gffa =[][]*TextChunk {_cgbd ._ebae };return nil ;
};_cgbd ._gffa =[][]*TextChunk {};var _fcddb []*TextChunk ;var _daeb float64 ;_aacgf :=_dc .IsSpace ;if !_baef {_aacgf =func (rune )bool {return false };};for _ ,_ebfcd :=range _cgbd ._ebae {_bdfee :=_ebfcd .Style ;_abcga :=_ebfcd ._fbdg ;var (_eddbb []rune ;
_eedg []float64 ;);for _ ,_daagd :=range _ebfcd .Text {if _daagd =='\u000A'{if !_baef {_eddbb =append (_eddbb ,_daagd );};_fcddb =append (_fcddb ,&TextChunk {Text :_ecg .TrimRightFunc (string (_eddbb ),_aacgf ),Style :_bdfee ,_fbdg :_eggc (_abcga )});_cgbd ._gffa =append (_cgbd ._gffa ,_fcddb );
_fcddb =nil ;_daeb =0;_eddbb =nil ;_eedg =nil ;continue ;};_cgeb :=_daagd ==' ';_bagef ,_bffce :=_bdfee .Font .GetRuneMetrics (_daagd );if !_bffce {_cd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_daagd );
return _f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_abbbc :=_bdfee .FontSize *_bagef .Wx ;_fcea :=_abbbc ;if !_cgeb {_fcea =_abbbc +_bdfee .CharSpacing *1000.0;
};if _daeb +_abbbc > _cgbd ._afgd *1000.0{_ddfcd :=-1;if !_cgeb {for _cded :=len (_eddbb )-1;_cded >=0;_cded --{if _eddbb [_cded ]==' '{_ddfcd =_cded ;break ;};};};_bfaf :=string (_eddbb );if _ddfcd >=0{_bfaf =string (_eddbb [0:_ddfcd +1]);_eddbb =_eddbb [_ddfcd +1:];
_eddbb =append (_eddbb ,_daagd );_eedg =_eedg [_ddfcd +1:];_eedg =append (_eedg ,_fcea );_daeb =0;for _ ,_acefa :=range _eedg {_daeb +=_acefa ;};}else {if _cgeb {_daeb =0;_eddbb =[]rune {};_eedg =[]float64 {};}else {_daeb =_fcea ;_eddbb =[]rune {_daagd };
_eedg =[]float64 {_fcea };};};if !_baef &&_cgeb {_bfaf +="\u0020";};_fcddb =append (_fcddb ,&TextChunk {Text :_ecg .TrimRightFunc (_bfaf ,_aacgf ),Style :_bdfee ,_fbdg :_eggc (_abcga )});_cgbd ._gffa =append (_cgbd ._gffa ,_fcddb );_fcddb =[]*TextChunk {};
}else {_daeb +=_fcea ;_eddbb =append (_eddbb ,_daagd );_eedg =append (_eedg ,_fcea );};};if len (_eddbb )> 0{_fcddb =append (_fcddb ,&TextChunk {Text :string (_eddbb ),Style :_bdfee ,_fbdg :_eggc (_abcga )});};};if len (_fcddb )> 0{_cgbd ._gffa =append (_cgbd ._gffa ,_fcddb );
};return nil ;};func _afg (_dgb ,_bae *_a .PdfPageResources )error {_gac ,_ :=_dgb .GetColorspaces ();if _gac !=nil &&len (_gac .Colorspaces )> 0{for _fdfe ,_cc :=range _gac .Colorspaces {_beb :=*_db .MakeName (_fdfe );if _bae .HasColorspaceByName (_beb ){continue ;
};_fab :=_bae .SetColorspaceByName (_beb ,_cc );if _fab !=nil {return _fab ;};};};return nil ;};func (_ecdfa *Creator )getActivePage ()*_a .PdfPage {if _ecdfa ._efgb ==nil {if len (_ecdfa ._effg )==0{return nil ;};return _ecdfa ._effg [len (_ecdfa ._effg )-1];
};return _ecdfa ._efgb ;};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_cadb *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _gdaff (x ,y ,width ,height );};func (_cab *Creator )initContext (){_cab ._aggdc .X =_cab ._egfg .Left ;_cab ._aggdc .Y =_cab ._egfg .Top ;_cab ._aggdc .Width =_cab ._ddag -_cab ._egfg .Right -_cab ._egfg .Left ;
_cab ._aggdc .Height =_cab ._bdgd -_cab ._egfg .Bottom -_cab ._egfg .Top ;_cab ._aggdc .PageHeight =_cab ._bdgd ;_cab ._aggdc .PageWidth =_cab ._ddag ;_cab ._aggdc .Margins =_cab ._egfg ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_bdcc *Creator )EnableFontSubsetting (font *_a .PdfFont ){_bdcc ._cadg =append (_bdcc ._cadg ,font )};func (_bdfe *StyledParagraph )getMaxLineWidth ()float64 {if _bdfe ._gffa ==nil ||len (_bdfe ._gffa )==0{_bdfe .wrapText ();};var _bgcfb float64 ;
for _ ,_cbde :=range _bdfe ._gffa {_gcbd :=_bdfe .getTextLineWidth (_cbde );if _gcbd > _bgcfb {_bgcfb =_gcbd ;};};return _bgcfb ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;func _edfa (_bagb TextStyle )*List {return &List {_fbfe :TextChunk {Text :"\u2022\u0020",Style :_bagb },_fdfegf :0,_cfacc :true ,_cdcc :PositionRelative ,_eaef :_bagb };};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;var PPI float64 =72;

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_acb *Creator )Draw (d Drawable )error {if _acb .getActivePage ()==nil {_acb .NewPage ();};_gfbd ,_dbab ,_cbff :=d .GeneratePageBlocks (_acb ._aggdc );if _cbff !=nil {return _cbff ;};for _feec ,_gedf :=range _gfbd {if _feec > 0{_acb .NewPage ();};
_feeb :=_acb .getActivePage ();if _adbe ,_ccd :=_acb ._ggcf [_feeb ];_ccd {if _efbe :=_adbe .mergeBlocks (_gedf );_efbe !=nil {return _efbe ;};if _cdbe :=_afg (_gedf ._dcba ,_adbe ._dcba );_cdbe !=nil {return _cdbe ;};}else {_acb ._ggcf [_feeb ]=_gedf ;
};};_acb ._aggdc .X =_dbab .X ;_acb ._aggdc .Y =_dbab .Y ;_acb ._aggdc .Height =_dbab .PageHeight -_dbab .Y -_dbab .Margins .Bottom ;return nil ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_gcgg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_egcgf float64 ;_bdbdd uint ;_egag float64 ;_fbed Positioning ;_gbfe float64 ;_cabb float64 ;_fbbe int64 ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_cbbb *Invoice )NoteStyle ()TextStyle {return _cbbb ._ddabf };func (_cdee rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _cdee ._cbcd ,_cdee ._eadc ,_cdee ._dbee ;};func (_cde *Chapter )headingNumber ()string {var _cgf string ;if _cde ._gag {if _cde ._bfb !=0{_cgf =_ff .Itoa (_cde ._bfb )+"\u002e";
};if _cde ._dff !=nil {_fgcb :=_cde ._dff .headingNumber ();if _fgcb !=""{_cgf =_fgcb +_cgf ;};};};return _cgf ;};

// SetRowHeight sets the height for a specified row.
func (_dfcfd *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_dfcfd ._ebaeg ){return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dfcfd ._ebaeg [row -1]=h ;return nil ;
};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// Logo returns the logo of the invoice.
func (_cbcf *Invoice )Logo ()*Image {return _cbcf ._bgdg };