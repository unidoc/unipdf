//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_c "bytes";_de "errors";_b "fmt";_bg "github.com/unidoc/unipdf/v3/common";_ab "github.com/unidoc/unipdf/v3/contentstream";_eb "github.com/unidoc/unipdf/v3/contentstream/draw";_ac "github.com/unidoc/unipdf/v3/core";_gc "github.com/unidoc/unipdf/v3/internal/transform";_da "github.com/unidoc/unipdf/v3/model";_dd "image";_ad "io";_ag "math";_g "os";_a "sort";_cb "strconv";_e "strings";_aa "unicode";);func (_dfge *StyledParagraph )appendChunk (_dadd *TextChunk )*TextChunk {_dfge ._caca =append (_dfge ._caca ,_dadd );_dfge .wrapText ();return _dadd ;};

// CreateFrontPage sets a function to generate a front Page.
func (_gcad *Creator )CreateFrontPage (genFrontPageFunc func (_bbcd FrontpageFunctionArgs )){_gcad ._efgc =genFrontPageFunc ;};

// SetNumber sets the number of the invoice.
func (_gbce *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gbce ._aggg [1].Value =number ;return _gbce ._aggg [0],_gbce ._aggg [1];};func _fcae (_afce int )*Table {_efcgf :=&Table {_gfbe :_afce ,_cbcfeg :10.0,_cgcgb :[]float64 {},_caceb :[]float64 {},_adceb :[]*TableCell {}};_efcgf .resetColumnWidths ();return _efcgf ;};

// Append adds a new text chunk to the paragraph.
func (_agae *StyledParagraph )Append (text string )*TextChunk {_gccg :=NewTextChunk (text ,_agae ._bgcf );return _agae .appendChunk (_gccg );};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_dfff *Division )Add (d VectorDrawable )error {_ebc :=false ;switch d .(type ){case *Paragraph :_ebc =true ;case *StyledParagraph :_ebc =true ;case *Image :_ebc =true ;};if !_ebc {return _de .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_dfff ._caed =append (_dfff ._caed ,d );return nil ;};

// Inline returns whether the inline mode of the division is active.
func (_cfga *Division )Inline ()bool {return _cfga ._feg };

// AddLine adds a new line with the provided style to the table of contents.
func (_eaec *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_eaec ._fgceb =append (_eaec ._fgceb ,line );return line ;};const (_abbd positioning =iota ;_gcda ;);var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// SetBorderOpacity sets the border opacity.
func (_cbef *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_cbef ._cdff =opacity };

// SetSubtotal sets the subtotal of the invoice.
func (_geff *Invoice )SetSubtotal (value string ){_geff ._befb [1].Value =value };

// SetPos sets absolute positioning with specified coordinates.
func (_ggeba *Paragraph )SetPos (x ,y float64 ){_ggeba ._cbcc =_gcda ;_ggeba ._fccb =x ;_ggeba ._gecb =y ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_bbdc *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _eeba (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fafg *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fafg ._gffg ._bfca ,_fafg ._gffg ._dbca ,_fafg ._gffg ._agbf ,_fafg ._gffg ._cee ;};func _bcdfg (_ccegb *_da .PdfAnnotationLink )*_da .PdfAnnotationLink {if _ccegb ==nil {return nil ;};_abbe :=_da .NewPdfAnnotationLink ();_abbe .BS =_ccegb .BS ;_abbe .A =_ccegb .A ;if _cgdf ,_edac :=_ccegb .GetAction ();_edac ==nil &&_cgdf !=nil {_abbe .SetAction (_cgdf );};if _gbad ,_eege :=_ccegb .Dest .(*_ac .PdfObjectArray );_eege {_abbe .Dest =_ac .MakeArray (_gbad .Elements ()...);};return _abbe ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_ebd *Image )ScaleToHeight (h float64 ){_baa :=_ebd ._cfdf /_ebd ._dgd ;_ebd ._dgd =h ;_ebd ._cfdf =h *_baa ;};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_cbcfe *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfdb :=_eb .Line {LineWidth :_cbcfe ._ccfde ,Opacity :1.0,LineColor :_cbcfe ._fbcb ,LineEndingStyle1 :_eb .LineEndingStyleNone ,LineEndingStyle2 :_eb .LineEndingStyleNone ,X1 :_cbcfe ._aecgd ,Y1 :ctx .PageHeight -_cbcfe ._cdga ,X2 :_cbcfe ._ggbag ,Y2 :ctx .PageHeight -_cbcfe ._dbba };_dggf ,_ ,_dcbc :=_bfdb .Draw ("");if _dcbc !=nil {return nil ,ctx ,_dcbc ;};_dcbc =_dcb .addContentsByString (string (_dggf ));if _dcbc !=nil {return nil ,ctx ,_dcbc ;};return []*Block {_dcb },ctx ,nil ;};

// CurCol returns the currently active cell's column number.
func (_adgfc *Table )CurCol ()int {_gcdga :=(_adgfc ._fbfgf -1)%(_adgfc ._gfbe )+1;return _gcdga };

// Rows returns the total number of rows the table has.
func (_edea *Table )Rows ()int {return _edea ._bead };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_agba *TOCLine )SetLevelOffset (levelOffset float64 ){_agba ._cgdb =levelOffset ;_agba ._agddae ._bbgga ._bfca =_agba ._egfb +float64 (_agba ._gcgd -1)*_agba ._cgdb ;};

// NewCellProps returns the default properties of an invoice cell.
func (_bebc *Invoice )NewCellProps ()InvoiceCellProps {_aegd :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_bebc ._adac ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_aegd ,BorderColor :_aegd ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};func _bcfg (_geeg []_eb .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_dcdc :&_eb .PolyBezierCurve {Curves :_geeg ,BorderColor :_da .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_dgdc :1.0,_cdff :1.0};};func (_bcdb *Invoice )drawInformation ()*Table {_fccd :=_fcae (2);_gcecf :=append ([][2]*InvoiceCell {_bcdb ._aggg ,_bcdb ._fdgea ,_bcdb ._fgd },_bcdb ._gdfd ...);for _ ,_dbff :=range _gcecf {_bbaa ,_efbc :=_dbff [0],_dbff [1];if _efbc .Value ==""{continue ;};_ddagf :=_fccd .NewCell ();_ddagf .SetBackgroundColor (_bbaa .BackgroundColor );_bcdb .setCellBorder (_ddagf ,_bbaa );_efed :=_adce (_bbaa .TextStyle );_efed .Append (_bbaa .Value );_efed .SetMargins (0,0,2,1);_ddagf .SetContent (_efed );_ddagf =_fccd .NewCell ();_ddagf .SetBackgroundColor (_efbc .BackgroundColor );_bcdb .setCellBorder (_ddagf ,_efbc );_efed =_adce (_efbc .TextStyle );_efed .Append (_efbc .Value );_efed .SetMargins (0,0,2,1);_ddagf .SetContent (_efed );};return _fccd ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_fgagf *TOC )SetLineNumberStyle (style TextStyle ){_fgagf ._fbgf =style };func (_geb *Block )mergeBlocks (_bda *Block )error {_aec :=_dad (_geb ._f ,_geb ._fa ,_bda ._f ,_bda ._fa );if _aec !=nil {return _aec ;};for _ ,_dba :=range _bda ._ga {_geb .AddAnnotation (_dba );};return nil ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_befc *List )SetIndent (indent float64 ){_befc ._fdbd =indent ;_befc ._fabc =false };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_ccec *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_dgfc :=NewTextChunk (text ,_ccec ._dgcgc );_dgfc ._accfg =_fgcbf (url );return _ccec .appendChunk (_dgfc );};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_fcfe *Paragraph )SetMaxLines (maxLines int ){_fcfe ._egfd =maxLines ;_fcfe .wrapText ()};

// NewFilledCurve returns a instance of filled curve.
func (_cde *Creator )NewFilledCurve ()*FilledCurve {return _bdbb ()};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_ggdgc *TOC )SetHeading (text string ,style TextStyle ){_adbb :=_ggdgc .Heading ();_adbb .Reset ();_gagba :=_adbb .Append (text );_gagba .Style =style ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ccdg *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _egaee float64 ;var _cecb []*StyledParagraph ;for _ ,_fddc :=range _ccdg ._fafce {_cfed :=_adce (_ccdg ._gebf );_cfed .SetEnableWrap (false );_cfed .SetTextAlignment (TextAlignmentRight );_cfed .Append (_fddc ._cdbcg .Text ).Style =_fddc ._cdbcg .Style ;_aaee :=_cfed .getTextWidth ()/1000.0/ctx .Width ;if _egaee < _aaee {_egaee =_aaee ;};_cecb =append (_cecb ,_cfed );};_fgbc :=_fcae (2);_fgbc .SetColumnWidths (_egaee ,1-_egaee );_fgbc .SetMargins (_ccdg ._fdbd ,0,0,0);for _badf ,_dafe :=range _ccdg ._fafce {_dada :=_fgbc .NewCell ();_dada .SetIndent (0);_dada .SetContent (_cecb [_badf ]);_dada =_fgbc .NewCell ();_dada .SetIndent (0);_dada .SetContent (_dafe ._gfbg );};return _fgbc .GeneratePageBlocks (ctx );};func (_fdga *Image )rotatedSize ()(float64 ,float64 ){_fccc :=_fdga ._cfdf ;_caebg :=_fdga ._dgd ;_eacdf :=_fdga ._afgd ;if _eacdf ==0{return _fccc ,_caebg ;};_acgd :=_eb .Path {Points :[]_eb .Point {_eb .NewPoint (0,0).Rotate (_eacdf ),_eb .NewPoint (_fccc ,0).Rotate (_eacdf ),_eb .NewPoint (0,_caebg ).Rotate (_eacdf ),_eb .NewPoint (_fccc ,_caebg ).Rotate (_eacdf )}}.GetBoundingBox ();return _acgd .Width ,_acgd .Height ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ecea *Image )ScaleToWidth (w float64 ){_egbe :=_ecea ._dgd /_ecea ._cfdf ;_ecea ._cfdf =w ;_ecea ._dgd =w *_egbe ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_bgc *Block )SetMargins (left ,right ,top ,bottom float64 ){_bgc ._ec ._bfca =left ;_bgc ._ec ._dbca =right ;_bgc ._ec ._agbf =top ;_bgc ._ec ._cee =bottom ;};

// SetColorRight sets border color for right.
func (_ggba *border )SetColorRight (col Color ){_ggba ._gbag =_da .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_bfge *StyledParagraph )SetWidth (width float64 ){_bfge ._ggdg =width ;_bfge .wrapText ()};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_geef *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _de .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _de .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _de .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_geef ._egfdd =true ;_geef ._bcce =startRow ;_geef ._fccf =endRow ;return nil ;};

// SetFillColor sets the fill color.
func (_dbce *Ellipse )SetFillColor (col Color ){_dbce ._adcg =_da .NewPdfColorDeviceRGB (col .ToRGB ())};func (_efea *TOCLine )prepareParagraph (_fcgg *StyledParagraph ,_affdd DrawContext ){_beefe :=_efea .Title .Text ;if _efea .Number .Text !=""{_beefe ="\u0020"+_beefe ;};_beefe +="\u0020";_deadd :=_efea .Page .Text ;if _deadd !=""{_deadd ="\u0020"+_deadd ;};_fcgg ._caca =[]*TextChunk {{Text :_efea .Number .Text ,Style :_efea .Number .Style ,_accfg :_efea .getLineLink ()},{Text :_beefe ,Style :_efea .Title .Style ,_accfg :_efea .getLineLink ()},{Text :_deadd ,Style :_efea .Page .Style ,_accfg :_efea .getLineLink ()}};_fcgg .wrapText ();_dcef :=len (_fcgg ._cff );if _dcef ==0{return ;};_ddeb :=_affdd .Width *1000-_fcgg .getTextLineWidth (_fcgg ._cff [_dcef -1]);_fcab :=_fcgg .getTextLineWidth ([]*TextChunk {&_efea .Separator });_ccace :=int (_ddeb /_fcab );_ffga :=_e .Repeat (_efea .Separator .Text ,_ccace );_efaec :=_efea .Separator .Style ;_ffgad :=_fcgg .Insert (2,_ffga );_ffgad .Style =_efaec ;_ffgad ._accfg =_efea .getLineLink ();_ddeb =_ddeb -float64 (_ccace )*_fcab ;if _ddeb > 500{_efadd ,_bbec :=_efaec .Font .GetRuneMetrics (' ');if _bbec &&_ddeb > _efadd .Wx {_ececa :=int (_ddeb /_efadd .Wx );if _ececa > 0{_ebdfc :=_efaec ;_ebdfc .FontSize =1;_ffgad =_fcgg .Insert (2,_e .Repeat ("\u0020",_ececa ));_ffgad .Style =_ebdfc ;_ffgad ._accfg =_efea .getLineLink ();};};};};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_cabf *Image )SetMargins (left ,right ,top ,bottom float64 ){_cabf ._cagf ._bfca =left ;_cabf ._cagf ._dbca =right ;_cabf ._cagf ._agbf =top ;_cabf ._cagf ._cee =bottom ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;func (_ddf *Block )drawToPage (_afc *_da .PdfPage )error {_caf :=&_ab .ContentStreamOperations {};if _afc .Resources ==nil {_afc .Resources =_da .NewPdfPageResources ();};_fgb :=_dad (_caf ,_afc .Resources ,_ddf ._f ,_ddf ._fa );if _fgb !=nil {return _fgb ;};if _fgb =_egb (_ddf ._fa ,_afc .Resources );_fgb !=nil {return _fgb ;};if _fgb =_afc .AppendContentBytes (_caf .Bytes (),true );_fgb !=nil {return _fgb ;};for _ ,_ffad :=range _ddf ._ga {_afc .AddAnnotation (_ffad );};return nil ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_aecgd float64 ;_cdga float64 ;_ggbag float64 ;_dbba float64 ;_fbcb *_da .PdfColorDeviceRGB ;_ccfde float64 ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_dgba *Image )SetEncoder (encoder _ac .StreamEncoder ){_dgba ._bfba =encoder };func (_faag *Paragraph )wrapText ()error {if !_faag ._agbb ||int (_faag ._feec )<=0{_faag ._cebg =[]string {_faag ._decf };return nil ;};_ggbb :=NewTextChunk (_faag ._decf ,TextStyle {Font :_faag ._edgag ,FontSize :_faag ._agge });_cfdg ,_aegf :=_ggbb .Wrap (_faag ._feec );if _aegf !=nil {return _aegf ;};if _faag ._egfd > 0&&len (_cfdg )> _faag ._egfd {_cfdg =_cfdg [:_faag ._egfd ];};_faag ._cebg =_cfdg ;return nil ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_egba *Image )GetHorizontalAlignment ()HorizontalAlignment {return _egba ._cgca };

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_ccag DrawContext )([]*Block ,DrawContext ,error );};

// SetFillColor sets the fill color.
func (_ecead *PolyBezierCurve )SetFillColor (color Color ){_ecead ._dcdc .FillColor =_da .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetLineHeight sets the line height (1.0 default).
func (_deed *StyledParagraph )SetLineHeight (lineheight float64 ){_deed ._gcgaf =lineheight };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_ccbg *TOCLine )SetLink (page int64 ,x ,y float64 ){_ccbg ._cdcg =x ;_ccbg ._degc =y ;_ccbg ._cacea =page ;_gcbd :=_ccbg ._agddae ._dgcgc .Color ;_ccbg .Number .Style .Color =_gcbd ;_ccbg .Title .Style .Color =_gcbd ;_ccbg .Separator .Style .Color =_gcbd ;_ccbg .Page .Style .Color =_gcbd ;};

// NewPageBreak create a new page break.
func (_aabb *Creator )NewPageBreak ()*PageBreak {return _ffaa ()};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ada *Block )Draw (d Drawable )error {_fde :=DrawContext {};_fde .Width =_ada ._acc ;_fde .Height =_ada ._ff ;_fde .PageWidth =_ada ._acc ;_fde .PageHeight =_ada ._ff ;_fde .X =0;_fde .Y =0;_dbe ,_ ,_gefc :=d .GeneratePageBlocks (_fde );if _gefc !=nil {return _gefc ;};if len (_dbe )!=1{return _de .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_adff :=range _dbe {if _feb :=_ada .mergeBlocks (_adff );_feb !=nil {return _feb ;};};return nil ;};func (_adbg *TOCLine )getLineLink ()*_da .PdfAnnotation {if _adbg ._cacea <=0{return nil ;};return _ace (_adbg ._cacea -1,_adbg ._cdcg ,_adbg ._degc ,0);};func (_fded *Table )resetColumnWidths (){_fded ._cgcgb =[]float64 {};_abadd :=float64 (1.0)/float64 (_fded ._gfbe );for _dbgg :=0;_dbgg < _fded ._gfbe ;_dbgg ++{_fded ._cgcgb =append (_fded ._cgcgb ,_abadd );};};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gaf *Invoice )SetAddressStyle (style TextStyle ){_gaf ._fgfd =style };

// NewInvoice returns an instance of an empty invoice.
func (_addc *Creator )NewInvoice ()*Invoice {_edeb :=_addc .NewTextStyle ();_edeb .Font =_addc ._ccge ;return _ebead (_addc .NewTextStyle (),_edeb );};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_bfcac *Division )Width ()float64 {return 0};

// SetAngle sets the rotation angle of the text.
func (_bafffb *Paragraph )SetAngle (angle float64 ){_bafffb ._agec =angle };

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_cdge *Rectangle )GetCoords ()(float64 ,float64 ){return _cdge ._adgf ,_cdge ._fbge };func (_bae *StyledParagraph )wrapText ()error {return _bae .wrapChunks (true )};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_egac *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_egac ._egagb =halign };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_feeb *Chapter )SetIncludeInTOC (includeInTOC bool ){_feeb ._aeba =includeInTOC };func (_befbf *Paragraph )getMaxLineWidth ()float64 {if _befbf ._cebg ==nil ||len (_befbf ._cebg )==0{_befbf .wrapText ();};var _dbgb float64 ;for _ ,_egegc :=range _befbf ._cebg {_efae :=_befbf .getTextLineWidth (_egegc );if _efae > _dbgb {_dbgb =_efae ;};};return _dbgb ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_cfgd :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_bg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cfgd ;};var _fdg ,_edbe ,_gdd int ;if len (hexStr )==4{var _egbc ,_ege ,_gcb int ;_egbg ,_dead :=_b .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_egbc ,&_ege ,&_gcb );if _dead !=nil {_bg .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_dead );return _cfgd ;};if _egbg !=3{_bg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cfgd ;};_fdg =_egbc *16+_egbc ;_edbe =_ege *16+_ege ;_gdd =_gcb *16+_gcb ;}else {_aba ,_bdbf :=_b .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fdg ,&_edbe ,&_gdd );if _bdbf !=nil {_bg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cfgd ;};if _aba !=3{_bg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_aba );return _cfgd ;};};_eaa :=float64 (_fdg )/255.0;_bef :=float64 (_edbe )/255.0;_agab :=float64 (_gdd )/255.0;_cfgd ._gdbe =_eaa ;_cfgd ._ddcc =_bef ;_cfgd ._def =_agab ;return _cfgd ;};

// SetSellerAddress sets the seller address of the invoice.
func (_dge *Invoice )SetSellerAddress (address *InvoiceAddress ){_dge ._ggbd =address };func (_bcgd *FilledCurve )draw (_geda string )([]byte ,*_da .PdfRectangle ,error ){_ddb :=_eb .NewCubicBezierPath ();for _ ,_fcba :=range _bcgd ._abaa {_ddb =_ddb .AppendCurve (_fcba );};creator :=_ab .NewContentCreator ();creator .Add_q ();if _bcgd .FillEnabled {creator .Add_rg (_bcgd ._fae .R (),_bcgd ._fae .G (),_bcgd ._fae .B ());};if _bcgd .BorderEnabled {creator .Add_RG (_bcgd ._eeea .R (),_bcgd ._eeea .G (),_bcgd ._eeea .B ());creator .Add_w (_bcgd .BorderWidth );};if len (_geda )> 1{creator .Add_gs (_ac .PdfObjectName (_geda ));};_eb .DrawBezierPathWithCreator (_ddb ,creator );creator .Add_h ();if _bcgd .FillEnabled &&_bcgd .BorderEnabled {creator .Add_B ();}else if _bcgd .FillEnabled {creator .Add_f ();}else if _bcgd .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_gdda :=_ddb .GetBoundingBox ();if _bcgd .BorderEnabled {_gdda .Height +=_bcgd .BorderWidth ;_gdda .Width +=_bcgd .BorderWidth ;_gdda .X -=_bcgd .BorderWidth /2;_gdda .Y -=_bcgd .BorderWidth /2;};_bfbe :=&_da .PdfRectangle {};_bfbe .Llx =_gdda .X ;_bfbe .Lly =_gdda .Y ;_bfbe .Urx =_gdda .X +_gdda .Width ;_bfbe .Ury =_gdda .Y +_gdda .Height ;return creator .Bytes (),_bfbe ,nil ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_dbea *Chapter )NewSubchapter (title string )*Chapter {_edb :=_fgbcb (_dbea ._ggfb ._edgag );_edb .FontSize =14;_dbea ._ggac ++;_efge :=_bfa (_dbea ,_dbea ._gbee ,_dbea ._dcgb ,title ,_dbea ._ggac ,_edb );_dbea .Add (_efge );return _efge ;};

// SetLineColor sets the line color.
func (_gbdd *Polyline )SetLineColor (color Color ){_gbdd ._adbe .LineColor =_da .NewPdfColorDeviceRGB (color .ToRGB ());};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_adbe *_eb .Polyline ;_cgge float64 ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_bgcb *Creator )NewParagraph (text string )*Paragraph {return _abgf (text ,_bgcb .NewTextStyle ())};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_afbbb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _bcgdd (number ,title ,page ,level ,style );};

// AddLine appends a new line to the invoice line items table.
func (_cdef *Invoice )AddLine (values ...string )[]*InvoiceCell {_gfcab :=len (_cdef ._ccce );var _fafcg []*InvoiceCell ;for _dacb ,_dfdd :=range values {_cgfb :=_cdef .newCell (_dfdd ,_cdef ._dfgf );if _dacb < _gfcab {_cgfb .Alignment =_cdef ._ccce [_dacb ].Alignment ;};_fafcg =append (_fafcg ,_cgfb );};_cdef ._fbcc =append (_cdef ._fbcc ,_fafcg );return _fafcg ;};type margins struct{_bfca float64 ;_dbca float64 ;_agbf float64 ;_cee float64 ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_eab *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eab ._cagf ._bfca ,_eab ._cagf ._dbca ,_eab ._cagf ._agbf ,_eab ._cagf ._cee ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_cccee *StyledParagraph )SetTextAlignment (align TextAlignment ){_cccee ._dabff =align };

// SetFillColor sets background color for border.
func (_cge *border )SetFillColor (col Color ){_cge ._aff =_da .NewPdfColorDeviceRGB (col .ToRGB ())};func _adgdcb (_cggb []_eb .Point )*Polyline {return &Polyline {_adbe :&_eb .Polyline {Points :_cggb ,LineColor :_da .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_cgge :1.0};};

// CurRow returns the currently active cell's row number.
func (_dbdeg *Table )CurRow ()int {_fcfef :=(_dbdeg ._fbfgf -1)/_dbdeg ._gfbe +1;return _fcfef };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_deade *List )Marker ()*TextChunk {return &_deade ._cgfe };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_abgb *Creator )NewPolyBezierCurve (curves []_eb .CubicBezierCurve )*PolyBezierCurve {return _bcfg (curves );};

// Write output of creator to io.Writer interface.
func (_bdg *Creator )Write (ws _ad .Writer )error {if _cedb :=_bdg .Finalize ();_cedb !=nil {return _cedb ;};_afda :=_da .NewPdfWriter ();_afda .SetOptimizer (_bdg ._gfc );if _bdg ._fdgd !=nil {_cda :=_afda .SetForms (_bdg ._fdgd );if _cda !=nil {_bg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cda );return _cda ;};};if _bdg ._dda !=nil {_afda .AddOutlineTree (_bdg ._dda );}else if _bdg ._gae !=nil &&_bdg .AddOutlines {_afda .AddOutlineTree (&_bdg ._gae .ToPdfOutline ().PdfOutlineTreeNode );};if _bdg ._fdge !=nil {if _abad :=_afda .SetPageLabels (_bdg ._fdge );_abad !=nil {_bg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_abad );return _abad ;};};if _bdg ._gdcd !=nil {for _ ,_dfeg :=range _bdg ._gdcd {_fcfb :=_dfeg .SubsetRegistered ();if _fcfb !=nil {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_fcfb );return _fcfb ;};};};if _bdg ._ccfd !=nil {_afbb :=_bdg ._ccfd (&_afda );if _afbb !=nil {_bg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_afbb );return _afbb ;};};for _ ,_dcgbg :=range _bdg ._egae {_ccea :=_afda .AddPage (_dcgbg );if _ccea !=nil {_bg .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_ccea );return _ccea ;};};_fcgf :=_afda .Write (ws );if _fcgf !=nil {return _fcgf ;};return nil ;};func _bfa (_abb *Chapter ,_ddc *TOC ,_aaba *_da .Outline ,_gedf string ,_bagf int ,_abf TextStyle )*Chapter {var _bdc uint =1;if _abb !=nil {_bdc =_abb ._fdec +1;};_bfe :=&Chapter {_bbfb :_bagf ,_daad :_gedf ,_aea :true ,_aeba :true ,_ebea :_abb ,_gbee :_ddc ,_dcgb :_aaba ,_fgf :[]Drawable {},_fdec :_bdc };_edg :=_abgf (_bfe .headingText (),_abf );_edg .SetFont (_abf .Font );_edg .SetFontSize (_abf .FontSize );_bfe ._ggfb =_edg ;return _bfe ;};func _bdbb ()*FilledCurve {_babe :=FilledCurve {};_babe ._abaa =[]_eb .CubicBezierCurve {};return &_babe ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_dbfa *Creator )NewChapter (title string )*Chapter {_dbfa ._bfbf ++;_ccb :=_dbfa .NewTextStyle ();_ccb .FontSize =16;return _bfa (nil ,_dbfa ._efdc ,_dbfa ._gae ,title ,_dbfa ._bfbf ,_ccb );};

// WriteToFile writes the Creator output to file specified by path.
func (_cdgfe *Creator )WriteToFile (outputPath string )error {_eebf ,_cfba :=_g .Create (outputPath );if _cfba !=nil {return _cfba ;};defer _eebf .Close ();return _cdgfe .Write (_eebf );};func (_acced *StyledParagraph )getLineHeight (_baba int )(_caacc ,_bgdab float64 ){if _acced ._cff ==nil ||len (_acced ._cff )==0{_acced .wrapText ();};if _baba < 0||_baba > len (_acced ._cff )-1{_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_baba );return 0,0;};_fbcbc :=_acced ._cff [_baba ];for _ ,_eceg :=range _fbcbc {_cegbb ,_cegg :=_eceg .Style .Font .GetFontDescriptor ();if _cegg !=nil {_bg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _fdad float64 ;if _cegbb !=nil {if _fdad ,_cegg =_cegbb .GetCapHeight ();_cegg !=nil {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cegg );};};if int (_fdad )<=0{_bg .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_fdad =1000;};_gaadb :=_fdad /1000.0*_eceg .Style .FontSize *_acced ._gcgaf ;if _gaadb > _caacc {_caacc =_gaadb ;};_gaadb =_acced ._gcgaf *_eceg .Style .FontSize ;if _gaadb > _bgdab {_bgdab =_gaadb ;};};return _caacc ,_bgdab ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_faed *Paragraph )Height ()float64 {_faed .wrapText ();return float64 (len (_faed ._cebg ))*_faed ._ebeae *_faed ._agge ;};

// Width returns the Block's width.
func (_fge *Block )Width ()float64 {return _fge ._acc };func (_fcbg *TableCell )height (_ebgb float64 )float64 {var _eegg float64 ;switch _abde :=_fcbg ._abcfe .(type ){case *Paragraph :if _abde ._agbb {_abde .SetWidth (_ebgb -_fcbg ._gcef -_abde ._gffg ._bfca -_abde ._gffg ._dbca );};_eegg =_abde .Height ()+_abde ._gffg ._agbf +_abde ._gffg ._cee +0.5*_abde ._agge *_abde ._ebeae ;case *StyledParagraph :if _abde ._afgdg {_abde .SetWidth (_ebgb -_fcbg ._gcef -_abde ._bbgga ._bfca -_abde ._bbgga ._dbca );};_eegg =_abde .Height ()+_abde ._bbgga ._agbf +_abde ._bbgga ._cee +0.5*_abde .getTextHeight ();case *Image :_eegg =_abde .Height ()+_abde ._cagf ._agbf +_abde ._cagf ._cee ;case *Table :_eegg =_abde .Height ()+_abde ._cebc ._agbf +_abde ._cebc ._cee ;case *List :_eegg =_abde .tableHeight (_ebgb -_fcbg ._gcef )+_abde ._cccf ._agbf +_abde ._cccf ._cee ;case *Division :_eegg =_abde .ctxHeight (_ebgb -_fcbg ._gcef )+_abde ._bca ._agbf +_abde ._bca ._cee ;};return _eegg ;};func _bgcg (_efbaf string ,_affgc ,_eagaa TextStyle )*TOC {_dabaf :=_eagaa ;_dabaf .FontSize =14;_aeeb :=_adce (_dabaf );_aeeb .SetEnableWrap (true );_aeeb .SetTextAlignment (TextAlignmentLeft );_aeeb .SetMargins (0,0,0,5);_gadc :=_aeeb .Append (_efbaf );_gadc .Style =_dabaf ;return &TOC {_dcae :_aeeb ,_fgceb :[]*TOCLine {},_fbgf :_affgc ,_fbcgb :_affgc ,_cacae :_affgc ,_cagfg :_affgc ,_fedcf :"\u002e",_ccgf :10,_ggbaa :margins {0,0,2,2},_abafa :_abbd ,_bdded :_affgc ,_eabe :true };};

// SellerAddress returns the seller address used in the invoice template.
func (_cba *Invoice )SellerAddress ()*InvoiceAddress {return _cba ._ggbd };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_aebfc *List )Add (item VectorDrawable )(*TextChunk ,error ){_eea :=&listItem {_gfbg :item ,_cdbcg :_aebfc ._cgfe };switch _fbae :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _fbae ._fabc {_fbae ._fdbd =15;};default:return nil ,_de .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_aebfc ._fafce =append (_aebfc ._fafce ,_eea );return &_eea ._cdbcg ,nil ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_gfbf *Chapter )GetHeading ()*Paragraph {return _gfbf ._ggfb };

// SetText sets the text content of the Paragraph.
func (_cabc *Paragraph )SetText (text string ){_cabc ._decf =text };

// NewTable create a new Table with a specified number of columns.
func (_cgff *Creator )NewTable (cols int )*Table {return _fcae (cols )};

// SetFillOpacity sets the fill opacity.
func (_agdc *PolyBezierCurve )SetFillOpacity (opacity float64 ){_agdc ._dgdc =opacity };

// SetPos sets absolute positioning with specified coordinates.
func (_efcd *StyledParagraph )SetPos (x ,y float64 ){_efcd ._cceg =_gcda ;_efcd ._agff =x ;_efcd ._cggeb =y ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_bbfb int ;_daad string ;_ggfb *Paragraph ;_fgf []Drawable ;_ggac int ;_aea bool ;_aeba bool ;_beca positioning ;_bbga ,_dbcg float64 ;_fdc margins ;_ebea *Chapter ;_gbee *TOC ;_dcgb *_da .Outline ;_efee *_da .OutlineItem ;_fdec uint ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_bgfe *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_dbbe :=_adce (_bgfe ._gebf );_dbbe .Append (text );_cef ,_bdde :=_bgfe .Add (_dbbe );return _dbbe ,_cef ,_bdde ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_ggcf *Image )SetPos (x ,y float64 ){_ggcf ._eda =_gcda ;_ggcf ._fgfb =x ;_ggcf ._cdfg =y };func (_deec *Invoice )newColumn (_ddee string ,_ebbb CellHorizontalAlignment )*InvoiceCell {_dece :=&InvoiceCell {_deec ._cdaef ,_ddee };_dece .Alignment =_ebbb ;return _dece ;};

// Length calculates and returns the line length.
func (_efdd *Line )Length ()float64 {return _ag .Sqrt (_ag .Pow (_efdd ._ggbag -_efdd ._aecgd ,2.0)+_ag .Pow (_efdd ._dbba -_efdd ._cdga ,2.0));};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_cgea *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bddb []*Block ;_dbde :=ctx ;if _cgea ._ffd .isRelative (){ctx .X +=_cgea ._bca ._bfca ;ctx .Y +=_cgea ._bca ._agbf ;ctx .Width -=_cgea ._bca ._bfca +_cgea ._bca ._dbca ;ctx .Height -=_cgea ._bca ._agbf +_cgea ._bca ._cee ;};ctx .Inline =_cgea ._feg ;_agcf :=ctx ;_deda :=ctx ;var _bddg float64 ;for _ ,_bbgg :=range _cgea ._caed {if ctx .Inline {if (ctx .X -_agcf .X )+_bbgg .Width ()<=ctx .Width {ctx .Y =_deda .Y ;ctx .Height =_deda .Height ;}else {ctx .X =_agcf .X ;ctx .Width =_agcf .Width ;_deda .Y +=_bddg ;_deda .Height -=_bddg ;_bddg =0;};};_ffdb ,_dcga ,_cgbb :=_bbgg .GeneratePageBlocks (ctx );if _cgbb !=nil {_bg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_cgbb );return nil ,ctx ,_cgbb ;};if len (_ffdb )< 1{continue ;};if len (_bddb )> 0{_bddb [len (_bddb )-1].mergeBlocks (_ffdb [0]);_bddb =append (_bddb ,_ffdb [1:]...);}else {_bddb =append (_bddb ,_ffdb [0:]...);};if ctx .Inline {if ctx .Page !=_dcga .Page {_agcf .Y =ctx .Margins ._agbf ;_agcf .Height =ctx .PageHeight -ctx .Margins ._agbf ;_deda .Y =_agcf .Y ;_deda .Height =_agcf .Height ;_bddg =_dcga .Height -_agcf .Height ;}else {if _gggf :=ctx .Height -_dcga .Height ;_gggf > _bddg {_bddg =_gggf ;};};}else {_dcga .X =ctx .X ;};ctx =_dcga ;};ctx .Inline =_dbde .Inline ;if _cgea ._ffd .isRelative (){ctx .X =_dbde .X ;};if _cgea ._ffd .isAbsolute (){return _bddb ,_dbde ,nil ;};return _bddb ,ctx ,nil ;};

// Title returns the title of the invoice.
func (_aebc *Invoice )Title ()string {return _aebc ._adcb };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_bcbff *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_bcbff ._feccc =valign };

// SetHeight sets the Image's document height to specified h.
func (_cadd *Image )SetHeight (h float64 ){_cadd ._dgd =h };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gdfc *Paragraph )SetTextAlignment (align TextAlignment ){_gdfc ._dbece =align };

// SetTerms sets the terms and conditions section of the invoice.
func (_gcacf *Invoice )SetTerms (title ,content string ){_gcacf ._baff =[2]string {title ,content }};func (_eeage *StyledParagraph )getTextLineWidth (_dbcebd []*TextChunk )float64 {var _efaee float64 ;_badfc :=len (_dbcebd );for _fgee ,_gbfa :=range _dbcebd {_cabb :=&_gbfa .Style ;_addb :=len (_gbfa .Text );for _gddf ,_ecbac :=range _gbfa .Text {if _ecbac =='\u000A'{continue ;};_fbce ,_edbgg :=_cabb .Font .GetRuneMetrics (_ecbac );if !_edbgg {_bg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ecbac );return -1;};_efaee +=_cabb .FontSize *_fbce .Wx ;if _ecbac !=' '&&(_fgee !=_badfc -1||_gddf !=_addb -1){_efaee +=_cabb .CharSpacing *1000.0;};};};return _efaee ;};

// SetMargins sets the Paragraph's margins.
func (_eeae *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_eeae ._bbgga ._bfca =left ;_eeae ._bbgga ._dbca =right ;_eeae ._bbgga ._agbf =top ;_eeae ._bbgga ._cee =bottom ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_gceb *Ellipse )GetCoords ()(float64 ,float64 ){return _gceb ._dgfd ,_gceb ._cdae };

// SetFillColor sets the fill color for the path.
func (_dcdd *FilledCurve )SetFillColor (color Color ){_dcdd ._fae =_da .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetFont sets the Paragraph's font.
func (_fffb *Paragraph )SetFont (font *_da .PdfFont ){_fffb ._edgag =font };

// Height returns the current page height.
func (_cddb *Creator )Height ()float64 {return _cddb ._gddb };func (_aac positioning )isRelative ()bool {return _aac ==_abbd };func (_cdg *Chapter )headingText ()string {_ega :=_cdg ._daad ;if _ggg :=_cdg .headingNumber ();_ggg !=""{_ega =_b .Sprintf ("\u0025\u0073\u0020%\u0073",_ggg ,_ega );};return _ega ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_aefb *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_ageae :=range subtable ._adceb {_cgcb :=&TableCell {};*_cgcb =*_ageae ;_cgcb ._baaf =_aefb ;_cgcb ._dbaad +=col -1;if _bffg :=_aefb ._gfbe -(_cgcb ._dbaad -1);_bffg < _cgcb ._ddedg {_aefb ._gfbe +=_cgcb ._ddedg -_bffg ;_aefb .resetColumnWidths ();_bg .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_aefb ._gfbe );};_cgcb ._gggcc +=row -1;_cdgbd :=subtable ._caceb [_ageae ._gggcc -1];if _cgcb ._gggcc > _aefb ._bead {for _cgcb ._gggcc > _aefb ._bead {_aefb ._bead ++;_aefb ._caceb =append (_aefb ._caceb ,_aefb ._cbcfeg );};_aefb ._caceb [_cgcb ._gggcc -1]=_cdgbd ;}else {_aefb ._caceb [_cgcb ._gggcc -1]=_ag .Max (_aefb ._caceb [_cgcb ._gggcc -1],_cdgbd );};_aefb ._adceb =append (_aefb ._adceb ,_cgcb );};_a .Slice (_aefb ._adceb ,func (_fedc ,_cdbd int )bool {_bggc :=_aefb ._adceb [_fedc ]._gggcc ;_dcegc :=_aefb ._adceb [_cdbd ]._gggcc ;if _bggc < _dcegc {return true ;};if _bggc > _dcegc {return false ;};return _aefb ._adceb [_fedc ]._dbaad < _aefb ._adceb [_cdbd ]._dbaad ;});};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_caca []*TextChunk ;_bgcf TextStyle ;_dgcgc TextStyle ;_dabff TextAlignment ;_gcgaf float64 ;_afgdg bool ;_ggdg float64 ;_babed bool ;_bdaf float64 ;_bbgga margins ;_cceg positioning ;_agff float64 ;_cggeb float64 ;_gdcc float64 ;_aece float64 ;_cff [][]*TextChunk ;_aedb func (_facf *StyledParagraph ,_bgba DrawContext );};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bccea *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bccea .Text },nil ;};var _dffee []string ;var _ddeee []rune ;var _cfec float64 ;var _bbfg []float64 ;_ddcf :=_bccea .Style ;for _ ,_ceaa :=range _bccea .Text {if _ceaa =='\u000A'{_dffee =append (_dffee ,_e .TrimRightFunc (string (_ddeee ),_aa .IsSpace )+string (_ceaa ));_ddeee =nil ;_cfec =0;_bbfg =nil ;continue ;};_ffgfd :=_ceaa ==' ';_eccb ,_aefca :=_ddcf .Font .GetRuneMetrics (_ceaa );if !_aefca {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_ceaa ,_ceaa ,_ddcf .Font .BaseFont (),_ddcf .Font .Subtype ());_bg .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ddcf .Font );_bg .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ddcf .Font .Encoder ());return nil ,_de .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_cgce :=_ddcf .FontSize *_eccb .Wx ;_gbca :=_cgce ;if !_ffgfd {_gbca =_cgce +_ddcf .CharSpacing *1000.0;};if _cfec +_cgce > width *1000.0{_cbddaf :=-1;if !_ffgfd {for _bggdg :=len (_ddeee )-1;_bggdg >=0;_bggdg --{if _ddeee [_bggdg ]==' '{_cbddaf =_bggdg ;break ;};};};_fdee :=string (_ddeee );if _cbddaf > 0{_fdee =string (_ddeee [0:_cbddaf +1]);_ddeee =append (_ddeee [_cbddaf +1:],_ceaa );_bbfg =append (_bbfg [_cbddaf +1:],_gbca );_cfec =0;for _ ,_edafb :=range _bbfg {_cfec +=_edafb ;};}else {if _ffgfd {_ddeee =[]rune {};_bbfg =[]float64 {};_cfec =0;}else {_ddeee =[]rune {_ceaa };_bbfg =[]float64 {_gbca };_cfec =_gbca ;};};_dffee =append (_dffee ,_e .TrimRightFunc (_fdee ,_aa .IsSpace ));}else {_ddeee =append (_ddeee ,_ceaa );_cfec +=_gbca ;_bbfg =append (_bbfg ,_gbca );};};if len (_ddeee )> 0{_dffee =append (_dffee ,string (_ddeee ));};return _dffee ,nil ;};

// SetWidthTop sets border width for top.
func (_fff *border )SetWidthTop (bw float64 ){_fff ._ecbd =bw };

// NewList creates a new list.
func (_edba *Creator )NewList ()*List {return _fgfcd (_edba .NewTextStyle ())};func (_ba *Block )setOpacity (_gef float64 ,_fg float64 )(string ,error ){if (_gef < 0||_gef >=1.0)&&(_fg < 0||_fg >=1.0){return "",nil ;};_eec :=0;_ged :=_b .Sprintf ("\u0047\u0053\u0025\u0064",_eec );for _ba ._fa .HasExtGState (_ac .PdfObjectName (_ged )){_eec ++;_ged =_b .Sprintf ("\u0047\u0053\u0025\u0064",_eec );};_gaa :=_ac .MakeDict ();if _gef >=0&&_gef < 1.0{_gaa .Set ("\u0063\u0061",_ac .MakeFloat (_gef ));};if _fg >=0&&_fg < 1.0{_gaa .Set ("\u0043\u0041",_ac .MakeFloat (_fg ));};_dc :=_ba ._fa .AddExtGState (_ac .PdfObjectName (_ged ),_gaa );if _dc !=nil {return "",_dc ;};return _ged ,nil ;};

// Add adds a new line with the default style to the table of contents.
func (_bcdfc *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_aecdg :=_bcdfc .AddLine (_bcgdd (TextChunk {Text :number ,Style :_bcdfc ._fbgf },TextChunk {Text :title ,Style :_bcdfc ._fbcgb },TextChunk {Text :page ,Style :_bcdfc ._cagfg },level ,_bcdfc ._bdded ));if _aecdg ==nil {return nil ;};_cbag :=&_bcdfc ._ggbaa ;_aecdg .SetMargins (_cbag ._bfca ,_cbag ._dbca ,_cbag ._agbf ,_cbag ._cee );_aecdg .SetLevelOffset (_bcdfc ._ccgf );_aecdg .Separator .Text =_bcdfc ._fedcf ;_aecdg .Separator .Style =_bcdfc ._cacae ;return _aecdg ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_egag *Creator )RotateDeg (angleDeg int64 )error {_ecbad :=_egag .getActivePage ();if _ecbad ==nil {_bg .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _de .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_bg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _de .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _fef int64 ;if _ecbad .Rotate !=nil {_fef =*(_ecbad .Rotate );};_fef +=angleDeg ;_ecbad .Rotate =&_fef ;return nil ;};func (_cbb *Creator )setActivePage (_gbbf *_da .PdfPage ){_cbb ._gecd =_gbbf };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_agcfcc *TOCLine )SetStyle (style TextStyle ){_agcfcc .Number .Style =style ;_agcfcc .Title .Style =style ;_agcfcc .Separator .Style =style ;_agcfcc .Page .Style =style ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_aeaa *Creator )NewImage (img *_da .Image )(*Image ,error ){return _feaf (img )};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_dcgc *List )Width ()float64 {return 0};

// RotatedSize returns the width and height of the rotated block.
func (_efd *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_aaf ,_gce :=_abafae (_efd ._acc ,_efd ._ff ,_efd ._ee );return _aaf ,_gce ;};func _eddd (_agfc ,_ffcb ,_gcdd ,_dgca float64 )*Ellipse {_cegd :=&Ellipse {};_cegd ._dgfd =_agfc ;_cegd ._cdae =_ffcb ;_cegd ._efa =_gcdd ;_cegd ._dee =_dgca ;_cegd ._cgfa =_da .NewPdfColorDeviceRGB (0,0,0);_cegd ._fgeff =1.0;return _cegd ;};func _edgb (_dgacc *_da .PdfAnnotation )*_da .PdfAnnotation {if _dgacc ==nil {return nil ;};var _fgfe *_da .PdfAnnotation ;switch _gbdc :=_dgacc .GetContext ().(type ){case *_da .PdfAnnotationLink :if _bdga :=_bcdfg (_gbdc );_bdga !=nil {_fgfe =_bdga .PdfAnnotation ;};};return _fgfe ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_febaa *TOCLine )LevelOffset ()float64 {return _febaa ._cgdb };

// Text sets the text content of the Paragraph.
func (_fgc *Paragraph )Text ()string {return _fgc ._decf };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// Notes returns the notes section of the invoice as a title-content pair.
func (_efc *Invoice )Notes ()(string ,string ){return _efc ._gagb [0],_efc ._gagb [1]};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_bba *Invoice )SetNoteHeadingStyle (style TextStyle ){_bba ._fegg =style };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_fcd *Creator )Finalize ()error {if _fcd ._cfe {return nil ;};_gbbd :=len (_fcd ._egae );_ffgg :=0;if _fcd ._efgc !=nil {_ffgg ++;};if _fcd .AddTOC {_fcd .initContext ();_fcd ._acf .Page =_ffgg +1;if _fcd ._efbe !=nil {if _fcca :=_fcd ._efbe (_fcd ._efdc );_fcca !=nil {return _fcca ;};};_ccdb ,_ ,_cacf :=_fcd ._efdc .GeneratePageBlocks (_fcd ._acf );if _cacf !=nil {_bg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_cacf );return _cacf ;};_ffgg +=len (_ccdb );_beg :=_fcd ._efdc .Lines ();for _ ,_fgag :=range _beg {_ceeg ,_eee :=_cb .Atoi (_fgag .Page .Text );if _eee !=nil {continue ;};_fgag .Page .Text =_cb .Itoa (_ceeg +_ffgg );};};_dec :=false ;if _fcd ._efgc !=nil {_gbbd ++;_ebbg :=_fcd .newPage ();_fcd ._egae =append ([]*_da .PdfPage {_ebbg },_fcd ._egae ...);_fcd .setActivePage (_ebbg );_gac :=FrontpageFunctionArgs {PageNum :1,TotalPages :_gbbd };_fcd ._efgc (_gac );_dec =true ;};if _fcd .AddTOC {_fcd .initContext ();if _fcd ._efbe !=nil {if _ede :=_fcd ._efbe (_fcd ._efdc );_ede !=nil {_bg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_ede );return _ede ;};};_dbeg :=_fcd ._efdc .Lines ();for _ ,_cbbe :=range _dbeg {_cbbe ._cacea +=int64 (_ffgg );};var _cab []*_da .PdfPage ;_efbg ,_ ,_ :=_fcd ._efdc .GeneratePageBlocks (_fcd ._acf );for _ ,_eafa :=range _efbg {_eafa .SetPos (0,0);_gbbd ++;_ebec :=_fcd .newPage ();_cab =append (_cab ,_ebec );_fcd .setActivePage (_ebec );_fcd .Draw (_eafa );};if _dec {_afg :=_fcd ._egae [0];_dfc :=_fcd ._egae [1:];_fcd ._egae =append ([]*_da .PdfPage {_afg },_cab ...);_fcd ._egae =append (_fcd ._egae ,_dfc ...);}else {_fcd ._egae =append (_cab ,_fcd ._egae ...);};};if _fcd ._gae !=nil &&_fcd .AddOutlines {var _gee func (_aebf *_da .OutlineItem );_gee =func (_deg *_da .OutlineItem ){_deg .Dest .Page +=int64 (_ffgg );if _cga :=int (_deg .Dest .Page );_cga >=0&&_cga < len (_fcd ._egae ){_deg .Dest .PageObj =_fcd ._egae [_cga ].GetPageAsIndirectObject ();}else {_bg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_cga );};_deg .Dest .Y =_fcd ._gddb -_deg .Dest .Y ;_acbe :=_deg .Items ();for _ ,_aae :=range _acbe {_gee (_aae );};};_bcfc :=_fcd ._gae .Items ();for _ ,_edgf :=range _bcfc {_gee (_edgf );};if _fcd .AddTOC {var _caeb int ;if _dec {_caeb =1;};_gcga :=_da .NewOutlineDest (int64 (_caeb ),0,_fcd ._gddb );if _caeb >=0&&_caeb < len (_fcd ._egae ){_gcga .PageObj =_fcd ._egae [_caeb ].GetPageAsIndirectObject ();}else {_bg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_caeb );};_fcd ._gae .Insert (0,_da .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_gcga ));};};for _gdfa ,_egf :=range _fcd ._egae {_fcd .setActivePage (_egf );if _fcd ._fca !=nil {_febe :=NewBlock (_fcd ._gagca ,_fcd ._dcaf ._agbf );_gefde :=HeaderFunctionArgs {PageNum :_gdfa +1,TotalPages :_gbbd };_fcd ._fca (_febe ,_gefde );_febe .SetPos (0,0);if _egad :=_fcd .Draw (_febe );_egad !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_egad );return _egad ;};};if _fcd ._cgb !=nil {_cdgf :=NewBlock (_fcd ._gagca ,_fcd ._dcaf ._cee );_fdfea :=FooterFunctionArgs {PageNum :_gdfa +1,TotalPages :_gbbd };_fcd ._cgb (_cdgf ,_fdfea );_cdgf .SetPos (0,_fcd ._gddb -_cdgf ._ff );if _ecde :=_fcd .Draw (_cdgf );_ecde !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_ecde );return _ecde ;};};_dbb ,_abd :=_fcd ._eacd [_egf ];if !_abd {continue ;};if _aecd ,_dfab :=_fcd ._dag [_egf ];_dfab {_dbb .transform (_aecd );};if _edca :=_dbb .drawToPage (_egf );_edca !=nil {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_gdfa +1,_edca );return _edca ;};};_fcd ._cfe =true ;return nil ;};

// SetInline sets the inline mode of the division.
func (_cbcfd *Division )SetInline (inline bool ){_cbcfd ._feg =inline };

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_cf *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cf ._ec ._bfca ,_cf ._ec ._dbca ,_cf ._ec ._agbf ,_cf ._ec ._cee ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_edebc *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _edebc ._aecgd ,_edebc ._cdga ,_edebc ._ggbag ,_edebc ._dbba ;};func (_cbe positioning )isAbsolute ()bool {return _cbe ==_gcda };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_bdeg *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aafdc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cbea ,_daga :=_aafdc .setOpacity (_bdeg ._dgdc ,_bdeg ._cdff );if _daga !=nil {return nil ,ctx ,_daga ;};_cbf :=_bdeg ._dcdc ;_cbf .FillEnabled =_cbf .FillColor !=nil ;_bbcf :=_cbf .Curves ;_agbbg :=ctx .PageHeight ;for _ddbf :=range _bbcf {_fdag :=&_bbcf [_ddbf ];_fdag .P0 .Y =_agbbg -_fdag .P0 .Y ;_fdag .P1 .Y =_agbbg -_fdag .P1 .Y ;_fdag .P2 .Y =_agbbg -_fdag .P2 .Y ;_fdag .P3 .Y =_agbbg -_fdag .P3 .Y ;};_gaag ,_ ,_daga :=_cbf .Draw (_cbea );if _daga !=nil {return nil ,ctx ,_daga ;};if _daga =_aafdc .addContentsByString (string (_gaag ));_daga !=nil {return nil ,ctx ,_daga ;};return []*Block {_aafdc },ctx ,nil ;};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_fce *Creator )AddPage (page *_da .PdfPage )error {_bfbg ,_gdf :=page .GetMediaBox ();if _gdf !=nil {_bg .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_gdf );return _gdf ;};_bfbg .Normalize ();_eecd ,_cbcfa :=_bfbg .Llx ,_bfbg .Lly ;_caee :=_gc .IdentityMatrix ();_edbf :=page .Rotate ;_bgda :=_edbf !=nil &&*_edbf %360!=0&&*_edbf %90==0;if _bgda {_dbfb :=float64 ((360+*page .Rotate %360)%360);_caee =_gc .RotationMatrix (_dbfb *_ag .Pi /180);if _dbfb ==90{_caee =_caee .Translate (_bfbg .Width (),0);}else if _dbfb ==180{_caee =_caee .Translate (_bfbg .Width (),_bfbg .Height ());}else if _dbfb ==270{_caee =_caee .Translate (0,_bfbg .Height ());};_caee =_caee .Round (0.000001);_bdd :=_eecdf (_bfbg ,_caee );_bfbg =_bdd ;_bfbg .Normalize ();};if _eecd !=0||_cbcfa !=0{_caee =_caee .Translate (_eecd ,_cbcfa );};if !_caee .Identity (){if _fce ._dag ==nil {_fce ._dag =map[*_da .PdfPage ]_gc .Matrix {};};_caee =_caee .Round (0.000001);_fce ._dag [page ]=_caee ;};_fce ._gagca =_bfbg .Width ();_fce ._gddb =_bfbg .Height ();_fce .initContext ();_fce ._egae =append (_fce ._egae ,page );_fce ._acf .Page ++;return nil ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_eaac *_da .XObjectImage ;_eacb *_da .Image ;_afgd float64 ;_cfdf ,_dgd float64 ;_fdfg ,_cgda float64 ;_eda positioning ;_cgca HorizontalAlignment ;_fgfb float64 ;_cdfg float64 ;_ddcb float64 ;_cagf margins ;_eefg ,_aega float64 ;_bfba _ac .StreamEncoder ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_adgf float64 ;_fbge float64 ;_bggd float64 ;_dade float64 ;_caea *_da .PdfColorDeviceRGB ;_cgde float64 ;_aafe *_da .PdfColorDeviceRGB ;_daba float64 ;_eefb float64 ;};

// SetWidthLeft sets border width for left.
func (_bcd *border )SetWidthLeft (bw float64 ){_bcd ._ece =bw };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_bcdda *Paragraph )SetWidth (width float64 ){_bcdda ._feec =width ;_bcdda .wrapText ()};func (_cbdg *StyledParagraph )getTextWidth ()float64 {var _ebdgd float64 ;_fbef :=len (_cbdg ._caca );for _fdbb ,_caffg :=range _cbdg ._caca {_ebfb :=&_caffg .Style ;_dage :=len (_caffg .Text );for _ecaa ,_geba :=range _caffg .Text {if _geba =='\u000A'{continue ;};_cbddd ,_eega :=_ebfb .Font .GetRuneMetrics (_geba );if !_eega {_bg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_geba );return -1;};_ebdgd +=_ebfb .FontSize *_cbddd .Wx ;if _geba !=' '&&(_fdbb !=_fbef -1||_ecaa !=_dage -1){_ebdgd +=_ebfb .CharSpacing *1000.0;};};};return _ebdgd ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_fadg *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _eaba (number ,title ,page ,level ,_fadg .NewTextStyle ());};func (_eddf *Paragraph )getTextWidth ()float64 {_bfbab :=0.0;for _ ,_gcff :=range _eddf ._decf {if _gcff =='\u000A'{continue ;};_agecd ,_gecc :=_eddf ._edgag .GetRuneMetrics (_gcff );if !_gecc {_bg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gcff ,_gcff );return -1;};_bfbab +=_eddf ._agge *_agecd .Wx ;};return _bfbab ;};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_gff *Creator )SetForms (form *_da .PdfAcroForm )error {_gff ._fdgd =form ;return nil };func (_bgbc *Paragraph )getTextLineWidth (_gaad string )float64 {var _ccagc float64 ;for _ ,_abeab :=range _gaad {if _abeab =='\u000A'{continue ;};_efdf ,_egeae :=_bgbc ._edgag .GetRuneMetrics (_abeab );if !_egeae {_bg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_abeab ,_abeab );return -1;};_ccagc +=_bgbc ._agge *_efdf .Wx ;};return _ccagc ;};func (_aafd *Invoice )generateNoteBlocks (_bbed DrawContext )([]*Block ,DrawContext ,error ){_daab :=_bdag ();_bege :=append ([][2]string {_aafd ._gagb ,_aafd ._baff },_aafd ._begg ...);for _ ,_ddeg :=range _bege {if _ddeg [1]!=""{_bafff :=_aafd .drawSection (_ddeg [0],_ddeg [1]);for _ ,_abec :=range _bafff {_daab .Add (_abec );};_dbcd :=_adce (_aafd ._adac );_dbcd .SetMargins (0,0,10,0);_daab .Add (_dbcd );};};return _daab .GeneratePageBlocks (_bbed );};func (_bcgf *List )tableHeight (_eeccb float64 )float64 {var _cace float64 ;for _ ,_egeg :=range _bcgf ._fafce {switch _efgf :=_egeg ._gfbg .(type ){case *Paragraph :_abdc :=_efgf ;if _abdc ._agbb {_abdc .SetWidth (_eeccb );};_cace +=_abdc .Height ()+_abdc ._gffg ._cee +_abdc ._gffg ._cee ;_cace +=0.5*_abdc ._agge *_abdc ._ebeae ;case *StyledParagraph :_bbgab :=_efgf ;if _bbgab ._afgdg {_bbgab .SetWidth (_eeccb );};_cace +=_bbgab .Height ()+_bbgab ._bbgga ._agbf +_bbgab ._bbgga ._cee ;_cace +=0.5*_bbgab .getTextHeight ();default:_cace +=_egeg ._gfbg .Height ();};};return _cace ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_fafce []*listItem ;_cccf margins ;_cgfe TextChunk ;_fdbd float64 ;_fabc bool ;_dgdd positioning ;_gebf TextStyle ;};

// SetWidthRight sets border width for right.
func (_gefd *border )SetWidthRight (bw float64 ){_gefd ._dfe =bw };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_fdce float64 ;_ecge float64 ;_fcb float64 ;_aaaeb float64 ;_ggeb float64 ;_fcdg float64 ;_cbbd *_da .PdfColorDeviceRGB ;_cgcg float64 ;};

// Angle returns the block rotation angle in degrees.
func (_bec *Block )Angle ()float64 {return _bec ._ee };

// SetStyleTop sets border style for top side.
func (_ffe *border )SetStyleTop (style CellBorderStyle ){_ffe ._edc =style };

// SetEnableWrap sets the line wrapping enabled flag.
func (_aeed *Paragraph )SetEnableWrap (enableWrap bool ){_aeed ._agbb =enableWrap ;_aeed ._gea =false };

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_da .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};func _bdag ()*Division {return &Division {_caed :[]VectorDrawable {}}};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_gbae *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_debg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cbbeb :=_eb .Circle {X :_gbae ._dgfd -_gbae ._efa /2,Y :ctx .PageHeight -_gbae ._cdae -_gbae ._dee /2,Width :_gbae ._efa ,Height :_gbae ._dee ,Opacity :1.0,BorderWidth :_gbae ._fgeff };if _gbae ._adcg !=nil {_cbbeb .FillEnabled =true ;_cbbeb .FillColor =_gbae ._adcg ;};if _gbae ._cgfa !=nil {_cbbeb .BorderEnabled =true ;_cbbeb .BorderColor =_gbae ._cgfa ;_cbbeb .BorderWidth =_gbae ._fgeff ;};_bfdd ,_ ,_beaaf :=_cbbeb .Draw ("");if _beaaf !=nil {return nil ,ctx ,_beaaf ;};_beaaf =_debg .addContentsByString (string (_bfdd ));if _beaaf !=nil {return nil ,ctx ,_beaaf ;};return []*Block {_debg },ctx ,nil ;};

// SetFillOpacity sets the fill opacity.
func (_dggce *Rectangle )SetFillOpacity (opacity float64 ){_dggce ._cgde =opacity };

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_dab *Block )AddAnnotation (annotation *_da .PdfAnnotation ){for _ ,_cbc :=range _dab ._ga {if _cbc ==annotation {return ;};};_dab ._ga =append (_dab ._ga ,annotation );};

// DrawWithContext draws the Block using the specified drawing context.
func (_ded *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_cgf ,_ ,_aca :=d .GeneratePageBlocks (ctx );if _aca !=nil {return _aca ;};if len (_cgf )!=1{return _de .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_cbdd :=range _cgf {if _fgeb :=_ded .mergeBlocks (_cbdd );_fgeb !=nil {return _fgeb ;};};return nil ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_gfbde *StyledParagraph )SetEnableWrap (enableWrap bool ){_gfbde ._afgdg =enableWrap ;_gfbde ._babed =false ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_bcda *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _bcda ._cccf ._bfca ,_bcda ._cccf ._dbca ,_bcda ._cccf ._agbf ,_bcda ._cccf ._cee ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bfcb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bfcb ._gfda =address };

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_gdcac *Table )EnableRowWrap (enable bool ){_gdcac ._ecab =enable };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_cgeb *Invoice )AddressHeadingStyle ()TextStyle {return _cgeb ._gcfa };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gfa *Creator )NewStyledParagraph ()*StyledParagraph {return _adce (_gfa .NewTextStyle ())};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_eeaf *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbfa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egff :=_eb .Rectangle {Opacity :1.0,X :_eeaf ._adgf ,Y :ctx .PageHeight -_eeaf ._fbge -_eeaf ._dade ,Height :_eeaf ._dade ,Width :_eeaf ._bggd };if _eeaf ._caea !=nil {_egff .FillEnabled =true ;_egff .FillColor =_eeaf ._caea ;};if _eeaf ._aafe !=nil &&_eeaf ._daba > 0{_egff .BorderEnabled =true ;_egff .BorderColor =_eeaf ._aafe ;_egff .BorderWidth =_eeaf ._daba ;};_gefe ,_cega :=_cbfa .setOpacity (_eeaf ._cgde ,_eeaf ._eefb );if _cega !=nil {return nil ,ctx ,_cega ;};_acfb ,_ ,_cega :=_egff .Draw (_gefe );if _cega !=nil {return nil ,ctx ,_cega ;};if _cega =_cbfa .addContentsByString (string (_acfb ));_cega !=nil {return nil ,ctx ,_cega ;};return []*Block {_cbfa },ctx ,nil ;};type border struct{_edf float64 ;_gcac float64 ;_acbb float64 ;_gdc float64 ;_aff *_da .PdfColorDeviceRGB ;_dcg *_da .PdfColorDeviceRGB ;_ece float64 ;_aebd *_da .PdfColorDeviceRGB ;_egc float64 ;_gbag *_da .PdfColorDeviceRGB ;_dfe float64 ;_fda *_da .PdfColorDeviceRGB ;_ecbd float64 ;LineStyle _eb .LineStyle ;_ecce CellBorderStyle ;_gcdb CellBorderStyle ;_edc CellBorderStyle ;_bcg CellBorderStyle ;};var PPMM =float64 (72*1.0/25.4);

// Height returns the total height of all rows.
func (_ecdc *Table )Height ()float64 {_cedf :=float64 (0.0);for _ ,_bbde :=range _ecdc ._caceb {_cedf +=_bbde ;};return _cedf ;};

// SetBorderColor sets the border color.
func (_ggd *Polygon )SetBorderColor (color Color ){_ggd ._cced .BorderColor =_da .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetFillColor sets the fill color.
func (_ggggd *Polygon )SetFillColor (color Color ){_ggggd ._cced .FillColor =_da .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetLineHeight sets the line height (1.0 default).
func (_dbead *Paragraph )SetLineHeight (lineheight float64 ){_dbead ._ebeae =lineheight };func (_dffc *Table )wrapRow (_dcfb int ,_aefc DrawContext ,_ceggf float64 )(bool ,error ){if !_dffc ._ecab {return false ,nil ;};var (_ffdeb =_dffc ._adceb [_dcfb ];_affb =-1;_fgbd []*TableCell ;_acab float64 ;_aebaf bool ;_fbaec =make ([]float64 ,0,len (_dffc ._cgcgb )););_fgbbd :=func (_bfae *TableCell ,_egd VectorDrawable ,_ecff bool )*TableCell {_fece :=*_bfae ;_fece ._abcfe =_egd ;if _ecff {_fece ._gggcc ++;};return &_fece ;};_bfdba :=func (_gaece int ,_abcdg VectorDrawable ){var _edbdc float64 =-1;if _abcdg ==nil {if _gcge :=_fbaec [_gaece -_dcfb ];_gcge > _aefc .Height {_abcdg =_dffc ._adceb [_gaece ]._abcfe ;_dffc ._adceb [_gaece ]._abcfe =nil ;_fbaec [_gaece -_dcfb ]=0;_edbdc =_gcge ;};};_adee :=_fgbbd (_dffc ._adceb [_gaece ],_abcdg ,true );_fgbd =append (_fgbd ,_adee );if _edbdc < 0{_edbdc =_adee .height (_aefc .Width );};if _edbdc > _acab {_acab =_edbdc ;};};for _fedea :=_dcfb ;_fedea < len (_dffc ._adceb );_fedea ++{_gdbd :=_dffc ._adceb [_fedea ];if _ffdeb ._gggcc !=_gdbd ._gggcc {_affb =_fedea ;break ;};_aefc .Width =_gdbd .width (_dffc ._cgcgb ,_ceggf );var _bee VectorDrawable ;switch _dbee :=_gdbd ._abcfe .(type ){case *StyledParagraph :if _abaf :=_gdbd .height (_aefc .Width );_abaf > _aefc .Height {_bbeb :=_aefc ;_bbeb .Height =_ag .Floor (_aefc .Height -_dbee ._bbgga ._agbf -_dbee ._bbgga ._cee -0.5*_dbee .getTextHeight ());_cgdgd ,_bfeb ,_caffa :=_dbee .split (_bbeb );if _caffa !=nil {return false ,_caffa ;};if _cgdgd !=nil &&_bfeb !=nil {_dbee =_cgdgd ;_gdbd =_fgbbd (_gdbd ,_cgdgd ,false );_dffc ._adceb [_fedea ]=_gdbd ;_bee =_bfeb ;_aebaf =true ;};};};_fbaec =append (_fbaec ,_gdbd .height (_aefc .Width ));if _aebaf {if _fgbd ==nil {_fgbd =make ([]*TableCell ,0,len (_dffc ._cgcgb ));for _cbgc :=_dcfb ;_cbgc < _fedea ;_cbgc ++{_bfdba (_cbgc ,nil );};};_bfdba (_fedea ,_bee );};};var _deea float64 ;for _ ,_ffdf :=range _fbaec {if _ffdf > _deea {_deea =_ffdf ;};};if _aebaf &&_deea < _aefc .Height {if _affb < 0{_affb =len (_dffc ._adceb );};_ebcb :=_dffc ._adceb [_affb -1]._gggcc +_dffc ._adceb [_affb -1]._cddd -1;for _addbd :=_affb ;_addbd < len (_dffc ._adceb );_addbd ++{_dffc ._adceb [_addbd ]._gggcc ++;};_dffc ._adceb =append (_dffc ._adceb [:_affb ],append (_fgbd ,_dffc ._adceb [_affb :]...)...);_dffc ._caceb =append (_dffc ._caceb [:_ebcb ],append ([]float64 {_acab },_dffc ._caceb [_ebcb :]...)...);_dffc ._caceb [_ffdeb ._gggcc +_ffdeb ._cddd -2]=_deea ;};return _aebaf ,nil ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_agddae *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_egfb float64 ;_gcgd uint ;_cgdb float64 ;_gbac positioning ;_cdcg float64 ;_degc float64 ;_cacea int64 ;};

// MoveY moves the drawing context to absolute position y.
func (_fbd *Creator )MoveY (y float64 ){_fbd ._acf .Y =y };func _daf (_gegg *Block ,_accf *Image ,_agde DrawContext )(DrawContext ,error ){_edff :=_agde ;_afff :=1;_gefb :=_ac .PdfObjectName (_b .Sprintf ("\u0049\u006d\u0067%\u0064",_afff ));for _gegg ._fa .HasXObjectByName (_gefb ){_afff ++;_gefb =_ac .PdfObjectName (_b .Sprintf ("\u0049\u006d\u0067%\u0064",_afff ));};_agaa :=_gegg ._fa .SetXObjectImageByName (_gefb ,_accf ._eaac );if _agaa !=nil {return _agde ,_agaa ;};_fab :=0;_ggab :=_ac .PdfObjectName (_b .Sprintf ("\u0047\u0053\u0025\u0064",_fab ));for _gegg ._fa .HasExtGState (_ggab ){_fab ++;_ggab =_ac .PdfObjectName (_b .Sprintf ("\u0047\u0053\u0025\u0064",_fab ));};_dagf :=_ac .MakeDict ();_dagf .Set ("\u0042\u004d",_ac .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _accf ._ddcb < 1.0{_dagf .Set ("\u0043\u0041",_ac .MakeFloat (_accf ._ddcb ));_dagf .Set ("\u0063\u0061",_ac .MakeFloat (_accf ._ddcb ));};_agaa =_gegg ._fa .AddExtGState (_ggab ,_ac .MakeIndirectObject (_dagf ));if _agaa !=nil {return _agde ,_agaa ;};_cfeg :=_accf .Width ();_ggebc :=_accf .Height ();_ ,_cfa :=_accf .rotatedSize ();_ddfc :=_agde .X ;_bbbg :=_agde .PageHeight -_agde .Y -_ggebc ;if _accf ._eda .isRelative (){_bbbg -=(_cfa -_ggebc )/2;switch _accf ._cgca {case HorizontalAlignmentCenter :_ddfc +=(_agde .Width -_cfeg )/2;case HorizontalAlignmentRight :_ddfc =_agde .PageWidth -_agde .Margins ._dbca -_accf ._cagf ._dbca -_cfeg ;};};_dccc :=_accf ._afgd ;_cbgg :=_ab .NewContentCreator ();_cbgg .Add_gs (_ggab );_cbgg .Translate (_ddfc ,_bbbg );if _dccc !=0{_cbgg .Translate (_cfeg /2,_ggebc /2);_cbgg .RotateDeg (_dccc );_cbgg .Translate (-_cfeg /2,-_ggebc /2);};_cbgg .Scale (_cfeg ,_ggebc ).Add_Do (_gefb );_cbeg :=_cbgg .Operations ();_cbeg .WrapIfNeeded ();_gegg .addContents (_cbeg );if _accf ._eda .isRelative (){_agde .Y +=_cfa ;_agde .Height -=_cfa ;return _agde ,nil ;};return _edff ,nil ;};

// SetStyleRight sets border style for right side.
func (_ade *border )SetStyleRight (style CellBorderStyle ){_ade ._gcdb =style };func (_ddag *Invoice )setCellBorder (_bcbf *TableCell ,_bcgg *InvoiceCell ){for _ ,_ceea :=range _bcgg .BorderSides {_bcbf .SetBorder (_ceea ,CellBorderStyleSingle ,_bcgg .BorderWidth );};_bcbf .SetBorderColor (_bcgg .BorderColor );};func _adce (_dgddd TextStyle )*StyledParagraph {return &StyledParagraph {_caca :[]*TextChunk {},_bgcf :_dgddd ,_dgcgc :_ggbf (_dgddd .Font ),_gcgaf :1.0,_dabff :TextAlignmentLeft ,_afgdg :true ,_babed :true ,_bdaf :0,_gdcc :1,_aece :1,_cceg :_abbd };};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_cdc *Creator )MoveRight (dx float64 ){_cdc ._acf .X +=dx };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_gebd *Invoice )SetNoteStyle (style TextStyle ){_gebd ._bcdf =style };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetLogo sets the logo of the invoice.
func (_ggfd *Invoice )SetLogo (logo *Image ){_ggfd ._dccg =logo };

// TOC returns the table of contents component of the creator.
func (_ffc *Creator )TOC ()*TOC {return _ffc ._efdc };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_egae []*_da .PdfPage ;_eacd map[*_da .PdfPage ]*Block ;_dag map[*_da .PdfPage ]_gc .Matrix ;_gecd *_da .PdfPage ;_bfb PageSize ;_acf DrawContext ;_dcaf margins ;_gagca ,_gddb float64 ;_bfbf int ;_efgc func (_ffac FrontpageFunctionArgs );_efbe func (_acba *TOC )error ;_fca func (_bga *Block ,_eed HeaderFunctionArgs );_cgb func (_cbdb *Block ,_cfcb FooterFunctionArgs );_ccfd func (_bgdf *_da .PdfWriter )error ;_cfe bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_efdc *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gae *_da .Outline ;_dda *_da .PdfOutlineTreeNode ;_fdgd *_da .PdfAcroForm ;_fdge _ac .PdfObject ;_gfc _da .Optimizer ;_gdcd []*_da .PdfFont ;_bfgaa *_da .PdfFont ;_ccge *_da .PdfFont ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ge :=&Block {};_ge ._f =&_ab .ContentStreamOperations {};_ge ._fa =_da .NewPdfPageResources ();_ge ._acc =width ;_ge ._ff =height ;return _ge ;};func _ace (_fddeb int64 ,_aabd ,_ccab ,_dabg float64 )*_da .PdfAnnotation {_edfdb :=_da .NewPdfAnnotationLink ();_ceecd :=_da .NewBorderStyle ();_ceecd .SetBorderWidth (0);_edfdb .BS =_ceecd .ToPdfObject ();if _fddeb < 0{_fddeb =0;};_edfdb .Dest =_ac .MakeArray (_ac .MakeInteger (_fddeb ),_ac .MakeName ("\u0058\u0059\u005a"),_ac .MakeFloat (_aabd ),_ac .MakeFloat (_ccab ),_ac .MakeFloat (_dabg ));return _edfdb .PdfAnnotation ;};func (_cad *Block )translate (_eeg ,_gg float64 ){_bc :=_ab .NewContentCreator ().Translate (_eeg ,-_gg ).Operations ();*_cad ._f =append (*_bc ,*_cad ._f ...);_cad ._f .WrapIfNeeded ();};

// GeneratePageBlocks implements drawable interface.
func (_daa *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bag :=_daa ._edf ;_agea :=ctx .PageHeight -_daa ._gcac ;if _daa ._aff !=nil {_dbcf :=_eb .Rectangle {Opacity :1.0,X :_daa ._edf ,Y :ctx .PageHeight -_daa ._gcac -_daa ._gdc ,Height :_daa ._gdc ,Width :_daa ._acbb };_dbcf .FillEnabled =true ;_dbcf .FillColor =_daa ._aff ;_dbcf .BorderEnabled =false ;_agf ,_ ,_egg :=_dbcf .Draw ("");if _egg !=nil {return nil ,ctx ,_egg ;};_egg =_bbf .addContentsByString (string (_agf ));if _egg !=nil {return nil ,ctx ,_egg ;};};_afcf :=_daa ._ecbd ;_gga :=_daa ._egc ;_bbb :=_daa ._ece ;_bbgc :=_daa ._dfe ;_dbd :=_daa ._ecbd ;if _daa ._edc ==CellBorderStyleDouble {_dbd +=2*_afcf ;};_agfe :=_daa ._egc ;if _daa ._bcg ==CellBorderStyleDouble {_agfe +=2*_gga ;};_gfd :=_daa ._ece ;if _daa ._ecce ==CellBorderStyleDouble {_gfd +=2*_bbb ;};_deb :=_daa ._dfe ;if _daa ._gcdb ==CellBorderStyleDouble {_deb +=2*_bbgc ;};if _daa ._ecbd !=0{_fcf :=_bag ;_aagc :=_agea ;if _daa ._edc ==CellBorderStyleDouble {_aagc -=_afcf ;_ced :=_eb .BasicLine {};_ced .X1 =_fcf -_dbd /2;_ced .Y1 =_aagc +2*_afcf ;_ced .X2 =_fcf +_daa ._acbb +_dbd /2;_ced .Y2 =_aagc +2*_afcf ;_ced .LineColor =_daa ._fda ;_ced .LineWidth =_daa ._ecbd ;_ced .LineStyle =_daa .LineStyle ;_gged ,_ ,_dcad :=_ced .Draw ("");if _dcad !=nil {return nil ,ctx ,_dcad ;};_dcad =_bbf .addContentsByString (string (_gged ));if _dcad !=nil {return nil ,ctx ,_dcad ;};};_gfb :=_eb .BasicLine {LineWidth :_daa ._ecbd ,Opacity :1.0,LineColor :_daa ._fda ,X1 :_fcf -_dbd /2+(_gfd -_daa ._ece ),Y1 :_aagc ,X2 :_fcf +_daa ._acbb +_dbd /2-(_deb -_daa ._dfe ),Y2 :_aagc ,LineStyle :_daa .LineStyle };_dadb ,_ ,_aab :=_gfb .Draw ("");if _aab !=nil {return nil ,ctx ,_aab ;};_aab =_bbf .addContentsByString (string (_dadb ));if _aab !=nil {return nil ,ctx ,_aab ;};};if _daa ._egc !=0{_bcee :=_bag ;_dgc :=_agea -_daa ._gdc ;if _daa ._bcg ==CellBorderStyleDouble {_dgc +=_gga ;_cfcg :=_eb .BasicLine {LineWidth :_daa ._egc ,Opacity :1.0,LineColor :_daa ._aebd ,X1 :_bcee -_agfe /2,Y1 :_dgc -2*_gga ,X2 :_bcee +_daa ._acbb +_agfe /2,Y2 :_dgc -2*_gga ,LineStyle :_daa .LineStyle };_bab ,_ ,_cfg :=_cfcg .Draw ("");if _cfg !=nil {return nil ,ctx ,_cfg ;};_cfg =_bbf .addContentsByString (string (_bab ));if _cfg !=nil {return nil ,ctx ,_cfg ;};};_bde :=_eb .BasicLine {LineWidth :_daa ._egc ,Opacity :1.0,LineColor :_daa ._aebd ,X1 :_bcee -_agfe /2+(_gfd -_daa ._ece ),Y1 :_dgc ,X2 :_bcee +_daa ._acbb +_agfe /2-(_deb -_daa ._dfe ),Y2 :_dgc ,LineStyle :_daa .LineStyle };_dgcg ,_ ,_gagc :=_bde .Draw ("");if _gagc !=nil {return nil ,ctx ,_gagc ;};_gagc =_bbf .addContentsByString (string (_dgcg ));if _gagc !=nil {return nil ,ctx ,_gagc ;};};if _daa ._ece !=0{_gab :=_bag ;_gbd :=_agea ;if _daa ._ecce ==CellBorderStyleDouble {_gab +=_bbb ;_cbga :=_eb .BasicLine {LineWidth :_daa ._ece ,Opacity :1.0,LineColor :_daa ._dcg ,X1 :_gab -2*_bbb ,Y1 :_gbd +_gfd /2,X2 :_gab -2*_bbb ,Y2 :_gbd -_daa ._gdc -_gfd /2,LineStyle :_daa .LineStyle };_gbec ,_ ,_abc :=_cbga .Draw ("");if _abc !=nil {return nil ,ctx ,_abc ;};_abc =_bbf .addContentsByString (string (_gbec ));if _abc !=nil {return nil ,ctx ,_abc ;};};_bgb :=_eb .BasicLine {LineWidth :_daa ._ece ,Opacity :1.0,LineColor :_daa ._dcg ,X1 :_gab ,Y1 :_gbd +_gfd /2-(_dbd -_daa ._ecbd ),X2 :_gab ,Y2 :_gbd -_daa ._gdc -_gfd /2+(_agfe -_daa ._egc ),LineStyle :_daa .LineStyle };_fafc ,_ ,_gcec :=_bgb .Draw ("");if _gcec !=nil {return nil ,ctx ,_gcec ;};_gcec =_bbf .addContentsByString (string (_fafc ));if _gcec !=nil {return nil ,ctx ,_gcec ;};};if _daa ._dfe !=0{_gadf :=_bag +_daa ._acbb ;_cae :=_agea ;if _daa ._gcdb ==CellBorderStyleDouble {_gadf -=_bbgc ;_bff :=_eb .BasicLine {LineWidth :_daa ._dfe ,Opacity :1.0,LineColor :_daa ._gbag ,X1 :_gadf +2*_bbgc ,Y1 :_cae +_deb /2,X2 :_gadf +2*_bbgc ,Y2 :_cae -_daa ._gdc -_deb /2,LineStyle :_daa .LineStyle };_dcd ,_ ,_ceb :=_bff .Draw ("");if _ceb !=nil {return nil ,ctx ,_ceb ;};_ceb =_bbf .addContentsByString (string (_dcd ));if _ceb !=nil {return nil ,ctx ,_ceb ;};};_gefdg :=_eb .BasicLine {LineWidth :_daa ._dfe ,Opacity :1.0,LineColor :_daa ._gbag ,X1 :_gadf ,Y1 :_cae +_deb /2-(_dbd -_daa ._ecbd ),X2 :_gadf ,Y2 :_cae -_daa ._gdc -_deb /2+(_agfe -_daa ._egc ),LineStyle :_daa .LineStyle };_bcga ,_ ,_eff :=_gefdg .Draw ("");if _eff !=nil {return nil ,ctx ,_eff ;};_eff =_bbf .addContentsByString (string (_bcga ));if _eff !=nil {return nil ,ctx ,_eff ;};};return []*Block {_bbf },ctx ,nil ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_aebe *Table )Width ()float64 {return 0};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_gfdc *Image )ConvertToBinary ()error {return _gfdc ._eacb .ConvertToBinary ()};func (_adfc *Invoice )generateTotalBlocks (_ecf DrawContext )([]*Block ,DrawContext ,error ){_adda :=_fcae (4);_adda .SetMargins (0,0,10,10);_ccfe :=[][2]*InvoiceCell {_adfc ._befb };_ccfe =append (_ccfe ,_adfc ._gda ...);_ccfe =append (_ccfe ,_adfc ._efad );for _ ,_dfag :=range _ccfe {_ageeb ,_ffde :=_dfag [0],_dfag [1];if _ffde .Value ==""{continue ;};_adda .SkipCells (2);_edcg :=_adda .NewCell ();_edcg .SetBackgroundColor (_ageeb .BackgroundColor );_edcg .SetHorizontalAlignment (_ffde .Alignment );_adfc .setCellBorder (_edcg ,_ageeb );_faac :=_adce (_ageeb .TextStyle );_faac .SetMargins (0,0,2,1);_faac .Append (_ageeb .Value );_edcg .SetContent (_faac );_edcg =_adda .NewCell ();_edcg .SetBackgroundColor (_ffde .BackgroundColor );_edcg .SetHorizontalAlignment (_ffde .Alignment );_adfc .setCellBorder (_edcg ,_ageeb );_faac =_adce (_ffde .TextStyle );_faac .SetMargins (0,0,2,1);_faac .Append (_ffde .Value );_edcg .SetContent (_faac );};return _adda .GeneratePageBlocks (_ecf );};

// NewPolyline creates a new polyline.
func (_cafa *Creator )NewPolyline (points []_eb .Point )*Polyline {return _adgdcb (points )};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ebfe *Creator )SetPageLabels (pageLabels _ac .PdfObject ){_ebfe ._fdge =pageLabels };

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_fbe *Creator )SetPageSize (size PageSize ){_fbe ._bfb =size ;_fbe ._gagca =size [0];_fbe ._gddb =size [1];_fdfe :=0.1*_fbe ._gagca ;_fbe ._dcaf ._bfca =_fdfe ;_fbe ._dcaf ._dbca =_fdfe ;_fbe ._dcaf ._agbf =_fdfe ;_fbe ._dcaf ._cee =_fdfe ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetLevel sets the indentation level of the TOC line.
func (_ecgb *TOCLine )SetLevel (level uint ){_ecgb ._gcgd =level ;_ecgb ._agddae ._bbgga ._bfca =_ecgb ._egfb +float64 (_ecgb ._gcgd -1)*_ecgb ._cgdb ;};

// Logo returns the logo of the invoice.
func (_cdfd *Invoice )Logo ()*Image {return _cdfd ._dccg };func (_ea *Block )addContents (_af *_ab .ContentStreamOperations ){_ea ._f .WrapIfNeeded ();_af .WrapIfNeeded ();*_ea ._f =append (*_ea ._f ,*_af ...);};

// GeneratePageBlocks generates a page break block.
func (_edae *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abcc :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_abeg :=ctx ;_abeg .Y =ctx .Margins ._agbf ;_abeg .X =ctx .Margins ._bfca ;_abeg .Height =ctx .PageHeight -ctx .Margins ._agbf -ctx .Margins ._cee ;_abeg .Width =ctx .PageWidth -ctx .Margins ._bfca -ctx .Margins ._dbca ;ctx =_abeg ;return _abcc ,ctx ,nil ;};func (_cgc *Block )addContentsByString (_cc string )error {_dae :=_ab .NewContentStreamParser (_cc );_efe ,_fe :=_dae .Parse ();if _fe !=nil {return _fe ;};_cgc ._f .WrapIfNeeded ();_efe .WrapIfNeeded ();*_cgc ._f =append (*_cgc ._f ,*_efe ...);return nil ;};

// SetRowHeight sets the height for a specified row.
func (_afde *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_afde ._caceb ){return _de .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_afde ._caceb [row -1]=h ;return nil ;};

// Columns returns all the columns in the invoice line items table.
func (_fgbg *Invoice )Columns ()[]*InvoiceCell {return _fgbg ._ccce };

// AppendColumn appends a column to the line items table.
func (_fddg *Invoice )AppendColumn (description string )*InvoiceCell {_egaa :=_fddg .NewColumn (description );_fddg ._ccce =append (_fddg ._ccce ,_egaa );return _egaa ;};

// SetMargins sets the Paragraph's margins.
func (_bebf *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_bebf ._gffg ._bfca =left ;_bebf ._gffg ._dbca =right ;_bebf ._gffg ._agbf =top ;_bebf ._gffg ._cee =bottom ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_dcdc *_eb .PolyBezierCurve ;_dgdc float64 ;_cdff float64 ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_facc *Invoice )Sections ()[][2]string {return _facc ._begg };

// AddTotalLine adds a new line in the invoice totals table.
func (_abce *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_fafcb :=&InvoiceCell {_abce ._cegc ,desc };_abcf :=&InvoiceCell {_abce ._cegc ,value };_abce ._gda =append (_abce ._gda ,[2]*InvoiceCell {_fafcb ,_abcf });return _fafcb ,_abcf ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_dcae *StyledParagraph ;_fgceb []*TOCLine ;_fbgf TextStyle ;_fbcgb TextStyle ;_cacae TextStyle ;_cagfg TextStyle ;_fedcf string ;_ccgf float64 ;_ggbaa margins ;_abafa positioning ;_bdded TextStyle ;_eabe bool ;};func _eecdf (_feea *_da .PdfRectangle ,_affdf _gc .Matrix )*_da .PdfRectangle {var _eegf _da .PdfRectangle ;_eegf .Llx ,_eegf .Lly =_affdf .Transform (_feea .Llx ,_feea .Lly );_eegf .Urx ,_eegf .Ury =_affdf .Transform (_feea .Urx ,_feea .Ury );_eegf .Normalize ();return &_eegf ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fabf *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fabf ._bbgga ._bfca ,_fabf ._bbgga ._dbca ,_fabf ._bbgga ._agbf ,_fabf ._bbgga ._cee ;};func _deac (_gdaa ,_agcfc ,_dgff ,_fcbd float64 )*Rectangle {return &Rectangle {_adgf :_gdaa ,_fbge :_agcfc ,_bggd :_dgff ,_dade :_fcbd ,_aafe :_da .NewPdfColorDeviceRGB (0,0,0),_daba :1.0,_cgde :1.0,_eefb :1.0};};func (_gcdbe *Creator )initContext (){_gcdbe ._acf .X =_gcdbe ._dcaf ._bfca ;_gcdbe ._acf .Y =_gcdbe ._dcaf ._agbf ;_gcdbe ._acf .Width =_gcdbe ._gagca -_gcdbe ._dcaf ._dbca -_gcdbe ._dcaf ._bfca ;_gcdbe ._acf .Height =_gcdbe ._gddb -_gcdbe ._dcaf ._cee -_gcdbe ._dcaf ._agbf ;_gcdbe ._acf .PageHeight =_gcdbe ._gddb ;_gcdbe ._acf .PageWidth =_gcdbe ._gagca ;_gcdbe ._acf .Margins =_gcdbe ._dcaf ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dddg *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _dddg ._fgd [0],_dddg ._fgd [1]};func _ggbf (_addbb *_da .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_addbb ,FontSize :10};};

// TitleStyle returns the style properties used to render the invoice title.
func (_abdd *Invoice )TitleStyle ()TextStyle {return _abdd ._eedg };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// GetCoords returns coordinates of border.
func (_bcf *border )GetCoords ()(float64 ,float64 ){return _bcf ._edf ,_bcf ._gcac };func _feaf (_cgbab *_da .Image )(*Image ,error ){_eecg :=float64 (_cgbab .Width );_cabd :=float64 (_cgbab .Height );return &Image {_eacb :_cgbab ,_fdfg :_eecg ,_cgda :_cabd ,_cfdf :_eecg ,_dgd :_cabd ,_afgd :0,_ddcb :1.0,_eda :_abbd },nil ;};

// SetColorTop sets border color for top.
func (_ggf *border )SetColorTop (col Color ){_ggf ._fda =_da .NewPdfColorDeviceRGB (col .ToRGB ())};func _eaba (_gcgb ,_gdeb ,_gfed string ,_gdcec uint ,_gabdf TextStyle )*TOCLine {return _bcgdd (TextChunk {Text :_gcgb ,Style :_gabdf },TextChunk {Text :_gdeb ,Style :_gabdf },TextChunk {Text :_gfed ,Style :_gabdf },_gdcec ,_gabdf );};func (_beaa *Division )ctxHeight (_gfbd float64 )float64 {var _fcfc float64 ;for _ ,_cceeb :=range _beaa ._caed {switch _cgd :=_cceeb .(type ){case *Paragraph :if _cgd ._agbb {_cgd .SetWidth (_gfbd );};_fcfc +=_cgd .Height ()+_cgd ._gffg ._agbf +_cgd ._gffg ._cee ;case *StyledParagraph :if _cgd ._afgdg {_cgd .SetWidth (_gfbd );};_fcfc +=_cgd .Height ()+_cgd ._bbgga ._agbf +_cgd ._bbgga ._cee ;default:_fcfc +=_cgd .Height ();};};return _fcfc ;};

// SetBorderWidth sets the border width.
func (_febf *Ellipse )SetBorderWidth (bw float64 ){_febf ._fgeff =bw };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_gad *Block )ScaleToHeight (h float64 ){_cbg :=h /_gad ._ff ;_gad .Scale (_cbg ,_cbg )};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_fdcg *TOC )SetLineTitleStyle (style TextStyle ){_fdcg ._fbcgb =style };

// Height returns the height of the list.
func (_fbbg *List )Height ()float64 {var _ceegc float64 ;for _ ,_dgde :=range _fbbg ._fafce {_ceegc +=_dgde ._gfbg .Height ();};return _ceegc ;};func (_bdcf *Invoice )drawAddress (_aeaf *InvoiceAddress )[]*StyledParagraph {var _bebd []*StyledParagraph ;if _aeaf .Heading !=""{_ageaf :=_adce (_bdcf ._dbac );_ageaf .SetMargins (0,0,0,7);_ageaf .Append (_aeaf .Heading );_bebd =append (_bebd ,_ageaf );};_dbbf :=_adce (_bdcf ._fgfd );_dbbf .SetLineHeight (1.2);_ebca :=_aeaf .Separator ;if _ebca ==""{_ebca =_bdcf ._ccfc ;};_bbe :=_aeaf .City ;if _aeaf .State !=""{if _bbe !=""{_bbe +=_ebca ;};_bbe +=_aeaf .State ;};if _aeaf .Zip !=""{if _bbe !=""{_bbe +=_ebca ;};_bbe +=_aeaf .Zip ;};if _aeaf .Name !=""{_dbbf .Append (_aeaf .Name +"\u000a");};if _aeaf .Street !=""{_dbbf .Append (_aeaf .Street +"\u000a");};if _aeaf .Street2 !=""{_dbbf .Append (_aeaf .Street2 +"\u000a");};if _bbe !=""{_dbbf .Append (_bbe +"\u000a");};if _aeaf .Country !=""{_dbbf .Append (_aeaf .Country +"\u000a");};_acac :=_adce (_bdcf ._fgfd );_acac .SetLineHeight (1.2);_acac .SetMargins (0,0,7,0);if _aeaf .Phone !=""{_acac .Append (_aeaf .fmtLine (_aeaf .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_aeaf .HidePhoneLabel ));};if _aeaf .Email !=""{_acac .Append (_aeaf .fmtLine (_aeaf .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_aeaf .HideEmailLabel ));};_bebd =append (_bebd ,_dbbf ,_acac );return _bebd ;};var PPI float64 =72;

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_cgcc *Block )ScaleToWidth (w float64 ){_afb :=w /_cgcc ._acc ;_cgcc .Scale (_afb ,_afb )};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_gfcc *Invoice )SetAddressHeadingStyle (style TextStyle ){_gfcc ._dbac =style };

// SkipOver skips over a specified number of rows and cols.
func (_badcg *Table )SkipOver (rows ,cols int ){_adafg :=rows *_badcg ._gfbe +cols -1;if _adafg < 0{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_badcg ._fbfgf +=_adafg ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// Width returns the width of the Paragraph.
func (_afbc *StyledParagraph )Width ()float64 {if _afbc ._afgdg &&int (_afbc ._ggdg )> 0{return _afbc ._ggdg ;};return _afbc .getTextWidth ()/1000.0;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_accfg *_da .PdfAnnotation ;_baafa bool ;};func (_gbf *Invoice )generateLineBlocks (_ccaf DrawContext )([]*Block ,DrawContext ,error ){_bdfg :=_fcae (len (_gbf ._ccce ));_bdfg .SetMargins (0,0,25,0);for _ ,_fbee :=range _gbf ._ccce {_gefcd :=_adce (_fbee .TextStyle );_gefcd .SetMargins (0,0,1,0);_gefcd .Append (_fbee .Value );_eba :=_bdfg .NewCell ();_eba .SetHorizontalAlignment (_fbee .Alignment );_eba .SetBackgroundColor (_fbee .BackgroundColor );_gbf .setCellBorder (_eba ,_fbee );_eba .SetContent (_gefcd );};for _ ,_dcf :=range _gbf ._fbcc {for _ ,_gadd :=range _dcf {_cfdb :=_adce (_gadd .TextStyle );_cfdb .SetMargins (0,0,3,2);_cfdb .Append (_gadd .Value );_cgef :=_bdfg .NewCell ();_cgef .SetHorizontalAlignment (_gadd .Alignment );_cgef .SetBackgroundColor (_gadd .BackgroundColor );_gbf .setCellBorder (_cgef ,_gadd );_cgef .SetContent (_cfdb );};};return _bdfg .GeneratePageBlocks (_ccaf );};func (_ccd *Creator )getActivePage ()*_da .PdfPage {if _ccd ._gecd ==nil {if len (_ccd ._egae )==0{return nil ;};return _ccd ._egae [len (_ccd ._egae )-1];};return _ccd ._gecd ;};

// NewTOC creates a new table of contents.
func (_aedg *Creator )NewTOC (title string )*TOC {_gccfe :=_aedg .NewTextStyle ();_gccfe .Font =_aedg ._ccge ;return _bgcg (title ,_aedg .NewTextStyle (),_gccfe );};

// SetStyleLeft sets border style for left side.
func (_gec *border )SetStyleLeft (style CellBorderStyle ){_gec ._ecce =style };

// Height returns the Block's height.
func (_cbd *Block )Height ()float64 {return _cbd ._ff };

// SetTitleStyle sets the style properties of the invoice title.
func (_aade *Invoice )SetTitleStyle (style TextStyle ){_aade ._eedg =style };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ccac *Creator )MoveDown (dy float64 ){_ccac ._acf .Y +=dy };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_ffb *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ffb ._fdc ._bfca ,_ffb ._fdc ._dbca ,_ffb ._fdc ._agbf ,_ffb ._fdc ._cee ;};

// SetColorBottom sets border color for bottom.
func (_aga *border )SetColorBottom (col Color ){_aga ._aebd =_da .NewPdfColorDeviceRGB (col .ToRGB ())};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_bead int ;_gfbe int ;_fbfgf int ;_cgcgb []float64 ;_caceb []float64 ;_cbcfeg float64 ;_adceb []*TableCell ;_cffgd positioning ;_ccde ,_ebfgbc float64 ;_cebc margins ;_egfdd bool ;_bcce int ;_fccf int ;_ecab bool ;};func _cafg (_dfdc string ,_gage _ac .PdfObject ,_gca *_da .PdfPageResources )_ac .PdfObjectName {_gedd :=_e .TrimRightFunc (_e .TrimSpace (_dfdc ),func (_ffgf rune )bool {return _aa .IsNumber (_ffgf )});if _gedd ==""{_gedd ="\u0046\u006f\u006e\u0074";};_ce :=0;_agc :=_ac .PdfObjectName (_dfdc );for {_eaca ,_beb :=_gca .GetFontByName (_agc );if !_beb ||_eaca ==_gage {break ;};_ce ++;_agc =_ac .PdfObjectName (_b .Sprintf ("\u0025\u0073\u0025\u0064",_gedd ,_ce ));};return _agc ;};

// SetColorLeft sets border color for left.
func (_fed *border )SetColorLeft (col Color ){_fed ._dcg =_da .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetLineWidth sets the line width.
func (_bbge *Line )SetLineWidth (lw float64 ){_bbge ._ccfde =lw };

// NewPolygon creates a new polygon.
func (_cafc *Creator )NewPolygon (points [][]_eb .Point )*Polygon {return _eage (points )};

// Width returns the width of the Paragraph.
func (_efada *Paragraph )Width ()float64 {if _efada ._agbb &&int (_efada ._feec )> 0{return _efada ._feec ;};return _efada .getTextWidth ()/1000.0;};

// SetAnnotation sets a annotation on a TextChunk.
func (_gebda *TextChunk )SetAnnotation (annotation *_da .PdfAnnotation ){_gebda ._accfg =annotation };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_aef *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eaeab :=ctx ;var _cfaa []*Block ;_edgeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _aef ._cceg .isRelative (){ctx .X +=_aef ._bbgga ._bfca ;ctx .Y +=_aef ._bbgga ._agbf ;ctx .Width -=_aef ._bbgga ._bfca +_aef ._bbgga ._dbca ;ctx .Height -=_aef ._bbgga ._agbf +_aef ._bbgga ._cee ;_aef .SetWidth (ctx .Width );}else {if int (_aef ._ggdg )<=0{_aef .SetWidth (_aef .getTextWidth ());};ctx .X =_aef ._agff ;ctx .Y =_aef ._cggeb ;};if _aef ._aedb !=nil {_aef ._aedb (_aef ,ctx );};if _eabb :=_aef .wrapText ();_eabb !=nil {return nil ,ctx ,_eabb ;};_fggc :=_aef ._cff ;for {_fdbgb ,_acgf ,_acaa :=_fbcga (_edgeb ,_aef ,_fggc ,ctx );if _acaa !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_acaa );return nil ,ctx ,_acaa ;};ctx =_fdbgb ;_cfaa =append (_cfaa ,_edgeb );if _fggc =_acgf ;len (_acgf )==0{break ;};_edgeb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fdbgb =ctx ;_fdbgb .Y =ctx .Margins ._agbf ;_fdbgb .X =ctx .Margins ._bfca +_aef ._bbgga ._bfca ;_fdbgb .Height =ctx .PageHeight -ctx .Margins ._agbf -ctx .Margins ._cee -_aef ._bbgga ._cee ;_fdbgb .Width =ctx .PageWidth -ctx .Margins ._bfca -ctx .Margins ._dbca -_aef ._bbgga ._bfca -_aef ._bbgga ._dbca ;ctx =_fdbgb ;};if _aef ._cceg .isRelative (){ctx .X -=_aef ._bbgga ._bfca ;ctx .Width =_eaeab .Width ;return _cfaa ,ctx ,nil ;};return _cfaa ,_eaeab ,nil ;};

// SetWidth sets line width.
func (_bcc *Curve )SetWidth (width float64 ){_bcc ._cgcg =width };func _egb (_cfc ,_ecb *_da .PdfPageResources )error {_bbdd ,_ :=_cfc .GetColorspaces ();if _bbdd !=nil &&len (_bbdd .Colorspaces )> 0{for _ccae ,_fea :=range _bbdd .Colorspaces {_aaaf :=*_ac .MakeName (_ccae );if _ecb .HasColorspaceByName (_aaaf ){continue ;};_bbg :=_ecb .SetColorspaceByName (_aaaf ,_fea );if _bbg !=nil {return _bbg ;};};};return nil ;};func _abgf (_eafc string ,_fdda TextStyle )*Paragraph {_dffd :=&Paragraph {_decf :_eafc ,_edgag :_fdda .Font ,_agge :_fdda .FontSize ,_ebeae :1.0,_agbb :true ,_gea :true ,_dbece :TextAlignmentLeft ,_agec :0,_cccd :1,_cacd :1,_cbcc :_abbd };_dffd .SetColor (_fdda .Color );return _dffd ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_da .PdfPage )(*Block ,error ){_gcc :=&Block {};_agd ,_ca :=page .GetAllContentStreams ();if _ca !=nil {return nil ,_ca ;};_ecc :=_ab .NewContentStreamParser (_agd );_ebb ,_ca :=_ecc .Parse ();if _ca !=nil {return nil ,_ca ;};_ebb .WrapIfNeeded ();_gcc ._f =_ebb ;if page .Resources !=nil {_gcc ._fa =page .Resources ;}else {_gcc ._fa =_da .NewPdfPageResources ();};_df ,_ca :=page .GetMediaBox ();if _ca !=nil {return nil ,_ca ;};if _df .Llx !=0||_df .Lly !=0{_gcc .translate (-_df .Llx ,_df .Lly );};_gcc ._acc =_df .Urx -_df .Llx ;_gcc ._ff =_df .Ury -_df .Lly ;if page .Rotate !=nil {_gcc ._ee =-float64 (*page .Rotate );};return _gcc ,nil ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_fbfd *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _fbfd ._eaac ==nil {if _aagg :=_fbfd .makeXObject ();_aagg !=nil {return nil ,ctx ,_aagg ;};};var _bcb []*Block ;_acce :=ctx ;_dagg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fbfd ._eda .isRelative (){if _fbfd ._dgd > ctx .Height {_bcb =append (_bcb ,_dagg );_dagg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dcdb :=ctx ;_dcdb .Y =ctx .Margins ._agbf ;_dcdb .X =ctx .Margins ._bfca +_fbfd ._cagf ._bfca ;_dcdb .Height =ctx .PageHeight -ctx .Margins ._agbf -ctx .Margins ._cee -_fbfd ._cagf ._cee ;_dcdb .Width =ctx .PageWidth -ctx .Margins ._bfca -ctx .Margins ._dbca -_fbfd ._cagf ._bfca -_fbfd ._cagf ._dbca ;ctx =_dcdb ;}else {ctx .Y +=_fbfd ._cagf ._agbf ;ctx .Height -=_fbfd ._cagf ._agbf +_fbfd ._cagf ._cee ;ctx .X +=_fbfd ._cagf ._bfca ;ctx .Width -=_fbfd ._cagf ._bfca +_fbfd ._cagf ._dbca ;};}else {ctx .X =_fbfd ._fgfb ;ctx .Y =_fbfd ._cdfg ;};ctx ,_dfg :=_daf (_dagg ,_fbfd ,ctx );if _dfg !=nil {return nil ,ctx ,_dfg ;};_bcb =append (_bcb ,_dagg );if _fbfd ._eda .isAbsolute (){ctx =_acce ;}else {ctx .Y +=_fbfd ._cagf ._cee ;ctx .Height -=_fbfd ._cagf ._cee ;};return _bcb ,ctx ,nil ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {_acgg :=&Creator {};_acgg ._egae =[]*_da .PdfPage {};_acgg ._eacd =map[*_da .PdfPage ]*Block {};_acgg .SetPageSize (PageSizeLetter );_gdca :=0.1*_acgg ._gagca ;_acgg ._dcaf ._bfca =_gdca ;_acgg ._dcaf ._dbca =_gdca ;_acgg ._dcaf ._agbf =_gdca ;_acgg ._dcaf ._cee =_gdca ;var _bad error ;_acgg ._bfgaa ,_bad =_da .NewStandard14Font (_da .HelveticaName );if _bad !=nil {_acgg ._bfgaa =_da .DefaultFont ();};_acgg ._ccge ,_bad =_da .NewStandard14Font (_da .HelveticaBoldName );if _bad !=nil {_acgg ._bfgaa =_da .DefaultFont ();};_acgg ._efdc =_acgg .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_acgg .AddOutlines =true ;_acgg ._gae =_da .NewOutline ();return _acgg ;};func _abafae (_baegb ,_fgdg ,_facd float64 )(_gfdd ,_bdccc ,_bedb ,_aaaa float64 ){if _facd ==0{return 0,0,_baegb ,_fgdg ;};_cbca :=_eb .Path {Points :[]_eb .Point {_eb .NewPoint (0,0).Rotate (_facd ),_eb .NewPoint (_baegb ,0).Rotate (_facd ),_eb .NewPoint (0,_fgdg ).Rotate (_facd ),_eb .NewPoint (_baegb ,_fgdg ).Rotate (_facd )}}.GetBoundingBox ();return _cbca .X ,_cbca .Y ,_cbca .Width ,_cbca .Height ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_adef *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_adef ._cgca =alignment };func _dad (_gefa *_ab .ContentStreamOperations ,_adaf *_da .PdfPageResources ,_dca *_ab .ContentStreamOperations ,_cdf *_da .PdfPageResources )error {_fb :=map[_ac .PdfObjectName ]_ac .PdfObjectName {};_cdb :=map[_ac .PdfObjectName ]_ac .PdfObjectName {};_agdd :=map[_ac .PdfObjectName ]_ac .PdfObjectName {};_dgfb :=map[_ac .PdfObjectName ]_ac .PdfObjectName {};_eg :=map[_ac .PdfObjectName ]_ac .PdfObjectName {};_fbf :=map[_ac .PdfObjectName ]_ac .PdfObjectName {};for _ ,_dbc :=range *_dca {switch _dbc .Operand {case "\u0044\u006f":if len (_dbc .Params )==1{if _faa ,_eecb :=_dbc .Params [0].(*_ac .PdfObjectName );_eecb {if _ ,_gbg :=_fb [*_faa ];!_gbg {var _aeb _ac .PdfObjectName ;_cbgd ,_ :=_cdf .GetXObjectByName (*_faa );if _cbgd !=nil {_aeb =*_faa ;for {_abe ,_ :=_adaf .GetXObjectByName (_aeb );if _abe ==nil ||_abe ==_cbgd {break ;};_aeb =_aeb +"\u0030";};};_adaf .SetXObjectByName (_aeb ,_cbgd );_fb [*_faa ]=_aeb ;};_fgeg :=_fb [*_faa ];_dbc .Params [0]=&_fgeg ;};};case "\u0054\u0066":if len (_dbc .Params )==2{if _gde ,_fba :=_dbc .Params [0].(*_ac .PdfObjectName );_fba {if _ ,_ggb :=_cdb [*_gde ];!_ggb {_fdea ,_fbg :=_cdf .GetFontByName (*_gde );_bb :=*_gde ;if _fbg &&_fdea !=nil {_bb =_cafg (_gde .String (),_fdea ,_adaf );};_adaf .SetFontByName (_bb ,_fdea );_cdb [*_gde ]=_bb ;};_ecg :=_cdb [*_gde ];_dbc .Params [0]=&_ecg ;};};case "\u0043\u0053","\u0063\u0073":if len (_dbc .Params )==1{if _eaf ,_bgf :=_dbc .Params [0].(*_ac .PdfObjectName );_bgf {if _ ,_aee :=_agdd [*_eaf ];!_aee {var _cdd _ac .PdfObjectName ;_bea ,_gccf :=_cdf .GetColorspaceByName (*_eaf );if _gccf {_cdd =*_eaf ;for {_gge ,_abg :=_adaf .GetColorspaceByName (_cdd );if !_abg ||_bea ==_gge {break ;};_cdd =_cdd +"\u0030";};_adaf .SetColorspaceByName (_cdd ,_bea );_agdd [*_eaf ]=_cdd ;}else {_bg .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _adc ,_cfd :=_agdd [*_eaf ];_cfd {_dbc .Params [0]=&_adc ;}else {_bg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_eaf );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_dbc .Params )==1{if _cce ,_faf :=_dbc .Params [0].(*_ac .PdfObjectName );_faf {if _ ,_eaea :=_dgfb [*_cce ];!_eaea {var _ed _ac .PdfObjectName ;_acg ,_gbc :=_cdf .GetPatternByName (*_cce );if _gbc {_ed =*_cce ;for {_fbfb ,_eac :=_adaf .GetPatternByName (_ed );if !_eac ||_fbfb ==_acg {break ;};_ed =_ed +"\u0030";};_ffg :=_adaf .SetPatternByName (_ed ,_acg .ToPdfObject ());if _ffg !=nil {return _ffg ;};_dgfb [*_cce ]=_ed ;};};if _gcd ,_bce :=_dgfb [*_cce ];_bce {_dbc .Params [0]=&_gcd ;};};};case "\u0073\u0068":if len (_dbc .Params )==1{if _dfa ,_dga :=_dbc .Params [0].(*_ac .PdfObjectName );_dga {if _ ,_dea :=_eg [*_dfa ];!_dea {var _ebf _ac .PdfObjectName ;_dac ,_efb :=_cdf .GetShadingByName (*_dfa );if _efb {_ebf =*_dfa ;for {_gbe ,_ccf :=_adaf .GetShadingByName (_ebf );if !_ccf ||_dac ==_gbe {break ;};_ebf =_ebf +"\u0030";};_abgg :=_adaf .SetShadingByName (_ebf ,_dac .ToPdfObject ());if _abgg !=nil {_bg .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_abgg );return _abgg ;};_eg [*_dfa ]=_ebf ;}else {_bg .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _dfd ,_dcaa :=_eg [*_dfa ];_dcaa {_dbc .Params [0]=&_dfd ;}else {_bg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_dfa );};};};case "\u0067\u0073":if len (_dbc .Params )==1{if _abed ,_dgaf :=_dbc .Params [0].(*_ac .PdfObjectName );_dgaf {if _ ,_eccf :=_fbf [*_abed ];!_eccf {var _bgdd _ac .PdfObjectName ;_ebe ,_cdbb :=_cdf .GetExtGState (*_abed );if _cdbb {_bgdd =*_abed ;_fee :=1;for {_fgac ,_gbb :=_adaf .GetExtGState (_bgdd );if !_gbb ||_ebe ==_fgac {break ;};_bgdd =_ac .PdfObjectName (_b .Sprintf ("\u0047\u0053\u0025\u0064",_fee ));_fee ++;};};_adaf .AddExtGState (_bgdd ,_ebe );_fbf [*_abed ]=_bgdd ;};_eag :=_fbf [*_abed ];_dbc .Params [0]=&_eag ;};};};*_gefa =append (*_gefa ,_dbc );};return nil ;};func (_aagf *StyledParagraph )wrapChunks (_cbfd bool )error {if !_aagf ._afgdg ||int (_aagf ._ggdg )<=0{_aagf ._cff =[][]*TextChunk {_aagf ._caca };return nil ;};_aagf ._cff =[][]*TextChunk {};var _geeb []*TextChunk ;var _dfed float64 ;_fgbb :=_aa .IsSpace ;if !_cbfd {_fgbb =func (rune )bool {return false };};for _ ,_gefge :=range _aagf ._caca {_cffg :=_gefge .Style ;_fcccf :=_gefge ._accfg ;var (_efeg []rune ;_fegc []float64 ;);for _ ,_bfef :=range _gefge .Text {if _bfef =='\u000A'{_geeb =append (_geeb ,&TextChunk {Text :_e .TrimRightFunc (string (_efeg ),_fgbb ),Style :_cffg ,_accfg :_edgb (_fcccf )});_aagf ._cff =append (_aagf ._cff ,_geeb );_geeb =nil ;_dfed =0;_efeg =nil ;_fegc =nil ;continue ;};_adbag :=_bfef ==' ';_dcgac ,_gaage :=_cffg .Font .GetRuneMetrics (_bfef );if !_gaage {_bg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bfef );return _de .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_ggda :=_cffg .FontSize *_dcgac .Wx ;_ebef :=_ggda ;if !_adbag {_ebef =_ggda +_cffg .CharSpacing *1000.0;};if _dfed +_ggda > _aagf ._ggdg *1000.0{_ecbe :=-1;if !_adbag {for _abdb :=len (_efeg )-1;_abdb >=0;_abdb --{if _efeg [_abdb ]==' '{_ecbe =_abdb ;break ;};};};_babd :=string (_efeg );if _ecbe >=0{_babd =string (_efeg [0:_ecbe +1]);_efeg =_efeg [_ecbe +1:];_efeg =append (_efeg ,_bfef );_fegc =_fegc [_ecbe +1:];_fegc =append (_fegc ,_ebef );_dfed =0;for _ ,_gcfd :=range _fegc {_dfed +=_gcfd ;};}else {if _adbag {_dfed =0;_efeg =[]rune {};_fegc =[]float64 {};}else {_dfed =_ebef ;_efeg =[]rune {_bfef };_fegc =[]float64 {_ebef };};};if !_cbfd &&_adbag {_babd +="\u0020";};_geeb =append (_geeb ,&TextChunk {Text :_e .TrimRightFunc (_babd ,_fgbb ),Style :_cffg ,_accfg :_edgb (_fcccf )});_aagf ._cff =append (_aagf ._cff ,_geeb );_geeb =[]*TextChunk {};}else {_dfed +=_ebef ;_efeg =append (_efeg ,_bfef );_fegc =append (_fegc ,_ebef );};};if len (_efeg )> 0{_geeb =append (_geeb ,&TextChunk {Text :string (_efeg ),Style :_cffg ,_accfg :_edgb (_fcccf )});};};if len (_geeb )> 0{_aagf ._cff =append (_aagf ._cff ,_geeb );};return nil ;};

// Scale block by specified factors in the x and y directions.
func (_fc *Block )Scale (sx ,sy float64 ){_aaa :=_ab .NewContentCreator ().Scale (sx ,sy ).Operations ();*_fc ._f =append (*_aaa ,*_fc ._f ...);_fc ._f .WrapIfNeeded ();_fc ._acc *=sx ;_fc ._ff *=sy ;};func (_baab *StyledParagraph )split (_bddea DrawContext )(_fcec ,_bcggea *StyledParagraph ,_abeb error ){if _abeb =_baab .wrapChunks (false );_abeb !=nil {return nil ,nil ,_abeb ;};_egfg :=func (_daca []*TextChunk ,_gdbf []*TextChunk )[]*TextChunk {if len (_gdbf )==0{return _daca ;};_dfcb :=len (_daca );if _dfcb ==0{return append (_daca ,_gdbf ...);};_daca [_dfcb -1].Text +=_gdbf [0].Text ;return append (_daca ,_gdbf [1:]...);};_gcdg :=func (_efca *StyledParagraph ,_ceba []*TextChunk )*StyledParagraph {if len (_ceba )==0{return nil ;};_dbdeb :=*_efca ;_dbdeb ._caca =_ceba ;return &_dbdeb ;};var (_adae float64 ;_ddgf []*TextChunk ;_gaee []*TextChunk ;);for _ ,_bed :=range _baab ._cff {var _gddaa float64 ;_ffed :=make ([]*TextChunk ,0,len (_bed ));for _ ,_ccfb :=range _bed {if _ggdc :=_ccfb .Style .FontSize ;_ggdc > _gddaa {_gddaa =_ggdc ;};_ffed =append (_ffed ,_ccfb .clone ());};_gddaa *=_baab ._gcgaf ;if _baab ._cceg .isRelative (){if _adae +_gddaa > _bddea .Height {_gaee =_egfg (_gaee ,_ffed );}else {_ddgf =_egfg (_ddgf ,_ffed );};};_adae +=_gddaa ;};_baab ._cff =nil ;if len (_gaee )==0{return _baab ,nil ,nil ;};return _gcdg (_baab ,_ddgf ),_gcdg (_baab ,_gaee ),nil ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_ddgb *Table )NewCell ()*TableCell {return _ddgb .newCell (1)};

// SetDueDate sets the due date of the invoice.
func (_accfc *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_accfc ._fgd [1].Value =dueDate ;return _accfc ._fgd [0],_accfc ._fgd [1];};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bgde *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _bgde ._befb [0],_bgde ._befb [1]};type rgbColor struct{_gdbe ,_ddcc ,_def float64 };

// Width returns the current page width.
func (_dgg *Creator )Width ()float64 {return _dgg ._gagca };func _dabfe (_eecad *_g .File )([]*_da .PdfPage ,error ){_abfe ,_faee :=_da .NewPdfReader (_eecad );if _faee !=nil {return nil ,_faee ;};_ffeb ,_faee :=_abfe .GetNumPages ();if _faee !=nil {return nil ,_faee ;};var _defc []*_da .PdfPage ;for _dgeb :=0;_dgeb < _ffeb ;_dgeb ++{_dcegb ,_eacbc :=_abfe .GetPage (_dgeb +1);if _eacbc !=nil {return nil ,_eacbc ;};_defc =append (_defc ,_dcegb );};return _defc ,nil ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_eagddc *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bede :=_eagddc ;if _eagddc ._ecab {_bede =_eagddc .clone ();};return _acgb (_bede ,ctx );};

// Heading returns the heading component of the table of contents.
func (_cbcde *TOC )Heading ()*StyledParagraph {return _cbcde ._dcae };func _eeba (_bbba ,_cdbc ,_aaga ,_edfdg ,_aeg ,_bdgb float64 )*Curve {_dgac :=&Curve {};_dgac ._fdce =_bbba ;_dgac ._ecge =_cdbc ;_dgac ._fcb =_aaga ;_dgac ._aaaeb =_edfdg ;_dgac ._ggeb =_aeg ;_dgac ._fcdg =_bdgb ;_dgac ._cbbd =_da .NewPdfColorDeviceRGB (0,0,0);_dgac ._cgcg =1.0;return _dgac ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_accc *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gag :=_ab .NewContentCreator ();_cg ,_dce :=_accc .Width (),_accc .Height ();if _accc ._be .isRelative (){_gag .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_dce );}else {_gag .Translate (_accc ._bf ,ctx .PageHeight -_accc ._bfd -_dce );};_db :=_dce ;if _accc ._ee !=0{_gag .Translate (_cg /2,_dce /2);_gag .RotateDeg (_accc ._ee );_gag .Translate (-_cg /2,-_dce /2);_ ,_db =_accc .RotatedSize ();};if _accc ._be .isRelative (){ctx .Y +=_db ;};_ef :=_accc .duplicate ();_ffa :=append (*_gag .Operations (),*_ef ._f ...);_ffa .WrapIfNeeded ();_ef ._f =&_ffa ;return []*Block {_ef },ctx ,nil ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_edabg *TOC )SetLineLevelOffset (levelOffset float64 ){_edabg ._ccgf =levelOffset };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_fefa *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdbg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbga ,_gadeg :=_fdbg .setOpacity (_fefa ._abgd ,_fefa ._gdac );if _gadeg !=nil {return nil ,ctx ,_gadeg ;};_bgdg :=_fefa ._cced ;_bgdg .FillEnabled =_bgdg .FillColor !=nil ;_bgdg .BorderEnabled =_bgdg .BorderColor !=nil &&_bgdg .BorderWidth > 0;_gfbaf :=_bgdg .Points ;for _dgbae :=range _gfbaf {for _dggc :=range _gfbaf [_dgbae ]{_ebdf :=&_gfbaf [_dgbae ][_dggc ];_ebdf .Y =ctx .PageHeight -_ebdf .Y ;};};_ffeg ,_ ,_gadeg :=_bgdg .Draw (_dbga );if _gadeg !=nil {return nil ,ctx ,_gadeg ;};if _gadeg =_fdbg .addContentsByString (string (_ffeg ));_gadeg !=nil {return nil ,ctx ,_gadeg ;};return []*Block {_fdbg },ctx ,nil ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_fbc *Chapter )SetShowNumbering (show bool ){_fbc ._aea =show ;_fbc ._ggfb .SetText (_fbc .headingText ());};

// SetDate sets the date of the invoice.
func (_bdf *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_bdf ._fdgea [1].Value =date ;return _bdf ._fdgea [0],_bdf ._fdgea [1];};

// SetShowLinks sets visibility of links for the TOC lines.
func (_baffa *TOC )SetShowLinks (showLinks bool ){_baffa ._eabe =showLinks };func _ebead (_afe ,_gbbb TextStyle )*Invoice {_ebeb :=&Invoice {_adcb :"\u0049N\u0056\u004f\u0049\u0043\u0045",_ccfc :"\u002c\u0020",_adac :_afe ,_gcfa :_gbbb };_ebeb ._ggbd =&InvoiceAddress {Separator :_ebeb ._ccfc };_ebeb ._gfda =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_ebeb ._ccfc };_eagd :=ColorRGBFrom8bit (245,245,245);_dggd :=ColorRGBFrom8bit (155,155,155);_ebeb ._eedg =_gbbb ;_ebeb ._eedg .Color =_dggd ;_ebeb ._eedg .FontSize =20;_ebeb ._fgfd =_afe ;_ebeb ._dbac =_gbbb ;_ebeb ._bcdf =_afe ;_ebeb ._fegg =_gbbb ;_ebeb ._efba =_ebeb .NewCellProps ();_ebeb ._efba .BackgroundColor =_eagd ;_ebeb ._efba .TextStyle =_gbbb ;_ebeb ._cdaef =_ebeb .NewCellProps ();_ebeb ._cdaef .TextStyle =_gbbb ;_ebeb ._cdaef .BackgroundColor =_eagd ;_ebeb ._cdaef .BorderColor =_eagd ;_ebeb ._dfgf =_ebeb .NewCellProps ();_ebeb ._dfgf .BorderColor =_eagd ;_ebeb ._dfgf .BorderSides =[]CellBorderSide {CellBorderSideBottom };_ebeb ._dfgf .Alignment =CellHorizontalAlignmentRight ;_ebeb ._cegc =_ebeb .NewCellProps ();_ebeb ._cegc .Alignment =CellHorizontalAlignmentRight ;_ebeb ._aggg =[2]*InvoiceCell {_ebeb .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_ebeb ._efba ),_ebeb .newCell ("",_ebeb ._efba )};_ebeb ._fdgea =[2]*InvoiceCell {_ebeb .newCell ("\u0044\u0061\u0074\u0065",_ebeb ._efba ),_ebeb .newCell ("",_ebeb ._efba )};_ebeb ._fgd =[2]*InvoiceCell {_ebeb .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_ebeb ._efba ),_ebeb .newCell ("",_ebeb ._efba )};_ebeb ._befb =[2]*InvoiceCell {_ebeb .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_ebeb ._cegc ),_ebeb .newCell ("",_ebeb ._cegc )};_eacaa :=_ebeb ._cegc ;_eacaa .TextStyle =_gbbb ;_eacaa .BackgroundColor =_eagd ;_eacaa .BorderColor =_eagd ;_ebeb ._efad =[2]*InvoiceCell {_ebeb .newCell ("\u0054\u006f\u0074a\u006c",_eacaa ),_ebeb .newCell ("",_eacaa )};_ebeb ._gagb =[2]string {"\u004e\u006f\u0074e\u0073",""};_ebeb ._baff =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_ebeb ._ccce =[]*InvoiceCell {_ebeb .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_ebeb .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_ebeb .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_ebeb .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _ebeb ;};

// SetAngle sets Image rotation angle in degrees.
func (_aagcg *Image )SetAngle (angle float64 ){_aagcg ._afgd =angle };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_edef *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfgc :=ctx ;_gggc :=[]func (_facb DrawContext )([]*Block ,DrawContext ,error ){_edef .generateHeaderBlocks ,_edef .generateInformationBlocks ,_edef .generateLineBlocks ,_edef .generateTotalBlocks ,_edef .generateNoteBlocks };var _ccbd []*Block ;for _ ,_abfa :=range _gggc {_fdab ,_ddde ,_gfab :=_abfa (ctx );if _gfab !=nil {return _ccbd ,ctx ,_gfab ;};if len (_ccbd )==0{_ccbd =_fdab ;}else if len (_fdab )> 0{_ccbd [len (_ccbd )-1].mergeBlocks (_fdab [0]);_ccbd =append (_ccbd ,_fdab [1:]...);};ctx =_ddde ;};if _edef ._dbceb .isRelative (){ctx .X =_cfgc .X ;};if _edef ._dbceb .isAbsolute (){return _ccbd ,_cfgc ,nil ;};return _ccbd ,ctx ,nil ;};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_caed []VectorDrawable ;_ffd positioning ;_bca margins ;_feg bool ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_bac *Creator )NewTextStyle ()TextStyle {return _fgbcb (_bac ._bfgaa )};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_bbc *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_bbc ._efdc =toc ;};func _bcgdd (_bfda ,_deagd ,_dfaaf TextChunk ,_bcba uint ,_ggaca TextStyle )*TOCLine {_afac :=_adce (_ggaca );_afac .SetEnableWrap (true );_afac .SetTextAlignment (TextAlignmentLeft );_afac .SetMargins (0,0,2,2);_bafe :=&TOCLine {_agddae :_afac ,Number :_bfda ,Title :_deagd ,Page :_dfaaf ,Separator :TextChunk {Text :"\u002e",Style :_ggaca },_egfb :0,_gcgd :_bcba ,_cgdb :10,_gbac :_abbd };_afac ._bbgga ._bfca =_bafe ._egfb +float64 (_bafe ._gcgd -1)*_bafe ._cgdb ;_afac ._aedb =_bafe .prepareParagraph ;return _bafe ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_edfg *TableCell )SetContent (vd VectorDrawable )error {switch _gbbg :=vd .(type ){case *Paragraph :if _gbbg ._gea {_gbbg ._agbb =true ;};_edfg ._abcfe =vd ;case *StyledParagraph :if _gbbg ._babed {_gbbg ._afgdg =true ;};_edfg ._abcfe =vd ;case *Image :_edfg ._abcfe =vd ;case *Table :_edfg ._abcfe =vd ;case *List :_edfg ._abcfe =vd ;case *Division :_edfg ._abcfe =vd ;default:_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _ac .ErrTypeError ;};return nil ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_cfef *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_dbbbf ,_caef :=_cfef .Wrap (width );if _caef !=nil {return nil ,_caef ;};_cacc :=int (height /_cfef .Style .FontSize );if _cacc >=len (_dbbbf ){return nil ,nil ;};_ggdgg :="\u000a";_cfef .Text =_e .Replace (_e .Join (_dbbbf [:_cacc ],"\u0020"),_ggdgg +"\u0020",_ggdgg ,-1);_efbb :=_e .Replace (_e .Join (_dbbbf [_cacc :],"\u0020"),_ggdgg +"\u0020",_ggdgg ,-1);return NewTextChunk (_efbb ,_cfef .Style ),nil ;};

// SetBorderColor sets border color.
func (_eaga *Rectangle )SetBorderColor (col Color ){_eaga ._aafe =_da .NewPdfColorDeviceRGB (col .ToRGB ());};func _fgcbf (_fafd string )*_da .PdfAnnotation {_fbdg :=_da .NewPdfAnnotationLink ();_cege :=_da .NewBorderStyle ();_cege .SetBorderWidth (0);_fbdg .BS =_cege .ToPdfObject ();_cbed :=_da .NewPdfActionURI ();_cbed .URI =_ac .MakeString (_fafd );_fbdg .SetAction (_cbed .PdfAction );return _fbdg .PdfAnnotation ;};

// Level returns the indentation level of the TOC line.
func (_cbagc *TOCLine )Level ()uint {return _cbagc ._gcgd };

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_ag .Max (_ag .Min (r ,1.0),0.0);g =_ag .Max (_ag .Min (g ,1.0),0.0);b =_ag .Max (_ag .Min (b ,1.0),0.0);_fafe :=rgbColor {};_fafe ._gdbe =r ;_fafe ._ddcc =g ;_fafe ._def =b ;return _fafe ;};

// GetOptimizer returns current PDF optimizer.
func (_fad *Creator )GetOptimizer ()_da .Optimizer {return _fad ._gfc };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_edbg *Invoice )TotalLines ()[][2]*InvoiceCell {_cfeb :=[][2]*InvoiceCell {_edbg ._befb };_cfeb =append (_cfeb ,_edbg ._gda ...);return append (_cfeb ,_edbg ._efad );};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_aed *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_agbe *_da .PdfWriter )error ){_aed ._ccfd =pdfWriterAccessFunc ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func (_gfec *Invoice )drawSection (_acggb ,_dbbg string )[]*StyledParagraph {var _caac []*StyledParagraph ;if _acggb !=""{_fgfc :=_adce (_gfec ._fegg );_fgfc .SetMargins (0,0,0,5);_fgfc .Append (_acggb );_caac =append (_caac ,_fgfc );};if _dbbg !=""{_gabe :=_adce (_gfec ._bcdf );_gabe .Append (_dbbg );_caac =append (_caac ,_gabe );};return _caac ;};

// SetBackgroundColor sets the cell's background color.
func (_ecdea *TableCell )SetBackgroundColor (col Color ){_ecdea ._bbfde =_da .NewPdfColorDeviceRGB (col .ToRGB ());};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gfeed *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eebfc :=ctx ;_egcc ,ctx ,_gecf :=_gfeed ._dcae .GeneratePageBlocks (ctx );if _gecf !=nil {return _egcc ,ctx ,_gecf ;};for _ ,_cgcbb :=range _gfeed ._fgceb {_gbaf :=_cgcbb ._cacea ;if !_gfeed ._eabe {_cgcbb ._cacea =0;};_eeaga ,_gced ,_dged :=_cgcbb .GeneratePageBlocks (ctx );_cgcbb ._cacea =_gbaf ;if _dged !=nil {return _egcc ,ctx ,_dged ;};if len (_eeaga )< 1{continue ;};_egcc [len (_egcc )-1].mergeBlocks (_eeaga [0]);_egcc =append (_egcc ,_eeaga [1:]...);ctx =_gced ;};if _gfeed ._abafa .isRelative (){ctx .X =_eebfc .X ;};if _gfeed ._abafa .isAbsolute (){return _egcc ,_eebfc ,nil ;};return _egcc ,ctx ,nil ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_bbbd *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_gaff :=&_bbbd ._ggbaa ;_gaff ._bfca =left ;_gaff ._dbca =right ;_gaff ._agbf =top ;_gaff ._cee =bottom ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// Lines returns all the lines the table of contents has.
func (_cded *TOC )Lines ()[]*TOCLine {return _cded ._fgceb };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_beaad *Invoice )SetColumns (cols []*InvoiceCell ){_beaad ._ccce =cols };

// SetBorderWidth sets the border width.
func (_cdbcd *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_cdbcd ._dcdc .BorderWidth =borderWidth ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_ecbag *StyledParagraph )Height ()float64 {_ecbag .wrapText ();var _cgbef float64 ;for _ ,_ggee :=range _ecbag ._cff {var _cbfc float64 ;for _ ,_deag :=range _ggee {_fedb :=_ecbag ._gcgaf *_deag .Style .FontSize ;if _fedb > _cbfc {_cbfc =_fedb ;};};_cgbef +=_cbfc ;};return _cgbef ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ebdb *TOC )SetLineStyle (style TextStyle ){_ebdb .SetLineNumberStyle (style );_ebdb .SetLineTitleStyle (style );_ebdb .SetLineSeparatorStyle (style );_ebdb .SetLinePageStyle (style );};

// SetFillOpacity sets the fill opacity.
func (_aede *Polygon )SetFillOpacity (opacity float64 ){_aede ._abgd =opacity };

// MoveX moves the drawing context to absolute position x.
func (_egef *Creator )MoveX (x float64 ){_egef ._acf .X =x };func (_ffca *Invoice )newCell (_fede string ,_affd InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_affd ,_fede };};func (_fdd *Block )duplicate ()*Block {_bd :=&Block {};*_bd =*_fdd ;_fdf :=_ab .ContentStreamOperations {};_fdf =append (_fdf ,*_fdd ._f ...);_bd ._f =&_fdf ;return _bd ;};func (_ggga *Invoice )generateInformationBlocks (_fdgb DrawContext )([]*Block ,DrawContext ,error ){_edgg :=_adce (_ggga ._adac );_edgg .SetMargins (0,0,0,20);_gfbfc :=_ggga .drawAddress (_ggga ._ggbd );_gfbfc =append (_gfbfc ,_edgg );_gfbfc =append (_gfbfc ,_ggga .drawAddress (_ggga ._gfda )...);_efgg :=_bdag ();for _ ,_ggaf :=range _gfbfc {_efgg .Add (_ggaf );};_fdba :=_ggga .drawInformation ();_gefdd :=_fcae (2);_gefdd .SetMargins (0,0,25,0);_fdde :=_gefdd .NewCell ();_fdde .SetIndent (0);_fdde .SetContent (_efgg );_fdde =_gefdd .NewCell ();_fdde .SetContent (_fdba );return _gefdd .GeneratePageBlocks (_fdgb );};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_bgfg *StyledParagraph )Insert (index uint ,text string )*TextChunk {_eaacf :=uint (len (_bgfg ._caca ));if index > _eaacf {index =_eaacf ;};_abcg :=NewTextChunk (text ,_bgfg ._bgcf );_bgfg ._caca =append (_bgfg ._caca [:index ],append ([]*TextChunk {_abcg },_bgfg ._caca [index :]...)...);_bgfg .wrapText ();return _abcg ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_gcg *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_gcg ._fdc ._bfca =left ;_gcg ._fdc ._dbca =right ;_gcg ._fdc ._agbf =top ;_gcg ._fdc ._cee =bottom ;};

// SetTitle sets the title of the invoice.
func (_bdbfd *Invoice )SetTitle (title string ){_bdbfd ._adcb =title };

// SetLineWidth sets the line width.
func (_fegf *Polyline )SetLineWidth (lineWidth float64 ){_fegf ._adbe .LineWidth =lineWidth };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_eece *Invoice )NoteHeadingStyle ()TextStyle {return _eece ._fegg };

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_decf string ;_edgag *_da .PdfFont ;_agge float64 ;_ebeae float64 ;_dcfg _da .PdfColorDeviceRGB ;_dbece TextAlignment ;_agbb bool ;_feec float64 ;_egfd int ;_gea bool ;_agec float64 ;_gffg margins ;_cbcc positioning ;_fccb float64 ;_gecb float64 ;_cccd ,_cacd float64 ;_cebg []string ;};

// Height returns Image's document height.
func (_bcfcc *Image )Height ()float64 {return _bcfcc ._dgd };func _fbcga (_cafgd *Block ,_eecaf *StyledParagraph ,_fgbce [][]*TextChunk ,_cbcfb DrawContext )(DrawContext ,[][]*TextChunk ,error ){_abggd :=1;_ecec :=_ac .PdfObjectName (_b .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abggd ));for _cafgd ._fa .HasFontByName (_ecec ){_abggd ++;_ecec =_ac .PdfObjectName (_b .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abggd ));};_feef :=_cafgd ._fa .SetFontByName (_ecec ,_eecaf ._bgcf .Font .ToPdfObject ());if _feef !=nil {return _cbcfb ,nil ,_feef ;};_abggd ++;_bbad :=_ecec ;_fbcbg :=_eecaf ._bgcf .FontSize ;_gaec :=_eecaf ._cceg .isRelative ();var _gbff [][]_ac .PdfObjectName ;var _cdgg float64 ;var _egbf [][]*TextChunk ;var _eefe float64 ;for _gcce ,_bbff :=range _fgbce {var _cfdfc []_ac .PdfObjectName ;var _aeda float64 ;for _ ,_fdgde :=range _bbff {_agbg :=_fdgde .Style ;if _gcce ==0&&_agbg .FontSize > _cdgg {_cdgg =_agbg .FontSize ;};if _agbg .FontSize > _aeda {_aeda =_agbg .FontSize ;};_ecec =_ac .PdfObjectName (_b .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abggd ));_fec :=_cafgd ._fa .SetFontByName (_ecec ,_agbg .Font .ToPdfObject ());if _fec !=nil {return _cbcfb ,nil ,_fec ;};_cfdfc =append (_cfdfc ,_ecec );_abggd ++;};_aeda *=_eecaf ._gcgaf ;if _gaec &&_eefe +_aeda > _cbcfb .Height {_egbf =_fgbce [_gcce :];_fgbce =_fgbce [:_gcce ];break ;};_eefe +=_aeda ;_gbff =append (_gbff ,_cfdfc );};_gfee :=_ab .NewContentCreator ();_gfee .Add_q ();_gbfc :=_cbcfb .PageHeight -_cbcfb .Y -_cdgg *_eecaf ._gcgaf ;_gfee .Translate (_cbcfb .X ,_gbfc );if _eecaf ._bdaf !=0{_gfee .RotateDeg (_eecaf ._bdaf );};_gfee .Add_BT ();_fcecc :=_gbfc ;for _egbb ,_fbeeeg :=range _fgbce {_ddabe :=_cbcfb .X ;if _egbb !=0{_gfee .Add_Tstar ();};_bffe :=_egbb ==len (_fgbce )-1;var (_caec float64 ;_gabgg float64 ;_fcag float64 ;_abdca uint ;);var _dceg []float64 ;for _ ,_bgdgg :=range _fbeeeg {_bgff :=&_bgdgg .Style ;if _bgff .FontSize > _gabgg {_gabgg =_bgff .FontSize ;};_aabg ,_eefa :=_bgff .Font .GetRuneMetrics (' ');if !_eefa {return _cbcfb ,nil ,_de .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _dcbcb uint ;var _decc float64 ;_dbbb :=len (_bgdgg .Text );for _feecd ,_cfad :=range _bgdgg .Text {if _cfad ==' '{_dcbcb ++;continue ;};if _cfad =='\u000A'{continue ;};_afca ,_gfae :=_bgff .Font .GetRuneMetrics (_cfad );if !_gfae {_bg .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_cfad );return _cbcfb ,nil ,_de .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_decc +=_bgff .FontSize *_afca .Wx ;if _feecd !=_dbbb -1{_decc +=_bgff .CharSpacing *1000.0;};};_dceg =append (_dceg ,_decc );_caec +=_decc ;_fcag +=float64 (_dcbcb )*_aabg .Wx *_bgff .FontSize ;_abdca +=_dcbcb ;};_gabgg *=_eecaf ._gcgaf ;var _aebcc []_ac .PdfObject ;_ebba :=_eecaf ._ggdg *1000.0;if _eecaf ._dabff ==TextAlignmentJustify {if _abdca > 0&&!_bffe {_fcag =(_ebba -_caec )/float64 (_abdca )/_fbcbg ;};}else if _eecaf ._dabff ==TextAlignmentCenter {_beda :=(_ebba -_caec -_fcag )/2;_cfaf :=_beda /_fbcbg ;_aebcc =append (_aebcc ,_ac .MakeFloat (-_cfaf ));_ddabe +=_beda /1000.0;}else if _eecaf ._dabff ==TextAlignmentRight {_fabff :=(_ebba -_caec -_fcag );_gdae :=_fabff /_fbcbg ;_aebcc =append (_aebcc ,_ac .MakeFloat (-_gdae ));_ddabe +=_fabff /1000.0;};if len (_aebcc )> 0{_gfee .Add_Tf (_bbad ,_fbcbg ).Add_TL (_fbcbg *_eecaf ._gcgaf ).Add_TJ (_aebcc ...);};for _edaf ,_eacdd :=range _fbeeeg {_eebff :=&_eacdd .Style ;_edebg ,_cecef ,_bgcc :=_eebff .Color .ToRGB ();_edeg :=_bbad ;_gfdca :=_fbcbg ;_gfee .Add_Tr (int64 (_eebff .RenderingMode ));_gfee .Add_Tc (_eebff .CharSpacing );if _eecaf ._dabff !=TextAlignmentJustify ||_bffe {_fddf ,_gcaf :=_eebff .Font .GetRuneMetrics (' ');if !_gcaf {return _cbcfb ,nil ,_de .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_edeg =_gbff [_egbb ][_edaf ];_gfdca =_eebff .FontSize ;_fcag =_fddf .Wx ;};_cfae :=_eebff .Font .Encoder ();var _abeag []byte ;for _ ,_dded :=range _eacdd .Text {if _edebg =='\u000A'{continue ;};if _dded ==' '{if len (_abeag )> 0{_gfee .Add_rg (_edebg ,_cecef ,_bgcc ).Add_Tf (_gbff [_egbb ][_edaf ],_eebff .FontSize ).Add_TL (_eebff .FontSize *_eecaf ._gcgaf ).Add_TJ ([]_ac .PdfObject {_ac .MakeStringFromBytes (_abeag )}...);_abeag =nil ;};_gfee .Add_Tf (_edeg ,_gfdca ).Add_TL (_gfdca *_eecaf ._gcgaf ).Add_TJ ([]_ac .PdfObject {_ac .MakeFloat (-_fcag )}...);_dceg [_edaf ]+=_fcag *_gfdca ;}else {if _ ,_cgdg :=_cfae .RuneToCharcode (_dded );!_cgdg {_bg .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_dded ,_dded );continue ;};_abeag =append (_abeag ,_cfae .Encode (string (_dded ))...);};};if len (_abeag )> 0{_gfee .Add_rg (_edebg ,_cecef ,_bgcc ).Add_Tf (_gbff [_egbb ][_edaf ],_eebff .FontSize ).Add_TL (_eebff .FontSize *_eecaf ._gcgaf ).Add_TJ ([]_ac .PdfObject {_ac .MakeStringFromBytes (_abeag )}...);};_affe :=_dceg [_edaf ]/1000.0;if _eacdd ._accfg !=nil {var _cfdaa *_ac .PdfObjectArray ;if !_eacdd ._baafa {switch _bbdg :=_eacdd ._accfg .GetContext ().(type ){case *_da .PdfAnnotationLink :_cfdaa =_ac .MakeArray ();_bbdg .Rect =_cfdaa ;_bfcc ,_eagdd :=_bbdg .Dest .(*_ac .PdfObjectArray );if _eagdd &&_bfcc .Len ()==5{_efbeb ,_aage :=_bfcc .Get (1).(*_ac .PdfObjectName );if _aage &&_efbeb .String ()=="\u0058\u0059\u005a"{_aafdd ,_gaca :=_ac .GetNumberAsFloat (_bfcc .Get (3));if _gaca ==nil {_bfcc .Set (3,_ac .MakeFloat (_cbcfb .PageHeight -_aafdd ));};};};};_eacdd ._baafa =true ;};if _cfdaa !=nil {_efdb :=_eb .NewPoint (_ddabe -_cbcfb .X ,_fcecc -_gbfc ).Rotate (_eecaf ._bdaf );_efdb .X +=_cbcfb .X ;_efdb .Y +=_gbfc ;_aaaed ,_bbfd ,_babg ,_agcc :=_abafae (_affe ,_gabgg ,_eecaf ._bdaf );_efdb .X +=_aaaed ;_efdb .Y +=_bbfd ;_cfdaa .Clear ();_cfdaa .Append (_ac .MakeFloat (_efdb .X ));_cfdaa .Append (_ac .MakeFloat (_efdb .Y ));_cfdaa .Append (_ac .MakeFloat (_efdb .X +_babg ));_cfdaa .Append (_ac .MakeFloat (_efdb .Y +_agcc ));};_cafgd .AddAnnotation (_eacdd ._accfg );};_ddabe +=_affe ;_gfee .Add_Tr (int64 (TextRenderingModeFill ));_gfee .Add_Tc (0);};_fcecc -=_gabgg ;};_gfee .Add_ET ();_gfee .Add_Q ();_eacaab :=_gfee .Operations ();_eacaab .WrapIfNeeded ();_cafgd .addContents (_eacaab );if _gaec {_egfc :=_eefe +_eecaf ._bbgga ._cee ;_cbcfb .Y +=_egfc ;_cbcfb .Height -=_egfc ;if _cbcfb .Inline {_cbcfb .X +=_eecaf .Width ()+_eecaf ._bbgga ._dbca ;};};return _cbcfb ,_egbf ,nil ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_dggcd *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_dggcd ._gfbe {_bg .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _de .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dggcd ._cgcgb =widths ;return nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dede *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfgg :=ctx ;_febfe ,ctx ,_efade :=_dede ._agddae .GeneratePageBlocks (ctx );if _efade !=nil {return _febfe ,ctx ,_efade ;};if _dede ._gbac .isRelative (){ctx .X =_dfgg .X ;};if _dede ._gbac .isAbsolute (){return _febfe ,_dfgg ,nil ;};return _febfe ,ctx ,nil ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func _bggb (_badd *Block ,_fgg *Paragraph ,_afgc DrawContext )(DrawContext ,error ){_cgab :=1;_dacg :=_ac .PdfObjectName ("\u0046\u006f\u006e\u0074"+_cb .Itoa (_cgab ));for _badd ._fa .HasFontByName (_dacg ){_cgab ++;_dacg =_ac .PdfObjectName ("\u0046\u006f\u006e\u0074"+_cb .Itoa (_cgab ));};_fcdf :=_badd ._fa .SetFontByName (_dacg ,_fgg ._edgag .ToPdfObject ());if _fcdf !=nil {return _afgc ,_fcdf ;};_fgg .wrapText ();_defe :=_ab .NewContentCreator ();_defe .Add_q ();_ecbdf :=_afgc .PageHeight -_afgc .Y -_fgg ._agge *_fgg ._ebeae ;_defe .Translate (_afgc .X ,_ecbdf );if _fgg ._agec !=0{_defe .RotateDeg (_fgg ._agec );};_defe .Add_BT ().Add_rg (_fgg ._dcfg .R (),_fgg ._dcfg .G (),_fgg ._dcfg .B ()).Add_Tf (_dacg ,_fgg ._agge ).Add_TL (_fgg ._agge *_fgg ._ebeae );for _ggabe ,_fgfg :=range _fgg ._cebg {if _ggabe !=0{_defe .Add_Tstar ();};_aeec :=[]rune (_fgfg );_gdce :=0.0;_ddg :=0;for _fdeb ,_dacd :=range _aeec {if _dacd ==' '{_ddg ++;continue ;};if _dacd =='\u000A'{continue ;};_ddea ,_eeag :=_fgg ._edgag .GetRuneMetrics (_dacd );if !_eeag {_bg .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_fdeb ,_dacd ,_dacd ,_fgg ._edgag .BaseFont (),_fgg ._edgag .Subtype ());return _afgc ,_de .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_gdce +=_fgg ._agge *_ddea .Wx ;};var _agdb []_ac .PdfObject ;_cafac ,_adba :=_fgg ._edgag .GetRuneMetrics (' ');if !_adba {return _afgc ,_de .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_dbedf :=_cafac .Wx ;switch _fgg ._dbece {case TextAlignmentJustify :if _ddg > 0&&_ggabe < len (_fgg ._cebg )-1{_dbedf =(_fgg ._feec *1000.0-_gdce )/float64 (_ddg )/_fgg ._agge ;};case TextAlignmentCenter :_afaf :=_gdce +float64 (_ddg )*_dbedf *_fgg ._agge ;_gdecf :=(_fgg ._feec *1000.0-_afaf )/2/_fgg ._agge ;_agdb =append (_agdb ,_ac .MakeFloat (-_gdecf ));case TextAlignmentRight :_edge :=_gdce +float64 (_ddg )*_dbedf *_fgg ._agge ;_bfcab :=(_fgg ._feec *1000.0-_edge )/_fgg ._agge ;_agdb =append (_agdb ,_ac .MakeFloat (-_bfcab ));};_abbf :=_fgg ._edgag .Encoder ();var _cafgf []byte ;for _ ,_eeca :=range _aeec {if _eeca =='\u000A'{continue ;};if _eeca ==' '{if len (_cafgf )> 0{_agdb =append (_agdb ,_ac .MakeStringFromBytes (_cafgf ));_cafgf =nil ;};_agdb =append (_agdb ,_ac .MakeFloat (-_dbedf ));}else {if _ ,_fgdc :=_abbf .RuneToCharcode (_eeca );!_fgdc {_bg .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_eeca ,_eeca );continue ;};_cafgf =append (_cafgf ,_abbf .Encode (string (_eeca ))...);};};if len (_cafgf )> 0{_agdb =append (_agdb ,_ac .MakeStringFromBytes (_cafgf ));};_defe .Add_TJ (_agdb ...);};_defe .Add_ET ();_defe .Add_Q ();_edfe :=_defe .Operations ();_edfe .WrapIfNeeded ();_badd .addContents (_edfe );if _fgg ._cbcc .isRelative (){_ggbaf :=_fgg .Height ()+_fgg ._gffg ._cee ;_afgc .Y +=_ggbaf ;_afgc .Height -=_ggbaf ;if _afgc .Inline {_afgc .X +=_fgg .Width ()+_fgg ._gffg ._dbca ;};};return _afgc ,nil ;};func _ffaa ()*PageBreak {return &PageBreak {}};

// NewCell returns a new invoice table cell.
func (_fgdf *Invoice )NewCell (value string )*InvoiceCell {return _fgdf .newCell (value ,_fgdf .NewCellProps ());};func (_bdae *Table )clone ()*Table {_aeca :=*_bdae ;_aeca ._caceb =make ([]float64 ,len (_bdae ._caceb ));copy (_aeca ._caceb ,_bdae ._caceb );_aeca ._cgcgb =make ([]float64 ,len (_bdae ._cgcgb ));copy (_aeca ._cgcgb ,_bdae ._cgcgb );_aeca ._adceb =make ([]*TableCell ,0,len (_bdae ._adceb ));for _ ,_gdbed :=range _bdae ._adceb {_cgeag :=*_gdbed ;_cgeag ._baaf =&_aeca ;_aeca ._adceb =append (_aeca ._adceb ,&_cgeag );};return &_aeca ;};func (_egace *TableCell )width (_bffa []float64 ,_fbec float64 )float64 {_babf :=float64 (0.0);for _affga :=0;_affga < _egace ._ddedg ;_affga ++{_babf +=_bffa [_egace ._dbaad +_affga -1];};return _babf *_fbec ;};type positioning int ;

// GeneratePageBlocks draws the filled curve on page blocks.
func (_gabg *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbdd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_deadb ,_ ,_fdeg :=_gabg .draw ("");if _fdeg !=nil {return nil ,ctx ,_fdeg ;};_fdeg =_dbdd .addContentsByString (string (_deadb ));if _fdeg !=nil {return nil ,ctx ,_fdeg ;};return []*Block {_dbdd },ctx ,nil ;};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_bge :=rgbColor {};_bge ._gdbe =float64 (r )/255.0;_bge ._ddcc =float64 (g )/255.0;_bge ._def =float64 (b )/255.0;return _bge ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_gbbc *Creator )NewPage ()*_da .PdfPage {_add :=_gbbc .newPage ();_gbbc ._egae =append (_gbbc ._egae ,_add );_gbbc ._acf .Page ++;return _add ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_cdea *FilledCurve )AppendCurve (curve _eb .CubicBezierCurve )*FilledCurve {_cdea ._abaa =append (_cdea ._abaa ,curve );return _cdea ;};type listItem struct{_gfbg VectorDrawable ;_cdbcg TextChunk ;};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_cfda *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gabed :=ctx ;var _aaec []*Block ;_bgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cfda ._cbcc .isRelative (){ctx .X +=_cfda ._gffg ._bfca ;ctx .Y +=_cfda ._gffg ._agbf ;ctx .Width -=_cfda ._gffg ._bfca +_cfda ._gffg ._dbca ;ctx .Height -=_cfda ._gffg ._agbf +_cfda ._gffg ._cee ;_cfda .SetWidth (ctx .Width );if _cfda .Height ()> ctx .Height {_aaec =append (_aaec ,_bgg );_bgg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_degf :=ctx ;_degf .Y =ctx .Margins ._agbf ;_degf .X =ctx .Margins ._bfca +_cfda ._gffg ._bfca ;_degf .Height =ctx .PageHeight -ctx .Margins ._agbf -ctx .Margins ._cee -_cfda ._gffg ._cee ;_degf .Width =ctx .PageWidth -ctx .Margins ._bfca -ctx .Margins ._dbca -_cfda ._gffg ._bfca -_cfda ._gffg ._dbca ;ctx =_degf ;};}else {if int (_cfda ._feec )<=0{_cfda .SetWidth (_cfda .getTextWidth ());};ctx .X =_cfda ._fccb ;ctx .Y =_cfda ._gecb ;};ctx ,_fdbde :=_bggb (_bgg ,_cfda ,ctx );if _fdbde !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fdbde );return nil ,ctx ,_fdbde ;};_aaec =append (_aaec ,_bgg );if _cfda ._cbcc .isRelative (){ctx .X -=_cfda ._gffg ._bfca ;ctx .Width =_gabed .Width ;return _aaec ,ctx ,nil ;};return _aaec ,_gabed ,nil ;};func (_fgcf *Table )newCell (_cbcdc int )*TableCell {_fgcf ._fbfgf ++;_ffgc :=(_fgcf ._fbfgf -1)/_fgcf ._gfbe +1;for _ffgc > _fgcf ._bead {_fgcf ._bead ++;_fgcf ._caceb =append (_fgcf ._caceb ,_fgcf ._cbcfeg );};_acfe :=(_fgcf ._fbfgf -1)%(_fgcf ._gfbe )+1;_dgef :=&TableCell {};_dgef ._gggcc =_ffgc ;_dgef ._dbaad =_acfe ;_dgef ._cddd =1;_dgef ._gcef =5;_dgef ._fcdfc =CellBorderStyleNone ;_dgef ._dbaf =_eb .LineStyleSolid ;_dgef ._egagb =CellHorizontalAlignmentLeft ;_dgef ._feccc =CellVerticalAlignmentTop ;_dgef ._gdg =0;_dgef ._dafb =0;_dgef ._dbfbf =0;_dgef ._afbbbe =0;_agcg :=ColorBlack ;_dgef ._dcec =_da .NewPdfColorDeviceRGB (_agcg .ToRGB ());_dgef ._gffe =_da .NewPdfColorDeviceRGB (_agcg .ToRGB ());_dgef ._bgbd =_da .NewPdfColorDeviceRGB (_agcg .ToRGB ());_dgef ._febae =_da .NewPdfColorDeviceRGB (_agcg .ToRGB ());if _cbcdc < 1{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_cbcdc );_cbcdc =1;};_ffcag :=_fgcf ._gfbe -(_dgef ._dbaad -1);if _cbcdc > _ffcag {_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_cbcdc ,_ffcag );_cbcdc =_ffcag ;};_dgef ._ddedg =_cbcdc ;_fgcf ._fbfgf +=_cbcdc -1;_fgcf ._adceb =append (_fgcf ._adceb ,_dgef );_dgef ._baaf =_fgcf ;return _dgef ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_edfd *Creator )NewImageFromGoImage (goimg _dd .Image )(*Image ,error ){return _dedb (goimg )};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_cddc *Invoice )AddressStyle ()TextStyle {return _cddc ._fgfd };

// SetNotes sets the notes section of the invoice.
func (_bcac *Invoice )SetNotes (title ,content string ){_bcac ._gagb =[2]string {title ,content }};

// SetColor sets the line color.
func (_cgbe *Curve )SetColor (col Color ){_cgbe ._cbbd =_da .NewPdfColorDeviceRGB (col .ToRGB ())};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// SetBorderColor sets the border color.
func (_cag *Ellipse )SetBorderColor (col Color ){_cag ._cgfa =_da .NewPdfColorDeviceRGB (col .ToRGB ())};

// Reset removes all the text chunks the paragraph contains.
func (_dfda *StyledParagraph )Reset (){_dfda ._caca =[]*TextChunk {}};func (_febd *Invoice )generateHeaderBlocks (_acbc DrawContext )([]*Block ,DrawContext ,error ){_dgfbc :=_adce (_febd ._eedg );_dgfbc .SetEnableWrap (true );_dgfbc .Append (_febd ._adcb );_ccef :=_fcae (2);if _febd ._dccg !=nil {_bfdg :=_ccef .NewCell ();_bfdg .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bfdg .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bfdg .SetIndent (0);_bfdg .SetContent (_febd ._dccg );_febd ._dccg .ScaleToHeight (_dgfbc .Height ()+20);}else {_ccef .SkipCells (1);};_cegb :=_ccef .NewCell ();_cegb .SetHorizontalAlignment (CellHorizontalAlignmentRight );_cegb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cegb .SetContent (_dgfbc );return _ccef .GeneratePageBlocks (_acbc );};

// NewDivision returns a new Division container component.
func (_acfd *Creator )NewDivision ()*Division {return _bdag ()};

// SetBorderColor sets the border color for the path.
func (_ddab *FilledCurve )SetBorderColor (color Color ){_ddab ._eeea =_da .NewPdfColorDeviceRGB (color .ToRGB ());};

// BuyerAddress returns the buyer address used in the invoice template.
func (_afa *Invoice )BuyerAddress ()*InvoiceAddress {return _afa ._gfda };func (_feae *Chapter )headingNumber ()string {var _bfga string ;if _feae ._aea {if _feae ._bbfb !=0{_bfga =_cb .Itoa (_feae ._bbfb )+"\u002e";};if _feae ._ebea !=nil {_dbec :=_feae ._ebea .headingNumber ();if _dbec !=""{_bfga =_dbec +_bfga ;};};};return _bfga ;};

// SetBorderWidth sets the border width.
func (_gddc *Polygon )SetBorderWidth (borderWidth float64 ){_gddc ._cced .BorderWidth =borderWidth };

// NewImageFromData creates an Image from image data.
func (_cafe *Creator )NewImageFromData (data []byte )(*Image ,error ){return _eegc (data )};func (_bdab *Image )makeXObject ()error {_adb :=_bdab ._bfba ;if _adb ==nil {_adb =_ac .NewFlateEncoder ();};_cbeb ,_gaab :=_da .NewXObjectImageFromImage (_bdab ._eacb ,nil ,_adb );if _gaab !=nil {_bg .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gaab );return _gaab ;};_bdab ._eaac =_cbeb ;return nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_adcb string ;_dccg *Image ;_gfda *InvoiceAddress ;_ggbd *InvoiceAddress ;_ccfc string ;_aggg [2]*InvoiceCell ;_fdgea [2]*InvoiceCell ;_fgd [2]*InvoiceCell ;_gdfd [][2]*InvoiceCell ;_ccce []*InvoiceCell ;_fbcc [][]*InvoiceCell ;_befb [2]*InvoiceCell ;_efad [2]*InvoiceCell ;_gda [][2]*InvoiceCell ;_gagb [2]string ;_baff [2]string ;_begg [][2]string ;_adac TextStyle ;_gcfa TextStyle ;_eedg TextStyle ;_fgfd TextStyle ;_dbac TextStyle ;_bcdf TextStyle ;_fegg TextStyle ;_efba InvoiceCellProps ;_cdaef InvoiceCellProps ;_dfgf InvoiceCellProps ;_cegc InvoiceCellProps ;_dbceb positioning ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_fgaa *Image )SetWidth (w float64 ){_fgaa ._cfdf =w };

// Scale scales Image by a constant factor, both width and height.
func (_cece *Image )Scale (xFactor ,yFactor float64 ){_cece ._cfdf =xFactor *_cece ._cfdf ;_cece ._dgd =yFactor *_cece ._dgd ;};

// SetLineOpacity sets the line opacity.
func (_ebdg *Polyline )SetLineOpacity (opacity float64 ){_ebdg ._cgge =opacity };

// SetTotal sets the total of the invoice.
func (_adgdc *Invoice )SetTotal (value string ){_adgdc ._efad [1].Value =value };

// DrawHeader sets a function to draw a header on created output pages.
func (_ecba *Creator )DrawHeader (drawHeaderFunc func (_cfb *Block ,_gdec HeaderFunctionArgs )){_ecba ._fca =drawHeaderFunc ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_gdff *TOC )SetLinePageStyle (style TextStyle ){_gdff ._cagfg =style };

// SetBorderOpacity sets the border opacity.
func (_gaeg *Rectangle )SetBorderOpacity (opacity float64 ){_gaeg ._eefb =opacity };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_dff *Creator )SetOutlineTree (outlineTree *_da .PdfOutlineTreeNode ){_dff ._dda =outlineTree };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_f *_ab .ContentStreamOperations ;_fa *_da .PdfPageResources ;_be positioning ;_bf ,_bfd float64 ;_acc float64 ;_ff float64 ;_ee float64 ;_ec margins ;_ga []*_da .PdfAnnotation ;};

// SetAngle sets the rotation angle of the text.
func (_abda *StyledParagraph )SetAngle (angle float64 ){_abda ._bdaf =angle };

// SetFillColor sets the fill color.
func (_dcfe *Rectangle )SetFillColor (col Color ){_dcfe ._caea =_da .NewPdfColorDeviceRGB (col .ToRGB ())};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetWidthBottom sets border width for bottom.
func (_cdbg *border )SetWidthBottom (bw float64 ){_cdbg ._egc =bw };func _dabf (_cbcd ,_daaec ,_dbed ,_fbeee float64 )*Line {_ebbgd :=&Line {};_ebbgd ._aecgd =_cbcd ;_ebbgd ._cdga =_daaec ;_ebbgd ._ggbag =_dbed ;_ebbgd ._dbba =_fbeee ;_ebbgd ._fbcb =_da .NewPdfColorDeviceRGB (0,0,0);_ebbgd ._ccfde =1.0;return _ebbgd ;};

// SkipCells skips over a specified number of cells in the table.
func (_cea *Table )SkipCells (num int ){if num < 0{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_cea ._fbfgf +=num ;};

// NewColumn returns a new column for the line items invoice table.
func (_ccdc *Invoice )NewColumn (description string )*InvoiceCell {return _ccdc .newColumn (description ,CellHorizontalAlignmentLeft );};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_ccfcc *Table )MultiColCell (colspan int )*TableCell {return _ccfcc .newCell (colspan )};

// Lines returns all the rows of the invoice line items table.
func (_daae *Invoice )Lines ()[][]*InvoiceCell {return _daae ._fbcc };

// SetBorderColor sets the cell's border color.
func (_cbce *TableCell )SetBorderColor (col Color ){_cbce ._dcec =_da .NewPdfColorDeviceRGB (col .ToRGB ());_cbce ._gffe =_da .NewPdfColorDeviceRGB (col .ToRGB ());_cbce ._bgbd =_da .NewPdfColorDeviceRGB (col .ToRGB ());_cbce ._febae =_da .NewPdfColorDeviceRGB (col .ToRGB ());};

// Add adds a new Drawable to the chapter.
func (_eca *Chapter )Add (d Drawable )error {if Drawable (_eca )==d {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _de .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_eca ._fgf =append (_eca ._fgf ,d );default:_bg .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _de .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_ggdb *StyledParagraph )SetText (text string )*TextChunk {_ggdb .Reset ();return _ggdb .Append (text );};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_gdbb *Invoice )Terms ()(string ,string ){return _gdbb ._baff [0],_gdbb ._baff [1]};

// InsertColumn inserts a column in the line items table at the specified index.
func (_aafad *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_agee :=uint (len (_aafad ._ccce ));if index > _agee {index =_agee ;};_agddc :=_aafad .NewColumn (description );_aafad ._ccce =append (_aafad ._ccce [:index ],append ([]*InvoiceCell {_agddc },_aafad ._ccce [index :]...)...);return _agddc ;};func _fgbcb (_bfde *_da .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_bfde ,FontSize :10};};

// NewImageFromFile creates an Image from a file.
func (_cec *Creator )NewImageFromFile (path string )(*Image ,error ){return _efbf (path )};

// SetIndent sets the cell's left indent.
func (_ddgg *TableCell )SetIndent (indent float64 ){_ddgg ._gcef =indent };func (_edga *InvoiceAddress )fmtLine (_deff ,_bfbgg string ,_ceca bool )string {if _ceca {_bfbgg ="";};return _b .Sprintf ("\u0025\u0073\u0025s\u000a",_bfbgg ,_deff );};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dgfe *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _dgfe ._efad [0],_dgfe ._efad [1]};

// SetBorderWidth sets the border width.
func (_bbbb *Rectangle )SetBorderWidth (bw float64 ){_bbbb ._daba =bw };func (_bbfa rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _bbfa ._gdbe ,_bbfa ._ddcc ,_bbfa ._def ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetBorder sets the cell's border style.
func (_bfgb *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_bfgb ._fcdfc =CellBorderStyleSingle ;_bfgb ._gdg =width ;_bfgb ._gfcca =CellBorderStyleSingle ;_bfgb ._dafb =width ;_bfgb ._dcaad =CellBorderStyleSingle ;_bfgb ._dbfbf =width ;_bfgb ._bbea =CellBorderStyleSingle ;_bfgb ._afbbbe =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_bfgb ._fcdfc =CellBorderStyleDouble ;_bfgb ._gdg =width ;_bfgb ._gfcca =CellBorderStyleDouble ;_bfgb ._dafb =width ;_bfgb ._dcaad =CellBorderStyleDouble ;_bfgb ._dbfbf =width ;_bfgb ._bbea =CellBorderStyleDouble ;_bfgb ._afbbbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_bfgb ._fcdfc =style ;_bfgb ._gdg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_bfgb ._gfcca =style ;_bfgb ._dafb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_bfgb ._dcaad =style ;_bfgb ._dbfbf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_bfgb ._bbea =style ;_bfgb ._afbbbe =width ;};};

// SetMargins sets the margins TOC line.
func (_ebff *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_ebff ._egfb =left ;_beef :=&_ebff ._agddae ._bbgga ;_beef ._bfca =_ebff ._egfb +float64 (_ebff ._gcgd -1)*_ebff ._cgdb ;_beef ._dbca =right ;_beef ._agbf =top ;_beef ._cee =bottom ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// GetRowHeight returns the height of the specified row.
func (_gafd *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_gafd ._caceb ){return 0,_de .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _gafd ._caceb [row -1],nil ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};func (_beggb *StyledParagraph )getTextHeight ()float64 {var _aeeg float64 ;for _ ,_ffcd :=range _beggb ._caca {_cecaa :=_ffcd .Style .FontSize *_beggb ._gcgaf ;if _cecaa > _aeeg {_aeeg =_cecaa ;};};return _aeeg ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_aaae *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_aaae ._dcaf ._bfca =left ;_aaae ._dcaf ._dbca =right ;_aaae ._dcaf ._agbf =top ;_aaae ._dcaf ._cee =bottom ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_bfac *TableCell )SetBorderLineStyle (style _eb .LineStyle ){_bfac ._dbaf =style };

// AddSection adds a new content section at the end of the invoice.
func (_gfba *Invoice )AddSection (title ,content string ){_gfba ._begg =append (_gfba ._begg ,[2]string {title ,content });};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_caga *Invoice )NoteStyle ()TextStyle {return _caga ._bcdf };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_dgfd float64 ;_cdae float64 ;_efa float64 ;_dee float64 ;_adcg *_da .PdfColorDeviceRGB ;_cgfa *_da .PdfColorDeviceRGB ;_fgeff float64 ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Width returns the cell's width based on the input draw context.
func (_febdc *TableCell )Width (ctx DrawContext )float64 {_cdcb :=float64 (0.0);for _acga :=0;_acga < _febdc ._ddedg ;_acga ++{_cdcb +=_febdc ._baaf ._cgcgb [_febdc ._dbaad +_acga -1];};_eaeag :=ctx .Width *_cdcb ;return _eaeag ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_bddd *TOC )SetLineSeparatorStyle (style TextStyle ){_bddd ._cacae =style };

// SetBorderColor sets the border color.
func (_fgce *PolyBezierCurve )SetBorderColor (color Color ){_fgce ._dcdc .BorderColor =_da .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_aegg *Paragraph )SetColor (col Color ){_cdcf :=_da .NewPdfColorDeviceRGB (col .ToRGB ());_aegg ._dcfg =*_cdcf ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_dgedd *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_dbcdc :=&_dgedd ._agddae ._bbgga ;return _dgedd ._egfb ,_dbcdc ._dbca ,_dbcdc ._agbf ,_dbcdc ._cee ;};

// SkipRows skips over a specified number of rows in the table.
func (_ffaaf *Table )SkipRows (num int ){_dafbf :=num *_ffaaf ._gfbe -1;if _dafbf < 0{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ffaaf ._fbfgf +=_dafbf ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_affg *Creator )Draw (d Drawable )error {if _affg .getActivePage ()==nil {_affg .NewPage ();};_edd ,_fcg ,_caa :=d .GeneratePageBlocks (_affg ._acf );if _caa !=nil {return _caa ;};for _cgba ,_dcdg :=range _edd {if _cgba > 0{_affg .NewPage ();};_ccc :=_affg .getActivePage ();if _aebdc ,_abea :=_affg ._eacd [_ccc ];_abea {if _gbcg :=_aebdc .mergeBlocks (_dcdg );_gbcg !=nil {return _gbcg ;};if _gfca :=_egb (_dcdg ._fa ,_aebdc ._fa );_gfca !=nil {return _gfca ;};}else {_affg ._eacd [_ccc ]=_dcdg ;};};_affg ._acf .X =_fcg .X ;_affg ._acf .Y =_fcg .Y ;_affg ._acf .Height =_fcg .PageHeight -_fcg .Y -_fcg .Margins ._cee ;return nil ;};func (_cfbe *Creator )newPage ()*_da .PdfPage {_abcd :=_da .NewPdfPage ();_agad :=_cfbe ._bfb [0];_dabc :=_cfbe ._bfb [1];_agag :=_da .PdfRectangle {Llx :0,Lly :0,Urx :_agad ,Ury :_dabc };_abcd .MediaBox =&_agag ;_cfbe ._gagca =_agad ;_cfbe ._gddb =_dabc ;_cfbe .initContext ();return _abcd ;};func (_dagd *StyledParagraph )getMaxLineWidth ()float64 {if _dagd ._cff ==nil ||len (_dagd ._cff )==0{_dagd .wrapText ();};var _abag float64 ;for _ ,_eddae :=range _dagd ._cff {_befbd :=_dagd .getTextLineWidth (_eddae );if _befbd > _abag {_abag =_befbd ;};};return _abag ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};func _acgb (_fbac *Table ,_geffd DrawContext )([]*Block ,DrawContext ,error ){var _aaed []*Block ;_ebed :=NewBlock (_geffd .PageWidth ,_geffd .PageHeight );_gbfcb :=_geffd ;if _fbac ._cffgd .isAbsolute (){_geffd .X =_fbac ._ccde ;_geffd .Y =_fbac ._ebfgbc ;}else {_geffd .X +=_fbac ._cebc ._bfca ;_geffd .Y +=_fbac ._cebc ._agbf ;_geffd .Width -=_fbac ._cebc ._bfca +_fbac ._cebc ._dbca ;_geffd .Height -=_fbac ._cebc ._cee +_fbac ._cebc ._agbf ;};_egab :=_geffd .Width ;_cdffg :=_geffd .X ;_fag :=_geffd .Y ;_geffd .Height =_geffd .PageHeight -_geffd .Y -_geffd .Margins ._cee ;_addg :=_geffd .Height ;_dgdb :=0;_ddda ,_ecgeb :=-1,-1;for _fafcc ,_gbagc :=range _fbac ._adceb {_dcfgg :=_gbagc .width (_fbac ._cgcgb ,_egab );if _fbac ._egfdd {if _gbagc ._gggcc >=_fbac ._bcce &&_gbagc ._gggcc <=_fbac ._fccf {if _ddda < 0{_ddda =_fafcc ;};_ecgeb =_fafcc ;};};_ebgf :=_fbac ._caceb [_gbagc ._gggcc +_gbagc ._cddd -2];if _ddfa :=_gbagc .height (_dcfgg );_ddfa > _ebgf {_fbac ._caceb [_gbagc ._gggcc +_gbagc ._cddd -2]=_ddfa ;};};var (_eccef bool ;_edgaf int ;_aacf int ;_dfb bool ;_fbff int ;_cabdb error ;);for _decfa :=0;_decfa < len (_fbac ._adceb );_decfa ++{_cfbg :=_fbac ._adceb [_decfa ];_bebcb :=_cfbg .width (_fbac ._cgcgb ,_egab );_fcbdd :=float64 (0.0);for _gfeb :=0;_gfeb < _cfbg ._dbaad -1;_gfeb ++{_fcbdd +=_fbac ._cgcgb [_gfeb ]*_egab ;};_addaf :=float64 (0.0);for _geec :=_dgdb ;_geec < _cfbg ._gggcc -1;_geec ++{_addaf +=_fbac ._caceb [_geec ];};_geffd .Height =_addg -_addaf ;_ggff :=float64 (0.0);for _aecb :=0;_aecb < _cfbg ._cddd ;_aecb ++{_ggff +=_fbac ._caceb [_cfbg ._gggcc +_aecb -1];};_ffec :=_dfb &&_cfbg ._gggcc !=_fbff ;_fbff =_cfbg ._gggcc ;if _ffec ||_ggff > _geffd .Height {if _fbac ._ecab &&!_dfb {_dfb ,_cabdb =_fbac .wrapRow (_decfa ,_geffd ,_egab );if _cabdb !=nil {return nil ,_geffd ,_cabdb ;};if _dfb {_decfa --;continue ;};};_aaed =append (_aaed ,_ebed );_ebed =NewBlock (_geffd .PageWidth ,_geffd .PageHeight );_cdffg =_geffd .Margins ._bfca ;_fag =_geffd .Margins ._agbf ;_geffd .Height =_geffd .PageHeight -_geffd .Margins ._agbf -_geffd .Margins ._cee ;_geffd .Page ++;_addg =_geffd .Height ;_dgdb =_cfbg ._gggcc -1;_addaf =0;_dfb =false ;if _fbac ._egfdd &&_ddda >=0{_edgaf =_decfa ;_decfa =_ddda -1;_aacf =_dgdb ;_dgdb =_fbac ._bcce -1;_eccef =true ;continue ;};if _ffec {_decfa --;continue ;};};_geffd .Width =_bebcb ;_geffd .X =_cdffg +_fcbdd ;_geffd .Y =_fag +_addaf ;_ddfb :=_baf (_geffd .X ,_geffd .Y ,_bebcb ,_ggff );if _cfbg ._bbfde !=nil {_cgcd :=_cfbg ._bbfde .R ();_efefc :=_cfbg ._bbfde .G ();_ccdd :=_cfbg ._bbfde .B ();_ddfb .SetFillColor (ColorRGBFromArithmetic (_cgcd ,_efefc ,_ccdd ));};_ddfb .LineStyle =_cfbg ._dbaf ;_ddfb ._ecce =_cfbg ._fcdfc ;_ddfb ._gcdb =_cfbg ._dcaad ;_ddfb ._edc =_cfbg ._bbea ;_ddfb ._bcg =_cfbg ._gfcca ;if _cfbg ._dcec !=nil {_ddfb .SetColorLeft (ColorRGBFromArithmetic (_cfbg ._dcec .R (),_cfbg ._dcec .G (),_cfbg ._dcec .B ()));};if _cfbg ._gffe !=nil {_ddfb .SetColorBottom (ColorRGBFromArithmetic (_cfbg ._gffe .R (),_cfbg ._gffe .G (),_cfbg ._gffe .B ()));};if _cfbg ._bgbd !=nil {_ddfb .SetColorRight (ColorRGBFromArithmetic (_cfbg ._bgbd .R (),_cfbg ._bgbd .G (),_cfbg ._bgbd .B ()));};if _cfbg ._febae !=nil {_ddfb .SetColorTop (ColorRGBFromArithmetic (_cfbg ._febae .R (),_cfbg ._febae .G (),_cfbg ._febae .B ()));};_ddfb .SetWidthBottom (_cfbg ._dafb );_ddfb .SetWidthLeft (_cfbg ._gdg );_ddfb .SetWidthRight (_cfbg ._dbfbf );_ddfb .SetWidthTop (_cfbg ._afbbbe );_caag :=_ebed .Draw (_ddfb );if _caag !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_caag );};if _cfbg ._abcfe !=nil {_cafgc :=_cfbg ._abcfe .Width ();_fecc :=_cfbg ._abcfe .Height ();_baeg :=0.0;switch _edgef :=_cfbg ._abcfe .(type ){case *Paragraph :if _edgef ._agbb {_cafgc =_edgef .getMaxLineWidth ()/1000.0;};_cafgc +=_edgef ._gffg ._bfca +_edgef ._gffg ._dbca ;_fecc +=_edgef ._gffg ._agbf +_edgef ._gffg ._cee ;case *StyledParagraph :if _edgef ._afgdg {_cafgc =_edgef .getMaxLineWidth ()/1000.0;};_cfbf ,_egaga :=_edgef .getLineHeight (0);if len (_edgef ._cff )==1{_fecc =_cfbf ;}else {_fecc =_fecc -_egaga +_cfbf ;};_baeg =_cfbf -_egaga ;switch _cfbg ._feccc {case CellVerticalAlignmentTop :_baeg +=_cfbf *0.5;case CellVerticalAlignmentBottom :_baeg -=_cfbf *0.5;};_cafgc +=_edgef ._bbgga ._bfca +_edgef ._bbgga ._dbca ;_fecc +=_edgef ._bbgga ._agbf +_edgef ._bbgga ._cee ;case *Table :_cafgc =_bebcb ;case *List :_cafgc =_bebcb ;};switch _cfbg ._egagb {case CellHorizontalAlignmentLeft :_geffd .X +=_cfbg ._gcef ;_geffd .Width -=_cfbg ._gcef ;case CellHorizontalAlignmentCenter :if _badc :=_bebcb -_cafgc ;_badc > 0{_geffd .X +=_badc /2;_geffd .Width -=_badc /2;};case CellHorizontalAlignmentRight :if _bebcb > _cafgc {_geffd .X =_geffd .X +_bebcb -_cafgc -_cfbg ._gcef ;_geffd .Width -=_cfbg ._gcef ;};};_geffd .Y +=_baeg ;switch _cfbg ._feccc {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _gfef :=_ggff -_fecc ;_gfef > 0{_geffd .Y +=_gfef /2;_geffd .Height -=_gfef /2;};case CellVerticalAlignmentBottom :if _ggff > _fecc {_geffd .Y =_geffd .Y +_ggff -_fecc ;_geffd .Height =_ggff ;};};_dccd :=_ebed .DrawWithContext (_cfbg ._abcfe ,_geffd );if _dccd !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dccd );};_geffd .Y -=_baeg ;};_geffd .Y +=_ggff ;_geffd .Height -=_ggff ;if _eccef &&_decfa +1> _ecgeb {_fag +=_addaf +_ggff ;_addg -=_ggff +_addaf ;_dgdb =_aacf ;_decfa =_edgaf -1;_eccef =false ;};};_aaed =append (_aaed ,_ebed );if _fbac ._cffgd .isAbsolute (){return _aaed ,_gbfcb ,nil ;};_geffd .X =_gbfcb .X ;_geffd .Width =_gbfcb .Width ;_geffd .Y +=_fbac ._cebc ._cee ;_geffd .Height -=_fbac ._cebc ._cee ;return _aaed ,_geffd ,nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_ccbe *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_aace :=NewTextChunk (text ,_ccbe ._dgcgc );_aace ._accfg =_ace (page -1,x ,y ,zoom );return _ccbe .appendChunk (_aace );};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_ddcd *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _deac (x ,y ,width ,height );};

// SetFontSize sets the font size in document units (points).
func (_egea *Paragraph )SetFontSize (fontSize float64 ){_egea ._agge =fontSize };

// SetOpacity sets opacity for Image.
func (_fbcf *Image )SetOpacity (opacity float64 ){_fbcf ._ddcb =opacity };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_abaa []_eb .CubicBezierCurve ;FillEnabled bool ;_fae *_da .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_eeea *_da .PdfColorDeviceRGB ;};

// Indent returns the left offset of the list when nested into another list.
func (_agca *List )Indent ()float64 {return _agca ._fdbd };

// SetAngle sets the rotation angle in degrees.
func (_fd *Block )SetAngle (angleDeg float64 ){_fd ._ee =angleDeg };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func _eage (_fgcb [][]_eb .Point )*Polygon {return &Polygon {_cced :&_eb .Polygon {Points :_fgcb },_abgd :1.0,_gdac :1.0};};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_adcbc *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _adcbc ._aggg [0],_adcbc ._aggg [1]};

// GetMargins returns the left, right, top, bottom Margins.
func (_ggdbe *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ggdbe ._cebc ._bfca ,_ggdbe ._cebc ._dbca ,_ggdbe ._cebc ._agbf ,_ggdbe ._cebc ._cee ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_gddd *Division )Height ()float64 {var _dgcf float64 ;for _ ,_edbd :=range _gddd ._caed {switch _cafcd :=_edbd .(type ){case *Paragraph :_dgcf +=_cafcd .Height ()+_cafcd ._gffg ._agbf +_cafcd ._gffg ._cee ;case *StyledParagraph :_dgcf +=_cafcd .Height ()+_cafcd ._bbgga ._agbf +_cafcd ._bbgga ._cee ;default:_dgcf +=_cafcd .Height ();};};return _dgcf ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_dbaa *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _dabf (x1 ,y1 ,x2 ,y2 )};

// GeneratePageBlocks draws the curve onto page blocks.
func (_afcd *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eecc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _bdgg []string ;_bdgg =append (_bdgg ,_b .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_afcd ._cgcg ));_bdgg =append (_bdgg ,_b .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_afcd ._cbbd [0],_afcd ._cbbd [1],_afcd ._cbbd [2]));_bdgg =append (_bdgg ,_b .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_afcd ._fdce ,ctx .PageHeight -_afcd ._ecge ));_bdgg =append (_bdgg ,_b .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_afcd ._fcb ,ctx .PageHeight -_afcd ._aaaeb ,_afcd ._ggeb ,ctx .PageHeight -_afcd ._fcdg ));_bbgd :=_eecc .addContentsByString (_e .Join (_bdgg ,"\u000a"));if _bbgd !=nil {return nil ,ctx ,_bbgd ;};return []*Block {_eecc },ctx ,nil ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_eae *Block )SetPos (x ,y float64 ){_eae ._be =_gcda ;_eae ._bf =x ;_eae ._bfd =y };func _baf (_efg ,_ggc ,_ccg ,_fbb float64 )*border {_ead :=&border {};_ead ._edf =_efg ;_ead ._gcac =_ggc ;_ead ._acbb =_ccg ;_ead ._gdc =_fbb ;_ead ._fda =_da .NewPdfColorDeviceRGB (0,0,0);_ead ._aebd =_da .NewPdfColorDeviceRGB (0,0,0);_ead ._dcg =_da .NewPdfColorDeviceRGB (0,0,0);_ead ._gbag =_da .NewPdfColorDeviceRGB (0,0,0);_ead ._ecbd =0;_ead ._egc =0;_ead ._ece =0;_ead ._dfe =0;_ead .LineStyle =_eb .LineStyleSolid ;return _ead ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_fbbd *Creator )MoveTo (x ,y float64 ){_fbbd ._acf .X =x ;_fbbd ._acf .Y =y };

// Width returns Image's document width.
func (_ddd *Image )Width ()float64 {return _ddd ._cfdf };func (_dedf *TextChunk )clone ()*TextChunk {_ffaf :=*_dedf ;_ffaf ._accfg =_edgb (_dedf ._accfg );return &_ffaf ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_adgc *Creator )DrawFooter (drawFooterFunc func (_aecg *Block ,_gcf FooterFunctionArgs )){_adgc ._cgb =drawFooterFunc ;};

// Cols returns the total number of columns the table has.
func (_bage *Table )Cols ()int {return _bage ._gfbe };

// Context returns the current drawing context.
func (_caff *Creator )Context ()DrawContext {return _caff ._acf };

// SetStyleBottom sets border style for bottom side.
func (_aag *border )SetStyleBottom (style CellBorderStyle ){_aag ._bcg =style };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_agadg *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_aad :=[2]*InvoiceCell {_agadg .newCell (description ,_agadg ._efba ),_agadg .newCell (value ,_agadg ._efba )};_agadg ._gdfd =append (_agadg ._gdfd ,_aad );return _aad [0],_aad [1];};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_dde *Creator )EnableFontSubsetting (font *_da .PdfFont ){_dde ._gdcd =append (_dde ._gdcd ,font )};

// SetMargins sets the margins of the paragraph.
func (_ebbe *List )SetMargins (left ,right ,top ,bottom float64 ){_ebbe ._cccf ._bfca =left ;_ebbe ._cccf ._dbca =right ;_ebbe ._cccf ._agbf =top ;_ebbe ._cccf ._cee =bottom ;};func _efbf (_gace string )(*Image ,error ){_fac ,_eaad :=_g .Open (_gace );if _eaad !=nil {return nil ,_eaad ;};defer _fac .Close ();_ggcg ,_eaad :=_da .ImageHandling .Read (_fac );if _eaad !=nil {_bg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eaad );return nil ,_eaad ;};return _feaf (_ggcg );};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_aeae *Table )SetPos (x ,y float64 ){_aeae ._cffgd =_gcda ;_aeae ._ccde =x ;_aeae ._ebfgbc =y };

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ggbc *Invoice )InfoLines ()[][2]*InvoiceCell {_cdgb :=[][2]*InvoiceCell {_ggbc ._aggg ,_ggbc ._fdgea ,_ggbc ._fgd };return append (_cdgb ,_ggbc ._gdfd ...);};

// CreateTableOfContents sets a function to generate table of contents.
func (_fdfd *Creator )CreateTableOfContents (genTOCFunc func (_dgcd *TOC )error ){_fdfd ._efbe =genTOCFunc ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_ddff *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbcfc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egbgb ,_fbag :=_dbcfc .setOpacity (_ddff ._cgge ,_ddff ._cgge );if _fbag !=nil {return nil ,ctx ,_fbag ;};_gfecc :=_ddff ._adbe .Points ;for _bcgge :=range _gfecc {_gacb :=&_gfecc [_bcgge ];_gacb .Y =ctx .PageHeight -_gacb .Y ;};_agfb ,_ ,_fbag :=_ddff ._adbe .Draw (_egbgb );if _fbag !=nil {return nil ,ctx ,_fbag ;};if _fbag =_dbcfc .addContentsByString (string (_agfb ));_fbag !=nil {return nil ,ctx ,_fbag ;};return []*Block {_dbcfc },ctx ,nil ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eefge *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _eefge ._fdgea [0],_eefge ._fdgea [1]};

// SetBorderOpacity sets the border opacity.
func (_gegc *Polygon )SetBorderOpacity (opacity float64 ){_gegc ._gdac =opacity };

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_gege *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _eddd (xc ,yc ,width ,height );};func (_gd *Block )transform (_agb _gc .Matrix ){_fga :=_ab .NewContentCreator ().Add_cm (_agb [0],_agb [1],_agb [3],_agb [4],_agb [6],_agb [7]).Operations ();*_gd ._f =append (*_fga ,*_gd ._f ...);_gd ._f .WrapIfNeeded ();};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_gefcc *Line )SetColor (col Color ){_gefcc ._fbcb =_da .NewPdfColorDeviceRGB (col .ToRGB ())};func _dedb (_dbg _dd .Image )(*Image ,error ){_gfbc ,_cacfc :=_da .ImageHandling .NewImageFromGoImage (_dbg );if _cacfc !=nil {return nil ,_cacfc ;};return _feaf (_gfbc );};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_gggg *Creator )SetOptimizer (optimizer _da .Optimizer ){_gggg ._gfc =optimizer };

// SetMargins sets the Table's left, right, top, bottom margins.
func (_cfdc *Table )SetMargins (left ,right ,top ,bottom float64 ){_cfdc ._cebc ._bfca =left ;_cfdc ._cebc ._dbca =right ;_cfdc ._cebc ._agbf =top ;_cfdc ._cebc ._cee =bottom ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_dfaa *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbfe :=ctx ;if _dfaa ._beca .isRelative (){ctx .X +=_dfaa ._fdc ._bfca ;ctx .Y +=_dfaa ._fdc ._agbf ;ctx .Width -=_dfaa ._fdc ._bfca +_dfaa ._fdc ._dbca ;ctx .Height -=_dfaa ._fdc ._agbf ;};_deba ,_gdb ,_aafa :=_dfaa ._ggfb .GeneratePageBlocks (ctx );if _aafa !=nil {return _deba ,ctx ,_aafa ;};ctx =_gdb ;_feba :=ctx .X ;_ebfa :=ctx .Y -_dfaa ._ggfb .Height ();_fbfg :=int64 (ctx .Page );_ecd :=_dfaa .headingNumber ();_dcadd :=_dfaa .headingText ();if _dfaa ._aeba {_gade :=_dfaa ._gbee .Add (_ecd ,_dfaa ._daad ,_cb .FormatInt (_fbfg ,10),_dfaa ._fdec );if _dfaa ._gbee ._eabe {_gade .SetLink (_fbfg ,_feba ,_ebfa );};};if _dfaa ._efee ==nil {_dfaa ._efee =_da .NewOutlineItem (_dcadd ,_da .NewOutlineDest (_fbfg -1,_feba ,_ebfa ));if _dfaa ._ebea !=nil {_dfaa ._ebea ._efee .Add (_dfaa ._efee );}else {_dfaa ._dcgb .Add (_dfaa ._efee );};}else {_adg :=&_dfaa ._efee .Dest ;_adg .Page =_fbfg -1;_adg .X =_feba ;_adg .Y =_ebfa ;};for _ ,_bdb :=range _dfaa ._fgf {_aeac ,_ceg ,_afd :=_bdb .GeneratePageBlocks (ctx );if _afd !=nil {return _deba ,ctx ,_afd ;};if len (_aeac )< 1{continue ;};_deba [len (_deba )-1].mergeBlocks (_aeac [0]);_deba =append (_deba ,_aeac [1:]...);ctx =_ceg ;};if _dfaa ._beca .isRelative (){ctx .X =_bbfe .X ;};if _dfaa ._beca .isAbsolute (){return _deba ,_bbfe ,nil ;};return _deba ,ctx ,nil ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_cced *_eb .Polygon ;_abgd float64 ;_gdac float64 ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_cgeac *TOC )SetLineSeparator (separator string ){_cgeac ._fedcf =separator };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_bbfde *_da .PdfColorDeviceRGB ;_dbaf _eb .LineStyle ;_fcdfc CellBorderStyle ;_dcec *_da .PdfColorDeviceRGB ;_gdg float64 ;_gfcca CellBorderStyle ;_gffe *_da .PdfColorDeviceRGB ;_dafb float64 ;_dcaad CellBorderStyle ;_bgbd *_da .PdfColorDeviceRGB ;_dbfbf float64 ;_bbea CellBorderStyle ;_febae *_da .PdfColorDeviceRGB ;_afbbbe float64 ;_gggcc ,_dbaad int ;_cddd int ;_ddedg int ;_abcfe VectorDrawable ;_egagb CellHorizontalAlignment ;_feccc CellVerticalAlignment ;_gcef float64 ;_baaf *Table ;};func _eegc (_cbba []byte )(*Image ,error ){_eadd :=_c .NewReader (_cbba );_debe ,_cdba :=_da .ImageHandling .Read (_eadd );if _cdba !=nil {_bg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cdba );return nil ,_cdba ;};return _feaf (_debe );};func _fgfcd (_cabg TextStyle )*List {return &List {_cgfe :TextChunk {Text :"\u2022\u0020",Style :_cabg },_fdbd :0,_fabc :true ,_dgdd :_abbd ,_gebf :_cabg };};