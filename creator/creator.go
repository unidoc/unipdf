//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_a "bytes";_gf "encoding/xml";_b "errors";_f "fmt";_fb "github.com/gorilla/i18n/linebreak";_ag "github.com/unidoc/unichart/render";_ce "github.com/unidoc/unipdf/v3/common";_ae "github.com/unidoc/unipdf/v3/contentstream";_ad "github.com/unidoc/unipdf/v3/contentstream/draw";
_e "github.com/unidoc/unipdf/v3/core";_de "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_fbb "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_fc "github.com/unidoc/unipdf/v3/internal/license";_dc "github.com/unidoc/unipdf/v3/internal/transform";
_aa "github.com/unidoc/unipdf/v3/model";_bb "golang.org/x/text/unicode/bidi";_be "image";_bd "io";_bcb "math";_d "os";_c "regexp";_ga "sort";_gcc "strconv";_gc "strings";_bc "text/template";_dd "unicode";);func _gcf (_aef ,_dab ,_bfd ,_eaa float64 )*border {_ceb :=&border {};
_ceb ._accf =_aef ;_ceb ._eec =_dab ;_ceb ._dff =_bfd ;_ceb ._gfb =_eaa ;_ceb ._bgf =ColorBlack ;_ceb ._gfe =ColorBlack ;_ceb ._cdca =ColorBlack ;_ceb ._bgac =ColorBlack ;_ceb ._dbg =0;_ceb ._gfg =0;_ceb ._edf =0;_ceb ._dfa =0;_ceb .LineStyle =_ad .LineStyleSolid ;
return _ceb ;};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_bgdb *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ebgf []*Block ;_bbaa =NewBlock (ctx .PageWidth ,ctx .PageHeight );_dgeb =ctx ;_fadb ,_dege =_bgdb ._ccfd ,ctx .PageHeight -_bgdb ._fbbgd ;_gaga ,_afcg =_bgdb ._fede ,ctx .PageHeight -_bgdb ._bdea ;
);_dbgg :=_bgdb ._baga .IsRelative ();if _dbgg {ctx .X +=_bgdb ._fgbea .Left ;ctx .Y +=_bgdb ._fgbea .Top ;ctx .Width -=_bgdb ._fgbea .Left +_bgdb ._fgbea .Right ;ctx .Height -=_bgdb ._fgbea .Top +_bgdb ._fgbea .Bottom ;_fadb ,_dege ,_gaga ,_afcg =_bgdb .computeCoords (ctx );
if _bgdb .Height ()> ctx .Height {_ebgf =append (_ebgf ,_bbaa );_bbaa =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gdg :=ctx ;_gdg .Y =ctx .Margins .Top +_bgdb ._fgbea .Top ;_gdg .X =ctx .Margins .Left +_bgdb ._fgbea .Left ;_gdg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bgdb ._fgbea .Top -_bgdb ._fgbea .Bottom ;
_gdg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bgdb ._fgbea .Left -_bgdb ._fgbea .Right ;ctx =_gdg ;_fadb ,_dege ,_gaga ,_afcg =_bgdb .computeCoords (ctx );};};_geda :=_ad .BasicLine {X1 :_fadb ,Y1 :_dege ,X2 :_gaga ,Y2 :_afcg ,LineColor :_adb (_bgdb ._daba ),Opacity :_bgdb ._bcfb ,LineWidth :_bgdb ._cdae ,LineStyle :_bgdb ._dfbd ,DashArray :_bgdb ._feeec ,DashPhase :_bgdb ._dbec };
_bfgd ,_abaf :=_bbaa .setOpacity (1.0,_bgdb ._bcfb );if _abaf !=nil {return nil ,ctx ,_abaf ;};_efbc ,_ ,_abaf :=_geda .Draw (_bfgd );if _abaf !=nil {return nil ,ctx ,_abaf ;};if _abaf =_bbaa .addContentsByString (string (_efbc ));_abaf !=nil {return nil ,ctx ,_abaf ;
};if _dbgg {ctx .X =_dgeb .X ;ctx .Width =_dgeb .Width ;_afd :=_bgdb .Height ();ctx .Y +=_afd +_bgdb ._fgbea .Bottom ;ctx .Height -=_afd ;}else {ctx =_dgeb ;};_ebgf =append (_ebgf ,_bbaa );return _ebgf ,ctx ,nil ;};

// Add adds a new line with the default style to the table of contents.
func (_ddcab *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_cafbc :=_ddcab .AddLine (_ccgf (TextChunk {Text :number ,Style :_ddcab ._faff },TextChunk {Text :title ,Style :_ddcab ._bccgdb },TextChunk {Text :page ,Style :_ddcab ._bdcgd },level ,_ddcab ._dace ));
if _cafbc ==nil {return nil ;};_bgbd :=&_ddcab ._ccecf ;_cafbc .SetMargins (_bgbd .Left ,_bgbd .Right ,_bgbd .Top ,_bgbd .Bottom );_cafbc .SetLevelOffset (_ddcab ._geadb );_cafbc .Separator .Text =_ddcab ._egga ;_cafbc .Separator .Style =_ddcab ._gdddd ;
return _cafbc ;};

// SetFont sets the Paragraph's font.
func (_eedb *Paragraph )SetFont (font *_aa .PdfFont ){_eedb ._gacgc =font };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_egega *Image )ScaleToHeight (h float64 ){_ebee :=_egega ._ddce /_egega ._afea ;_egega ._afea =h ;_egega ._ddce =h *_ebee ;};

// SetColor sets the line color.
func (_aafa *Curve )SetColor (col Color ){_aafa ._acgb =col };func (_fded *LinearShading )shadingModel ()*_aa .PdfShadingType2 {_ecdff :=_ad .NewPoint (_fded ._cbaa .Llx +_fded ._cbaa .Width ()/2,_fded ._cbaa .Lly +_fded ._cbaa .Height ()/2);_abgg :=_ad .NewPoint (_fded ._cbaa .Llx ,_fded ._cbaa .Lly +_fded ._cbaa .Height ()/2).Add (-_ecdff .X ,-_ecdff .Y ).Rotate (_fded ._eadf ).Add (_ecdff .X ,_ecdff .Y );
_abgg =_ad .NewPoint (_bcb .Max (_bcb .Min (_abgg .X ,_fded ._cbaa .Urx ),_fded ._cbaa .Llx ),_bcb .Max (_bcb .Min (_abgg .Y ,_fded ._cbaa .Ury ),_fded ._cbaa .Lly ));_bbcf :=_ad .NewPoint (_fded ._cbaa .Urx ,_fded ._cbaa .Lly +_fded ._cbaa .Height ()/2).Add (-_ecdff .X ,-_ecdff .Y ).Rotate (_fded ._eadf ).Add (_ecdff .X ,_ecdff .Y );
_bbcf =_ad .NewPoint (_bcb .Min (_bcb .Max (_bbcf .X ,_fded ._cbaa .Llx ),_fded ._cbaa .Urx ),_bcb .Min (_bcb .Max (_bbcf .Y ,_fded ._cbaa .Lly ),_fded ._cbaa .Ury ));_abcg :=_aa .NewPdfShadingType2 ();_abcg .PdfShading .ShadingType =_e .MakeInteger (2);
_abcg .PdfShading .ColorSpace =_aa .NewPdfColorspaceDeviceRGB ();_abcg .PdfShading .AntiAlias =_e .MakeBool (_fded ._cgfe ._acef );_abcg .Coords =_e .MakeArrayFromFloats ([]float64 {_abgg .X ,_abgg .Y ,_bbcf .X ,_bbcf .Y });_abcg .Extend =_e .MakeArray (_e .MakeBool (_fded ._cgfe ._cfddb [0]),_e .MakeBool (_fded ._cgfe ._cfddb [1]));
_abcg .Function =_fded ._cgfe .generatePdfFunctions ();return _abcg ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func (_cdec *Chapter )headingNumber ()string {var _bbf string ;
if _cdec ._bcfg {if _cdec ._aeg !=0{_bbf =_gcc .Itoa (_cdec ._aeg )+"\u002e";};if _cdec ._ade !=nil {_fcd :=_cdec ._ade .headingNumber ();if _fcd !=""{_bbf =_fcd +_bbf ;};};};return _bbf ;};

// Rows returns the total number of rows the table has.
func (_eece *Table )Rows ()int {return _eece ._ccgdf };func _dafa (_aegf ,_faed ,_bcgg ,_bbda float64 )*Line {return &Line {_ccfd :_aegf ,_fbbgd :_faed ,_fede :_bcgg ,_bdea :_bbda ,_daba :ColorBlack ,_bcfb :1.0,_cdae :1.0,_feeec :[]int64 {1,1},_baga :PositionAbsolute };
};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_cbda *_ad .CurvePolygon ;_fae float64 ;_ccgef float64 ;_fbbbb Color ;};func (_fbfaf *templateProcessor )parseChapterHeading (_dcfeb *templateNode )(interface{},error ){if _dcfeb ._fedefc ==nil {_fbfaf .nodeLogError (_dcfeb ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_fgcf ;};_dgbaf ,_agdeg :=_dcfeb ._fedefc ._ebabb .(*Chapter );if !_agdeg {_fbfaf .nodeLogError (_dcfeb ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_dcfeb ._fedefc ._ebabb );
return nil ,_fgcf ;};_accg :=_dgbaf .GetHeading ();if _ ,_bcegf :=_fbfaf .parseParagraph (_dcfeb ,_accg );_bcegf !=nil {return nil ,_bcegf ;};return _accg ,nil ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_edce *Creator )Finalize ()error {if _edce ._ggge {return nil ;};_afeb :=len (_edce ._agfa );_dceef :=0;if _edce ._accb !=nil {_aadg :=*_edce ;_edce ._agfa =nil ;_edce ._caf =nil ;_edce .initContext ();_acfe :=FrontpageFunctionArgs {PageNum :1,TotalPages :_afeb };
_edce ._accb (_acfe );_dceef +=len (_edce ._agfa );_edce ._agfa =_aadg ._agfa ;_edce ._caf =_aadg ._caf ;};if _edce .AddTOC {_edce .initContext ();_edce ._aaa .Page =_dceef +1;if _edce .CustomTOC &&_edce ._gecc !=nil {_dgf :=*_edce ;_edce ._agfa =nil ;
_edce ._caf =nil ;if _edcb :=_edce ._gecc (_edce ._fegf );_edcb !=nil {return _edcb ;};_dceef +=len (_edce ._agfa );_edce ._agfa =_dgf ._agfa ;_edce ._caf =_dgf ._caf ;}else {if _edce ._gecc !=nil {if _cgbe :=_edce ._gecc (_edce ._fegf );_cgbe !=nil {return _cgbe ;
};};_dfc ,_ ,_eea :=_edce ._fegf .GeneratePageBlocks (_edce ._aaa );if _eea !=nil {_ce .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_eea );
return _eea ;};_dceef +=len (_dfc );};_aeea :=_edce ._fegf .Lines ();for _ ,_fcfc :=range _aeea {_dcfd ,_fga :=_gcc .Atoi (_fcfc .Page .Text );if _fga !=nil {continue ;};_fcfc .Page .Text =_gcc .Itoa (_dcfd +_dceef );_fcfc ._gggf +=int64 (_dceef );};};
_fdaeg :=false ;var _deadb []*_aa .PdfPage ;if _edce ._accb !=nil {_cca :=*_edce ;_edce ._agfa =nil ;_edce ._caf =nil ;_gedc :=FrontpageFunctionArgs {PageNum :1,TotalPages :_afeb };_edce ._accb (_gedc );_afeb +=len (_edce ._agfa );_deadb =_edce ._agfa ;
_edce ._agfa =append (_edce ._agfa ,_cca ._agfa ...);_edce ._caf =_cca ._caf ;_fdaeg =true ;};var _bde []*_aa .PdfPage ;if _edce .AddTOC {_edce .initContext ();if _edce .CustomTOC &&_edce ._gecc !=nil {_ddfa :=*_edce ;_edce ._agfa =nil ;_edce ._caf =nil ;
if _gcaf :=_edce ._gecc (_edce ._fegf );_gcaf !=nil {_ce .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_gcaf );return _gcaf ;};_bde =_edce ._agfa ;_afeb +=len (_bde );
_edce ._agfa =_ddfa ._agfa ;_edce ._caf =_ddfa ._caf ;}else {if _edce ._gecc !=nil {if _dgdec :=_edce ._gecc (_edce ._fegf );_dgdec !=nil {_ce .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_dgdec );
return _dgdec ;};};_ebbc ,_ ,_ :=_edce ._fegf .GeneratePageBlocks (_edce ._aaa );for _ ,_aaad :=range _ebbc {_aaad .SetPos (0,0);_afeb ++;_aag :=_edce .newPage ();_bde =append (_bde ,_aag );_edce .setActivePage (_aag );_edce .Draw (_aaad );};};if _fdaeg {_aadd :=_deadb ;
_cea :=_edce ._agfa [len (_deadb ):];_edce ._agfa =append ([]*_aa .PdfPage {},_aadd ...);_edce ._agfa =append (_edce ._agfa ,_bde ...);_edce ._agfa =append (_edce ._agfa ,_cea ...);}else {_edce ._agfa =append (_bde ,_edce ._agfa ...);};};if _edce ._gcdce !=nil &&_edce .AddOutlines {var _ccfa func (_cfbbc *_aa .OutlineItem );
_ccfa =func (_gfbb *_aa .OutlineItem ){_gfbb .Dest .Page +=int64 (_dceef );if _afc :=int (_gfbb .Dest .Page );_afc >=0&&_afc < len (_edce ._agfa ){_gfbb .Dest .PageObj =_edce ._agfa [_afc ].GetPageAsIndirectObject ();}else {_ce .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_afc );
};_gfbb .Dest .Y =_edce ._ccdb -_gfbb .Dest .Y ;_eeg :=_gfbb .Items ();for _ ,_ece :=range _eeg {_ccfa (_ece );};};_edgbf :=_edce ._gcdce .Items ();for _ ,_ffg :=range _edgbf {_ccfa (_ffg );};if _edce .AddTOC {var _ebef int ;if _fdaeg {_ebef =len (_deadb );
};_eaaa :=_aa .NewOutlineDest (int64 (_ebef ),0,_edce ._ccdb );if _ebef >=0&&_ebef < len (_edce ._agfa ){_eaaa .PageObj =_edce ._agfa [_ebef ].GetPageAsIndirectObject ();}else {_ce .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ebef );
};_edce ._gcdce .Insert (0,_aa .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_eaaa ));};};for _fgbe ,_fbbg :=range _edce ._agfa {_edce .setActivePage (_fbbg );if _edce ._aeee !=nil {_fag ,_aacd ,_bbac :=_fbbg .Size ();
if _bbac !=nil {return _bbac ;};_aefa :=PageFinalizeFunctionArgs {PageNum :_fgbe +1,PageWidth :_fag ,PageHeight :_aacd ,TOCPages :len (_bde ),TotalPages :_afeb };if _ebc :=_edce ._aeee (_aefa );_ebc !=nil {_ce .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_ebc );
return _ebc ;};};if _edce ._cbag !=nil {_gadb :=NewBlock (_edce ._fddd ,_edce ._bag .Top );_fage :=HeaderFunctionArgs {PageNum :_fgbe +1,TotalPages :_afeb };_edce ._cbag (_gadb ,_fage );_gadb .SetPos (0,0);if _ebab :=_edce .Draw (_gadb );_ebab !=nil {_ce .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_ebab );
return _ebab ;};};if _edce ._ccba !=nil {_bcfd :=NewBlock (_edce ._fddd ,_edce ._bag .Bottom );_ceab :=FooterFunctionArgs {PageNum :_fgbe +1,TotalPages :_afeb };_edce ._ccba (_bcfd ,_ceab );_bcfd .SetPos (0,_edce ._ccdb -_bcfd ._cb );if _aagd :=_edce .Draw (_bcfd );
_aagd !=nil {_ce .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_aagd );return _aagd ;};};_bgb ,_bcce :=_edce ._bdae [_fbbg ];if _dbaa ,_debb :=_edce ._abfg [_fbbg ];
_debb {if _bcce {_bgb .transformBlock (_dbaa );};if _fcge :=_dbaa .drawToPage (_fbbg );_fcge !=nil {_ce .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_fgbe +1,_fcge );
return _fcge ;};};if _bcce {if _dggc :=_bgb .transformPage (_fbbg );_dggc !=nil {_ce .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_dggc );
return _dggc ;};};};_edce ._ggge =true ;return nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fgfe *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcedd :=ctx ;_gbdbb ,ctx ,_gegce :=_fgfe ._cbggb .GeneratePageBlocks (ctx );if _gegce !=nil {return _gbdbb ,ctx ,_gegce ;};for _ ,_caddg :=range _fgfe ._cdabg {_cdbga :=_caddg ._gggf ;
if !_fgfe ._ebdf {_caddg ._gggf =0;};_ceafg ,_facae ,_ccdg :=_caddg .GeneratePageBlocks (ctx );_caddg ._gggf =_cdbga ;if _ccdg !=nil {return _gbdbb ,ctx ,_ccdg ;};if len (_ceafg )< 1{continue ;};_gbdbb [len (_gbdbb )-1].mergeBlocks (_ceafg [0]);_gbdbb =append (_gbdbb ,_ceafg [1:]...);
ctx =_facae ;};if _fgfe ._adedd .IsRelative (){ctx .X =_bcedd .X ;};if _fgfe ._adedd .IsAbsolute (){return _gbdbb ,_bcedd ,nil ;};return _gbdbb ,ctx ,nil ;};func (_cf *Block )duplicate ()*Block {_df :=&Block {};*_df =*_cf ;_cdce :=_ae .ContentStreamOperations {};
_cdce =append (_cdce ,*_cf ._aae ...);_df ._aae =&_cdce ;return _df ;};

// NewCurvePolygon creates a new curve polygon.
func (_gbcgf *Creator )NewCurvePolygon (rings [][]_ad .CubicBezierCurve )*CurvePolygon {return _ccfaf (rings );};

// SetStyleRight sets border style for right side.
func (_fdd *border )SetStyleRight (style CellBorderStyle ){_fdd ._ggb =style };

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_agg *Block )DrawTemplate (c *Creator ,r _bd .Reader ,data interface{},options *TemplateOptions )error {return _aecbe (c ,r ,data ,options ,_agg );};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;func (_fagc *Paragraph )getTextLineWidth (_ccea string )float64 {var _abfee float64 ;for _ ,_egee :=range _ccea {if _egee =='\u000A'{continue ;};_gbce ,_ebac :=_fagc ._gacgc .GetRuneMetrics (_egee );if !_ebac {_ce .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_egee ,_egee );
return -1;};_abfee +=_fagc ._ffbe *_gbce .Wx ;};return _abfee ;};

// SetText sets the text content of the Paragraph.
func (_fceb *Paragraph )SetText (text string ){_fceb ._adad =text };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_ddbbg *Invoice )TotalLines ()[][2]*InvoiceCell {_fcbg :=[][2]*InvoiceCell {_ddbbg ._febf };_fcbg =append (_fcbg ,_ddbbg ._gfaa ...);return append (_fcbg ,_ddbbg ._fcbe );};

// Color returns the color of the line.
func (_dgec *Line )Color ()Color {return _dgec ._daba };

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_adaed *Division )SetPadding (left ,right ,top ,bottom float64 ){_adaed ._fgfc .Left =left ;_adaed ._fgfc .Right =right ;_adaed ._fgfc .Top =top ;_adaed ._fgfc .Bottom =bottom ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_ddge float64 ;_gead float64 ;_dbda float64 ;_agfc float64 ;_fbeb Positioning ;_fdgf Color ;_befe float64 ;_aebf Color ;_bcceg float64 ;_gfdfab float64 ;_cbdb float64 ;_agda float64 ;_efde float64 ;_eadce float64 ;_ebgg Margins ;_bcdfc FitMode ;
};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_befa *Creator )NewStyledParagraph ()*StyledParagraph {return _fbfg (_befa .NewTextStyle ())};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_fgba *Division )Width ()float64 {return 0};

// SetMargins sets the margins TOC line.
func (_ebfga *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_ebfga ._fbedc =left ;_abega :=&_ebfga ._eggfe ._gcdca ;_abega .Left =_ebfga ._fbedc +float64 (_ebfga ._edac -1)*_ebfga ._cfeda ;_abega .Right =right ;_abega .Top =top ;_abega .Bottom =bottom ;
};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_eggba *Rectangle )ScaleToHeight (h float64 ){_fcbb :=_eggba ._dbda /_eggba ._agfc ;_eggba ._agfc =h ;_eggba ._dbda =h *_fcbb ;};

// SetSideBorderWidth sets the cell's side border width.
func (_cfabf *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_cfabf ._dbeeb =width ;_cfabf ._edbge =width ;_cfabf ._fggged =width ;_cfabf ._ffdaf =width ;case CellBorderSideTop :_cfabf ._dbeeb =width ;
case CellBorderSideBottom :_cfabf ._edbge =width ;case CellBorderSideLeft :_cfabf ._fggged =width ;case CellBorderSideRight :_cfabf ._ffdaf =width ;};};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_deeg *GraphicSVG )SetPos (x ,y float64 ){_deeg ._eddc =PositionAbsolute ;_deeg ._ggaf =x ;_deeg ._bcac =y ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_dec :_bcb .Max (_bcb .Min (c ,1.0),0.0),_fbfcd :_bcb .Max (_bcb .Min (m ,1.0),0.0),_gbd :_bcb .Max (_bcb .Min (y ,1.0),0.0),_agcb :_bcb .Max (_bcb .Min (k ,1.0),0.0)};};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_gaeb *Image )SetWidth (w float64 ){_gaeb ._ddce =w };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_gedd *Invoice )Sections ()[][2]string {return _gedd ._faeb };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_cccef *LinearShading )SetAntiAlias (enable bool ){_cccef ._cgfe .SetAntiAlias (enable )};func (_fbega *templateProcessor )parseRectangle (_bdce *templateNode )(interface{},error ){_aecec :=_fbega .creator .NewRectangle (0,0,0,0);for _ ,_eaec :=range _bdce ._gcbdb .Attr {_cdacb :=_eaec .Value ;
switch _ededf :=_eaec .Name .Local ;_ededf {case "\u0078":_aecec ._ddge =_fbega .parseFloatAttr (_ededf ,_cdacb );case "\u0079":_aecec ._gead =_fbega .parseFloatAttr (_ededf ,_cdacb );case "\u0077\u0069\u0064t\u0068":_aecec .SetWidth (_fbega .parseFloatAttr (_ededf ,_cdacb ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_aecec .SetHeight (_fbega .parseFloatAttr (_ededf ,_cdacb ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_aecec .SetFillColor (_fbega .parseColorAttr (_ededf ,_cdacb ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_aecec .SetFillOpacity (_fbega .parseFloatAttr (_ededf ,_cdacb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_aecec .SetBorderColor (_fbega .parseColorAttr (_ededf ,_cdacb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_aecec .SetBorderOpacity (_fbega .parseFloatAttr (_ededf ,_cdacb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_aecec .SetBorderWidth (_fbega .parseFloatAttr (_ededf ,_cdacb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_bfgcd ,_dafb ,_bdfgef ,_fgaea :=_fbega .parseBorderRadiusAttr (_ededf ,_cdacb );
_aecec .SetBorderRadius (_bfgcd ,_dafb ,_fgaea ,_bdfgef );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_aecec ._cbdb =_fbega .parseFloatAttr (_ededf ,_cdacb );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_aecec ._agda =_fbega .parseFloatAttr (_ededf ,_cdacb );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_aecec ._efde =_fbega .parseFloatAttr (_ededf ,_cdacb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_aecec ._eadce =_fbega .parseFloatAttr (_ededf ,_cdacb );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_aecec .SetPositioning (_fbega .parsePositioningAttr (_ededf ,_cdacb ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_aecec .SetFitMode (_fbega .parseFitModeAttr (_ededf ,_cdacb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ffee :=_fbega .parseMarginAttr (_ededf ,_cdacb );
_aecec .SetMargins (_ffee .Left ,_ffee .Right ,_ffee .Top ,_ffee .Bottom );default:_fbega .nodeLogDebug (_bdce ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ededf );
};};return _aecec ,nil ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_ccbbg *Rectangle )SetFillOpacity (opacity float64 ){_ccbbg ._befe =opacity };

// Width returns the cell's width based on the input draw context.
func (_aeffba *TableCell )Width (ctx DrawContext )float64 {_abaaf :=float64 (0.0);for _gaecf :=0;_gaecf < _aeffba ._ebbb ;_gaecf ++{_abaaf +=_aeffba ._cccc ._bdbga [_aeffba ._dbbgc +_gaecf -1];};_acfd :=ctx .Width *_abaaf ;return _acfd ;};

// Vertical returns total vertical (top + bottom) margin.
func (_gdf *Margins )Vertical ()float64 {return _gdf .Bottom +_gdf .Top };

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_bccd *Table )MultiCell (rowspan ,colspan int )*TableCell {_bccd ._fdagd ++;_ebgbe :=(_bccd .moveToNextAvailableCell ()-1)%(_bccd ._abdae )+1;_gcdga :=(_bccd ._fdagd -1)/_bccd ._abdae +1;for _gcdga > _bccd ._ccgdf {_bccd ._ccgdf ++;_bccd ._ecdda =append (_bccd ._ecdda ,_bccd ._feae );
};_afaff :=&TableCell {};_afaff ._afefg =_gcdga ;_afaff ._dbbgc =_ebgbe ;_afaff ._bbad =5;_afaff ._dbfa =CellBorderStyleNone ;_afaff ._fegfe =_ad .LineStyleSolid ;_afaff ._cfad =CellHorizontalAlignmentLeft ;_afaff ._dbcg =CellVerticalAlignmentTop ;_afaff ._fggged =0;
_afaff ._edbge =0;_afaff ._ffdaf =0;_afaff ._dbeeb =0;_ffad :=ColorBlack ;_afaff ._dabfg =_ffad ;_afaff ._decc =_ffad ;_afaff ._fgbce =_ffad ;_afaff ._cbdbb =_ffad ;if rowspan < 1{_ce .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_egfe :=_bccd ._ccgdf -(_afaff ._afefg -1);if rowspan > _egfe {_ce .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_egfe );
_bccd ._ccgdf +=rowspan -1;for _acab :=0;_acab <=rowspan -_egfe ;_acab ++{_bccd ._ecdda =append (_bccd ._ecdda ,_bccd ._feae );};};for _edfb :=0;_edfb < colspan &&_ebgbe +_edfb -1< len (_bccd ._adaf );_edfb ++{_bccd ._adaf [_ebgbe +_edfb -1]=rowspan -1;
};_afaff ._dgfd =rowspan ;if colspan < 1{_ce .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_fcgb :=_bccd ._abdae -(_afaff ._dbbgc -1);if colspan > _fcgb {_ce .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_fcgb );
colspan =_fcgb ;};_afaff ._ebbb =colspan ;_bccd ._fdagd +=colspan -1;_bccd ._dfaeg =append (_bccd ._dfaeg ,_afaff );_afaff ._cccc =_bccd ;return _afaff ;};type pageTransformations struct{_fece *_dc .Matrix ;_gdaa bool ;_bdgd bool ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_abbc *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _ccgf (number ,title ,page ,level ,style );};

// SetShowLinks sets visibility of links for the TOC lines.
func (_cfffab *TOC )SetShowLinks (showLinks bool ){_cfffab ._ebdf =showLinks };

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _ggaed (path )};

// SetAnchor set gradient position anchor.
// Default to center.
func (_cacb *RadialShading )SetAnchor (anchor AnchorPoint ){_cacb ._cbad =anchor };func _bcgcb (_cgbg ,_aegb ,_aega ,_abea ,_dbcdc ,_aaf float64 )*Curve {_dabg :=&Curve {};_dabg ._bgggf =_cgbg ;_dabg ._cfda =_aegb ;_dabg ._ccge =_aega ;_dabg ._fbaf =_abea ;
_dabg ._edag =_dbcdc ;_dabg ._dbea =_aaf ;_dabg ._acgb =ColorBlack ;_dabg ._cfed =1.0;return _dabg ;};

// SetWidthBottom sets border width for bottom.
func (_adae *border )SetWidthBottom (bw float64 ){_adae ._gfg =bw };func (_bcdc *templateProcessor )parseTextOverflowAttr (_cffba ,_cagab string )TextOverflow {_ce .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_cffba ,_cagab );
_ddbdd :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_cagab ];return _ddbdd ;};

// SetWidth sets the width of the ellipse.
func (_fged *Ellipse )SetWidth (width float64 ){_fged ._cgec =width };

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_dgdf *Division )Height ()float64 {var _gffa float64 ;for _ ,_bggd :=range _dgdf ._fgaa {switch _aebag :=_bggd .(type ){case marginDrawable :_ ,_ ,_gdag ,_gddd :=_aebag .GetMargins ();_gffa +=_aebag .Height ()+_gdag +_gddd ;default:_gffa +=_aebag .Height ();
};};return _gffa ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_agfa []*_aa .PdfPage ;_abfg map[*_aa .PdfPage ]*Block ;_bdae map[*_aa .PdfPage ]*pageTransformations ;_caf *_aa .PdfPage ;_dafd PageSize ;_aaa DrawContext ;_bag Margins ;_fddd ,_ccdb float64 ;_cce int ;_accb func (_beaf FrontpageFunctionArgs );
_gecc func (_edee *TOC )error ;_cbag func (_bcd *Block ,_befb HeaderFunctionArgs );_ccba func (_gbdd *Block ,_gcdc FooterFunctionArgs );_aeee func (_ccgd PageFinalizeFunctionArgs )error ;_ggba func (_bgfe *_aa .PdfWriter )error ;_ggge bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_fegf *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gcdce *_aa .Outline ;_eca *_aa .PdfOutlineTreeNode ;_bbc *_aa .PdfAcroForm ;_cab _e .PdfObject ;_aga _aa .Optimizer ;_gaee []*_aa .PdfFont ;_edbc *_aa .PdfFont ;_eff *_aa .PdfFont ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_cfbg *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _cfbg ._ccfd ,_cfbg ._fbbgd ,_cfbg ._fede ,_cfbg ._bdea ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_fgdbf []_ad .CubicBezierCurve ;FillEnabled bool ;_dcda Color ;BorderEnabled bool ;BorderWidth float64 ;_aeff Color ;};

// SetBorderWidth sets the border width.
func (_dcbb *CurvePolygon )SetBorderWidth (borderWidth float64 ){_dcbb ._cbda .BorderWidth =borderWidth };

// SetMargins sets the margins of the chart component.
func (_abcd *Chart )SetMargins (left ,right ,top ,bottom float64 ){_abcd ._feeca .Left =left ;_abcd ._feeca .Right =right ;_abcd ._feeca .Top =top ;_abcd ._feeca .Bottom =bottom ;};func _ccbg (_ggfc *templateProcessor ,_aagba *templateNode )(interface{},error ){return _ggfc .parseRectangle (_aagba );
};

// SetNumber sets the number of the invoice.
func (_bfdc *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_bfdc ._aaeg [1].Value =number ;return _bfdc ._aaeg [0],_bfdc ._aaeg [1];};

// SetStyleTop sets border style for top side.
func (_ddf *border )SetStyleTop (style CellBorderStyle ){_ddf ._gfbe =style };func (_acfbf *Paragraph )wrapText ()error {if !_acfbf ._eeda ||int (_acfbf ._cagbag )<=0{_acfbf ._agac =[]string {_acfbf ._adad };return nil ;};_fgeb :=NewTextChunk (_acfbf ._adad ,TextStyle {Font :_acfbf ._gacgc ,FontSize :_acfbf ._ffbe });
_gcbbd ,_bgbc :=_fgeb .Wrap (_acfbf ._cagbag );if _bgbc !=nil {return _bgbc ;};if _acfbf ._cecg > 0&&len (_gcbbd )> _acfbf ._cecg {_gcbbd =_gcbbd [:_acfbf ._cecg ];};_acfbf ._agac =_gcbbd ;return nil ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_dagf *shading ;_cgeag *_aa .PdfRectangle ;_cbad AnchorPoint ;_aaae float64 ;_aeagb float64 ;_eaae float64 ;_dceed float64 ;};func (_bdeca *templateProcessor )parseFitModeAttr (_fabdf ,_accfc string )FitMode {_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_fabdf ,_accfc );
_dfbgb :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_accfc ];return _dfbgb ;};func (_gdc *Block )translate (_cfgd ,_aadf float64 ){_deg :=_ae .NewContentCreator ().Translate (_cfgd ,-_aadf ).Operations ();
*_gdc ._aae =append (*_deg ,*_gdc ._aae ...);_gdc ._aae .WrapIfNeeded ();};func _gbggf (_cabb string ,_dddb bool )string {_fgcdb :=_cabb ;if _fgcdb ==""{return "";};_dcbe :=_bb .Paragraph {};_ ,_bcgba :=_dcbe .SetString (_cabb );if _bcgba !=nil {return _fgcdb ;
};_dbeea ,_bcgba :=_dcbe .Order ();if _bcgba !=nil {return _fgcdb ;};_gfbea :=_dbeea .NumRuns ();_gffc :=make ([]string ,_gfbea );for _aagaa :=0;_aagaa < _dbeea .NumRuns ();_aagaa ++{_eegb :=_dbeea .Run (_aagaa );_eccff :=_eegb .String ();if _eegb .Direction ()==_bb .RightToLeft {_eccff =_bb .ReverseString (_eccff );
};if _dddb {_gffc [_aagaa ]=_eccff ;}else {_gffc [_gfbea -1]=_eccff ;};_gfbea --;};if len (_gffc )!=_dbeea .NumRuns (){return _cabb ;};_fgcdb =_gc .Join (_gffc ,"");return _fgcdb ;};

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_gdccd *Rectangle )FillOpacity ()float64 {return _gdccd ._befe };func (_fdbbg *templateProcessor )parseChart (_dedc *templateNode )(interface{},error ){var _aecff string ;for _ ,_gcagg :=range _dedc ._gcbdb .Attr {_cfba :=_gcagg .Value ;switch _cdee :=_gcagg .Name .Local ;
_cdee {case "\u0073\u0072\u0063":_aecff =_cfba ;};};if _aecff ==""{_fdbbg .nodeLogError (_dedc ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_dggcgg ;};_eccgc ,_fcdgg :=_fdbbg ._agfcg .ChartMap [_aecff ];if !_fcdgg {_fdbbg .nodeLogError (_dedc ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_aecff );
return nil ,_dggcgg ;};_eadae :=NewChart (_eccgc );for _ ,_gffaff :=range _dedc ._gcbdb .Attr {_bccgd :=_gffaff .Value ;switch _gdfb :=_gffaff .Name .Local ;_gdfb {case "\u0078":_eadae .SetPos (_fdbbg .parseFloatAttr (_gdfb ,_bccgd ),_eadae ._abd );case "\u0079":_eadae .SetPos (_eadae ._ccbb ,_fdbbg .parseFloatAttr (_gdfb ,_bccgd ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ddgea :=_fdbbg .parseMarginAttr (_gdfb ,_bccgd );_eadae .SetMargins (_ddgea .Left ,_ddgea .Right ,_ddgea .Top ,_ddgea .Bottom );case "\u0077\u0069\u0064t\u0068":_eadae ._cedg .SetWidth (int (_fdbbg .parseFloatAttr (_gdfb ,_bccgd )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_eadae ._cedg .SetHeight (int (_fdbbg .parseFloatAttr (_gdfb ,_bccgd )));case "\u0073\u0072\u0063":break ;default:_fdbbg .nodeLogDebug (_dedc ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_gdfb );
};};return _eadae ,nil ;};

// SetOpacity sets the opacity of the line (0-1).
func (_edced *Line )SetOpacity (opacity float64 ){_edced ._bcfb =opacity };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline };};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_bdfdg *Creator )MoveTo (x ,y float64 ){_bdfdg ._aaa .X =x ;_bdfdg ._aaa .Y =y };func (_afge *pageTransformations )transformBlock (_dge *Block ){if _afge ._fece !=nil {_dge .transform (*_afge ._fece );};};func (_cfegc *Invoice )setCellBorder (_cagba *TableCell ,_eabc *InvoiceCell ){for _ ,_aebd :=range _eabc .BorderSides {_cagba .SetBorder (_aebd ,CellBorderStyleSingle ,_eabc .BorderWidth );
};_cagba .SetBorderColor (_eabc .BorderColor );};var _efda =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dbbbb :_gafbd },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_ccgdfa :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_dbbbb :_beea },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dbbbb :_gffgg },"\u0074\u0061\u0062l\u0065":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dbbbb :_acccg },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_ccgdfa :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_dbbbb :_ffgbd },"\u006c\u0069\u006e\u0065":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dbbbb :_fddcg },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dbbbb :_ccbg },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dbbbb :_edbf },"\u0069\u006d\u0061g\u0065":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dbbbb :_fbaca },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dbbbb :_cdgg },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dbbbb :_cafgf },"\u0063\u0068\u0061r\u0074":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dbbbb :_dgdbc },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dbbbb :_ddbc },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_ccgdfa :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_dbbbb :_cgcbg },"\u006c\u0069\u0073\u0074":&templateTag {_ccgdfa :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dbbbb :_gege },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_ccgdfa :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_dbbbb :_gdcag },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_ccgdfa :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dbbbb :_fdfa }};


// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_gdcb *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_gdcb ._geab .Left =left ;_gdcb ._geab .Right =right ;_gdcb ._geab .Top =top ;_gdcb ._geab .Bottom =bottom ;};

// CurRow returns the currently active cell's row number.
func (_fgacc *Table )CurRow ()int {_gced :=(_fgacc ._fdagd -1)/_fgacc ._abdae +1;return _gced };

// Width returns the width of the ellipse.
func (_gfcgd *Ellipse )Width ()float64 {return _gfcgd ._cgec };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_gcab *Creator )EnableFontSubsetting (font *_aa .PdfFont ){_gcab ._gaee =append (_gcab ._gaee ,font );};func _dfdbbc (_afggbg ,_fadcc ,_geafg float64 )(_dgffa ,_dceaef ,_gdggd ,_bafce float64 ){if _geafg ==0{return 0,0,_afggbg ,_fadcc ;};_gafbe :=_ad .Path {Points :[]_ad .Point {_ad .NewPoint (0,0).Rotate (_geafg ),_ad .NewPoint (_afggbg ,0).Rotate (_geafg ),_ad .NewPoint (0,_fadcc ).Rotate (_geafg ),_ad .NewPoint (_afggbg ,_fadcc ).Rotate (_geafg )}}.GetBoundingBox ();
return _gafbe .X ,_gafbe .Y ,_gafbe .Width ,_gafbe .Height ;};func _dcce (_fff *_aa .Image )(*Image ,error ){_badf :=float64 (_fff .Width );_fbef :=float64 (_fff .Height );return &Image {_dcbd :_fff ,_acde :_badf ,_fcbf :_fbef ,_ddce :_badf ,_afea :_fbef ,_ggggg :0,_bgda :1.0,_ddca :PositionRelative },nil ;
};func _fdabe (_gbf string )(*GraphicSVG ,error ){_gagg ,_cffg :=_de .ParseFromString (_gbf );if _cffg !=nil {return nil ,_cffg ;};return _geea (_gagg );};func _cafgf (_gbefd *templateProcessor ,_beabf *templateNode )(interface{},error ){return _gbefd .parseChapterHeading (_beabf );
};const (DefaultHorizontalScaling =100;);

// SetEnableWrap sets the line wrapping enabled flag.
func (_bafef *StyledParagraph )SetEnableWrap (enableWrap bool ){_bafef ._eacd =enableWrap ;_bafef ._bbca =false ;};func (_dcbgc *templateProcessor )parseBorderRadiusAttr (_dfgag ,_aeae string )(_ddebba ,_dedbe ,_fbcbb ,_fggfc float64 ){_ce .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_dfgag ,_aeae );
switch _bggab :=_gc .Fields (_aeae );len (_bggab ){case 1:_ddebba ,_ =_gcc .ParseFloat (_bggab [0],64);_dedbe =_ddebba ;_fbcbb =_ddebba ;_fggfc =_ddebba ;case 2:_ddebba ,_ =_gcc .ParseFloat (_bggab [0],64);_fbcbb =_ddebba ;_dedbe ,_ =_gcc .ParseFloat (_bggab [1],64);
_fggfc =_dedbe ;case 3:_ddebba ,_ =_gcc .ParseFloat (_bggab [0],64);_dedbe ,_ =_gcc .ParseFloat (_bggab [1],64);_fggfc =_dedbe ;_fbcbb ,_ =_gcc .ParseFloat (_bggab [2],64);case 4:_ddebba ,_ =_gcc .ParseFloat (_bggab [0],64);_dedbe ,_ =_gcc .ParseFloat (_bggab [1],64);
_fbcbb ,_ =_gcc .ParseFloat (_bggab [2],64);_fggfc ,_ =_gcc .ParseFloat (_bggab [3],64);};return _ddebba ,_dedbe ,_fbcbb ,_fggfc ;};

// SetBorderColor sets the border color for the path.
func (_egcg *FilledCurve )SetBorderColor (color Color ){_egcg ._aeff =color };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_dbefa *Image )ConvertToBinary ()error {return _dbefa ._dcbd .ConvertToBinary ()};

// Padding returns the padding of the component.
func (_faee *Division )Padding ()(_cace ,_afa ,_gdbg ,_gadd float64 ){return _faee ._fgfc .Left ,_faee ._fgfc .Right ,_faee ._fgfc .Top ,_faee ._fgfc .Bottom ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_fccg *Creator )SetPageSize (size PageSize ){_fccg ._dafd =size ;_fccg ._fddd =size [0];_fccg ._ccdb =size [1];_degc :=0.1*_fccg ._fddd ;_fccg ._bag .Left =_degc ;_fccg ._bag .Right =_degc ;_fccg ._bag .Top =_degc ;_fccg ._bag .Bottom =_degc ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_ebeec *Invoice )BuyerAddress ()*InvoiceAddress {return _ebeec ._bec };

// SetSubtotal sets the subtotal of the invoice.
func (_cdcgc *Invoice )SetSubtotal (value string ){_cdcgc ._febf [1].Value =value };

// Width returns the current page width.
func (_fafc *Creator )Width ()float64 {return _fafc ._fddd };

// SetInline sets the inline mode of the division.
func (_fdbf *Division )SetInline (inline bool ){_fdbf ._dcfb =inline };

// NewPageBreak create a new page break.
func (_cgba *Creator )NewPageBreak ()*PageBreak {return _ccce ()};func _ccce ()*PageBreak {return &PageBreak {}};

// IsRelative checks if the positioning is relative.
func (_dgdg Positioning )IsRelative ()bool {return _dgdg ==PositionRelative };func (_bbag *Line )computeCoords (_dggcb DrawContext )(_ffgb ,_efff ,_eaeg ,_cfeb float64 ){_ffgb =_dggcb .X ;_eaeg =_ffgb +_bbag ._fede -_bbag ._ccfd ;_gdda :=_bbag ._cdae ;
if _bbag ._ccfd ==_bbag ._fede {_gdda /=2;};if _bbag ._fbbgd < _bbag ._bdea {_efff =_dggcb .PageHeight -_dggcb .Y -_gdda ;_cfeb =_efff -_bbag ._bdea +_bbag ._fbbgd ;}else {_cfeb =_dggcb .PageHeight -_dggcb .Y -_gdda ;_efff =_cfeb -_bbag ._fbbgd +_bbag ._bdea ;
};switch _bbag ._bbgf {case FitModeFillWidth :_eaeg =_ffgb +_dggcb .Width ;};return _ffgb ,_efff ,_eaeg ,_cfeb ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_cbggb *StyledParagraph ;_cdabg []*TOCLine ;_faff TextStyle ;_bccgdb TextStyle ;_gdddd TextStyle ;_bdcgd TextStyle ;_egga string ;_geadb float64 ;_ccecf Margins ;_adedd Positioning ;_dace TextStyle ;_ebdf bool ;};

// SetLineColor sets the line color.
func (_daea *Polyline )SetLineColor (color Color ){_daea ._fefe .LineColor =_adb (color )};

// SetFillColor sets the fill color of the rectangle.
func (_fgdc *Rectangle )SetFillColor (col Color ){_fgdc ._fdgf =col };func _dfac (_fdad *_aa .PdfRectangle ,_bbea _dc .Matrix )*_aa .PdfRectangle {var _cgad _aa .PdfRectangle ;_cgad .Llx ,_cgad .Lly =_bbea .Transform (_fdad .Llx ,_fdad .Lly );_cgad .Urx ,_cgad .Ury =_bbea .Transform (_fdad .Urx ,_fdad .Ury );
_cgad .Normalize ();return &_cgad ;};

// SetSideBorderStyle sets the cell's side border style.
func (_bfgf *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_bfgf ._gcge =style ;_bfgf ._faaa =style ;_bfgf ._dbfa =style ;_bfgf ._geee =style ;case CellBorderSideTop :_bfgf ._gcge =style ;
case CellBorderSideBottom :_bfgf ._faaa =style ;case CellBorderSideLeft :_bfgf ._dbfa =style ;case CellBorderSideRight :_bfgf ._geee =style ;};};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_eggbf *Table )NewCell ()*TableCell {return _eggbf .MultiCell (1,1)};

// CurCol returns the currently active cell's column number.
func (_cdbb *Table )CurCol ()int {_bedgd :=(_cdbb ._fdagd -1)%(_cdbb ._abdae )+1;return _bedgd };

// SetAngle sets the rotation angle of the text.
func (_deege *StyledParagraph )SetAngle (angle float64 ){_deege ._aggf =angle };func _caegc (_gadaf *_aa .PdfAnnotationLink )*_aa .PdfAnnotationLink {if _gadaf ==nil {return nil ;};_gafdg :=_aa .NewPdfAnnotationLink ();_gafdg .BS =_gadaf .BS ;_gafdg .A =_gadaf .A ;
if _afbcc ,_gcdafb :=_gadaf .GetAction ();_gcdafb ==nil &&_afbcc !=nil {_gafdg .SetAction (_afbcc );};if _eecc ,_edbeb :=_gadaf .Dest .(*_e .PdfObjectArray );_edbeb {_gafdg .Dest =_e .MakeArray (_eecc .Elements ()...);};return _gafdg ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_fagg *Creator )NewChapter (title string )*Chapter {_fagg ._cce ++;_beaff :=_fagg .NewTextStyle ();_beaff .FontSize =16;return _fde (nil ,_fagg ._fegf ,_fagg ._gcdce ,title ,_fagg ._cce ,_beaff );};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_aae *_ae .ContentStreamOperations ;_ddc *_aa .PdfPageResources ;_db Positioning ;_ed ,_ac float64 ;_ff float64 ;_cb float64 ;_eb float64 ;_ge Margins ;_af []*_aa .PdfAnnotation ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_cfdd *Image )GetHorizontalAlignment ()HorizontalAlignment {return _cfdd ._adf };

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_agcc *Table )SetPos (x ,y float64 ){_agcc ._dbgb =PositionAbsolute ;_agcc ._caba =x ;_agcc ._cdfcg =y ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_dbed *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbac :=ctx ;if _dbed ._feed .IsRelative (){ctx .X +=_dbed ._aaefc .Left ;ctx .Y +=_dbed ._aaefc .Top ;ctx .Width -=_dbed ._aaefc .Left +_dbed ._aaefc .Right ;ctx .Height -=_dbed ._aaefc .Top ;
};_ccc ,_ggd ,_ccf :=_dbed ._bbeg .GeneratePageBlocks (ctx );if _ccf !=nil {return _ccc ,ctx ,_ccf ;};ctx =_ggd ;_edfd :=ctx .X ;_ecg :=ctx .Y -_dbed ._bbeg .Height ();_fdag :=int64 (ctx .Page );_bcfe :=_dbed .headingNumber ();_bfgc :=_dbed .headingText ();
if _dbed ._bae {_agd :=_dbed ._egfag .Add (_bcfe ,_dbed ._gcca ,_gcc .FormatInt (_fdag ,10),_dbed ._bdfda );if _dbed ._egfag ._ebdf {_agd .SetLink (_fdag ,_edfd ,_ecg );};};if _dbed ._ebg ==nil {_dbed ._ebg =_aa .NewOutlineItem (_bfgc ,_aa .NewOutlineDest (_fdag -1,_edfd ,_ecg ));
if _dbed ._ade !=nil {_dbed ._ade ._ebg .Add (_dbed ._ebg );}else {_dbed ._eef .Add (_dbed ._ebg );};}else {_bed :=&_dbed ._ebg .Dest ;_bed .Page =_fdag -1;_bed .X =_edfd ;_bed .Y =_ecg ;};for _ ,_fef :=range _dbed ._fca {_cbfe ,_babe ,_aegd :=_fef .GeneratePageBlocks (ctx );
if _aegd !=nil {return _ccc ,ctx ,_aegd ;};if len (_cbfe )< 1{continue ;};_ccc [len (_ccc )-1].mergeBlocks (_cbfe [0]);_ccc =append (_ccc ,_cbfe [1:]...);ctx =_babe ;};if _dbed ._feed .IsRelative (){ctx .X =_dbac .X ;};if _dbed ._feed .IsAbsolute (){return _ccc ,_dbac ,nil ;
};return _ccc ,ctx ,nil ;};func (_cgce *RadialShading )shadingModel ()*_aa .PdfShadingType3 {_efdg ,_aecce ,_defdg :=_cgce ._dagf ._egfd .ToRGB ();var _cdcd _ad .Point ;switch _cgce ._cbad {case AnchorBottomLeft :_cdcd =_ad .Point {X :_cgce ._cgeag .Llx ,Y :_cgce ._cgeag .Lly };
case AnchorBottomRight :_cdcd =_ad .Point {X :_cgce ._cgeag .Urx ,Y :_cgce ._cgeag .Ury -_cgce ._cgeag .Height ()};case AnchorTopLeft :_cdcd =_ad .Point {X :_cgce ._cgeag .Llx ,Y :_cgce ._cgeag .Lly +_cgce ._cgeag .Height ()};case AnchorTopRight :_cdcd =_ad .Point {X :_cgce ._cgeag .Urx ,Y :_cgce ._cgeag .Ury };
case AnchorLeft :_cdcd =_ad .Point {X :_cgce ._cgeag .Llx ,Y :_cgce ._cgeag .Lly +_cgce ._cgeag .Height ()/2};case AnchorTop :_cdcd =_ad .Point {X :_cgce ._cgeag .Llx +_cgce ._cgeag .Width ()/2,Y :_cgce ._cgeag .Ury };case AnchorRight :_cdcd =_ad .Point {X :_cgce ._cgeag .Urx ,Y :_cgce ._cgeag .Lly +_cgce ._cgeag .Height ()/2};
case AnchorBottom :_cdcd =_ad .Point {X :_cgce ._cgeag .Urx +_cgce ._cgeag .Width ()/2,Y :_cgce ._cgeag .Lly };default:_cdcd =_ad .NewPoint (_cgce ._cgeag .Llx +_cgce ._cgeag .Width ()/2,_cgce ._cgeag .Lly +_cgce ._cgeag .Height ()/2);};_bbbc :=_cgce ._eaae ;
_afafc :=_cgce ._dceed ;_bcffg :=_cdcd .X +_cgce ._aaae ;_dafe :=_cdcd .Y +_cgce ._aeagb ;if _bbbc ==-1.0{_bbbc =0.0;};if _afafc ==-1.0{var _bgce []float64 ;_abbab :=_bcb .Pow (_bcffg -_cgce ._cgeag .Llx ,2)+_bcb .Pow (_dafe -_cgce ._cgeag .Lly ,2);_bgce =append (_bgce ,_bcb .Abs (_abbab ));
_eeafc :=_bcb .Pow (_bcffg -_cgce ._cgeag .Llx ,2)+_bcb .Pow (_cgce ._cgeag .Lly +_cgce ._cgeag .Height ()-_dafe ,2);_bgce =append (_bgce ,_bcb .Abs (_eeafc ));_baaaa :=_bcb .Pow (_cgce ._cgeag .Urx -_bcffg ,2)+_bcb .Pow (_dafe -_cgce ._cgeag .Ury -_cgce ._cgeag .Height (),2);
_bgce =append (_bgce ,_bcb .Abs (_baaaa ));_gbba :=_bcb .Pow (_cgce ._cgeag .Urx -_bcffg ,2)+_bcb .Pow (_cgce ._cgeag .Ury -_dafe ,2);_bgce =append (_bgce ,_bcb .Abs (_gbba ));_ga .Slice (_bgce ,func (_gcde ,_bfcaa int )bool {return _gcde > _bfcaa });_afafc =_bcb .Sqrt (_bgce [0]);
};_fdegc :=&_aa .PdfRectangle {Llx :_bcffg -_afafc ,Lly :_dafe -_afafc ,Urx :_bcffg +_afafc ,Ury :_dafe +_afafc };_gefdg :=_aa .NewPdfShadingType3 ();_gefdg .PdfShading .ShadingType =_e .MakeInteger (3);_gefdg .PdfShading .ColorSpace =_aa .NewPdfColorspaceDeviceRGB ();
_gefdg .PdfShading .Background =_e .MakeArrayFromFloats ([]float64 {_efdg ,_aecce ,_defdg });_gefdg .PdfShading .BBox =_fdegc ;_gefdg .PdfShading .AntiAlias =_e .MakeBool (_cgce ._dagf ._acef );_gefdg .Coords =_e .MakeArrayFromFloats ([]float64 {_bcffg ,_dafe ,_bbbc ,_bcffg ,_dafe ,_afafc });
_gefdg .Domain =_e .MakeArrayFromFloats ([]float64 {0.0,1.0});_gefdg .Extend =_e .MakeArray (_e .MakeBool (_cgce ._dagf ._cfddb [0]),_e .MakeBool (_cgce ._dagf ._cfddb [1]));_gefdg .Function =_cgce ._dagf .generatePdfFunctions ();return _gefdg ;};

// SetBorderColor sets the border color.
func (_cadad *CurvePolygon )SetBorderColor (color Color ){_cadad ._cbda .BorderColor =_adb (color )};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_fge *Creator )SetForms (form *_aa .PdfAcroForm )error {_fge ._bbc =form ;return nil };type templateProcessor struct{creator *Creator ;_edbe []byte ;_agfcg *TemplateOptions ;_effb componentRenderer ;_dgbff string ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_beae *Chart )Width ()float64 {return float64 (_beae ._cedg .Width ())};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_dddc *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eacf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbda ,_abed :=_eacf .setOpacity (_dddc ._fae ,_dddc ._ccgef );if _abed !=nil {return nil ,ctx ,_abed ;};
_geff :=_dddc ._cbda ;_geff .FillEnabled =_geff .FillColor !=nil ;_geff .BorderEnabled =_geff .BorderColor !=nil &&_geff .BorderWidth > 0;var (_dfea =ctx .PageHeight ;_bdc =_geff .Rings ;_efg =make ([][]_ad .CubicBezierCurve ,0,len (_geff .Rings )););_feceg :=_aa .PdfRectangle {};
if len (_bdc )> 0&&len (_bdc [0])> 0{_feeg :=_bdc [0][0];_feeg .P0 .Y =_dfea -_feeg .P0 .Y ;_feeg .P1 .Y =_dfea -_feeg .P1 .Y ;_feeg .P2 .Y =_dfea -_feeg .P2 .Y ;_feeg .P3 .Y =_dfea -_feeg .P3 .Y ;_feceg =_feeg .GetBounds ();};for _ ,_dbge :=range _bdc {_edbd :=make ([]_ad .CubicBezierCurve ,0,len (_dbge ));
for _ ,_fafb :=range _dbge {_aacg :=_fafb ;_aacg .P0 .Y =_dfea -_aacg .P0 .Y ;_aacg .P1 .Y =_dfea -_aacg .P1 .Y ;_aacg .P2 .Y =_dfea -_aacg .P2 .Y ;_aacg .P3 .Y =_dfea -_aacg .P3 .Y ;_edbd =append (_edbd ,_aacg );_aacgg :=_aacg .GetBounds ();_feceg .Llx =_bcb .Min (_feceg .Llx ,_aacgg .Llx );
_feceg .Lly =_bcb .Min (_feceg .Lly ,_aacgg .Lly );_feceg .Urx =_bcb .Max (_feceg .Urx ,_aacgg .Urx );_feceg .Ury =_bcb .Max (_feceg .Ury ,_aacgg .Ury );};_efg =append (_efg ,_edbd );};_geff .Rings =_efg ;defer func (){_geff .Rings =_bdc }();if _geff .FillEnabled {_ebcf :=_effg (_eacf ,_dddc ._cbda .FillColor ,_dddc ._fbbbb ,func ()Rectangle {return Rectangle {_ddge :_feceg .Llx ,_gead :_feceg .Lly ,_dbda :_feceg .Width (),_agfc :_feceg .Height ()};
});if _ebcf !=nil {return nil ,ctx ,_ebcf ;};};_cfff ,_ ,_abed :=_geff .Draw (_gbda );if _abed !=nil {return nil ,ctx ,_abed ;};if _abed =_eacf .addContentsByString (string (_cfff ));_abed !=nil {return nil ,ctx ,_abed ;};return []*Block {_eacf },ctx ,nil ;
};func (_gged *Invoice )generateLineBlocks (_dbgf DrawContext )([]*Block ,DrawContext ,error ){_dggce :=_baea (len (_gged ._dagc ));_dggce .SetMargins (0,0,25,0);for _ ,_aecb :=range _gged ._dagc {_bgga :=_fbfg (_aecb .TextStyle );_bgga .SetMargins (0,0,1,0);
_bgga .Append (_aecb .Value );_fbdg :=_dggce .NewCell ();_fbdg .SetHorizontalAlignment (_aecb .Alignment );_fbdg .SetBackgroundColor (_aecb .BackgroundColor );_gged .setCellBorder (_fbdg ,_aecb );_fbdg .SetContent (_bgga );};for _ ,_eefa :=range _gged ._bcdb {for _ ,_dbf :=range _eefa {_ccag :=_fbfg (_dbf .TextStyle );
_ccag .SetMargins (0,0,3,2);_ccag .Append (_dbf .Value );_bbb :=_dggce .NewCell ();_bbb .SetHorizontalAlignment (_dbf .Alignment );_bbb .SetBackgroundColor (_dbf .BackgroundColor );_gged .setCellBorder (_bbb ,_dbf );_bbb .SetContent (_ccag );};};return _dggce .GeneratePageBlocks (_dbgf );
};

// SetAngle sets Image rotation angle in degrees.
func (_gbddc *Image )SetAngle (angle float64 ){_gbddc ._ggggg =angle };

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_ggdag *Line )SetColor (color Color ){_ggdag ._daba =color };

// DrawHeader sets a function to draw a header on created output pages.
func (_gcda *Creator )DrawHeader (drawHeaderFunc func (_dgbd *Block ,_gcce HeaderFunctionArgs )){_gcda ._cbag =drawHeaderFunc ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_aded *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _aded ._aade .Left ,_aded ._aade .Right ,_aded ._aade .Top ,_aded ._aade .Bottom ;};

// BorderWidth returns the border width of the ellipse.
func (_fege *Ellipse )BorderWidth ()float64 {return _fege ._ggcgf };

// SetColorBottom sets border color for bottom.
func (_feb *border )SetColorBottom (col Color ){_feb ._gfe =col };func _gbga (_ceddb *_aa .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_ceddb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_geaed *Invoice )Terms ()(string ,string ){return _geaed ._cef [0],_geaed ._cef [1]};func (_fgeg *templateProcessor )parseCellBorderStyleAttr (_gaddb ,_abdfg string )CellBorderStyle {_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_gaddb ,_abdfg );
_cefce :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_abdfg ];return _cefce ;};

// SetLogo sets the logo of the invoice.
func (_bbdc *Invoice )SetLogo (logo *Image ){_bbdc ._fafe =logo };

// SetLineOpacity sets the line opacity.
func (_dbab *Polyline )SetLineOpacity (opacity float64 ){_dbab ._eagd =opacity };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_febgg *RadialShading )SetBackgroundColor (backgroundColor Color ){_febgg ._dagf .SetBackgroundColor (backgroundColor );};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func (_fbf *Block )drawToPage (_bea *_aa .PdfPage )error {_ffd :=&_ae .ContentStreamOperations {};
if _bea .Resources ==nil {_bea .Resources =_aa .NewPdfPageResources ();};_fbfc :=_gaa (_ffd ,_bea .Resources ,_fbf ._aae ,_fbf ._ddc );if _fbfc !=nil {return _fbfc ;};if _fbfc =_abc (_fbf ._ddc ,_bea .Resources );_fbfc !=nil {return _fbfc ;};if _fbfc =_bea .AppendContentBytes (_ffd .Bytes (),true );
_fbfc !=nil {return _fbfc ;};for _ ,_bfb :=range _fbf ._af {_bea .AddAnnotation (_bfb );};return nil ;};type listItem struct{_cbcgc VectorDrawable ;_fcac TextChunk ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_ebbd *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_ebbd ._bfbc =align ;};func (_ccefg *templateProcessor )run ()error {_gcacb :=_gf .NewDecoder (_a .NewReader (_ccefg ._edbe ));var _aabd *templateNode ;for {_gfad ,_efab :=_gcacb .Token ();
if _efab !=nil {if _efab ==_bd .EOF {return nil ;};return _efab ;};if _gfad ==nil {break ;};_cbeb ,_cfcae :=_cbgfe (_gcacb );_febaa :=_gcacb .InputOffset ();switch _gfeea :=_gfad .(type ){case _gf .StartElement :_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_gfeea .Name .Local );
_dfegc ,_cbabc :=_efda [_gfeea .Name .Local ];if !_cbabc {if _ccefg ._dgbff ==""{if _cbeb !=0{_ce .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_gfeea .Name .Local ,_cbeb ,_cfcae );
}else {_ce .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_gfeea .Name .Local ,_febaa );
};}else {if _cbeb !=0{_ce .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_gfeea .Name .Local ,_ccefg ._dgbff ,_cbeb ,_cfcae );
}else {_ce .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_gfeea .Name .Local ,_ccefg ._dgbff ,_febaa );
};};continue ;};_aabd =&templateNode {_gcbdb :_gfeea ,_fedefc :_aabd ,_gfaad :_cbeb ,_gfacg :_cfcae ,_dfag :_febaa };if _dcaa :=_dfegc ._dbbbb ;_dcaa !=nil {_aabd ._ebabb ,_efab =_dcaa (_ccefg ,_aabd );if _efab !=nil {return _efab ;};};case _gf .EndElement :_ce .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_gfeea .Name .Local );
if _aabd !=nil {if _aabd ._ebabb !=nil {if _ebeb :=_ccefg .renderNode (_aabd );_ebeb !=nil {return _ebeb ;};};_aabd =_aabd ._fedefc ;};case _gf .CharData :if _aabd !=nil &&_aabd ._ebabb !=nil {if _fbfff :=_ccefg .addNodeText (_aabd ,string (_gfeea ));_fbfff !=nil {return _fbfff ;
};};case _gf .Comment :_ce .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_gfeea ));};};return nil ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_dcag *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_cece ,_agfea :=_dcag .Wrap (width );if _agfea !=nil {return nil ,_agfea ;};_ddbe :=int (height /_dcag .Style .FontSize );if _ddbe >=len (_cece ){return nil ,nil ;};_geede :="\u000a";
_dcag .Text =_gc .Replace (_gc .Join (_cece [:_ddbe ],"\u0020"),_geede +"\u0020",_geede ,-1);_cbged :=_gc .Replace (_gc .Join (_cece [_ddbe :],"\u0020"),_geede +"\u0020",_geede ,-1);return NewTextChunk (_cbged ,_dcag .Style ),nil ;};

// Height returns the height of the list.
func (_dgfef *List )Height ()float64 {var _accd float64 ;for _ ,_efgd :=range _dgfef ._dbedd {_accd +=_efgd .ctxHeight (_dgfef .Width ());};return _accd ;};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_dfce *Ellipse )SetFillOpacity (opacity float64 ){_dfce ._bce =opacity };

// AddTotalLine adds a new line in the invoice totals table.
func (_bcdg *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_cgbaff :=&InvoiceCell {_bcdg ._fgccc ,desc };_adba :=&InvoiceCell {_bcdg ._fgccc ,value };_bcdg ._gfaa =append (_bcdg ._gfaa ,[2]*InvoiceCell {_cgbaff ,_adba });return _cgbaff ,_adba ;
};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// NewInvoice returns an instance of an empty invoice.
func (_bdfa *Creator )NewInvoice ()*Invoice {_baff :=_bdfa .NewTextStyle ();_baff .Font =_bdfa ._eff ;return _dfaa (_bdfa .NewTextStyle (),_baff );};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_fgga *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_dagae :=range subtable ._dfaeg {_faege :=&TableCell {};*_faege =*_dagae ;_faege ._cccc =_fgga ;_faege ._dbbgc +=col -1;if _adeee :=_fgga ._abdae -(_faege ._dbbgc -1);_adeee < _faege ._ebbb {_fgga ._abdae +=_faege ._ebbb -_adeee ;
_fgga .resetColumnWidths ();_ce .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_fgga ._abdae );
};_faege ._afefg +=row -1;_ecgg :=subtable ._ecdda [_dagae ._afefg -1];if _faege ._afefg > _fgga ._ccgdf {for _faege ._afefg > _fgga ._ccgdf {_fgga ._ccgdf ++;_fgga ._ecdda =append (_fgga ._ecdda ,_fgga ._feae );};_fgga ._ecdda [_faege ._afefg -1]=_ecgg ;
}else {_fgga ._ecdda [_faege ._afefg -1]=_bcb .Max (_fgga ._ecdda [_faege ._afefg -1],_ecgg );};_fgga ._dfaeg =append (_fgga ._dfaeg ,_faege );};_fgga .sortCells ();};

// SetEnableWrap sets the line wrapping enabled flag.
func (_adde *Paragraph )SetEnableWrap (enableWrap bool ){_adde ._eeda =enableWrap ;_adde ._cbga =false };func _cgg (_ffag VectorDrawable ,_efbd float64 )float64 {switch _dfcc :=_ffag .(type ){case *Paragraph :if _dfcc ._eeda {_dfcc .SetWidth (_efbd -_dfcc ._bgeb .Left -_dfcc ._bgeb .Right );
};return _dfcc .Height ()+_dfcc ._bgeb .Top +_dfcc ._bgeb .Bottom ;case *StyledParagraph :if _dfcc ._eacd {_dfcc .SetWidth (_efbd -_dfcc ._gcdca .Left -_dfcc ._gcdca .Right );};return _dfcc .Height ()+_dfcc ._gcdca .Top +_dfcc ._gcdca .Bottom ;case *Image :_dfcc .applyFitMode (_efbd );
return _dfcc .Height ()+_dfcc ._ddbd .Top +_dfcc ._ddbd .Bottom ;case *Rectangle :_dfcc .applyFitMode (_efbd );return _dfcc .Height ()+_dfcc ._ebgg .Top +_dfcc ._ebgg .Bottom +_dfcc ._bcceg ;case *Ellipse :_dfcc .applyFitMode (_efbd );return _dfcc .Height ()+_dfcc ._geab .Top +_dfcc ._geab .Bottom ;
case *Division :return _dfcc .ctxHeight (_efbd )+_dfcc ._cgf .Top +_dfcc ._cgf .Bottom +_dfcc ._fgfc .Top +_dfcc ._fgfc .Bottom ;case *Table :_dfcc .updateRowHeights (_efbd -_dfcc ._dafge .Left -_dfcc ._dafge .Right );return _dfcc .Height ()+_dfcc ._dafge .Top +_dfcc ._dafge .Bottom ;
case *List :return _dfcc .ctxHeight (_efbd )+_dfcc ._aade .Top +_dfcc ._aade .Bottom ;case marginDrawable :_ ,_ ,_abbd ,_bcdd :=_dfcc .GetMargins ();return _dfcc .Height ()+_abbd +_bcdd ;default:return _dfcc .Height ();};};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_bdeg *GraphicSVG )Scale (xFactor ,yFactor float64 ){_bdeg ._age .Width =xFactor *_bdeg ._age .Width ;_bdeg ._age .Height =yFactor *_bdeg ._age .Height ;_bdeg ._age .SetScaling (xFactor ,yFactor );};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_baaff *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _baaff ._gcdca .Left ,_baaff ._gcdca .Right ,_baaff ._gcdca .Top ,_baaff ._gcdca .Bottom ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_fccd *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_cabge :=uint (len (_fccd ._dagc ));if index > _cabge {index =_cabge ;};_dgaa :=_fccd .NewColumn (description );_fccd ._dagc =append (_fccd ._dagc [:index ],append ([]*InvoiceCell {_dgaa },_fccd ._dagc [index :]...)...);
return _dgaa ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_bfcce *TOC )SetLinePageStyle (style TextStyle ){_bfcce ._bdcgd =style };func _fbaca (_bccac *templateProcessor ,_cdad *templateNode )(interface{},error ){return _bccac .parseImage (_cdad );};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_dbgd *Creator )NewParagraph (text string )*Paragraph {return _agde (text ,_dbgd .NewTextStyle ())};

// SetWidthTop sets border width for top.
func (_gcac *border )SetWidthTop (bw float64 ){_gcac ._dbg =bw };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fgac *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _fgac ._febf [0],_fgac ._febf [1]};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_fafcb *Ellipse )ScaleToHeight (h float64 ){_daaf :=_fafcb ._cgec /_fafcb ._dceeg ;_fafcb ._dceeg =h ;_fafcb ._cgec =h *_daaf ;};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _bc .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_bd .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_aa .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_aa .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ag .ChartRenderable ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_cabd *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_cabd ._cbaa =&_aa .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetBorderColor sets the border color.
func (_bbcc *PolyBezierCurve )SetBorderColor (color Color ){_bbcc ._gbgb .BorderColor =_adb (color )};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_acca *Creator )MoveRight (dx float64 ){_acca ._aaa .X +=dx };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_aa .PdfPage )(*Block ,error ){_gec :=&Block {};_dg ,_agb :=page .GetAllContentStreams ();if _agb !=nil {return nil ,_agb ;};_cd :=_ae .NewContentStreamParser (_dg );_da ,_agb :=_cd .Parse ();if _agb !=nil {return nil ,_agb ;
};_da .WrapIfNeeded ();_gec ._aae =_da ;if page .Resources !=nil {_gec ._ddc =page .Resources ;}else {_gec ._ddc =_aa .NewPdfPageResources ();};_aad ,_agb :=page .GetMediaBox ();if _agb !=nil {return nil ,_agb ;};if _aad .Llx !=0||_aad .Lly !=0{_gec .translate (-_aad .Llx ,_aad .Lly );
};_gec ._ff =_aad .Urx -_aad .Llx ;_gec ._cb =_aad .Ury -_aad .Lly ;if page .Rotate !=nil {_gec ._eb =-float64 (*page .Rotate );};return _gec ,nil ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_gcbg *Chart )SetPos (x ,y float64 ){_gcbg ._egg =PositionAbsolute ;_gcbg ._ccbb =x ;_gcbg ._abd =y ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_bdg :_bcb .Max (_bcb .Min (r ,1.0),0.0),_cbcf :_bcb .Max (_bcb .Min (g ,1.0),0.0),_bgdf :_bcb .Max (_bcb .Min (b ,1.0),0.0)};};type componentRenderer interface{Draw (_edcgc Drawable )error ;
};

// AddLine adds a new line with the provided style to the table of contents.
func (_fgegc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_fgegc ._cdabg =append (_fgegc ._cdabg ,line );return line ;};

// SetPos sets absolute positioning with specified coordinates.
func (_eaed *StyledParagraph )SetPos (x ,y float64 ){_eaed ._bfgcf =PositionAbsolute ;_eaed ._aedfg =x ;_eaed ._afgd =y ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};func (_dcbc *Image )makeXObject ()error {_acdg :=_dcbc ._bbaf ;if _acdg ==nil {_acdg =_e .NewFlateEncoder ();};_cadf ,_ebabg :=_aa .NewXObjectImageFromImage (_dcbc ._dcbd ,nil ,_acdg );if _ebabg !=nil {_ce .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ebabg );
return _ebabg ;};_dcbc ._bdga =_cadf ;return nil ;};func (_fbeg *Creator )getActivePage ()*_aa .PdfPage {if _fbeg ._caf ==nil {if len (_fbeg ._agfa )==0{return nil ;};return _fbeg ._agfa [len (_fbeg ._agfa )-1];};return _fbeg ._caf ;};func _fbgcc (_dcdgc int64 ,_ecddf ,_ebag ,_bgbgf float64 )*_aa .PdfAnnotation {_eedbb :=_aa .NewPdfAnnotationLink ();
_edaff :=_aa .NewBorderStyle ();_edaff .SetBorderWidth (0);_eedbb .BS =_edaff .ToPdfObject ();if _dcdgc < 0{_dcdgc =0;};_eedbb .Dest =_e .MakeArray (_e .MakeInteger (_dcdgc ),_e .MakeName ("\u0058\u0059\u005a"),_e .MakeFloat (_ecddf ),_e .MakeFloat (_ebag ),_e .MakeFloat (_bgbgf ));
return _eedbb .PdfAnnotation ;};

// Height returns the height of the ellipse.
func (_gegc *Ellipse )Height ()float64 {return _gegc ._dceeg };

// AddLine appends a new line to the invoice line items table.
func (_gfdfa *Invoice )AddLine (values ...string )[]*InvoiceCell {_dfgd :=len (_gfdfa ._dagc );var _cgbb []*InvoiceCell ;for _cgde ,_aceb :=range values {_bcffc :=_gfdfa .newCell (_aceb ,_gfdfa ._cdg );if _cgde < _dfgd {_bcffc .Alignment =_gfdfa ._dagc [_cgde ].Alignment ;
};_cgbb =append (_cgbb ,_bcffc );};_gfdfa ._bcdb =append (_gfdfa ._bcdb ,_cgbb );return _cgbb ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_afbea *List )Add (item VectorDrawable )(*TextChunk ,error ){_cafb :=&listItem {_cbcgc :item ,_fcac :_afbea ._dbfb };switch _bcdbd :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _bcdbd ._aadde {_bcdbd ._ecbc =15;};case *Division :case *Image :case *Table :default:return nil ,_b .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_afbea ._dbedd =append (_afbea ._dbedd ,_cafb );return &_cafb ._fcac ,nil ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_cbeg *Ellipse )BorderOpacity ()float64 {return _cbeg ._gbdg };func (_gcbc *pageTransformations )transformPage (_agfb *_aa .PdfPage )error {if _eaac :=_gcbc .applyFlip (_agfb );_eaac !=nil {return _eaac ;};return nil ;};

// SkipOver skips over a specified number of rows and cols.
func (_gbca *Table )SkipOver (rows ,cols int ){_cgae :=rows *_gbca ._abdae +cols -1;if _cgae < 0{_ce .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gbca ._fdagd +=_cgae ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_adac *Creator )NewPage ()*_aa .PdfPage {_baeg :=_adac .newPage ();_adac ._agfa =append (_adac ._agfa ,_baeg );_adac ._aaa .Page ++;return _baeg ;};func (_feeb rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _feeb ._bdg ,_feeb ._cbcf ,_feeb ._bgdf ;
};

// NewColumn returns a new column for the line items invoice table.
func (_dddg *Invoice )NewColumn (description string )*InvoiceCell {return _dddg .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_ebda *Invoice )SetColumns (cols []*InvoiceCell ){_ebda ._dagc =cols };

// NewTOC creates a new table of contents.
func (_cebf *Creator )NewTOC (title string )*TOC {_ecbe :=_cebf .NewTextStyle ();_ecbe .Font =_cebf ._eff ;return _dacf (title ,_cebf .NewTextStyle (),_ecbe );};func _abad (_aged string )(*Image ,error ){_bdd ,_cee :=_d .Open (_aged );if _cee !=nil {return nil ,_cee ;
};defer _bdd .Close ();_gfag ,_cee :=_aa .ImageHandling .Read (_bdd );if _cee !=nil {_ce .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cee );return nil ,_cee ;
};return _dcce (_gfag );};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fbffb *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cafbe :=ctx ;_eaab ,ctx ,_accaa :=_fbffb ._eggfe .GeneratePageBlocks (ctx );if _accaa !=nil {return _eaab ,ctx ,_accaa ;};if _fbffb ._caagcg .IsRelative (){ctx .X =_cafbe .X ;
};if _fbffb ._caagcg .IsAbsolute (){return _eaab ,_cafbe ,nil ;};return _eaab ,ctx ,nil ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_abfe *Ellipse )SetFitMode (fitMode FitMode ){_abfe ._efgb =fitMode };

// SetMargins sets the margins of the paragraph.
func (_fbgc *List )SetMargins (left ,right ,top ,bottom float64 ){_fbgc ._aade .Left =left ;_fbgc ._aade .Right =right ;_fbgc ._aade .Top =top ;_fbgc ._aade .Bottom =bottom ;};

// BorderColor returns the border color of the ellipse.
func (_bgggfg *Ellipse )BorderColor ()Color {return _bgggfg ._bdfg };

// AddSection adds a new content section at the end of the invoice.
func (_baeed *Invoice )AddSection (title ,content string ){_baeed ._faeb =append (_baeed ._faeb ,[2]string {title ,content });};

// SetBorderOpacity sets the border opacity.
func (_ceec *Polygon )SetBorderOpacity (opacity float64 ){_ceec ._fbfb =opacity };

// LineWidth returns the width of the line.
func (_dgcd *Line )LineWidth ()float64 {return _dgcd ._cdae };func _bgc (_cdbe _ag .ChartRenderable )*Chart {return &Chart {_cedg :_cdbe ,_egg :PositionRelative ,_feeca :Margins {Top :10,Bottom :10}};};func (_feba *TableCell )width (_fagcg []float64 ,_cfbe float64 )float64 {_abfgc :=float64 (0.0);
for _ecfg :=0;_ecfg < _feba ._ebbb ;_ecfg ++{_abfgc +=_fagcg [_feba ._dbbgc +_ecfg -1];};return _abfgc *_cfbe ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_eebb rune ;_gdaf []error ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_aaefb *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _aaefb ._bdga ==nil {if _gfga :=_aaefb .makeXObject ();_gfga !=nil {return nil ,ctx ,_gfga ;};};var _bcaa []*Block ;_begg :=ctx ;_adag :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _aaefb ._ddca .IsRelative (){_aaefb .applyFitMode (ctx .Width );ctx .X +=_aaefb ._ddbd .Left ;ctx .Y +=_aaefb ._ddbd .Top ;ctx .Width -=_aaefb ._ddbd .Left +_aaefb ._ddbd .Right ;ctx .Height -=_aaefb ._ddbd .Top +_aaefb ._ddbd .Bottom ;if _aaefb ._afea > ctx .Height {_bcaa =append (_bcaa ,_adag );
_adag =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gaab :=ctx ;_gaab .Y =ctx .Margins .Top +_aaefb ._ddbd .Top ;_gaab .X =ctx .Margins .Left +_aaefb ._ddbd .Left ;_gaab .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_aaefb ._ddbd .Top -_aaefb ._ddbd .Bottom ;
_gaab .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_aaefb ._ddbd .Left -_aaefb ._ddbd .Right ;ctx =_gaab ;};}else {ctx .X =_aaefb ._cffa ;ctx .Y =_aaefb ._aefac ;};ctx ,_aeffe :=_edbb (_adag ,_aaefb ,ctx );if _aeffe !=nil {return nil ,ctx ,_aeffe ;
};_bcaa =append (_bcaa ,_adag );if _aaefb ._ddca .IsAbsolute (){ctx =_begg ;}else {ctx .X =_begg .X ;ctx .Width =_begg .Width ;ctx .Y +=_aaefb ._ddbd .Bottom ;};return _bcaa ,ctx ,nil ;};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;
AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// Height returns the height of the graphic svg.
func (_bcgcg *GraphicSVG )Height ()float64 {return _bcgcg ._age .Height };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_ffcfc *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgdc :=ctx ;var _acgg []*Block ;_bgef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ffcfc ._bdag .IsRelative (){ctx .X +=_ffcfc ._bgeb .Left ;ctx .Y +=_ffcfc ._bgeb .Top ;
ctx .Width -=_ffcfc ._bgeb .Left +_ffcfc ._bgeb .Right ;ctx .Height -=_ffcfc ._bgeb .Top ;_ffcfc .SetWidth (ctx .Width );if _ffcfc .Height ()> ctx .Height {_acgg =append (_acgg ,_bgef );_bgef =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_edae :=ctx ;
_edae .Y =ctx .Margins .Top ;_edae .X =ctx .Margins .Left +_ffcfc ._bgeb .Left ;_edae .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_edae .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ffcfc ._bgeb .Left -_ffcfc ._bgeb .Right ;
ctx =_edae ;};}else {if int (_ffcfc ._cagbag )<=0{_ffcfc .SetWidth (_ffcfc .getTextWidth ());};ctx .X =_ffcfc ._eedf ;ctx .Y =_ffcfc ._gaba ;};ctx ,_aaddeg :=_dcfe (_bgef ,_ffcfc ,ctx );if _aaddeg !=nil {_ce .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_aaddeg );
return nil ,ctx ,_aaddeg ;};_acgg =append (_acgg ,_bgef );if _ffcfc ._bdag .IsRelative (){ctx .Y +=_ffcfc ._bgeb .Bottom ;ctx .Height -=_ffcfc ._bgeb .Bottom ;if !ctx .Inline {ctx .X =_cgdc .X ;ctx .Width =_cgdc .Width ;};return _acgg ,ctx ,nil ;};return _acgg ,_cgdc ,nil ;
};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_bgfb *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_bgfb ._aaefc .Left =left ;_bgfb ._aaefc .Right =right ;_bgfb ._aaefc .Top =top ;_bgfb ._aaefc .Bottom =bottom ;};

// SetWidthRight sets border width for right.
func (_gag *border )SetWidthRight (bw float64 ){_gag ._dfa =bw };func _eabcb (_dbaf Color ,_fcaba float64 )*ColorPoint {return &ColorPoint {_fddb :_dbaf ,_gcgc :_fcaba }};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_aab *Block )SetMargins (left ,right ,top ,bottom float64 ){_aab ._ge .Left =left ;_aab ._ge .Right =right ;_aab ._ge .Top =top ;_aab ._ge .Bottom =bottom ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;
);

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// Width returns Image's document width.
func (_aebe *Image )Width ()float64 {return _aebe ._ddce };func _cbgfe (_cddcd *_gf .Decoder )(int ,int ){return 0,0};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_egca *Image )ScaleToWidth (w float64 ){_ddbb :=_egca ._afea /_egca ._ddce ;_egca ._ddce =w ;_egca ._afea =w *_ddbb ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_cbcda *Invoice )AddressHeadingStyle ()TextStyle {return _cbcda ._bccad };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_dfg *Chapter )SetShowNumbering (show bool ){_dfg ._bcfg =show ;_dfg ._bbeg .SetText (_dfg .headingText ());};

// Positioning returns the type of positioning the line is set to use.
func (_cadcc *Line )Positioning ()Positioning {return _cadcc ._baga };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_ccfd float64 ;_fbbgd float64 ;_fede float64 ;_bdea float64 ;_daba Color ;_dfbd _ad .LineStyle ;_bcfb float64 ;_feeec []int64 ;_dbec int64 ;_cdae float64 ;_baga Positioning ;_bbgf FitMode ;_fgbea Margins ;};func (_bfead *TextChunk )clone ()*TextChunk {_ebgad :=*_bfead ;
_ebgad ._eafe =_befeb (_bfead ._eafe );return &_ebgad ;};type fontMetrics struct{_dafeg float64 ;_dfabf float64 ;_fgffa float64 ;_gabca float64 ;};func (_febge *Invoice )newCell (_abgc string ,_dfcf InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_dfcf ,_abgc };
};func (_gde *Image )applyFitMode (_gbeb float64 ){_gbeb -=_gde ._ddbd .Left +_gde ._ddbd .Right ;switch _gde ._gbdc {case FitModeFillWidth :_gde .ScaleToWidth (_gbeb );};};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_bgdfe *LinearShading )AddShadingResource (block *Block )(_dcab _e .PdfObjectName ,_cccg error ){_dcadf :=1;_dcab =_e .PdfObjectName ("\u0053\u0068"+_gcc .Itoa (_dcadf ));for block ._ddc .HasShadingByName (_dcab ){_dcadf ++;_dcab =_e .PdfObjectName ("\u0053\u0068"+_gcc .Itoa (_dcadf ));
};if _efcc :=block ._ddc .SetShadingByName (_dcab ,_bgdfe .shadingModel ().ToPdfObject ());_efcc !=nil {return "",_efcc ;};return _dcab ,nil ;};

// RotatedSize returns the width and height of the rotated block.
func (_ab *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_acf ,_edg :=_dfdbbc (_ab ._ff ,_ab ._cb ,_ab ._eb );return _acf ,_edg ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_dddda *LinearShading )SetExtends (start bool ,end bool ){_dddda ._cgfe .SetExtends (start ,end )};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aegge *Paragraph )SetTextAlignment (align TextAlignment ){_aegge ._bcdbb =align };

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_cdfg *Rectangle )SetCoords (x ,y float64 ){_cdfg ._ddge =x ;_cdfg ._gead =y };func (_faedf *templateProcessor )parseEllipse (_cegb *templateNode )(interface{},error ){_dabeb :=_faedf .creator .NewEllipse (0,0,0,0);for _ ,_acbad :=range _cegb ._gcbdb .Attr {_egbca :=_acbad .Value ;
switch _abdfa :=_acbad .Name .Local ;_abdfa {case "\u0063\u0078":_dabeb ._eadc =_faedf .parseFloatAttr (_abdfa ,_egbca );case "\u0063\u0079":_dabeb ._ffaga =_faedf .parseFloatAttr (_abdfa ,_egbca );case "\u0077\u0069\u0064t\u0068":_dabeb .SetWidth (_faedf .parseFloatAttr (_abdfa ,_egbca ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_dabeb .SetHeight (_faedf .parseFloatAttr (_abdfa ,_egbca ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dabeb .SetFillColor (_faedf .parseColorAttr (_abdfa ,_egbca ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_dabeb .SetFillOpacity (_faedf .parseFloatAttr (_abdfa ,_egbca ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dabeb .SetBorderColor (_faedf .parseColorAttr (_abdfa ,_egbca ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_dabeb .SetBorderOpacity (_faedf .parseFloatAttr (_abdfa ,_egbca ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_dabeb .SetBorderWidth (_faedf .parseFloatAttr (_abdfa ,_egbca ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dabeb .SetPositioning (_faedf .parsePositioningAttr (_abdfa ,_egbca ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dabeb .SetFitMode (_faedf .parseFitModeAttr (_abdfa ,_egbca ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_efgbe :=_faedf .parseMarginAttr (_abdfa ,_egbca );_dabeb .SetMargins (_efgbe .Left ,_efgbe .Right ,_efgbe .Top ,_efgbe .Bottom );
default:_faedf .nodeLogDebug (_cegb ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_abdfa );
};};return _dabeb ,nil ;};func _cgcbg (_ecgec *templateProcessor ,_gdcdb *templateNode )(interface{},error ){return _ecgec .parseBackground (_gdcdb );};var (_eggbfg =_c .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");
_ffdbd =_b .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");_fgcf =_b .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");
_cebe =_b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");_dggcgg =_b .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e");
);type shading struct{_egfd Color ;_acef bool ;_cfddb []bool ;_gdee []*ColorPoint ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_ccbf *StyledParagraph )SetTextAlignment (align TextAlignment ){_ccbf ._bfad =align };

// Scale scales the rectangle dimensions by the specified factors.
func (_bbeb *Rectangle )Scale (xFactor ,yFactor float64 ){_bbeb ._dbda =xFactor *_bbeb ._dbda ;_bbeb ._agfc =yFactor *_bbeb ._agfc ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ageb *TOC )SetLineStyle (style TextStyle ){_ageb .SetLineNumberStyle (style );_ageb .SetLineTitleStyle (style );_ageb .SetLineSeparatorStyle (style );_ageb .SetLinePageStyle (style );};

// Width returns the Block's width.
func (_acg *Block )Width ()float64 {return _acg ._ff };

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_gdad *Creator )Flip (flipH ,flipV bool )error {_babb :=_gdad .getActivePage ();if _babb ==nil {return _b .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_beg ,_feac :=_gdad ._bdae [_babb ];if !_feac {_beg =&pageTransformations {};
_gdad ._bdae [_babb ]=_beg ;};_beg ._gdaa =flipH ;_beg ._bdgd =flipV ;return nil ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_fcdf *StyledParagraph )SetText (text string )*TextChunk {_fcdf .Reset ();return _fcdf .Append (text );};

// SetFillColor sets the fill color.
func (_acdc *Polygon )SetFillColor (color Color ){_acdc ._abaa =color ;_acdc ._cgdec .FillColor =_adb (color );};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _fdabe (svgStr )};func (_eaea *templateProcessor )parseListItem (_dfcd *templateNode )(interface{},error ){if _dfcd ._fedefc ==nil {_eaea .nodeLogError (_dfcd ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_fgcf ;};_ffgca ,_eceg :=_dfcd ._fedefc ._ebabb .(*List );if !_eceg {_eaea .nodeLogError (_dfcd ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_fgcf ;};_fdbaa :=_cead ();_fdbaa ._fcac =_ffgca ._dbfb ;return _fdbaa ,nil ;};

// SetFontSize sets the font size in document units (points).
func (_fbaa *Paragraph )SetFontSize (fontSize float64 ){_fbaa ._ffbe =fontSize };func (_cdbc *templateProcessor )parsePageBreak (_deda *templateNode )(interface{},error ){return _ccce (),nil ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_fbd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_fbd ._fegf =toc ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// Style returns the style of the line.
func (_gfac *Line )Style ()_ad .LineStyle {return _gfac ._dfbd };func _acgf (_caff []_ad .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_gbgb :&_ad .PolyBezierCurve {Curves :_caff ,BorderColor :_aa .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_abbb :1.0,_babg :1.0};
};func (_afg *Block )addContents (_fa *_ae .ContentStreamOperations ){_afg ._aae .WrapIfNeeded ();_fa .WrapIfNeeded ();*_afg ._aae =append (*_afg ._aae ,*_fa ...);};func _bedc (_cgfa []byte )(*Image ,error ){_ffeb :=_a .NewReader (_cgfa );_deaa ,_bfge :=_aa .ImageHandling .Read (_ffeb );
if _bfge !=nil {_ce .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bfge );return nil ,_bfge ;};return _dcce (_deaa );};

// SetBorderColor sets the border color of the ellipse.
func (_ffe *Ellipse )SetBorderColor (col Color ){_ffe ._bdfg =col };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_fbcd *Creator )NewPolyBezierCurve (curves []_ad .CubicBezierCurve )*PolyBezierCurve {return _acgf (curves );};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_ecdaa *TOCLine )SetLink (page int64 ,x ,y float64 ){_ecdaa ._gfece =x ;_ecdaa ._gedabe =y ;_ecdaa ._gggf =page ;_febdd :=_ecdaa ._eggfe ._fbga .Color ;_ecdaa .Number .Style .Color =_febdd ;_ecdaa .Title .Style .Color =_febdd ;_ecdaa .Separator .Style .Color =_febdd ;
_ecdaa .Page .Style .Color =_febdd ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_bcgb *Invoice )TitleStyle ()TextStyle {return _bcgb ._bfdb };

// SetTotal sets the total of the invoice.
func (_fbca *Invoice )SetTotal (value string ){_fbca ._fcbe [1].Value =value };func _ccgf (_fabbc ,_afegb ,_dabab TextChunk ,_acbgbd uint ,_ebge TextStyle )*TOCLine {_bbdab :=_fbfg (_ebge );_bbdab .SetEnableWrap (true );_bbdab .SetTextAlignment (TextAlignmentLeft );
_bbdab .SetMargins (0,0,2,2);_ecffb :=&TOCLine {_eggfe :_bbdab ,Number :_fabbc ,Title :_afegb ,Page :_dabab ,Separator :TextChunk {Text :"\u002e",Style :_ebge },_fbedc :0,_edac :_acbgbd ,_cfeda :10,_caagcg :PositionRelative };_bbdab ._gcdca .Left =_ecffb ._fbedc +float64 (_ecffb ._edac -1)*_ecffb ._cfeda ;
_bbdab ._ceda =_ecffb .prepareParagraph ;return _ecffb ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;
TextRenderingModeClip ;);

// SetMargins sets the Table's left, right, top, bottom margins.
func (_adagg *Table )SetMargins (left ,right ,top ,bottom float64 ){_adagg ._dafge .Left =left ;_adagg ._dafge .Right =right ;_adagg ._dafge .Top =top ;_adagg ._dafge .Bottom =bottom ;};func _acccg (_fgaca *templateProcessor ,_fgcbfe *templateNode )(interface{},error ){return _fgaca .parseTable (_fgcbfe );
};

// SetStyle sets the style of the line (solid or dashed).
func (_dafc *Line )SetStyle (style _ad .LineStyle ){_dafc ._dfbd =style };

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_cdfb *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _efede (xc ,yc ,width ,height );};func _aecbe (_deff *Creator ,_bdgade _bd .Reader ,_bbaba interface{},_bbebc *TemplateOptions ,_gffaf componentRenderer )error {if _deff ==nil {_ce .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _ffdbd ;};_dgfeb :="";if _fcaf ,_aaeaa :=_bdgade .(*_d .File );_aaeaa {_dgfeb =_fcaf .Name ();};_gfgb :=_a .NewBuffer (nil );if _ ,_acgba :=_bd .Copy (_gfgb ,_bdgade );_acgba !=nil {return _acgba ;};_egada :=_bc .FuncMap {"\u0064\u0069\u0063\u0074":_ccaaa };
if _bbebc !=nil &&_bbebc .HelperFuncMap !=nil {for _afcgb ,_efaa :=range _bbebc .HelperFuncMap {if _ ,_dcdce :=_egada [_afcgb ];_dcdce {_ce .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_afcgb );
continue ;};_egada [_afcgb ]=_efaa ;};};_bggcb ,_dabecd :=_bc .New ("").Funcs (_egada ).Parse (_gfgb .String ());if _dabecd !=nil {return _dabecd ;};if _bbebc !=nil &&_bbebc .SubtemplateMap !=nil {for _cfegd ,_bcgf :=range _bbebc .SubtemplateMap {if _cfegd ==""{_ce .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _bcgf ==nil {_ce .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_dabecc :=_a .NewBuffer (nil );if _ ,_dage :=_bd .Copy (_dabecc ,_bcgf );_dage !=nil {return _dage ;};if _ ,_cbec :=_bggcb .New (_cfegd ).Parse (_dabecc .String ());_cbec !=nil {return _cbec ;};};};_gfgb .Reset ();if _abbe :=_bggcb .Execute (_gfgb ,_bbaba );
_abbe !=nil {return _abbe ;};return _adafg (_deff ,_dgfeb ,_gfgb .Bytes (),_bbebc ,_gffaf ).run ();};

// SetCoords sets the center coordinates of the ellipse.
func (_cbcg *Ellipse )SetCoords (xc ,yc float64 ){_cbcg ._eadc =xc ;_cbcg ._ffaga =yc };type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_gdcad *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gdcad ._feeca .Left ,_gdcad ._feeca .Right ,_gdcad ._feeca .Top ,_gdcad ._feeca .Bottom ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_cabc *TOCLine )LevelOffset ()float64 {return _cabc ._cfeda };

// NewFilledCurve returns a instance of filled curve.
func (_fbbd *Creator )NewFilledCurve ()*FilledCurve {return _agfg ()};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };
);

// SetRowHeight sets the height for a specified row.
func (_adbea *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_adbea ._ecdda ){return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adbea ._ecdda [row -1]=h ;return nil ;
};func (_dbdd *List )markerWidth ()float64 {var _fdec float64 ;for _ ,_daab :=range _dbdd ._dbedd {_geefa :=_fbfg (_dbdd ._gbfgg );_geefa .SetEnableWrap (false );_geefa .SetTextAlignment (TextAlignmentRight );_geefa .Append (_daab ._fcac .Text ).Style =_daab ._fcac .Style ;
_ffdb :=_geefa .getTextWidth ()/1000.0;if _fdec < _ffdb {_fdec =_ffdb ;};};return _fdec ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_gaf *Chapter )GetHeading ()*Paragraph {return _gaf ._bbeg };

// Title returns the title of the invoice.
func (_gfdbd *Invoice )Title ()string {return _gfdbd ._cagb };func (_gcaca *Table )wrapRow (_ggaa int ,_edgd DrawContext ,_cdceb float64 )(bool ,error ){if !_gcaca ._cggd {return false ,nil ;};var (_fdcfg =_gcaca ._dfaeg [_ggaa ];_dbeae =-1;_bfbb []*TableCell ;
_geabd float64 ;_gccaf bool ;_cbdd =make ([]float64 ,0,len (_gcaca ._bdbga )););_afff :=func (_fbgaf *TableCell ,_bggdb VectorDrawable ,_dcdgg bool )*TableCell {_feaea :=*_fbgaf ;_feaea ._afgge =_bggdb ;if _dcdgg {_feaea ._afefg ++;};return &_feaea ;};
_bfcf :=func (_ccaga int ,_cgfd VectorDrawable ){var _gaggg float64 =-1;if _cgfd ==nil {if _cegab :=_cbdd [_ccaga -_ggaa ];_cegab > _edgd .Height {_cgfd =_gcaca ._dfaeg [_ccaga ]._afgge ;_gcaca ._dfaeg [_ccaga ]._afgge =nil ;_cbdd [_ccaga -_ggaa ]=0;_gaggg =_cegab ;
};};_dafgeg :=_afff (_gcaca ._dfaeg [_ccaga ],_cgfd ,true );_bfbb =append (_bfbb ,_dafgeg );if _gaggg < 0{_gaggg =_dafgeg .height (_edgd .Width );};if _gaggg > _geabd {_geabd =_gaggg ;};};for _gcggc :=_ggaa ;_gcggc < len (_gcaca ._dfaeg );_gcggc ++{_gbcf :=_gcaca ._dfaeg [_gcggc ];
if _fdcfg ._afefg !=_gbcf ._afefg {_dbeae =_gcggc ;break ;};_edgd .Width =_gbcf .width (_gcaca ._bdbga ,_cdceb );_ggdaf :=_gbcf .height (_edgd .Width );var _agceb VectorDrawable ;switch _dbfcb :=_gbcf ._afgge .(type ){case *StyledParagraph :if _ggdaf > _edgd .Height {_ecee :=_edgd ;
_ecee .Height =_bcb .Floor (_edgd .Height -_dbfcb ._gcdca .Top -_dbfcb ._gcdca .Bottom -0.5*_dbfcb .getTextHeight ());_fggaf ,_edcab ,_fecfe :=_dbfcb .split (_ecee );if _fecfe !=nil {return false ,_fecfe ;};if _fggaf !=nil &&_edcab !=nil {_dbfcb =_fggaf ;
_gbcf =_afff (_gbcf ,_fggaf ,false );_gcaca ._dfaeg [_gcggc ]=_gbcf ;_agceb =_edcab ;_gccaf =true ;};_ggdaf =_gbcf .height (_edgd .Width );};case *Division :if _ggdaf > _edgd .Height {_acfg :=_edgd ;_acfg .Height =_bcb .Floor (_edgd .Height -_dbfcb ._cgf .Top -_dbfcb ._cgf .Bottom );
_gecd ,_fdbgb :=_dbfcb .split (_acfg );if _gecd !=nil &&_fdbgb !=nil {_dbfcb =_gecd ;_gbcf =_afff (_gbcf ,_gecd ,false );_gcaca ._dfaeg [_gcggc ]=_gbcf ;_agceb =_fdbgb ;_gccaf =true ;if _gecd ._bede !=nil {_gecd ._bede .BorderRadiusBottomLeft =0;_gecd ._bede .BorderRadiusBottomRight =0;
};if _fdbgb ._bede !=nil {_fdbgb ._bede .BorderRadiusTopLeft =0;_fdbgb ._bede .BorderRadiusTopRight =0;};_ggdaf =_gbcf .height (_edgd .Width );};};case *List :if _ggdaf > _edgd .Height {_cbac :=_edgd ;_cbac .Height =_bcb .Floor (_edgd .Height -_dbfcb ._aade .Vertical ());
_dbbgf ,_eede :=_dbfcb .split (_cbac );if _dbbgf !=nil {_dbfcb =_dbbgf ;_gbcf =_afff (_gbcf ,_dbbgf ,false );_gcaca ._dfaeg [_gcggc ]=_gbcf ;};if _eede !=nil {_agceb =_eede ;_gccaf =true ;};_ggdaf =_gbcf .height (_edgd .Width );};};_cbdd =append (_cbdd ,_ggdaf );
if _gccaf {if _bfbb ==nil {_bfbb =make ([]*TableCell ,0,len (_gcaca ._bdbga ));for _geacg :=_ggaa ;_geacg < _gcggc ;_geacg ++{_bfcf (_geacg ,nil );};};_bfcf (_gcggc ,_agceb );};};var _ddea float64 ;for _ ,_bedb :=range _cbdd {if _bedb > _ddea {_ddea =_bedb ;
};};if _gccaf &&_ddea < _edgd .Height {if _dbeae < 0{_dbeae =len (_gcaca ._dfaeg );};_dabec :=_gcaca ._dfaeg [_dbeae -1]._afefg +_gcaca ._dfaeg [_dbeae -1]._dgfd -1;for _cggb :=_dbeae ;_cggb < len (_gcaca ._dfaeg );_cggb ++{_gcaca ._dfaeg [_cggb ]._afefg ++;
};_gcaca ._dfaeg =append (_gcaca ._dfaeg [:_dbeae ],append (_bfbb ,_gcaca ._dfaeg [_dbeae :]...)...);_gcaca ._ecdda =append (_gcaca ._ecdda [:_dabec ],append ([]float64 {_geabd },_gcaca ._ecdda [_dabec :]...)...);_gcaca ._ecdda [_fdcfg ._afefg +_fdcfg ._dgfd -2]=_ddea ;
};return _gccaf ,nil ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_cgef *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cgef ._dafge .Left ,_cgef ._dafge .Right ,_cgef ._dafge .Top ,_cgef ._dafge .Bottom ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;
TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_abafg *Table )MultiRowCell (rowspan int )*TableCell {return _abafg .MultiCell (rowspan ,1)};

// SetTerms sets the terms and conditions section of the invoice.
func (_gggbg *Invoice )SetTerms (title ,content string ){_gggbg ._cef =[2]string {title ,content }};

// DashPattern returns the dash pattern of the line.
func (_bfbe *Line )DashPattern ()(_gcfb []int64 ,_gdafa int64 ){return _bfbe ._feeec ,_bfbe ._dbec };func (_gddb *StyledParagraph )getTextHeight ()float64 {var _eaace float64 ;for _ ,_ceea :=range _gddb ._fcfcf {_ecce :=_ceea .Style .FontSize *_gddb ._ffafa ;
if _ecce > _eaace {_eaace =_ecce ;};};return _eaace ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;func (_ddab *templateProcessor )parseTextVerticalAlignmentAttr (_fcgca ,_ceed string )TextVerticalAlignment {_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fcgca ,_ceed );
_daef :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_ceed ];return _daef ;};

// NewTable create a new Table with a specified number of columns.
func (_dbee *Creator )NewTable (cols int )*Table {return _baea (cols )};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_fbce *RadialShading )AddPatternResource (block *Block )(_ebgb _e .PdfObjectName ,_fedff error ){_eggg :=1;_bgcea :=_e .PdfObjectName ("\u0050"+_gcc .Itoa (_eggg ));for block ._ddc .HasPatternByName (_bgcea ){_eggg ++;_bgcea =_e .PdfObjectName ("\u0050"+_gcc .Itoa (_eggg ));
};if _gceg :=block ._ddc .SetPatternByName (_bgcea ,_fbce .ToPdfShadingPattern ().ToPdfObject ());_gceg !=nil {return "",_gceg ;};return _bgcea ,nil ;};

// Cols returns the total number of columns the table has.
func (_gabfd *Table )Cols ()int {return _gabfd ._abdae };

// GeneratePageBlocks draw graphic svg into block.
func (_fggg *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eabb :=ctx ;_aceg :=_fggg ._eddc .IsRelative ();var _fdcf []*Block ;if _aceg {_fgde :=1.0;_eddb :=_fggg ._baac .Top ;if _fggg ._age .Height > ctx .Height -_fggg ._baac .Top {_fdcf =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _decf error ;if _ ,ctx ,_decf =_ccce ().GeneratePageBlocks (ctx );_decf !=nil {return nil ,ctx ,_decf ;};_eddb =0;};ctx .X +=_fggg ._baac .Left +_fgde ;ctx .Y +=_eddb ;ctx .Width -=_fggg ._baac .Left +_fggg ._baac .Right +2*_fgde ;ctx .Height -=_eddb ;
}else {ctx .X =_fggg ._ggaf ;ctx .Y =_fggg ._bcac ;};_gaac :=_ae .NewContentCreator ();_gaac .Translate (0,ctx .PageHeight );_gaac .Scale (1,-1);_gaac .Translate (ctx .X ,ctx .Y );_edfc :=_fggg ._age .Width /_fggg ._age .ViewBox .W ;_bad :=_fggg ._age .Height /_fggg ._age .ViewBox .H ;
_edga :=_fggg ._ggaf -(_fggg ._age .ViewBox .X *_bcb .Max (_edfc ,_bad ));_ffb :=_fggg ._bcac -(_fggg ._age .ViewBox .Y *_bcb .Max (_edfc ,_bad ));_fggg ._age .ToContentCreator (_gaac ,_edfc ,_bad ,_edga ,_ffb );_bgaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _gfed :=_bgaf .addContentsByString (_gaac .String ());_gfed !=nil {return nil ,ctx ,_gfed ;};if _aceg {_gcbbc :=_fggg .Height ()+_fggg ._baac .Bottom ;ctx .Y +=_gcbbc ;ctx .Height -=_gcbbc ;}else {ctx =_eabb ;};_fdcf =append (_fdcf ,_bgaf );return _fdcf ,ctx ,nil ;
};

// SetTitleStyle sets the style properties of the invoice title.
func (_gfgac *Invoice )SetTitleStyle (style TextStyle ){_gfgac ._bfdb =style };

// SetHeight sets the height of the ellipse.
func (_aecc *Ellipse )SetHeight (height float64 ){_aecc ._dceeg =height };func _dgdbc (_gbfb *templateProcessor ,_efggb *templateNode )(interface{},error ){return _gbfb .parseChart (_efggb );};func (_gbgg *templateProcessor )parseBoolAttr (_ccaa ,_cegbf string )bool {_ce .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ccaa ,_cegbf );
_agbeb ,_ :=_gcc .ParseBool (_cegbf );return _cegbf ==""||_agbeb ;};func _befeb (_adgg *_aa .PdfAnnotation )*_aa .PdfAnnotation {if _adgg ==nil {return nil ;};var _bbedb *_aa .PdfAnnotation ;switch _bbagd :=_adgg .GetContext ().(type ){case *_aa .PdfAnnotationLink :if _eedbbb :=_caegc (_bbagd );
_eedbbb !=nil {_bbedb =_eedbbb .PdfAnnotation ;};};return _bbedb ;};func (_gaadb *Invoice )generateHeaderBlocks (_ddcd DrawContext )([]*Block ,DrawContext ,error ){_ffgc :=_fbfg (_gaadb ._bfdb );_ffgc .SetEnableWrap (true );_ffgc .Append (_gaadb ._cagb );
_bdeb :=_baea (2);if _gaadb ._fafe !=nil {_bafb :=_bdeb .NewCell ();_bafb .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bafb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bafb .SetIndent (0);_bafb .SetContent (_gaadb ._fafe );_gaadb ._fafe .ScaleToHeight (_ffgc .Height ()+20);
}else {_bdeb .SkipCells (1);};_gcdae :=_bdeb .NewCell ();_gcdae .SetHorizontalAlignment (CellHorizontalAlignmentRight );_gcdae .SetVerticalAlignment (CellVerticalAlignmentMiddle );_gcdae .SetContent (_ffgc );return _bdeb .GeneratePageBlocks (_ddcd );};


// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_edcd *GraphicSVG )ScaleToWidth (w float64 ){_eggf :=_edcd ._age .Height /_edcd ._age .Width ;_edcd ._age .Width =w ;_edcd ._age .Height =w *_eggf ;_edcd ._age .SetScaling (_eggf ,_eggf );};

// AddColorStop add color stop info for rendering gradient color.
func (_gcfge *RadialShading )AddColorStop (color Color ,point float64 ){_gcfge ._dagf .AddColorStop (color ,point );};func (_bcdf *Invoice )drawAddress (_bafc *InvoiceAddress )[]*StyledParagraph {var _gdbf []*StyledParagraph ;if _bafc .Heading !=""{_fedf :=_fbfg (_bcdf ._efefb );
_fedf .SetMargins (0,0,0,7);_fedf .Append (_bafc .Heading );_gdbf =append (_gdbf ,_fedf );};_babf :=_fbfg (_bcdf ._edba );_babf .SetLineHeight (1.2);_gbff :=_bafc .Separator ;if _gbff ==""{_gbff =_bcdf ._dfaf ;};_fbbbf :=_bafc .City ;if _bafc .State !=""{if _fbbbf !=""{_fbbbf +=_gbff ;
};_fbbbf +=_bafc .State ;};if _bafc .Zip !=""{if _fbbbf !=""{_fbbbf +=_gbff ;};_fbbbf +=_bafc .Zip ;};if _bafc .Name !=""{_babf .Append (_bafc .Name +"\u000a");};if _bafc .Street !=""{_babf .Append (_bafc .Street +"\u000a");};if _bafc .Street2 !=""{_babf .Append (_bafc .Street2 +"\u000a");
};if _fbbbf !=""{_babf .Append (_fbbbf +"\u000a");};if _bafc .Country !=""{_babf .Append (_bafc .Country +"\u000a");};_geca :=_fbfg (_bcdf ._edba );_geca .SetLineHeight (1.2);_geca .SetMargins (0,0,7,0);if _bafc .Phone !=""{_geca .Append (_bafc .fmtLine (_bafc .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_bafc .HidePhoneLabel ));
};if _bafc .Email !=""{_geca .Append (_bafc .fmtLine (_bafc .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_bafc .HideEmailLabel ));};_gdbf =append (_gdbf ,_babf ,_geca );return _gdbf ;};func _geea (_fbac *_de .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_age :_fbac ,_eddc :PositionRelative ,_baac :Margins {Top :10,Bottom :10}},nil ;
};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_dacb *Ellipse )FillOpacity ()float64 {return _dacb ._bce };func (_dafgg *templateProcessor )parseTextChunk (_aabbd *templateNode ,_fabb *TextChunk )(interface{},error ){if _aabbd ._fedefc ==nil {_dafgg .nodeLogError (_aabbd ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_fgcf ;};var (_dgeba =_dafgg .creator .NewTextStyle ();_dgdb bool ;);for _ ,_deadc :=range _aabbd ._gcbdb .Attr {if _deadc .Name .Local =="\u006c\u0069\u006e\u006b"{_cfgdd ,_ebba :=_aabbd ._fedefc ._ebabb .(*StyledParagraph );if !_ebba {_dafgg .nodeLogError (_aabbd ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_dgdb =true ;}else {_dgeba =_cfgdd ._fbga ;};break ;};};if _fabb ==nil {_fabb =NewTextChunk ("",_dgeba );};for _ ,_dgafbf :=range _aabbd ._gcbdb .Attr {_dcfbd :=_dgafbf .Value ;switch _bagc :=_dgafbf .Name .Local ;_bagc {case "\u0063\u006f\u006co\u0072":_fabb .Style .Color =_dafgg .parseColorAttr (_bagc ,_dcfbd );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_fabb .Style .OutlineColor =_dafgg .parseColorAttr (_bagc ,_dcfbd );case "\u0066\u006f\u006e\u0074":_fabb .Style .Font =_dafgg .parseFontAttr (_bagc ,_dcfbd );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_fabb .Style .FontSize =_dafgg .parseFloatAttr (_bagc ,_dcfbd );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_fabb .Style .OutlineSize =_dafgg .parseFloatAttr (_bagc ,_dcfbd );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_fabb .Style .CharSpacing =_dafgg .parseFloatAttr (_bagc ,_dcfbd );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_fabb .Style .HorizontalScaling =_dafgg .parseFloatAttr (_bagc ,_dcfbd );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_fabb .Style .RenderingMode =_dafgg .parseTextRenderingModeAttr (_bagc ,_dcfbd );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_fabb .Style .Underline =_dafgg .parseBoolAttr (_bagc ,_dcfbd );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_fabb .Style .UnderlineStyle .Color =_dafgg .parseColorAttr (_bagc ,_dcfbd );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_fabb .Style .UnderlineStyle .Offset =_dafgg .parseFloatAttr (_bagc ,_dcfbd );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_fabb .Style .UnderlineStyle .Thickness =_dafgg .parseFloatAttr (_bagc ,_dcfbd );
case "\u006c\u0069\u006e\u006b":if !_dgdb {_fabb ._eafe =_dafgg .parseLinkAttr (_bagc ,_dcfbd );};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_fabb .Style .TextRise =_dafgg .parseFloatAttr (_bagc ,_dcfbd );default:_dafgg .nodeLogDebug (_aabbd ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_bagc );
};};return _fabb ,nil ;};

// SetDate sets the date of the invoice.
func (_eggfd *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_eggfd ._gaad [1].Value =date ;return _eggfd ._gaad [0],_eggfd ._gaad [1];};

// NewSubchapter creates a new child chapter with the specified title.
func (_cded *Chapter )NewSubchapter (title string )*Chapter {_eabd :=_geddb (_cded ._bbeg ._gacgc );_eabd .FontSize =14;_cded ._egfa ++;_gfgg :=_fde (_cded ,_cded ._egfag ,_cded ._eef ,title ,_cded ._egfa ,_eabd );_cded .Add (_gfgg );return _gfgg ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_dfad *Division )EnablePageWrap (enable bool ){_dfad ._bgba =enable };

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_eddbc *Rectangle )Height ()float64 {return _eddbc ._agfc };

// SetBorderWidth sets the border width.
func (_fgag *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_fgag ._gbgb .BorderWidth =borderWidth ;};

// SetFillColor sets the fill color.
func (_cabg *CurvePolygon )SetFillColor (color Color ){_cabg ._fbbbb =color ;_cabg ._cbda .FillColor =_adb (color );};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_gefbb *TableCell )SetBorderLineStyle (style _ad .LineStyle ){_gefbb ._fegfe =style };func _geddb (_afgeg *_aa .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_afgeg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_fbgg *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_ffga *_aa .PdfWriter )error ){_fbgg ._ggba =pdfWriterAccessFunc ;};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_gedce *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gedce ._baac .Left ,_gedce ._baac .Right ,_gedce ._baac .Top ,_gedce ._baac .Bottom ;};func (_dgaae *templateProcessor )addNodeText (_gcabf *templateNode ,_gedge string )error {_cdfe :=_gcabf ._ebabb ;
if _cdfe ==nil {return nil ;};switch _efdd :=_cdfe .(type ){case *TextChunk :_efdd .Text =_gedge ;case *Paragraph :switch _gcabf ._gcbdb .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _gcabf ._fedefc !=nil {if _agfe ,_fdefe :=_gcabf ._fedefc ._ebabb .(*Chapter );
_fdefe {_agfe ._gcca =_gedge ;_efdd .SetText (_agfe .headingText ());};};default:_efdd .SetText (_gedge );};};return nil ;};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetPositioning sets the positioning of the line (absolute or relative).
func (_fbgd *Line )SetPositioning (positioning Positioning ){_fbgd ._baga =positioning };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_ebbga *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdbg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_deaf ,_gggec :=_fdbg .setOpacity (_ebbga ._abbb ,_ebbga ._babg );if _gggec !=nil {return nil ,ctx ,_gggec ;
};_dggcg :=_ebbga ._gbgb ;_dggcg .FillEnabled =_dggcg .FillColor !=nil ;var (_gebg =ctx .PageHeight ;_gddf =_dggcg .Curves ;_ffgbe =make ([]_ad .CubicBezierCurve ,0,len (_dggcg .Curves )););_bccc :=_aa .PdfRectangle {};for _aaea :=range _dggcg .Curves {_ddebb :=_gddf [_aaea ];
_ddebb .P0 .Y =_gebg -_ddebb .P0 .Y ;_ddebb .P1 .Y =_gebg -_ddebb .P1 .Y ;_ddebb .P2 .Y =_gebg -_ddebb .P2 .Y ;_ddebb .P3 .Y =_gebg -_ddebb .P3 .Y ;_ffgbe =append (_ffgbe ,_ddebb );_aadea :=_ddebb .GetBounds ();if _aaea ==0{_bccc =_aadea ;}else {_bccc .Llx =_bcb .Min (_bccc .Llx ,_aadea .Llx );
_bccc .Lly =_bcb .Min (_bccc .Lly ,_aadea .Lly );_bccc .Urx =_bcb .Max (_bccc .Urx ,_aadea .Urx );_bccc .Ury =_bcb .Max (_bccc .Ury ,_aadea .Ury );};};_dggcg .Curves =_ffgbe ;defer func (){_dggcg .Curves =_gddf }();if _dggcg .FillEnabled {_eagae :=_effg (_fdbg ,_ebbga ._gbgb .FillColor ,_ebbga ._afgcf ,func ()Rectangle {return Rectangle {_ddge :_bccc .Llx ,_gead :_bccc .Lly ,_dbda :_bccc .Width (),_agfc :_bccc .Height ()};
});if _eagae !=nil {return nil ,ctx ,_eagae ;};};_cged ,_ ,_gggec :=_dggcg .Draw (_deaf );if _gggec !=nil {return nil ,ctx ,_gggec ;};if _gggec =_fdbg .addContentsByString (string (_cged ));_gggec !=nil {return nil ,ctx ,_gggec ;};return []*Block {_fdbg },ctx ,nil ;
};func (_bagd *Ellipse )applyFitMode (_fgec float64 ){_fgec -=_bagd ._geab .Left +_bagd ._geab .Right ;switch _bagd ._efgb {case FitModeFillWidth :_bagd .ScaleToWidth (_fgec );};};

// GetCoords returns coordinates of border.
func (_cbaf *border )GetCoords ()(float64 ,float64 ){return _cbaf ._accf ,_cbaf ._eec };func (_dgda cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_dfeg :=_dgda ._agcb ;return 1-(_dgda ._dec *(1-_dfeg )+_dfeg ),1-(_dgda ._fbfcd *(1-_dfeg )+_dfeg ),1-(_dgda ._gbd *(1-_dfeg )+_dfeg );
};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_bbec *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _dafa (x1 ,y1 ,x2 ,y2 )};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_eaebb *Paragraph )SetMaxLines (maxLines int ){_eaebb ._cecg =maxLines ;_eaebb .wrapText ()};func (_badfa *TableCell )cloneProps (_ddga VectorDrawable )*TableCell {_eegab :=*_badfa ;_eegab ._afgge =_ddga ;return &_eegab ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_edabg *StyledParagraph )Height ()float64 {_edabg .wrapText ();var _dbfe float64 ;for _ ,_bfea :=range _edabg ._gaca {var _ffcd float64 ;for _ ,_gcdec :=range _bfea {_agag :=_edabg ._ffafa *_gcdec .Style .FontSize ;if _agag > _ffcd {_ffcd =_agag ;
};};_dbfe +=_ffcd ;};return _dbfe ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_agfcc *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgab :=ctx ;var _baafc []*Block ;_fgccb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _agfcc ._bfgcf .IsRelative (){ctx .X +=_agfcc ._gcdca .Left ;ctx .Y +=_agfcc ._gcdca .Top ;
ctx .Width -=_agfcc ._gcdca .Left +_agfcc ._gcdca .Right ;ctx .Height -=_agfcc ._gcdca .Top ;_agfcc .SetWidth (ctx .Width );}else {if int (_agfcc ._fffe )<=0{_agfcc .SetWidth (_agfcc .getTextWidth ()/1000.0);};ctx .X =_agfcc ._aedfg ;ctx .Y =_agfcc ._afgd ;
};if _agfcc ._ceda !=nil {_agfcc ._ceda (_agfcc ,ctx );};if _gcbd :=_agfcc .wrapText ();_gcbd !=nil {return nil ,ctx ,_gcbd ;};_fefeg :=_agfcc ._gaca ;for {_ebdc ,_afde ,_fbgf :=_fggb (_fgccb ,_agfcc ,_fefeg ,ctx );if _fbgf !=nil {_ce .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbgf );
return nil ,ctx ,_fbgf ;};ctx =_ebdc ;_baafc =append (_baafc ,_fgccb );if _fefeg =_afde ;len (_afde )==0{break ;};_fgccb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ebdc =ctx ;_ebdc .Y =ctx .Margins .Top ;_ebdc .X =ctx .Margins .Left +_agfcc ._gcdca .Left ;
_ebdc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_ebdc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_agfcc ._gcdca .Left -_agfcc ._gcdca .Right ;ctx =_ebdc ;};if _agfcc ._bfgcf .IsRelative (){ctx .Y +=_agfcc ._gcdca .Bottom ;
ctx .Height -=_agfcc ._gcdca .Bottom ;if !ctx .Inline {ctx .X =_cgab .X ;ctx .Width =_cgab .Width ;};return _baafc ,ctx ,nil ;};return _baafc ,_cgab ,nil ;};func (_fbfd *templateProcessor )getNodeErrorLocation (_dgbfg *templateNode ,_gdebg string ,_daeg ...interface{})string {_bcfac :=_f .Sprintf (_gdebg ,_daeg ...);
_edbcd :=_f .Sprintf ("\u0025\u0064",_dgbfg ._dfag );if _dgbfg ._gfaad !=0{_edbcd =_f .Sprintf ("\u0025\u0064\u003a%\u0064",_dgbfg ._gfaad ,_dgbfg ._gfacg );};if _fbfd ._dgbff !=""{return _f .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_bcfac ,_fbfd ._dgbff ,_edbcd );
};return _f .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_bcfac ,_edbcd );};func _gcbcg (_bbgg _be .Image )(*Image ,error ){_dfba ,_bbfa :=_aa .ImageHandling .NewImageFromGoImage (_bbgg );if _bbfa !=nil {return nil ,_bbfa ;};return _dcce (_dfba );
};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_fgaa []VectorDrawable ;_gbgf Positioning ;_cgf Margins ;_fgfc Margins ;_dcfb bool ;_bgba bool ;_bede *Background ;};func (_fcff *listItem )ctxHeight (_gagf float64 )float64 {var _cfddd float64 ;switch _fggc :=_fcff ._cbcgc .(type ){case *Paragraph :if _fggc ._eeda {_fggc .SetWidth (_gagf -_fggc ._bgeb .Horizontal ());
};_cfddd =_fggc .Height ()+_fggc ._bgeb .Vertical ();_cfddd +=0.5*_fggc ._ffbe *_fggc ._gabb ;case *StyledParagraph :if _fggc ._eacd {_fggc .SetWidth (_gagf -_fggc ._gcdca .Horizontal ());};_cfddd =_fggc .Height ()+_fggc ._gcdca .Vertical ();_cfddd +=0.5*_fggc .getTextHeight ();
case *List :_dfec :=_gagf -_fcff ._fcac .Width ()-_fggc ._aade .Horizontal ()-_fggc ._ecbc ;_cfddd =_fggc .ctxHeight (_dfec )+_fggc ._aade .Vertical ();case *Image :_cfddd =_fggc .Height ()+_fggc ._ddbd .Vertical ();case *Division :_aecf :=_gagf -_fcff ._fcac .Width ()-_fggc ._cgf .Horizontal ();
_cfddd =_fggc .ctxHeight (_aecf )+_fggc ._cgf .Vertical ();case *Table :_bggbc :=_gagf -_fcff ._fcac .Width ()-_fggc ._dafge .Horizontal ();_fggc .updateRowHeights (_bggbc );_cfddd =_fggc .Height ()+_fggc ._dafge .Vertical ();default:_cfddd =_fcff ._cbcgc .Height ();
};return _cfddd ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_gggga *shading )SetAntiAlias (enable bool ){_gggga ._acef =enable };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_eafe *_aa .PdfAnnotation ;_dgef bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _eae ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_fed :=&Creator {};_fed ._agfa =[]*_aa .PdfPage {};_fed ._abfg =map[*_aa .PdfPage ]*Block {};_fed ._bdae =map[*_aa .PdfPage ]*pageTransformations {};_fed .SetPageSize (PageSizeLetter );
_adbd :=0.1*_fed ._fddd ;_fed ._bag .Left =_adbd ;_fed ._bag .Right =_adbd ;_fed ._bag .Top =_adbd ;_fed ._bag .Bottom =_adbd ;var _ddcg error ;_fed ._edbc ,_ddcg =_aa .NewStandard14Font (_aa .HelveticaName );if _ddcg !=nil {_fed ._edbc =_aa .DefaultFont ();
};_fed ._eff ,_ddcg =_aa .NewStandard14Font (_aa .HelveticaBoldName );if _ddcg !=nil {_fed ._edbc =_aa .DefaultFont ();};_fed ._fegf =_fed .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_fed .AddOutlines =true ;
_fed ._gcdce =_aa .NewOutline ();_fc .TrackUse (_eae );return _fed ;};

// SetMargins sets the Paragraph's margins.
func (_ecdf *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_ecdf ._bgeb .Left =left ;_ecdf ._bgeb .Right =right ;_ecdf ._bgeb .Top =top ;_ecdf ._bgeb .Bottom =bottom ;};

// Scale block by specified factors in the x and y directions.
func (_abg *Block )Scale (sx ,sy float64 ){_gbg :=_ae .NewContentCreator ().Scale (sx ,sy ).Operations ();*_abg ._aae =append (*_gbg ,*_abg ._aae ...);_abg ._aae .WrapIfNeeded ();_abg ._ff *=sx ;_abg ._cb *=sy ;};func _bggc ()*Division {return &Division {_bgba :true }};
var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0);
);func (_cage *List )split (_bfac DrawContext )(_fbdb ,_ggec *List ){var (_egad float64 ;_gadc ,_eccb []*listItem ;);_gbabe :=_bfac .Width -_cage ._aade .Horizontal ()-_cage ._ecbc -_cage .markerWidth ();_aefd :=_cage .markerWidth ();for _fcfg ,_dgaf :=range _cage ._dbedd {_gdcc :=_dgaf .ctxHeight (_gbabe );
_egad +=_gdcc ;if _egad <=_bfac .Height {_gadc =append (_gadc ,_dgaf );}else {switch _decfb :=_dgaf ._cbcgc .(type ){case *List :_gfcb :=_bfac ;_gfcb .Height =_bcb .Floor (_gdcc -(_egad -_bfac .Height ));_dbcb ,_fbfaa :=_decfb .split (_gfcb );if _dbcb !=nil {_bedg :=_cead ();
_bedg ._fcac =_dgaf ._fcac ;_bedg ._cbcgc =_dbcb ;_gadc =append (_gadc ,_bedg );};if _fbfaa !=nil {_ddcbd :=_decfb ._dbfb .Style .FontSize ;_faeg ,_fabd :=_decfb ._dbfb .Style .Font .GetRuneMetrics (' ');if _fabd {_ddcbd =_decfb ._dbfb .Style .FontSize *_faeg .Wx *_decfb ._dbfb .Style .horizontalScale ()/1000.0;
};_ebga :=_gc .Repeat ("\u0020",int (_aefd /_ddcbd ));_aece :=_cead ();_aece ._fcac =*NewTextChunk (_ebga ,_decfb ._dbfb .Style );_aece ._cbcgc =_fbfaa ;_eccb =append (_eccb ,_aece );_eccb =append (_eccb ,_cage ._dbedd [_fcfg +1:]...);};default:_eccb =_cage ._dbedd [_fcfg :];
};if len (_eccb )> 0{break ;};};};if len (_gadc )> 0{_fbdb =_fcdg (_cage ._gbfgg );*_fbdb =*_cage ;_fbdb ._dbedd =_gadc ;};if len (_eccb )> 0{_ggec =_fcdg (_cage ._gbfgg );*_ggec =*_cage ;_ggec ._dbedd =_eccb ;};return _fbdb ,_ggec ;};func (_fegd *templateProcessor )parseLinearGradientAttr (creator *Creator ,_fdefea string )Color {_eddba :=ColorBlack ;
if _fdefea ==""{return _eddba ;};_eccdc :=creator .NewLinearGradientColor ([]*ColorPoint {});_eccdc .SetExtends (true ,true );var (_fdddb =_gc .Split (_fdefea [16:len (_fdefea )-1],"\u002c");_feeed =_gc .TrimSpace (_fdddb [0]););if _gc .HasSuffix (_feeed ,"\u0064\u0065\u0067"){_baefa ,_abbaa :=_gcc .ParseFloat (_feeed [:len (_feeed )-3],64);
if _abbaa !=nil {_ce .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_abbaa );}else {_eccdc .SetAngle (_baefa );
};_fdddb =_fdddb [1:];};_cbfee ,_aabg :=_fegd .processGradientColorPair (_fdddb );if _cbfee ==nil ||_aabg ==nil {return _eddba ;};for _efce :=0;_efce < len (_cbfee );_efce ++{_eccdc .AddColorStop (_cbfee [_efce ],_aabg [_efce ]);};return _eccdc ;};

// FitMode returns the fit mode of the image.
func (_ega *Image )FitMode ()FitMode {return _ega ._gbdc };

// NewCellProps returns the default properties of an invoice cell.
func (_cfec *Invoice )NewCellProps ()InvoiceCellProps {_adc :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_cfec ._ebea ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_adc ,BorderColor :_adc ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetMargins sets the Paragraph's margins.
func (_fbggc *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_fbggc ._gcdca .Left =left ;_fbggc ._gcdca .Right =right ;_fbggc ._gcdca .Top =top ;_fbggc ._gcdca .Bottom =bottom ;};

// SetFillColor sets the fill color of the ellipse.
func (_fbda *Ellipse )SetFillColor (col Color ){_fbda ._ffde =col };

// Height returns the Block's height.
func (_gg *Block )Height ()float64 {return _gg ._cb };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_cegd *TOC )SetHeading (text string ,style TextStyle ){_abcdbd :=_cegd .Heading ();_abcdbd .Reset ();_gdbga :=_abcdbd .Append (text );_gdbga .Style =style ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_fbff *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_fbff ._feeec =dashArray ;_fbff ._dbec =dashPhase ;};func _cdgg (_acbgb *templateProcessor ,_gedde *templateNode )(interface{},error ){return _acbgb .parseChapter (_gedde );};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_gfa *Block )ScaleToHeight (h float64 ){_fgc :=h /_gfa ._cb ;_gfa .Scale (_fgc ,_fgc )};

// SetNotes sets the notes section of the invoice.
func (_edca *Invoice )SetNotes (title ,content string ){_edca ._eegf =[2]string {title ,content }};

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// SetDueDate sets the due date of the invoice.
func (_fbad *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_fbad ._agef [1].Value =dueDate ;return _fbad ._agef [0],_fbad ._agef [1];};

// SetBorderOpacity sets the border opacity.
func (_dbaac *CurvePolygon )SetBorderOpacity (opacity float64 ){_dbaac ._ccgef =opacity };

// SkipRows skips over a specified number of rows in the table.
func (_affca *Table )SkipRows (num int ){_gcgec :=num *_affca ._abdae -1;if _gcgec < 0{_ce .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_affca ._fdagd +=_gcgec ;};

// NewImageFromData creates an Image from image data.
func (_begd *Creator )NewImageFromData (data []byte )(*Image ,error ){return _bedc (data )};func _edbb (_eaef *Block ,_dbce *Image ,_dga DrawContext )(DrawContext ,error ){_degd :=_dga ;_eega :=1;_degdf :=_e .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_eega ));
for _eaef ._ddc .HasXObjectByName (_degdf ){_eega ++;_degdf =_e .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_eega ));};_cgbaf :=_eaef ._ddc .SetXObjectImageByName (_degdf ,_dbce ._bdga );if _cgbaf !=nil {return _dga ,_cgbaf ;};_aafc :=0;_cgag :=_e .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_aafc ));
for _eaef ._ddc .HasExtGState (_cgag ){_aafc ++;_cgag =_e .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_aafc ));};_dcfc :=_e .MakeDict ();_dcfc .Set ("\u0042\u004d",_e .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _dbce ._bgda < 1.0{_dcfc .Set ("\u0043\u0041",_e .MakeFloat (_dbce ._bgda ));
_dcfc .Set ("\u0063\u0061",_e .MakeFloat (_dbce ._bgda ));};_cgbaf =_eaef ._ddc .AddExtGState (_cgag ,_e .MakeIndirectObject (_dcfc ));if _cgbaf !=nil {return _dga ,_cgbaf ;};_dabf :=_dbce .Width ();_afbe :=_dbce .Height ();_ ,_dcga :=_dbce .rotatedSize ();
_cebd :=_dga .X ;_adee :=_dga .PageHeight -_dga .Y -_afbe ;if _dbce ._ddca .IsRelative (){_adee -=(_dcga -_afbe )/2;switch _dbce ._adf {case HorizontalAlignmentCenter :_cebd +=(_dga .Width -_dabf )/2;case HorizontalAlignmentRight :_cebd =_dga .PageWidth -_dga .Margins .Right -_dbce ._ddbd .Right -_dabf ;
};};_bdfb :=_dbce ._ggggg ;_bacf :=_ae .NewContentCreator ();_bacf .Add_gs (_cgag );_bacf .Translate (_cebd ,_adee );if _bdfb !=0{_bacf .Translate (_dabf /2,_afbe /2);_bacf .RotateDeg (_bdfb );_bacf .Translate (-_dabf /2,-_afbe /2);};_bacf .Scale (_dabf ,_afbe ).Add_Do (_degdf );
_dfdb :=_bacf .Operations ();_dfdb .WrapIfNeeded ();_eaef .addContents (_dfdb );if _dbce ._ddca .IsRelative (){_dga .Y +=_dcga ;_dga .Height -=_dcga ;return _dga ,nil ;};return _degd ,nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func (_agdb *templateProcessor )parseList (_dcdcg *templateNode )(interface{},error ){_bgee :=_agdb .creator .NewList ();for _ ,_eaag :=range _dcdcg ._gcbdb .Attr {_bdbaf :=_eaag .Value ;switch _bcfdc :=_eaag .Name .Local ;
_bcfdc {case "\u0069\u006e\u0064\u0065\u006e\u0074":_bgee .SetIndent (_agdb .parseFloatAttr (_bcfdc ,_bdbaf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bcgga :=_agdb .parseMarginAttr (_bcfdc ,_bdbaf );_bgee .SetMargins (_bcgga .Left ,_bcgga .Right ,_bcgga .Top ,_bcgga .Bottom );
default:_agdb .nodeLogDebug (_dcdcg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bcfdc );
};};return _bgee ,nil ;};

// SetBorderWidth sets the border width.
func (_gdgg *Polygon )SetBorderWidth (borderWidth float64 ){_gdgg ._cgdec .BorderWidth =borderWidth };

// TextAlignment options for paragraph.
type TextAlignment int ;func (_ecage *StyledParagraph )getLineMetrics (_dcefd int )(_gfdfg ,_fedef ,_bafg float64 ){if _ecage ._gaca ==nil ||len (_ecage ._gaca )==0{_ecage .wrapText ();};if _dcefd < 0||_dcefd > len (_ecage ._gaca )-1{_ce .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_dcefd );
return 0,0,0;};_cbgf :=_ecage ._gaca [_dcefd ];for _ ,_eagf :=range _cbgf {_baef :=_fcee (_eagf .Style .Font ,_eagf .Style .FontSize );if _baef ._dafeg > _gfdfg {_gfdfg =_baef ._dafeg ;};if _baef ._gabca < _bafg {_bafg =_baef ._gabca ;};if _dedb :=_eagf .Style .FontSize ;
_dedb > _fedef {_fedef =_dedb ;};};return _gfdfg ,_fedef ,_bafg ;};

// Context returns the current drawing context.
func (_gaea *Creator )Context ()DrawContext {return _gaea ._aaa };func _dcfe (_afaf *Block ,_bbdcf *Paragraph ,_efafa DrawContext )(DrawContext ,error ){_gddc :=1;_dbdb :=_e .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gcc .Itoa (_gddc ));for _afaf ._ddc .HasFontByName (_dbdb ){_gddc ++;
_dbdb =_e .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gcc .Itoa (_gddc ));};_bbabg :=_afaf ._ddc .SetFontByName (_dbdb ,_bbdcf ._gacgc .ToPdfObject ());if _bbabg !=nil {return _efafa ,_bbabg ;};_bbdcf .wrapText ();_ecbb :=_ae .NewContentCreator ();_ecbb .Add_q ();
_agff :=_efafa .PageHeight -_efafa .Y -_bbdcf ._ffbe *_bbdcf ._gabb ;_ecbb .Translate (_efafa .X ,_agff );if _bbdcf ._ggbaf !=0{_ecbb .RotateDeg (_bbdcf ._ggbaf );};_bcgd :=_adb (_bbdcf ._bdfge );_bbabg =_effg (_afaf ,_bcgd ,_bbdcf ._bdfge ,func ()Rectangle {return Rectangle {_ddge :_efafa .X ,_gead :_agff ,_dbda :_bbdcf .getMaxLineWidth ()/1000.0,_agfc :_bbdcf .Height ()};
});if _bbabg !=nil {return _efafa ,_bbabg ;};_ecbb .Add_BT ().SetNonStrokingColor (_bcgd ).Add_Tf (_dbdb ,_bbdcf ._ffbe ).Add_TL (_bbdcf ._ffbe *_bbdcf ._gabb );for _gfbg ,_cagf :=range _bbdcf ._agac {if _gfbg !=0{_ecbb .Add_Tstar ();};_edaf :=[]rune (_cagf );
_gfdff :=0.0;_bdcg :=0;for _bceg ,_dgdag :=range _edaf {if _dgdag ==' '{_bdcg ++;continue ;};if _dgdag =='\u000A'{continue ;};_ddgc ,_ffdfb :=_bbdcf ._gacgc .GetRuneMetrics (_dgdag );if !_ffdfb {_ce .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_bceg ,_dgdag ,_dgdag ,_bbdcf ._gacgc .BaseFont (),_bbdcf ._gacgc .Subtype ());
return _efafa ,_b .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_gfdff +=_bbdcf ._ffbe *_ddgc .Wx ;};var _fdga []_e .PdfObject ;_gbdgf ,_gcdf :=_bbdcf ._gacgc .GetRuneMetrics (' ');
if !_gcdf {return _efafa ,_b .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_aeffd :=_gbdgf .Wx ;switch _bbdcf ._bcdbb {case TextAlignmentJustify :if _bdcg > 0&&_gfbg < len (_bbdcf ._agac )-1{_aeffd =(_bbdcf ._cagbag *1000.0-_gfdff )/float64 (_bdcg )/_bbdcf ._ffbe ;
};case TextAlignmentCenter :_dgddg :=_gfdff +float64 (_bdcg )*_aeffd *_bbdcf ._ffbe ;_ddag :=(_bbdcf ._cagbag *1000.0-_dgddg )/2/_bbdcf ._ffbe ;_fdga =append (_fdga ,_e .MakeFloat (-_ddag ));case TextAlignmentRight :_ccfac :=_gfdff +float64 (_bdcg )*_aeffd *_bbdcf ._ffbe ;
_gffe :=(_bbdcf ._cagbag *1000.0-_ccfac )/_bbdcf ._ffbe ;_fdga =append (_fdga ,_e .MakeFloat (-_gffe ));};_ffgac :=_bbdcf ._gacgc .Encoder ();var _fbgdd []byte ;for _ ,_cfcgc :=range _edaf {if _cfcgc =='\u000A'{continue ;};if _cfcgc ==' '{if len (_fbgdd )> 0{_fdga =append (_fdga ,_e .MakeStringFromBytes (_fbgdd ));
_fbgdd =nil ;};_fdga =append (_fdga ,_e .MakeFloat (-_aeffd ));}else {if _ ,_dcgf :=_ffgac .RuneToCharcode (_cfcgc );!_dcgf {_bbabg =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cfcgc ,_cfcgc ),Rune :_cfcgc };
_efafa ._gdaf =append (_efafa ._gdaf ,_bbabg );_ce .Log .Debug (_bbabg .Error ());if _efafa ._eebb <=0{continue ;};_cfcgc =_efafa ._eebb ;};_fbgdd =append (_fbgdd ,_ffgac .Encode (string (_cfcgc ))...);};};if len (_fbgdd )> 0{_fdga =append (_fdga ,_e .MakeStringFromBytes (_fbgdd ));
};_ecbb .Add_TJ (_fdga ...);};_ecbb .Add_ET ();_ecbb .Add_Q ();_ddff :=_ecbb .Operations ();_ddff .WrapIfNeeded ();_afaf .addContents (_ddff );if _bbdcf ._bdag .IsRelative (){_abeg :=_bbdcf .Height ();_efafa .Y +=_abeg ;_efafa .Height -=_abeg ;if _efafa .Inline {_efafa .X +=_bbdcf .Width ()+_bbdcf ._bgeb .Right ;
};};return _efafa ,nil ;};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_egba *Image )SetFitMode (fitMode FitMode ){_egba ._gbdc =fitMode };

// SetLineHeight sets the line height (1.0 default).
func (_gfcbb *Paragraph )SetLineHeight (lineheight float64 ){_gfcbb ._gabb =lineheight };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cfffb *Invoice )NoteHeadingStyle ()TextStyle {return _cfffb ._gegbe };

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_cgfe *shading ;_cbaa *_aa .PdfRectangle ;_eadf float64 ;};

// GetOptimizer returns current PDF optimizer.
func (_dabe *Creator )GetOptimizer ()_aa .Optimizer {return _dabe ._aga };func (_ffec *templateProcessor )parseLineStyleAttr (_ggccf ,_eegg string )_ad .LineStyle {_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ggccf ,_eegg );
_gbed :=map[string ]_ad .LineStyle {"\u0073\u006f\u006ci\u0064":_ad .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_ad .LineStyleDashed }[_eegg ];return _gbed ;};

// Lines returns all the lines the table of contents has.
func (_geedee *TOC )Lines ()[]*TOCLine {return _geedee ._cdabg };

// NewList creates a new list.
func (_gbe *Creator )NewList ()*List {return _fcdg (_gbe .NewTextStyle ())};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_baaf *Line )Width ()float64 {return _bcb .Abs (_baaf ._fede -_baaf ._ccfd )};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_bcde *Rectangle )BorderOpacity ()float64 {return _bcde ._gfdfab };

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _eabcb (color ,point )};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_eggfe *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_fbedc float64 ;_edac uint ;_cfeda float64 ;_caagcg Positioning ;_gfece float64 ;_gedabe float64 ;_gggf int64 ;};

// CreateFrontPage sets a function to generate a front Page.
func (_eda *Creator )CreateFrontPage (genFrontPageFunc func (_cbcd FrontpageFunctionArgs )){_eda ._accb =genFrontPageFunc ;};func _agfg ()*FilledCurve {_dgdd :=FilledCurve {};_dgdd ._fgdbf =[]_ad .CubicBezierCurve {};return &_dgdd ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_abac *FilledCurve )AppendCurve (curve _ad .CubicBezierCurve )*FilledCurve {_abac ._fgdbf =append (_abac ._fgdbf ,curve );return _abac ;};func _gafbd (_eagfd *templateProcessor ,_bffga *templateNode )(interface{},error ){return _eagfd .parseStyledParagraph (_bffga );
};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_ddfg *Table )Width ()float64 {return 0};

// TOC returns the table of contents component of the creator.
func (_gee *Creator )TOC ()*TOC {return _gee ._fegf };func (_addef *templateProcessor )parseMarginAttr (_aacf ,_eggff string )Margins {_ce .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_aacf ,_eggff );
_eafgg :=Margins {};switch _egcf :=_gc .Fields (_eggff );len (_egcf ){case 1:_eafgg .Top ,_ =_gcc .ParseFloat (_egcf [0],64);_eafgg .Bottom =_eafgg .Top ;_eafgg .Left =_eafgg .Top ;_eafgg .Right =_eafgg .Top ;case 2:_eafgg .Top ,_ =_gcc .ParseFloat (_egcf [0],64);
_eafgg .Bottom =_eafgg .Top ;_eafgg .Left ,_ =_gcc .ParseFloat (_egcf [1],64);_eafgg .Right =_eafgg .Left ;case 3:_eafgg .Top ,_ =_gcc .ParseFloat (_egcf [0],64);_eafgg .Left ,_ =_gcc .ParseFloat (_egcf [1],64);_eafgg .Right =_eafgg .Left ;_eafgg .Bottom ,_ =_gcc .ParseFloat (_egcf [2],64);
case 4:_eafgg .Top ,_ =_gcc .ParseFloat (_egcf [0],64);_eafgg .Right ,_ =_gcc .ParseFloat (_egcf [1],64);_eafgg .Bottom ,_ =_gcc .ParseFloat (_egcf [2],64);_eafgg .Left ,_ =_gcc .ParseFloat (_egcf [3],64);};return _eafgg ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_dbef :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_ce .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dbef ;
};var _cfgc ,_ccd ,_def int ;if len (hexStr )==4{var _dgggb ,_dagd ,_cfaa int ;_fccf ,_cgb :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_dgggb ,&_dagd ,&_cfaa );if _cgb !=nil {_ce .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_cgb );
return _dbef ;};if _fccf !=3{_ce .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dbef ;};_cfgc =_dgggb *16+_dgggb ;_ccd =_dagd *16+_dagd ;_def =_cfaa *16+_cfaa ;}else {_geag ,_fdab :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_cfgc ,&_ccd ,&_def );
if _fdab !=nil {_ce .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dbef ;};if _geag !=3{_ce .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_geag );
return _dbef ;};};_adgd :=float64 (_cfgc )/255.0;_gebe :=float64 (_ccd )/255.0;_gffg :=float64 (_def )/255.0;_dbef ._bdg =_adgd ;_dbef ._cbcf =_gebe ;_dbef ._bgdf =_gffg ;return _dbef ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_fg *Block )AddAnnotation (annotation *_aa .PdfAnnotation ){for _ ,_cdc :=range _fg ._af {if _cdc ==annotation {return ;};};_fg ._af =append (_fg ._af ,annotation );};func _abcdb (_dgbdg [][]_ad .Point )*Polygon {return &Polygon {_cgdec :&_ad .Polygon {Points :_dgbdg },_ebgd :1.0,_fbfb :1.0};
};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_dbedd []*listItem ;_aade Margins ;_dbfb TextChunk ;_ecbc float64 ;_aadde bool ;_afbd Positioning ;_gbfgg TextStyle ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_bdga *_aa .XObjectImage ;_dcbd *_aa .Image ;_ggggg float64 ;_ddce ,_afea float64 ;_acde ,_fcbf float64 ;_ddca Positioning ;_adf HorizontalAlignment ;_cffa float64 ;_aefac float64 ;_bgda float64 ;_ddbd Margins ;_ddaf ,_gcabc float64 ;
_bbaf _e .StreamEncoder ;_gbdc FitMode ;};

// SetBorderRadius sets the radius of the rectangle corners.
func (_gdaaa *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_gdaaa ._cbdb =topLeft ;_gdaaa ._agda =topRight ;_gdaaa ._efde =bottomLeft ;_gdaaa ._eadce =bottomRight ;};func (_ggcd *Table )getLastCellFromCol (_aedfe int )(int ,*TableCell ){for _dgaad :=len (_ggcd ._dfaeg )-1;
_dgaad >=0;_dgaad --{if _ggcd ._dfaeg [_dgaad ]._dbbgc ==_aedfe {return _dgaad ,_ggcd ._dfaeg [_dgaad ];};};return 0,nil ;};func (_beb *InvoiceAddress )fmtLine (_ffeg ,_bggce string ,_cdcg bool )string {if _cdcg {_bggce ="";};return _f .Sprintf ("\u0025\u0073\u0025s\u000a",_bggce ,_ffeg );
};func (_gdcd *templateProcessor )parseInt64Attr (_adcc ,_ebbgb string )int64 {_ce .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_adcc ,_ebbgb );
_dfccf ,_ :=_gcc .ParseInt (_ebbgb ,10,64);return _dfccf ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_faga *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _b .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _b .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _b .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_faga ._cbab =true ;_faga ._dacd =startRow ;_faga ._geaaf =endRow ;return nil ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_cedg _ag .ChartRenderable ;_egg Positioning ;_ccbb float64 ;_abd float64 ;_feeca Margins ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gcdaf *Invoice )SetAddressStyle (style TextStyle ){_gcdaf ._edba =style };

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_bbabge *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_bbabge ._cgeag =&_aa .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func (_dgdc *templateProcessor )parsePositioningAttr (_fdece ,_afad string )Positioning {_ce .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fdece ,_afad );
_ggfd :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_afad ];return _ggfd ;};

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_adcf *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _adcf ._ebgg .Left ,_adcf ._ebgg .Right ,_adcf ._ebgg .Top ,_adcf ._ebgg .Bottom ;};func (_ddae *StyledParagraph )appendChunk (_agfd *TextChunk )*TextChunk {_ddae ._fcfcf =append (_ddae ._fcfcf ,_agfd );
_ddae .wrapText ();return _agfd ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_babee *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func (_fddba *StyledParagraph )getMaxLineWidth ()float64 {if _fddba ._gaca ==nil ||len (_fddba ._gaca )==0{_fddba .wrapText ();};var _ffafc float64 ;for _ ,_bffa :=range _fddba ._gaca {_bead :=_fddba .getTextLineWidth (_bffa );
if _bead > _ffafc {_ffafc =_bead ;};};return _ffafc ;};

// String implements error interface.
func (_gacg UnsupportedRuneError )Error ()string {return _gacg .Message };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bcacc *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_eagg :=NewTextChunk (text ,_bcacc ._fbga );_eagg ._eafe =_fbgcc (page -1,x ,y ,zoom );return _bcacc .appendChunk (_eagg );};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_eggb *Ellipse )SetPositioning (position Positioning ){_eggb ._bgdc =position };

// SetAngle sets the rotation angle in degrees.
func (_gccc *Block )SetAngle (angleDeg float64 ){_gccc ._eb =angleDeg };

// SetIndent sets the left offset of the list when nested into another list.
func (_edcc *List )SetIndent (indent float64 ){_edcc ._ecbc =indent ;_edcc ._aadde =false };func (_cbcb *templateProcessor )parseRadialGradientAttr (creator *Creator ,_dgcg string )Color {_dadc :=ColorBlack ;if _dgcg ==""{return _dadc ;};var (_eaggg error ;
_cfedbc =0.0;_ebfg =0.0;_deafd =-1.0;_ecggc =_gc .Split (_dgcg [16:len (_dgcg )-1],"\u002c"););_cfdc :=_gc .Fields (_ecggc [0]);if len (_cfdc )==2&&_gc .TrimSpace (_cfdc [0])[0]!='#'{_cfedbc ,_eaggg =_gcc .ParseFloat (_cfdc [0],64);if _eaggg !=nil {_ce .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_eaggg );
};_ebfg ,_eaggg =_gcc .ParseFloat (_cfdc [1],64);if _eaggg !=nil {_ce .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_eaggg );
};_ecggc =_ecggc [1:];};_aedbc :=_gc .TrimSpace (_ecggc [0]);if _aedbc [0]!='#'{_deafd ,_eaggg =_gcc .ParseFloat (_aedbc ,64);if _eaggg !=nil {_ce .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_eaggg );
};_ecggc =_ecggc [1:];};_dagef ,_eagdb :=_cbcb .processGradientColorPair (_ecggc );if _dagef ==nil ||_eagdb ==nil {return _dadc ;};_afab :=creator .NewRadialGradientColor (_cfedbc ,_ebfg ,0,_deafd ,[]*ColorPoint {});for _abcgc :=0;_abcgc < len (_dagef );
_abcgc ++{_afab .AddColorStop (_dagef [_abcgc ],_eagdb [_abcgc ]);};return _afab ;};

// BorderWidth returns the border width of the rectangle.
func (_deed *Rectangle )BorderWidth ()float64 {return _deed ._bcceg };

// SetFillColor sets the fill color.
func (_dded *PolyBezierCurve )SetFillColor (color Color ){_dded ._afgcf =color ;_dded ._gbgb .FillColor =_adb (color );};func _gdcag (_efaec *templateProcessor ,_gbcae *templateNode )(interface{},error ){return _efaec .parseListItem (_gbcae );};func (_cafdf *templateProcessor )parseHorizontalAlignmentAttr (_cfdddc ,_fgbg string )HorizontalAlignment {_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_cfdddc ,_fgbg );
_deba :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_fgbg ];return _deba ;};func (_gfd *Block )transform (_gae _dc .Matrix ){_gfdd :=_ae .NewContentCreator ().Add_cm (_gae [0],_gae [1],_gae [3],_gae [4],_gae [6],_gae [7]).Operations ();
*_gfd ._aae =append (*_gfdd ,*_gfd ._aae ...);_gfd ._aae .WrapIfNeeded ();};

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_dfed *GraphicSVG )ScaleToHeight (h float64 ){_bbfc :=_dfed ._age .Width /_dfed ._age .Height ;_dfed ._age .Height =h ;_dfed ._age .Width =h *_bbfc ;_dfed ._age .SetScaling (_bbfc ,_bbfc );};

// DrawWithContext draws the Block using the specified drawing context.
func (_eg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_ec ,_ ,_ddcc :=d .GeneratePageBlocks (ctx );if _ddcc !=nil {return _ddcc ;};if len (_ec )!=1{return _b .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
};for _ ,_dgg :=range _ec {if _gdca :=_eg .mergeBlocks (_dgg );_gdca !=nil {return _gdca ;};};return nil ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_dgc *Creator )CreateTableOfContents (genTOCFunc func (_ddcb *TOC )error ){_dgc ._gecc =genTOCFunc ;};

// NewCell returns a new invoice table cell.
func (_fecc *Invoice )NewCell (value string )*InvoiceCell {return _fecc .newCell (value ,_fecc .NewCellProps ());};

// Width returns the width of the Paragraph.
func (_gacbc *Paragraph )Width ()float64 {if _gacbc ._eeda &&int (_gacbc ._cagbag )> 0{return _gacbc ._cagbag ;};return _gacbc .getTextWidth ()/1000.0;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_geddd *Line )SetFitMode (fitMode FitMode ){_geddd ._bbgf =fitMode };func (_cfca *Paragraph )getTextWidth ()float64 {_fcab :=0.0;for _ ,_bbba :=range _cfca ._adad {if _bbba =='\u000A'{continue ;};_dgcf ,_egbb :=_cfca ._gacgc .GetRuneMetrics (_bbba );
if !_egbb {_ce .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bbba ,_bbba );
return -1;};_fcab +=_cfca ._ffbe *_dgcf .Wx ;};return _fcab ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_gacc *Image )SetPos (x ,y float64 ){_gacc ._ddca =PositionAbsolute ;_gacc ._cffa =x ;_gacc ._aefac =y ;};

// SetStyleLeft sets border style for left side.
func (_aee *border )SetStyleLeft (style CellBorderStyle ){_aee ._bgea =style };func (_fgca *Table )moveToNextAvailableCell ()int {_dfde :=(_fgca ._fdagd -1)%(_fgca ._abdae )+1;for {if _dfde -1>=len (_fgca ._adaf ){if _fgca ._adaf [0]==0{return _dfde ;};
_dfde =1;}else if _fgca ._adaf [_dfde -1]==0{return _dfde ;};_fgca ._fdagd ++;_fgca ._adaf [_dfde -1]--;_dfde ++;};};

// Height returns Image's document height.
func (_bddg *Image )Height ()float64 {return _bddg ._afea };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_gdcba *TOC )SetLineLevelOffset (levelOffset float64 ){_gdcba ._geadb =levelOffset };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// BorderColor returns the border color of the rectangle.
func (_badfe *Rectangle )BorderColor ()Color {return _badfe ._aebf };

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_eedc *Creator )PageFinalize (pageFinalizeFunc func (_gdb PageFinalizeFunctionArgs )error ){_eedc ._aeee =pageFinalizeFunc ;};func (_cbfaa *templateProcessor )parseTextAlignmentAttr (_acfaf ,_dcfcc string )TextAlignment {_ce .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_acfaf ,_dcfcc );
_gdebgf :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_dcfcc ];
return _gdebgf ;};func (_fgbd *Paragraph )getMaxLineWidth ()float64 {if _fgbd ._agac ==nil ||len (_fgbd ._agac )==0{_fgbd .wrapText ();};var _afac float64 ;for _ ,_abcc :=range _fgbd ._agac {_gdfd :=_fgbd .getTextLineWidth (_abcc );if _gdfd > _afac {_afac =_gdfd ;
};};return _afac ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_aabb *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_deae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fdea ,_ffef :=_deae .setOpacity (_aabb ._eagd ,_aabb ._eagd );if _ffef !=nil {return nil ,ctx ,_ffef ;};_fadc :=_aabb ._fefe .Points ;
for _ebdgf :=range _fadc {_ecae :=&_fadc [_ebdgf ];_ecae .Y =ctx .PageHeight -_ecae .Y ;};_cfgda ,_ ,_ffef :=_aabb ._fefe .Draw (_fdea );if _ffef !=nil {return nil ,ctx ,_ffef ;};if _ffef =_deae .addContentsByString (string (_cfgda ));_ffef !=nil {return nil ,ctx ,_ffef ;
};return []*Block {_deae },ctx ,nil ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_babeb *Invoice )NoteStyle ()TextStyle {return _babeb ._cfedb };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_ecgad *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_ddfcce :=&_ecgad ._eggfe ._gcdca ;return _ecgad ._fbedc ,_ddfcce .Right ,_ddfcce .Top ,_ddfcce .Bottom ;};func (_gfdf *Division )ctxHeight (_gaff float64 )float64 {_gaff -=_gfdf ._cgf .Left +_gfdf ._cgf .Right +_gfdf ._fgfc .Left +_gfdf ._fgfc .Right ;
var _aff float64 ;for _ ,_geef :=range _gfdf ._fgaa {_aff +=_cgg (_geef ,_gaff );};return _aff ;};func _dfaa (_aeag ,_eccc TextStyle )*Invoice {_dfgb :=&Invoice {_cagb :"\u0049N\u0056\u004f\u0049\u0043\u0045",_dfaf :"\u002c\u0020",_ebea :_aeag ,_bccad :_eccc };
_dfgb ._edcbb =&InvoiceAddress {Separator :_dfgb ._dfaf };_dfgb ._bec =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_dfgb ._dfaf };_dbbcc :=ColorRGBFrom8bit (245,245,245);_bdad :=ColorRGBFrom8bit (155,155,155);_dfgb ._bfdb =_eccc ;
_dfgb ._bfdb .Color =_bdad ;_dfgb ._bfdb .FontSize =20;_dfgb ._edba =_aeag ;_dfgb ._efefb =_eccc ;_dfgb ._cfedb =_aeag ;_dfgb ._gegbe =_eccc ;_dfgb ._fgfd =_dfgb .NewCellProps ();_dfgb ._fgfd .BackgroundColor =_dbbcc ;_dfgb ._fgfd .TextStyle =_eccc ;_dfgb ._cfea =_dfgb .NewCellProps ();
_dfgb ._cfea .TextStyle =_eccc ;_dfgb ._cfea .BackgroundColor =_dbbcc ;_dfgb ._cfea .BorderColor =_dbbcc ;_dfgb ._cdg =_dfgb .NewCellProps ();_dfgb ._cdg .BorderColor =_dbbcc ;_dfgb ._cdg .BorderSides =[]CellBorderSide {CellBorderSideBottom };_dfgb ._cdg .Alignment =CellHorizontalAlignmentRight ;
_dfgb ._fgccc =_dfgb .NewCellProps ();_dfgb ._fgccc .Alignment =CellHorizontalAlignmentRight ;_dfgb ._aaeg =[2]*InvoiceCell {_dfgb .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_dfgb ._fgfd ),_dfgb .newCell ("",_dfgb ._fgfd )};
_dfgb ._gaad =[2]*InvoiceCell {_dfgb .newCell ("\u0044\u0061\u0074\u0065",_dfgb ._fgfd ),_dfgb .newCell ("",_dfgb ._fgfd )};_dfgb ._agef =[2]*InvoiceCell {_dfgb .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_dfgb ._fgfd ),_dfgb .newCell ("",_dfgb ._fgfd )};
_dfgb ._febf =[2]*InvoiceCell {_dfgb .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_dfgb ._fgccc ),_dfgb .newCell ("",_dfgb ._fgccc )};_fgdef :=_dfgb ._fgccc ;_fgdef .TextStyle =_eccc ;_fgdef .BackgroundColor =_dbbcc ;_fgdef .BorderColor =_dbbcc ;
_dfgb ._fcbe =[2]*InvoiceCell {_dfgb .newCell ("\u0054\u006f\u0074a\u006c",_fgdef ),_dfgb .newCell ("",_fgdef )};_dfgb ._eegf =[2]string {"\u004e\u006f\u0074e\u0073",""};_dfgb ._cef =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_dfgb ._dagc =[]*InvoiceCell {_dfgb .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_dfgb .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_dfgb .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_dfgb .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _dfgb ;};

// SetTitle sets the title of the invoice.
func (_bee *Invoice )SetTitle (title string ){_bee ._cagb =title };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_gegg *Creator )SetOptimizer (optimizer _aa .Optimizer ){_gegg ._aga =optimizer };func (_ecdeef *TOCLine )getLineLink ()*_aa .PdfAnnotation {if _ecdeef ._gggf <=0{return nil ;};return _fbgcc (_ecdeef ._gggf -1,_ecdeef ._gfece ,_ecdeef ._gedabe ,0);
};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_cfege *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_dgbg []*Block ;_edbg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfgb =ctx ;);_egeg :=_cfege ._bgdc .IsRelative ();if _egeg {_cfege .applyFitMode (ctx .Width );
ctx .X +=_cfege ._geab .Left ;ctx .Y +=_cfege ._geab .Top ;ctx .Width -=_cfege ._geab .Left +_cfege ._geab .Right ;ctx .Height -=_cfege ._geab .Top +_cfege ._geab .Bottom ;if _cfege ._dceeg > ctx .Height {_dgbg =append (_dgbg ,_edbg );_edbg =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_dbcf :=ctx ;_dbcf .Y =ctx .Margins .Top +_cfege ._geab .Top ;_dbcf .X =ctx .Margins .Left +_cfege ._geab .Left ;_dbcf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cfege ._geab .Top -_cfege ._geab .Bottom ;_dbcf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cfege ._geab .Left -_cfege ._geab .Right ;
ctx =_dbcf ;};}else {ctx .X =_cfege ._eadc -_cfege ._cgec /2;ctx .Y =_cfege ._ffaga -_cfege ._dceeg /2;};_cda :=_ad .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_cfege ._dceeg ,Width :_cfege ._cgec ,Height :_cfege ._dceeg ,BorderWidth :_cfege ._ggcgf ,Opacity :1.0};
if _cfege ._ffde !=nil {_cda .FillEnabled =true ;_bdbe :=_adb (_cfege ._ffde );_defe :=_effg (_edbg ,_bdbe ,_cfege ._ffde ,func ()Rectangle {return Rectangle {_ddge :_cda .X ,_gead :_cda .Y ,_dbda :_cda .Width ,_agfc :_cda .Height };});if _defe !=nil {return nil ,ctx ,_defe ;
};_cda .FillColor =_bdbe ;};if _cfege ._bdfg !=nil {_cda .BorderEnabled =false ;if _cfege ._ggcgf > 0{_cda .BorderEnabled =true ;};_cda .BorderColor =_adb (_cfege ._bdfg );_cda .BorderWidth =_cfege ._ggcgf ;};_eeff ,_fgdb :=_edbg .setOpacity (_cfege ._bce ,_cfege ._gbdg );
if _fgdb !=nil {return nil ,ctx ,_fgdb ;};_ddfb ,_ ,_fgdb :=_cda .Draw (_eeff );if _fgdb !=nil {return nil ,ctx ,_fgdb ;};_fgdb =_edbg .addContentsByString (string (_ddfb ));if _fgdb !=nil {return nil ,ctx ,_fgdb ;};if _egeg {ctx .X =_bfgb .X ;ctx .Width =_bfgb .Width ;
ctx .Y +=_cfege ._dceeg +_cfege ._geab .Bottom ;ctx .Height -=_cfege ._dceeg ;}else {ctx =_bfgb ;};_dgbg =append (_dgbg ,_edbg );return _dgbg ,ctx ,nil ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_abdf *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_abdf ._bag .Left =left ;_abdf ._bag .Right =right ;_abdf ._bag .Top =top ;_abdf ._bag .Bottom =bottom ;};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_efag *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _efag ._fgbea .Left ,_efag ._fgbea .Right ,_efag ._fgbea .Top ,_efag ._fgbea .Bottom ;};func (_dcgb *templateProcessor )parseTextRenderingModeAttr (_gcggb ,_fccb string )TextRenderingMode {_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gcggb ,_fccb );
_dbeg :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_fccb ];
return _dbeg ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_ccab *Paragraph )SetWidth (width float64 ){_ccab ._cagbag =width ;_ccab .wrapText ()};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_cfbb *Creator )AddPage (page *_aa .PdfPage )error {_daa ,_dac :=_cfbb .wrapPageIfNeeded (page );if _dac !=nil {return _dac ;};if _daa !=nil {page =_daa ;};_dgde ,_dac :=page .GetMediaBox ();if _dac !=nil {_ce .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_dac );
return _dac ;};_dgde .Normalize ();_dagg ,_abcf :=_dgde .Llx ,_dgde .Lly ;_dgga :=_dgde ;if _dabeg :=page .CropBox ;_dabeg !=nil &&*_dabeg !=*_dgde {_dabeg .Normalize ();_dagg ,_abcf =_dabeg .Llx ,_dabeg .Lly ;_dgga =_dabeg ;};_fcf :=_dc .IdentityMatrix ();
_ggae ,_dac :=page .GetRotate ();if _dac !=nil {_ce .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_dac .Error ());
};_eaeb :=_ggae %360!=0&&_ggae %90==0;if _eaeb {_dgee :=float64 ((360+_ggae %360)%360);if _dgee ==90{_fcf =_fcf .Translate (_dgga .Width (),0);}else if _dgee ==180{_fcf =_fcf .Translate (_dgga .Width (),_dgga .Height ());}else if _dgee ==270{_fcf =_fcf .Translate (0,_dgga .Height ());
};_fcf =_fcf .Mult (_dc .RotationMatrix (_dgee *_bcb .Pi /180));_fcf =_fcf .Round (0.000001);_gcbgc :=_dfac (_dgga ,_fcf );_dgga =_gcbgc ;_dgga .Normalize ();};if _dagg !=0||_abcf !=0{_fcf =_dc .TranslationMatrix (_dagg ,_abcf ).Mult (_fcf );};if !_fcf .Identity (){_fcf =_fcf .Round (0.000001);
_cfbb ._bdae [page ]=&pageTransformations {_fece :&_fcf };};_cfbb ._fddd =_dgga .Width ();_cfbb ._ccdb =_dgga .Height ();_cfbb .initContext ();_cfbb ._agfa =append (_cfbb ._agfa ,page );_cfbb ._aaa .Page ++;return nil ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_afbee *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _afbee ._aaeg [0],_afbee ._aaeg [1]};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_dfgg *shading )SetBackgroundColor (backgroundColor Color ){_dfgg ._egfd =backgroundColor };func (_daag *templateProcessor )parseImage (_cadff *templateNode )(interface{},error ){var _babc string ;for _ ,_deca :=range _cadff ._gcbdb .Attr {_ggbe :=_deca .Value ;
switch _agaf :=_deca .Name .Local ;_agaf {case "\u0073\u0072\u0063":_babc =_ggbe ;};};_badad ,_bfeag :=_daag .loadImageFromSrc (_babc );if _bfeag !=nil {return nil ,_bfeag ;};for _ ,_gacba :=range _cadff ._gcbdb .Attr {_aebb :=_gacba .Value ;switch _fdee :=_gacba .Name .Local ;
_fdee {case "\u0061\u006c\u0069g\u006e":_badad .SetHorizontalAlignment (_daag .parseHorizontalAlignmentAttr (_fdee ,_aebb ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_badad .SetOpacity (_daag .parseFloatAttr (_fdee ,_aebb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cfagd :=_daag .parseMarginAttr (_fdee ,_aebb );
_badad .SetMargins (_cfagd .Left ,_cfagd .Right ,_cfagd .Top ,_cfagd .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_badad .SetFitMode (_daag .parseFitModeAttr (_fdee ,_aebb ));case "\u0078":_badad .SetPos (_daag .parseFloatAttr (_fdee ,_aebb ),_badad ._aefac );
case "\u0079":_badad .SetPos (_badad ._cffa ,_daag .parseFloatAttr (_fdee ,_aebb ));case "\u0077\u0069\u0064t\u0068":_badad .SetWidth (_daag .parseFloatAttr (_fdee ,_aebb ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_badad .SetHeight (_daag .parseFloatAttr (_fdee ,_aebb ));
case "\u0061\u006e\u0067l\u0065":_badad .SetAngle (_daag .parseFloatAttr (_fdee ,_aebb ));case "\u0073\u0072\u0063":break ;default:_daag .nodeLogDebug (_cadff ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fdee );
};};return _badad ,nil ;};func (_dead *Creator )newPage ()*_aa .PdfPage {_fgcb :=_aa .NewPdfPage ();_dfdf :=_dead ._dafd [0];_gggg :=_dead ._dafd [1];_cadc :=_aa .PdfRectangle {Llx :0,Lly :0,Urx :_dfdf ,Ury :_gggg };_fgcb .MediaBox =&_cadc ;_dead ._fddd =_dfdf ;
_dead ._ccdb =_gggg ;_dead .initContext ();return _fgcb ;};func _ggaed (_agae string )(*GraphicSVG ,error ){_dddd ,_fega :=_de .ParseFromFile (_agae );if _fega !=nil {return nil ,_fega ;};return _geea (_dddd );};func _effg (_cceb *Block ,_ffae _aa .PdfColor ,_dfafe Color ,_gfdfc func ()Rectangle )error {switch _bafd :=_ffae .(type ){case *_aa .PdfColorPatternType2 :_aebc ,_acce :=_dfafe .(*LinearShading );
if !_acce {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_gdfdf :=_gfdfc ();_aebc .SetBoundingBox (_gdfdf ._ddge ,_gdfdf ._gead ,_gdfdf ._dbda ,_gdfdf ._agfc );
_gffea ,_dcca :=_aebc .AddPatternResource (_cceb );if _dcca !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_dcca );
};_bafd .PatternName =_gffea ;case *_aa .PdfColorPatternType3 :_cebab ,_ebcc :=_dfafe .(*RadialShading );if !_ebcc {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_baaee :=_gfdfc ();_cebab .SetBoundingBox (_baaee ._ddge ,_baaee ._gead ,_baaee ._dbda ,_baaee ._agfc );_fegag ,_dcgea :=_cebab .AddPatternResource (_cceb );if _dcgea !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_dcgea );
};_bafd .PatternName =_fegag ;};return nil ;};func _acac (_aabae float64 ,_abbcf float64 )float64 {return _bcb .Round (_aabae /_abbcf )*_abbcf };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_ggfb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_ggfb ._dbcg =valign };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gfbbf *TOCLine )SetStyle (style TextStyle ){_gfbbf .Number .Style =style ;_gfbbf .Title .Style =style ;_gfbbf .Separator .Style =style ;_gfbbf .Page .Style =style ;};func _cbgg (_gcb string ,_geg _e .PdfObject ,_dcd *_aa .PdfPageResources )_e .PdfObjectName {_acbg :=_gc .TrimRightFunc (_gc .TrimSpace (_gcb ),func (_efdb rune )bool {return _dd .IsNumber (_efdb )});
if _acbg ==""{_acbg ="\u0046\u006f\u006e\u0074";};_bge :=0;_ged :=_e .PdfObjectName (_gcb );for {_fce ,_cdeb :=_dcd .GetFontByName (_ged );if !_cdeb ||_fce ==_geg {break ;};_bge ++;_ged =_e .PdfObjectName (_f .Sprintf ("\u0025\u0073\u0025\u0064",_acbg ,_bge ));
};return _ged ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_efbf *Paragraph )SetColor (col Color ){_efbf ._bdfge =col };

// SetLineWidth sets the line width.
func (_cfffa *Polyline )SetLineWidth (lineWidth float64 ){_cfffa ._fefe .LineWidth =lineWidth };func _beea (_fddff *templateProcessor ,_ecaeb *templateNode )(interface{},error ){return _fddff .parseTextChunk (_ecaeb ,nil );};func _ccfaf (_ccfc [][]_ad .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_cbda :&_ad .CurvePolygon {Rings :_ccfc },_fae :1.0,_ccgef :1.0};
};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_cddf *RadialShading )AddShadingResource (block *Block )(_fbdbg _e .PdfObjectName ,_edagc error ){_egbaa :=1;_fbdbg =_e .PdfObjectName ("\u0053\u0068"+_gcc .Itoa (_egbaa ));for block ._ddc .HasShadingByName (_fbdbg ){_egbaa ++;_fbdbg =_e .PdfObjectName ("\u0053\u0068"+_gcc .Itoa (_egbaa ));
};if _fgagb :=block ._ddc .SetShadingByName (_fbdbg ,_cddf .shadingModel ().ToPdfObject ());_fgagb !=nil {return "",_fgagb ;};return _fbdbg ,nil ;};func _edbf (_cdcec *templateProcessor ,_fdbe *templateNode )(interface{},error ){return _cdcec .parseEllipse (_fdbe );
};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_fgbcd *TOC )SetLineTitleStyle (style TextStyle ){_fgbcd ._bccgdb =style };type templateNode struct{_ebabb interface{};_gcbdb _gf .StartElement ;_fedefc *templateNode ;_gfaad int ;_gfacg int ;_dfag int64 ;};func (_daee *templateProcessor )parseCellVerticalAlignmentAttr (_babce ,_bcbdf string )CellVerticalAlignment {_ce .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_babce ,_bcbdf );
_gbcef :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_bcbdf ];return _gbcef ;
};func (_eccgg *Division )split (_caeg DrawContext )(_cec ,_feeda *Division ){var (_ecbd float64 ;_cfgf ,_bdaa []VectorDrawable ;);_gfca :=_caeg .Width -_eccgg ._cgf .Left -_eccgg ._cgf .Right -_eccgg ._fgfc .Left -_eccgg ._fgfc .Right ;for _gbgc ,_fegfg :=range _eccgg ._fgaa {_ecbd +=_cgg (_fegfg ,_gfca );
if _ecbd < _caeg .Height {_cfgf =append (_cfgf ,_fegfg );}else {_bdaa =_eccgg ._fgaa [_gbgc :];break ;};};if len (_cfgf )> 0{_cec =_bggc ();*_cec =*_eccgg ;_cec ._fgaa =_cfgf ;if _eccgg ._bede !=nil {_cec ._bede =&Background {};*_cec ._bede =*_eccgg ._bede ;
};};if len (_bdaa )> 0{_feeda =_bggc ();*_feeda =*_eccgg ;_feeda ._fgaa =_bdaa ;if _eccgg ._bede !=nil {_feeda ._bede =&Background {};*_feeda ._bede =*_eccgg ._bede ;};};return _cec ,_feeda ;};

// SetLineHeight sets the line height (1.0 default).
func (_dcadg *StyledParagraph )SetLineHeight (lineheight float64 ){_dcadg ._ffafa =lineheight };

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_gce *Division )SetMargins (left ,right ,top ,bottom float64 ){_gce ._cgf .Left =left ;_gce ._cgf .Right =right ;_gce ._cgf .Top =top ;_gce ._cgf .Bottom =bottom ;};func (_ecdce *templateProcessor )parseDivision (_dbdae *templateNode )(interface{},error ){_aeed :=_ecdce .creator .NewDivision ();
for _ ,_faddg :=range _dbdae ._gcbdb .Attr {_fgffe :=_faddg .Value ;switch _gcbba :=_faddg .Name .Local ;_gcbba {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_aeed .EnablePageWrap (_ecdce .parseBoolAttr (_gcbba ,_fgffe ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_acage :=_ecdce .parseMarginAttr (_gcbba ,_fgffe );_aeed .SetMargins (_acage .Left ,_acage .Right ,_acage .Top ,_acage .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_adgad :=_ecdce .parseMarginAttr (_gcbba ,_fgffe );
_aeed .SetPadding (_adgad .Left ,_adgad .Right ,_adgad .Top ,_adgad .Bottom );default:_ecdce .nodeLogDebug (_dbdae ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gcbba );
};};return _aeed ,nil ;};func _gaa (_acb *_ae .ContentStreamOperations ,_fdb *_aa .PdfPageResources ,_cge *_ae .ContentStreamOperations ,_faa *_aa .PdfPageResources )error {_ca :=map[_e .PdfObjectName ]_e .PdfObjectName {};_gge :=map[_e .PdfObjectName ]_e .PdfObjectName {};
_ddb :=map[_e .PdfObjectName ]_e .PdfObjectName {};_faf :=map[_e .PdfObjectName ]_e .PdfObjectName {};_bcbb :=map[_e .PdfObjectName ]_e .PdfObjectName {};_adg :=map[_e .PdfObjectName ]_e .PdfObjectName {};for _ ,_fec :=range *_cge {switch _fec .Operand {case "\u0044\u006f":if len (_fec .Params )==1{if _fda ,_cag :=_fec .Params [0].(*_e .PdfObjectName );
_cag {if _ ,_dadf :=_ca [*_fda ];!_dadf {var _ebb _e .PdfObjectName ;_bgd ,_ :=_faa .GetXObjectByName (*_fda );if _bgd !=nil {_ebb =*_fda ;for {_gff ,_ :=_fdb .GetXObjectByName (_ebb );if _gff ==nil ||_gff ==_bgd {break ;};_ebb =*_e .MakeName (_abb (_ebb .String ()));
};};_fdb .SetXObjectByName (_ebb ,_bgd );_ca [*_fda ]=_ebb ;};_fbe :=_ca [*_fda ];_fec .Params [0]=&_fbe ;};};case "\u0054\u0066":if len (_fec .Params )==2{if _egf ,_fdbb :=_fec .Params [0].(*_e .PdfObjectName );_fdbb {if _ ,_dggg :=_gge [*_egf ];!_dggg {_aac ,_dcec :=_faa .GetFontByName (*_egf );
_aggb :=*_egf ;if _dcec &&_aac !=nil {_aggb =_cbgg (_egf .String (),_aac ,_fdb );};_fdb .SetFontByName (_aggb ,_aac );_gge [*_egf ]=_aggb ;};_gca :=_gge [*_egf ];_fec .Params [0]=&_gca ;};};case "\u0043\u0053","\u0063\u0073":if len (_fec .Params )==1{if _dea ,_edgb :=_fec .Params [0].(*_e .PdfObjectName );
_edgb {if _ ,_ceg :=_ddb [*_dea ];!_ceg {var _edb _e .PdfObjectName ;_ffc ,_caa :=_faa .GetColorspaceByName (*_dea );if _caa {_edb =*_dea ;for {_dcad ,_dba :=_fdb .GetColorspaceByName (_edb );if !_dba ||_ffc ==_dcad {break ;};_edb =*_e .MakeName (_abb (_edb .String ()));
};_fdb .SetColorspaceByName (_edb ,_ffc );_ddb [*_dea ]=_edb ;}else {_ce .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _fac ,_deb :=_ddb [*_dea ];_deb {_fec .Params [0]=&_fac ;}else {_ce .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_dea );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_fec .Params )==1{if _dbc ,_gfdg :=_fec .Params [0].(*_e .PdfObjectName );_gfdg {if _ ,_efdf :=_faf [*_dbc ];!_efdf {var _eed _e .PdfObjectName ;_fecd ,_ecf :=_faa .GetPatternByName (*_dbc );
if _ecf {_eed =*_dbc ;for {_fad ,_dbba :=_fdb .GetPatternByName (_eed );if !_dbba ||_fad ==_fecd {break ;};_eed =*_e .MakeName (_abb (_eed .String ()));};_fdae :=_fdb .SetPatternByName (_eed ,_fecd .ToPdfObject ());if _fdae !=nil {return _fdae ;};_faf [*_dbc ]=_eed ;
};};if _ada ,_gda :=_faf [*_dbc ];_gda {_fec .Params [0]=&_ada ;};};};case "\u0073\u0068":if len (_fec .Params )==1{if _ffcf ,_bga :=_fec .Params [0].(*_e .PdfObjectName );_bga {if _ ,_bcff :=_bcbb [*_ffcf ];!_bcff {var _ecd _e .PdfObjectName ;_aaba ,_bbe :=_faa .GetShadingByName (*_ffcf );
if _bbe {_ecd =*_ffcf ;for {_fgg ,_ba :=_fdb .GetShadingByName (_ecd );if !_ba ||_aaba ==_fgg {break ;};_ecd =*_e .MakeName (_abb (_ecd .String ()));};_afe :=_fdb .SetShadingByName (_ecd ,_aaba .ToPdfObject ());if _afe !=nil {_ce .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_afe );
return _afe ;};_bcbb [*_ffcf ]=_ecd ;}else {_ce .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cac ,_gad :=_bcbb [*_ffcf ];_gad {_fec .Params [0]=&_cac ;}else {_ce .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ffcf );
};};};case "\u0067\u0073":if len (_fec .Params )==1{if _ecde ,_bcfa :=_fec .Params [0].(*_e .PdfObjectName );_bcfa {if _ ,_baf :=_adg [*_ecde ];!_baf {var _cdfd _e .PdfObjectName ;_cfdf ,_eacc :=_faa .GetExtGState (*_ecde );if _eacc {_cdfd =*_ecde ;for {_faab ,_fbg :=_fdb .GetExtGState (_cdfd );
if !_fbg ||_cfdf ==_faab {break ;};_cdfd =*_e .MakeName (_abb (_cdfd .String ()));};};_fdb .AddExtGState (_cdfd ,_cfdf );_adg [*_ecde ]=_cdfd ;};_dag :=_adg [*_ecde ];_fec .Params [0]=&_dag ;};};};*_acb =append (*_acb ,_fec );};return nil ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_aeg int ;_gcca string ;_bbeg *Paragraph ;_fca []Drawable ;_egfa int ;_bcfg bool ;_bae bool ;_feed Positioning ;_bef ,_gbcg float64 ;_aaefc Margins ;_ade *Chapter ;_egfag *TOC ;_eef *_aa .Outline ;_ebg *_aa .OutlineItem ;_bdfda uint ;
};

// Positioning returns the type of positioning the rectangle is set to use.
func (_aaab *Rectangle )Positioning ()Positioning {return _aaab ._fbeb };

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_afcb *Line )SetMargins (left ,right ,top ,bottom float64 ){_afcb ._fgbea .Left =left ;_afcb ._fgbea .Right =right ;_afcb ._fgbea .Top =top ;_afcb ._fgbea .Bottom =bottom ;};

// AppendColumn appends a column to the line items table.
func (_dega *Invoice )AppendColumn (description string )*InvoiceCell {_gccb :=_dega .NewColumn (description );_dega ._dagc =append (_dega ._dagc ,_gccb );return _gccb ;};func (_dfbg *templateProcessor )parseTable (_dbdaf *templateNode )(interface{},error ){var _addad int64 ;
for _ ,_abbde :=range _dbdaf ._gcbdb .Attr {_dffa :=_abbde .Value ;switch _dbdde :=_abbde .Name .Local ;_dbdde {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_addad =_dfbg .parseInt64Attr (_dbdde ,_dffa );};};if _addad <=0{_dfbg .nodeLogDebug (_dbdaf ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_addad );
_addad =1;};_fabba :=_dfbg .creator .NewTable (int (_addad ));for _ ,_egbd :=range _dbdaf ._gcbdb .Attr {_aaga :=_egbd .Value ;switch _adgb :=_egbd .Name .Local ;_adgb {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_fabba .SetColumnWidths (_dfbg .parseFloatArray (_adgb ,_aaga )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_edgba :=_dfbg .parseMarginAttr (_adgb ,_aaga );_fabba .SetMargins (_edgba .Left ,_edgba .Right ,_edgba .Top ,_edgba .Bottom );case "\u0078":_fabba .SetPos (_dfbg .parseFloatAttr (_adgb ,_aaga ),_fabba ._cdfcg );
case "\u0079":_fabba .SetPos (_fabba ._caba ,_dfbg .parseFloatAttr (_adgb ,_aaga ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_fabba ._dacd =int (_dfbg .parseInt64Attr (_adgb ,_aaga ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_fabba ._geaaf =int (_dfbg .parseInt64Attr (_adgb ,_aaga ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_fabba .EnableRowWrap (_dfbg .parseBoolAttr (_adgb ,_aaga ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_fabba .EnablePageWrap (_dfbg .parseBoolAttr (_adgb ,_aaga ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_dfbg .nodeLogDebug (_dbdaf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_adgb );
};};if _fabba ._dacd !=0&&_fabba ._geaaf !=0{_dbde :=_fabba .SetHeaderRows (_fabba ._dacd ,_fabba ._geaaf );if _dbde !=nil {_dfbg .nodeLogDebug (_dbdaf ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_dbde );
};}else {_fabba ._dacd =0;_fabba ._geaaf =0;};return _fabba ,nil ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_gaadd *Invoice )SetBuyerAddress (address *InvoiceAddress ){_gaadd ._bec =address };type templateTag struct{_ccgdfa map[string ]struct{};_dbbbb func (*templateProcessor ,*templateNode )(interface{},error );};

// SetSideBorderColor sets the cell's side border color.
func (_fdcc *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_fdcc ._cbdbb =col ;_fdcc ._decc =col ;_fdcc ._dabfg =col ;_fdcc ._fgbce =col ;case CellBorderSideTop :_fdcc ._cbdbb =col ;case CellBorderSideBottom :_fdcc ._decc =col ;
case CellBorderSideLeft :_fdcc ._dabfg =col ;case CellBorderSideRight :_fdcc ._fgbce =col ;};};

// SetSellerAddress sets the seller address of the invoice.
func (_ecdee *Invoice )SetSellerAddress (address *InvoiceAddress ){_ecdee ._edcbb =address };

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func (_ceba *Invoice )drawSection (_gbbdb ,_dgfe string )[]*StyledParagraph {var _cecd []*StyledParagraph ;if _gbbdb !=""{_eggd :=_fbfg (_ceba ._gegbe );_eggd .SetMargins (0,0,0,5);_eggd .Append (_gbbdb );_cecd =append (_cecd ,_eggd );
};if _dgfe !=""{_aafg :=_fbfg (_ceba ._cfedb );_aafg .Append (_dgfe );_cecd =append (_cecd ,_aafg );};return _cecd ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_accab *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_accab ._abdae {_ce .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_accab ._bdbga =widths ;return nil ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_fbfa *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _dgafb (colorPoints );};

// MoveX moves the drawing context to absolute position x.
func (_bfc *Creator )MoveX (x float64 ){_bfc ._aaa .X =x };func _fdfa (_eeaa *templateProcessor ,_egfdd *templateNode )(interface{},error ){return _eeaa .parseListMarker (_egfdd );};func _dacf (_gdced string ,_fagge ,_fcbd TextStyle )*TOC {_cdbbb :=_fcbd ;
_cdbbb .FontSize =14;_befde :=_fbfg (_cdbbb );_befde .SetEnableWrap (true );_befde .SetTextAlignment (TextAlignmentLeft );_befde .SetMargins (0,0,0,5);_afdg :=_befde .Append (_gdced );_afdg .Style =_cdbbb ;return &TOC {_cbggb :_befde ,_cdabg :[]*TOCLine {},_faff :_fagge ,_bccgdb :_fagge ,_gdddd :_fagge ,_bdcgd :_fagge ,_egga :"\u002e",_geadb :10,_ccecf :Margins {0,0,2,2},_adedd :PositionRelative ,_dace :_fagge ,_ebdf :true };
};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_ebffg *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gecg []*Block ;_decb =NewBlock (ctx .PageWidth ,ctx .PageHeight );_dgbe =ctx ;_bbff =_ebffg ._bcceg /2;);_gecf :=_ebffg ._fbeb .IsRelative ();if _gecf {_ebffg .applyFitMode (ctx .Width );
ctx .X +=_ebffg ._ebgg .Left +_bbff ;ctx .Y +=_ebffg ._ebgg .Top +_bbff ;ctx .Width -=_ebffg ._ebgg .Left +_ebffg ._ebgg .Right ;ctx .Height -=_ebffg ._ebgg .Top +_ebffg ._ebgg .Bottom ;if _ebffg ._agfc > ctx .Height {_gecg =append (_gecg ,_decb );_decb =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_dfdbb :=ctx ;_dfdbb .Y =ctx .Margins .Top +_ebffg ._ebgg .Top +_bbff ;_dfdbb .X =ctx .Margins .Left +_ebffg ._ebgg .Left +_bbff ;_dfdbb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ebffg ._ebgg .Top -_ebffg ._ebgg .Bottom ;
_dfdbb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ebffg ._ebgg .Left -_ebffg ._ebgg .Right ;ctx =_dfdbb ;};}else {ctx .X =_ebffg ._ddge ;ctx .Y =_ebffg ._gead ;};_ecfd :=_ad .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_ebffg ._agfc ,Width :_ebffg ._dbda ,Height :_ebffg ._agfc ,BorderRadiusTopLeft :_ebffg ._cbdb ,BorderRadiusTopRight :_ebffg ._agda ,BorderRadiusBottomLeft :_ebffg ._efde ,BorderRadiusBottomRight :_ebffg ._eadce ,Opacity :1.0};
if _ebffg ._fdgf !=nil {_ecfd .FillEnabled =true ;_fbdd :=_adb (_ebffg ._fdgf );_cffb :=_effg (_decb ,_fbdd ,_ebffg ._fdgf ,func ()Rectangle {return Rectangle {_ddge :_ecfd .X ,_gead :_ecfd .Y ,_dbda :_ecfd .Width ,_agfc :_ecfd .Height };});if _cffb !=nil {return nil ,ctx ,_cffb ;
};_ecfd .FillColor =_fbdd ;};if _ebffg ._aebf !=nil &&_ebffg ._bcceg > 0{_ecfd .BorderEnabled =true ;_ecfd .BorderColor =_adb (_ebffg ._aebf );_ecfd .BorderWidth =_ebffg ._bcceg ;};_gbcb ,_gada :=_decb .setOpacity (_ebffg ._befe ,_ebffg ._gfdfab );if _gada !=nil {return nil ,ctx ,_gada ;
};_dafdc ,_ ,_gada :=_ecfd .Draw (_gbcb );if _gada !=nil {return nil ,ctx ,_gada ;};if _gada =_decb .addContentsByString (string (_dafdc ));_gada !=nil {return nil ,ctx ,_gada ;};if _gecf {ctx .X =_dgbe .X ;ctx .Width =_dgbe .Width ;_badb :=_ebffg ._agfc +_bbff ;
ctx .Y +=_badb +_ebffg ._ebgg .Bottom ;ctx .Height -=_badb ;}else {ctx =_dgbe ;};_gecg =append (_gecg ,_decb );return _gecg ,ctx ,nil ;};func (_gcbb *Creator )wrapPageIfNeeded (_gdcee *_aa .PdfPage )(*_aa .PdfPage ,error ){_cgdb ,_efee :=_gdcee .GetAllContentStreams ();
if _efee !=nil {return nil ,_efee ;};_ccff :=_ae .NewContentStreamParser (_cgdb );_dffg ,_efee :=_ccff .Parse ();if _efee !=nil {return nil ,_efee ;};if !_dffg .HasUnclosedQ (){return nil ,nil ;};_dffg .WrapIfNeeded ();_fbc ,_efee :=_e .MakeStream (_dffg .Bytes (),_e .NewFlateEncoder ());
if _efee !=nil {return nil ,_efee ;};_gdcee .Contents =_e .MakeArray (_fbc );return _gdcee ,nil ;};func (_cagad *templateProcessor )parseColorAttr (_gagca ,_debg string )Color {_ce .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gagca ,_debg );
_debg =_gc .TrimSpace (_debg );if _gc .HasPrefix (_debg ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_gc .HasSuffix (_debg ,"\u0029")&&len (_debg )> 17{return _cagad .parseLinearGradientAttr (_cagad .creator ,_debg );
};if _gc .HasPrefix (_debg ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_gc .HasSuffix (_debg ,"\u0029")&&len (_debg )> 17{return _cagad .parseRadialGradientAttr (_cagad .creator ,_debg );};if _bcbba :=_cagad .parseColor (_debg );
_bcbba !=nil {return _bcbba ;};return ColorBlack ;};

// Angle returns the block rotation angle in degrees.
func (_add *Block )Angle ()float64 {return _add ._eb };

// FillColor returns the fill color of the ellipse.
func (_agdf *Ellipse )FillColor ()Color {return _agdf ._ffde };func _ddbc (_bddc *templateProcessor ,_bbfac *templateNode )(interface{},error ){return _bddc .parsePageBreak (_bbfac );};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_adda *Invoice )SetAddressHeadingStyle (style TextStyle ){_adda ._efefb =style };

// SetBorderColor sets the cell's border color.
func (_bfef *TableCell )SetBorderColor (col Color ){_bfef ._dabfg =col ;_bfef ._decc =col ;_bfef ._fgbce =col ;_bfef ._cbdbb =col ;};

// WriteToFile writes the Creator output to file specified by path.
func (_fcb *Creator )WriteToFile (outputPath string )error {_cfeg ,_adeae :=_d .Create (outputPath );if _adeae !=nil {return _adeae ;};defer _cfeg .Close ();return _fcb .Write (_cfeg );};func (_ggcc *templateProcessor )renderNode (_geeag *templateNode )error {_deded :=_geeag ._ebabb ;
if _deded ==nil {return nil ;};_aaagg :=_geeag ._gcbdb .Name .Local ;_ccfe ,_cgfg :=_efda [_aaagg ];if !_cgfg {_ggcc .nodeLogDebug (_geeag ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_aaagg );
return nil ;};var _egec interface{};if _geeag ._fedefc !=nil &&_geeag ._fedefc ._ebabb !=nil {_dbadg :=_geeag ._fedefc ._gcbdb .Name .Local ;if _ ,_cgfg =_ccfe ._ccgdfa [_dbadg ];!_cgfg {_ggcc .nodeLogDebug (_geeag ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_dbadg ,_aaagg );
return _fgcf ;};_egec =_geeag ._fedefc ._ebabb ;}else {_gfae :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _ggcc ._effb .(type ){case *Block :_gfae ="\u0062\u006c\u006fc\u006b";};if _ ,_cgfg =_ccfe ._ccgdfa [_gfae ];!_cgfg {_ggcc .nodeLogDebug (_geeag ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_gfae ,_aaagg );
return _fgcf ;};_egec =_ggcc ._effb ;};switch _cdgc :=_egec .(type ){case componentRenderer :_fefgb ,_gbbc :=_deded .(Drawable );if !_gbbc {_ggcc .nodeLogError (_geeag ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_aaagg ,_deded );
return _cebe ;};_cafd :=_cdgc .Draw (_fefgb );if _cafd !=nil {return _ggcc .nodeError (_geeag ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_aaagg ,_deded ,_cafd );
};case *Division :switch _gfadb :=_deded .(type ){case *Background :_cdgc .SetBackground (_gfadb );case VectorDrawable :_cebfd :=_cdgc .Add (_gfadb );if _cebfd !=nil {return _ggcc .nodeError (_geeag ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_aaagg ,_deded ,_cebfd );
};};case *TableCell :_bbed ,_eagge :=_deded .(VectorDrawable );if !_eagge {_ggcc .nodeLogError (_geeag ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_aaagg ,_deded );
return _cebe ;};_bbcge :=_cdgc .SetContent (_bbed );if _bbcge !=nil {return _ggcc .nodeError (_geeag ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_aaagg ,_deded ,_bbcge );
};case *StyledParagraph :_acdb ,_cadb :=_deded .(*TextChunk );if !_cadb {_ggcc .nodeLogError (_geeag ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_aaagg ,_deded );
return _cebe ;};_cdgc .appendChunk (_acdb );case *Chapter :switch _edeef :=_deded .(type ){case *Chapter :return nil ;case *Paragraph :if _geeag ._gcbdb .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_badg :=_cdgc .Add (_edeef );if _badg !=nil {return _ggcc .nodeError (_geeag ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_aaagg ,_deded ,_badg );
};case Drawable :_cgfcg :=_cdgc .Add (_edeef );if _cgfcg !=nil {return _ggcc .nodeError (_geeag ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_aaagg ,_deded ,_cgfcg );
};};case *List :switch _ceaf :=_deded .(type ){case *TextChunk :case *listItem :_cdgc ._dbedd =append (_cdgc ._dbedd ,_ceaf );default:_ggcc .nodeLogError (_geeag ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_aaagg ,_deded );
};case *listItem :switch _cfecb :=_deded .(type ){case *TextChunk :case *StyledParagraph :_cdgc ._cbcgc =_cfecb ;case *List :if _cfecb ._aadde {_cfecb ._ecbc =15;};_cdgc ._cbcgc =_cfecb ;case *Image :_cdgc ._cbcgc =_cfecb ;case *Division :_cdgc ._cbcgc =_cfecb ;
case *Table :_cdgc ._cbcgc =_cfecb ;default:_ggcc .nodeLogError (_geeag ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_aaagg ,_deded );
return _cebe ;};};return nil ;};func _cead ()*listItem {return &listItem {}};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_gcdg *List )Marker ()*TextChunk {return &_gcdg ._dbfb };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_cgdec *_ad .Polygon ;_ebgd float64 ;_fbfb float64 ;_abaa Color ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_bfag *TOCLine )SetLevelOffset (levelOffset float64 ){_bfag ._cfeda =levelOffset ;_bfag ._eggfe ._gcdca .Left =_bfag ._fbedc +float64 (_bfag ._edac -1)*_bfag ._cfeda ;};

// SetPos sets absolute positioning with specified coordinates.
func (_bgfd *Paragraph )SetPos (x ,y float64 ){_bgfd ._bdag =PositionAbsolute ;_bgfd ._eedf =x ;_bgfd ._gaba =y ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// Height returns the current page height.
func (_dcg *Creator )Height ()float64 {return _dcg ._ccdb };func (_edcbbf *StyledParagraph )wrapText ()error {return _edcbbf .wrapChunks (true )};func (_dae *Chapter )headingText ()string {_fea :=_dae ._gcca ;if _bab :=_dae .headingNumber ();_bab !=""{_fea =_f .Sprintf ("\u0025\u0073\u0020%\u0073",_bab ,_fea );
};return _fea ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_eeaf *Creator )DrawTemplate (r _bd .Reader ,data interface{},options *TemplateOptions )error {return _aecbe (_eeaf ,r ,data ,options ,_eeaf );};func _fcee (_gcdb *_aa .PdfFont ,_aceeg float64 )*fontMetrics {_effec :=&fontMetrics {};if _gcdb ==nil {_ce .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");
return _effec ;};_gbdf ,_bbdag :=_gcdb .GetFontDescriptor ();if _bbdag !=nil {_ce .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_bbdag );
return _effec ;};if _effec ._dafeg ,_bbdag =_gbdf .GetCapHeight ();_bbdag !=nil {_ce .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_bbdag );
};if int (_effec ._dafeg )<=0{_ce .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_effec ._dafeg =1000;};_effec ._dafeg *=_aceeg /1000.0;if _effec ._dfabf ,_bbdag =_gbdf .GetXHeight ();_bbdag !=nil {_ce .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_bbdag );
};_effec ._dfabf *=_aceeg /1000.0;if _effec ._fgffa ,_bbdag =_gbdf .GetAscent ();_bbdag !=nil {_ce .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_bbdag );
};_effec ._fgffa *=_aceeg /1000.0;if _effec ._gabca ,_bbdag =_gbdf .GetDescent ();_bbdag !=nil {_ce .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_bbdag );
};_effec ._gabca *=_aceeg /1000.0;return _effec ;};func _geedg (_cffd []_ad .Point )*Polyline {return &Polyline {_fefe :&_ad .Polyline {Points :_cffd ,LineColor :_aa .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_eagd :1.0};};

// GeneratePageBlocks implements drawable interface.
func (_bdf *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_faag :=_bdf ._accf ;_eacca :=ctx .PageHeight -_bdf ._eec ;if _bdf ._eaf !=nil {_febg :=_ad .Rectangle {Opacity :1.0,X :_bdf ._accf ,Y :ctx .PageHeight -_bdf ._eec -_bdf ._gfb ,Height :_bdf ._gfb ,Width :_bdf ._dff };
_febg .FillEnabled =true ;_gcaa :=_adb (_bdf ._eaf );_ead :=_effg (_dbd ,_gcaa ,_bdf ._eaf ,func ()Rectangle {return Rectangle {_ddge :_febg .X ,_gead :_febg .Y ,_dbda :_febg .Width ,_agfc :_febg .Height };});if _ead !=nil {return nil ,ctx ,_ead ;};_febg .FillColor =_gcaa ;
_febg .BorderEnabled =false ;_afga ,_ ,_ead :=_febg .Draw ("");if _ead !=nil {return nil ,ctx ,_ead ;};_ead =_dbd .addContentsByString (string (_afga ));if _ead !=nil {return nil ,ctx ,_ead ;};};_ddd :=_bdf ._dbg ;_ggc :=_bdf ._gfg ;_bda :=_bdf ._edf ;
_cbb :=_bdf ._dfa ;_ggcg :=_bdf ._dbg ;if _bdf ._gfbe ==CellBorderStyleDouble {_ggcg +=2*_ddd ;};_geb :=_bdf ._gfg ;if _bdf ._efef ==CellBorderStyleDouble {_geb +=2*_ggc ;};_dfe :=_bdf ._edf ;if _bdf ._bgea ==CellBorderStyleDouble {_dfe +=2*_bda ;};_bfg :=_bdf ._dfa ;
if _bdf ._ggb ==CellBorderStyleDouble {_bfg +=2*_cbb ;};_gdce :=(_ggcg -_dfe )/2;_aea :=(_ggcg -_bfg )/2;_dbdc :=(_geb -_dfe )/2;_gfdgd :=(_geb -_bfg )/2;if _bdf ._dbg !=0{_fcc :=_faag ;_fgf :=_eacca ;if _bdf ._gfbe ==CellBorderStyleDouble {_fgf -=_ddd ;
_cbcc :=_ad .BasicLine {LineColor :_adb (_bdf ._bgf ),Opacity :1.0,LineWidth :_bdf ._dbg ,LineStyle :_bdf .LineStyle ,X1 :_fcc -_ggcg /2+_gdce ,Y1 :_fgf +2*_ddd ,X2 :_fcc +_ggcg /2-_aea +_bdf ._dff ,Y2 :_fgf +2*_ddd };_bcg ,_ ,_gdac :=_cbcc .Draw ("");
if _gdac !=nil {return nil ,ctx ,_gdac ;};_gdac =_dbd .addContentsByString (string (_bcg ));if _gdac !=nil {return nil ,ctx ,_gdac ;};};_afed :=_ad .BasicLine {LineWidth :_bdf ._dbg ,Opacity :1.0,LineColor :_adb (_bdf ._bgf ),LineStyle :_bdf .LineStyle ,X1 :_fcc -_ggcg /2+_gdce +(_dfe -_bdf ._edf ),Y1 :_fgf ,X2 :_fcc +_ggcg /2-_aea +_bdf ._dff -(_bfg -_bdf ._dfa ),Y2 :_fgf };
_ggeg ,_ ,_aeab :=_afed .Draw ("");if _aeab !=nil {return nil ,ctx ,_aeab ;};_aeab =_dbd .addContentsByString (string (_ggeg ));if _aeab !=nil {return nil ,ctx ,_aeab ;};};if _bdf ._gfg !=0{_cgea :=_faag ;_aeb :=_eacca -_bdf ._gfb ;if _bdf ._efef ==CellBorderStyleDouble {_aeb +=_ggc ;
_ebf :=_ad .BasicLine {LineWidth :_bdf ._gfg ,Opacity :1.0,LineColor :_adb (_bdf ._gfe ),LineStyle :_bdf .LineStyle ,X1 :_cgea -_geb /2+_dbdc ,Y1 :_aeb -2*_ggc ,X2 :_cgea +_geb /2-_gfdgd +_bdf ._dff ,Y2 :_aeb -2*_ggc };_facd ,_ ,_dee :=_ebf .Draw ("");
if _dee !=nil {return nil ,ctx ,_dee ;};_dee =_dbd .addContentsByString (string (_facd ));if _dee !=nil {return nil ,ctx ,_dee ;};};_cfce :=_ad .BasicLine {LineWidth :_bdf ._gfg ,Opacity :1.0,LineColor :_adb (_bdf ._gfe ),LineStyle :_bdf .LineStyle ,X1 :_cgea -_geb /2+_dbdc +(_dfe -_bdf ._edf ),Y1 :_aeb ,X2 :_cgea +_geb /2-_gfdgd +_bdf ._dff -(_bfg -_bdf ._dfa ),Y2 :_aeb };
_efa ,_ ,_gfcg :=_cfce .Draw ("");if _gfcg !=nil {return nil ,ctx ,_gfcg ;};_gfcg =_dbd .addContentsByString (string (_efa ));if _gfcg !=nil {return nil ,ctx ,_gfcg ;};};if _bdf ._edf !=0{_aaef :=_faag ;_cfdb :=_eacca ;if _bdf ._bgea ==CellBorderStyleDouble {_aaef +=_bda ;
_edc :=_ad .BasicLine {LineWidth :_bdf ._edf ,Opacity :1.0,LineColor :_adb (_bdf ._cdca ),LineStyle :_bdf .LineStyle ,X1 :_aaef -2*_bda ,Y1 :_cfdb +_dfe /2+_gdce ,X2 :_aaef -2*_bda ,Y2 :_cfdb -_dfe /2-_dbdc -_bdf ._gfb };_cae ,_ ,_eab :=_edc .Draw ("");
if _eab !=nil {return nil ,ctx ,_eab ;};_eab =_dbd .addContentsByString (string (_cae ));if _eab !=nil {return nil ,ctx ,_eab ;};};_abe :=_ad .BasicLine {LineWidth :_bdf ._edf ,Opacity :1.0,LineColor :_adb (_bdf ._cdca ),LineStyle :_bdf .LineStyle ,X1 :_aaef ,Y1 :_cfdb +_dfe /2+_gdce -(_ggcg -_bdf ._dbg ),X2 :_aaef ,Y2 :_cfdb -_dfe /2-_dbdc -_bdf ._gfb +(_geb -_bdf ._gfg )};
_fggf ,_ ,_ggg :=_abe .Draw ("");if _ggg !=nil {return nil ,ctx ,_ggg ;};_ggg =_dbd .addContentsByString (string (_fggf ));if _ggg !=nil {return nil ,ctx ,_ggg ;};};if _bdf ._dfa !=0{_cfe :=_faag +_bdf ._dff ;_dgba :=_eacca ;if _bdf ._ggb ==CellBorderStyleDouble {_cfe -=_cbb ;
_bfdf :=_ad .BasicLine {LineWidth :_bdf ._dfa ,Opacity :1.0,LineColor :_adb (_bdf ._bgac ),LineStyle :_bdf .LineStyle ,X1 :_cfe +2*_cbb ,Y1 :_dgba +_bfg /2+_aea ,X2 :_cfe +2*_cbb ,Y2 :_dgba -_bfg /2-_gfdgd -_bdf ._gfb };_abf ,_ ,_bdfd :=_bfdf .Draw ("");
if _bdfd !=nil {return nil ,ctx ,_bdfd ;};_bdfd =_dbd .addContentsByString (string (_abf ));if _bdfd !=nil {return nil ,ctx ,_bdfd ;};};_eag :=_ad .BasicLine {LineWidth :_bdf ._dfa ,Opacity :1.0,LineColor :_adb (_bdf ._bgac ),LineStyle :_bdf .LineStyle ,X1 :_cfe ,Y1 :_dgba +_bfg /2+_aea -(_ggcg -_bdf ._dbg ),X2 :_cfe ,Y2 :_dgba -_bfg /2-_gfdgd -_bdf ._gfb +(_geb -_bdf ._gfg )};
_dbbf ,_ ,_dddf :=_eag .Draw ("");if _dddf !=nil {return nil ,ctx ,_dddf ;};_dddf =_dbd .addContentsByString (string (_dbbf ));if _dddf !=nil {return nil ,ctx ,_dddf ;};};return []*Block {_dbd },ctx ,nil ;};func (_gfba *templateProcessor )parseFloatAttr (_cggca ,_ecgc string )float64 {_ce .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_cggca ,_ecgc );
_ecfgf ,_ :=_gcc .ParseFloat (_ecgc ,64);return _ecfgf ;};func (_gbbf *Image )rotatedSize ()(float64 ,float64 ){_fdbd :=_gbbf ._ddce ;_caeb :=_gbbf ._afea ;_caaf :=_gbbf ._ggggg ;if _caaf ==0{return _fdbd ,_caeb ;};_aadc :=_ad .Path {Points :[]_ad .Point {_ad .NewPoint (0,0).Rotate (_caaf ),_ad .NewPoint (_fdbd ,0).Rotate (_caaf ),_ad .NewPoint (0,_caeb ).Rotate (_caaf ),_ad .NewPoint (_fdbd ,_caeb ).Rotate (_caaf )}}.GetBoundingBox ();
return _aadc .Width ,_aadc .Height ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_fbab *Creator )NewImage (img *_aa .Image )(*Image ,error ){return _dcce (img )};

// SetIndent sets the cell's left indent.
func (_cbdg *TableCell )SetIndent (indent float64 ){_cbdg ._bbad =indent };type cmykColor struct{_dec ,_fbfcd ,_gbd ,_agcb float64 };

// SetAngle sets the rotation angle of the text.
func (_dfff *Paragraph )SetAngle (angle float64 ){_dfff ._ggbaf =angle };const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// FitMode returns the fit mode of the ellipse.
func (_caad *Ellipse )FitMode ()FitMode {return _caad ._efgb };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aafbf *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfee :=ctx ;_eddg :=[]func (_ffda DrawContext )([]*Block ,DrawContext ,error ){_aafbf .generateHeaderBlocks ,_aafbf .generateInformationBlocks ,_aafbf .generateLineBlocks ,_aafbf .generateTotalBlocks ,_aafbf .generateNoteBlocks };
var _cgeb []*Block ;for _ ,_cgbd :=range _eddg {_acag ,_becc ,_geabg :=_cgbd (ctx );if _geabg !=nil {return _cgeb ,ctx ,_geabg ;};if len (_cgeb )==0{_cgeb =_acag ;}else if len (_acag )> 0{_cgeb [len (_cgeb )-1].mergeBlocks (_acag [0]);_cgeb =append (_cgeb ,_acag [1:]...);
};ctx =_becc ;};if _aafbf ._egfg .IsRelative (){ctx .X =_cfee .X ;};if _aafbf ._egfg .IsAbsolute (){return _cgeb ,_cfee ,nil ;};return _cgeb ,ctx ,nil ;};

// SetStyleBottom sets border style for bottom side.
func (_cbc *border )SetStyleBottom (style CellBorderStyle ){_cbc ._efef =style };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_cfbfd *RadialShading )SetAntiAlias (enable bool ){_cfbfd ._dagf .SetAntiAlias (enable )};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_dcee *Chapter )Add (d Drawable )error {if Drawable (_dcee )==d {_ce .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cdd :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_dcee ._fca =append (_dcee ._fca ,d );case containerDrawable :_gafc ,_gfef :=_cdd .ContainerComponent (_dcee );
if _gfef !=nil {return _gfef ;};_dcee ._fca =append (_dcee ._fca ,_gafc );default:_ce .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _b .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func (_deab *Division )drawBackground (_ggf []*Block ,_gccf ,_fdaa DrawContext ,_geae bool )([]*Block ,error ){_ebff :=len (_ggf );if _ebff ==0||_deab ._bede ==nil {return _ggf ,nil ;};_afaa :=make ([]*Block ,0,len (_ggf ));for _ccef ,_abef :=range _ggf {var (_abca =_deab ._bede .BorderRadiusTopLeft ;
_gba =_deab ._bede .BorderRadiusTopRight ;_cdebd =_deab ._bede .BorderRadiusBottomLeft ;_edda =_deab ._bede .BorderRadiusBottomRight ;);_feaa :=_gccf ;_feaa .Page +=_ccef ;if _ccef ==0{if _geae {_afaa =append (_afaa ,_abef );continue ;};if _ebff ==1{_feaa .Height =_fdaa .Y -_gccf .Y ;
};}else {_feaa .X =_feaa .Margins .Left +_deab ._cgf .Left ;_feaa .Y =_feaa .Margins .Top ;_feaa .Width =_feaa .PageWidth -_feaa .Margins .Left -_feaa .Margins .Right -_deab ._cgf .Left -_deab ._cgf .Right ;if _ccef ==_ebff -1{_feaa .Height =_fdaa .Y -_feaa .Margins .Top -_deab ._cgf .Top ;
}else {_feaa .Height =_feaa .PageHeight -_feaa .Margins .Top -_feaa .Margins .Bottom ;};if !_geae {_abca =0;_gba =0;};};if _ebff > 1&&_ccef !=_ebff -1{_cdebd =0;_edda =0;};_geaa :=_aefc (_feaa .X ,_feaa .Y ,_feaa .Width ,_feaa .Height );_geaa .SetFillColor (_deab ._bede .FillColor );
_geaa .SetBorderColor (_deab ._bede .BorderColor );_geaa .SetBorderWidth (_deab ._bede .BorderSize );_geaa .SetBorderRadius (_abca ,_gba ,_cdebd ,_edda );_gaead ,_ ,_ege :=_geaa .GeneratePageBlocks (_feaa );if _ege !=nil {return nil ,_ege ;};if len (_gaead )==0{continue ;
};_fdeg :=_gaead [0];if _ege =_fdeg .mergeBlocks (_abef );_ege !=nil {return nil ,_ege ;};_afaa =append (_afaa ,_fdeg );};return _afaa ,nil ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_gbag *Invoice )Notes ()(string ,string ){return _gbag ._eegf [0],_gbag ._eegf [1]};func (_dgae *templateProcessor )parseParagraph (_ddcff *templateNode ,_bgbga *Paragraph )(interface{},error ){if _bgbga ==nil {_bgbga =_dgae .creator .NewParagraph ("");
};for _ ,_ggbcc :=range _ddcff ._gcbdb .Attr {_agffc :=_ggbcc .Value ;switch _dabecf :=_ggbcc .Name .Local ;_dabecf {case "\u0066\u006f\u006e\u0074":_bgbga .SetFont (_dgae .parseFontAttr (_dabecf ,_agffc ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_bgbga .SetFontSize (_dgae .parseFloatAttr (_dabecf ,_agffc ));
case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_bgbga .SetTextAlignment (_dgae .parseTextAlignmentAttr (_dabecf ,_agffc ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_bgbga .SetLineHeight (_dgae .parseFloatAttr (_dabecf ,_agffc ));
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_bgbga .SetEnableWrap (_dgae .parseBoolAttr (_dabecf ,_agffc ));case "\u0063\u006f\u006co\u0072":_bgbga .SetColor (_dgae .parseColorAttr (_dabecf ,_agffc ));case "\u0078":_bgbga .SetPos (_dgae .parseFloatAttr (_dabecf ,_agffc ),_bgbga ._gaba );
case "\u0079":_bgbga .SetPos (_bgbga ._eedf ,_dgae .parseFloatAttr (_dabecf ,_agffc ));case "\u0061\u006e\u0067l\u0065":_bgbga .SetAngle (_dgae .parseFloatAttr (_dabecf ,_agffc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_babgb :=_dgae .parseMarginAttr (_dabecf ,_agffc );
_bgbga .SetMargins (_babgb .Left ,_babgb .Right ,_babgb .Top ,_babgb .Bottom );case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_bgbga .SetMaxLines (int (_dgae .parseInt64Attr (_dabecf ,_agffc )));default:_dgae .nodeLogDebug (_ddcff ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_dabecf );
};};return _bgbga ,nil ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_abdda *StyledParagraph )Insert (index uint ,text string )*TextChunk {_fdgd :=uint (len (_abdda ._fcfcf ));if index > _fdgd {index =_fdgd ;};_cfced :=NewTextChunk (text ,_abdda ._gfdbdf );_abdda ._fcfcf =append (_abdda ._fcfcf [:index ],append ([]*TextChunk {_cfced },_abdda ._fcfcf [index :]...)...);
_abdda .wrapText ();return _cfced ;};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_baab *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _aefc (x ,y ,width ,height );};func (_bdada *StyledParagraph )split (_gabg DrawContext )(_aafag ,_daac *StyledParagraph ,_ccabc error ){if _ccabc =_bdada .wrapChunks (false );
_ccabc !=nil {return nil ,nil ,_ccabc ;};if len (_bdada ._gaca )==1&&_bdada ._ffafa > _gabg .Height {return _bdada ,nil ,nil ;};_gdfda :=func (_bcffd []*TextChunk ,_ebdb []*TextChunk )[]*TextChunk {if len (_ebdb )==0{return _bcffd ;};_ffdac :=len (_bcffd );
if _ffdac ==0{return append (_bcffd ,_ebdb ...);};if _bcffd [_ffdac -1].Style ==_ebdb [0].Style {_bcffd [_ffdac -1].Text +=_ebdb [0].Text ;}else {_bcffd =append (_bcffd ,_ebdb [0]);};return append (_bcffd ,_ebdb [1:]...);};_agcd :=func (_degf *StyledParagraph ,_edcf []*TextChunk )*StyledParagraph {if len (_edcf )==0{return nil ;
};_dbgee :=*_degf ;_dbgee ._fcfcf =_edcf ;return &_dbgee ;};var (_eefde float64 ;_baffc []*TextChunk ;_ecdc []*TextChunk ;);for _ ,_bbaad :=range _bdada ._gaca {var _dafce float64 ;_bgbg :=make ([]*TextChunk ,0,len (_bbaad ));for _ ,_gcfgea :=range _bbaad {if _aaag :=_gcfgea .Style .FontSize ;
_aaag > _dafce {_dafce =_aaag ;};_bgbg =append (_bgbg ,_gcfgea .clone ());};_dafce *=_bdada ._ffafa ;if _bdada ._bfgcf .IsRelative (){if _eefde +_dafce > _gabg .Height {_ecdc =_gdfda (_ecdc ,_bgbg );}else {_baffc =_gdfda (_baffc ,_bgbg );};};_eefde +=_dafce ;
};_bdada ._gaca =nil ;if len (_ecdc )==0{return _bdada ,nil ,nil ;};return _agcd (_bdada ,_baffc ),_agcd (_bdada ,_ecdc ),nil ;};

// SetLevel sets the indentation level of the TOC line.
func (_adccb *TOCLine )SetLevel (level uint ){_adccb ._edac =level ;_adccb ._eggfe ._gcdca .Left =_adccb ._fbedc +float64 (_adccb ._edac -1)*_adccb ._cfeda ;};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_eadgd *Ellipse )GetCoords ()(float64 ,float64 ){return _eadgd ._eadc ,_eadgd ._ffaga };

// Append adds a new text chunk to the paragraph.
func (_aacge *StyledParagraph )Append (text string )*TextChunk {_afef :=NewTextChunk (text ,_aacge ._gfdbdf );return _aacge .appendChunk (_afef );};var PPI float64 =72;func _gffgg (_bbaaa *templateProcessor ,_edbeg *templateNode )(interface{},error ){return _bbaaa .parseDivision (_edbeg );
};func (_fdage *templateProcessor )parseFloatArray (_bfdg ,_gbfce string )[]float64 {_ce .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bfdg ,_gbfce );
_facb :=_gc .Fields (_gbfce );_bdcgf :=make ([]float64 ,0,len (_facb ));for _ ,_gbcea :=range _facb {_dgbdgg ,_ :=_gcc .ParseFloat (_gbcea ,64);_bdcgf =append (_bdcgf ,_dgbdgg );};return _bdcgf ;};

// NewDivision returns a new Division container component.
func (_edcg *Creator )NewDivision ()*Division {return _bggc ()};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_gbgb *_ad .PolyBezierCurve ;_abbb float64 ;_babg float64 ;_afgcf Color ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_eccgcc *TOC )SetLineSeparatorStyle (style TextStyle ){_eccgcc ._gdddd =style };

// Heading returns the heading component of the table of contents.
func (_baaad *TOC )Heading ()*StyledParagraph {return _baaad ._cbggb };func _fbfg (_ageg TextStyle )*StyledParagraph {return &StyledParagraph {_fcfcf :[]*TextChunk {},_gfdbdf :_ageg ,_fbga :_gbga (_ageg .Font ),_ffafa :1.0,_bfad :TextAlignmentLeft ,_eacd :true ,_bbca :true ,_cefc :false ,_aggf :0,_cabe :1,_bage :1,_bfgcf :PositionRelative };
};

// SetBorderOpacity sets the border opacity.
func (_bbbe *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_bbbe ._babg =opacity };

// SetFillOpacity sets the fill opacity.
func (_beac *Polygon )SetFillOpacity (opacity float64 ){_beac ._ebgd =opacity };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_acbga *TOC )SetLineNumberStyle (style TextStyle ){_acbga ._faff =style };

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_cgcf *LinearShading )ToPdfShadingPattern ()*_aa .PdfShadingPatternType2 {_gafd ,_bedcd ,_dfeb :=_cgcf ._cgfe ._egfd .ToRGB ();_ffdbe :=_cgcf .shadingModel ();_ffdbe .PdfShading .Background =_e .MakeArrayFromFloats ([]float64 {_gafd ,_bedcd ,_dfeb });
_eccgb :=_aa .NewPdfShadingPatternType2 ();_eccgb .Shading =_ffdbe ;return _eccgb ;};func (_adga *pageTransformations )applyFlip (_dgbfa *_aa .PdfPage )error {_bbdf ,_dde :=_adga ._gdaa ,_adga ._bdgd ;if !_bbdf &&!_dde {return nil ;};if _dgbfa ==nil {return _b .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_aba ,_dfda :=_dgbfa .GetMediaBox ();if _dfda !=nil {return _dfda ;};_gac ,_aadb :=_aba .Width (),_aba .Height ();_ddda ,_dfda :=_dgbfa .GetRotate ();if _dfda !=nil {_ce .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_dfda .Error ());
};if _cbae :=_ddda %360!=0&&_ddda %90==0;_cbae {if _cbd :=(360+_ddda %360)%360;_cbd ==90||_cbd ==270{_bbdf ,_dde =_dde ,_bbdf ;};};_aec ,_ecb :=1.0,0.0;if _bbdf {_aec ,_ecb =-1.0,-_gac ;};_dcc ,_gga :=1.0,0.0;if _dde {_dcc ,_gga =-1.0,-_aadb ;};_dffe :=_ae .NewContentCreator ().Scale (_aec ,_dcc ).Translate (_ecb ,_gga );
_eba ,_dfda :=_e .MakeStream (_dffe .Bytes (),_e .NewFlateEncoder ());if _dfda !=nil {return _dfda ;};_adea :=_e .MakeArray (_eba );_adea .Append (_dgbfa .GetContentStreamObjs ()...);_dgbfa .Contents =_adea ;return nil ;};func _agde (_gefd string ,_ffcg TextStyle )*Paragraph {_adec :=&Paragraph {_adad :_gefd ,_gacgc :_ffcg .Font ,_ffbe :_ffcg .FontSize ,_gabb :1.0,_eeda :true ,_cbga :true ,_bcdbb :TextAlignmentLeft ,_ggbaf :0,_beaa :1,_ecag :1,_bdag :PositionRelative };
_adec .SetColor (_ffcg .Color );return _adec ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_cada *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cada ._aaefc .Left ,_cada ._aaefc .Right ,_cada ._aaefc .Top ,_cada ._aaefc .Bottom ;};func (_abcag *templateProcessor )processGradientColorPair (_cgee []string )(_ebbaa []Color ,_bddac []float64 ){for _ ,_gdcde :=range _cgee {var (_edgc =_gc .Fields (_gdcde );
_ffgcf =len (_edgc ););if _ffgcf ==0{continue ;};_fdfg :="";if _ffgcf > 1{_fdfg =_gc .TrimSpace (_edgc [1]);};_dfdc :=-1.0;if _gc .HasSuffix (_fdfg ,"\u0025"){_fcbeb ,_bbagg :=_gcc .ParseFloat (_fdfg [:len (_fdfg )-1],64);if _bbagg !=nil {_ce .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_bbagg );
};_dfdc =_fcbeb /100.0;};_adedg :=_abcag .parseColor (_gc .TrimSpace (_edgc [0]));if _adedg !=nil {_ebbaa =append (_ebbaa ,_adedg );_bddac =append (_bddac ,_dfdc );};};if len (_ebbaa )!=len (_bddac ){_ce .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_edddd :=-1;_ddbf :=0.0;for _efge ,_ceecb :=range _bddac {if _ceecb ==-1.0{if _efge ==0{_ceecb =0.0;_bddac [_efge ]=0.0;continue ;};_edddd ++;if _efge < len (_bddac )-1{continue ;}else {_ceecb =1.0;_bddac [_efge ]=1.0;};};_dggcd :=_edddd +1;
for _cdfgb :=_efge -_edddd ;_cdfgb < _efge ;_cdfgb ++{_bddac [_cdfgb ]=_ddbf +(float64 (_cdfgb )*(_ceecb -_ddbf )/float64 (_dggcd ));};_ddbf =_ceecb ;_edddd =-1;};return _ebbaa ,_bddac ;};

// Logo returns the logo of the invoice.
func (_abefg *Invoice )Logo ()*Image {return _abefg ._fafe };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_eadc float64 ;_ffaga float64 ;_cgec float64 ;_dceeg float64 ;_bgdc Positioning ;_ffde Color ;_bce float64 ;_bdfg Color ;_ggcgf float64 ;_gbdg float64 ;_geab Margins ;_efgb FitMode ;};func (_eagb *TOCLine )prepareParagraph (_afcbf *StyledParagraph ,_eeceb DrawContext ){_edgcb :=_eagb .Title .Text ;
if _eagb .Number .Text !=""{_edgcb ="\u0020"+_edgcb ;};_edgcb +="\u0020";_bfdfg :=_eagb .Page .Text ;if _bfdfg !=""{_bfdfg ="\u0020"+_bfdfg ;};_afcbf ._fcfcf =[]*TextChunk {{Text :_eagb .Number .Text ,Style :_eagb .Number .Style ,_eafe :_eagb .getLineLink ()},{Text :_edgcb ,Style :_eagb .Title .Style ,_eafe :_eagb .getLineLink ()},{Text :_bfdfg ,Style :_eagb .Page .Style ,_eafe :_eagb .getLineLink ()}};
_afcbf .wrapText ();_acgd :=len (_afcbf ._gaca );if _acgd ==0{return ;};_eggda :=_eeceb .Width *1000-_afcbf .getTextLineWidth (_afcbf ._gaca [_acgd -1]);_bbce :=_afcbf .getTextLineWidth ([]*TextChunk {&_eagb .Separator });_ffadd :=int (_eggda /_bbce );
_fecaae :=_gc .Repeat (_eagb .Separator .Text ,_ffadd );_eecg :=_eagb .Separator .Style ;_affa :=_afcbf .Insert (2,_fecaae );_affa .Style =_eecg ;_affa ._eafe =_eagb .getLineLink ();_eggda =_eggda -float64 (_ffadd )*_bbce ;if _eggda > 500{_ggaba ,_abadfc :=_eecg .Font .GetRuneMetrics (' ');
if _abadfc &&_eggda > _ggaba .Wx {_cgaa :=int (_eggda /_ggaba .Wx );if _cgaa > 0{_aaaac :=_eecg ;_aaaac .FontSize =1;_affa =_afcbf .Insert (2,_gc .Repeat ("\u0020",_cgaa ));_affa .Style =_aaaac ;_affa ._eafe =_eagb .getLineLink ();};};};};func (_fcbab *templateProcessor )parseStyledParagraph (_ecbdb *templateNode )(interface{},error ){_cdaef :=_fcbab .creator .NewStyledParagraph ();
for _ ,_geaf :=range _ecbdb ._gcbdb .Attr {_deedd :=_geaf .Value ;switch _fabee :=_geaf .Name .Local ;_fabee {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cdaef .SetTextAlignment (_fcbab .parseTextAlignmentAttr (_fabee ,_deedd ));
case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cdaef .SetTextVerticalAlignment (_fcbab .parseTextVerticalAlignmentAttr (_fabee ,_deedd ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_cdaef .SetLineHeight (_fcbab .parseFloatAttr (_fabee ,_deedd ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_dcead :=_fcbab .parseMarginAttr (_fabee ,_deedd );_cdaef .SetMargins (_dcead .Left ,_dcead .Right ,_dcead .Top ,_dcead .Bottom );case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_cdaef .SetEnableWrap (_fcbab .parseBoolAttr (_fabee ,_deedd ));
case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_cdaef .EnableWordWrap (_fcbab .parseBoolAttr (_fabee ,_deedd ));case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_cdaef .SetTextOverflow (_fcbab .parseTextOverflowAttr (_fabee ,_deedd ));
case "\u0078":_cdaef .SetPos (_fcbab .parseFloatAttr (_fabee ,_deedd ),_cdaef ._afgd );case "\u0079":_cdaef .SetPos (_cdaef ._aedfg ,_fcbab .parseFloatAttr (_fabee ,_deedd ));case "\u0061\u006e\u0067l\u0065":_cdaef .SetAngle (_fcbab .parseFloatAttr (_fabee ,_deedd ));
default:_fcbab .nodeLogDebug (_ecbdb ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fabee );
};};return _cdaef ,nil ;};func _ffgbd (_adeba *templateProcessor ,_eegfg *templateNode )(interface{},error ){return _adeba .parseTableCell (_eegfg );};func _abc (_afb ,_cdbg *_aa .PdfPageResources )error {_dfb ,_ :=_afb .GetColorspaces ();if _dfb !=nil &&len (_dfb .Colorspaces )> 0{for _feec ,_bfba :=range _dfb .Colorspaces {_bcca :=*_e .MakeName (_feec );
if _cdbg .HasColorspaceByName (_bcca ){continue ;};_dcf :=_cdbg .SetColorspaceByName (_bcca ,_bfba );if _dcf !=nil {return _dcf ;};};};return nil ;};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_bgfed *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_bgfed ._ebgg .Left =left ;_bgfed ._ebgg .Right =right ;_bgfed ._ebgg .Top =top ;_bgfed ._ebgg .Bottom =bottom ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_gcg *Creator )NewTextStyle ()TextStyle {return _geddb (_gcg ._edbc )};

// GeneratePageBlocks draws the chart onto a block.
func (_bac *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dggbc :=ctx ;_ede :=_bac ._egg .IsRelative ();var _abdd []*Block ;if _ede {_dceb :=1.0;_eadd :=_bac ._feeca .Top ;if float64 (_bac ._cedg .Height ())> ctx .Height -_bac ._feeca .Top {_abdd =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _cfa error ;if _ ,ctx ,_cfa =_ccce ().GeneratePageBlocks (ctx );_cfa !=nil {return nil ,ctx ,_cfa ;};_eadd =0;};ctx .X +=_bac ._feeca .Left +_dceb ;ctx .Y +=_eadd ;ctx .Width -=_bac ._feeca .Left +_bac ._feeca .Right +2*_dceb ;ctx .Height -=_eadd ;
_bac ._cedg .SetWidth (int (ctx .Width ));}else {ctx .X =_bac ._ccbb ;ctx .Y =_bac ._abd ;};_addc :=_ae .NewContentCreator ();_addc .Translate (0,ctx .PageHeight );_addc .Scale (1,-1);_addc .Translate (ctx .X ,ctx .Y );_feg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
_bac ._cedg .Render (_fbb .NewRenderer (_addc ,_feg ._ddc ),nil );if _eee :=_feg .addContentsByString (_addc .String ());_eee !=nil {return nil ,ctx ,_eee ;};if _ede {_aegg :=_bac .Height ()+_bac ._feeca .Bottom ;ctx .Y +=_aegg ;ctx .Height -=_aegg ;}else {ctx =_dggbc ;
};_abdd =append (_abdd ,_feg );return _abdd ,ctx ,nil ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_dggb *Chapter )SetIncludeInTOC (includeInTOC bool ){_dggb ._bae =includeInTOC };func (_gacb *Invoice )generateInformationBlocks (_aaeb DrawContext )([]*Block ,DrawContext ,error ){_aafb :=_fbfg (_gacb ._ebea );_aafb .SetMargins (0,0,0,20);_fcdd :=_gacb .drawAddress (_gacb ._edcbb );
_fcdd =append (_fcdd ,_aafb );_fcdd =append (_fcdd ,_gacb .drawAddress (_gacb ._bec )...);_fbgga :=_bggc ();for _ ,_ffed :=range _fcdd {_fbgga .Add (_ffed );};_agab :=_gacb .drawInformation ();_feee :=_baea (2);_feee .SetMargins (0,0,25,0);_egff :=_feee .NewCell ();
_egff .SetIndent (0);_egff .SetContent (_fbgga );_egff =_feee .NewCell ();_egff .SetContent (_agab );return _feee .GeneratePageBlocks (_aaeb );};

// Indent returns the left offset of the list when nested into another list.
func (_ffaf *List )Indent ()float64 {return _ffaf ._ecbc };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_ebcb *LinearShading )SetBackgroundColor (backgroundColor Color ){_ebcb ._cgfe .SetBackgroundColor (backgroundColor );};func (_dbcfg *Invoice )newColumn (_ggggb string ,_aabfe CellHorizontalAlignment )*InvoiceCell {_cege :=&InvoiceCell {_dbcfg ._cfea ,_ggggb };
_cege .Alignment =_aabfe ;return _cege ;};func (_gafga *templateProcessor )parseCellAlignmentAttr (_ggade ,_feced string )CellHorizontalAlignment {_ce .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ggade ,_feced );
_gadba :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_feced ];return _gadba ;
};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gcfg *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _gcfg ._fcbe [0],_gcfg ._fcbe [1]};

// NewPolyline creates a new polyline.
func (_aeec *Creator )NewPolyline (points []_ad .Point )*Polyline {return _geedg (points )};func _adb (_dfdg Color )_aa .PdfColor {if _dfdg ==nil {_dfdg =ColorBlack ;};switch _bcgc :=_dfdg .(type ){case cmykColor :return _aa .NewPdfColorDeviceCMYK (_bcgc ._dec ,_bcgc ._fbfcd ,_bcgc ._gbd ,_bcgc ._agcb );
case *LinearShading :return _aa .NewPdfColorPatternType2 ();case *RadialShading :return _aa .NewPdfColorPatternType3 ();};return _aa .NewPdfColorDeviceRGB (_dfdg .ToRGB ());};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_gcgg Drawable )(Drawable ,error );};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_bcbca DrawContext )([]*Block ,DrawContext ,error );};

// Lines returns all the rows of the invoice line items table.
func (_bgad *Invoice )Lines ()[][]*InvoiceCell {return _bgad ._bcdb };

// SetBorderOpacity sets the border opacity of the rectangle.
func (_bbggd *Rectangle )SetBorderOpacity (opacity float64 ){_bbggd ._gfdfab =opacity };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_ddde *TOC )SetLineSeparator (separator string ){_ddde ._egga =separator };func _adafg (_gafe *Creator ,_daeb string ,_cdgae []byte ,_bgbf *TemplateOptions ,_cedd componentRenderer )*templateProcessor {if _bgbf ==nil {_bgbf =&TemplateOptions {};};
_bgbf .init ();if _cedd ==nil {_cedd =_gafe ;};return &templateProcessor {creator :_gafe ,_edbe :_cdgae ,_agfcg :_bgbf ,_effb :_cedd ,_dgbff :_daeb };};

// Inline returns whether the inline mode of the division is active.
func (_fgfb *Division )Inline ()bool {return _fgfb ._dcfb };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_daaa *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _bcgcb (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gbee *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _gbee ._gaad [0],_gbee ._gaad [1]};

// Link returns link information for this line.
func (_ccgdb *TOCLine )Link ()(_dcafd int64 ,_fbacd ,_ddfde float64 ){return _ccgdb ._gggf ,_ccgdb ._gfece ,_ccgdb ._gedabe ;};func (_afeg *templateProcessor )parseLine (_eeae *templateNode )(interface{},error ){_agea :=_afeg .creator .NewLine (0,0,0,0);
for _ ,_ggde :=range _eeae ._gcbdb .Attr {_ggdc :=_ggde .Value ;switch _cbca :=_ggde .Name .Local ;_cbca {case "\u0078\u0031":_agea ._ccfd =_afeg .parseFloatAttr (_cbca ,_ggdc );case "\u0079\u0031":_agea ._fbbgd =_afeg .parseFloatAttr (_cbca ,_ggdc );case "\u0078\u0032":_agea ._fede =_afeg .parseFloatAttr (_cbca ,_ggdc );
case "\u0079\u0032":_agea ._bdea =_afeg .parseFloatAttr (_cbca ,_ggdc );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_agea .SetLineWidth (_afeg .parseFloatAttr (_cbca ,_ggdc ));case "\u0063\u006f\u006co\u0072":_agea .SetColor (_afeg .parseColorAttr (_cbca ,_ggdc ));
case "\u0073\u0074\u0079l\u0065":_agea .SetStyle (_afeg .parseLineStyleAttr (_cbca ,_ggdc ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_agea .SetDashPattern (_afeg .parseInt64Array (_cbca ,_ggdc ),_agea ._dbec );case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_agea .SetDashPattern (_agea ._feeec ,_afeg .parseInt64Attr (_cbca ,_ggdc ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_agea .SetOpacity (_afeg .parseFloatAttr (_cbca ,_ggdc ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_agea .SetPositioning (_afeg .parsePositioningAttr (_cbca ,_ggdc ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_agea .SetFitMode (_afeg .parseFitModeAttr (_cbca ,_ggdc ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_cbgga :=_afeg .parseMarginAttr (_cbca ,_ggdc );_agea .SetMargins (_cbgga .Left ,_cbgga .Right ,_cbgga .Top ,_cbgga .Bottom );default:_afeg .nodeLogDebug (_eeae ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cbca );
};};return _agea ,nil ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);func (_cff *Creator )initContext (){_cff ._aaa .X =_cff ._bag .Left ;_cff ._aaa .Y =_cff ._bag .Top ;
_cff ._aaa .Width =_cff ._fddd -_cff ._bag .Right -_cff ._bag .Left ;_cff ._aaa .Height =_cff ._ccdb -_cff ._bag .Bottom -_cff ._bag .Top ;_cff ._aaa .PageHeight =_cff ._ccdb ;_cff ._aaa .PageWidth =_cff ._fddd ;_cff ._aaa .Margins =_cff ._bag ;_cff ._aaa ._eebb =_cff .UnsupportedCharacterReplacement ;
};func (_ffba *StyledParagraph )wrapChunks (_bfbee bool )error {if !_ffba ._eacd ||int (_ffba ._fffe )<=0{_ffba ._gaca =[][]*TextChunk {_ffba ._fcfcf };return nil ;};if _ffba ._cefc {_ffba .wrapWordChunks ();};_ffba ._gaca =[][]*TextChunk {};var _egbc []*TextChunk ;
var _dbedc float64 ;_badbg :=_dd .IsSpace ;if !_bfbee {_badbg =func (rune )bool {return false };};_ffcga :=_acac (_ffba ._fffe *1000.0,0.000001);for _ ,_dgbc :=range _ffba ._fcfcf {_agbgd :=_dgbc .Style ;_bafefd :=_dgbc ._eafe ;_ebdee :=_dgbc .VerticalAlignment ;
var (_bfeb []rune ;_geagf []float64 ;);_gfda :=_adfe (_dgbc .Text );for _ ,_dgfb :=range _dgbc .Text {if _dgfb =='\u000A'{if !_bfbee {_bfeb =append (_bfeb ,_dgfb );};_egbc =append (_egbc ,&TextChunk {Text :_gc .TrimRightFunc (string (_bfeb ),_badbg ),Style :_agbgd ,_eafe :_befeb (_bafefd ),VerticalAlignment :_ebdee });
_ffba ._gaca =append (_ffba ._gaca ,_egbc );_egbc =nil ;_dbedc =0;_bfeb =nil ;_geagf =nil ;continue ;};_eegae :=_dgfb ==' ';_eebbb ,_ggce :=_agbgd .Font .GetRuneMetrics (_dgfb );if !_ggce {_ce .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dgfb );
return _b .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_daabc :=_agbgd .FontSize *_eebbb .Wx *_agbgd .horizontalScale ();_dcaf :=_daabc ;if !_eegae {_dcaf =_daabc +_agbgd .CharSpacing *1000.0;
};if _dbedc +_daabc > _ffcga {_gffd :=-1;if !_eegae {for _ecbbe :=len (_bfeb )-1;_ecbbe >=0;_ecbbe --{if _bfeb [_ecbbe ]==' '{_gffd =_ecbbe ;break ;};};};if _ffba ._cefc {if len (_egbc )> 0{_ffba ._gaca =append (_ffba ._gaca ,_egbc );_egbc =[]*TextChunk {};
};_bfeb =append (_bfeb ,_dgfb );_geagf =append (_geagf ,_dcaf );if _gffd >=0{_bfeb =_bfeb [_gffd +1:];_geagf =_geagf [_gffd +1:];};_dbedc =0;for _ ,_gcfbg :=range _geagf {_dbedc +=_gcfbg ;};if _dbedc > _ffcga {_fecf :=string (_bfeb [:len (_bfeb )-1]);_fecf =_gbggf (_fecf ,_gfda );
if !_bfbee &&_eegae {_fecf +="\u0020";};_egbc =append (_egbc ,&TextChunk {Text :_gc .TrimRightFunc (_fecf ,_badbg ),Style :_agbgd ,_eafe :_befeb (_bafefd ),VerticalAlignment :_ebdee });_ffba ._gaca =append (_ffba ._gaca ,_egbc );_egbc =[]*TextChunk {};
_bfeb =[]rune {_dgfb };_geagf =[]float64 {_dcaf };_dbedc =_dcaf ;};continue ;};_aafca :=string (_bfeb );if _gffd >=0{_aafca =string (_bfeb [0:_gffd +1]);_bfeb =_bfeb [_gffd +1:];_bfeb =append (_bfeb ,_dgfb );_geagf =_geagf [_gffd +1:];_geagf =append (_geagf ,_dcaf );
_dbedc =0;for _ ,_ddceb :=range _geagf {_dbedc +=_ddceb ;};}else {if _eegae {_dbedc =0;_bfeb =[]rune {};_geagf =[]float64 {};}else {_dbedc =_dcaf ;_bfeb =[]rune {_dgfb };_geagf =[]float64 {_dcaf };};};_aafca =_gbggf (_aafca ,_gfda );if !_bfbee &&_eegae {_aafca +="\u0020";
};_egbc =append (_egbc ,&TextChunk {Text :_gc .TrimRightFunc (_aafca ,_badbg ),Style :_agbgd ,_eafe :_befeb (_bafefd ),VerticalAlignment :_ebdee });_ffba ._gaca =append (_ffba ._gaca ,_egbc );_egbc =[]*TextChunk {};}else {_dbedc +=_dcaf ;_bfeb =append (_bfeb ,_dgfb );
_geagf =append (_geagf ,_dcaf );};};if len (_bfeb )> 0{_fadgda :=_gbggf (string (_bfeb ),_gfda );_egbc =append (_egbc ,&TextChunk {Text :_fadgda ,Style :_agbgd ,_eafe :_befeb (_bafefd ),VerticalAlignment :_ebdee });};};if len (_egbc )> 0{_ffba ._gaca =append (_ffba ._gaca ,_egbc );
};return nil ;};func (_bbgd *StyledParagraph )wrapWordChunks (){if !_bbgd ._cefc {return ;};var (_dcdb []*TextChunk ;_dcdg *_aa .PdfFont ;);for _ ,_acefe :=range _bbgd ._fcfcf {_gbagf :=[]rune (_acefe .Text );if _dcdg ==nil {_dcdg =_acefe .Style .Font ;
};_beda :=_acefe ._eafe ;_fcbfe :=_acefe .VerticalAlignment ;if len (_dcdb )> 0{if len (_gbagf )==1&&_dd .IsPunct (_gbagf [0])&&_acefe .Style .Font ==_dcdg {_eead :=[]rune (_dcdb [len (_dcdb )-1].Text );_dcdb [len (_dcdb )-1].Text =string (append (_eead ,_gbagf [0]));
continue ;}else {_ ,_bcegb :=_gcc .Atoi (_acefe .Text );if _bcegb ==nil {_ecdb :=[]rune (_dcdb [len (_dcdb )-1].Text );_efcd :=len (_ecdb );if _efcd >=2{_ ,_faad :=_gcc .Atoi (string (_ecdb [_efcd -2]));if _faad ==nil &&_dd .IsPunct (_ecdb [_efcd -1]){_dcdb [len (_dcdb )-1].Text =string (append (_ecdb ,_gbagf ...));
continue ;};};};};};_cddgb ,_egcd :=_fggd (_acefe .Text );if _egcd !=nil {_ce .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_egcd );
_cddgb =[]string {_acefe .Text };};for _ ,_ddgf :=range _cddgb {_efbde :=NewTextChunk (_ddgf ,_acefe .Style );_efbde ._eafe =_befeb (_beda );_efbde .VerticalAlignment =_fcbfe ;_dcdb =append (_dcdb ,_efbde );};_dcdg =_acefe .Style .Font ;};if len (_dcdb )> 0{_bbgd ._fcfcf =_dcdb ;
};};

// NewImageFromFile creates an Image from a file.
func (_afba *Creator )NewImageFromFile (path string )(*Image ,error ){return _abad (path )};

// SetWidthLeft sets border width for left.
func (_gfee *border )SetWidthLeft (bw float64 ){_gfee ._edf =bw };

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_fdddc *shading )SetExtends (start bool ,end bool ){_fdddc ._cfddb =[]bool {start ,end }};

// GeneratePageBlocks draws the curve onto page blocks.
func (_ecff *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cafg :=_ae .NewContentCreator ();_cafg .Add_q ().Add_w (_ecff ._cfed ).SetStrokingColor (_adb (_ecff ._acgb )).Add_m (_ecff ._bgggf ,ctx .PageHeight -_ecff ._cfda ).Add_v (_ecff ._ccge ,ctx .PageHeight -_ecff ._fbaf ,_ecff ._edag ,ctx .PageHeight -_ecff ._dbea ).Add_S ().Add_Q ();
_ddeb :=_eeb .addContentsByString (_cafg .String ());if _ddeb !=nil {return nil ,ctx ,_ddeb ;};return []*Block {_eeb },ctx ,nil ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_egd *Table )EnableRowWrap (enable bool ){_egd ._cggd =enable };

// FillColor returns the fill color of the rectangle.
func (_fgfcg *Rectangle )FillColor ()Color {return _fgfcg ._fdgf };func (_bcbc *Block )mergeBlocks (_dgb *Block )error {_bdb :=_gaa (_bcbc ._aae ,_bcbc ._ddc ,_dgb ._aae ,_dgb ._ddc );if _bdb !=nil {return _bdb ;};for _ ,_acfb :=range _dgb ._af {_bcbc .AddAnnotation (_acfb );
};return nil ;};

// SetBorderColor sets border color of the rectangle.
func (_afged *Rectangle )SetBorderColor (col Color ){_afged ._aebf =col };

// SetRowPosition sets cell row position.
func (_dgafd *TableCell )SetRowPosition (row int ){_dgafd ._afefg =row };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_eebg *Invoice )SetNoteStyle (style TextStyle ){_eebg ._cfedb =style };

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};func (_abdb *Table )sortCells (){_ga .Slice (_abdb ._dfaeg ,func (_cgddc ,_fgfca int )bool {_bbgc :=_abdb ._dfaeg [_cgddc ]._afefg ;
_acegc :=_abdb ._dfaeg [_fgfca ]._afefg ;if _bbgc < _acegc {return true ;};if _bbgc > _acegc {return false ;};return _abdb ._dfaeg [_cgddc ]._dbbgc < _abdb ._dfaeg [_fgfca ]._dbbgc ;});};func _adfe (_ggcef string )bool {_cacg :=func (_ggdeb rune )bool {return _ggdeb =='\u000A'};
_dgefd :=_gc .TrimFunc (_ggcef ,_cacg );_afffc :=_bb .Paragraph {};_ ,_fcgf :=_afffc .SetString (_dgefd );if _fcgf !=nil {return true ;};_cabce ,_fcgf :=_afffc .Order ();if _fcgf !=nil {return true ;};if _cabce .NumRuns ()< 1{return true ;};return _afffc .IsLeftToRight ();
};

// NewPolygon creates a new polygon.
func (_cga *Creator )NewPolygon (points [][]_ad .Point )*Polygon {return _abcdb (points )};

// SetBorderRadius sets the radius of the background corners.
func (_fe *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_fe .BorderRadiusTopLeft =topLeft ;_fe .BorderRadiusTopRight =topRight ;_fe .BorderRadiusBottomLeft =bottomLeft ;_fe .BorderRadiusBottomRight =bottomRight ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_cddc *Creator )MoveDown (dy float64 ){_cddc ._aaa .Y +=dy };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_bbfg *Paragraph )Height ()float64 {_bbfg .wrapText ();return float64 (len (_bbfg ._agac ))*_bbfg ._gabb *_bbfg ._ffbe ;};

// Scale scales Image by a constant factor, both width and height.
func (_ddg *Image )Scale (xFactor ,yFactor float64 ){_ddg ._ddce =xFactor *_ddg ._ddce ;_ddg ._afea =yFactor *_ddg ._afea ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ag .ChartRenderable )*Chart {return _bgc (chart )};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_egb *Creator )RotateDeg (angleDeg int64 )error {_aggd :=_egb .getActivePage ();if _aggd ==nil {_ce .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _b .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_ce .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _ebe int64 ;if _aggd .Rotate !=nil {_ebe =*(_aggd .Rotate );};_ebe +=angleDeg ;_aggd .Rotate =&_ebe ;return nil ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_cggge *TableCell )SetContent (vd VectorDrawable )error {switch _cfaed :=vd .(type ){case *Paragraph :if _cfaed ._cbga {_cfaed ._eeda =true ;};_cggge ._afgge =vd ;case *StyledParagraph :if _cfaed ._bbca {_cfaed ._eacd =true ;};_cggge ._afgge =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_cggge ._afgge =vd ;default:_ce .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _e .ErrTypeError ;};return nil ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_gabc *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gabf []*Block ;_gdbc bool ;_dgcb error ;_gbbd =_gabc ._gbgf .IsRelative ();_ecca =_gabc ._cgf .Top ;);if _gbbd &&!_gabc ._bgba &&!_gabc ._dcfb {_bfa :=_gabc .ctxHeight (ctx .Width );
if _bfa > ctx .Height -_gabc ._cgf .Top &&_bfa <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _gabf ,ctx ,_dgcb =_ccce ().GeneratePageBlocks (ctx );_dgcb !=nil {return nil ,ctx ,_dgcb ;};_gdbc =true ;_ecca =0;};};_ace :=ctx ;_dccb :=ctx ;
if _gbbd {ctx .X +=_gabc ._cgf .Left ;ctx .Y +=_ecca ;ctx .Width -=_gabc ._cgf .Left +_gabc ._cgf .Right ;ctx .Height -=_ecca ;_dccb =ctx ;ctx .X +=_gabc ._fgfc .Left ;ctx .Y +=_gabc ._fgfc .Top ;ctx .Width -=_gabc ._fgfc .Left +_gabc ._fgfc .Right ;ctx .Height -=_gabc ._fgfc .Top ;
ctx .Margins .Top +=_gabc ._fgfc .Top ;ctx .Margins .Bottom +=_gabc ._fgfc .Bottom ;ctx .Margins .Left +=_gabc ._cgf .Left +_gabc ._fgfc .Left ;ctx .Margins .Right +=_gabc ._cgf .Right +_gabc ._fgfc .Right ;};ctx .Inline =_gabc ._dcfb ;_agfbb :=ctx ;_dbbeb :=ctx ;
var _dddab float64 ;for _ ,_ggcf :=range _gabc ._fgaa {if ctx .Inline {if (ctx .X -_agfbb .X )+_ggcf .Width ()<=ctx .Width {ctx .Y =_dbbeb .Y ;ctx .Height =_dbbeb .Height ;}else {ctx .X =_agfbb .X ;ctx .Width =_agfbb .Width ;_dbbeb .Y +=_dddab ;_dbbeb .Height -=_dddab ;
_dddab =0;};};_gegb ,_bfe ,_aed :=_ggcf .GeneratePageBlocks (ctx );if _aed !=nil {_ce .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_aed );
return nil ,ctx ,_aed ;};if len (_gegb )< 1{continue ;};if len (_gabf )> 0{_gabf [len (_gabf )-1].mergeBlocks (_gegb [0]);_gabf =append (_gabf ,_gegb [1:]...);}else {if _dede :=_gegb [0]._aae ;_dede ==nil ||len (*_dede )==0{_gdbc =true ;};_gabf =append (_gabf ,_gegb [0:]...);
};if ctx .Inline {if ctx .Page !=_bfe .Page {_agfbb .Y =ctx .Margins .Top ;_agfbb .Height =ctx .PageHeight -ctx .Margins .Top ;_dbbeb .Y =_agfbb .Y ;_dbbeb .Height =_agfbb .Height ;_dddab =_bfe .Height -_agfbb .Height ;}else {if _ddfd :=ctx .Height -_bfe .Height ;
_ddfd > _dddab {_dddab =_ddfd ;};};}else {_bfe .X =ctx .X ;};ctx =_bfe ;};ctx .Inline =_ace .Inline ;ctx .Margins =_ace .Margins ;if _gbbd {ctx .X =_ace .X ;ctx .Width =_ace .Width ;ctx .Y +=_gabc ._fgfc .Bottom ;ctx .Height -=_gabc ._fgfc .Bottom ;};if _gabc ._bede !=nil {_gabf ,_dgcb =_gabc .drawBackground (_gabf ,_dccb ,ctx ,_gdbc );
if _dgcb !=nil {return nil ,ctx ,_dgcb ;};};if _gabc ._gbgf .IsAbsolute (){return _gabf ,_ace ,nil ;};ctx .Y +=_gabc ._cgf .Bottom ;ctx .Height -=_gabc ._cgf .Bottom ;return _gabf ,ctx ,nil ;};func (_daf *Block )setOpacity (_gb float64 ,_aca float64 )(string ,error ){if (_gb < 0||_gb >=1.0)&&(_aca < 0||_aca >=1.0){return "",nil ;
};_cdf :=0;_dafg :=_f .Sprintf ("\u0047\u0053\u0025\u0064",_cdf );for _daf ._ddc .HasExtGState (_e .PdfObjectName (_dafg )){_cdf ++;_dafg =_f .Sprintf ("\u0047\u0053\u0025\u0064",_cdf );};_bg :=_e .MakeDict ();if _gb >=0&&_gb < 1.0{_bg .Set ("\u0063\u0061",_e .MakeFloat (_gb ));
};if _aca >=0&&_aca < 1.0{_bg .Set ("\u0043\u0041",_e .MakeFloat (_aca ));};_bf :=_daf ._ddc .AddExtGState (_e .PdfObjectName (_dafg ),_bg );if _bf !=nil {return "",_bf ;};return _dafg ,nil ;};func (_fceba *templateProcessor )parseFontAttr (_gacbd ,_fcfgg string )*_aa .PdfFont {_ce .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gacbd ,_fcfgg );
_bdabb :=_fceba .creator ._edbc ;if _fcfgg ==""{return _bdabb ;};_dceae :=_gc .Split (_fcfgg ,"\u002c");for _ ,_efdc :=range _dceae {_efdc =_gc .TrimSpace (_efdc );if _efdc ==""{continue ;};_ddagd ,_bbef :=_fceba ._agfcg .FontMap [_fcfgg ];if _bbef {return _ddagd ;
};_fbgafa ,_bbef :=map[string ]_aa .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_aa .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_aa .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_aa .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_aa .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_aa .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_aa .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_aa .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_aa .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_aa .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_aa .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_aa .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_aa .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_aa .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_aa .TimesBoldItalicName }[_fcfgg ];
if _bbef {if _gaebc ,_dgeg :=_aa .NewStandard14Font (_fbgafa );_dgeg ==nil {return _gaebc ;};};if _ddbbe :=_fceba .parseAttrPropList (_efdc );len (_ddbbe )> 0{if _bdgba ,_dbga :=_ddbbe ["\u0070\u0061\u0074\u0068"];_dbga {_eaaaa :=_aa .NewPdfFontFromTTFFile ;
if _bgcb ,_ffdbc :=_ddbbe ["\u0074\u0079\u0070\u0065"];_ffdbc &&_bgcb =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_eaaaa =_aa .NewCompositePdfFontFromTTFFile ;};if _bbcgd ,_aagc :=_eaaaa (_bdgba );_aagc !=nil {_ce .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_bdgba ,_aagc );
}else {return _bbcgd ;};};};};return _bdabb ;};

// Width returns the width of the specified text chunk.
func (_aeda *TextChunk )Width ()float64 {var (_bcfgb float64 ;_cccf =_aeda .Style ;);for _ ,_fddce :=range _aeda .Text {_aecca ,_ecdde :=_cccf .Font .GetRuneMetrics (_fddce );if !_ecdde {_ce .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_fddce ,_fddce ,_cccf .Font .BaseFont (),_cccf .Font .Subtype ());
_ce .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_cccf .Font );_ce .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_cccf .Font .Encoder ());};_bfab :=_cccf .FontSize *_aecca .Wx ;_gaddd :=_bfab ;if _fddce !=' '{_gaddd =_bfab +_cccf .CharSpacing *1000.0;
};_bcfgb +=_gaddd ;};return _bcfgb /1000.0;};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};type rgbColor struct{_bdg ,_cbcf ,_bgdf float64 };

// Reset removes all the text chunks the paragraph contains.
func (_ccfaa *StyledParagraph )Reset (){_ccfaa ._fcfcf =[]*TextChunk {}};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bdfdc *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bdfdc .Text },nil ;};var _edfdee []string ;var _aaagd []rune ;var _ggcbd float64 ;var _fcfge []float64 ;_cegg :=_bdfdc .Style ;_bgfcg :=_adfe (_bdfdc .Text );
for _ ,_faef :=range _bdfdc .Text {if _faef =='\u000A'{_egfc :=_gbggf (string (_aaagd ),_bgfcg );_edfdee =append (_edfdee ,_gc .TrimRightFunc (_egfc ,_dd .IsSpace )+string (_faef ));_aaagd =nil ;_ggcbd =0;_fcfge =nil ;continue ;};_fbgb :=_faef ==' ';_gcec ,_fccfa :=_cegg .Font .GetRuneMetrics (_faef );
if !_fccfa {_ce .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_faef ,_faef ,_cegg .Font .BaseFont (),_cegg .Font .Subtype ());
_ce .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_cegg .Font );_ce .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_cegg .Font .Encoder ());return nil ,_b .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_gdfbc :=_cegg .FontSize *_gcec .Wx ;_aacbf :=_gdfbc ;if !_fbgb {_aacbf =_gdfbc +_cegg .CharSpacing *1000.0;};if _ggcbd +_gdfbc > width *1000.0{_egecg :=-1;if !_fbgb {for _edeaf :=len (_aaagd )-1;_edeaf >=0;_edeaf --{if _aaagd [_edeaf ]==' '{_egecg =_edeaf ;
break ;};};};_ggffg :=string (_aaagd );if _egecg > 0{_ggffg =string (_aaagd [0:_egecg +1]);_aaagd =append (_aaagd [_egecg +1:],_faef );_fcfge =append (_fcfge [_egecg +1:],_aacbf );_ggcbd =0;for _ ,_bfcab :=range _fcfge {_ggcbd +=_bfcab ;};}else {if _fbgb {_aaagd =[]rune {};
_fcfge =[]float64 {};_ggcbd =0;}else {_aaagd =[]rune {_faef };_fcfge =[]float64 {_aacbf };_ggcbd =_aacbf ;};};_ggffg =_gbggf (_ggffg ,_bgfcg );_edfdee =append (_edfdee ,_gc .TrimRightFunc (_ggffg ,_dd .IsSpace ));}else {_aaagd =append (_aaagd ,_faef );
_ggcbd +=_aacbf ;_fcfge =append (_fcfge ,_aacbf );};};if len (_aaagd )> 0{_ecga :=string (_aaagd );_ecga =_gbggf (_ecga ,_bgfcg );_edfdee =append (_edfdee ,_ecga );};return _edfdee ,nil ;};func _fggb (_bada *Block ,_bgcg *StyledParagraph ,_bdfe [][]*TextChunk ,_adfd DrawContext )(DrawContext ,[][]*TextChunk ,error ){_cdbge :=1;
_bega :=_e .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cdbge ));for _bada ._ddc .HasFontByName (_bega ){_cdbge ++;_bega =_e .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cdbge ));};_daed :=_bada ._ddc .SetFontByName (_bega ,_bgcg ._gfdbdf .Font .ToPdfObject ());
if _daed !=nil {return _adfd ,nil ,_daed ;};_cdbge ++;_aebeb :=_bega ;_dffd :=_bgcg ._gfdbdf .FontSize ;_ecda :=_bgcg ._bfgcf .IsRelative ();var _ecdd [][]_e .PdfObjectName ;var _gcgaa [][]*TextChunk ;var _ffcfb float64 ;for _badc ,_gaec :=range _bdfe {var _bcag []_e .PdfObjectName ;
var _cdac float64 ;if len (_gaec )> 0{_cdac =_gaec [0].Style .FontSize ;};for _ ,_geeb :=range _gaec {_baad :=_geeb .Style ;if _geeb .Text !=""&&_baad .FontSize > _cdac {_cdac =_baad .FontSize ;};_bega =_e .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cdbge ));
_accdg :=_bada ._ddc .SetFontByName (_bega ,_baad .Font .ToPdfObject ());if _accdg !=nil {return _adfd ,nil ,_accdg ;};_bcag =append (_bcag ,_bega );_cdbge ++;};_cdac *=_bgcg ._ffafa ;if _ecda &&_ffcfb +_cdac > _adfd .Height {_gcgaa =_bdfe [_badc :];_bdfe =_bdfe [:_badc ];
break ;};_ffcfb +=_cdac ;_ecdd =append (_ecdd ,_bcag );};_afgg ,_ffab ,_bced :=_bgcg .getLineMetrics (0);_bdcc ,_bgge :=_afgg *_bgcg ._ffafa ,_ffab *_bgcg ._ffafa ;if len (_bdfe )==0{return _adfd ,_gcgaa ,nil ;};_cgdd :=_ae .NewContentCreator ();_cgdd .Add_q ();
_bcae :=_bgge ;if _bgcg ._bfbc ==TextVerticalAlignmentCenter {_bcae =_ffab +(_afgg +_bced -_ffab )/2+(_bgge -_ffab )/2;};_adbef :=_adfd .PageHeight -_adfd .Y -_bcae ;_cgdd .Translate (_adfd .X ,_adbef );_fefgc :=_adbef ;if _bgcg ._aggf !=0{_cgdd .RotateDeg (_bgcg ._aggf );
};if _bgcg ._cgbc ==TextOverflowHidden {_cgdd .Add_re (0,-_ffcfb +_bdcc +1,_bgcg ._fffe ,_ffcfb ).Add_W ().Add_n ();};_cgdd .Add_BT ();_agad :=0.0;var _edfa []*_ad .BasicLine ;for _dfae ,_beab :=range _bdfe {_fbbc :=_adfd .X ;var _gccg float64 ;if len (_beab )> 0{_gccg =_beab [0].Style .FontSize ;
};_afgg ,_ ,_bced =_bgcg .getLineMetrics (_dfae );_bgge =(_afgg +_bced );for _ ,_dbfd :=range _beab {_gfec :=&_dbfd .Style ;if _dbfd .Text !=""&&_gfec .FontSize > _gccg {_gccg =_gfec .FontSize ;};if _bgge > _gccg {_gccg =_bgge ;};};if _dfae !=0{_cgdd .Add_TD (0,-_gccg *_bgcg ._ffafa +_agad );
_fefgc -=_gccg *_bgcg ._ffafa +_agad ;_agad =0.0;};_afdf :=_dfae ==len (_bdfe )-1;var (_caae float64 ;_dgff float64 ;_cbbbf *fontMetrics ;_ceadc float64 ;_ecdcc uint ;);var _dfgc []float64 ;for _ ,_bbbb :=range _beab {_bgdfc :=&_bbbb .Style ;if _bgdfc .FontSize > _dgff {_dgff =_bgdfc .FontSize ;
_cbbbf =_fcee (_bbbb .Style .Font ,_bgdfc .FontSize );};if _bgge > _dgff {_dgff =_bgge ;};_aggbd ,_eddf :=_bgdfc .Font .GetRuneMetrics (' ');if !_eddf {return _adfd ,nil ,_b .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _gggc uint ;var _abcca float64 ;_cdda :=len (_bbbb .Text );for _efbg ,_cecdf :=range _bbbb .Text {if _cecdf ==' '{_gggc ++;continue ;};if _cecdf =='\u000A'{continue ;};_adbf ,_gfaf :=_bgdfc .Font .GetRuneMetrics (_cecdf );if !_gfaf {_ce .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_cecdf );
return _adfd ,nil ,_b .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_abcca +=_bgdfc .FontSize *_adbf .Wx *_bgdfc .horizontalScale ();if _efbg !=_cdda -1{_abcca +=_bgdfc .CharSpacing *1000.0;
};};_dfgc =append (_dfgc ,_abcca );_caae +=_abcca ;_ceadc +=float64 (_gggc )*_aggbd .Wx *_bgdfc .FontSize *_bgdfc .horizontalScale ();_ecdcc +=_gggc ;};_dgff *=_bgcg ._ffafa ;var _dffb []_e .PdfObject ;_fgbb :=_bgcg ._fffe *1000.0;if _bgcg ._bfad ==TextAlignmentJustify {if _ecdcc > 0&&!_afdf {_ceadc =(_fgbb -_caae )/float64 (_ecdcc )/_dffd ;
};}else if _bgcg ._bfad ==TextAlignmentCenter {_ccdad :=(_fgbb -_caae -_ceadc )/2;_dcdc :=_ccdad /_dffd ;_dffb =append (_dffb ,_e .MakeFloat (-_dcdc ));_fbbc +=_ccdad /1000.0;}else if _bgcg ._bfad ==TextAlignmentRight {_gcdff :=(_fgbb -_caae -_ceadc );
_cgge :=_gcdff /_dffd ;_dffb =append (_dffb ,_e .MakeFloat (-_cgge ));_fbbc +=_gcdff /1000.0;};if len (_dffb )> 0{_cgdd .Add_Tf (_aebeb ,_dffd ).Add_TL (_dffd *_bgcg ._ffafa ).Add_TJ (_dffb ...);};_baaaf :=0.0;for _fbcb ,_edea :=range _beab {_cafc :=&_edea .Style ;
_cfde :=_aebeb ;_dbgdc :=_dffd ;_bcbd :=_cafc .OutlineColor !=nil ;_aaadb :=_cafc .HorizontalScaling !=DefaultHorizontalScaling ;_faca :=_cafc .OutlineSize !=1;if _faca {_cgdd .Add_w (_cafc .OutlineSize );};_ebbgc :=_cafc .RenderingMode !=TextRenderingModeFill ;
if _ebbgc {_cgdd .Add_Tr (int64 (_cafc .RenderingMode ));};_fgcd :=_cafc .CharSpacing !=0;if _fgcd {_cgdd .Add_Tc (_cafc .CharSpacing );};_aeecd :=_cafc .TextRise !=0;if _aeecd {_cgdd .Add_Ts (_cafc .TextRise );};if _edea .VerticalAlignment !=TextVerticalAlignmentBaseline {_dcac :=_fcee (_edea .Style .Font ,_cafc .FontSize );
switch _edea .VerticalAlignment {case TextVerticalAlignmentCenter :_baaaf =_cbbbf ._dfabf /2-_dcac ._dfabf /2;case TextVerticalAlignmentBottom :_baaaf =_cbbbf ._gabca -_dcac ._gabca ;case TextVerticalAlignmentTop :_baaaf =_ffab -_cafc .FontSize ;};if _baaaf !=0.0{_cgdd .Translate (0,_baaaf );
};};if _bgcg ._bfad !=TextAlignmentJustify ||_afdf {_cfafe ,_aefff :=_cafc .Font .GetRuneMetrics (' ');if !_aefff {return _adfd ,nil ,_b .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_cfde =_ecdd [_dfae ][_fbcb ];_dbgdc =_cafc .FontSize ;_ceadc =_cfafe .Wx *_cafc .horizontalScale ();};_dffba :=_cafc .Font .Encoder ();var _bbdfc []byte ;for _ ,_bdda :=range _edea .Text {if _bdda =='\u000A'{continue ;};if _bdda ==' '{if len (_bbdfc )> 0{if _bcbd {_cgdd .SetStrokingColor (_adb (_cafc .OutlineColor ));
};if _aaadb {_cgdd .Add_Tz (_cafc .HorizontalScaling );};_cgdd .SetNonStrokingColor (_adb (_cafc .Color )).Add_Tf (_ecdd [_dfae ][_fbcb ],_cafc .FontSize ).Add_TJ ([]_e .PdfObject {_e .MakeStringFromBytes (_bbdfc )}...);_bbdfc =nil ;};if _aaadb {_cgdd .Add_Tz (DefaultHorizontalScaling );
};_cgdd .Add_Tf (_cfde ,_dbgdc ).Add_TJ ([]_e .PdfObject {_e .MakeFloat (-_ceadc )}...);_dfgc [_fbcb ]+=_ceadc *_dbgdc ;}else {if _ ,_bgbe :=_dffba .RuneToCharcode (_bdda );!_bgbe {_daed =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bdda ,_bdda ),Rune :_bdda };
_adfd ._gdaf =append (_adfd ._gdaf ,_daed );_ce .Log .Debug (_daed .Error ());if _adfd ._eebb <=0{continue ;};_bdda =_adfd ._eebb ;};_bbdfc =append (_bbdfc ,_dffba .Encode (string (_bdda ))...);};};if len (_bbdfc )> 0{if _bcbd {_cgdd .SetStrokingColor (_adb (_cafc .OutlineColor ));
};if _aaadb {_cgdd .Add_Tz (_cafc .HorizontalScaling );};_cgdd .SetNonStrokingColor (_adb (_cafc .Color )).Add_Tf (_ecdd [_dfae ][_fbcb ],_cafc .FontSize ).Add_TJ ([]_e .PdfObject {_e .MakeStringFromBytes (_bbdfc )}...);};_bafea :=_dfgc [_fbcb ]/1000.0;
if _cafc .Underline {_gbcgbd :=_cafc .UnderlineStyle .Color ;if _gbcgbd ==nil {_gbcgbd =_edea .Style .Color ;};_ceabc ,_aefe ,_cgbf :=_gbcgbd .ToRGB ();_dddcb :=_fbbc -_adfd .X ;_adcd :=_fefgc -_adbef +_cafc .TextRise -_cafc .UnderlineStyle .Offset ;_edfa =append (_edfa ,&_ad .BasicLine {X1 :_dddcb ,Y1 :_adcd ,X2 :_dddcb +_bafea ,Y2 :_adcd ,LineWidth :_edea .Style .UnderlineStyle .Thickness ,LineColor :_aa .NewPdfColorDeviceRGB (_ceabc ,_aefe ,_cgbf )});
};if _edea ._eafe !=nil {var _fgbae *_e .PdfObjectArray ;if !_edea ._dgef {switch _bebc :=_edea ._eafe .GetContext ().(type ){case *_aa .PdfAnnotationLink :_fgbae =_e .MakeArray ();_bebc .Rect =_fgbae ;_agce ,_eedfe :=_bebc .Dest .(*_e .PdfObjectArray );
if _eedfe &&_agce .Len ()==5{_bdgad ,_adgdc :=_agce .Get (1).(*_e .PdfObjectName );if _adgdc &&_bdgad .String ()=="\u0058\u0059\u005a"{_edgff ,_gadce :=_e .GetNumberAsFloat (_agce .Get (3));if _gadce ==nil {_agce .Set (3,_e .MakeFloat (_adfd .PageHeight -_edgff ));
};};};};_edea ._dgef =true ;};if _fgbae !=nil {_gbcgfc :=_ad .NewPoint (_fbbc -_adfd .X ,_fefgc +_cafc .TextRise -_adbef ).Rotate (_bgcg ._aggf );_gbcgfc .X +=_adfd .X ;_gbcgfc .Y +=_adbef ;_eefae ,_gefdb ,_fgbc ,_eeba :=_dfdbbc (_bafea ,_dgff ,_bgcg ._aggf );
_gbcgfc .X +=_eefae ;_gbcgfc .Y +=_gefdb ;_fgbae .Clear ();_fgbae .Append (_e .MakeFloat (_gbcgfc .X ));_fgbae .Append (_e .MakeFloat (_gbcgfc .Y ));_fgbae .Append (_e .MakeFloat (_gbcgfc .X +_fgbc ));_fgbae .Append (_e .MakeFloat (_gbcgfc .Y +_eeba ));
};_bada .AddAnnotation (_edea ._eafe );};_fbbc +=_bafea ;if _faca {_cgdd .Add_w (1.0);};if _bcbd {_cgdd .Add_RG (0.0,0.0,0.0);};if _ebbgc {_cgdd .Add_Tr (int64 (TextRenderingModeFill ));};if _fgcd {_cgdd .Add_Tc (0);};if _aeecd {_cgdd .Add_Ts (0);};if _aaadb {_cgdd .Add_Tz (DefaultHorizontalScaling );
};if _baaaf !=0.0{_cgdd .Translate (0,-_baaaf );_baaaf =0.0;};};};_cgdd .Add_ET ();for _ ,_eabf :=range _edfa {_cgdd .SetStrokingColor (_eabf .LineColor ).Add_w (_eabf .LineWidth ).Add_m (_eabf .X1 ,_eabf .Y1 ).Add_l (_eabf .X2 ,_eabf .Y2 ).Add_s ();};
_cgdd .Add_Q ();_addf :=_cgdd .Operations ();_addf .WrapIfNeeded ();_bada .addContents (_addf );if _ecda {_ebdgc :=_ffcfb ;_adfd .Y +=_ebdgc ;_adfd .Height -=_ebdgc ;if _adfd .Inline {_adfd .X +=_bgcg .Width ()+_bgcg ._gcdca .Right ;};};return _adfd ,_gcgaa ,nil ;
};func (_bagdf *TableCell )height (_cedad float64 )float64 {var _bcfbb float64 ;switch _bffd :=_bagdf ._afgge .(type ){case *Paragraph :if _bffd ._eeda {_bffd .SetWidth (_cedad -_bagdf ._bbad -_bffd ._bgeb .Left -_bffd ._bgeb .Right );};_bcfbb =_bffd .Height ()+_bffd ._bgeb .Top +_bffd ._bgeb .Bottom +0.5*_bffd ._ffbe *_bffd ._gabb ;
case *StyledParagraph :if _bffd ._eacd {_bffd .SetWidth (_cedad -_bagdf ._bbad -_bffd ._gcdca .Left -_bffd ._gcdca .Right );};_bcfbb =_bffd .Height ()+_bffd ._gcdca .Top +_bffd ._gcdca .Bottom +0.5*_bffd .getTextHeight ();case *Image :_bffd .applyFitMode (_cedad -_bagdf ._bbad );
_bcfbb =_bffd .Height ()+_bffd ._ddbd .Top +_bffd ._ddbd .Bottom ;case *Table :_bffd .updateRowHeights (_cedad -_bagdf ._bbad -_bffd ._dafge .Left -_bffd ._dafge .Right );_bcfbb =_bffd .Height ()+_bffd ._dafge .Top +_bffd ._dafge .Bottom ;case *List :_bcfbb =_bffd .ctxHeight (_cedad -_bagdf ._bbad )+_bffd ._aade .Top +_bffd ._aade .Bottom ;
case *Division :_bcfbb =_bffd .ctxHeight (_cedad -_bagdf ._bbad )+_bffd ._cgf .Top +_bffd ._cgf .Bottom +_bffd ._fgfc .Top +_bffd ._fgfc .Bottom ;case *Chart :_bcfbb =_bffd .Height ()+_bffd ._feeca .Top +_bffd ._feeca .Bottom ;case *Rectangle :_bffd .applyFitMode (_cedad -_bagdf ._bbad );
_bcfbb =_bffd .Height ()+_bffd ._ebgg .Top +_bffd ._ebgg .Bottom +_bffd ._bcceg ;case *Ellipse :_bffd .applyFitMode (_cedad -_bagdf ._bbad );_bcfbb =_bffd .Height ()+_bffd ._geab .Top +_bffd ._geab .Bottom ;case *Line :_bcfbb =_bffd .Height ()+_bffd ._fgbea .Top +_bffd ._fgbea .Bottom ;
};return _bcfbb ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_agbe Color ;_fegfe _ad .LineStyle ;_dbfa CellBorderStyle ;_dabfg Color ;_fggged float64 ;_faaa CellBorderStyle ;_decc Color ;_edbge float64 ;_geee CellBorderStyle ;_fgbce Color ;_ffdaf float64 ;_gcge CellBorderStyle ;_cbdbb Color ;
_dbeeb float64 ;_afefg ,_dbbgc int ;_dgfd int ;_ebbb int ;_afgge VectorDrawable ;_cfad CellHorizontalAlignment ;_dbcg CellVerticalAlignment ;_bbad float64 ;_cccc *Table ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_adge *Invoice )AddressStyle ()TextStyle {return _adge ._edba };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_efea *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_affc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eggbe ,_fdef :=_affc .setOpacity (_efea ._ebgd ,_efea ._fbfb );if _fdef !=nil {return nil ,ctx ,_fdef ;};_abccg :=_efea ._cgdec ;
_abccg .FillEnabled =_abccg .FillColor !=nil ;_abccg .BorderEnabled =_abccg .BorderColor !=nil &&_abccg .BorderWidth > 0;_aeac :=_abccg .Points ;_dagcd :=_aa .PdfRectangle {};_ebdec :=false ;for _ggbab :=range _aeac {for _gcga :=range _aeac [_ggbab ]{_ecge :=&_aeac [_ggbab ][_gcga ];
_ecge .Y =ctx .PageHeight -_ecge .Y ;if !_ebdec {_dagcd .Llx =_ecge .X ;_dagcd .Lly =_ecge .Y ;_dagcd .Urx =_ecge .X ;_dagcd .Ury =_ecge .Y ;_ebdec =true ;}else {_dagcd .Llx =_bcb .Min (_dagcd .Llx ,_ecge .X );_dagcd .Lly =_bcb .Min (_dagcd .Lly ,_ecge .Y );
_dagcd .Urx =_bcb .Max (_dagcd .Urx ,_ecge .X );_dagcd .Ury =_bcb .Max (_dagcd .Ury ,_ecge .Y );};};};if _abccg .FillEnabled {_eefg :=_effg (_affc ,_efea ._cgdec .FillColor ,_efea ._abaa ,func ()Rectangle {return Rectangle {_ddge :_dagcd .Llx ,_gead :_dagcd .Lly ,_dbda :_dagcd .Width (),_agfc :_dagcd .Height ()};
});if _eefg !=nil {return nil ,ctx ,_eefg ;};};_eefd ,_ ,_fdef :=_abccg .Draw (_eggbe );if _fdef !=nil {return nil ,ctx ,_fdef ;};if _fdef =_affc .addContentsByString (string (_eefd ));_fdef !=nil {return nil ,ctx ,_fdef ;};return []*Block {_affc },ctx ,nil ;
};func (_edgf *StyledParagraph )getTextWidth ()float64 {var _adcb float64 ;_adbg :=len (_edgf ._fcfcf );for _fddac ,_gadf :=range _edgf ._fcfcf {_ceeg :=&_gadf .Style ;_gdfg :=len (_gadf .Text );for _dbbg ,_ggab :=range _gadf .Text {if _ggab =='\u000A'{continue ;
};_gecaf ,_fggge :=_ceeg .Font .GetRuneMetrics (_ggab );if !_fggge {_ce .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ggab );
return -1;};_adcb +=_ceeg .FontSize *_gecaf .Wx *_ceeg .horizontalScale ();if _ggab !=' '&&(_fddac !=_adbg -1||_dbbg !=_gdfg -1){_adcb +=_ceeg .CharSpacing *1000.0;};};};return _adcb ;};func _efede (_ffaa ,_cacee ,_agbc ,_baae float64 )*Ellipse {return &Ellipse {_eadc :_ffaa ,_ffaga :_cacee ,_cgec :_agbc ,_dceeg :_baae ,_bgdc :PositionAbsolute ,_bce :1.0,_bdfg :ColorBlack ,_ggcgf :1.0,_gbdg :1.0};
};var PPMM =float64 (72*1.0/25.4);func (_abdff *StyledParagraph )getTextLineWidth (_fcdb []*TextChunk )float64 {var _befc float64 ;_bgfef :=len (_fcdb );for _gbfc ,_efae :=range _fcdb {_fecb :=&_efae .Style ;_gdbb :=len (_efae .Text );for _cdfc ,_dcfdf :=range _efae .Text {if _dcfdf =='\u000A'{continue ;
};_cabdf ,_efaga :=_fecb .Font .GetRuneMetrics (_dcfdf );if !_efaga {_ce .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dcfdf );
return -1;};_befc +=_fecb .FontSize *_cabdf .Wx *_fecb .horizontalScale ();if _dcfdf !=' '&&(_gbfc !=_bgfef -1||_cdfc !=_gdbb -1){_befc +=_fecb .CharSpacing *1000.0;};};};return _befc ;};func (_cffae *TextStyle )horizontalScale ()float64 {return _cffae .HorizontalScaling /100};


// Width returns the width of the Paragraph.
func (_aceff *StyledParagraph )Width ()float64 {if _aceff ._eacd &&int (_aceff ._fffe )> 0{return _aceff ._fffe ;};return _aceff .getTextWidth ()/1000.0;};func (_bccg *Invoice )generateTotalBlocks (_agbf DrawContext )([]*Block ,DrawContext ,error ){_fabg :=_baea (4);
_fabg .SetMargins (0,0,10,10);_abfd :=[][2]*InvoiceCell {_bccg ._febf };_abfd =append (_abfd ,_bccg ._gfaa ...);_abfd =append (_abfd ,_bccg ._fcbe );for _ ,_adgc :=range _abfd {_eafb ,_ccec :=_adgc [0],_adgc [1];if _ccec .Value ==""{continue ;};_fabg .SkipCells (2);
_dged :=_fabg .NewCell ();_dged .SetBackgroundColor (_eafb .BackgroundColor );_dged .SetHorizontalAlignment (_ccec .Alignment );_bccg .setCellBorder (_dged ,_eafb );_fafd :=_fbfg (_eafb .TextStyle );_fafd .SetMargins (0,0,2,1);_fafd .Append (_eafb .Value );
_dged .SetContent (_fafd );_dged =_fabg .NewCell ();_dged .SetBackgroundColor (_ccec .BackgroundColor );_dged .SetHorizontalAlignment (_ccec .Alignment );_bccg .setCellBorder (_dged ,_eafb );_fafd =_fbfg (_ccec .TextStyle );_fafd .SetMargins (0,0,2,1);
_fafd .Append (_ccec .Value );_dged .SetContent (_fafd );};return _fabg .GeneratePageBlocks (_agbf );};func (_daacf *templateProcessor )parseInt64Array (_acbgg ,_defda string )[]int64 {_ce .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_acbgg ,_defda );
_accgd :=_gc .Fields (_defda );_abge :=make ([]int64 ,0,len (_accgd ));for _ ,_afgdf :=range _accgd {_ccgdc ,_ :=_gcc .ParseInt (_afgdf ,10,64);_abge =append (_abge ,_ccgdc );};return _abge ;};

// SetColorLeft sets border color for left.
func (_gece *border )SetColorLeft (col Color ){_gece ._cdca =col };func (_aagb *Table )wrapContent (_abdg DrawContext )error {if _aagb ._cggd {return nil ;};_aagb .sortCells ();_dcfeg :=func (_dcecf *TableCell ,_aeecf int ,_ecfc int ,_cgabf int )(_cbabd int ){if _cgabf < 1{return -1;
};_dbdf :=0;for _fcce :=_ecfc +1;_fcce < len (_aagb ._dfaeg )-1;_fcce ++{_ffcfcb :=_aagb ._dfaeg [_fcce ];if _ffcfcb ._afefg ==_cgabf &&_dbdf !=_ecfc {_dbdf =_fcce ;if (_ffcfcb ._dbbgc < _dcecf ._dbbgc &&_aagb ._abdae > _ffcfcb ._dbbgc )||_dcecf ._dbbgc < _aagb ._abdae {continue ;
};break ;};};_cffff :=float64 (0.0);for _fafdd :=0;_fafdd < _dcecf ._dgfd ;_fafdd ++{_cffff +=_aagb ._ecdda [_dcecf ._afefg +_fafdd -1];};_acfge :=_dcecf .width (_aagb ._bdbga ,_abdg .Width );var (_ddfac VectorDrawable ;_bacde =false ;);switch _bcacg :=_dcecf ._afgge .(type ){case *StyledParagraph :_cbce :=_abdg ;
_cbce .Height =_bcb .Floor (_cffff -_bcacg ._gcdca .Top -_bcacg ._gcdca .Bottom -0.5*_bcacg .getTextHeight ());_cbce .Width =_acfge ;_fbag ,_fdbfa ,_adbda :=_bcacg .split (_cbce );if _adbda !=nil {_ce .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_adbda .Error ());
};if _fbag !=nil &&_fdbfa !=nil {_aagb ._dfaeg [_ecfc ]._afgge =_fbag ;_ddfac =_fdbfa ;_bacde =true ;};};_aagb ._dfaeg [_ecfc ]._dgfd =_dcecf ._dgfd ;_abdg .Height =_abdg .PageHeight -_abdg .Margins .Top -_abdg .Margins .Bottom ;_edeac :=_dcecf .cloneProps (nil );
if _bacde {_edeac ._afgge =_ddfac ;};_edeac ._dgfd =_aeecf ;_edeac ._afefg =_cgabf +1;_edeac ._dbbgc =_dcecf ._dbbgc ;if _edeac ._afefg +_edeac ._dgfd -1> _aagb ._ccgdf {for _cfdab :=_aagb ._ccgdf ;_cfdab < _edeac ._afefg +_edeac ._dgfd -1;_cfdab ++{_aagb ._ccgdf ++;
_aagb ._ecdda =append (_aagb ._ecdda ,_aagb ._feae );};};_aagb ._dfaeg =append (_aagb ._dfaeg [:_dbdf +1],append ([]*TableCell {_edeac },_aagb ._dfaeg [_dbdf +1:]...)...);return _dbdf +1;};_fagaf :=func (_cbgfg *TableCell ,_gffab int ,_facdc int ,_dafab float64 )(_egea int ){_fbdf :=_cbgfg .width (_aagb ._bdbga ,_abdg .Width );
_acgcb :=_dafab ;_gedab :=1;_cffde :=_abdg .Height ;for _acgcb > _cffde {_acgcb -=_abdg .Height ;_cffde =_abdg .PageHeight -_abdg .Margins .Top -_abdg .Margins .Bottom ;_gedab ++;};var (_fggfa VectorDrawable ;_bfbdc =false ;);switch _eeeb :=_cbgfg ._afgge .(type ){case *StyledParagraph :_fcddg :=_abdg ;
_fcddg .Height =_bcb .Floor (_abdg .Height -_eeeb ._gcdca .Top -_eeeb ._gcdca .Bottom -0.5*_eeeb .getTextHeight ());_fcddg .Width =_fbdf ;_ebec ,_cfgab ,_bedeg :=_eeeb .split (_fcddg );if _bedeg !=nil {_ce .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_bedeg .Error ());
};if _ebec !=nil &&_cfgab !=nil {_aagb ._dfaeg [_gffab ]._afgge =_ebec ;_fggfa =_cfgab ;_bfbdc =true ;};};if _gedab < 2{return -1;};if _aagb ._dfaeg [_gffab ]._afefg +_gedab -1> _aagb ._ccgdf {for _ffaed :=0;_ffaed < _gedab ;_ffaed ++{_aagb ._ccgdf ++;
_aagb ._ecdda =append (_aagb ._ecdda ,_aagb ._feae );};};_fffc :=_dafab /float64 (_gedab );for _fccdd :=0;_fccdd < _gedab ;_fccdd ++{_aagb ._ecdda [_facdc +_fccdd -1]=_fffc ;};_abdg .Height =_abdg .PageHeight -_abdg .Margins .Top -_abdg .Margins .Bottom ;
_gccbg :=_cbgfg .cloneProps (nil );if _bfbdc {_gccbg ._afgge =_fggfa ;};_gccbg ._dgfd =1;_gccbg ._afefg =_facdc +_gedab -1;_gccbg ._dbbgc =_cbgfg ._dbbgc ;_aagb ._dfaeg =append (_aagb ._dfaeg ,_gccbg );return len (_aagb ._dfaeg );};_edccg :=1;_fdgg :=-1;
for _abeb :=0;_abeb < len (_aagb ._dfaeg );_abeb ++{_ccdf :=_aagb ._dfaeg [_abeb ];if _fdgg ==_abeb {_edccg =_ccdf ._afefg ;};if _ccdf ._dgfd < 2{if _dfga :=_aagb ._ecdda [_ccdf ._afefg -1];_dfga > _abdg .Height {_fdgg =_fagaf (_ccdf ,_abeb ,_ccdf ._afefg ,_dfga );
continue ;};continue ;};_cefd :=float64 (0);for _cadcg :=0;_cadcg < _ccdf ._dgfd ;_cadcg ++{_cefd +=_aagb ._ecdda [_ccdf ._afefg +_cadcg -1];};_bfce :=float64 (0);for _eced :=_edccg -1;_eced < _ccdf ._afefg -1;_eced ++{_bfce +=_aagb ._ecdda [_eced ];};
if _cefd <=(_abdg .Height -_bfce ){continue ;};_cdgd :=float64 (0.0);_acbb :=_ccdf ._dgfd ;_fcffb :=-1;_fbfbf :=1;for _cadd :=1;_cadd <=_ccdf ._dgfd ;_cadd ++{if (_cdgd +_aagb ._ecdda [_ccdf ._afefg +_cadd -2])> (_abdg .Height -_bfce ){_fbfbf --;break ;
};_fcffb =_ccdf ._afefg +_cadd -1;_acbb =_ccdf ._dgfd -_cadd ;_cdgd +=_aagb ._ecdda [_ccdf ._afefg +_cadd -2];_fbfbf ++;};if _acbb > 0&&_ccdf ._dgfd > _fbfbf {_ccdf ._dgfd =_fbfbf ;_fdgg =_dcfeg (_ccdf ,_acbb ,_abeb ,_fcffb );if _abeb +1==_fdgg {_abeb --;
};};_edccg =_ccdf ._afefg ;};_aagb .sortCells ();return nil ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_ccgdf int ;_abdae int ;_fdagd int ;_bdbga []float64 ;_ecdda []float64 ;_feae float64 ;_dfaeg []*TableCell ;_adaf []int ;_dbgb Positioning ;_caba ,_cdfcg float64 ;_dafge Margins ;_cbab bool ;_dacd int ;_geaaf int ;_cggd bool ;_affg bool ;
};

// SetBorderOpacity sets the border opacity of the ellipse.
func (_gbab *Ellipse )SetBorderOpacity (opacity float64 ){_gbab ._gbdg =opacity };func _dceeb (_bfbdg ,_efgf ,_cbced string ,_fgbbg uint ,_dcbbf TextStyle )*TOCLine {return _ccgf (TextChunk {Text :_bfbdg ,Style :_dcbbf },TextChunk {Text :_efgf ,Style :_dcbbf },TextChunk {Text :_cbced ,Style :_dcbbf },_fgbbg ,_dcbbf );
};func (_edge *templateProcessor )parseListMarker (_bfcd *templateNode )(interface{},error ){if _bfcd ._fedefc ==nil {_edge .nodeLogError (_bfcd ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_fgcf ;};var _efac *TextChunk ;switch _cadaa :=_bfcd ._fedefc ._ebabb .(type ){case *List :_efac =&_cadaa ._dbfb ;case *listItem :_efac =&_cadaa ._fcac ;default:_edge .nodeLogError (_bfcd ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_cadaa );
return nil ,_fgcf ;};if _ ,_dabeccf :=_edge .parseTextChunk (_bfcd ,_efac );_dabeccf !=nil {_edge .nodeLogError (_bfcd ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_dabeccf );
return nil ,nil ;};return _efac ,nil ;};

// AddColorStop add color stop info for rendering gradient color.
func (_cfgcb *LinearShading )AddColorStop (color Color ,point float64 ){_cfgcb ._cgfe .AddColorStop (color ,point );};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_cbdac *Rectangle )SetPositioning (position Positioning ){_cbdac ._fbeb =position };

// Height returns the total height of all rows.
func (_daae *Table )Height ()float64 {_affd :=float64 (0.0);for _ ,_afbbe :=range _daae ._ecdda {_affd +=_afbbe ;};return _affd ;};func _fcdg (_fedgf TextStyle )*List {return &List {_dbfb :TextChunk {Text :"\u2022\u0020",Style :_fedgf },_ecbc :0,_aadde :true ,_afbd :PositionRelative ,_gbfgg :_fedgf };
};

// SetBorderWidth sets the border width of the ellipse.
func (_egc *Ellipse )SetBorderWidth (bw float64 ){_egc ._ggcgf =bw };

// Margins returns the margins of the component.
func (_ebce *Division )Margins ()(_aeef ,_eccg ,_bfbg ,_cddd float64 ){return _ebce ._cgf .Left ,_ebce ._cgf .Right ,_ebce ._cgf .Top ,_ebce ._cgf .Bottom ;};func (_ccfb *templateProcessor )nodeLogDebug (_ggff *templateNode ,_ffagc string ,_eccd ...interface{}){_ce .Log .Debug (_ccfb .getNodeErrorLocation (_ggff ,_ffagc ,_eccd ...));
};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_bfae *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_baee :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gaae ,_ ,_ffgd :=_bfae .draw (_baee ,"");if _ffgd !=nil {return nil ,ctx ,_ffgd ;};_ffgd =_baee .addContentsByString (string (_gaae ));
if _ffgd !=nil {return nil ,ctx ,_ffgd ;};return []*Block {_baee },ctx ,nil ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_bdg :float64 (r )/255.0,_cbcf :float64 (g )/255.0,_bgdf :float64 (b )/255.0};};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_adce *LinearShading )AddPatternResource (block *Block )(_aeece _e .PdfObjectName ,_eecf error ){_cbbb :=1;_dbgc :=_e .PdfObjectName ("\u0050"+_gcc .Itoa (_cbbb ));for block ._ddc .HasPatternByName (_dbgc ){_cbbb ++;_dbgc =_e .PdfObjectName ("\u0050"+_gcc .Itoa (_cbbb ));
};if _gfaab :=block ._ddc .SetPatternByName (_dbgc ,_adce .ToPdfShadingPattern ().ToPdfObject ());_gfaab !=nil {return "",_gfaab ;};return _dbgc ,nil ;};func _baea (_fdaaf int )*Table {_gfcga :=&Table {_abdae :_fdaaf ,_feae :10.0,_bdbga :[]float64 {},_ecdda :[]float64 {},_dfaeg :[]*TableCell {},_adaf :make ([]int ,_fdaaf ),_affg :true };
_gfcga .resetColumnWidths ();return _gfcga ;};func (_ecbcc *TemplateOptions )init (){if _ecbcc .SubtemplateMap ==nil {_ecbcc .SubtemplateMap =map[string ]_bd .Reader {};};if _ecbcc .FontMap ==nil {_ecbcc .FontMap =map[string ]*_aa .PdfFont {};};if _ecbcc .ImageMap ==nil {_ecbcc .ImageMap =map[string ]*_aa .Image {};
};if _ecbcc .ColorMap ==nil {_ecbcc .ColorMap =map[string ]Color {};};if _ecbcc .ChartMap ==nil {_ecbcc .ChartMap =map[string ]_ag .ChartRenderable {};};};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_fbcdc *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_fbcdc ._cfad =halign ;};

// SetHeight sets the Image's document height to specified h.
func (_ffcc *Image )SetHeight (h float64 ){_ffcc ._afea =h };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_fefe *_ad .Polyline ;_eagd float64 ;};

// Width returns the width of the graphic svg.
func (_ggbb *GraphicSVG )Width ()float64 {return _ggbb ._age .Width };

// Horizontal returns total horizontal (left + right) margin.
func (_ggcb *Margins )Horizontal ()float64 {return _ggcb .Left +_ggcb .Right };

// SetOpacity sets opacity for Image.
func (_cbggf *Image )SetOpacity (opacity float64 ){_cbggf ._bgda =opacity };

// Columns returns all the columns in the invoice line items table.
func (_gcdd *Invoice )Columns ()[]*InvoiceCell {return _gcdd ._dagc };

// SetFillOpacity sets the fill opacity.
func (_fdc *CurvePolygon )SetFillOpacity (opacity float64 ){_fdc ._fae =opacity };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_ggad *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_ggad ._cgbc =textOverflow };func (_aggg *templateProcessor )parseColor (_fbbdb string )Color {if _fbbdb ==""{return nil ;};_deaad ,_gbgcg :=_aggg ._agfcg .ColorMap [_fbbdb ];if _gbgcg {return _deaad ;
};if _fbbdb [0]=='#'{return ColorRGBFromHex (_fbbdb );};return nil ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_bgggf float64 ;_cfda float64 ;_ccge float64 ;_fbaf float64 ;_edag float64 ;_dbea float64 ;_acgb Color ;_cfed float64 ;};func (_cgded *Table )updateRowHeights (_eddd float64 ){for _ ,_bcfee :=range _cgded ._dfaeg {_fddc :=_bcfee .width (_cgded ._bdbga ,_eddd );
_afca :=_bcfee .height (_fddc );_cbgec :=_cgded ._ecdda [_bcfee ._afefg +_bcfee ._dgfd -2];if _bcfee ._dgfd > 1{_gdacb :=0.0;_ddfc :=_cgded ._ecdda [_bcfee ._afefg -1:(_bcfee ._afefg +_bcfee ._dgfd -1)];for _ ,_ebeeb :=range _ddfc {_gdacb +=_ebeeb ;};if _afca <=_gdacb {continue ;
};};if _afca > _cbgec {_bbee :=_afca /float64 (_bcfee ._dgfd );if _bbee > _cbgec {for _bcec :=1;_bcec <=_bcfee ._dgfd ;_bcec ++{if _bbee > _cgded ._ecdda [_bcfee ._afefg +_bcec -2]{_cgded ._ecdda [_bcfee ._afefg +_bcec -2]=_bbee ;};};};};};};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_dbbe *Block )ScaleToWidth (w float64 ){_ced :=w /_dbbe ._ff ;_dbbe .Scale (_ced ,_ced )};

// SetBorderColor sets the border color.
func (_degcf *Polygon )SetBorderColor (color Color ){_degcf ._cgdec .BorderColor =_adb (color )};

// GeneratePageBlocks generates a page break block.
func (_gaccf *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gccd :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_afag :=ctx ;_afag .Y =ctx .Margins .Top ;
_afag .X =ctx .Margins .Left ;_afag .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_afag .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_afag ;return _gccd ,ctx ,nil ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cega *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_ceee :=[2]*InvoiceCell {_cega .newCell (description ,_cega ._fgfd ),_cega .newCell (value ,_cega ._fgfd )};_cega ._gafb =append (_cega ._gafb ,_ceee );return _ceee [0],_ceee [1];
};

// FitMode returns the fit mode of the line.
func (_eaga *Line )FitMode ()FitMode {return _eaga ._bbgf };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gbfg *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _gbfg ._agef [0],_gbfg ._agef [1]};

// Scale scales the ellipse dimensions by the specified factors.
func (_cgc *Ellipse )Scale (xFactor ,yFactor float64 ){_cgc ._cgec =xFactor *_cgc ._cgec ;_cgc ._dceeg =yFactor *_cgc ._dceeg ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_cbge *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_cccb :=_fbfg (_cbge ._gbfgg );_cccb .Append (text );_edab ,_eddbb :=_cbge .Add (_cccb );return _cccb ,_edab ,_eddbb ;};

// SetMargins sets the margins of the graphic svg component.
func (_fcba *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_fcba ._baac .Left =left ;_fcba ._baac .Right =right ;_fcba ._baac .Top =top ;_fcba ._baac .Bottom =bottom ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_fead *Image )SetMargins (left ,right ,top ,bottom float64 ){_fead ._ddbd .Left =left ;_fead ._ddbd .Right =right ;_fead ._ddbd .Top =top ;_fead ._ddbd .Bottom =bottom ;};func (_dfefd *templateProcessor )nodeError (_bfda *templateNode ,_fbgafb string ,_efbfb ...interface{})error {return _f .Errorf (_dfefd .getNodeErrorLocation (_bfda ,_fbgafb ,_efbfb ...));
};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_cfaf *Invoice )SetNoteHeadingStyle (style TextStyle ){_cfaf ._gegbe =style };

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_abadf *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_acae :=NewTextChunk (text ,_abadf ._fbga );_acae ._eafe =_gffee (url );return _abadf .appendChunk (_acae );};func (_gggeg *templateProcessor )parseTableCell (_ecbbf *templateNode )(interface{},error ){if _ecbbf ._fedefc ==nil {_gggeg .nodeLogError (_ecbbf ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_fgcf ;};_gcag ,_ecedg :=_ecbbf ._fedefc ._ebabb .(*Table );if !_ecedg {_gggeg .nodeLogError (_ecbbf ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_ecbbf ._fedefc ._ebabb );
return nil ,_fgcf ;};var _ccdfe ,_aaeba int64 ;for _ ,_efcb :=range _ecbbf ._gcbdb .Attr {_ggeab :=_efcb .Value ;switch _acebe :=_efcb .Name .Local ;_acebe {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_ccdfe =_gggeg .parseInt64Attr (_acebe ,_ggeab );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_aaeba =_gggeg .parseInt64Attr (_acebe ,_ggeab );
};};if _ccdfe <=0{_ccdfe =1;};if _aaeba <=0{_aaeba =1;};_ggbc :=_gcag .MultiCell (int (_aaeba ),int (_ccdfe ));for _ ,_bagdc :=range _ecbbf ._gcbdb .Attr {_cbdgc :=_bagdc .Value ;switch _dgfbe :=_bagdc .Name .Local ;_dgfbe {case "\u0069\u006e\u0064\u0065\u006e\u0074":_ggbc .SetIndent (_gggeg .parseFloatAttr (_dgfbe ,_cbdgc ));
case "\u0061\u006c\u0069g\u006e":_ggbc .SetHorizontalAlignment (_gggeg .parseCellAlignmentAttr (_dgfbe ,_cbdgc ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_ggbc .SetVerticalAlignment (_gggeg .parseCellVerticalAlignmentAttr (_dgfbe ,_cbdgc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_ggbc .SetSideBorderStyle (CellBorderSideAll ,_gggeg .parseCellBorderStyleAttr (_dgfbe ,_cbdgc ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_ggbc .SetSideBorderStyle (CellBorderSideTop ,_gggeg .parseCellBorderStyleAttr (_dgfbe ,_cbdgc ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ggbc .SetSideBorderStyle (CellBorderSideBottom ,_gggeg .parseCellBorderStyleAttr (_dgfbe ,_cbdgc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_ggbc .SetSideBorderStyle (CellBorderSideLeft ,_gggeg .parseCellBorderStyleAttr (_dgfbe ,_cbdgc ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_ggbc .SetSideBorderStyle (CellBorderSideRight ,_gggeg .parseCellBorderStyleAttr (_dgfbe ,_cbdgc ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_ggbc .SetSideBorderWidth (CellBorderSideAll ,_gggeg .parseFloatAttr (_dgfbe ,_cbdgc ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_ggbc .SetSideBorderWidth (CellBorderSideTop ,_gggeg .parseFloatAttr (_dgfbe ,_cbdgc ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ggbc .SetSideBorderWidth (CellBorderSideBottom ,_gggeg .parseFloatAttr (_dgfbe ,_cbdgc ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_ggbc .SetSideBorderWidth (CellBorderSideLeft ,_gggeg .parseFloatAttr (_dgfbe ,_cbdgc ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_ggbc .SetSideBorderWidth (CellBorderSideRight ,_gggeg .parseFloatAttr (_dgfbe ,_cbdgc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_ggbc .SetSideBorderColor (CellBorderSideAll ,_gggeg .parseColorAttr (_dgfbe ,_cbdgc ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_ggbc .SetSideBorderColor (CellBorderSideTop ,_gggeg .parseColorAttr (_dgfbe ,_cbdgc ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ggbc .SetSideBorderColor (CellBorderSideBottom ,_gggeg .parseColorAttr (_dgfbe ,_cbdgc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_ggbc .SetSideBorderColor (CellBorderSideLeft ,_gggeg .parseColorAttr (_dgfbe ,_cbdgc ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_ggbc .SetSideBorderColor (CellBorderSideRight ,_gggeg .parseColorAttr (_dgfbe ,_cbdgc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_ggbc .SetBorderLineStyle (_gggeg .parseLineStyleAttr (_dgfbe ,_cbdgc ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_ggbc .SetBackgroundColor (_gggeg .parseColorAttr (_dgfbe ,_cbdgc ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_gggeg .nodeLogDebug (_ecbbf ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_dgfbe );
};};return _ggbc ,nil ;};func (_cceff *templateProcessor )parseLinkAttr (_ecfb ,_fcbabb string )*_aa .PdfAnnotation {_fcbabb =_gc .TrimSpace (_fcbabb );if _gc .HasPrefix (_fcbabb ,"\u0075\u0072\u006c(\u0027")&&_gc .HasSuffix (_fcbabb ,"\u0027\u0029")&&len (_fcbabb )> 7{return _gffee (_fcbabb [5:len (_fcbabb )-2]);
};if _gc .HasPrefix (_fcbabb ,"\u0070\u0061\u0067e\u0028")&&_gc .HasSuffix (_fcbabb ,"\u0029")&&len (_fcbabb )> 6{var (_fedgb error ;_fdeab int64 ;_bdca float64 ;_gcega float64 ;_ccagb =1.0;_cbcee =_gc .Split (_fcbabb [5:len (_fcbabb )-1],"\u002c"););_fdeab ,_fedgb =_gcc .ParseInt (_gc .TrimSpace (_cbcee [0]),10,64);
if _fedgb !=nil {_ce .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fedgb );return nil ;};if len (_cbcee )>=2{_bdca ,_fedgb =_gcc .ParseFloat (_gc .TrimSpace (_cbcee [1]),64);
if _fedgb !=nil {_ce .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fedgb );
return nil ;};};if len (_cbcee )>=3{_gcega ,_fedgb =_gcc .ParseFloat (_gc .TrimSpace (_cbcee [2]),64);if _fedgb !=nil {_ce .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fedgb );
return nil ;};};if len (_cbcee )>=4{_ccagb ,_fedgb =_gcc .ParseFloat (_gc .TrimSpace (_cbcee [3]),64);if _fedgb !=nil {_ce .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fedgb );
return nil ;};};return _fbgcc (_fdeab -1,_bdca ,_gcega ,_ccagb );};return nil ;};var _dbcd =_c .MustCompile ("\u005c\u0064\u002b");

// NewTOCLine creates a new table of contents line with the default style.
func (_gdcae *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _dceeb (number ,title ,page ,level ,_gdcae .NewTextStyle ());};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_cbe *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _dfbc (x ,y ,innerRadius ,outerRadius ,colorPoints );};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_eeec *Ellipse )ScaleToWidth (w float64 ){_cddg :=_eeec ._dceeg /_eeec ._cgec ;_eeec ._cgec =w ;_eeec ._dceeg =w *_cddg ;};

// Text sets the text content of the Paragraph.
func (_dbcfc *Paragraph )Text ()string {return _dbcfc ._adad };

// Height returns the height of the line.
func (_abedd *Line )Height ()float64 {_fgede :=_abedd ._cdae ;if _abedd ._ccfd ==_abedd ._fede {_fgede /=2;};return _bcb .Abs (_abedd ._bdea -_abedd ._fbbgd )+_fgede ;};func (_daabd *templateProcessor )parseAttrPropList (_aagdd string )map[string ]string {_fbed :=_gc .Fields (_aagdd );
if len (_fbed )==0{return nil ;};_gggd :=map[string ]string {};for _ ,_cgbeg :=range _fbed {_cffe :=_eggbfg .FindStringSubmatch (_cgbeg );if len (_cffe )< 3{continue ;};_gfbdg ,_agbee :=_gc .TrimSpace (_cffe [1]),_cffe [2];if _gfbdg ==""{continue ;};_gggd [_gfbdg ]=_agbee ;
};return _gggd ;};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_age *_de .GraphicSVG ;_eddc Positioning ;_ggaf float64 ;_bcac float64 ;_baac Margins ;};

// MoveY moves the drawing context to absolute position y.
func (_gdd *Creator )MoveY (y float64 ){_gdd ._aaa .Y =y };

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_edaa *RadialShading )SetExtends (start bool ,end bool ){_edaa ._dagf .SetExtends (start ,end )};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_bfaf *List )Width ()float64 {return 0};func _dgafb (_eded []*ColorPoint )*LinearShading {return &LinearShading {_cgfe :&shading {_egfd :ColorWhite ,_acef :false ,_cfddb :[]bool {false ,false },_gdee :_eded },_cbaa :&_aa .PdfRectangle {}};};func _gege (_aagbg *templateProcessor ,_badd *templateNode )(interface{},error ){return _aagbg .parseList (_badd );
};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func _ccaaa (_faeda ...interface{})(map[string ]interface{},error ){_bade :=len (_faeda );if _bade %2!=0{_ce .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_bade );
return nil ,_e .ErrRangeError ;};_beag :=map[string ]interface{}{};for _bbbf :=0;_bbbf < _bade ;_bbbf +=2{_efbda ,_fafee :=_faeda [_bbbf ].(string );if !_fafee {_ce .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_faeda [_bbbf ]);
return nil ,_e .ErrTypeError ;};_beag [_efbda ]=_faeda [_bbbf +1];};return _beag ,nil ;};

// SetColPosition sets cell column position.
func (_daec *TableCell )SetColPosition (col int ){_daec ._dbbgc =col };func (_gcdcd *Table )clone ()*Table {_bbbg :=*_gcdcd ;_bbbg ._ecdda =make ([]float64 ,len (_gcdcd ._ecdda ));copy (_bbbg ._ecdda ,_gcdcd ._ecdda );_bbbg ._bdbga =make ([]float64 ,len (_gcdcd ._bdbga ));
copy (_bbbg ._bdbga ,_gcdcd ._bdbga );_bbbg ._dfaeg =make ([]*TableCell ,0,len (_gcdcd ._dfaeg ));for _ ,_bfbd :=range _gcdcd ._dfaeg {_dfaab :=*_bfbd ;_dfaab ._cccc =&_bbbg ;_bbbg ._dfaeg =append (_bbbg ._dfaeg ,&_dfaab );};return &_bbbg ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;
HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetBackground sets the background properties of the component.
func (_gbcgb *Division )SetBackground (background *Background ){_gbcgb ._bede =background };

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_cfga *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cfga ._geab .Left ,_cfga ._geab .Right ,_cfga ._geab .Top ,_cfga ._geab .Bottom ;};

// SetBorder sets the cell's border style.
func (_bbcd *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_bbcd ._dbfa =CellBorderStyleSingle ;_bbcd ._fggged =width ;_bbcd ._faaa =CellBorderStyleSingle ;
_bbcd ._edbge =width ;_bbcd ._geee =CellBorderStyleSingle ;_bbcd ._ffdaf =width ;_bbcd ._gcge =CellBorderStyleSingle ;_bbcd ._dbeeb =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_bbcd ._dbfa =CellBorderStyleDouble ;_bbcd ._fggged =width ;
_bbcd ._faaa =CellBorderStyleDouble ;_bbcd ._edbge =width ;_bbcd ._geee =CellBorderStyleDouble ;_bbcd ._ffdaf =width ;_bbcd ._gcge =CellBorderStyleDouble ;_bbcd ._dbeeb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_bbcd ._dbfa =style ;
_bbcd ._fggged =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_bbcd ._faaa =style ;_bbcd ._edbge =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_bbcd ._geee =style ;
_bbcd ._ffdaf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_bbcd ._gcge =style ;_bbcd ._dbeeb =width ;};};func (_cfbc *templateProcessor )parseBackground (_ddfcc *templateNode )(interface{},error ){_eeafg :=&Background {};
for _ ,_bfcc :=range _ddfcc ._gcbdb .Attr {_eabe :=_bfcc .Value ;switch _adgcf :=_bfcc .Name .Local ;_adgcf {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_eeafg .FillColor =_cfbc .parseColorAttr (_adgcf ,_eabe );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_eeafg .BorderColor =_cfbc .parseColorAttr (_adgcf ,_eabe );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_eeafg .BorderSize =_cfbc .parseFloatAttr (_adgcf ,_eabe );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_ccfdb ,_fcaa ,_dgdae ,_gagc :=_cfbc .parseBorderRadiusAttr (_adgcf ,_eabe );
_eeafg .SetBorderRadius (_ccfdb ,_fcaa ,_gagc ,_dgdae );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_eeafg .BorderRadiusTopLeft =_cfbc .parseFloatAttr (_adgcf ,_eabe );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_eeafg .BorderRadiusTopRight =_cfbc .parseFloatAttr (_adgcf ,_eabe );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_eeafg .BorderRadiusBottomLeft =_cfbc .parseFloatAttr (_adgcf ,_eabe );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_eeafg .BorderRadiusBottomRight =_cfbc .parseFloatAttr (_adgcf ,_eabe );
default:_cfbc .nodeLogDebug (_ddfcc ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_adgcf );
};};return _eeafg ,nil ;};func (_dceg *Invoice )drawInformation ()*Table {_ebgc :=_baea (2);_cfcd :=append ([][2]*InvoiceCell {_dceg ._aaeg ,_dceg ._gaad ,_dceg ._agef },_dceg ._gafb ...);for _ ,_ffdf :=range _cfcd {_gbebf ,_cbed :=_ffdf [0],_ffdf [1];
if _cbed .Value ==""{continue ;};_abbdg :=_ebgc .NewCell ();_abbdg .SetBackgroundColor (_gbebf .BackgroundColor );_dceg .setCellBorder (_abbdg ,_gbebf );_ebdg :=_fbfg (_gbebf .TextStyle );_ebdg .Append (_gbebf .Value );_ebdg .SetMargins (0,0,2,1);_abbdg .SetContent (_ebdg );
_abbdg =_ebgc .NewCell ();_abbdg .SetBackgroundColor (_cbed .BackgroundColor );_dceg .setCellBorder (_abbdg ,_cbed );_ebdg =_fbfg (_cbed .TextStyle );_ebdg .Append (_cbed .Value );_ebdg .SetMargins (0,0,2,1);_abbdg .SetContent (_ebdg );};return _ebgc ;
};

// Height returns the height of the chart.
func (_bgg *Chart )Height ()float64 {return float64 (_bgg ._cedg .Height ())};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_geac *Table )EnablePageWrap (enable bool ){_geac ._affg =enable };

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_agca *Rectangle )ScaleToWidth (w float64 ){_dfddb :=_agca ._agfc /_agca ._dbda ;_agca ._dbda =w ;_agca ._agfc =w *_dfddb ;};func (_ccabe *shading )generatePdfFunctions ()[]_aa .PdfFunction {if len (_ccabe ._gdee )==0{return nil ;}else if len (_ccabe ._gdee )<=2{_fefd ,_dgea ,_cfgdab :=_ccabe ._gdee [0]._fddb .ToRGB ();
_dcgc ,_geeg ,_baaa :=_ccabe ._gdee [len (_ccabe ._gdee )-1]._fddb .ToRGB ();return []_aa .PdfFunction {&_aa .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_fefd ,_dgea ,_cfgdab },C1 :[]float64 {_dcgc ,_geeg ,_baaa }}};
}else {_fcfd :=[]_aa .PdfFunction {};_ebca :=[]float64 {};for _bbge :=0;_bbge < len (_ccabe ._gdee )-1;_bbge ++{_abbdc ,_edcgg ,_cdga :=_ccabe ._gdee [_bbge ]._fddb .ToRGB ();_eagdg ,_bccb ,_ddedc :=_ccabe ._gdee [_bbge +1]._fddb .ToRGB ();_ebcaa :=&_aa .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_abbdc ,_edcgg ,_cdga },C1 :[]float64 {_eagdg ,_bccb ,_ddedc }};
_fcfd =append (_fcfd ,_ebcaa );if _bbge > 0{_ebca =append (_ebca ,_ccabe ._gdee [_bbge ]._gcgc );};};_bgead :=[]float64 {};for range _fcfd {_bgead =append (_bgead ,[]float64 {0.0,1.0}...);};return []_aa .PdfFunction {&_aa .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_fcfd ,Bounds :_ebca ,Encode :_bgead }};
};};

// EnableWordWrap sets the paragraph word wrap flag.
func (_afcgd *StyledParagraph )EnableWordWrap (val bool ){_afcgd ._cefc =val };

// IsAbsolute checks if the positioning is absolute.
func (_bgeg Positioning )IsAbsolute ()bool {return _bgeg ==PositionAbsolute };

// Invoice represents a configurable invoice template.
type Invoice struct{_cagb string ;_fafe *Image ;_bec *InvoiceAddress ;_edcbb *InvoiceAddress ;_dfaf string ;_aaeg [2]*InvoiceCell ;_gaad [2]*InvoiceCell ;_agef [2]*InvoiceCell ;_gafb [][2]*InvoiceCell ;_dagc []*InvoiceCell ;_bcdb [][]*InvoiceCell ;_febf [2]*InvoiceCell ;
_fcbe [2]*InvoiceCell ;_gfaa [][2]*InvoiceCell ;_eegf [2]string ;_cef [2]string ;_faeb [][2]string ;_ebea TextStyle ;_bccad TextStyle ;_bfdb TextStyle ;_edba TextStyle ;_efefb TextStyle ;_cfedb TextStyle ;_gegbe TextStyle ;_fgfd InvoiceCellProps ;_cfea InvoiceCellProps ;
_cdg InvoiceCellProps ;_fgccc InvoiceCellProps ;_egfg Positioning ;};func _fggd (_beca string )([]string ,error ){var (_bgdab []string ;_gacaa []rune ;);for _ ,_cfgfg :=range _beca {if _cfgfg =='\u000A'{if len (_gacaa )> 0{_bgdab =append (_bgdab ,string (_gacaa ));
};_bgdab =append (_bgdab ,string (_cfgfg ));_gacaa =nil ;continue ;};_gacaa =append (_gacaa ,_cfgfg );};if len (_gacaa )> 0{_bgdab =append (_bgdab ,string (_gacaa ));};var _ccgfg []string ;for _ ,_efeeg :=range _bgdab {_daca :=[]rune (_efeeg );_cgcd :=_fb .NewScanner (_daca );
var _ccfeb []rune ;for _fcde :=0;_fcde < len (_daca );_fcde ++{_ ,_ccgb ,_fbead :=_cgcd .Next ();if _fbead !=nil {return nil ,_fbead ;};if _ccgb ==_fb .BreakProhibited ||_dd .IsSpace (_daca [_fcde ]){_ccfeb =append (_ccfeb ,_daca [_fcde ]);if _dd .IsSpace (_daca [_fcde ]){_ccgfg =append (_ccgfg ,string (_ccfeb ));
_ccfeb =[]rune {};};continue ;}else {if len (_ccfeb )> 0{_ccgfg =append (_ccgfg ,string (_ccfeb ));};_ccfeb =[]rune {_daca [_fcde ]};};};if len (_ccfeb )> 0{_ccgfg =append (_ccgfg ,string (_ccfeb ));};};return _ccgfg ,nil ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_gbbab *RadialShading )ToPdfShadingPattern ()*_aa .PdfShadingPatternType3 {_acdcd ,_ffge ,_eeecg :=_gbbab ._dagf ._egfd .ToRGB ();_fccdg :=_gbbab .shadingModel ();_fccdg .PdfShading .Background =_e .MakeArrayFromFloats ([]float64 {_acdcd ,_ffge ,_eeecg });
_gefb :=_aa .NewPdfShadingPatternType3 ();_gefb .Shading =_fccdg ;return _gefb ;};func (_accbc *templateProcessor )loadImageFromSrc (_bbadc string )(*Image ,error ){if _bbadc ==""{_ce .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_dggcgg ;};_cefcee :=_gc .Split (_bbadc ,"\u002c");for _ ,_bebff :=range _cefcee {_bebff =_gc .TrimSpace (_bebff );if _bebff ==""{continue ;};_fddf ,_gcdgb :=_accbc ._agfcg .ImageMap [_bebff ];if _gcdgb {return _dcce (_fddf );};if _dgab :=_accbc .parseAttrPropList (_bebff );
len (_dgab )> 0{if _daefe ,_bdff :=_dgab ["\u0070\u0061\u0074\u0068"];_bdff {if _bdbef ,_cdbaa :=_abad (_daefe );_cdbaa !=nil {_ce .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_daefe ,_cdbaa );
}else {return _bdbef ,nil ;};};};};_ce .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_bbadc );return nil ,_dggcgg ;};const (TextAlignmentLeft TextAlignment =iota ;
TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_fddb Color ;_gcgc float64 ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cdbd *Creator )Draw (d Drawable )error {if _cdbd .getActivePage ()==nil {_cdbd .NewPage ();};_geed ,_abba ,_gega :=d .GeneratePageBlocks (_cdbd ._aaa );if _gega !=nil {return _gega ;};if len (_abba ._gdaf )> 0{_cdbd .Errors =append (_cdbd .Errors ,_abba ._gdaf ...);
};for _ffa ,_ggea :=range _geed {if _ffa > 0{_cdbd .NewPage ();};_bggg :=_cdbd .getActivePage ();if _fadgd ,_cfge :=_cdbd ._abfg [_bggg ];_cfge {if _gfbd :=_fadgd .mergeBlocks (_ggea );_gfbd !=nil {return _gfbd ;};if _gfgf :=_abc (_ggea ._ddc ,_fadgd ._ddc );
_gfgf !=nil {return _gfgf ;};}else {_cdbd ._abfg [_bggg ]=_ggea ;};};_cdbd ._aaa .X =_abba .X ;_cdbd ._aaa .Y =_abba .Y ;_cdbd ._aaa .Height =_abba .PageHeight -_abba .Y -_abba .Margins .Bottom ;return nil ;};func (_afggb *templateProcessor )parseChapter (_bdec *templateNode )(interface{},error ){_gace :=_afggb .creator .NewChapter ;
if _bdec ._fedefc !=nil {if _edfde ,_fbafb :=_bdec ._fedefc ._ebabb .(*Chapter );_fbafb {_gace =_edfde .NewSubchapter ;};};_fdfd :=_gace ("");for _ ,_agaea :=range _bdec ._gcbdb .Attr {_dcba :=_agaea .Value ;switch _bfbea :=_agaea .Name .Local ;_bfbea {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_fdfd .SetShowNumbering (_afggb .parseBoolAttr (_bfbea ,_dcba ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_fdfd .SetIncludeInTOC (_afggb .parseBoolAttr (_bfbea ,_dcba ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ffedf :=_afggb .parseMarginAttr (_bfbea ,_dcba );_fdfd .SetMargins (_ffedf .Left ,_ffedf .Right ,_ffedf .Top ,_ffedf .Bottom );
default:_afggb .nodeLogDebug (_bdec ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bfbea );
};};return _fdfd ,nil ;};

// SetColorTop sets border color for top.
func (_dcef *border )SetColorTop (col Color ){_dcef ._bgf =col };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_gdada *Table )MultiColCell (colspan int )*TableCell {return _gdada .MultiCell (1,colspan )};

// SetHeight sets the height of the rectangle.
func (_acgbc *Rectangle )SetHeight (height float64 ){_acgbc ._agfc =height };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_cfagb *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cfagb ._bgeb .Left ,_cfagb ._bgeb .Right ,_cfagb ._bgeb .Top ,_cfagb ._bgeb .Bottom ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_eebe *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eebe ._ddbd .Left ,_eebe ._ddbd .Right ,_eebe ._ddbd .Top ,_eebe ._ddbd .Bottom ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_dce *Block )Draw (d Drawable )error {_ea :=DrawContext {};_ea .Width =_dce ._ff ;_ea .Height =_dce ._cb ;_ea .PageWidth =_dce ._ff ;_ea .PageHeight =_dce ._cb ;_ea .X =0;_ea .Y =0;_cdba ,_ ,_ccb :=d .GeneratePageBlocks (_ea );if _ccb !=nil {return _ccb ;
};if len (_cdba )!=1{return _b .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
};for _ ,_dbbc :=range _cdba {if _cbf :=_dce .mergeBlocks (_dbbc );_cbf !=nil {return _cbf ;};};return nil ;};func _dfbc (_gdcab float64 ,_caee float64 ,_fafbc float64 ,_ccced float64 ,_dgbfb []*ColorPoint )*RadialShading {return &RadialShading {_dagf :&shading {_egfd :ColorWhite ,_acef :false ,_cfddb :[]bool {false ,false },_gdee :_dgbfb },_aaae :_gdcab ,_aeagb :_caee ,_eaae :_fafbc ,_dceed :_ccced ,_cbad :AnchorCenter };
};

// Opacity returns the opacity of the line.
func (_ffbg *Line )Opacity ()float64 {return _ffbg ._bcfb };

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dbcde *Rectangle )SetFitMode (fitMode FitMode ){_dbcde ._bcdfc =fitMode };func (_gdeg *Invoice )generateNoteBlocks (_eggdd DrawContext )([]*Block ,DrawContext ,error ){_fbdab :=_bggc ();_dfdd :=append ([][2]string {_gdeg ._eegf ,_gdeg ._cef },_gdeg ._faeb ...);
for _ ,_ccda :=range _dfdd {if _ccda [1]!=""{_afcc :=_gdeg .drawSection (_ccda [0],_ccda [1]);for _ ,_gegcd :=range _afcc {_fbdab .Add (_gegcd );};_ggda :=_fbfg (_gdeg ._ebea );_ggda .SetMargins (0,0,10,0);_fbdab .Add (_ggda );};};return _fbdab .GeneratePageBlocks (_eggdd );
};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_bfca *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_bfca ._adf =alignment };

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_dggf *Rectangle )GetCoords ()(float64 ,float64 ){return _dggf ._ddge ,_dggf ._gead };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_ddcf *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_degfa :=_ddcf ;if _ddcf ._cggd {_degfa =_ddcf .clone ();};return _aeffb (_degfa ,ctx );};func _eedba (_eeadb *_d .File )([]*_aa .PdfPage ,error ){_bbaca ,_dbacd :=_aa .NewPdfReader (_eeadb );
if _dbacd !=nil {return nil ,_dbacd ;};_afagc ,_dbacd :=_bbaca .GetNumPages ();if _dbacd !=nil {return nil ,_dbacd ;};var _afbccf []*_aa .PdfPage ;for _bbde :=0;_bbde < _afagc ;_bbde ++{_fcca ,_febac :=_bbaca .GetPage (_bbde +1);if _febac !=nil {return nil ,_febac ;
};_afbccf =append (_afbccf ,_fcca );};return _afbccf ,nil ;};

// SetLineWidth sets the line width.
func (_afbc *Line )SetLineWidth (width float64 ){_afbc ._cdae =width };

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_fcfcf []*TextChunk ;_gfdbdf TextStyle ;_fbga TextStyle ;_bfad TextAlignment ;_bfbc TextVerticalAlignment ;_ffafa float64 ;_eacd bool ;_fffe float64 ;_cefc bool ;_bbca bool ;_cgbc TextOverflow ;_aggf float64 ;_gcdca Margins ;
_bfgcf Positioning ;_aedfg float64 ;_afgd float64 ;_cabe float64 ;_bage float64 ;_gaca [][]*TextChunk ;_ceda func (_ceaa *StyledParagraph ,_fdagb DrawContext );};

// Positioning returns the type of positioning the ellipse is set to use.
func (_fefg *Ellipse )Positioning ()Positioning {return _fefg ._bgdc };

// SetBackgroundColor sets the cell's background color.
func (_gcad *TableCell )SetBackgroundColor (col Color ){_gcad ._agbe =col };

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_fefgd *Invoice )InfoLines ()[][2]*InvoiceCell {_gegf :=[][2]*InvoiceCell {_fefgd ._aaeg ,_fefgd ._gaad ,_fefgd ._agef };return append (_gegf ,_fefgd ._gafb ...);};func _aeffb (_cabea *Table ,_dadg DrawContext )([]*Block ,DrawContext ,error ){var _caadg []*Block ;
_ggecb :=NewBlock (_dadg .PageWidth ,_dadg .PageHeight );_cabea .updateRowHeights (_dadg .Width -_cabea ._dafge .Left -_cabea ._dafge .Right );_acdcg :=_cabea ._dafge .Top ;if _cabea ._dbgb .IsRelative ()&&!_cabea ._affg {_fabe :=_cabea .Height ();if _fabe > _dadg .Height -_cabea ._dafge .Top &&_fabe <=_dadg .PageHeight -_dadg .Margins .Top -_dadg .Margins .Bottom {_caadg =[]*Block {NewBlock (_dadg .PageWidth ,_dadg .PageHeight -_dadg .Y )};
var _gbgd error ;if _ ,_dadg ,_gbgd =_ccce ().GeneratePageBlocks (_dadg );_gbgd !=nil {return nil ,_dadg ,_gbgd ;};_acdcg =0;};};_abag :=_dadg ;if _cabea ._dbgb .IsAbsolute (){_dadg .X =_cabea ._caba ;_dadg .Y =_cabea ._cdfcg ;}else {_dadg .X +=_cabea ._dafge .Left ;
_dadg .Y +=_acdcg ;_dadg .Width -=_cabea ._dafge .Left +_cabea ._dafge .Right ;_dadg .Height -=_acdcg ;};_bfgce :=_dadg .Width ;_gcbce :=_dadg .X ;_bfee :=_dadg .Y ;_dbfc :=_dadg .Height ;_ddfgg :=0;_eafg ,_bbae :=-1,-1;if _cabea ._cbab {for _dbgbb ,_cdedg :=range _cabea ._dfaeg {if _cdedg ._afefg < _cabea ._dacd {continue ;
};if _cdedg ._afefg > _cabea ._geaaf {break ;};if _eafg < 0{_eafg =_dbgbb ;};_bbae =_dbgbb ;};};if _cedf :=_cabea .wrapContent (_dadg );_cedf !=nil {return nil ,_dadg ,_cedf ;};_cabea .updateRowHeights (_dadg .Width -_cabea ._dafge .Left -_cabea ._dafge .Right );
var (_cdab bool ;_febd int ;_ecad int ;_gaggc bool ;_gffgc int ;_bdead error ;);for _eggde :=0;_eggde < len (_cabea ._dfaeg );_eggde ++{_ceeag :=_cabea ._dfaeg [_eggde ];if _cedfe ,_egde :=_cabea .getLastCellFromCol (_ceeag ._dbbgc );_cedfe ==_eggde {if (_egde ._afefg +_egde ._dgfd -1)< _cabea ._ccgdf {for _fgae :=_ceeag ._afefg ;
_fgae < _cabea ._ccgdf ;_fgae ++{_dcea :=&TableCell {};_dcea ._afefg =_fgae +1;_dcea ._dgfd =1;_dcea ._dbbgc =_ceeag ._dbbgc ;_cabea ._dfaeg =append (_cabea ._dfaeg ,_dcea );};};};_fcfe :=_ceeag .width (_cabea ._bdbga ,_bfgce );_dgdecd :=float64 (0.0);
for _dfcec :=0;_dfcec < _ceeag ._dbbgc -1;_dfcec ++{_dgdecd +=_cabea ._bdbga [_dfcec ]*_bfgce ;};_faggf :=float64 (0.0);for _ddfce :=_ddfgg ;_ddfce < _ceeag ._afefg -1;_ddfce ++{_faggf +=_cabea ._ecdda [_ddfce ];};_dadg .Height =_dbfc -_faggf ;_addcb :=float64 (0.0);
for _egbf :=0;_egbf < _ceeag ._dgfd ;_egbf ++{_addcb +=_cabea ._ecdda [_ceeag ._afefg +_egbf -1];};_fdcg :=_gaggc &&_ceeag ._afefg !=_gffgc ;_gffgc =_ceeag ._afefg ;if _fdcg ||_addcb > _dadg .Height {if _cabea ._cggd &&!_gaggc {_gaggc ,_bdead =_cabea .wrapRow (_eggde ,_dadg ,_bfgce );
if _bdead !=nil {return nil ,_dadg ,_bdead ;};if _gaggc {_eggde --;continue ;};_fdcg =true ;};_caadg =append (_caadg ,_ggecb );_ggecb =NewBlock (_dadg .PageWidth ,_dadg .PageHeight );_gcbce =_dadg .Margins .Left +_cabea ._dafge .Left ;_bfee =_dadg .Margins .Top ;
_dadg .Height =_dadg .PageHeight -_dadg .Margins .Top -_dadg .Margins .Bottom ;_dadg .Page ++;_dbfc =_dadg .Height ;_ddfgg =_ceeag ._afefg -1;_faggf =0;_gaggc =false ;if _cabea ._cbab &&_eafg >=0{_febd =_eggde ;_eggde =_eafg -1;_ecad =_ddfgg ;_ddfgg =_cabea ._dacd -1;
_cdab =true ;if _ceeag ._dgfd > (_cabea ._ccgdf -_gffgc )||(_ceeag ._dgfd > 1&&_eggde < 0){_ce .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_cdab =false ;_eafg ,_bbae =-1,-1;};continue ;};if _fdcg {_eggde --;continue ;};};_dadg .Width =_fcfe ;_dadg .X =_gcbce +_dgdecd ;_dadg .Y =_bfee +_faggf ;_cbgb :=_gcf (_dadg .X ,_dadg .Y ,_fcfe ,_addcb );if _ceeag ._agbe !=nil {_cbgb .SetFillColor (_ceeag ._agbe );
};_cbgb .LineStyle =_ceeag ._fegfe ;_cbgb ._bgea =_ceeag ._dbfa ;_cbgb ._ggb =_ceeag ._geee ;_cbgb ._gfbe =_ceeag ._gcge ;_cbgb ._efef =_ceeag ._faaa ;if _ceeag ._dabfg !=nil {_cbgb .SetColorLeft (_ceeag ._dabfg );};if _ceeag ._decc !=nil {_cbgb .SetColorBottom (_ceeag ._decc );
};if _ceeag ._fgbce !=nil {_cbgb .SetColorRight (_ceeag ._fgbce );};if _ceeag ._cbdbb !=nil {_cbgb .SetColorTop (_ceeag ._cbdbb );};_cbgb .SetWidthBottom (_ceeag ._edbge );_cbgb .SetWidthLeft (_ceeag ._fggged );_cbgb .SetWidthRight (_ceeag ._ffdaf );_cbgb .SetWidthTop (_ceeag ._dbeeb );
_ffbaa :=_ggecb .Draw (_cbgb );if _ffbaa !=nil {_ce .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffbaa );};if _ceeag ._afgge !=nil {_cgdedf :=_ceeag ._afgge .Width ();_edeae :=_ceeag ._afgge .Height ();_bbcg :=0.0;switch _dgggd :=_ceeag ._afgge .(type ){case *Paragraph :if _dgggd ._eeda {_cgdedf =_dgggd .getMaxLineWidth ()/1000.0;
};_cgdedf +=_dgggd ._bgeb .Left +_dgggd ._bgeb .Right ;_edeae +=_dgggd ._bgeb .Top +_dgggd ._bgeb .Bottom ;case *StyledParagraph :if _dgggd ._eacd {_cgdedf =_dgggd .getMaxLineWidth ()/1000.0;};_dbfdg ,_fbea ,_fbfcc :=_dgggd .getLineMetrics (0);_faggc ,_cgcb :=_dbfdg *_dgggd ._ffafa ,_fbea *_dgggd ._ffafa ;
if _dgggd ._bfbc ==TextVerticalAlignmentCenter {_bbcg =_cgcb -(_fbea +(_dbfdg +_fbfcc -_fbea )/2+(_cgcb -_fbea )/2);};if len (_dgggd ._gaca )==1{_edeae =_faggc ;}else {_edeae =_edeae -_cgcb +_faggc ;};_bbcg +=_faggc -_cgcb ;switch _ceeag ._dbcg {case CellVerticalAlignmentTop :_bbcg +=_faggc *0.5;
case CellVerticalAlignmentBottom :_bbcg -=_faggc *0.5;};_cgdedf +=_dgggd ._gcdca .Left +_dgggd ._gcdca .Right ;_edeae +=_dgggd ._gcdca .Top +_dgggd ._gcdca .Bottom ;case *Table :_cgdedf =_fcfe ;case *List :_cgdedf =_fcfe ;case *Division :_cgdedf =_fcfe ;
case *Chart :_cgdedf =_fcfe ;case *Line :_edeae +=_dgggd ._fgbea .Top +_dgggd ._fgbea .Bottom ;_bbcg -=_dgggd .Height ()/2;case *Image :_cgdedf +=_dgggd ._ddbd .Left +_dgggd ._ddbd .Right ;_edeae +=_dgggd ._ddbd .Top +_dgggd ._ddbd .Bottom ;};switch _ceeag ._cfad {case CellHorizontalAlignmentLeft :_dadg .X +=_ceeag ._bbad ;
_dadg .Width -=_ceeag ._bbad ;case CellHorizontalAlignmentCenter :if _cgfc :=_fcfe -_cgdedf ;_cgfc > 0{_dadg .X +=_cgfc /2;_dadg .Width -=_cgfc /2;};case CellHorizontalAlignmentRight :if _fcfe > _cgdedf {_dadg .X =_dadg .X +_fcfe -_cgdedf -_ceeag ._bbad ;
_dadg .Width -=_ceeag ._bbad ;};};_gggae :=_dadg .Y ;_dgfec :=_dadg .Height ;_dadg .Y +=_bbcg ;switch _ceeag ._dbcg {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _eabff :=_addcb -_edeae ;_eabff > 0{_dadg .Y +=_eabff /2;_dadg .Height -=_eabff /2;
};case CellVerticalAlignmentBottom :if _addcb > _edeae {_dadg .Y =_dadg .Y +_addcb -_edeae ;_dadg .Height =_addcb ;};};_abce :=_ggecb .DrawWithContext (_ceeag ._afgge ,_dadg );if _abce !=nil {_ce .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_abce );
};_dadg .Y =_gggae ;_dadg .Height =_dgfec ;};_dadg .Y +=_addcb ;_dadg .Height -=_addcb ;if _cdab &&_eggde +1> _bbae {_bfee +=_faggf +_addcb ;_dbfc -=_addcb +_faggf ;_ddfgg =_ecad ;_eggde =_febd -1;_cdab =false ;};};_caadg =append (_caadg ,_ggecb );if _cabea ._dbgb .IsAbsolute (){return _caadg ,_abag ,nil ;
};_dadg .X =_abag .X ;_dadg .Width =_abag .Width ;_dadg .Y +=_cabea ._dafge .Bottom ;_dadg .Height -=_cabea ._dafge .Bottom ;return _caadg ,_dadg ,nil ;};

// FitMode returns the fit mode of the rectangle.
func (_ecbdd *Rectangle )FitMode ()FitMode {return _ecbdd ._bcdfc };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_ecac *Creator )NewImageFromGoImage (goimg _be .Image )(*Image ,error ){return _gcbcg (goimg )};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_dec :_bcb .Min (float64 (c ),100)/100.0,_fbfcd :_bcb .Min (float64 (m ),100)/100.0,_gbd :_bcb .Min (float64 (y ),100)/100.0,_agcb :_bcb .Min (float64 (k ),100)/100.0};};

// Length calculates and returns the length of the line.
func (_fcbee *Line )Length ()float64 {return _bcb .Sqrt (_bcb .Pow (_fcbee ._fede -_fcbee ._ccfd ,2.0)+_bcb .Pow (_fcbee ._bdea -_fcbee ._fbbgd ,2.0));};func (_ebcac *templateProcessor )nodeLogError (_dgfba *templateNode ,_gbaa string ,_gedcc ...interface{}){_ce .Log .Error (_ebcac .getNodeErrorLocation (_dgfba ,_gbaa ,_gedcc ...));
};

// SetWidth sets the width of the rectangle.
func (_defd *Rectangle )SetWidth (width float64 ){_defd ._dbda =width };func (_cfcg *FilledCurve )draw (_fcfa *Block ,_ebde string )([]byte ,*_aa .PdfRectangle ,error ){_acee :=_ad .NewCubicBezierPath ();for _ ,_fcfce :=range _cfcg ._fgdbf {_acee =_acee .AppendCurve (_fcfce );
};creator :=_ae .NewContentCreator ();creator .Add_q ();if _cfcg .FillEnabled &&_cfcg ._dcda !=nil {_caga :=_adb (_cfcg ._dcda );_gage :=_effg (_fcfa ,_caga ,_cfcg ._dcda ,func ()Rectangle {_eada :=_ad .NewCubicBezierPath ();for _ ,_dbbd :=range _cfcg ._fgdbf {_eada =_eada .AppendCurve (_dbbd );
};_eeed :=_eada .GetBoundingBox ();if _cfcg .BorderEnabled {_eeed .Height +=_cfcg .BorderWidth ;_eeed .Width +=_cfcg .BorderWidth ;_eeed .X -=_cfcg .BorderWidth /2;_eeed .Y -=_cfcg .BorderWidth /2;};return Rectangle {_ddge :_eeed .X ,_gead :_eeed .Y ,_dbda :_eeed .Width ,_agfc :_eeed .Height };
});if _gage !=nil {return nil ,nil ,_gage ;};creator .SetNonStrokingColor (_caga );};if _cfcg .BorderEnabled {if _cfcg ._aeff !=nil {creator .SetStrokingColor (_adb (_cfcg ._aeff ));};creator .Add_w (_cfcg .BorderWidth );};if len (_ebde )> 1{creator .Add_gs (_e .PdfObjectName (_ebde ));
};_ad .DrawBezierPathWithCreator (_acee ,creator );creator .Add_h ();if _cfcg .FillEnabled &&_cfcg .BorderEnabled {creator .Add_B ();}else if _cfcg .FillEnabled {creator .Add_f ();}else if _cfcg .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_cfbf :=_acee .GetBoundingBox ();
if _cfcg .BorderEnabled {_cfbf .Height +=_cfcg .BorderWidth ;_cfbf .Width +=_cfcg .BorderWidth ;_cfbf .X -=_cfcg .BorderWidth /2;_cfbf .Y -=_cfcg .BorderWidth /2;};_fdda :=&_aa .PdfRectangle {};_fdda .Llx =_cfbf .X ;_fdda .Lly =_cfbf .Y ;_fdda .Urx =_cfbf .X +_cfbf .Width ;
_fdda .Ury =_cfbf .Y +_cfbf .Height ;return creator .Bytes (),_fdda ,nil ;};

// GetIndent get the cell's left indent.
func (_gdeb *TableCell )GetIndent ()float64 {return _gdeb ._bbad };

// DrawFooter sets a function to draw a footer on created output pages.
func (_bafe *Creator )DrawFooter (drawFooterFunc func (_dcbg *Block ,_bdbg FooterFunctionArgs )){_bafe ._ccba =drawFooterFunc ;};func (_dbb *Block )addContentsByString (_cg string )error {_ccg :=_ae .NewContentStreamParser (_cg );_gcd ,_dad :=_ccg .Parse ();
if _dad !=nil {return _dad ;};_dbb ._aae .WrapIfNeeded ();_gcd .WrapIfNeeded ();*_dbb ._aae =append (*_dbb ._aae ,*_gcd ...);return nil ;};

// SetFillColor sets background color for border.
func (_bff *border )SetFillColor (col Color ){_bff ._eaf =col };

// SetBorderWidth sets the border width of the rectangle.
func (_bbdfg *Rectangle )SetBorderWidth (bw float64 ){_bbdfg ._bcceg =bw };

// GetRowHeight returns the height of the specified row.
func (_cbfa *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_cbfa ._ecdda ){return 0,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _cbfa ._ecdda [row -1],nil ;
};

// SetFillOpacity sets the fill opacity.
func (_ecbf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_ecbf ._abbb =opacity };func _fde (_gbb *Chapter ,_ebd *TOC ,_ccgc *_aa .Outline ,_aabf string ,_efed int ,_cfbd TextStyle )*Chapter {var _cgd uint =1;if _gbb !=nil {_cgd =_gbb ._bdfda +1;
};_fgb :=&Chapter {_aeg :_efed ,_gcca :_aabf ,_bcfg :true ,_bae :true ,_ade :_gbb ,_egfag :_ebd ,_eef :_ccgc ,_fca :[]Drawable {},_bdfda :_cgd };_febc :=_agde (_fgb .headingText (),_cfbd );_febc .SetFont (_cfbd .Font );_febc .SetFontSize (_cfbd .FontSize );
_fgb ._bbeg =_febc ;return _fgb ;};func (_efc *Creator )setActivePage (_cfdg *_aa .PdfPage ){_efc ._caf =_cfdg };

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_bagf *Rectangle )Width ()float64 {return _bagf ._dbda };

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_cbg *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbd :=_dc .IdentityMatrix ();_fd ,_cfg :=_cbg .Width (),_cbg .Height ();if _cbg ._db .IsRelative (){_bbd =_bbd .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_cfg );
}else {_bbd =_bbd .Translate (_cbg ._ed ,ctx .PageHeight -_cbg ._ac -_cfg );};_dgd :=_cfg ;if _cbg ._eb !=0{_bbd =_bbd .Translate (_fd /2,_cfg /2).Rotate (_cbg ._eb *_bcb .Pi /180.0).Translate (-_fd /2,-_cfg /2);_ ,_dgd =_cbg .RotatedSize ();};if _cbg ._db .IsRelative (){ctx .Y +=_dgd ;
};_efe :=_ae .NewContentCreator ();_efe .Add_cm (_bbd [0],_bbd [1],_bbd [3],_bbd [4],_bbd [6],_bbd [7]);_cc :=_cbg .duplicate ();_gd :=append (*_efe .Operations (),*_cc ._aae ...);_gd .WrapIfNeeded ();_cc ._aae =&_gd ;for _ ,_cba :=range _cbg ._af {_dda ,_gbc :=_e .GetArray (_cba .Rect );
if !_gbc ||_dda .Len ()!=4{_ce .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_cba .Rect );
continue ;};_dca ,_cdb :=_aa .NewPdfRectangle (*_dda );if _cdb !=nil {_ce .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_cdb );
continue ;};_dca .Transform (_bbd );_cba .Rect =_dca .ToPdfObject ();};return []*Block {_cc },ctx ,nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_bgfc *StyledParagraph )SetWidth (width float64 ){_bgfc ._fffe =width ;_bgfc .wrapText ()};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_adad string ;_gacgc *_aa .PdfFont ;_ffbe float64 ;_gabb float64 ;_bdfge Color ;_bcdbb TextAlignment ;_eeda bool ;_cagbag float64 ;_cecg int ;_cbga bool ;_ggbaf float64 ;_bgeb Margins ;_bdag Positioning ;_eedf float64 ;_gaba float64 ;
_beaa ,_ecag float64 ;_agac []string ;};func (_caagc *Table )resetColumnWidths (){_caagc ._bdbga =[]float64 {};_gdcbg :=float64 (1.0)/float64 (_caagc ._abdae );for _aedb :=0;_aedb < _caagc ._abdae ;_aedb ++{_caagc ._bdbga =append (_caagc ._bdbga ,_gdcbg );
};};

// SetWidth sets line width.
func (_ebfc *Curve )SetWidth (width float64 ){_ebfc ._cfed =width };

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_ebdeg *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_fcg *Block )SetPos (x ,y float64 ){_fcg ._db =PositionAbsolute ;_fcg ._ed =x ;_fcg ._ac =y };

// SetFillColor sets the fill color for the path.
func (_eeea *FilledCurve )SetFillColor (color Color ){_eeea ._dcda =color };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_fgccce *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_bagca :=&_fgccce ._ccecf ;_bagca .Left =left ;_bagca .Right =right ;_bagca .Top =top ;_bagca .Bottom =bottom ;};

// AddColorStop add color stop information for rendering gradient.
func (_fgff *shading )AddColorStop (color Color ,point float64 ){_fgff ._gdee =append (_fgff ._gdee ,_eabcb (color ,point ));};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_aa .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};type border struct{_accf float64 ;_eec float64 ;_dff float64 ;_gfb float64 ;_eaf Color ;_cdca Color ;_edf float64 ;_gfe Color ;_gfg float64 ;_bgac Color ;_dfa float64 ;_bgf Color ;_dbg float64 ;LineStyle _ad .LineStyle ;_bgea CellBorderStyle ;
_ggb CellBorderStyle ;_gfbe CellBorderStyle ;_efef CellBorderStyle ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_eaff *Image )SetEncoder (encoder _e .StreamEncoder ){_eaff ._bbaf =encoder };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fbcdb *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _acgc float64 ;var _fdf []*StyledParagraph ;for _ ,_adgdf :=range _fbcdb ._dbedd {_decfd :=_fbfg (_fbcdb ._gbfgg );_decfd .SetEnableWrap (false );_decfd .SetTextAlignment (TextAlignmentRight );
_decfd .Append (_adgdf ._fcac .Text ).Style =_adgdf ._fcac .Style ;_acba :=_decfd .getTextWidth ()/1000.0/ctx .Width ;if _acgc < _acba {_acgc =_acba ;};_fdf =append (_fdf ,_decfd );};_fdg :=_baea (2);_fdg .SetColumnWidths (_acgc ,1-_acgc );_fdg .SetMargins (_fbcdb ._aade .Left +_fbcdb ._ecbc ,_fbcdb ._aade .Right ,_fbcdb ._aade .Top ,_fbcdb ._aade .Bottom );
_fdg .EnableRowWrap (true );for _adbe ,_ecgd :=range _fbcdb ._dbedd {_bfaa :=_fdg .NewCell ();_bfaa .SetIndent (0);_bfaa .SetContent (_fdf [_adbe ]);_bfaa =_fdg .NewCell ();_bfaa .SetIndent (0);_bfaa .SetContent (_ecgd ._cbcgc );};return _fdg .GeneratePageBlocks (ctx );
};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_gaaf *LinearShading )SetAngle (angle float64 ){_gaaf ._eadf =angle };

// SellerAddress returns the seller address used in the invoice template.
func (_becb *Invoice )SellerAddress ()*InvoiceAddress {return _becb ._edcbb };func _gffee (_ggccd string )*_aa .PdfAnnotation {_eafggf :=_aa .NewPdfAnnotationLink ();_aadcc :=_aa .NewBorderStyle ();_aadcc .SetBorderWidth (0);_eafggf .BS =_aadcc .ToPdfObject ();
_bbeed :=_aa .NewPdfActionURI ();_bbeed .URI =_e .MakeString (_ggccd );_eafggf .SetAction (_bbeed .PdfAction );return _eafggf .PdfAnnotation ;};func (_abda *List )ctxHeight (_accc float64 )float64 {_accc -=_abda ._ecbc ;var _fabc float64 ;for _ ,_cggg :=range _abda ._dbedd {_fabc +=_cggg .ctxHeight (_accc );
};return _fabc ;};func _fddcg (_cbcdb *templateProcessor ,_cfgec *templateNode )(interface{},error ){return _cbcdb .parseLine (_cfgec );};

// Write output of creator to io.Writer interface.
func (_aabc *Creator )Write (ws _bd .Writer )error {if _cadab :=_aabc .Finalize ();_cadab !=nil {return _cadab ;};_cgead :=_aa .NewPdfWriter ();_cgead .SetOptimizer (_aabc ._aga );if _aabc ._bbc !=nil {_bbab :=_cgead .SetForms (_aabc ._bbc );if _bbab !=nil {_ce .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bbab );
return _bbab ;};};if _aabc ._eca !=nil {_cgead .AddOutlineTree (_aabc ._eca );}else if _aabc ._gcdce !=nil &&_aabc .AddOutlines {_cgead .AddOutlineTree (&_aabc ._gcdce .ToPdfOutline ().PdfOutlineTreeNode );};if _aabc ._cab !=nil {if _gef :=_cgead .SetPageLabels (_aabc ._cab );
_gef !=nil {_ce .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_gef );return _gef ;};};if _aabc ._gaee !=nil {for _ ,_fab :=range _aabc ._gaee {_bdgb :=_fab .SubsetRegistered ();
if _bdgb !=nil {_ce .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_bdgb );return _bdgb ;};};};if _aabc ._ggba !=nil {_bbg :=_aabc ._ggba (&_cgead );
if _bbg !=nil {_ce .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bbg );return _bbg ;};};for _ ,_aeba :=range _aabc ._agfa {_cfab :=_cgead .AddPage (_aeba );if _cfab !=nil {_ce .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_cfab );
return _cfab ;};};_bdac :=_cgead .Write (ws );if _bdac !=nil {return _bdac ;};return nil ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_agbg *Division )Add (d VectorDrawable )error {switch _efaf :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_bdba ,_fgcc :=_efaf .ContainerComponent (_agbg );
if _fgcc !=nil {return _fgcc ;};_gfdb ,_dabd :=_bdba .(VectorDrawable );if !_dabd {return _f .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_bdba );
};d =_gfdb ;default:return _b .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_agbg ._fgaa =append (_agbg ._fgaa ,d );return nil ;};func (_beff *Rectangle )applyFitMode (_dfab float64 ){_dfab -=_beff ._ebgg .Left +_beff ._ebgg .Right +_beff ._bcceg ;
switch _beff ._bcdfc {case FitModeFillWidth :_beff .ScaleToWidth (_dfab );};};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_cfc *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cfc ._ge .Left ,_cfc ._ge .Right ,_cfc ._ge .Top ,_cfc ._ge .Bottom ;};

// SetColorRight sets border color for right.
func (_dcb *border )SetColorRight (col Color ){_dcb ._bgac =col };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_effe *Creator )SetOutlineTree (outlineTree *_aa .PdfOutlineTreeNode ){_effe ._eca =outlineTree };

// SetAnnotation sets a annotation on a TextChunk.
func (_abfba *TextChunk )SetAnnotation (annotation *_aa .PdfAnnotation ){_abfba ._eafe =annotation };func _aefc (_abcfb ,_bacg ,_dcde ,_dcfbf float64 )*Rectangle {return &Rectangle {_ddge :_abcfb ,_gead :_bacg ,_dbda :_dcde ,_agfc :_dcfbf ,_fbeb :PositionAbsolute ,_befe :1.0,_aebf :ColorBlack ,_bcceg :1.0,_gfdfab :1.0};
};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ecc *Creator )SetPageLabels (pageLabels _e .PdfObject ){_ecc ._cab =pageLabels };

// Level returns the indentation level of the TOC line.
func (_agcaa *TOCLine )Level ()uint {return _agcaa ._edac };func _abb (_cad string )string {_agc :=_dbcd .FindAllString (_cad ,-1);if len (_agc )==0{_cad =_cad +"\u0030";}else {_cfb ,_daga :=_gcc .Atoi (_agc [len (_agc )-1]);if _daga !=nil {_ce .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_daga );
_cad =_cad +"\u0030";}else {_cfb ++;_fdba :=_gc .LastIndex (_cad ,_agc [len (_agc )-1]);if _fdba ==-1{_cad =_f .Sprintf ("\u0025\u0073\u0025\u0064",_cad [:len (_cad )-1],_cfb );}else {_cad =_cad [:_fdba ]+_gcc .Itoa (_cfb );};};};return _cad ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ee :=&Block {};_ee ._aae =&_ae .ContentStreamOperations {};_ee ._ddc =_aa .NewPdfPageResources ();_ee ._ff =width ;_ee ._cb =height ;return _ee ;};

// SkipCells skips over a specified number of cells in the table.
func (_gacbca *Table )SkipCells (num int ){if num < 0{_ce .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gacbca ._fdagd +=num ;};