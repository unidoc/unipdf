//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_cd "bytes";_a "errors";_ba "fmt";_af "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/contentstream";_gd "github.com/unidoc/unipdf/v3/contentstream/draw";_fg "github.com/unidoc/unipdf/v3/core";_ce "github.com/unidoc/unipdf/v3/model";_g "image";_ab "io";_f "math";_b "os";_c "sort";_gf "strconv";_be "strings";_gb "unicode";);func (_dfag *Invoice )drawSection (_dgae ,_dged string )[]*StyledParagraph {var _fcbc []*StyledParagraph ;if _dgae !=""{_aefd :=_cagb (_dfag ._adbg );_aefd .SetMargins (0,0,0,5);_aefd .Append (_dgae );_fcbc =append (_fcbc ,_aefd );};if _dged !=""{_abce :=_cagb (_dfag ._gdee );_abce .Append (_dged );_fcbc =append (_fcbc ,_abce );};return _fcbc ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_ccfa *TOC )SetLineSeparator (separator string ){_ccfa ._cdge =separator };func (_cbdda *StyledParagraph )wrapText ()error {if !_cbdda ._edgb ||int (_cbdda ._aag )<=0{_cbdda ._fgde =[][]*TextChunk {_cbdda ._ebcb };return nil ;};_cbdda ._fgde =[][]*TextChunk {};var _ggbeg []*TextChunk ;var _gdfdg float64 ;_eaadb :=func (_ddac *_ce .PdfAnnotation )*_ce .PdfAnnotation {if _ddac ==nil {return nil ;};var _gaea *_ce .PdfAnnotation ;switch _degf :=_ddac .GetContext ().(type ){case *_ce .PdfAnnotationLink :if _fecf :=_babfad (_degf );_fecf !=nil {_gaea =_fecf .PdfAnnotation ;};};return _gaea ;};for _ ,_fcdfg :=range _cbdda ._ebcb {_afga :=_fcdfg .Style ;_ceedd :=_fcdfg ._gcbge ;var (_edbf []rune ;_fggba []float64 ;);for _ ,_ggea :=range _fcdfg .Text {if _ggea =='\u000A'{_ggbeg =append (_ggbeg ,&TextChunk {Text :_be .TrimRightFunc (string (_edbf ),_gb .IsSpace ),Style :_afga ,_gcbge :_eaadb (_ceedd )});_cbdda ._fgde =append (_cbdda ._fgde ,_ggbeg );_ggbeg =nil ;_gdfdg =0;_edbf =nil ;_fggba =nil ;continue ;};_fdad :=_ggea ==' ';_ebcf ,_aadae :=_afga .Font .GetRuneMetrics (_ggea );if !_aadae {_af .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ggea );return _a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_bgea :=_afga .FontSize *_ebcf .Wx ;_beeg :=_bgea ;if !_fdad {_beeg =_bgea +_afga .CharSpacing *1000.0;};if _gdfdg +_bgea > _cbdda ._aag *1000.0{_gfgg :=-1;if !_fdad {for _cebg :=len (_edbf )-1;_cebg >=0;_cebg --{if _edbf [_cebg ]==' '{_gfgg =_cebg ;break ;};};};_cegg :=string (_edbf );if _gfgg >=0{_cegg =string (_edbf [0:_gfgg +1]);_edbf =_edbf [_gfgg +1:];_edbf =append (_edbf ,_ggea );_fggba =_fggba [_gfgg +1:];_fggba =append (_fggba ,_beeg );_gdfdg =0;for _ ,_gabc :=range _fggba {_gdfdg +=_gabc ;};}else {if _fdad {_gdfdg =0;_edbf =[]rune {};_fggba =[]float64 {};}else {_gdfdg =_beeg ;_edbf =[]rune {_ggea };_fggba =[]float64 {_beeg };};};_ggbeg =append (_ggbeg ,&TextChunk {Text :_be .TrimRightFunc (string (_cegg ),_gb .IsSpace ),Style :_afga ,_gcbge :_eaadb (_ceedd )});_cbdda ._fgde =append (_cbdda ._fgde ,_ggbeg );_ggbeg =[]*TextChunk {};}else {_gdfdg +=_beeg ;_edbf =append (_edbf ,_ggea );_fggba =append (_fggba ,_beeg );};};if len (_edbf )> 0{_ggbeg =append (_ggbeg ,&TextChunk {Text :string (_edbf ),Style :_afga ,_gcbge :_eaadb (_ceedd )});};};if len (_ggbeg )> 0{_cbdda ._fgde =append (_cbdda ._fgde ,_ggbeg );};return nil ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_fffc *Creator )NewImage (img *_ce .Image )(*Image ,error ){return _begbe (img )};

// NewImageFromFile creates an Image from a file.
func (_edda *Creator )NewImageFromFile (path string )(*Image ,error ){return _fdg (path )};

// SetWidthBottom sets border width for bottom.
func (_cae *border )SetWidthBottom (bw float64 ){_cae ._cdf =bw };

// SetStyleLeft sets border style for left side.
func (_gec *border )SetStyleLeft (style CellBorderStyle ){_gec ._afee =style };func _baec (_bef ,_dec ,_bbfd ,_bdag ,_adeb ,_gdgac float64 )*Curve {_bca :=&Curve {};_bca ._dgde =_bef ;_bca ._bfg =_dec ;_bca ._cbbaa =_bbfd ;_bca ._bgecd =_bdag ;_bca ._ecgd =_adeb ;_bca ._fcdd =_gdgac ;_bca ._afef =_ce .NewPdfColorDeviceRGB (0,0,0);_bca ._efgd =1.0;return _bca ;};

// SetOpacity sets opacity for Image.
func (_abba *Image )SetOpacity (opacity float64 ){_abba ._bbdd =opacity };func _dcea (_cacfd ,_gdbb ,_ffaf ,_bcea float64 )*Ellipse {_bdbd :=&Ellipse {};_bdbd ._aad =_cacfd ;_bdbd ._dee =_gdbb ;_bdbd ._cgge =_ffaf ;_bdbd ._eaeb =_bcea ;_bdbd ._cga =_ce .NewPdfColorDeviceRGB (0,0,0);_bdbd ._begd =1.0;return _bdbd ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cecg *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_cgdg :=[2]*InvoiceCell {_cecg .newCell (description ,_cecg ._ffaab ),_cecg .newCell (value ,_cecg ._ffaab )};_cecg ._bfb =append (_cecg ._bfb ,_cgdg );return _cgdg [0],_cgdg [1];};

// SetMargins sets the margins of the paragraph.
func (_bffc *List )SetMargins (left ,right ,top ,bottom float64 ){_bffc ._bgff ._dca =left ;_bffc ._bgff ._ffe =right ;_bffc ._bgff ._dcgbd =top ;_bffc ._bgff ._fbf =bottom ;};

// Width returns Image's document width.
func (_cdec *Image )Width ()float64 {return _cdec ._gefe };

// SetBorderWidth sets the border width.
func (_cacd *Rectangle )SetBorderWidth (bw float64 ){_cacd ._gefg =bw };func _dgfeg (_eggf *_ce .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_eggf ,FontSize :10};};func _gfe (_dfgb ,_bda *_ce .PdfPageResources )error {_fcacg ,_ :=_dfgb .GetColorspaces ();if _fcacg !=nil &&len (_fcacg .Colorspaces )> 0{for _cbb ,_cca :=range _fcacg .Colorspaces {_aecg :=*_fg .MakeName (_cbb );if _bda .HasColorspaceByName (_aecg ){continue ;};_ggbe :=_bda .SetColorspaceByName (_aecg ,_cca );if _ggbe !=nil {return _ggbe ;};};};return nil ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_cfe *Creator )DrawFooter (drawFooterFunc func (_dgb *Block ,_bdd FooterFunctionArgs )){_cfe ._dcbb =drawFooterFunc ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_cbgg *Creator )NewParagraph (text string )*Paragraph {return _bbga (text ,_cbgg .NewTextStyle ())};func (_aefc *Invoice )generateNoteBlocks (_dfadg DrawContext )([]*Block ,DrawContext ,error ){_caaag :=_aeae ();_gbgc :=append ([][2]string {_aefc ._agfd ,_aefc ._cgde },_aefc ._ddbf ...);for _ ,_bfa :=range _gbgc {if _bfa [1]!=""{_ebgf :=_aefc .drawSection (_bfa [0],_bfa [1]);for _ ,_fada :=range _ebgf {_caaag .Add (_fada );};_dfead :=_cagb (_aefc ._ggceg );_dfead .SetMargins (0,0,10,0);_caaag .Add (_dfead );};};return _caaag .GeneratePageBlocks (_dfadg );};

// Height returns Image's document height.
func (_bbcb *Image )Height ()float64 {return _bbcb ._gad };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetLogo sets the logo of the invoice.
func (_gdfb *Invoice )SetLogo (logo *Image ){_gdfb ._eaaf =logo };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_edea *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aecc :=ctx ;var _dceag []*Block ;_aefce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _edea ._bcefb .isRelative (){ctx .X +=_edea ._dagf ._dca ;ctx .Y +=_edea ._dagf ._dcgbd ;ctx .Width -=_edea ._dagf ._dca +_edea ._dagf ._ffe ;ctx .Height -=_edea ._dagf ._dcgbd +_edea ._dagf ._fbf ;_edea .SetWidth (ctx .Width );if _edea .Height ()> ctx .Height {_dceag =append (_dceag ,_aefce );_aefce =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_adef :=ctx ;_adef .Y =ctx .Margins ._dcgbd ;_adef .X =ctx .Margins ._dca +_edea ._dagf ._dca ;_adef .Height =ctx .PageHeight -ctx .Margins ._dcgbd -ctx .Margins ._fbf -_edea ._dagf ._fbf ;_adef .Width =ctx .PageWidth -ctx .Margins ._dca -ctx .Margins ._ffe -_edea ._dagf ._dca -_edea ._dagf ._ffe ;ctx =_adef ;};}else {if int (_edea ._deff )<=0{_edea .SetWidth (_edea .getTextWidth ());};ctx .X =_edea ._afc ;ctx .Y =_edea ._gcfc ;};ctx ,_eacdf :=_ddda (_aefce ,_edea ,ctx );if _eacdf !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eacdf );return nil ,ctx ,_eacdf ;};_dceag =append (_dceag ,_aefce );if _edea ._bcefb .isRelative (){ctx .X -=_edea ._dagf ._dca ;ctx .Width =_aecc .Width ;return _dceag ,ctx ,nil ;};return _dceag ,_aecc ,nil ;};

// TOC returns the table of contents component of the creator.
func (_dcc *Creator )TOC ()*TOC {return _dcc ._eea };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_acf *Invoice )SetNoteStyle (style TextStyle ){_acf ._gdee =style };func _egec (_ecf _g .Image )(*Image ,error ){_dade ,_deec :=_ce .ImageHandling .NewImageFromGoImage (_ecf );if _deec !=nil {return nil ,_deec ;};return _begbe (_dade );};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_aafg *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _dfaf (number ,title ,page ,level ,style );};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_aad float64 ;_dee float64 ;_cgge float64 ;_eaeb float64 ;_ggce *_ce .PdfColorDeviceRGB ;_cga *_ce .PdfColorDeviceRGB ;_begd float64 ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_gfca *Invoice )AddressStyle ()TextStyle {return _gfca ._agdf };func _babfad (_gcabe *_ce .PdfAnnotationLink )*_ce .PdfAnnotationLink {if _gcabe ==nil {return nil ;};_gdgae :=_ce .NewPdfAnnotationLink ();_gdgae .BS =_gcabe .BS ;_gdgae .A =_gcabe .A ;if _bcade ,_ggbb :=_gcabe .GetAction ();_ggbb ==nil &&_bcade !=nil {_gdgae .SetAction (_bcade );};if _fegg ,_acdbd :=_gcabe .Dest .(*_fg .PdfObjectArray );_acdbd {_gdgae .Dest =_fg .MakeArray (_fegg .Elements ()...);};return _gdgae ;};

// NewCell returns a new invoice table cell.
func (_fdge *Invoice )NewCell (value string )*InvoiceCell {return _fdge .newCell (value ,_fdge .NewCellProps ());};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_agac *Invoice )AddressHeadingStyle ()TextStyle {return _agac ._bde };

// SetWidthLeft sets border width for left.
func (_bbf *border )SetWidthLeft (bw float64 ){_bbf ._gafd =bw };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_feg *Creator )NewPage ()*_ce .PdfPage {_bgac :=_feg .newPage ();_feg ._fea =append (_feg ._fea ,_bgac );_feg ._ceg .Page ++;return _bgac ;};func _gaf (_gfff string ,_fga _fg .PdfObject ,_cgfg *_ce .PdfPageResources )_fg .PdfObjectName {_ceae :=_be .TrimRightFunc (_be .TrimSpace (_gfff ),func (_caaa rune )bool {return _gb .IsNumber (_caaa )});if _ceae ==""{_ceae ="\u0046\u006f\u006e\u0074";};_acg :=0;_eae :=_fg .PdfObjectName (_gfff );for {_aeec ,_cbe :=_cgfg .GetFontByName (_eae );if !_cbe ||_aeec ==_fga {break ;};_acg ++;_eae =_fg .PdfObjectName (_ba .Sprintf ("\u0025\u0073\u0025\u0064",_ceae ,_acg ));};return _eae ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_cdag int ;_bcec string ;_ebb *Paragraph ;_gge []Drawable ;_fdc int ;_dbd bool ;_dfd bool ;_gagc positioning ;_cdfc ,_dgg float64 ;_ebbe margins ;_eccg *Chapter ;_efgg *TOC ;_ecbb *_ce .Outline ;_begf *_ce .OutlineItem ;_cgg uint ;};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_fggd *Rectangle )GetCoords ()(float64 ,float64 ){return _fggd ._eeff ,_fggd ._dddcb };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_fgb *_cf .ContentStreamOperations ;_cb *_ce .PdfPageResources ;_gg positioning ;_cea ,_bee float64 ;_e float64 ;_ae float64 ;_de float64 ;_abb margins ;_fc []*_ce .PdfAnnotation ;};func (_fbef *Paragraph )getMaxLineWidth ()float64 {if _fbef ._gdab ==nil ||len (_fbef ._gdab )==0{_fbef .wrapText ();};var _baggf float64 ;for _ ,_aceb :=range _fbef ._gdab {_agaa :=_fbef .getTextLineWidth (_aceb );if _agaa > _baggf {_baggf =_agaa ;};};return _baggf ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bbce *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bbce ._ecef =address };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_fbc *Creator )SetForms (form *_ce .PdfAcroForm )error {_fbc ._dgda =form ;return nil };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Write output of creator to io.Writer interface.
func (_aeeg *Creator )Write (ws _ab .Writer )error {if _bad :=_aeeg .Finalize ();_bad !=nil {return _bad ;};_dfga :=_ce .NewPdfWriter ();_dfga .SetOptimizer (_aeeg ._aab );if _aeeg ._dgda !=nil {_cce :=_dfga .SetForms (_aeeg ._dgda );if _cce !=nil {_af .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cce );return _cce ;};};if _aeeg ._afba !=nil {_dfga .AddOutlineTree (_aeeg ._afba );}else if _aeeg ._gac !=nil &&_aeeg .AddOutlines {_dfga .AddOutlineTree (&_aeeg ._gac .ToPdfOutline ().PdfOutlineTreeNode );};if _aeeg ._dabd !=nil {if _efcb :=_dfga .SetPageLabels (_aeeg ._dabd );_efcb !=nil {_af .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_efcb );return _efcb ;};};if _aeeg ._debe !=nil {for _ ,_eed :=range _aeeg ._debe {_ccef :=_eed .SubsetRegistered ();if _ccef !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_ccef );return _ccef ;};};};if _aeeg ._cfa !=nil {_bcff :=_aeeg ._cfa (&_dfga );if _bcff !=nil {_af .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bcff );return _bcff ;};};for _ ,_bbb :=range _aeeg ._fea {_eeaa :=_dfga .AddPage (_bbb );if _eeaa !=nil {_af .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_eeaa );return _eeaa ;};};_bfef :=_dfga .Write (ws );if _bfef !=nil {return _bfef ;};return nil ;};

// SetFillColor sets the fill color.
func (_abed *Polygon )SetFillColor (color Color ){_abed ._dfge .FillColor =_ce .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetTitleStyle sets the style properties of the invoice title.
func (_gdag *Invoice )SetTitleStyle (style TextStyle ){_gdag ._bbac =style };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_ffcf *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _baec (x1 ,y1 ,cx ,cy ,x2 ,y2 );};func _fce (_dad *Chapter ,_dfbd *TOC ,_bae *_ce .Outline ,_cfgf string ,_gdf int ,_cff TextStyle )*Chapter {var _acb uint =1;if _dad !=nil {_acb =_dad ._cgg +1;};_eff :=&Chapter {_cdag :_gdf ,_bcec :_cfgf ,_dbd :true ,_dfd :true ,_eccg :_dad ,_efgg :_dfbd ,_ecbb :_bae ,_gge :[]Drawable {},_cgg :_acb };_daf :=_bbga (_eff .headingText (),_cff );_daf .SetFont (_cff .Font );_daf .SetFontSize (_cff .FontSize );_eff ._ebb =_daf ;return _eff ;};func (_abgf *Invoice )newCell (_fgaa string ,_edb InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_edb ,_fgaa };};

// NewPolyline creates a new polyline.
func (_cabc *Creator )NewPolyline (points []_gd .Point )*Polyline {return _bdcf (points )};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_aeb *Block )AddAnnotation (annotation *_ce .PdfAnnotation ){for _ ,_aed :=range _aeb ._fc {if _aed ==annotation {return ;};};_aeb ._fc =append (_aeb ._fc ,annotation );};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Width returns the width of the Paragraph.
func (_afgb *Paragraph )Width ()float64 {if _afgb ._ebbd &&int (_afgb ._deff )> 0{return _afgb ._deff ;};return _afgb .getTextWidth ()/1000.0;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_dbbcf *List )Marker ()*TextChunk {return &_dbbcf ._bgbe };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_cec :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_af .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cec ;};var _fdd ,_fadc ,_ggafc int ;if len (hexStr )==4{var _gdga ,_dge ,_dac int ;_fdff ,_dfca :=_ba .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_gdga ,&_dge ,&_dac );if _dfca !=nil {_af .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_dfca );return _cec ;};if _fdff !=3{_af .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cec ;};_fdd =_gdga *16+_gdga ;_fadc =_dge *16+_dge ;_ggafc =_dac *16+_dac ;}else {_egbc ,_eda :=_ba .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fdd ,&_fadc ,&_ggafc );if _eda !=nil {_af .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cec ;};if _egbc !=3{_af .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_egbc );return _cec ;};};_edgd :=float64 (_fdd )/255.0;_fcded :=float64 (_fadc )/255.0;_eag :=float64 (_ggafc )/255.0;_cec ._eeb =_edgd ;_cec ._cdbf =_fcded ;_cec ._edcc =_eag ;return _cec ;};

// Height returns the total height of all rows.
func (_dgdg *Table )Height ()float64 {_ada :=float64 (0.0);for _ ,_gcdcd :=range _dgdg ._effbc {_ada +=_gcdcd ;};return _ada ;};

// GetOptimizer returns current PDF optimizer.
func (_bacg *Creator )GetOptimizer ()_ce .Optimizer {return _bacg ._aab };

// SetBorderColor sets the cell's border color.
func (_egcdg *TableCell )SetBorderColor (col Color ){_egcdg ._dbbcg =_ce .NewPdfColorDeviceRGB (col .ToRGB ());_egcdg ._dabfe =_ce .NewPdfColorDeviceRGB (col .ToRGB ());_egcdg ._fgba =_ce .NewPdfColorDeviceRGB (col .ToRGB ());_egcdg ._fcfg =_ce .NewPdfColorDeviceRGB (col .ToRGB ());};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_gcdf float64 ;_cbge float64 ;_ecgg float64 ;_dgea float64 ;_gdac *_ce .PdfColorDeviceRGB ;_dbfd float64 ;};func (_egdg *Invoice )drawInformation ()*Table {_fdef :=_baga (2);_fdbdg :=append ([][2]*InvoiceCell {_egdg ._cdc ,_egdg ._bfcd ,_egdg ._fgfd },_egdg ._bfb ...);for _ ,_fadca :=range _fdbdg {_gbe ,_caca :=_fadca [0],_fadca [1];if _caca .Value ==""{continue ;};_bbba :=_fdef .NewCell ();_bbba .SetBackgroundColor (_gbe .BackgroundColor );_egdg .setCellBorder (_bbba ,_gbe );_dbg :=_cagb (_gbe .TextStyle );_dbg .Append (_gbe .Value );_dbg .SetMargins (0,0,2,1);_bbba .SetContent (_dbg );_bbba =_fdef .NewCell ();_bbba .SetBackgroundColor (_caca .BackgroundColor );_egdg .setCellBorder (_bbba ,_caca );_dbg =_cagb (_caca .TextStyle );_dbg .Append (_caca .Value );_dbg .SetMargins (0,0,2,1);_bbba .SetContent (_dbg );};return _fdef ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bdcdf *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_baedg :=ctx ;_cgfec ,ctx ,_adge :=_bdcdf ._bfec .GeneratePageBlocks (ctx );if _adge !=nil {return _cgfec ,ctx ,_adge ;};for _ ,_ceea :=range _bdcdf ._aafca {_dfgg :=_ceea ._fcfa ;if !_bdcdf ._gdgf {_ceea ._fcfa =0;};_dcag ,_adbc ,_eeed :=_ceea .GeneratePageBlocks (ctx );_ceea ._fcfa =_dfgg ;if _eeed !=nil {return _cgfec ,ctx ,_eeed ;};if len (_dcag )< 1{continue ;};_cgfec [len (_cgfec )-1].mergeBlocks (_dcag [0]);_cgfec =append (_cgfec ,_dcag [1:]...);ctx =_adbc ;};if _bdcdf ._cfgg .isRelative (){ctx .X =_baedg .X ;};if _bdcdf ._cfgg .isAbsolute (){return _cgfec ,_baedg ,nil ;};return _cgfec ,ctx ,nil ;};func (_cdbb rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _cdbb ._eeb ,_cdbb ._cdbf ,_cdbb ._edcc ;};

// Length calculates and returns the line length.
func (_adbe *Line )Length ()float64 {return _f .Sqrt (_f .Pow (_adbe ._ecgg -_adbe ._gcdf ,2.0)+_f .Pow (_adbe ._dgea -_adbe ._cbge ,2.0));};func _baga (_dfcf int )*Table {_edga :=&Table {_cebb :_dfcf ,_ccfda :10.0,_gggbc :[]float64 {},_effbc :[]float64 {},_gfeg :[]*TableCell {}};_edga .resetColumnWidths ();return _edga ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_eddc *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _dea (x1 ,y1 ,x2 ,y2 )};

// Add adds a new line with the default style to the table of contents.
func (_cdba *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_ebfg :=_cdba .AddLine (_dfaf (TextChunk {Text :number ,Style :_cdba ._acda },TextChunk {Text :title ,Style :_cdba ._faff },TextChunk {Text :page ,Style :_cdba ._bdbc },level ,_cdba ._fedc ));if _ebfg ==nil {return nil ;};_befd :=&_cdba ._cfgd ;_ebfg .SetMargins (_befd ._dca ,_befd ._ffe ,_befd ._dcgbd ,_befd ._fbf );_ebfg .SetLevelOffset (_cdba ._efgcc );_ebfg .Separator .Text =_cdba ._cdge ;_ebfg .Separator .Style =_cdba ._efdd ;return _ebfg ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cfgb *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _agega float64 ;var _dfbf []*StyledParagraph ;for _ ,_bcad :=range _cfgb ._cafd {_cdce :=_cagb (_cfgb ._cgad );_cdce .SetEnableWrap (false );_cdce .SetTextAlignment (TextAlignmentRight );_cdce .Append (_bcad ._abe .Text ).Style =_bcad ._abe .Style ;_cffd :=_cdce .getTextWidth ()/1000.0/ctx .Width ;if _agega < _cffd {_agega =_cffd ;};_dfbf =append (_dfbf ,_cdce );};_ccaae :=_baga (2);_ccaae .SetColumnWidths (_agega ,1-_agega );_ccaae .SetMargins (_cfgb ._ceaf ,0,0,0);for _fcgc ,_cddd :=range _cfgb ._cafd {_dfgf :=_ccaae .NewCell ();_dfgf .SetIndent (0);_dfgf .SetContent (_dfbf [_fcgc ]);_dfgf =_ccaae .NewCell ();_dfgf .SetIndent (0);_dfgf .SetContent (_cddd ._adba );};return _ccaae .GeneratePageBlocks (ctx );};

// SetBorderOpacity sets the border opacity.
func (_egcad *Polygon )SetBorderOpacity (opacity float64 ){_egcad ._aecaf =opacity };

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_ega *Invoice )SetAddressHeadingStyle (style TextStyle ){_ega ._cbaaf =style };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_dffacd *TOCLine )SetLevelOffset (levelOffset float64 ){_dffacd ._agcfb =levelOffset ;_dffacd ._ggfe ._gbc ._dca =_dffacd ._dbfeg +float64 (_dffacd ._ccgbg -1)*_dffacd ._agcfb ;};

// SetSellerAddress sets the seller address of the invoice.
func (_ddc *Invoice )SetSellerAddress (address *InvoiceAddress ){_ddc ._gaba =address };

// CurRow returns the currently active cell's row number.
func (_bbaff *Table )CurRow ()int {_egcd :=(_bbaff ._eede -1)/_bbaff ._cebb +1;return _egcd };

// SetTerms sets the terms and conditions section of the invoice.
func (_dgfg *Invoice )SetTerms (title ,content string ){_dgfg ._cgde =[2]string {title ,content }};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_abgd *Creator )Finalize ()error {if _abgd ._fcb {return nil ;};_bgec :=len (_abgd ._fea );_fbfd :=0;if _abgd ._eeec !=nil {_fbfd ++;};if _abgd .AddTOC {_abgd .initContext ();_abgd ._ceg .Page =_fbfd +1;if _abgd ._eba !=nil {if _cfbf :=_abgd ._eba (_abgd ._eea );_cfbf !=nil {return _cfbf ;};};_gda ,_ ,_ebab :=_abgd ._eea .GeneratePageBlocks (_abgd ._ceg );if _ebab !=nil {_af .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_ebab );return _ebab ;};_fbfd +=len (_gda );_cfae :=_abgd ._eea .Lines ();for _ ,_gfd :=range _cfae {_ecgb ,_feag :=_gf .Atoi (_gfd .Page .Text );if _feag !=nil {continue ;};_gfd .Page .Text =_gf .Itoa (_ecgb +_fbfd );};};_ddf :=false ;if _abgd ._eeec !=nil {_bgec ++;_ced :=_abgd .newPage ();_abgd ._fea =append ([]*_ce .PdfPage {_ced },_abgd ._fea ...);_abgd .setActivePage (_ced );_aefb :=FrontpageFunctionArgs {PageNum :1,TotalPages :_bgec };_abgd ._eeec (_aefb );_ddf =true ;};if _abgd .AddTOC {_abgd .initContext ();if _abgd ._eba !=nil {if _gdbd :=_abgd ._eba (_abgd ._eea );_gdbd !=nil {_af .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_gdbd );return _gdbd ;};};_cacf :=_abgd ._eea .Lines ();for _ ,_gcgd :=range _cacf {_gcgd ._fcfa +=int64 (_fbfd );};var _fcba []*_ce .PdfPage ;_egce ,_ ,_ :=_abgd ._eea .GeneratePageBlocks (_abgd ._ceg );for _ ,_ggbc :=range _egce {_ggbc .SetPos (0,0);_bgec ++;_ccb :=_abgd .newPage ();_fcba =append (_fcba ,_ccb );_abgd .setActivePage (_ccb );_abgd .Draw (_ggbc );};if _ddf {_gffg :=_abgd ._fea [0];_abfd :=_abgd ._fea [1:];_abgd ._fea =append ([]*_ce .PdfPage {_gffg },_fcba ...);_abgd ._fea =append (_abgd ._fea ,_abfd ...);}else {_abgd ._fea =append (_fcba ,_abgd ._fea ...);};};if _abgd ._gac !=nil &&_abgd .AddOutlines {var _fde func (_gdef *_ce .OutlineItem );_fde =func (_cde *_ce .OutlineItem ){_cde .Dest .Page +=int64 (_fbfd );if _dabf :=int (_cde .Dest .Page );_dabf >=0&&_dabf < len (_abgd ._fea ){_cde .Dest .PageObj =_abgd ._fea [_dabf ].GetPageAsIndirectObject ();}else {_af .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_dabf );};_cde .Dest .Y =_abgd ._ceed -_cde .Dest .Y ;_gffc :=_cde .Items ();for _ ,_aff :=range _gffc {_fde (_aff );};};_gbf :=_abgd ._gac .Items ();for _ ,_bfee :=range _gbf {_fde (_bfee );};if _abgd .AddTOC {var _gfa int ;if _ddf {_gfa =1;};_dbe :=_ce .NewOutlineDest (int64 (_gfa ),0,_abgd ._ceed );if _gfa >=0&&_gfa < len (_abgd ._fea ){_dbe .PageObj =_abgd ._fea [_gfa ].GetPageAsIndirectObject ();}else {_af .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gfa );};_abgd ._gac .Insert (0,_ce .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_dbe ));};};for _eacd ,_gea :=range _abgd ._fea {_abgd .setActivePage (_gea );if _abgd ._aebef !=nil {_fcg :=NewBlock (_abgd ._acge ,_abgd ._baa ._dcgbd );_eaad :=HeaderFunctionArgs {PageNum :_eacd +1,TotalPages :_bgec };_abgd ._aebef (_fcg ,_eaad );_fcg .SetPos (0,0);if _agee :=_abgd .Draw (_fcg );_agee !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_agee );return _agee ;};};if _abgd ._dcbb !=nil {_fbaf :=NewBlock (_abgd ._acge ,_abgd ._baa ._fbf );_begb :=FooterFunctionArgs {PageNum :_eacd +1,TotalPages :_bgec };_abgd ._dcbb (_fbaf ,_begb );_fbaf .SetPos (0,_abgd ._ceed -_fbaf ._ae );if _eadf :=_abgd .Draw (_fbaf );_eadf !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_eadf );return _eadf ;};};_dcga ,_fadb :=_abgd ._abac [_gea ];if !_fadb {continue ;};if _dccg :=_dcga .drawToPage (_gea );_dccg !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_eacd +1,_dccg );return _dccg ;};};_abgd ._fcb =true ;return nil ;};func (_baaeb *Table )newCell (_ggfb int )*TableCell {_baaeb ._eede ++;_caaee :=(_baaeb ._eede -1)/_baaeb ._cebb +1;for _caaee > _baaeb ._fadae {_baaeb ._fadae ++;_baaeb ._effbc =append (_baaeb ._effbc ,_baaeb ._ccfda );};_gacb :=(_baaeb ._eede -1)%(_baaeb ._cebb )+1;_gcfe :=&TableCell {};_gcfe ._ggab =_caaee ;_gcfe ._effc =_gacb ;_gcfe ._gcfb =1;_gcfe ._fdefd =5;_gcfe ._fgef =CellBorderStyleNone ;_gcfe ._cgee =_gd .LineStyleSolid ;_gcfe ._bgda =CellHorizontalAlignmentLeft ;_gcfe ._fbcec =CellVerticalAlignmentTop ;_gcfe ._acab =0;_gcfe ._bbge =0;_gcfe ._cgbe =0;_gcfe ._gaeef =0;_beacc :=ColorBlack ;_gcfe ._dbbcg =_ce .NewPdfColorDeviceRGB (_beacc .ToRGB ());_gcfe ._dabfe =_ce .NewPdfColorDeviceRGB (_beacc .ToRGB ());_gcfe ._fgba =_ce .NewPdfColorDeviceRGB (_beacc .ToRGB ());_gcfe ._fcfg =_ce .NewPdfColorDeviceRGB (_beacc .ToRGB ());if _ggfb < 1{_af .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_ggfb );_ggfb =1;};_afcfa :=_baaeb ._cebb -(_gcfe ._effc -1);if _ggfb > _afcfa {_af .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_ggfb ,_afcfa );_ggfb =_afcfa ;};_gcfe ._acgee =_ggfb ;_baaeb ._eede +=_ggfb -1;_baaeb ._gfeg =append (_baaeb ._gfeg ,_gcfe );_gcfe ._gabdd =_baaeb ;return _gcfe ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_feac *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_feac ._fbcec =valign };

// SetText sets the text content of the Paragraph.
func (_cgdc *Paragraph )SetText (text string ){_cgdc ._cfcb =text };

// Margins returns the margins of the list: left, right, top, bottom.
func (_cgfa *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _cgfa ._bgff ._dca ,_cgfa ._bgff ._ffe ,_cgfa ._bgff ._dcgbd ,_cgfa ._bgff ._fbf ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_bba *Image )SetMargins (left ,right ,top ,bottom float64 ){_bba ._cfba ._dca =left ;_bba ._cfba ._ffe =right ;_bba ._cfba ._dcgbd =top ;_bba ._cfba ._fbf =bottom ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_ebcb []*TextChunk ;_geb TextStyle ;_cefff TextStyle ;_cdfb TextAlignment ;_eefc float64 ;_edgb bool ;_aag float64 ;_ebee bool ;_agcb float64 ;_gbc margins ;_cfbd positioning ;_abfa float64 ;_cdccc float64 ;_ffae float64 ;_ffd float64 ;_fgde [][]*TextChunk ;_cbdd func (_aaac *StyledParagraph ,_bfcdd DrawContext );};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_feage *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_feage ._bgda =halign ;};func _cagb (_ebaa TextStyle )*StyledParagraph {return &StyledParagraph {_ebcb :[]*TextChunk {},_geb :_ebaa ,_cefff :_bafc (_ebaa .Font ),_eefc :1.0,_cdfb :TextAlignmentLeft ,_edgb :true ,_ebee :true ,_agcb :0,_ffae :1,_ffd :1,_cfbd :_ccff };};

// MoveX moves the drawing context to absolute position x.
func (_fgag *Creator )MoveX (x float64 ){_fgag ._ceg .X =x };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;};

// SetNotes sets the notes section of the invoice.
func (_eaf *Invoice )SetNotes (title ,content string ){_eaf ._agfd =[2]string {title ,content }};

// Width returns the cell's width based on the input draw context.
func (_gbgb *TableCell )Width (ctx DrawContext )float64 {_dabg :=float64 (0.0);for _cdece :=0;_cdece < _gbgb ._acgee ;_cdece ++{_dabg +=_gbgb ._gabdd ._gggbc [_gbgb ._effc +_cdece -1];};_egafe :=ctx .Width *_dabg ;return _egafe ;};var PPI float64 =72;func _babga (_fefc *Block ,_fbdb *Image ,_fefa DrawContext )(DrawContext ,error ){_afeg :=_fefa ;_bafgb :=1;_bag :=_fg .PdfObjectName (_ba .Sprintf ("\u0049\u006d\u0067%\u0064",_bafgb ));for _fefc ._cb .HasXObjectByName (_bag ){_bafgb ++;_bag =_fg .PdfObjectName (_ba .Sprintf ("\u0049\u006d\u0067%\u0064",_bafgb ));};_aac :=_fefc ._cb .SetXObjectImageByName (_bag ,_fbdb ._bdfe );if _aac !=nil {return _fefa ,_aac ;};_aae :=0;_baae :=_fg .PdfObjectName (_ba .Sprintf ("\u0047\u0053\u0025\u0064",_aae ));for _fefc ._cb .HasExtGState (_baae ){_aae ++;_baae =_fg .PdfObjectName (_ba .Sprintf ("\u0047\u0053\u0025\u0064",_aae ));};_dbb :=_fg .MakeDict ();_dbb .Set ("\u0042\u004d",_fg .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _fbdb ._bbdd < 1.0{_dbb .Set ("\u0043\u0041",_fg .MakeFloat (_fbdb ._bbdd ));_dbb .Set ("\u0063\u0061",_fg .MakeFloat (_fbdb ._bbdd ));};_aac =_fefc ._cb .AddExtGState (_baae ,_fg .MakeIndirectObject (_dbb ));if _aac !=nil {return _fefa ,_aac ;};_fbff :=_fbdb .Width ();_bdab :=_fbdb .Height ();_ ,_cafb :=_fbdb .rotatedSize ();_dbdb :=_fefa .X ;_egde :=_fefa .PageHeight -_fefa .Y -_bdab ;if _fbdb ._cfcd .isRelative (){_egde -=(_cafb -_bdab )/2;switch _fbdb ._gdde {case HorizontalAlignmentCenter :_dbdb +=(_fefa .Width -_fbff )/2;case HorizontalAlignmentRight :_dbdb =_fefa .PageWidth -_fefa .Margins ._ffe -_fbdb ._cfba ._ffe -_fbff ;};};_agcd :=_fbdb ._cegb ;_adb :=_cf .NewContentCreator ();_adb .Add_gs (_baae );_adb .Translate (_dbdb ,_egde );if _agcd !=0{_adb .Translate (_fbff /2,_bdab /2);_adb .RotateDeg (_agcd );_adb .Translate (-_fbff /2,-_bdab /2);};_adb .Scale (_fbff ,_bdab ).Add_Do (_bag );_facb :=_adb .Operations ();_facb .WrapIfNeeded ();_fefc .addContents (_facb );if _fbdb ._cfcd .isRelative (){_fefa .Y +=_cafb ;_fefa .Height -=_cafb ;return _fefa ,nil ;};return _afeg ,nil ;};func (_ddgdc *StyledParagraph )getTextLineWidth (_gcae []*TextChunk )float64 {var _eadg float64 ;_fefag :=len (_gcae );for _gded ,_aabb :=range _gcae {_cdad :=&_aabb .Style ;_defd :=len (_aabb .Text );for _aada ,_geaf :=range _aabb .Text {if _geaf =='\u000A'{continue ;};_dffac ,_cfbaa :=_cdad .Font .GetRuneMetrics (_geaf );if !_cfbaa {_af .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_geaf );return -1;};_eadg +=_cdad .FontSize *_dffac .Wx ;if _geaf !=' '&&(_gded !=_fefag -1||_aada !=_defd -1){_eadg +=_cdad .CharSpacing *1000.0;};};};return _eadg ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_cbee *Creator )CreateTableOfContents (genTOCFunc func (_fcdea *TOC )error ){_cbee ._eba =genTOCFunc ;};func _bdcf (_cfce []_gd .Point )*Polyline {return &Polyline {_bbfe :&_gd .Polyline {Points :_cfce ,LineColor :_ce .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_bedag :1.0};};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_gdeag *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_eagb :=&_gdeag ._ggfe ._gbc ;return _gdeag ._dbfeg ,_eagb ._ffe ,_eagb ._dcgbd ,_eagb ._fbf ;};

// SetLevel sets the indentation level of the TOC line.
func (_eadgc *TOCLine )SetLevel (level uint ){_eadgc ._ccgbg =level ;_eadgc ._ggfe ._gbc ._dca =_eadgc ._dbfeg +float64 (_eadgc ._ccgbg -1)*_eadgc ._agcfb ;};

// Reset removes all the text chunks the paragraph contains.
func (_babfa *StyledParagraph )Reset (){_babfa ._ebcb =[]*TextChunk {}};func _afab (_fagf string ,_ceddf ,_ecceb TextStyle )*TOC {_dbce :=_ecceb ;_dbce .FontSize =14;_gcdce :=_cagb (_dbce );_gcdce .SetEnableWrap (true );_gcdce .SetTextAlignment (TextAlignmentLeft );_gcdce .SetMargins (0,0,0,5);_aeff :=_gcdce .Append (_fagf );_aeff .Style =_dbce ;return &TOC {_bfec :_gcdce ,_aafca :[]*TOCLine {},_acda :_ceddf ,_faff :_ceddf ,_efdd :_ceddf ,_bdbc :_ceddf ,_cdge :"\u002e",_efgcc :10,_cfgd :margins {0,0,2,2},_cfgg :_ccff ,_fedc :_ceddf ,_gdgf :true };};

// Cols returns the total number of columns the table has.
func (_cggcd *Table )Cols ()int {return _cggcd ._cebb };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        â€¢ This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_cafd []*listItem ;_bgff margins ;_bgbe TextChunk ;_ceaf float64 ;_gdfa bool ;_agacd positioning ;_cgad TextStyle ;};

// NewList creates a new list.
func (_dfgba *Creator )NewList ()*List {return _agbd (_dfgba .NewTextStyle ())};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_bbfe *_gd .Polyline ;_bedag float64 ;};

// SetLineWidth sets the line width.
func (_cbgdc *Polyline )SetLineWidth (lineWidth float64 ){_cbgdc ._bbfe .LineWidth =lineWidth };func (_dbgg *Invoice )generateHeaderBlocks (_abfdb DrawContext )([]*Block ,DrawContext ,error ){_effb :=_cagb (_dbgg ._bbac );_effb .SetEnableWrap (true );_effb .Append (_dbgg ._gggf );_bddg :=_baga (2);if _dbgg ._eaaf !=nil {_feae :=_bddg .NewCell ();_feae .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_feae .SetVerticalAlignment (CellVerticalAlignmentMiddle );_feae .SetIndent (0);_feae .SetContent (_dbgg ._eaaf );_dbgg ._eaaf .ScaleToHeight (_effb .Height ()+20);}else {_bddg .SkipCells (1);};_ddga :=_bddg .NewCell ();_ddga .SetHorizontalAlignment (CellHorizontalAlignmentRight );_ddga .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ddga .SetContent (_effb );return _bddg .GeneratePageBlocks (_abfdb );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ggdg *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfce :=ctx ;_dceg :=[]func (_fecc DrawContext )([]*Block ,DrawContext ,error ){_ggdg .generateHeaderBlocks ,_ggdg .generateInformationBlocks ,_ggdg .generateLineBlocks ,_ggdg .generateTotalBlocks ,_ggdg .generateNoteBlocks };var _bcc []*Block ;for _ ,_cbef :=range _dceg {_eagc ,_gbdf ,_abga :=_cbef (ctx );if _abga !=nil {return _bcc ,ctx ,_abga ;};if len (_bcc )==0{_bcc =_eagc ;}else if len (_eagc )> 0{_bcc [len (_bcc )-1].mergeBlocks (_eagc [0]);_bcc =append (_bcc ,_eagc [1:]...);};ctx =_gbdf ;};if _ggdg ._abbad .isRelative (){ctx .X =_bfce .X ;};if _ggdg ._abbad .isAbsolute (){return _bcc ,_bfce ,nil ;};return _bcc ,ctx ,nil ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_dbf *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _dcea (xc ,yc ,width ,height );};

// Lines returns all the lines the table of contents has.
func (_eebe *TOC )Lines ()[]*TOCLine {return _eebe ._aafca };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gcbge *_ce .PdfAnnotation ;_fbaa bool ;};func (_dcdg *StyledParagraph )getTextHeight ()float64 {var _edgcc float64 ;for _ ,_bddd :=range _dcdg ._ebcb {_cadg :=_bddd .Style .FontSize *_dcdg ._eefc ;if _cadg > _edgcc {_edgcc =_cadg ;};};return _edgcc ;};func _begbe (_ggg *_ce .Image )(*Image ,error ){_bfge :=float64 (_ggg .Width );_gdcg :=float64 (_ggg .Height );return &Image {_gdfc :_ggg ,_ege :_bfge ,_gecb :_gdcg ,_gefe :_bfge ,_gad :_gdcg ,_cegb :0,_bbdd :1.0,_cfcd :_ccff },nil ;};

// SetNumber sets the number of the invoice.
func (_cace *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_cace ._cdc [1].Value =number ;return _cace ._cdc [0],_cace ._cdc [1];};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetColor sets the line color.
func (_eca *Curve )SetColor (col Color ){_eca ._afef =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewChapter creates a new chapter with the specified title as the heading.
func (_gcb *Creator )NewChapter (title string )*Chapter {_gcb ._deg ++;_ffaa :=_gcb .NewTextStyle ();_ffaa .FontSize =16;return _fce (nil ,_gcb ._eea ,_gcb ._gac ,title ,_gcb ._deg ,_ffaa );};

// NewInvoice returns an instance of an empty invoice.
func (_cffc *Creator )NewInvoice ()*Invoice {_cfac :=_cffc .NewTextStyle ();_cfac .Font =_cffc ._efb ;return _caef (_cffc .NewTextStyle (),_cfac );};func (_facdf *List )tableHeight (_badd float64 )float64 {var _fddd float64 ;for _ ,_caaf :=range _facdf ._cafd {switch _geca :=_caaf ._adba .(type ){case *Paragraph :_fggbc :=_geca ;if _fggbc ._ebbd {_fggbc .SetWidth (_badd );};_fddd +=_fggbc .Height ()+_fggbc ._dagf ._fbf +_fggbc ._dagf ._fbf ;_fddd +=0.5*_fggbc ._feccg *_fggbc ._gfga ;case *StyledParagraph :_adgc :=_geca ;if _adgc ._edgb {_adgc .SetWidth (_badd );};_fddd +=_adgc .Height ()+_adgc ._gbc ._dcgbd +_adgc ._gbc ._fbf ;_fddd +=0.5*_adgc .getTextHeight ();default:_fddd +=_caaf ._adba .Height ();};};return _fddd ;};

// SetHeight sets the Image's document height to specified h.
func (_cebf *Image )SetHeight (h float64 ){_cebf ._gad =h };func _bgecb ()*PageBreak {return &PageBreak {}};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SellerAddress returns the seller address used in the invoice template.
func (_ageeg *Invoice )SellerAddress ()*InvoiceAddress {return _ageeg ._gaba };

// SetTotal sets the total of the invoice.
func (_beca *Invoice )SetTotal (value string ){_beca ._ccfd [1].Value =value };

// SetWidthRight sets border width for right.
func (_dfa *border )SetWidthRight (bw float64 ){_dfa ._ge =bw };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_fbec *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_fbec ._eea =toc ;};

// SetBorderColor sets border color.
func (_ccgfd *Rectangle )SetBorderColor (col Color ){_ccgfd ._aefe =_ce .NewPdfColorDeviceRGB (col .ToRGB ());};

// AddTotalLine adds a new line in the invoice totals table.
func (_edfa *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gcff :=&InvoiceCell {_edfa ._cabb ,desc };_cggc :=&InvoiceCell {_edfa ._cabb ,value };_edfa ._cfab =append (_edfa ._cfab ,[2]*InvoiceCell {_gcff ,_cggc });return _gcff ,_cggc ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_dgde float64 ;_bfg float64 ;_cbbaa float64 ;_bgecd float64 ;_ecgd float64 ;_fcdd float64 ;_afef *_ce .PdfColorDeviceRGB ;_efgd float64 ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_bbda *_gd .PolyBezierCurve ;_ddfb float64 ;_facbb float64 ;};

// SetInline sets the inline mode of the division.
func (_fgbf *Division )SetInline (inline bool ){_fgbf ._afg =inline };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dbfa *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _dbfa ._fgfd [0],_dbfa ._fgfd [1]};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_dbfg *Ellipse )GetCoords ()(float64 ,float64 ){return _dbfg ._aad ,_dbfg ._dee };

// SetWidth sets line width.
func (_feb *Curve )SetWidth (width float64 ){_feb ._efgd =width };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetEnableWrap sets the line wrapping enabled flag.
func (_badf *Paragraph )SetEnableWrap (enableWrap bool ){_badf ._ebbd =enableWrap ;_badf ._egaf =false };

// Indent returns the left offset of the list when nested into another list.
func (_bgfa *List )Indent ()float64 {return _bgfa ._ceaf };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// SetLineHeight sets the line height (1.0 default).
func (_cad *StyledParagraph )SetLineHeight (lineheight float64 ){_cad ._eefc =lineheight };

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_eegf *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bacc []*Block ;_gafb :=ctx ;if _eegf ._ffac .isRelative (){ctx .X +=_eegf ._ddgc ._dca ;ctx .Y +=_eegf ._ddgc ._dcgbd ;ctx .Width -=_eegf ._ddgc ._dca +_eegf ._ddgc ._ffe ;ctx .Height -=_eegf ._ddgc ._dcgbd +_eegf ._ddgc ._fbf ;};ctx .Inline =_eegf ._afg ;_dff :=ctx ;_bcb :=ctx ;var _dcgd float64 ;for _ ,_abgg :=range _eegf ._fbce {if ctx .Inline {if (ctx .X -_dff .X )+_abgg .Width ()<=ctx .Width {ctx .Y =_bcb .Y ;ctx .Height =_bcb .Height ;}else {ctx .X =_dff .X ;ctx .Width =_dff .Width ;_bcb .Y +=_dcgd ;_bcb .Height -=_dcgd ;_dcgd =0;};};_geaa ,_bdfd ,_ecab :=_abgg .GeneratePageBlocks (ctx );if _ecab !=nil {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_ecab );return nil ,ctx ,_ecab ;};if len (_geaa )< 1{continue ;};if len (_bacc )> 0{_bacc [len (_bacc )-1].mergeBlocks (_geaa [0]);_bacc =append (_bacc ,_geaa [1:]...);}else {_bacc =append (_bacc ,_geaa [0:]...);};if ctx .Inline {if ctx .Page !=_bdfd .Page {_dff .Y =ctx .Margins ._dcgbd ;_dff .Height =ctx .PageHeight -ctx .Margins ._dcgbd ;_bcb .Y =_dff .Y ;_bcb .Height =_dff .Height ;_dcgd =_bdfd .Height -_dff .Height ;}else {if _cgeb :=ctx .Height -_bdfd .Height ;_cgeb > _dcgd {_dcgd =_cgeb ;};};}else {_bdfd .X =ctx .X ;};ctx =_bdfd ;};ctx .Inline =_gafb .Inline ;if _eegf ._ffac .isRelative (){ctx .X =_gafb .X ;};if _eegf ._ffac .isAbsolute (){return _bacc ,_gafb ,nil ;};return _bacc ,ctx ,nil ;};const (_ccff positioning =iota ;_efeg ;);func _geeeg (_baeec ,_gdeggd ,_gafge float64 )(_gead ,_fedg ,_dece ,_cgcf float64 ){if _gafge ==0{return 0,0,_baeec ,_gdeggd ;};_cadf :=_gd .Path {Points :[]_gd .Point {_gd .NewPoint (0,0).Rotate (_gafge ),_gd .NewPoint (_baeec ,0).Rotate (_gafge ),_gd .NewPoint (0,_gdeggd ).Rotate (_gafge ),_gd .NewPoint (_baeec ,_gdeggd ).Rotate (_gafge )}}.GetBoundingBox ();return _cadf .X ,_cadf .Y ,_cadf .Width ,_cadf .Height ;};func (_dffaf *Paragraph )getTextWidth ()float64 {_dccb :=0.0;for _ ,_aeaf :=range _dffaf ._cfcb {if _aeaf =='\u000A'{continue ;};_acgef ,_cdcf :=_dffaf ._deag .GetRuneMetrics (_aeaf );if !_cdcf {_af .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_aeaf ,_aeaf );return -1;};_dccb +=_dffaf ._feccg *_acgef .Wx ;};return _dccb ;};func _bgfc (_faf ,_gdegd ,_bdbb ,_gegc float64 )*Rectangle {return &Rectangle {_eeff :_faf ,_dddcb :_gdegd ,_ffee :_bdbb ,_gbac :_gegc ,_aefe :_ce .NewPdfColorDeviceRGB (0,0,0),_gefg :1.0,_gbbd :1.0,_cdbg :1.0};};func (_fd *Block )mergeBlocks (_fbd *Block )error {_ef :=_fad (_fd ._fgb ,_fd ._cb ,_fbd ._fgb ,_fbd ._cb );if _ef !=nil {return _ef ;};for _ ,_fee :=range _fbd ._fc {_fd .AddAnnotation (_fee );};return nil ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_dfac *TOC )SetShowLinks (showLinks bool ){_dfac ._gdgf =showLinks };

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_gba *Image )GetHorizontalAlignment ()HorizontalAlignment {return _gba ._gdde };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_cabbc *StyledParagraph )SetWidth (width float64 ){_cabbc ._aag =width ;_cabbc .wrapText ()};func (_eeee *StyledParagraph )getTextWidth ()float64 {var _bddf float64 ;_bddff :=len (_eeee ._ebcb );for _bfbe ,_abcdd :=range _eeee ._ebcb {_fbde :=&_abcdd .Style ;_ecgbg :=len (_abcdd .Text );for _faae ,_baac :=range _abcdd .Text {if _baac =='\u000A'{continue ;};_ffbaa ,_ggba :=_fbde .Font .GetRuneMetrics (_baac );if !_ggba {_af .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_baac );return -1;};_bddf +=_fbde .FontSize *_ffbaa .Wx ;if _baac !=' '&&(_bfbe !=_bddff -1||_faae !=_ecgbg -1){_bddf +=_fbde .CharSpacing *1000.0;};};};return _bddf ;};

// Title returns the title of the invoice.
func (_gbdeg *Invoice )Title ()string {return _gbdeg ._gggf };func _agbd (_ddag TextStyle )*List {return &List {_bgbe :TextChunk {Text :"\u2022\u0020",Style :_ddag },_ceaf :0,_gdfa :true ,_agacd :_ccff ,_cgad :_ddag };};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetStyleTop sets border style for top side.
func (_geg *border )SetStyleTop (style CellBorderStyle ){_geg ._bff =style };func (_cdb *Block )drawToPage (_dcf *_ce .PdfPage )error {_dcd ,_faa :=_dcf .GetAllContentStreams ();if _faa !=nil {return _faa ;};_bd :=_cf .NewContentStreamParser (_dcd );_eg ,_faa :=_bd .Parse ();if _faa !=nil {return _faa ;};_eg .WrapIfNeeded ();if _dcf .Resources ==nil {_dcf .Resources =_ce .NewPdfPageResources ();};_faa =_fad (_eg ,_dcf .Resources ,_cdb ._fgb ,_cdb ._cb );if _faa !=nil {return _faa ;};if _faa =_gfe (_cdb ._cb ,_dcf .Resources );_faa !=nil {return _faa ;};_faa =_dcf .SetContentStreams ([]string {string (_eg .Bytes ())},_fg .NewFlateEncoder ());if _faa !=nil {return _faa ;};for _ ,_bgba :=range _cdb ._fc {_dcf .AddAnnotation (_bgba );};return nil ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_bbgg *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfdbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bedf :=_gd .Rectangle {Opacity :1.0,X :_bbgg ._eeff ,Y :ctx .PageHeight -_bbgg ._dddcb -_bbgg ._gbac ,Height :_bbgg ._gbac ,Width :_bbgg ._ffee };if _bbgg ._dgefa !=nil {_bedf .FillEnabled =true ;_bedf .FillColor =_bbgg ._dgefa ;};if _bbgg ._aefe !=nil &&_bbgg ._gefg > 0{_bedf .BorderEnabled =true ;_bedf .BorderColor =_bbgg ._aefe ;_bedf .BorderWidth =_bbgg ._gefg ;};_bcga ,_cdbda :=_dfdbd .setOpacity (_bbgg ._gbbd ,_bbgg ._cdbg );if _cdbda !=nil {return nil ,ctx ,_cdbda ;};_cgab ,_ ,_cdbda :=_bedf .Draw (_bcga );if _cdbda !=nil {return nil ,ctx ,_cdbda ;};if _cdbda =_dfdbd .addContentsByString (string (_cgab ));_cdbda !=nil {return nil ,ctx ,_cdbda ;};return []*Block {_dfdbd },ctx ,nil ;};func (_ddd *Block )translate (_gcdb ,_bf float64 ){_dcg :=_cf .NewContentCreator ().Translate (_gcdb ,-_bf ).Operations ();*_ddd ._fgb =append (*_dcg ,*_ddd ._fgb ...);_ddd ._fgb .WrapIfNeeded ();};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_acebdb *Table )MultiColCell (colspan int )*TableCell {return _acebdb .newCell (colspan )};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_acbb *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbbe ,_ffcc :=_cdff .setOpacity (_acbb ._acgc ,_acbb ._aecaf );if _ffcc !=nil {return nil ,ctx ,_ffcc ;};_efaa :=_acbb ._dfge ;_efaa .FillEnabled =_efaa .FillColor !=nil ;_efaa .BorderEnabled =_efaa .BorderColor !=nil &&_efaa .BorderWidth > 0;_ccdf :=_efaa .Points ;for _agaad :=range _ccdf {for _daag :=range _ccdf [_agaad ]{_fgga :=&_ccdf [_agaad ][_daag ];_fgga .Y =ctx .PageHeight -_fgga .Y ;};};_cbefa ,_ ,_ffcc :=_efaa .Draw (_gbbe );if _ffcc !=nil {return nil ,ctx ,_ffcc ;};if _ffcc =_cdff .addContentsByString (string (_cbefa ));_ffcc !=nil {return nil ,ctx ,_ffcc ;};return []*Block {_cdff },ctx ,nil ;};

// SetDueDate sets the due date of the invoice.
func (_dfee *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_dfee ._fgfd [1].Value =dueDate ;return _dfee ._fgfd [0],_dfee ._fgfd [1];};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_fec *Division )Width ()float64 {return 0};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gffge *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _gffge ._ccfd [0],_gffge ._ccfd [1]};func _fad (_egd *_cf .ContentStreamOperations ,_feeb *_ce .PdfPageResources ,_bab *_cf .ContentStreamOperations ,_gdb *_ce .PdfPageResources )error {_gff :=map[_fg .PdfObjectName ]_fg .PdfObjectName {};_ece :=map[_fg .PdfObjectName ]_fg .PdfObjectName {};_cfc :=map[_fg .PdfObjectName ]_fg .PdfObjectName {};_ceag :=map[_fg .PdfObjectName ]_fg .PdfObjectName {};_fbb :=map[_fg .PdfObjectName ]_fg .PdfObjectName {};_ffb :=map[_fg .PdfObjectName ]_fg .PdfObjectName {};for _ ,_dcb :=range *_bab {switch _dcb .Operand {case "\u0044\u006f":if len (_dcb .Params )==1{if _fcd ,_eab :=_dcb .Params [0].(*_fg .PdfObjectName );_eab {if _ ,_dg :=_gff [*_fcd ];!_dg {var _cab _fg .PdfObjectName ;_caa ,_ :=_gdb .GetXObjectByName (*_fcd );if _caa !=nil {_cab =*_fcd ;for {_efg ,_ :=_feeb .GetXObjectByName (_cab );if _efg ==nil ||_efg ==_caa {break ;};_cab =_cab +"\u0030";};};_feeb .SetXObjectByName (_cab ,_caa );_gff [*_fcd ]=_cab ;};_babe :=_gff [*_fcd ];_dcb .Params [0]=&_babe ;};};case "\u0054\u0066":if len (_dcb .Params )==2{if _dddc ,_abc :=_dcb .Params [0].(*_fg .PdfObjectName );_abc {if _ ,_aegb :=_ece [*_dddc ];!_aegb {_fcde ,_cfbb :=_gdb .GetFontByName (*_dddc );_edf :=*_dddc ;if _cfbb &&_fcde !=nil {_edf =_gaf (_dddc .String (),_fcde ,_feeb );};_feeb .SetFontByName (_edf ,_fcde );_ece [*_dddc ]=_edf ;};_ccf :=_ece [*_dddc ];_dcb .Params [0]=&_ccf ;};};case "\u0043\u0053","\u0063\u0073":if len (_dcb .Params )==1{if _bced ,_cgf :=_dcb .Params [0].(*_fg .PdfObjectName );_cgf {if _ ,_egcc :=_cfc [*_bced ];!_egcc {var _bdc _fg .PdfObjectName ;_fgc ,_bcf :=_gdb .GetColorspaceByName (*_bced );if _bcf {_bdc =*_bced ;for {_gce ,_fdf :=_feeb .GetColorspaceByName (_bdc );if !_fdf ||_fgc ==_gce {break ;};_bdc =_bdc +"\u0030";};_feeb .SetColorspaceByName (_bdc ,_fgc );_cfc [*_bced ]=_bdc ;}else {_af .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _bece ,_bcg :=_cfc [*_bced ];_bcg {_dcb .Params [0]=&_bece ;}else {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_bced );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_dcb .Params )==1{if _efe ,_eef :=_dcb .Params [0].(*_fg .PdfObjectName );_eef {if _ ,_eabg :=_ceag [*_efe ];!_eabg {var _ffc _fg .PdfObjectName ;_gbb ,_gcg :=_gdb .GetPatternByName (*_efe );if _gcg {_ffc =*_efe ;for {_eade ,_eee :=_feeb .GetPatternByName (_ffc );if !_eee ||_eade ==_gbb {break ;};_ffc =_ffc +"\u0030";};_cdaa :=_feeb .SetPatternByName (_ffc ,_gbb .ToPdfObject ());if _cdaa !=nil {return _cdaa ;};_ceag [*_efe ]=_ffc ;};};if _gbd ,_fba :=_ceag [*_efe ];_fba {_dcb .Params [0]=&_gbd ;};};};case "\u0073\u0068":if len (_dcb .Params )==1{if _aa ,_dfgd :=_dcb .Params [0].(*_fg .PdfObjectName );_dfgd {if _ ,_gcge :=_fbb [*_aa ];!_gcge {var _gga _fg .PdfObjectName ;_feebe ,_bbe :=_gdb .GetShadingByName (*_aa );if _bbe {_gga =*_aa ;for {_eaa ,_bfc :=_feeb .GetShadingByName (_gga );if !_bfc ||_feebe ==_eaa {break ;};_gga =_gga +"\u0030";};_gcged :=_feeb .SetShadingByName (_gga ,_feebe .ToPdfObject ());if _gcged !=nil {_af .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_gcged );return _gcged ;};_fbb [*_aa ]=_gga ;}else {_af .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _ebe ,_ccgf :=_fbb [*_aa ];_ccgf {_dcb .Params [0]=&_ebe ;}else {_af .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_aa );};};};case "\u0067\u0073":if len (_dcb .Params )==1{if _fcac ,_cddf :=_dcb .Params [0].(*_fg .PdfObjectName );_cddf {if _ ,_efa :=_ffb [*_fcac ];!_efa {var _bdf _fg .PdfObjectName ;_ggb ,_fgce :=_gdb .GetExtGState (*_fcac );if _fgce {_bdf =*_fcac ;_ecg :=1;for {_fcae ,_ffa :=_feeb .GetExtGState (_bdf );if !_ffa ||_ggb ==_fcae {break ;};_bdf =_fg .PdfObjectName (_ba .Sprintf ("\u0047\u0053\u0025\u0064",_ecg ));_ecg ++;};};_feeb .AddExtGState (_bdf ,_ggb );_ffb [*_fcac ]=_bdf ;};_dab :=_ffb [*_fcac ];_dcb .Params [0]=&_dab ;};};};*_egd =append (*_egd ,_dcb );};return nil ;};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_ce .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};

// SetBorderColor sets the border color.
func (_cdfa *Ellipse )SetBorderColor (col Color ){_cdfa ._cga =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// AppendColumn appends a column to the line items table.
func (_cgbc *Invoice )AppendColumn (description string )*InvoiceCell {_ebba :=_cgbc .NewColumn (description );_cgbc ._dfeb =append (_cgbc ._dfeb ,_ebba );return _ebba ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_dbcg *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_befg :=uint (len (_dbcg ._dfeb ));if index > _befg {index =_befg ;};_gcde :=_dbcg .NewColumn (description );_dbcg ._dfeb =append (_dbcg ._dfeb [:index ],append ([]*InvoiceCell {_gcde },_dbcg ._dfeb [index :]...)...);return _gcde ;};var PPMM =float64 (72*1.0/25.4);

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_cba []_gd .CubicBezierCurve ;FillEnabled bool ;_eegb *_ce .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_gdfe *_ce .PdfColorDeviceRGB ;};

// SetPos sets absolute positioning with specified coordinates.
func (_feagc *Paragraph )SetPos (x ,y float64 ){_feagc ._bcefb =_efeg ;_feagc ._afc =x ;_feagc ._gcfc =y ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_dfad *Creator )RotateDeg (angleDeg int64 )error {_bdcg :=_dfad .getActivePage ();if _bdcg ==nil {_af .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _a .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _gbda int64 ;if _bdcg .Rotate !=nil {_gbda =*(_bdcg .Rotate );};_gbda +=angleDeg ;_bdcg .Rotate =&_gbda ;return nil ;};type border struct{_dde float64 ;_faab float64 ;_abbd float64 ;_bcedc float64 ;_afa *_ce .PdfColorDeviceRGB ;_ecc *_ce .PdfColorDeviceRGB ;_gafd float64 ;_cag *_ce .PdfColorDeviceRGB ;_cdf float64 ;_acc *_ce .PdfColorDeviceRGB ;_ge float64 ;_fab *_ce .PdfColorDeviceRGB ;_dfc float64 ;LineStyle _gd .LineStyle ;_afee CellBorderStyle ;_ded CellBorderStyle ;_bff CellBorderStyle ;_dcge CellBorderStyle ;};func (_dcff *Image )makeXObject ()error {_fdbd :=_dcff ._dfab ;if _fdbd ==nil {_fdbd =_fg .NewFlateEncoder ();};_aafc ,_bgdd :=_ce .NewXObjectImageFromImage (_dcff ._gdfc ,nil ,_fdbd );if _bgdd !=nil {_af .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bgdd );return _bgdd ;};_dcff ._bdfe =_aafc ;return nil ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_dcba *Line )SetColor (col Color ){_dcba ._gdac =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};func _dfaf (_egag ,_fbafd ,_edde TextChunk ,_eedeg uint ,_gdgda TextStyle )*TOCLine {_abeg :=_cagb (_gdgda );_abeg .SetEnableWrap (true );_abeg .SetTextAlignment (TextAlignmentLeft );_abeg .SetMargins (0,0,2,2);_ddad :=&TOCLine {_ggfe :_abeg ,Number :_egag ,Title :_fbafd ,Page :_edde ,Separator :TextChunk {Text :"\u002e",Style :_gdgda },_dbfeg :0,_ccgbg :_eedeg ,_agcfb :10,_afac :_ccff };_abeg ._gbc ._dca =_ddad ._dbfeg +float64 (_ddad ._ccgbg -1)*_ddad ._agcfb ;_abeg ._cbdd =_ddad .prepareParagraph ;return _ddad ;};

// SetDate sets the date of the invoice.
func (_bbae *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_bbae ._bfcd [1].Value =date ;return _bbae ._bfcd [0],_bbae ._bfcd [1];};

// SetFillOpacity sets the fill opacity.
func (_bcefa *Polygon )SetFillOpacity (opacity float64 ){_bcefa ._acgc =opacity };

// SetLineOpacity sets the line opacity.
func (_bdbf *Polyline )SetLineOpacity (opacity float64 ){_bdbf ._bedag =opacity };

// SetTitle sets the title of the invoice.
func (_fbbd *Invoice )SetTitle (title string ){_fbbd ._gggf =title };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_fb *Block )SetPos (x ,y float64 ){_fb ._gg =_efeg ;_fb ._cea =x ;_fb ._bee =y };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_badbb *TOC )SetLineNumberStyle (style TextStyle ){_badbb ._acda =style };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_cbeeg *TOC )SetHeading (text string ,style TextStyle ){_beacb :=_cbeeg .Heading ();_beacb .Reset ();_aabg :=_beacb .Append (text );_aabg .Style =style ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_fddc *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bada :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _agcf []string ;_agcf =append (_agcf ,_ba .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_fddc ._efgd ));_agcf =append (_agcf ,_ba .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_fddc ._afef [0],_fddc ._afef [1],_fddc ._afef [2]));_agcf =append (_agcf ,_ba .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_fddc ._dgde ,ctx .PageHeight -_fddc ._bfg ));_agcf =append (_agcf ,_ba .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_fddc ._cbbaa ,ctx .PageHeight -_fddc ._bgecd ,_fddc ._ecgd ,ctx .PageHeight -_fddc ._fcdd ));_fbfdg :=_bada .addContentsByString (_be .Join (_agcf ,"\u000a"));if _fbfdg !=nil {return nil ,ctx ,_fbfdg ;};return []*Block {_bada },ctx ,nil ;};

// Width returns the width of the Paragraph.
func (_agab *StyledParagraph )Width ()float64 {if _agab ._edgb &&int (_agab ._aag )> 0{return _agab ._aag ;};return _agab .getTextWidth ()/1000.0;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_eabf *Invoice )SetAddressStyle (style TextStyle ){_eabf ._agdf =style };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_gcbb *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_feagcc :=&_gcbb ._cfgd ;_feagcc ._dca =left ;_feagcc ._ffe =right ;_feagcc ._dcgbd =top ;_feagcc ._fbf =bottom ;};func _dea (_ecdg ,_dgdd ,_cdgg ,_gffgc float64 )*Line {_aecd :=&Line {};_aecd ._gcdf =_ecdg ;_aecd ._cbge =_dgdd ;_aecd ._ecgg =_cdgg ;_aecd ._dgea =_gffgc ;_aecd ._gdac =_ce .NewPdfColorDeviceRGB (0,0,0);_aecd ._dbfd =1.0;return _aecd ;};

// SetBorderColor sets the border color.
func (_effd *Polygon )SetBorderColor (color Color ){_effd ._dfge .BorderColor =_ce .NewPdfColorDeviceRGB (color .ToRGB ());};func (_fcaec *Creator )initContext (){_fcaec ._ceg .X =_fcaec ._baa ._dca ;_fcaec ._ceg .Y =_fcaec ._baa ._dcgbd ;_fcaec ._ceg .Width =_fcaec ._acge -_fcaec ._baa ._ffe -_fcaec ._baa ._dca ;_fcaec ._ceg .Height =_fcaec ._ceed -_fcaec ._baa ._fbf -_fcaec ._baa ._dcgbd ;_fcaec ._ceg .PageHeight =_fcaec ._ceed ;_fcaec ._ceg .PageWidth =_fcaec ._acge ;_fcaec ._ceg .Margins =_fcaec ._baa ;};func (_cg *Block )setOpacity (_dc float64 ,_gde float64 )(string ,error ){if (_dc < 0||_dc >=1.0)&&(_gde < 0||_gde >=1.0){return "",nil ;};_bg :=0;_cef :=_ba .Sprintf ("\u0047\u0053\u0025\u0064",_bg );for _cg ._cb .HasExtGState (_fg .PdfObjectName (_cef )){_bg ++;_cef =_ba .Sprintf ("\u0047\u0053\u0025\u0064",_bg );};_abg :=_fg .MakeDict ();if _dc >=0&&_dc < 1.0{_abg .Set ("\u0063\u0061",_fg .MakeFloat (_dc ));};if _gde >=0&&_gde < 1.0{_abg .Set ("\u0043\u0041",_fg .MakeFloat (_gde ));};_beg :=_cg ._cb .AddExtGState (_fg .PdfObjectName (_cef ),_abg );if _beg !=nil {return "",_beg ;};return _cef ,nil ;};

// Text sets the text content of the Paragraph.
func (_decd *Paragraph )Text ()string {return _decd ._cfcb };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_fcbg *TOC )SetLinePageStyle (style TextStyle ){_fcbg ._bdbc =style };

// SetMargins sets the margins TOC line.
func (_dada *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_dada ._dbfeg =left ;_cged :=&_dada ._ggfe ._gbc ;_cged ._dca =_dada ._dbfeg +float64 (_dada ._ccgbg -1)*_dada ._agcfb ;_cged ._ffe =right ;_cged ._dcgbd =top ;_cged ._fbf =bottom ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// NewPageBreak create a new page break.
func (_dfea *Creator )NewPageBreak ()*PageBreak {return _bgecb ()};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_fddb *Invoice )Sections ()[][2]string {return _fddb ._ddbf };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aaa *Creator )NewStyledParagraph ()*StyledParagraph {return _cagb (_aaa .NewTextStyle ())};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_cfcb string ;_deag *_ce .PdfFont ;_feccg float64 ;_gfga float64 ;_beeb _ce .PdfColorDeviceRGB ;_dacc TextAlignment ;_ebbd bool ;_deff float64 ;_cfeg int ;_egaf bool ;_bcab float64 ;_dagf margins ;_bcefb positioning ;_afc float64 ;_gcfc float64 ;_ecbc ,_gdagd float64 ;_gdab []string ;};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_fbce []VectorDrawable ;_ffac positioning ;_ddgc margins ;_afg bool ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_ddce *StyledParagraph )Insert (index uint ,text string )*TextChunk {_dddcbf :=uint (len (_ddce ._ebcb ));if index > _dddcbf {index =_dddcbf ;};_fbfde :=NewTextChunk (text ,_ddce ._geb );_ddce ._ebcb =append (_ddce ._ebcb [:index ],append ([]*TextChunk {_fbfde },_ddce ._ebcb [index :]...)...);_ddce .wrapText ();return _fbfde ;};type rgbColor struct{_eeb ,_cdbf ,_edcc float64 };func _aeae ()*Division {return &Division {_fbce :[]VectorDrawable {}}};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_dded *Creator )SetPageLabels (pageLabels _fg .PdfObject ){_dded ._dabd =pageLabels };type positioning int ;

// SetColorLeft sets border color for left.
func (_bcedcb *border )SetColorLeft (col Color ){_bcedcb ._ecc =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetColorRight sets border color for right.
func (_eacc *border )SetColorRight (col Color ){_eacc ._acc =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_bade *Image )ConvertToBinary ()error {return _bade ._gdfc .ConvertToBinary ()};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_aebd *List )Add (item VectorDrawable )(*TextChunk ,error ){_ecce :=&listItem {_adba :item ,_abe :_aebd ._bgbe };switch _gdae :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _gdae ._gdfa {_gdae ._ceaf =15;};default:return nil ,_a .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_aebd ._cafd =append (_aebd ._cafd ,_ecce );return &_ecce ._abe ,nil ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_eeac *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eddcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ecae ,_aecf :=_eddcg .setOpacity (_eeac ._bedag ,_eeac ._bedag );if _aecf !=nil {return nil ,ctx ,_aecf ;};_aadd :=_eeac ._bbfe .Points ;for _cddb :=range _aadd {_ccdbg :=&_aadd [_cddb ];_ccdbg .Y =ctx .PageHeight -_ccdbg .Y ;};_efge ,_ ,_aecf :=_eeac ._bbfe .Draw (_ecae );if _aecf !=nil {return nil ,ctx ,_aecf ;};if _aecf =_eddcg .addContentsByString (string (_efge ));_aecf !=nil {return nil ,ctx ,_aecf ;};return []*Block {_eddcg },ctx ,nil ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetLineColor sets the line color.
func (_agaf *Polyline )SetLineColor (color Color ){_agaf ._bbfe .LineColor =_ce .NewPdfColorDeviceRGB (color .ToRGB ());};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_fdfb *Image )SetWidth (w float64 ){_fdfb ._gefe =w };

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_cee *Chapter )GetHeading ()*Paragraph {return _cee ._ebb };

// Rows returns the total number of rows the table has.
func (_fgdc *Table )Rows ()int {return _fgdc ._fadae };

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_bgb *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fef :=_cf .NewContentCreator ();_gdg ,_ceaa :=_bgb .Width (),_bgb .Height ();if _bgb ._gg .isRelative (){_fef .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_ceaa );}else {_fef .Translate (_bgb ._cea ,ctx .PageHeight -_bgb ._bee -_ceaa );};_dfb :=_ceaa ;if _bgb ._de !=0{_fef .Translate (_gdg /2,_ceaa /2);_fef .RotateDeg (_bgb ._de );_fef .Translate (-_gdg /2,-_ceaa /2);_ ,_dfb =_bgb .RotatedSize ();};if _bgb ._gg .isRelative (){ctx .Y +=_dfb ;};_ff :=_bgb .duplicate ();_cbc :=append (*_fef .Operations (),*_ff ._fgb ...);_cbc .WrapIfNeeded ();_ff ._fgb =&_cbc ;return []*Block {_ff },ctx ,nil ;};

// SetBorderOpacity sets the border opacity.
func (_cefe *Rectangle )SetBorderOpacity (opacity float64 ){_cefe ._cdbg =opacity };func (_beda *Paragraph )wrapText ()error {if !_beda ._ebbd ||int (_beda ._deff )<=0{_beda ._gdab =[]string {_beda ._cfcb };return nil ;};_gefb :=NewTextChunk (_beda ._cfcb ,TextStyle {Font :_beda ._deag ,FontSize :_beda ._feccg });_add ,_ddfea :=_gefb .Wrap (_beda ._deff );if _ddfea !=nil {return _ddfea ;};if _beda ._cfeg > 0&&len (_add )> _beda ._cfeg {_add =_add [:_beda ._cfeg ];};_beda ._gdab =_add ;return nil ;};

// SetBorderColor sets the border color for the path.
func (_aadg *FilledCurve )SetBorderColor (color Color ){_aadg ._gdfe =_ce .NewPdfColorDeviceRGB (color .ToRGB ());};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_df :=&Block {};_df ._fgb =&_cf .ContentStreamOperations {};_df ._cb =_ce .NewPdfPageResources ();_df ._e =width ;_df ._ae =height ;return _df ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ccgb *_ce .PdfColorDeviceRGB ;_cgee _gd .LineStyle ;_fgef CellBorderStyle ;_dbbcg *_ce .PdfColorDeviceRGB ;_acab float64 ;_dgag CellBorderStyle ;_dabfe *_ce .PdfColorDeviceRGB ;_bbge float64 ;_gfcd CellBorderStyle ;_fgba *_ce .PdfColorDeviceRGB ;_cgbe float64 ;_gbfc CellBorderStyle ;_fcfg *_ce .PdfColorDeviceRGB ;_gaeef float64 ;_ggab ,_effc int ;_gcfb int ;_acgee int ;_fbg VectorDrawable ;_bgda CellHorizontalAlignment ;_fbcec CellVerticalAlignment ;_fdefd float64 ;_gabdd *Table ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_fcbd *Invoice )NoteHeadingStyle ()TextStyle {return _fcbd ._adbg };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_gdfd *Invoice )NoteStyle ()TextStyle {return _gdfd ._gdee };

// Heading returns the heading component of the table of contents.
func (_edff *TOC )Heading ()*StyledParagraph {return _edff ._bfec };

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_affc *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aaef :=_gd .Line {LineWidth :_affc ._dbfd ,Opacity :1.0,LineColor :_affc ._gdac ,LineEndingStyle1 :_gd .LineEndingStyleNone ,LineEndingStyle2 :_gd .LineEndingStyleNone ,X1 :_affc ._gcdf ,Y1 :ctx .PageHeight -_affc ._cbge ,X2 :_affc ._ecgg ,Y2 :ctx .PageHeight -_affc ._dgea };_ddba ,_ ,_ageee :=_aaef .Draw ("");if _ageee !=nil {return nil ,ctx ,_ageee ;};_ageee =_faaa .addContentsByString (string (_ddba ));if _ageee !=nil {return nil ,ctx ,_ageee ;};return []*Block {_faaa },ctx ,nil ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_afdf *Creator )NewTextStyle ()TextStyle {return _dgfeg (_afdf ._ggda )};

// WriteToFile writes the Creator output to file specified by path.
func (_babf *Creator )WriteToFile (outputPath string )error {_bbbc ,_fgafc :=_b .Create (outputPath );if _fgafc !=nil {return _fgafc ;};defer _bbbc .Close ();return _babf .Write (_bbbc );};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_bfcb *Paragraph )SetWidth (width float64 ){_bfcb ._deff =width ;_bfcb .wrapText ()};

// Inline returns whether the inline mode of the division is active.
func (_gef *Division )Inline ()bool {return _gef ._afg };

// BuyerAddress returns the buyer address used in the invoice template.
func (_cfbaf *Invoice )BuyerAddress ()*InvoiceAddress {return _cfbaf ._ecef };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aaee *Paragraph )SetTextAlignment (align TextAlignment ){_aaee ._dacc =align };

// SetBorder sets the cell's border style.
func (_cbbc *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_cbbc ._fgef =CellBorderStyleSingle ;_cbbc ._acab =width ;_cbbc ._dgag =CellBorderStyleSingle ;_cbbc ._bbge =width ;_cbbc ._gfcd =CellBorderStyleSingle ;_cbbc ._cgbe =width ;_cbbc ._gbfc =CellBorderStyleSingle ;_cbbc ._gaeef =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_cbbc ._fgef =CellBorderStyleDouble ;_cbbc ._acab =width ;_cbbc ._dgag =CellBorderStyleDouble ;_cbbc ._bbge =width ;_cbbc ._gfcd =CellBorderStyleDouble ;_cbbc ._cgbe =width ;_cbbc ._gbfc =CellBorderStyleDouble ;_cbbc ._gaeef =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_cbbc ._fgef =style ;_cbbc ._acab =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_cbbc ._dgag =style ;_cbbc ._bbge =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_cbbc ._gfcd =style ;_cbbc ._cgbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_cbbc ._gbfc =style ;_cbbc ._gaeef =width ;};};

// SetStyleBottom sets border style for bottom side.
func (_gdgd *border )SetStyleBottom (style CellBorderStyle ){_gdgd ._dcge =style };func _ddda (_bfde *Block ,_gaag *Paragraph ,_aabc DrawContext )(DrawContext ,error ){_ebac :=1;_bedab :=_fg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gf .Itoa (_ebac ));for _bfde ._cb .HasFontByName (_bedab ){_ebac ++;_bedab =_fg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gf .Itoa (_ebac ));};_fbeff :=_bfde ._cb .SetFontByName (_bedab ,_gaag ._deag .ToPdfObject ());if _fbeff !=nil {return _aabc ,_fbeff ;};_gaag .wrapText ();_adbf :=_cf .NewContentCreator ();_adbf .Add_q ();_debea :=_aabc .PageHeight -_aabc .Y -_gaag ._feccg *_gaag ._gfga ;_adbf .Translate (_aabc .X ,_debea );if _gaag ._bcab !=0{_adbf .RotateDeg (_gaag ._bcab );};_adbf .Add_BT ().Add_rg (_gaag ._beeb .R (),_gaag ._beeb .G (),_gaag ._beeb .B ()).Add_Tf (_bedab ,_gaag ._feccg ).Add_TL (_gaag ._feccg *_gaag ._gfga );for _gdbdg ,_cdafa :=range _gaag ._gdab {if _gdbdg !=0{_adbf .Add_Tstar ();};_bgbee :=[]rune (_cdafa );_aaeb :=0.0;_bdcc :=0;for _abcd ,_gcdfg :=range _bgbee {if _gcdfg ==' '{_bdcc ++;continue ;};if _gcdfg =='\u000A'{continue ;};_eaccc ,_gbgg :=_gaag ._deag .GetRuneMetrics (_gcdfg );if !_gbgg {_af .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_abcd ,_gcdfg ,_gcdfg ,_gaag ._deag .BaseFont (),_gaag ._deag .Subtype ());return _aabc ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_aaeb +=_gaag ._feccg *_eaccc .Wx ;};var _fcfb []_fg .PdfObject ;_gbaa ,_dddg :=_gaag ._deag .GetRuneMetrics (' ');if !_dddg {return _aabc ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_gfefc :=_gbaa .Wx ;switch _gaag ._dacc {case TextAlignmentJustify :if _bdcc > 0&&_gdbdg < len (_gaag ._gdab )-1{_gfefc =(_gaag ._deff *1000.0-_aaeb )/float64 (_bdcc )/_gaag ._feccg ;};case TextAlignmentCenter :_bcae :=_aaeb +float64 (_bdcc )*_gfefc *_gaag ._feccg ;_ddbd :=(_gaag ._deff *1000.0-_bcae )/2/_gaag ._feccg ;_fcfb =append (_fcfb ,_fg .MakeFloat (-_ddbd ));case TextAlignmentRight :_aeca :=_aaeb +float64 (_bdcc )*_gfefc *_gaag ._feccg ;_gabd :=(_gaag ._deff *1000.0-_aeca )/_gaag ._feccg ;_fcfb =append (_fcfb ,_fg .MakeFloat (-_gabd ));};_cedg :=_gaag ._deag .Encoder ();var _ddegc []byte ;for _ ,_cgae :=range _bgbee {if _cgae =='\u000A'{continue ;};if _cgae ==' '{if len (_ddegc )> 0{_fcfb =append (_fcfb ,_fg .MakeStringFromBytes (_ddegc ));_ddegc =nil ;};_fcfb =append (_fcfb ,_fg .MakeFloat (-_gfefc ));}else {if _ ,_aede :=_cedg .RuneToCharcode (_cgae );!_aede {_af .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cgae ,_cgae );continue ;};_ddegc =append (_ddegc ,_cedg .Encode (string (_cgae ))...);};};if len (_ddegc )> 0{_fcfb =append (_fcfb ,_fg .MakeStringFromBytes (_ddegc ));};_adbf .Add_TJ (_fcfb ...);};_adbf .Add_ET ();_adbf .Add_Q ();_gcgdf :=_adbf .Operations ();_gcgdf .WrapIfNeeded ();_bfde .addContents (_gcgdf );if _gaag ._bcefb .isRelative (){_gega :=_gaag .Height ()+_gaag ._dagf ._fbf ;_aabc .Y +=_gega ;_aabc .Height -=_gega ;if _aabc .Inline {_aabc .X +=_gaag .Width ()+_gaag ._dagf ._ffe ;};};return _aabc ,nil ;};

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_f .Max (_f .Min (r ,1.0),0.0);g =_f .Max (_f .Min (g ,1.0),0.0);b =_f .Max (_f .Min (b ,1.0),0.0);_gfef :=rgbColor {};_gfef ._eeb =r ;_gfef ._cdbf =g ;_gfef ._edcc =b ;return _gfef ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_gcffc *Table )Width ()float64 {return 0};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_acdb *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _cbed []*Block ;_fagb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_edcg :=ctx ;if _acdb ._fegc .isAbsolute (){ctx .X =_acdb ._afcc ;ctx .Y =_acdb ._decg ;}else {ctx .X +=_acdb ._cacab ._dca ;ctx .Y +=_acdb ._cacab ._dcgbd ;ctx .Width -=_acdb ._cacab ._dca +_acdb ._cacab ._ffe ;ctx .Height -=_acdb ._cacab ._fbf +_acdb ._cacab ._dcgbd ;};_cbgde :=ctx .Width ;_ebge :=ctx .X ;_adgg :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._fbf ;_dceaf :=ctx .Height ;_gcba :=0;_cgbg :=-1;_befe :=-1;for _babgc ,_cbea :=range _acdb ._gfeg {_gdcc :=float64 (0.0);for _badba :=0;_badba < _cbea ._acgee ;_badba ++{_gdcc +=_acdb ._gggbc [_cbea ._effc +_badba -1];};_gddf :=float64 (0.0);for _aecb :=0;_aecb < _cbea ._effc -1;_aecb ++{_gddf +=_acdb ._gggbc [_aecb ]*_cbgde ;};_bbeg :=float64 (0.0);for _cbbaaa :=_gcba ;_cbbaaa < _cbea ._ggab -1;_cbbaaa ++{_bbeg +=_acdb ._effbc [_cbbaaa ];};_aggf :=_gdcc *_cbgde ;_eggce :=float64 (0.0);for _bgfcg :=0;_bgfcg < _cbea ._gcfb ;_bgfcg ++{_eggce +=_acdb ._effbc [_cbea ._ggab +_bgfcg -1];};if _acdb ._gfefb {if _cbea ._ggab >=_acdb ._gacd &&_cbea ._ggab <=_acdb ._dbbd {if _cgbg < 0{_cgbg =_babgc ;};_befe =_babgc ;};};switch _cecea :=_cbea ._fbg .(type ){case *Paragraph :_fece :=_cecea ;if _fece ._ebbd {_fece .SetWidth (_aggf -_cbea ._fdefd );};_fcdb :=_fece .Height ()+_fece ._dagf ._fbf +_fece ._dagf ._fbf ;_fcdb +=0.5*_fece ._feccg *_fece ._gfga ;if _fcdb > _eggce {_cadaa :=_fcdb -_eggce ;_acdb ._effbc [_cbea ._ggab +_cbea ._gcfb -2]+=_cadaa ;};case *StyledParagraph :_afcg :=_cecea ;if _afcg ._edgb {_afcg .SetWidth (_aggf -_cbea ._fdefd );};_cecc :=_afcg .Height ()+_afcg ._gbc ._dcgbd +_afcg ._gbc ._fbf ;_cecc +=0.5*_afcg .getTextHeight ();if _cecc > _eggce {_cdgbb :=_cecc -_eggce ;_acdb ._effbc [_cbea ._ggab +_cbea ._gcfb -2]+=_cdgbb ;};case *Image :_ebbfe :=_cecea ;_cabbe :=_ebbfe .Height ()+_ebbfe ._cfba ._dcgbd +_ebbfe ._cfba ._fbf ;if _cabbe > _eggce {_gcecc :=_cabbe -_eggce ;_acdb ._effbc [_cbea ._ggab +_cbea ._gcfb -2]+=_gcecc ;};case *Table :_adfd :=_cecea ;_dafa :=_adfd .Height ()+_adfd ._cacab ._dcgbd +_adfd ._cacab ._fbf ;if _dafa > _eggce {_abda :=_dafa -_eggce ;_acdb ._effbc [_cbea ._ggab +_cbea ._gcfb -2]+=_abda ;};case *List :_cfde :=_cecea ;_ebfc :=_cfde .tableHeight (_aggf -_cbea ._fdefd )+_cfde ._bgff ._dcgbd +_cfde ._bgff ._fbf ;if _ebfc > _eggce {_feab :=_ebfc -_eggce ;_acdb ._effbc [_cbea ._ggab +_cbea ._gcfb -2]+=_feab ;};case *Division :_fdbgg :=_cecea ;_aeccad :=ctx ;_aeccad .X =_gddf ;_aeccad .Y =_bbeg ;_aeccad .Width =_aggf ;_ccage ,_ ,_gcbf :=_fdbgg .GeneratePageBlocks (_aeccad );if _gcbf !=nil {return nil ,ctx ,_gcbf ;};if len (_ccage )> 1{_gagga :=_aeccad .Height -_eggce ;if _gagga > _eggce {_fgdb :=_gagga -_eggce ;_acdb ._effbc [_cbea ._ggab +_cbea ._gcfb -2]+=_fgdb ;};};_fbdgd :=_fdbgg .Height ()+_fdbgg ._ddgc ._dcgbd +_fdbgg ._ddgc ._fbf ;if _fbdgd > _eggce {_baee :=_fbdgd -_eggce ;_acdb ._effbc [_cbea ._ggab +_cbea ._gcfb -2]+=_baee ;};};};var _gfec bool ;var _fbebc ,_begg int ;for _gcgg :=0;_gcgg < len (_acdb ._gfeg );_gcgg ++{_cgade :=_acdb ._gfeg [_gcgg ];_bdgb :=float64 (0.0);for _gbfgd :=0;_gbfgd < _cgade ._acgee ;_gbfgd ++{_bdgb +=_acdb ._gggbc [_cgade ._effc +_gbfgd -1];};_aeafg :=float64 (0.0);for _edce :=0;_edce < _cgade ._effc -1;_edce ++{_aeafg +=_acdb ._gggbc [_edce ]*_cbgde ;};_ddeca :=float64 (0.0);for _cege :=_gcba ;_cege < _cgade ._ggab -1;_cege ++{_ddeca +=_acdb ._effbc [_cege ];};_bgef :=_bdgb *_cbgde ;_afgbc :=float64 (0.0);for _gdbad :=0;_gdbad < _cgade ._gcfb ;_gdbad ++{_afgbc +=_acdb ._effbc [_cgade ._ggab +_gdbad -1];};ctx .Height =_dceaf -_ddeca ;if _afgbc > ctx .Height {_cbed =append (_cbed ,_fagb );_fagb =NewBlock (ctx .PageWidth ,ctx .PageHeight );_ebge =ctx .Margins ._dca ;_adgg =ctx .Margins ._dcgbd ;ctx .Height =ctx .PageHeight -ctx .Margins ._dcgbd -ctx .Margins ._fbf ;ctx .Page ++;_dceaf =ctx .Height ;_gcba =_cgade ._ggab -1;_ddeca =0;if _acdb ._gfefb &&_cgbg >=0{_fbebc =_gcgg ;_gcgg =_cgbg -1;_begg =_gcba ;_gcba =_acdb ._gacd -1;_gfec =true ;continue ;};};ctx .Width =_bgef ;ctx .X =_ebge +_aeafg ;ctx .Y =_adgg +_ddeca ;_ebbef :=_bbg (ctx .X ,ctx .Y ,_bgef ,_afgbc );if _cgade ._ccgb !=nil {_bcdd :=_cgade ._ccgb .R ();_bgcf :=_cgade ._ccgb .G ();_ddbae :=_cgade ._ccgb .B ();_ebbef .SetFillColor (ColorRGBFromArithmetic (_bcdd ,_bgcf ,_ddbae ));};_ebbef .LineStyle =_cgade ._cgee ;_ebbef ._afee =_cgade ._fgef ;_ebbef ._ded =_cgade ._gfcd ;_ebbef ._bff =_cgade ._gbfc ;_ebbef ._dcge =_cgade ._dgag ;if _cgade ._dbbcg !=nil {_ebbef .SetColorLeft (ColorRGBFromArithmetic (_cgade ._dbbcg .R (),_cgade ._dbbcg .G (),_cgade ._dbbcg .B ()));};if _cgade ._dabfe !=nil {_ebbef .SetColorBottom (ColorRGBFromArithmetic (_cgade ._dabfe .R (),_cgade ._dabfe .G (),_cgade ._dabfe .B ()));};if _cgade ._fgba !=nil {_ebbef .SetColorRight (ColorRGBFromArithmetic (_cgade ._fgba .R (),_cgade ._fgba .G (),_cgade ._fgba .B ()));};if _cgade ._fcfg !=nil {_ebbef .SetColorTop (ColorRGBFromArithmetic (_cgade ._fcfg .R (),_cgade ._fcfg .G (),_cgade ._fcfg .B ()));};_ebbef .SetWidthBottom (_cgade ._bbge );_ebbef .SetWidthLeft (_cgade ._acab );_ebbef .SetWidthRight (_cgade ._cgbe );_ebbef .SetWidthTop (_cgade ._gaeef );_baeee :=_fagb .Draw (_ebbef );if _baeee !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_baeee );};if _cgade ._fbg !=nil {_efgec :=_cgade ._fbg .Width ();_ddfbd :=_cgade ._fbg .Height ();_adcg :=0.0;switch _dfcd :=_cgade ._fbg .(type ){case *Paragraph :if _dfcd ._ebbd {_efgec =_dfcd .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _dfcd ._edgb {_efgec =_dfcd .getMaxLineWidth ()/1000.0;};_fbab ,_cedc :=_dfcd .getLineHeight (0);if len (_dfcd ._fgde )==1{_ddfbd =_fbab ;}else {_ddfbd =_ddfbd -_cedc +_fbab ;};_adcg =_fbab -_cedc ;switch _cgade ._fbcec {case CellVerticalAlignmentTop :_adcg +=_fbab *0.5;case CellVerticalAlignmentBottom :_adcg -=_fbab *0.5;};case *Table :_efgec =_bgef ;case *List :_efgec =_bgef ;};switch _cgade ._bgda {case CellHorizontalAlignmentLeft :ctx .X +=_cgade ._fdefd ;ctx .Width -=_cgade ._fdefd ;case CellHorizontalAlignmentCenter :_ggee :=_bgef -_efgec ;if _ggee > 0{ctx .X +=_ggee /2;ctx .Width -=_ggee /2;};case CellHorizontalAlignmentRight :if _bgef > _efgec {ctx .X =ctx .X +_bgef -_efgec -_cgade ._fdefd ;ctx .Width -=_cgade ._fdefd ;};};ctx .Y +=_adcg ;switch _cgade ._fbcec {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_beaa :=_afgbc -_ddfbd ;if _beaa > 0{ctx .Y +=_beaa /2;ctx .Height -=_beaa /2;};case CellVerticalAlignmentBottom :if _afgbc > _ddfbd {ctx .Y =ctx .Y +_afgbc -_ddfbd ;ctx .Height =_afgbc ;};};_bagf :=_fagb .DrawWithContext (_cgade ._fbg ,ctx );if _bagf !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bagf );};ctx .Y -=_adcg ;};ctx .Y +=_afgbc ;ctx .Height -=_afgbc ;if _gfec &&_gcgg +1> _befe {_adgg +=_ddeca +_afgbc ;_dceaf -=_afgbc +_ddeca ;_gcba =_begg ;_gcgg =_fbebc -1;_gfec =false ;};};_cbed =append (_cbed ,_fagb );if _acdb ._fegc .isAbsolute (){return _cbed ,_edcg ,nil ;};ctx .X =_edcg .X ;ctx .Width =_edcg .Width ;ctx .Y +=_acdb ._cacab ._fbf ;ctx .Height -=_acdb ._cacab ._fbf ;return _cbed ,ctx ,nil ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_cggg DrawContext )([]*Block ,DrawContext ,error );};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_cge *Block )ScaleToHeight (h float64 ){_cbf :=h /_cge ._ae ;_cge .Scale (_cbf ,_cbf )};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_fcdf *Image )SetPos (x ,y float64 ){_fcdf ._cfcd =_efeg ;_fcdf ._bbdf =x ;_fcdf ._ccag =y };type listItem struct{_adba VectorDrawable ;_abe TextChunk ;};func (_bfeg *Invoice )setCellBorder (_fgfa *TableCell ,_dfcab *InvoiceCell ){for _ ,_fgdf :=range _dfcab .BorderSides {_fgfa .SetBorder (_fgdf ,CellBorderStyleSingle ,_dfcab .BorderWidth );};_fgfa .SetBorderColor (_dfcab .BorderColor );};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dbba *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_efeab :=_cagb (_dbba ._cgad );_efeab .Append (text );_fgcfd ,_aacd :=_dbba .Add (_efeab );return _efeab ,_fgcfd ,_aacd ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_fbca *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_fbca ._cebb {_af .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fbca ._gggbc =widths ;return nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);func (_fcedf *TOCLine )prepareParagraph (_aaeeb *StyledParagraph ,_bgfg DrawContext ){_agbb :=_fcedf .Title .Text ;if _fcedf .Number .Text !=""{_agbb ="\u0020"+_agbb ;};_agbb +="\u0020";_ddee :=_fcedf .Page .Text ;if _ddee !=""{_ddee ="\u0020"+_ddee ;};_aaeeb ._ebcb =[]*TextChunk {{Text :_fcedf .Number .Text ,Style :_fcedf .Number .Style ,_gcbge :_fcedf .getLineLink ()},{Text :_agbb ,Style :_fcedf .Title .Style ,_gcbge :_fcedf .getLineLink ()},{Text :_ddee ,Style :_fcedf .Page .Style ,_gcbge :_fcedf .getLineLink ()}};_aaeeb .wrapText ();_cafgd :=len (_aaeeb ._fgde );if _cafgd ==0{return ;};_ebdfa :=_bgfg .Width *1000-_aaeeb .getTextLineWidth (_aaeeb ._fgde [_cafgd -1]);_egaa :=_aaeeb .getTextLineWidth ([]*TextChunk {&_fcedf .Separator });_egeeb :=int (_ebdfa /_egaa );_ebbefg :=_be .Repeat (_fcedf .Separator .Text ,_egeeb );_cbda :=_fcedf .Separator .Style ;_aedg :=_aaeeb .Insert (2,_ebbefg );_aedg .Style =_cbda ;_aedg ._gcbge =_fcedf .getLineLink ();_ebdfa =_ebdfa -float64 (_egeeb )*_egaa ;if _ebdfa > 500{_cgbfe ,_efgda :=_cbda .Font .GetRuneMetrics (' ');if _efgda &&_ebdfa > _cgbfe .Wx {_ebcg :=int (_ebdfa /_cgbfe .Wx );if _ebcg > 0{_fffgb :=_cbda ;_fffgb .FontSize =1;_aedg =_aaeeb .Insert (2,_be .Repeat ("\u0020",_ebcg ));_aedg .Style =_fffgb ;_aedg ._gcbge =_fcedf .getLineLink ();};};};};func _debed (_gdaf int64 ,_fdbaf ,_dbaa ,_fafg float64 )*_ce .PdfAnnotation {_ddbac :=_ce .NewPdfAnnotationLink ();_ffbd :=_ce .NewBorderStyle ();_ffbd .SetBorderWidth (0);_ddbac .BS =_ffbd .ToPdfObject ();if _gdaf < 0{_gdaf =0;};_ddbac .Dest =_fg .MakeArray (_fg .MakeInteger (_gdaf ),_fg .MakeName ("\u0058\u0059\u005a"),_fg .MakeFloat (_fdbaf ),_fg .MakeFloat (_dbaa ),_fg .MakeFloat (_fafg ));return _ddbac .PdfAnnotation ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_cfd *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_cfd ._ebbe ._dca =left ;_cfd ._ebbe ._ffe =right ;_cfd ._ebbe ._dcgbd =top ;_cfd ._ebbe ._fbf =bottom ;};

// SkipOver skips over a specified number of rows and cols.
func (_ggbae *Table )SkipOver (rows ,cols int ){_abdgg :=rows *_ggbae ._cebb +cols -1;if _abdgg < 0{_af .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ggbae ._eede +=_abdgg ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_ccde *Creator )NewImageFromGoImage (goimg _g .Image )(*Image ,error ){return _egec (goimg )};func _ccgg (_dbbe []_gd .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_bbda :&_gd .PolyBezierCurve {Curves :_dbbe ,BorderColor :_ce .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_ddfb :1.0,_facbb :1.0};};func (_aebc *Invoice )generateTotalBlocks (_bcaae DrawContext )([]*Block ,DrawContext ,error ){_fefd :=_baga (4);_fefd .SetMargins (0,0,10,10);_cdcc :=[][2]*InvoiceCell {_aebc ._bcd };_cdcc =append (_cdcc ,_aebc ._cfab ...);_cdcc =append (_cdcc ,_aebc ._ccfd );for _ ,_fdbg :=range _cdcc {_fffag ,_afeb :=_fdbg [0],_fdbg [1];if _afeb .Value ==""{continue ;};_fefd .SkipCells (2);_ccaa :=_fefd .NewCell ();_ccaa .SetBackgroundColor (_fffag .BackgroundColor );_ccaa .SetHorizontalAlignment (_afeb .Alignment );_aebc .setCellBorder (_ccaa ,_fffag );_cgbce :=_cagb (_fffag .TextStyle );_cgbce .SetMargins (0,0,2,1);_cgbce .Append (_fffag .Value );_ccaa .SetContent (_cgbce );_ccaa =_fefd .NewCell ();_ccaa .SetBackgroundColor (_afeb .BackgroundColor );_ccaa .SetHorizontalAlignment (_afeb .Alignment );_aebc .setCellBorder (_ccaa ,_fffag );_cgbce =_cagb (_afeb .TextStyle );_cgbce .SetMargins (0,0,2,1);_cgbce .Append (_afeb .Value );_ccaa .SetContent (_cgbce );};return _fefd .GeneratePageBlocks (_bcaae );};

// SetFillOpacity sets the fill opacity.
func (_geed *Rectangle )SetFillOpacity (opacity float64 ){_geed ._gbbd =opacity };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_adefd *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_edaaa ,_ddca :=_gbff .setOpacity (_adefd ._ddfb ,_adefd ._facbb );if _ddca !=nil {return nil ,ctx ,_ddca ;};_gdeba :=_adefd ._bbda ;_gdeba .FillEnabled =_gdeba .FillColor !=nil ;_acff :=_gdeba .Curves ;_egcf :=ctx .PageHeight ;for _fcacf :=range _acff {_acac :=&_acff [_fcacf ];_acac .P0 .Y =_egcf -_acac .P0 .Y ;_acac .P1 .Y =_egcf -_acac .P1 .Y ;_acac .P2 .Y =_egcf -_acac .P2 .Y ;_acac .P3 .Y =_egcf -_acac .P3 .Y ;};_bcead ,_ ,_ddca :=_gdeba .Draw (_edaaa );if _ddca !=nil {return nil ,ctx ,_ddca ;};if _ddca =_gbff .addContentsByString (string (_bcead ));_ddca !=nil {return nil ,ctx ,_ddca ;};return []*Block {_gbff },ctx ,nil ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_cgfe *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_cgfe ._baa ._dca =left ;_cgfe ._baa ._ffe =right ;_cgfe ._baa ._dcgbd =top ;_cgfe ._baa ._fbf =bottom ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_dfabg *Invoice )Notes ()(string ,string ){return _dfabg ._agfd [0],_dfabg ._agfd [1]};

// AddLine appends a new line to the invoice line items table.
func (_dffa *Invoice )AddLine (values ...string )[]*InvoiceCell {_gdegg :=len (_dffa ._dfeb );var _ggbf []*InvoiceCell ;for _fda ,_cfed :=range values {_gbdc :=_dffa .newCell (_cfed ,_dffa ._ebce );if _fda < _gdegg {_gbdc .Alignment =_dffa ._dfeb [_fda ].Alignment ;};_ggbf =append (_ggbf ,_gbdc );};_dffa ._cdef =append (_dffa ._cdef ,_ggbf );return _ggbf ;};

// SetColorBottom sets border color for bottom.
func (_ddeg *border )SetColorBottom (col Color ){_ddeg ._cag =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetEnableWrap sets the line wrapping enabled flag.
func (_eddf *StyledParagraph )SetEnableWrap (enableWrap bool ){_eddf ._edgb =enableWrap ;_eddf ._ebee =false ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_eeff float64 ;_dddcb float64 ;_ffee float64 ;_gbac float64 ;_dgefa *_ce .PdfColorDeviceRGB ;_gbbd float64 ;_aefe *_ce .PdfColorDeviceRGB ;_gefg float64 ;_cdbg float64 ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_badc *TOCLine )SetStyle (style TextStyle ){_badc .Number .Style =style ;_badc .Title .Style =style ;_badc .Separator .Style =style ;_badc .Page .Style =style ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// SetMargins sets the Table's left, right, top, bottom margins.
func (_facf *Table )SetMargins (left ,right ,top ,bottom float64 ){_facf ._cacab ._dca =left ;_facf ._cacab ._ffe =right ;_facf ._cacab ._dcgbd =top ;_facf ._cacab ._fbf =bottom ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_agd *Creator )SetPageSize (size PageSize ){_agd ._gcec =size ;_agd ._acge =size [0];_agd ._ceed =size [1];_ffec :=0.1*_agd ._acge ;_agd ._baa ._dca =_ffec ;_agd ._baa ._ffe =_ffec ;_agd ._baa ._dcgbd =_ffec ;_agd ._baa ._fbf =_ffec ;};func (_aebb *Invoice )newColumn (_becf string ,_cbgd CellHorizontalAlignment )*InvoiceCell {_eggg :=&InvoiceCell {_aebb ._fdcc ,_becf };_eggg .Alignment =_cbgd ;return _eggg ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_bfec *StyledParagraph ;_aafca []*TOCLine ;_acda TextStyle ;_faff TextStyle ;_efdd TextStyle ;_bdbc TextStyle ;_cdge string ;_efgcc float64 ;_cfgd margins ;_cfgg positioning ;_fedc TextStyle ;_gdgf bool ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_ebed *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_ebed ._gdde =alignment };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_agdd *Invoice )TotalLines ()[][2]*InvoiceCell {_dgbf :=[][2]*InvoiceCell {_agdd ._bcd };_dgbf =append (_dgbf ,_agdd ._cfab ...);return append (_dgbf ,_agdd ._ccfd );};func (_abcgb *Image )rotatedSize ()(float64 ,float64 ){_ddgf :=_abcgb ._gefe ;_efgc :=_abcgb ._gad ;_afec :=_abcgb ._cegb ;if _afec ==0{return _ddgf ,_efgc ;};_beff :=_gd .Path {Points :[]_gd .Point {_gd .NewPoint (0,0).Rotate (_afec ),_gd .NewPoint (_ddgf ,0).Rotate (_afec ),_gd .NewPoint (0,_efgc ).Rotate (_afec ),_gd .NewPoint (_ddgf ,_efgc ).Rotate (_afec )}}.GetBoundingBox ();return _beff .Width ,_beff .Height ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_fgdfd *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_fgdfd ._aafca =append (_fgdfd ._aafca ,line );return line ;};

// SetWidthTop sets border width for top.
func (_ebc *border )SetWidthTop (bw float64 ){_ebc ._dfc =bw };

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_efea *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _efea ._bdfe ==nil {if _gacfe :=_efea .makeXObject ();_gacfe !=nil {return nil ,ctx ,_gacfe ;};};var _fddf []*Block ;_ebf :=ctx ;_fgac :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _efea ._cfcd .isRelative (){if _efea ._gad > ctx .Height {_fddf =append (_fddf ,_fgac );_fgac =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cdeca :=ctx ;_cdeca .Y =ctx .Margins ._dcgbd ;_cdeca .X =ctx .Margins ._dca +_efea ._cfba ._dca ;_cdeca .Height =ctx .PageHeight -ctx .Margins ._dcgbd -ctx .Margins ._fbf -_efea ._cfba ._fbf ;_cdeca .Width =ctx .PageWidth -ctx .Margins ._dca -ctx .Margins ._ffe -_efea ._cfba ._dca -_efea ._cfba ._ffe ;ctx =_cdeca ;}else {ctx .Y +=_efea ._cfba ._dcgbd ;ctx .Height -=_efea ._cfba ._dcgbd +_efea ._cfba ._fbf ;ctx .X +=_efea ._cfba ._dca ;ctx .Width -=_efea ._cfba ._dca +_efea ._cfba ._ffe ;};}else {ctx .X =_efea ._bbdf ;ctx .Y =_efea ._ccag ;};ctx ,_cdgc :=_babga (_fgac ,_efea ,ctx );if _cdgc !=nil {return nil ,ctx ,_cdgc ;};_fddf =append (_fddf ,_fgac );if _efea ._cfcd .isAbsolute (){ctx =_ebf ;}else {ctx .Y +=_efea ._cfba ._fbf ;ctx .Height -=_efea ._cfba ._fbf ;};return _fddf ,ctx ,nil ;};

// Context returns the current drawing context.
func (_bbc *Creator )Context ()DrawContext {return _bbc ._ceg };func (_fdb *Chapter )headingNumber ()string {var _caf string ;if _fdb ._dbd {if _fdb ._cdag !=0{_caf =_gf .Itoa (_fdb ._cdag )+"\u002e";};if _fdb ._eccg !=nil {_ggc :=_fdb ._eccg .headingNumber ();if _ggc !=""{_caf =_ggc +_caf ;};};};return _caf ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dda *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _dda ._bfcd [0],_dda ._bfcd [1]};

// SetAngle sets the rotation angle of the text.
func (_gdeb *Paragraph )SetAngle (angle float64 ){_gdeb ._bcab =angle };

// CreateFrontPage sets a function to generate a front Page.
func (_bdb *Creator )CreateFrontPage (genFrontPageFunc func (_bgf FrontpageFunctionArgs )){_bdb ._eeec =genFrontPageFunc ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_bce *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bce ._abb ._dca ,_bce ._abb ._ffe ,_bce ._abb ._dcgbd ,_bce ._abb ._fbf ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_fgge *TOCLine )LevelOffset ()float64 {return _fgge ._agcfb };func _fdg (_dcef string )(*Image ,error ){_edaa ,_baed :=_b .Open (_dcef );if _baed !=nil {return nil ,_baed ;};defer _edaa .Close ();_ebag ,_baed :=_ce .ImageHandling .Read (_edaa );if _baed !=nil {_af .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_baed );return nil ,_baed ;};return _begbe (_ebag );};

// GetRowHeight returns the height of the specified row.
func (_gbec *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_gbec ._effbc ){return 0,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _gbec ._effbc [row -1],nil ;};

// SetBorderColor sets the border color.
func (_cgff *PolyBezierCurve )SetBorderColor (color Color ){_cgff ._bbda .BorderColor =_ce .NewPdfColorDeviceRGB (color .ToRGB ());};func _daaa (_efeff [][]_gd .Point )*Polygon {return &Polygon {_dfge :&_gd .Polygon {Points :_efeff },_acgc :1.0,_aecaf :1.0};};

// NewTOCLine creates a new table of contents line with the default style.
func (_agcc *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _ccab (number ,title ,page ,level ,_agcc .NewTextStyle ());};

// NewImageFromData creates an Image from image data.
func (_gbga *Creator )NewImageFromData (data []byte )(*Image ,error ){return _gfgc (data )};

// SetSubtotal sets the subtotal of the invoice.
func (_facd *Invoice )SetSubtotal (value string ){_facd ._bcd [1].Value =value };

// Add adds a new Drawable to the chapter.
func (_dcgb *Chapter )Add (d Drawable )error {if Drawable (_dcgb )==d {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_dcgb ._gge =append (_dcgb ._gge ,d );default:_af .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _a .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_acea *Creator )NewPolyBezierCurve (curves []_gd .CubicBezierCurve )*PolyBezierCurve {return _ccgg (curves );};

// SetIndent sets the cell's left indent.
func (_fgff *TableCell )SetIndent (indent float64 ){_fgff ._fdefd =indent };

// Angle returns the block rotation angle in degrees.
func (_cdd *Block )Angle ()float64 {return _cdd ._de };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_acef *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfeag :=ctx ;var _fdfbg []*Block ;_dgec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _acef ._cfbd .isRelative (){ctx .X +=_acef ._gbc ._dca ;ctx .Y +=_acef ._gbc ._dcgbd ;ctx .Width -=_acef ._gbc ._dca +_acef ._gbc ._ffe ;ctx .Height -=_acef ._gbc ._dcgbd +_acef ._gbc ._fbf ;_acef .SetWidth (ctx .Width );}else {if int (_acef ._aag )<=0{_acef .SetWidth (_acef .getTextWidth ());};ctx .X =_acef ._abfa ;ctx .Y =_acef ._cdccc ;};if _acef ._cbdd !=nil {_acef ._cbdd (_acef ,ctx );};if _efgce :=_acef .wrapText ();_efgce !=nil {return nil ,ctx ,_efgce ;};_fag :=_acef ._fgde ;for {_gdcb ,_ebcfb ,_bacd :=_eaee (_dgec ,_acef ,_fag ,ctx );if _bacd !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bacd );return nil ,ctx ,_bacd ;};ctx =_gdcb ;_fdfbg =append (_fdfbg ,_dgec );if _fag =_ebcfb ;len (_ebcfb )==0{break ;};_dgec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gdcb =ctx ;_gdcb .Y =ctx .Margins ._dcgbd ;_gdcb .X =ctx .Margins ._dca +_acef ._gbc ._dca ;_gdcb .Height =ctx .PageHeight -ctx .Margins ._dcgbd -ctx .Margins ._fbf -_acef ._gbc ._fbf ;_gdcb .Width =ctx .PageWidth -ctx .Margins ._dca -ctx .Margins ._ffe -_acef ._gbc ._dca -_acef ._gbc ._ffe ;ctx =_gdcb ;};if _acef ._cfbd .isRelative (){ctx .X -=_acef ._gbc ._dca ;ctx .Width =_cfeag .Width ;return _fdfbg ,ctx ,nil ;};return _fdfbg ,_cfeag ,nil ;};func (_eeg *Creator )setActivePage (_afbd *_ce .PdfPage ){_eeg ._dgd =_afbd };

// SetFillColor sets the fill color for the path.
func (_agb *FilledCurve )SetFillColor (color Color ){_agb ._eegb =_ce .NewPdfColorDeviceRGB (color .ToRGB ());};

// NewFilledCurve returns a instance of filled curve.
func (_dcaa *Creator )NewFilledCurve ()*FilledCurve {return _aadb ()};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_gbfe *StyledParagraph )Height ()float64 {_gbfe .wrapText ();var _gfde float64 ;for _ ,_fbecb :=range _gbfe ._fgde {var _gddea float64 ;for _ ,_gcfdb :=range _fbecb {_dfdg :=_gbfe ._eefc *_gcfdb .Style .FontSize ;if _dfdg > _gddea {_gddea =_dfdg ;};};_gfde +=_gddea ;};return _gfde ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cfea *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _cfea ._bcd [0],_cfea ._bcd [1]};func (_bgbf *StyledParagraph )getMaxLineWidth ()float64 {if _bgbf ._fgde ==nil ||len (_bgbf ._fgde )==0{_bgbf .wrapText ();};var _eagg float64 ;for _ ,_gae :=range _bgbf ._fgde {_dddf :=_bgbf .getTextLineWidth (_gae );if _dddf > _eagg {_eagg =_dddf ;};};return _eagg ;};

// MoveY moves the drawing context to absolute position y.
func (_gfb *Creator )MoveY (y float64 ){_gfb ._ceg .Y =y };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_abd *Creator )MoveRight (dx float64 ){_abd ._ceg .X +=dx };

// SetIndent sets the left offset of the list when nested into another list.
func (_gdce *List )SetIndent (indent float64 ){_gdce ._ceaf =indent ;_gdce ._gdfa =false };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_fgae *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bdfb *_ce .PdfWriter )error ){_fgae ._cfa =pdfWriterAccessFunc ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_fgd *Creator )DrawHeader (drawHeaderFunc func (_accc *Block ,_defc HeaderFunctionArgs )){_fgd ._aebef =drawHeaderFunc ;};

// SetPos sets absolute positioning with specified coordinates.
func (_gegg *StyledParagraph )SetPos (x ,y float64 ){_gegg ._cfbd =_efeg ;_gegg ._abfa =x ;_gegg ._cdccc =y ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// NewColumn returns a new column for the line items invoice table.
func (_dbbc *Invoice )NewColumn (description string )*InvoiceCell {return _dbbc .newColumn (description ,CellHorizontalAlignmentLeft );};

// TextAlignment options for paragraph.
type TextAlignment int ;

// GetCoords returns coordinates of border.
func (_fcc *border )GetCoords ()(float64 ,float64 ){return _fcc ._dde ,_fcc ._faab };

// Height returns the height of the list.
func (_afad *List )Height ()float64 {var _ddec float64 ;for _ ,_adf :=range _afad ._cafd {_ddec +=_adf ._adba .Height ();};return _ddec ;};func (_abbdac *StyledParagraph )appendChunk (_bfgb *TextChunk )*TextChunk {_abbdac ._ebcb =append (_abbdac ._ebcb ,_bfgb );_abbdac .wrapText ();return _bfgb ;};

// SetColorTop sets border color for top.
func (_def *border )SetColorTop (col Color ){_def ._fab =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetBackgroundColor sets the cell's background color.
func (_gggbf *TableCell )SetBackgroundColor (col Color ){_gggbf ._ccgb =_ce .NewPdfColorDeviceRGB (col .ToRGB ());};

// NewTOC creates a new table of contents.
func (_aeef *Creator )NewTOC (title string )*TOC {_gdea :=_aeef .NewTextStyle ();_gdea .Font =_aeef ._efb ;return _afab (title ,_aeef .NewTextStyle (),_gdea );};func (_bcee positioning )isAbsolute ()bool {return _bcee ==_efeg };type margins struct{_dca float64 ;_ffe float64 ;_dcgbd float64 ;_fbf float64 ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_dgdf *TOC )SetLineTitleStyle (style TextStyle ){_dgdf ._faff =style };

// SetFillColor sets the fill color.
func (_edab *PolyBezierCurve )SetFillColor (color Color ){_edab ._bbda .FillColor =_ce .NewPdfColorDeviceRGB (color .ToRGB ());};

// NewTable create a new Table with a specified number of columns.
func (_efce *Creator )NewTable (cols int )*Table {return _baga (cols )};

// SetFillOpacity sets the fill opacity.
func (_cced *PolyBezierCurve )SetFillOpacity (opacity float64 ){_cced ._ddfb =opacity };

// Columns returns all the columns in the invoice line items table.
func (_ebfb *Invoice )Columns ()[]*InvoiceCell {return _ebfb ._dfeb };

// GetMargins returns the left, right, top, bottom Margins.
func (_ebbac *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ebbac ._cacab ._dca ,_ebbac ._cacab ._ffe ,_ebbac ._cacab ._dcgbd ,_ebbac ._cacab ._fbf ;};func (_ed *Block )duplicate ()*Block {_cfb :=&Block {};*_cfb =*_ed ;_fca :=_cf .ContentStreamOperations {};for _ ,_acd :=range *_ed ._fgb {_fca =append (_fca ,_acd );};_cfb ._fgb =&_fca ;return _cfb ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_bage *TableCell )SetContent (vd VectorDrawable )error {switch _gcee :=vd .(type ){case *Paragraph :if _gcee ._egaf {_gcee ._ebbd =true ;};_bage ._fbg =vd ;case *StyledParagraph :if _gcee ._ebee {_gcee ._edgb =true ;};_bage ._fbg =vd ;case *Image :_bage ._fbg =vd ;case *Table :_bage ._fbg =vd ;case *List :_bage ._fbg =vd ;case *Division :_bage ._fbg =vd ;default:_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _fg .ErrTypeError ;};return nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_gggf string ;_eaaf *Image ;_ecef *InvoiceAddress ;_gaba *InvoiceAddress ;_ddfe string ;_cdc [2]*InvoiceCell ;_bfcd [2]*InvoiceCell ;_fgfd [2]*InvoiceCell ;_bfb [][2]*InvoiceCell ;_dfeb []*InvoiceCell ;_cdef [][]*InvoiceCell ;_bcd [2]*InvoiceCell ;_ccfd [2]*InvoiceCell ;_cfab [][2]*InvoiceCell ;_agfd [2]string ;_cgde [2]string ;_ddbf [][2]string ;_ggceg TextStyle ;_bde TextStyle ;_bbac TextStyle ;_agdf TextStyle ;_cbaaf TextStyle ;_gdee TextStyle ;_adbg TextStyle ;_ffaab InvoiceCellProps ;_fdcc InvoiceCellProps ;_ebce InvoiceCellProps ;_cabb InvoiceCellProps ;_abbad positioning ;};

// Width returns the current page width.
func (_eadb *Creator )Width ()float64 {return _eadb ._acge };

// SetText replaces all the text of the paragraph with the specified one.
func (_dfgfd *StyledParagraph )SetText (text string )*TextChunk {_dfgfd .Reset ();return _dfgfd .Append (text );};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_agef *Table )SetPos (x ,y float64 ){_agef ._fegc =_efeg ;_agef ._afcc =x ;_agef ._decg =y };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ggcg *Creator )MoveDown (dy float64 ){_ggcg ._ceg .Y +=dy };

// Height returns the current page height.
func (_edgc *Creator )Height ()float64 {return _edgc ._ceed };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_adad *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_fface :=range subtable ._gfeg {_bfcf :=&TableCell {};*_bfcf =*_fface ;_bfcf ._gabdd =_adad ;_bfcf ._effc +=col -1;if _dfcg :=_adad ._cebb -(_bfcf ._effc -1);_dfcg < _bfcf ._acgee {_adad ._cebb +=_bfcf ._acgee -_dfcg ;_adad .resetColumnWidths ();_af .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_adad ._cebb );};_bfcf ._ggab +=row -1;_ddbfd :=subtable ._effbc [_fface ._ggab -1];if _bfcf ._ggab > _adad ._fadae {for _bfcf ._ggab > _adad ._fadae {_adad ._fadae ++;_adad ._effbc =append (_adad ._effbc ,_adad ._ccfda );};_adad ._effbc [_bfcf ._ggab -1]=_ddbfd ;}else {_adad ._effbc [_bfcf ._ggab -1]=_f .Max (_adad ._effbc [_bfcf ._ggab -1],_ddbfd );};_adad ._gfeg =append (_adad ._gfeg ,_bfcf );};_c .Slice (_adad ._gfeg ,func (_gbcg ,_dbca int )bool {_eaaa :=_adad ._gfeg [_gbcg ]._ggab ;_fgfdd :=_adad ._gfeg [_dbca ]._ggab ;if _eaaa < _fgfdd {return true ;};if _eaaa > _fgfdd {return false ;};return _adad ._gfeg [_gbcg ]._effc < _adad ._gfeg [_dbca ]._effc ;});};func (_fffg *TOCLine )getLineLink ()*_ce .PdfAnnotation {if _fffg ._fcfa <=0{return nil ;};return _debed (_fffg ._fcfa -1,_fffg ._fgec ,_fffg ._aagbg ,0);};

// GeneratePageBlocks generates a page break block.
func (_fgbd *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eedfe :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_gdbe :=ctx ;_gdbe .Y =ctx .Margins ._dcgbd ;_gdbe .X =ctx .Margins ._dca ;_gdbe .Height =ctx .PageHeight -ctx .Margins ._dcgbd -ctx .Margins ._fbf ;_gdbe .Width =ctx .PageWidth -ctx .Margins ._dca -ctx .Margins ._ffe ;ctx =_gdbe ;return _eedfe ,ctx ,nil ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_fea []*_ce .PdfPage ;_abac map[*_ce .PdfPage ]*Block ;_dgd *_ce .PdfPage ;_gcec PageSize ;_ceg DrawContext ;_baa margins ;_acge ,_ceed float64 ;_deg int ;_eeec func (_eddb FrontpageFunctionArgs );_eba func (_egca *TOC )error ;_aebef func (_abbe *Block ,_cdbde HeaderFunctionArgs );_dcbb func (_aga *Block ,_baf FooterFunctionArgs );_cfa func (_gbde *_ce .PdfWriter )error ;_fcb bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_eea *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gac *_ce .Outline ;_afba *_ce .PdfOutlineTreeNode ;_dgda *_ce .PdfAcroForm ;_dabd _fg .PdfObject ;_aab _ce .Optimizer ;_debe []*_ce .PdfFont ;_ggda *_ce .PdfFont ;_efb *_ce .PdfFont ;};

// SetLineHeight sets the line height (1.0 default).
func (_abbg *Paragraph )SetLineHeight (lineheight float64 ){_abbg ._gfga =lineheight };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_efbb *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _efbb ._cfba ._dca ,_efbb ._cfba ._ffe ,_efbb ._cfba ._dcgbd ,_efbb ._cfba ._fbf ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_cgd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afea :=ctx ;if _cgd ._gagc .isRelative (){ctx .X +=_cgd ._ebbe ._dca ;ctx .Y +=_cgd ._ebbe ._dcgbd ;ctx .Width -=_cgd ._ebbe ._dca +_cgd ._ebbe ._ffe ;ctx .Height -=_cgd ._ebbe ._dcgbd ;};_cbg ,_abbc ,_bbd :=_cgd ._ebb .GeneratePageBlocks (ctx );if _bbd !=nil {return _cbg ,ctx ,_bbd ;};ctx =_abbc ;_fac :=ctx .X ;_gfg :=ctx .Y -_cgd ._ebb .Height ();_cddfe :=int64 (ctx .Page );_efga :=_cgd .headingNumber ();_dabe :=_cgd .headingText ();if _cgd ._dfd {_fcf :=_cgd ._efgg .Add (_efga ,_cgd ._bcec ,_gf .FormatInt (_cddfe ,10),_cgd ._cgg );if _cgd ._efgg ._gdgf {_fcf .SetLink (_cddfe ,_fac ,_gfg );};};if _cgd ._begf ==nil {_cgd ._begf =_ce .NewOutlineItem (_dabe ,_ce .NewOutlineDest (_cddfe -1,_fac ,_gfg ));if _cgd ._eccg !=nil {_cgd ._eccg ._begf .Add (_cgd ._begf );}else {_cgd ._ecbb .Add (_cgd ._begf );};}else {_cdbdf :=&_cgd ._begf .Dest ;_cdbdf .Page =_cddfe -1;_cdbdf .X =_fac ;_cdbdf .Y =_gfg ;};for _ ,_edg :=range _cgd ._gge {_defg ,_gfc ,_gcf :=_edg .GeneratePageBlocks (ctx );if _gcf !=nil {return _cbg ,ctx ,_gcf ;};if len (_defg )< 1{continue ;};_cbg [len (_cbg )-1].mergeBlocks (_defg [0]);_cbg =append (_cbg ,_defg [1:]...);ctx =_gfc ;};if _cgd ._gagc .isRelative (){ctx .X =_afea .X ;};if _cgd ._gagc .isAbsolute (){return _cbg ,_afea ,nil ;};return _cbg ,ctx ,nil ;};func (_gcgeg *Invoice )drawAddress (_cdaf *InvoiceAddress )[]*StyledParagraph {var _bdgg []*StyledParagraph ;if _cdaf .Heading !=""{_cdae :=_cagb (_gcgeg ._cbaaf );_cdae .SetMargins (0,0,0,7);_cdae .Append (_cdaf .Heading );_bdgg =append (_bdgg ,_cdae );};_fggb :=_cagb (_gcgeg ._agdf );_fggb .SetLineHeight (1.2);_beac :=_cdaf .Separator ;if _beac ==""{_beac =_gcgeg ._ddfe ;};_deee :=_cdaf .City ;if _cdaf .State !=""{if _deee !=""{_deee +=_beac ;};_deee +=_cdaf .State ;};if _cdaf .Zip !=""{if _deee !=""{_deee +=_beac ;};_deee +=_cdaf .Zip ;};if _cdaf .Name !=""{_fggb .Append (_cdaf .Name +"\u000a");};if _cdaf .Street !=""{_fggb .Append (_cdaf .Street +"\u000a");};if _cdaf .Street2 !=""{_fggb .Append (_cdaf .Street2 +"\u000a");};if _deee !=""{_fggb .Append (_deee +"\u000a");};if _cdaf .Country !=""{_fggb .Append (_cdaf .Country +"\u000a");};_bbff :=_cagb (_gcgeg ._agdf );_bbff .SetLineHeight (1.2);_bbff .SetMargins (0,0,7,0);if _cdaf .Phone !=""{_bbff .Append (_ba .Sprintf ("\u0050\u0068\u006f\u006e\u0065\u003a\u0020\u0025\u0073\u000a",_cdaf .Phone ));};if _cdaf .Email !=""{_bbff .Append (_ba .Sprintf ("\u0045\u006d\u0061\u0069\u006c\u003a\u0020\u0025\u0073\u000a",_cdaf .Email ));};_bdgg =append (_bdgg ,_fggb ,_bbff );return _bdgg ;};func (_cece positioning )isRelative ()bool {return _cece ==_ccff };

// SetMargins sets the Paragraph's margins.
func (_fgeg *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_fgeg ._dagf ._dca =left ;_fgeg ._dagf ._ffe =right ;_fgeg ._dagf ._dcgbd =top ;_fgeg ._dagf ._fbf =bottom ;};

// SetStyleRight sets border style for right side.
func (_fgab *border )SetStyleRight (style CellBorderStyle ){_fgab ._ded =style };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_cdfe *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_dbea :=NewTextChunk (text ,_cdfe ._cefff );_dbea ._gcbge =_debed (page -1,x ,y ,zoom );return _cdfe .appendChunk (_dbea );};func (_abf *Creator )newPage ()*_ce .PdfPage {_cbfa :=_ce .NewPdfPage ();_cbd :=_abf ._gcec [0];_gagf :=_abf ._gcec [1];_bfd :=_ce .PdfRectangle {Llx :0,Lly :0,Urx :_cbd ,Ury :_gagf };_cbfa .MediaBox =&_bfd ;_abf ._acge =_cbd ;_abf ._ceed =_gagf ;_abf .initContext ();return _cbfa ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_efaea *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _a .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_efaea ._gfefb =true ;_efaea ._gacd =startRow ;_efaea ._dbbd =endRow ;return nil ;};

// Logo returns the logo of the invoice.
func (_bedb *Invoice )Logo ()*Image {return _bedb ._eaaf };

// Scale scales Image by a constant factor, both width and height.
func (_dfdb *Image )Scale (xFactor ,yFactor float64 ){_dfdb ._gefe =xFactor *_dfdb ._gefe ;_dfdb ._gad =yFactor *_dfdb ._gad ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aecde *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdbe :=ctx ;_dbab ,ctx ,_bbab :=_aecde ._ggfe .GeneratePageBlocks (ctx );if _bbab !=nil {return _dbab ,ctx ,_bbab ;};if _aecde ._afac .isRelative (){ctx .X =_cdbe .X ;};if _aecde ._afac .isAbsolute (){return _dbab ,_cdbe ,nil ;};return _dbab ,ctx ,nil ;};

// RotatedSize returns the width and height of the rotated block.
func (_bgd *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_bea ,_edc :=_geeeg (_bgd ._e ,_bgd ._ae ,_bgd ._de );return _bea ,_edc ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_eeea *Division )Add (d VectorDrawable )error {_dgfe :=false ;switch d .(type ){case *Paragraph :_dgfe =true ;case *StyledParagraph :_dgfe =true ;case *Image :_dgfe =true ;};if !_dgfe {return _a .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_eeea ._fbce =append (_eeea ._fbce ,d );return nil ;};func _ccab (_cdbfb ,_fefcd ,_eeaf string ,_acaf uint ,_afade TextStyle )*TOCLine {return _dfaf (TextChunk {Text :_cdbfb ,Style :_afade },TextChunk {Text :_fefcd ,Style :_afade },TextChunk {Text :_eeaf ,Style :_afade },_acaf ,_afade );};

// GeneratePageBlocks implements drawable interface.
func (_egb *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ade :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfba :=_egb ._dde ;_cbeb :=ctx .PageHeight -_egb ._faab ;if _egb ._afa !=nil {_cgc :=_gd .Rectangle {Opacity :1.0,X :_egb ._dde ,Y :ctx .PageHeight -_egb ._faab -_egb ._bcedc ,Height :_egb ._bcedc ,Width :_egb ._abbd };_cgc .FillEnabled =true ;_cgc .FillColor =_egb ._afa ;_cgc .BorderEnabled =false ;_cdbd ,_ ,_daa :=_cgc .Draw ("");if _daa !=nil {return nil ,ctx ,_daa ;};_daa =_ade .addContentsByString (string (_cdbd ));if _daa !=nil {return nil ,ctx ,_daa ;};};_ggaf :=_egb ._dfc ;_fbe :=_egb ._cdf ;_gbg :=_egb ._gafd ;_adea :=_egb ._ge ;_accf :=_egb ._dfc ;if _egb ._bff ==CellBorderStyleDouble {_accf +=2*_ggaf ;};_bed :=_egb ._cdf ;if _egb ._dcge ==CellBorderStyleDouble {_bed +=2*_fbe ;};_faabe :=_egb ._gafd ;if _egb ._afee ==CellBorderStyleDouble {_faabe +=2*_gbg ;};_beaf :=_egb ._ge ;if _egb ._ded ==CellBorderStyleDouble {_beaf +=2*_adea ;};if _egb ._dfc !=0{_gagg :=_dfba ;_fbag :=_cbeb ;if _egb ._bff ==CellBorderStyleDouble {_fbag -=_ggaf ;_bgdb :=_gd .BasicLine {};_bgdb .X1 =_gagg -_accf /2;_bgdb .Y1 =_fbag +2*_ggaf ;_bgdb .X2 =_gagg +_egb ._abbd +_accf /2;_bgdb .Y2 =_fbag +2*_ggaf ;_bgdb .LineColor =_egb ._fab ;_bgdb .LineWidth =_egb ._dfc ;_bgdb .LineStyle =_egb .LineStyle ;_dgf ,_ ,_aaff :=_bgdb .Draw ("");if _aaff !=nil {return nil ,ctx ,_aaff ;};_aaff =_ade .addContentsByString (string (_dgf ));if _aaff !=nil {return nil ,ctx ,_aaff ;};};_cacg :=_gd .BasicLine {LineWidth :_egb ._dfc ,Opacity :1.0,LineColor :_egb ._fab ,X1 :_gagg -_accf /2+(_faabe -_egb ._gafd ),Y1 :_fbag ,X2 :_gagg +_egb ._abbd +_accf /2-(_beaf -_egb ._ge ),Y2 :_fbag ,LineStyle :_egb .LineStyle };_adg ,_ ,_gdc :=_cacg .Draw ("");if _gdc !=nil {return nil ,ctx ,_gdc ;};_gdc =_ade .addContentsByString (string (_adg ));if _gdc !=nil {return nil ,ctx ,_gdc ;};};if _egb ._cdf !=0{_gbdg :=_dfba ;_ddgd :=_cbeb -_egb ._bcedc ;if _egb ._dcge ==CellBorderStyleDouble {_ddgd +=_fbe ;_afaf :=_gd .BasicLine {LineWidth :_egb ._cdf ,Opacity :1.0,LineColor :_egb ._cag ,X1 :_gbdg -_bed /2,Y1 :_ddgd -2*_fbe ,X2 :_gbdg +_egb ._abbd +_bed /2,Y2 :_ddgd -2*_fbe ,LineStyle :_egb .LineStyle };_edcb ,_ ,_ecb :=_afaf .Draw ("");if _ecb !=nil {return nil ,ctx ,_ecb ;};_ecb =_ade .addContentsByString (string (_edcb ));if _ecb !=nil {return nil ,ctx ,_ecb ;};};_efc :=_gd .BasicLine {LineWidth :_egb ._cdf ,Opacity :1.0,LineColor :_egb ._cag ,X1 :_gbdg -_bed /2+(_faabe -_egb ._gafd ),Y1 :_ddgd ,X2 :_gbdg +_egb ._abbd +_bed /2-(_beaf -_egb ._ge ),Y2 :_ddgd ,LineStyle :_egb .LineStyle };_dag ,_ ,_fbbe :=_efc .Draw ("");if _fbbe !=nil {return nil ,ctx ,_fbbe ;};_fbbe =_ade .addContentsByString (string (_dag ));if _fbbe !=nil {return nil ,ctx ,_fbbe ;};};if _egb ._gafd !=0{_caba :=_dfba ;_egfb :=_cbeb ;if _egb ._afee ==CellBorderStyleDouble {_caba +=_gbg ;_dce :=_gd .BasicLine {LineWidth :_egb ._gafd ,Opacity :1.0,LineColor :_egb ._ecc ,X1 :_caba -2*_gbg ,Y1 :_egfb +_faabe /2,X2 :_caba -2*_gbg ,Y2 :_egfb -_egb ._bcedc -_faabe /2,LineStyle :_egb .LineStyle };_bege ,_ ,_cgbf :=_dce .Draw ("");if _cgbf !=nil {return nil ,ctx ,_cgbf ;};_cgbf =_ade .addContentsByString (string (_bege ));if _cgbf !=nil {return nil ,ctx ,_cgbf ;};};_aeda :=_gd .BasicLine {LineWidth :_egb ._gafd ,Opacity :1.0,LineColor :_egb ._ecc ,X1 :_caba ,Y1 :_egfb +_faabe /2-(_accf -_egb ._dfc ),X2 :_caba ,Y2 :_egfb -_egb ._bcedc -_faabe /2+(_bed -_egb ._cdf ),LineStyle :_egb .LineStyle };_bcfa ,_ ,_aeab :=_aeda .Draw ("");if _aeab !=nil {return nil ,ctx ,_aeab ;};_aeab =_ade .addContentsByString (string (_bcfa ));if _aeab !=nil {return nil ,ctx ,_aeab ;};};if _egb ._ge !=0{_fbae :=_dfba +_egb ._abbd ;_age :=_cbeb ;if _egb ._ded ==CellBorderStyleDouble {_fbae -=_adea ;_cdg :=_gd .BasicLine {LineWidth :_egb ._ge ,Opacity :1.0,LineColor :_egb ._acc ,X1 :_fbae +2*_adea ,Y1 :_age +_beaf /2,X2 :_fbae +2*_adea ,Y2 :_age -_egb ._bcedc -_beaf /2,LineStyle :_egb .LineStyle };_db ,_ ,_ecga :=_cdg .Draw ("");if _ecga !=nil {return nil ,ctx ,_ecga ;};_ecga =_ade .addContentsByString (string (_db ));if _ecga !=nil {return nil ,ctx ,_ecga ;};};_fbdd :=_gd .BasicLine {LineWidth :_egb ._ge ,Opacity :1.0,LineColor :_egb ._acc ,X1 :_fbae ,Y1 :_age +_beaf /2-(_accf -_egb ._dfc ),X2 :_fbae ,Y2 :_age -_egb ._bcedc -_beaf /2+(_bed -_egb ._cdf ),LineStyle :_egb .LineStyle };_cbbd ,_ ,_dcbf :=_fbdd .Draw ("");if _dcbf !=nil {return nil ,ctx ,_dcbf ;};_dcbf =_ade .addContentsByString (string (_cbbd ));if _dcbf !=nil {return nil ,ctx ,_dcbf ;};};return []*Block {_ade },ctx ,nil ;};func (_bec *Block )addContentsByString (_ea string )error {_ec :=_cf .NewContentStreamParser (_ea );_bb ,_ead :=_ec .Parse ();if _ead !=nil {return _ead ;};_bec ._fgb .WrapIfNeeded ();_bb .WrapIfNeeded ();*_bec ._fgb =append (*_bec ._fgb ,*_bb ...);return nil ;};func (_cggeg *Table )resetColumnWidths (){_cggeg ._gggbc =[]float64 {};_dabbe :=float64 (1.0)/float64 (_cggeg ._cebb );for _gaee :=0;_gaee < _cggeg ._cebb ;_gaee ++{_cggeg ._gggbc =append (_cggeg ._gggbc ,_dabbe );};};

// SetBorderOpacity sets the border opacity.
func (_fabe *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_fabe ._facbb =opacity };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_dafb *Creator )Draw (d Drawable )error {if _dafb .getActivePage ()==nil {_dafb .NewPage ();};_beb ,_bbgc ,_fcec :=d .GeneratePageBlocks (_dafb ._ceg );if _fcec !=nil {return _fcec ;};for _gfbf ,_fbeb :=range _beb {if _gfbf > 0{_dafb .NewPage ();};_cgdd :=_dafb .getActivePage ();if _dfe ,_eabd :=_dafb ._abac [_cgdd ];_eabd {if _acgg :=_dfe .mergeBlocks (_fbeb );_acgg !=nil {return _acgg ;};if _fffa :=_gfe (_fbeb ._cb ,_dfe ._cb );_fffa !=nil {return _fffa ;};}else {_dafb ._abac [_cgdd ]=_fbeb ;};};_dafb ._ceg .X =_bbgc .X ;_dafb ._ceg .Y =_bbgc .Y ;_dafb ._ceg .Height =_bbgc .PageHeight -_bbgc .Y -_bbgc .Margins ._fbf ;return nil ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_aebe *Chapter )NewSubchapter (title string )*Chapter {_fgaf :=_dgfeg (_aebe ._ebb ._deag );_fgaf .FontSize =14;_aebe ._fdc ++;_ageg :=_fce (_aebe ,_aebe ._efgg ,_aebe ._ecbb ,title ,_aebe ._fdc ,_fgaf );_aebe .Add (_ageg );return _ageg ;};

// SetFillColor sets background color for border.
func (_gdd *border )SetFillColor (col Color ){_gdd ._afa =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_ee *Block )SetMargins (left ,right ,top ,bottom float64 ){_ee ._abb ._dca =left ;_ee ._abb ._ffe =right ;_ee ._abb ._dcgbd =top ;_ee ._abb ._fbf =bottom ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_bddc *Invoice )SetColumns (cols []*InvoiceCell ){_bddc ._dfeb =cols };func (_fdcb *StyledParagraph )getLineHeight (_accb int )(_ffad ,_dbgc float64 ){if _fdcb ._fgde ==nil ||len (_fdcb ._fgde )==0{_fdcb .wrapText ();};if _accb < 0||_accb > len (_fdcb ._fgde )-1{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_accb );return 0,0;};_caab :=_fdcb ._fgde [_accb ];for _ ,_cada :=range _caab {_gfbc ,_abbgf :=_cada .Style .Font .GetFontDescriptor ();if _abbgf !=nil {_af .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _feff float64 ;if _gfbc !=nil {if _feff ,_abbgf =_gfbc .GetCapHeight ();_abbgf !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_abbgf );};};if int (_feff )<=0{_af .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_feff =1000;};_aecca :=_feff /1000.0*_cada .Style .FontSize *_fdcb ._eefc ;if _aecca > _ffad {_ffad =_aecca ;};_aecca =_fdcb ._eefc *_cada .Style .FontSize ;if _aecca > _dbgc {_dbgc =_aecca ;};};return _ffad ,_dbgc ;};

// NewPolygon creates a new polygon.
func (_cdagg *Creator )NewPolygon (points [][]_gd .Point )*Polygon {return _daaa (points )};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_ecd :=rgbColor {};_ecd ._eeb =float64 (r )/255.0;_ecd ._cdbf =float64 (g )/255.0;_ecd ._edcc =float64 (b )/255.0;return _ecd ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_ggfe *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_dbfeg float64 ;_ccgbg uint ;_agcfb float64 ;_afac positioning ;_fgec float64 ;_aagbg float64 ;_fcfa int64 ;};

// SetAngle sets the rotation angle in degrees.
func (_aee *Block )SetAngle (angleDeg float64 ){_aee ._de =angleDeg };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_egc *Block )Draw (d Drawable )error {_becc :=DrawContext {};_becc .Width =_egc ._e ;_becc .Height =_egc ._ae ;_becc .PageWidth =_egc ._e ;_becc .PageHeight =_egc ._ae ;_becc .X =0;_becc .Y =0;_deb ,_ ,_edca :=d .GeneratePageBlocks (_becc );if _edca !=nil {return _edca ;};if len (_deb )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ag :=range _deb {if _cda :=_egc .mergeBlocks (_ag );_cda !=nil {return _cda ;};};return nil ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_bafg *Image )ScaleToHeight (h float64 ){_ccdb :=_bafg ._gefe /_bafg ._gad ;_bafg ._gad =h ;_bafg ._gefe =h *_ccdb ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_bdfe *_ce .XObjectImage ;_gdfc *_ce .Image ;_cegb float64 ;_gefe ,_gad float64 ;_ege ,_gecb float64 ;_cfcd positioning ;_gdde HorizontalAlignment ;_bbdf float64 ;_ccag float64 ;_bbdd float64 ;_cfba margins ;_baad ,_cded float64 ;_dfab _fg .StreamEncoder ;};

// Width returns the Block's width.
func (_afb *Block )Width ()float64 {return _afb ._e };

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_fadae int ;_cebb int ;_eede int ;_gggbc []float64 ;_effbc []float64 ;_ccfda float64 ;_gfeg []*TableCell ;_fegc positioning ;_afcc ,_decg float64 ;_cacab margins ;_gfefb bool ;_gacd int ;_dbbd int ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_agf *Creator )MoveTo (x ,y float64 ){_agf ._ceg .X =x ;_agf ._ceg .Y =y };

// SetAngle sets the rotation angle of the text.
func (_gdegde *StyledParagraph )SetAngle (angle float64 ){_gdegde ._agcb =angle };

// SetRowHeight sets the height for a specified row.
func (_bebg *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_bebg ._effbc ){return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bebg ._effbc [row -1]=h ;return nil ;};

// NewDivision returns a new Division container component.
func (_ede *Creator )NewDivision ()*Division {return _aeae ()};func (_dfg *Block )addContents (_ccg *_cf .ContentStreamOperations ){_dfg ._fgb .WrapIfNeeded ();_ccg .WrapIfNeeded ();*_dfg ._fgb =append (*_dfg ._fgb ,*_ccg ...);};

// AppendCurve appends a Bezier curve to the filled curve.
func (_gcdcb *FilledCurve )AppendCurve (curve _gd .CubicBezierCurve )*FilledCurve {_gcdcb ._cba =append (_gcdcb ._cba ,curve );return _gcdcb ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_cgdef *Invoice )InfoLines ()[][2]*InvoiceCell {_ged :=[][2]*InvoiceCell {_cgdef ._cdc ,_cgdef ._bfcd ,_cgdef ._fgfd };return append (_ged ,_cgdef ._bfb ...);};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_fcbf *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _fcbf ._gcdf ,_fcbf ._cbge ,_fcbf ._ecgg ,_fcbf ._dgea ;};func (_dbef *Invoice )generateLineBlocks (_egbe DrawContext )([]*Block ,DrawContext ,error ){_ggbee :=_baga (len (_dbef ._dfeb ));_ggbee .SetMargins (0,0,25,0);for _ ,_bagg :=range _dbef ._dfeb {_cbfe :=_cagb (_bagg .TextStyle );_cbfe .SetMargins (0,0,1,0);_cbfe .Append (_bagg .Value );_cgbcd :=_ggbee .NewCell ();_cgbcd .SetHorizontalAlignment (_bagg .Alignment );_cgbcd .SetBackgroundColor (_bagg .BackgroundColor );_dbef .setCellBorder (_cgbcd ,_bagg );_cgbcd .SetContent (_cbfe );};for _ ,_egee :=range _dbef ._cdef {for _ ,_fecb :=range _egee {_agcg :=_cagb (_fecb .TextStyle );_agcg .SetMargins (0,0,3,2);_agcg .Append (_fecb .Value );_adc :=_ggbee .NewCell ();_adc .SetHorizontalAlignment (_fecb .Alignment );_adc .SetBackgroundColor (_fecb .BackgroundColor );_dbef .setCellBorder (_adc ,_fecb );_adc .SetContent (_agcg );};};return _ggbee .GeneratePageBlocks (_egbe );};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bbed *Creator )SetOptimizer (optimizer _ce .Optimizer ){_bbed ._aab =optimizer };

// CurCol returns the currently active cell's column number.
func (_geede *Table )CurCol ()int {_bfae :=(_geede ._eede -1)%(_geede ._cebb )+1;return _bfae };

// Lines returns all the rows of the invoice line items table.
func (_ffba *Invoice )Lines ()[][]*InvoiceCell {return _ffba ._cdef };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_dfge *_gd .Polygon ;_acgc float64 ;_aecaf float64 ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gee *Chapter )SetShowNumbering (show bool ){_gee ._dbd =show ;_gee ._ebb .SetText (_gee .headingText ());};

// SetMargins sets the Paragraph's margins.
func (_gggfd *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_gggfd ._gbc ._dca =left ;_gggfd ._gbc ._ffe =right ;_gggfd ._gbc ._dcgbd =top ;_gggfd ._gbc ._fbf =bottom ;};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_gacf *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _bgfc (x ,y ,width ,height );};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_fagd *TOCLine )SetLink (page int64 ,x ,y float64 ){_fagd ._fgec =x ;_fagd ._aagbg =y ;_fagd ._fcfa =page ;_aegbd :=_fagd ._ggfe ._cefff .Color ;_fagd .Number .Style .Color =_aegbd ;_fagd .Title .Style .Color =_aegbd ;_fagd .Separator .Style .Color =_aegbd ;_fagd .Page .Style .Color =_aegbd ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {_eecb :=&Creator {};_eecb ._fea =[]*_ce .PdfPage {};_eecb ._abac =map[*_ce .PdfPage ]*Block {};_eecb .SetPageSize (PageSizeLetter );_bfcg :=0.1*_eecb ._acge ;_eecb ._baa ._dca =_bfcg ;_eecb ._baa ._ffe =_bfcg ;_eecb ._baa ._dcgbd =_bfcg ;_eecb ._baa ._fbf =_bfcg ;var _cbba error ;_eecb ._ggda ,_cbba =_ce .NewStandard14Font (_ce .HelveticaName );if _cbba !=nil {_eecb ._ggda =_ce .DefaultFont ();};_eecb ._efb ,_cbba =_ce .NewStandard14Font (_ce .HelveticaBoldName );if _cbba !=nil {_eecb ._ggda =_ce .DefaultFont ();};_eecb ._eea =_eecb .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_eecb .AddOutlines =true ;_eecb ._gac =_ce .NewOutline ();return _eecb ;};

// Height returns the Block's height.
func (_dd *Block )Height ()float64 {return _dd ._ae };func _aadb ()*FilledCurve {_gafg :=FilledCurve {};_gafg ._cba =[]_gd .CubicBezierCurve {};return &_gafg ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_aef *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aef ._ebbe ._dca ,_aef ._ebbe ._ffe ,_aef ._ebbe ._dcgbd ,_aef ._ebbe ._fbf ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// TitleStyle returns the style properties used to render the invoice title.
func (_ffef *Invoice )TitleStyle ()TextStyle {return _ffef ._bbac };

// SetFont sets the Paragraph's font.
func (_bgc *Paragraph )SetFont (font *_ce .PdfFont ){_bgc ._deag =font };

// Append adds a new text chunk to the paragraph.
func (_afag *StyledParagraph )Append (text string )*TextChunk {_ebfba :=NewTextChunk (text ,_afag ._geb );return _afag .appendChunk (_ebfba );};

// AddSection adds a new content section at the end of the invoice.
func (_dgef *Invoice )AddSection (title ,content string ){_dgef ._ddbf =append (_dgef ._ddbf ,[2]string {title ,content });};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_efbf *TOC )SetLineLevelOffset (levelOffset float64 ){_efbf ._efgcc =levelOffset };

// SetBorderWidth sets the border width.
func (_gadg *Polygon )SetBorderWidth (borderWidth float64 ){_gadg ._dfge .BorderWidth =borderWidth };

// SetBorderWidth sets the border width.
func (_dcee *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_dcee ._bbda .BorderWidth =borderWidth ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_dgaa *List )Width ()float64 {return 0};func _ddgfc (_fead string )*_ce .PdfAnnotation {_fcfe :=_ce .NewPdfAnnotationLink ();_fgbfd :=_ce .NewBorderStyle ();_fgbfd .SetBorderWidth (0);_fcfe .BS =_fgbfd .ToPdfObject ();_dgafg :=_ce .NewPdfActionURI ();_dgafg .URI =_fg .MakeString (_fead );_fcfe .SetAction (_dgafg .PdfAction );return _fcfe .PdfAnnotation ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_efef *Image )SetEncoder (encoder _fg .StreamEncoder ){_efef ._dfab =encoder };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_adag *TOC )SetLineSeparatorStyle (style TextStyle ){_adag ._efdd =style };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ce .PdfPage )(*Block ,error ){_cc :=&Block {};_gc ,_eb :=page .GetAllContentStreams ();if _eb !=nil {return nil ,_eb ;};_ccc :=_cf .NewContentStreamParser (_gc );_fa ,_eb :=_ccc .Parse ();if _eb !=nil {return nil ,_eb ;};_fa .WrapIfNeeded ();_cc ._fgb =_fa ;if page .Resources !=nil {_cc ._cb =page .Resources ;}else {_cc ._cb =_ce .NewPdfPageResources ();};_ac ,_eb :=page .GetMediaBox ();if _eb !=nil {return nil ,_eb ;};if _ac .Llx !=0||_ac .Lly !=0{_cc .translate (-_ac .Llx ,_ac .Lly );};_cc ._e =_ac .Urx -_ac .Llx ;_cc ._ae =_ac .Ury -_ac .Lly ;if page .Rotate !=nil {_cc ._de =-float64 (*page .Rotate );};return _cc ,nil ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_badb *Creator )EnableFontSubsetting (font *_ce .PdfFont ){_badb ._debe =append (_badb ._debe ,font );};

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_bdg *Division )Height ()float64 {_gdgb :=0.0;_ceb :=0.0;for _ ,_abge :=range _bdg ._fbce {_caae ,_dbdd :=_abge .Width (),_abge .Height ();switch _cabf :=_abge .(type ){case *Paragraph :_ebg :=_cabf ;_caae +=_ebg ._dagf ._dca +_ebg ._dagf ._ffe ;_dbdd +=_ebg ._dagf ._dcgbd +_ebg ._dagf ._fbf ;case *StyledParagraph :_gcgdd :=_cabf ;_caae +=_gcgdd ._gbc ._dca +_gcgdd ._gbc ._ffe ;_dbdd +=_gcgdd ._gbc ._dcgbd +_gcgdd ._gbc ._fbf ;};_gdgb +=_dbdd ;_ceb =_gdgb ;};return _ceb ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_adga *Paragraph )Height ()float64 {_adga .wrapText ();return float64 (len (_adga ._gdab ))*_adga ._gfga *_adga ._feccg ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bfff *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bfff ._gbc ._dca ,_bfff ._gbc ._ffe ,_bfff ._gbc ._dcgbd ,_bfff ._gbc ._fbf ;};

// SetFillColor sets the fill color.
func (_ebdf *Ellipse )SetFillColor (col Color ){_ebdf ._ggce =_ce .NewPdfColorDeviceRGB (col .ToRGB ())};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gbfg *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _gbfg ._cdc [0],_gbfg ._cdc [1]};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_cccg *Block )ScaleToWidth (w float64 ){_gcd :=w /_cccg ._e ;_cccg .Scale (_gcd ,_gcd )};func (_bge *Creator )getActivePage ()*_ce .PdfPage {if _bge ._dgd ==nil {if len (_bge ._fea )==0{return nil ;};return _bge ._fea [len (_bge ._fea )-1];};return _bge ._dgd ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_edcca *Image )ScaleToWidth (w float64 ){_geab :=_edcca ._gad /_edcca ._gefe ;_edcca ._gefe =w ;_edcca ._gad =w *_geab ;};

// SetAngle sets Image rotation angle in degrees.
func (_bcaa *Image )SetAngle (angle float64 ){_bcaa ._cegb =angle };func _bbg (_gdec ,_egf ,_cccge ,_cgb float64 )*border {_eac :=&border {};_eac ._dde =_gdec ;_eac ._faab =_egf ;_eac ._abbd =_cccge ;_eac ._bcedc =_cgb ;_eac ._fab =_ce .NewPdfColorDeviceRGB (0,0,0);_eac ._cag =_ce .NewPdfColorDeviceRGB (0,0,0);_eac ._ecc =_ce .NewPdfColorDeviceRGB (0,0,0);_eac ._acc =_ce .NewPdfColorDeviceRGB (0,0,0);_eac ._dfc =0;_eac ._cdf =0;_eac ._gafd =0;_eac ._ge =0;_eac .LineStyle =_gd .LineStyleSolid ;return _eac ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_cfabc *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cfabc ._dagf ._dca ,_cfabc ._dagf ._ffe ,_cfabc ._dagf ._dcgbd ,_cfabc ._dagf ._fbf ;};

// SetBorderWidth sets the border width.
func (_babg *Ellipse )SetBorderWidth (bw float64 ){_babg ._begd =bw };

// AddPage adds the specified page to the creator.
func (_gfcc *Creator )AddPage (page *_ce .PdfPage )error {_gcdc ,_ccfc :=page .GetMediaBox ();if _ccfc !=nil {_af .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_ccfc );return _ccfc ;};_gfcc ._ceg .X =_gcdc .Llx +_gfcc ._baa ._dca ;_gfcc ._ceg .Y =_gfcc ._baa ._dcgbd ;_gfcc ._ceg .PageHeight =_gcdc .Ury -_gcdc .Lly ;_gfcc ._ceg .PageWidth =_gcdc .Urx -_gcdc .Llx ;_gfcc ._fea =append (_gfcc ._fea ,page );_gfcc ._ceg .Page ++;return nil ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_dgaf *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_afcf :=NewTextChunk (text ,_dgaf ._cefff );_afcf ._gcbge =_ddgfc (url );return _dgaf .appendChunk (_afcf );};

// SetFillColor sets the fill color.
func (_aecdf *Rectangle )SetFillColor (col Color ){_aecdf ._dgefa =_ce .NewPdfColorDeviceRGB (col .ToRGB ());};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_geee *Creator )SetOutlineTree (outlineTree *_ce .PdfOutlineTreeNode ){_geee ._afba =outlineTree };

// NewCellProps returns the default properties of an invoice cell.
func (_gcfff *Invoice )NewCellProps ()InvoiceCellProps {_dga :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_gcfff ._ggceg ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_dga ,BorderColor :_dga ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_bcca *TOC )SetLineStyle (style TextStyle ){_bcca .SetLineNumberStyle (style );_bcca .SetLineTitleStyle (style );_bcca .SetLineSeparatorStyle (style );_bcca .SetLinePageStyle (style );};func _caef (_dabfd ,_bbaa TextStyle )*Invoice {_bffd :=&Invoice {_gggf :"\u0049N\u0056\u004f\u0049\u0043\u0045",_ddfe :"\u002c\u0020",_ggceg :_dabfd ,_bde :_bbaa };_bffd ._gaba =&InvoiceAddress {Separator :_bffd ._ddfe };_bffd ._ecef =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_bffd ._ddfe };_eded :=ColorRGBFrom8bit (245,245,245);_cfbe :=ColorRGBFrom8bit (155,155,155);_bffd ._bbac =_bbaa ;_bffd ._bbac .Color =_cfbe ;_bffd ._bbac .FontSize =20;_bffd ._agdf =_dabfd ;_bffd ._cbaaf =_bbaa ;_bffd ._gdee =_dabfd ;_bffd ._adbg =_bbaa ;_bffd ._ffaab =_bffd .NewCellProps ();_bffd ._ffaab .BackgroundColor =_eded ;_bffd ._ffaab .TextStyle =_bbaa ;_bffd ._fdcc =_bffd .NewCellProps ();_bffd ._fdcc .TextStyle =_bbaa ;_bffd ._fdcc .BackgroundColor =_eded ;_bffd ._fdcc .BorderColor =_eded ;_bffd ._ebce =_bffd .NewCellProps ();_bffd ._ebce .BorderColor =_eded ;_bffd ._ebce .BorderSides =[]CellBorderSide {CellBorderSideBottom };_bffd ._ebce .Alignment =CellHorizontalAlignmentRight ;_bffd ._cabb =_bffd .NewCellProps ();_bffd ._cabb .Alignment =CellHorizontalAlignmentRight ;_bffd ._cdc =[2]*InvoiceCell {_bffd .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_bffd ._ffaab ),_bffd .newCell ("",_bffd ._ffaab )};_bffd ._bfcd =[2]*InvoiceCell {_bffd .newCell ("\u0044\u0061\u0074\u0065",_bffd ._ffaab ),_bffd .newCell ("",_bffd ._ffaab )};_bffd ._fgfd =[2]*InvoiceCell {_bffd .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_bffd ._ffaab ),_bffd .newCell ("",_bffd ._ffaab )};_bffd ._bcd =[2]*InvoiceCell {_bffd .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_bffd ._cabb ),_bffd .newCell ("",_bffd ._cabb )};_ddgg :=_bffd ._cabb ;_ddgg .TextStyle =_bbaa ;_ddgg .BackgroundColor =_eded ;_ddgg .BorderColor =_eded ;_bffd ._ccfd =[2]*InvoiceCell {_bffd .newCell ("\u0054\u006f\u0074a\u006c",_ddgg ),_bffd .newCell ("",_ddgg )};_bffd ._agfd =[2]string {"\u004e\u006f\u0074e\u0073",""};_bffd ._cgde =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_bffd ._dfeb =[]*InvoiceCell {_bffd .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_bffd .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_bffd .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_bffd .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _bffd ;};

// Level returns the indentation level of the TOC line.
func (_aecfe *TOCLine )Level ()uint {return _aecfe ._ccgbg };

// SetLineWidth sets the line width.
func (_gcac *Line )SetLineWidth (lw float64 ){_gcac ._dbfd =lw };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_fgbc *Chapter )SetIncludeInTOC (includeInTOC bool ){_fgbc ._dfd =includeInTOC };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_cafg *Invoice )Terms ()(string ,string ){return _cafg ._cgde [0],_cafg ._cgde [1]};

// Scale block by specified factors in the x and y directions.
func (_ca *Block )Scale (sx ,sy float64 ){_cac :=_cf .NewContentCreator ().Scale (sx ,sy ).Operations ();*_ca ._fgb =append (*_cac ,*_ca ._fgb ...);_ca ._fgb .WrapIfNeeded ();_ca ._e *=sx ;_ca ._ae *=sy ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_eeag *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_eeag .Text },nil ;};var _adgf []string ;var _ffg []rune ;var _bdcgb float64 ;var _fccd []float64 ;_dage :=_eeag .Style ;_gcbe :=[]rune (_eeag .Text );for _ ,_aacc :=range _gcbe {if _aacc =='\u000A'{_adgf =append (_adgf ,_be .TrimRightFunc (string (_ffg ),_gb .IsSpace )+string (_aacc ));_ffg =nil ;_bdcgb =0;_fccd =nil ;continue ;};_dba :=_aacc ==' ';_deae ,_bbccc :=_dage .Font .GetRuneMetrics (_aacc );if !_bbccc {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_aacc ,_aacc ,_dage .Font .BaseFont (),_dage .Font .Subtype ());_af .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_dage .Font );_af .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_dage .Font .Encoder ());return nil ,_a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_dedc :=_dage .FontSize *_deae .Wx ;_gdded :=_dedc ;if !_dba {_gdded =_dedc +_dage .CharSpacing *1000.0;};if _bdcgb +_dedc > width *1000.0{_gdbef :=-1;if !_dba {for _aecbe :=len (_ffg )-1;_aecbe >=0;_aecbe --{if _ffg [_aecbe ]==' '{_gdbef =_aecbe ;break ;};};};_bcedd :=string (_ffg );if _gdbef > 0{_bcedd =string (_ffg [0:_gdbef +1]);_ffg =append (_ffg [_gdbef +1:],_aacc );_fccd =append (_fccd [_gdbef +1:],_gdded );_bdcgb =0;for _ ,_abcbe :=range _fccd {_bdcgb +=_abcbe ;};}else {if _dba {_ffg =[]rune {};_fccd =[]float64 {};_bdcgb =0;}else {_ffg =[]rune {_aacc };_fccd =[]float64 {_gdded };_bdcgb =_gdded ;};};_adgf =append (_adgf ,_be .TrimRightFunc (_bcedd ,_gb .IsSpace ));}else {_ffg =append (_ffg ,_aacc );_bdcgb +=_gdded ;_fccd =append (_fccd ,_gdded );};};if len (_ffg )> 0{_adgf =append (_adgf ,string (_ffg ));};return _adgf ,nil ;};func _bbga (_cbdb string ,_fdac TextStyle )*Paragraph {_gadb :=&Paragraph {_cfcb :_cbdb ,_deag :_fdac .Font ,_feccg :_fdac .FontSize ,_gfga :1.0,_ebbd :true ,_egaf :true ,_dacc :TextAlignmentLeft ,_bcab :0,_ecbc :1,_gdagd :1,_bcefb :_ccff };_gadb .SetColor (_fdac .Color );return _gadb ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_agaac *Table )NewCell ()*TableCell {return _agaac .newCell (1)};func (_efaf *Chapter )headingText ()string {_ecge :=_efaf ._bcec ;if _dbc :=_efaf .headingNumber ();_dbc !=""{_ecge =_ba .Sprintf ("\u0025\u0073\u0020%\u0073",_dbc ,_ecge );};return _ecge ;};func _bafc (_fbefd *_ce .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_fbefd ,FontSize :10};};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_bffg *Paragraph )SetMaxLines (maxLines int ){_bffg ._cfeg =maxLines ;_bffg .wrapText ()};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_dgfc *Paragraph )SetColor (col Color ){_fge :=_ce .NewPdfColorDeviceRGB (col .ToRGB ());_dgfc ._beeb =*_fge ;};func _eaee (_fccb *Block ,_adda *StyledParagraph ,_bdcaa [][]*TextChunk ,_fefg DrawContext )(DrawContext ,[][]*TextChunk ,error ){_aeaeg :=1;_ddcc :=_fg .PdfObjectName (_ba .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeaeg ));for _fccb ._cb .HasFontByName (_ddcc ){_aeaeg ++;_ddcc =_fg .PdfObjectName (_ba .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeaeg ));};_afda :=_fccb ._cb .SetFontByName (_ddcc ,_adda ._geb .Font .ToPdfObject ());if _afda !=nil {return _fefg ,nil ,_afda ;};_aeaeg ++;_ggdad :=_ddcc ;_adcb :=_adda ._geb .FontSize ;_ggf :=_adda ._cfbd .isRelative ();var _aadbe [][]_fg .PdfObjectName ;var _gfcb float64 ;var _agg [][]*TextChunk ;var _gdbdb float64 ;for _gcbg ,_acbd :=range _bdcaa {var _gbacb []_fg .PdfObjectName ;var _adcf float64 ;for _ ,_abdg :=range _acbd {_fbee :=_abdg .Style ;if _gcbg ==0&&_fbee .FontSize > _gfcb {_gfcb =_fbee .FontSize ;};if _fbee .FontSize > _adcf {_adcf =_fbee .FontSize ;};_ddcc =_fg .PdfObjectName (_ba .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeaeg ));_cdagd :=_fccb ._cb .SetFontByName (_ddcc ,_fbee .Font .ToPdfObject ());if _cdagd !=nil {return _fefg ,nil ,_cdagd ;};_gbacb =append (_gbacb ,_ddcc );_aeaeg ++;};_adcf *=_adda ._eefc ;if _ggf &&_gdbdb +_adcf > _fefg .Height {_agg =_bdcaa [_gcbg :];_bdcaa =_bdcaa [:_gcbg ];break ;};_gdbdb +=_adcf ;_aadbe =append (_aadbe ,_gbacb );};_dffb :=_cf .NewContentCreator ();_dffb .Add_q ();_fdgee :=_fefg .PageHeight -_fefg .Y -_gfcb *_adda ._eefc ;_dffb .Translate (_fefg .X ,_fdgee );if _adda ._agcb !=0{_dffb .RotateDeg (_adda ._agcb );};_dffb .Add_BT ();_gfge :=_fdgee ;for _febgd ,_fgfdb :=range _bdcaa {_ebcef :=_fefg .X ;if _febgd !=0{_dffb .Add_Tstar ();};_feaea :=_febgd ==len (_bdcaa )-1;var (_ebfd float64 ;_debg float64 ;_eagd float64 ;_abcb uint ;);var _egbf []float64 ;for _ ,_cgca :=range _fgfdb {_acfb :=&_cgca .Style ;if _acfb .FontSize > _debg {_debg =_acfb .FontSize ;};_eaba ,_fcad :=_acfb .Font .GetRuneMetrics (' ');if !_fcad {return _fefg ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _fccf uint ;var _afce float64 ;_cedd :=len (_cgca .Text );for _gdba ,_fbbf :=range _cgca .Text {if _fbbf ==' '{_fccf ++;continue ;};if _fbbf =='\u000A'{continue ;};_adfe ,_ffff :=_acfb .Font .GetRuneMetrics (_fbbf );if !_ffff {_af .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_fbbf );return _fefg ,nil ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_afce +=_acfb .FontSize *_adfe .Wx ;if _gdba !=_cedd -1{_afce +=_acfb .CharSpacing *1000.0;};};_egbf =append (_egbf ,_afce );_ebfd +=_afce ;_eagd +=float64 (_fccf )*_eaba .Wx *_acfb .FontSize ;_abcb +=_fccf ;};_debg *=_adda ._eefc ;var _aeecf []_fg .PdfObject ;_addf :=_adda ._aag *1000.0;if _adda ._cdfb ==TextAlignmentJustify {if _abcb > 0&&!_feaea {_eagd =(_addf -_ebfd )/float64 (_abcb )/_adcb ;};}else if _adda ._cdfb ==TextAlignmentCenter {_bbaf :=(_addf -_ebfd -_eagd )/2;_acec :=_bbaf /_adcb ;_aeecf =append (_aeecf ,_fg .MakeFloat (-_acec ));_ebcef +=_bbaf /1000.0;}else if _adda ._cdfb ==TextAlignmentRight {_afecb :=(_addf -_ebfd -_eagd );_dabb :=_afecb /_adcb ;_aeecf =append (_aeecf ,_fg .MakeFloat (-_dabb ));_ebcef +=_afecb /1000.0;};if len (_aeecf )> 0{_dffb .Add_Tf (_ggdad ,_adcb ).Add_TL (_adcb *_adda ._eefc ).Add_TJ (_aeecf ...);};for _eggc ,_ceaac :=range _fgfdb {_bgcc :=&_ceaac .Style ;_acebd ,_fadg ,_fgabf :=_bgcc .Color .ToRGB ();_abab :=_ggdad ;_bbgcf :=_adcb ;_dffb .Add_Tr (int64 (_bgcc .RenderingMode ));_dffb .Add_Tc (_bgcc .CharSpacing );if _adda ._cdfb !=TextAlignmentJustify ||_feaea {_egae ,_fcbaa :=_bgcc .Font .GetRuneMetrics (' ');if !_fcbaa {return _fefg ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_abab =_aadbe [_febgd ][_eggc ];_bbgcf =_bgcc .FontSize ;_eagd =_egae .Wx ;};_aeed :=_bgcc .Font .Encoder ();var _ebege []byte ;for _ ,_cdac :=range _ceaac .Text {if _acebd =='\u000A'{continue ;};if _cdac ==' '{if len (_ebege )> 0{_dffb .Add_rg (_acebd ,_fadg ,_fgabf ).Add_Tf (_aadbe [_febgd ][_eggc ],_bgcc .FontSize ).Add_TL (_bgcc .FontSize *_adda ._eefc ).Add_TJ ([]_fg .PdfObject {_fg .MakeStringFromBytes (_ebege )}...);_ebege =nil ;};_dffb .Add_Tf (_abab ,_bbgcf ).Add_TL (_bbgcf *_adda ._eefc ).Add_TJ ([]_fg .PdfObject {_fg .MakeFloat (-_eagd )}...);_egbf [_eggc ]+=_eagd *_bbgcf ;}else {if _ ,_aaad :=_aeed .RuneToCharcode (_cdac );!_aaad {_af .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cdac ,_cdac );continue ;};_ebege =append (_ebege ,_aeed .Encode (string (_cdac ))...);};};if len (_ebege )> 0{_dffb .Add_rg (_acebd ,_fadg ,_fgabf ).Add_Tf (_aadbe [_febgd ][_eggc ],_bgcc .FontSize ).Add_TL (_bgcc .FontSize *_adda ._eefc ).Add_TJ ([]_fg .PdfObject {_fg .MakeStringFromBytes (_ebege )}...);};_dbfe :=_egbf [_eggc ]/1000.0;if _ceaac ._gcbge !=nil {var _bceb *_fg .PdfObjectArray ;if !_ceaac ._fbaa {switch _aebde :=_ceaac ._gcbge .GetContext ().(type ){case *_ce .PdfAnnotationLink :_bceb =_fg .MakeArray ();_aebde .Rect =_bceb ;_ebfe ,_dgcg :=_aebde .Dest .(*_fg .PdfObjectArray );if _dgcg &&_ebfe .Len ()==5{_bcada ,_efd :=_ebfe .Get (1).(*_fg .PdfObjectName );if _efd &&_bcada .String ()=="\u0058\u0059\u005a"{_fbdg ,_gbeg :=_fg .GetNumberAsFloat (_ebfe .Get (3));if _gbeg ==nil {_ebfe .Set (3,_fg .MakeFloat (_fefg .PageHeight -_fbdg ));};};};};_ceaac ._fbaa =true ;};if _bceb !=nil {_ggeb :=_gd .NewPoint (_ebcef -_fefg .X ,_gfge -_fdgee ).Rotate (_adda ._agcb );_ggeb .X +=_fefg .X ;_ggeb .Y +=_fdgee ;_bdage ,_gfgf ,_cegga ,_fed :=_geeeg (_dbfe ,_debg ,_adda ._agcb );_ggeb .X +=_bdage ;_ggeb .Y +=_gfgf ;_bceb .Clear ();_bceb .Append (_fg .MakeFloat (_ggeb .X ));_bceb .Append (_fg .MakeFloat (_ggeb .Y ));_bceb .Append (_fg .MakeFloat (_ggeb .X +_cegga ));_bceb .Append (_fg .MakeFloat (_ggeb .Y +_fed ));};_fccb .AddAnnotation (_ceaac ._gcbge );};_ebcef +=_dbfe ;_dffb .Add_Tr (int64 (TextRenderingModeFill ));_dffb .Add_Tc (0);};_gfge -=_debg ;};_dffb .Add_ET ();_dffb .Add_Q ();_ffcd :=_dffb .Operations ();_ffcd .WrapIfNeeded ();_fccb .addContents (_ffcd );if _ggf {_ggbg :=_gdbdb +_adda ._gbc ._fbf ;_fefg .Y +=_ggbg ;_fefg .Height -=_ggbg ;if _fefg .Inline {_fefg .X +=_adda .Width ()+_adda ._gbc ._ffe ;};};return _fefg ,_agg ,nil ;};

// SkipCells skips over a specified number of cells in the table.
func (_bbaab *Table )SkipCells (num int ){if num < 0{_af .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_bbaab ._eede +=num ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gbbg *StyledParagraph )SetTextAlignment (align TextAlignment ){_gbbg ._cdfb =align };func (_bdca *Paragraph )getTextLineWidth (_ebeg string )float64 {var _dae float64 ;for _ ,_aeac :=range _ebeg {if _aeac =='\u000A'{continue ;};_fdba ,_dccd :=_bdca ._deag .GetRuneMetrics (_aeac );if !_dccd {_af .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_aeac ,_aeac );return -1;};_dae +=_bdca ._feccg *_fdba .Wx ;};return _dae ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_fgcf *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gdeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_feaa ,_ ,_cdbfd :=_fgcf .draw ("");_cdbfd =_gdeg .addContentsByString (string (_feaa ));if _cdbfd !=nil {return nil ,ctx ,_cdbfd ;};return []*Block {_gdeg },ctx ,nil ;};

// SkipRows skips over a specified number of rows in the table.
func (_edbfa *Table )SkipRows (num int ){_fadcc :=num *_edbfa ._cebb -1;if _fadcc < 0{_af .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_edbfa ._eede +=_fadcc ;};func _ggff (_cfeab *_b .File )([]*_ce .PdfPage ,error ){_ceggf ,_fbcd :=_ce .NewPdfReader (_cfeab );if _fbcd !=nil {return nil ,_fbcd ;};_bagfb ,_fbcd :=_ceggf .GetNumPages ();if _fbcd !=nil {return nil ,_fbcd ;};var _dfdge []*_ce .PdfPage ;for _bacda :=0;_bacda < _bagfb ;_bacda ++{_agcce ,_fbcf :=_ceggf .GetPage (_bacda +1);if _fbcf !=nil {return nil ,_fbcf ;};_dfdge =append (_dfdge ,_agcce );};return _dfdge ,nil ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_da *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_ccd ,_ ,_aea :=d .GeneratePageBlocks (ctx );if _aea !=nil {return _aea ;};if len (_ccd )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ddb :=range _ccd {if _bcef :=_da .mergeBlocks (_ddb );_bcef !=nil {return _bcef ;};};return nil ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_bdcd *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_efdb ,_fdadg :=_bdcd .Wrap (width );if _fdadg !=nil {return nil ,_fdadg ;};_aagb :=int (height /_bdcd .Style .FontSize );if _aagb >=len (_efdb ){return nil ,nil ;};_fgffe :="\u000a";_bdcd .Text =_be .Replace (_be .Join (_efdb [:_aagb ],"\u0020"),_fgffe +"\u0020",_fgffe ,-1);_dggg :=_be .Replace (_be .Join (_efdb [_aagb :],"\u0020"),_fgffe +"\u0020",_fgffe ,-1);return NewTextChunk (_dggg ,_bdcd .Style ),nil ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_bgbae *Invoice )SetNoteHeadingStyle (style TextStyle ){_bgbae ._adbg =style };func (_eedf *FilledCurve )draw (_abcg string )([]byte ,*_ce .PdfRectangle ,error ){_gdgag :=_gd .NewCubicBezierPath ();for _ ,_cfdd :=range _eedf ._cba {_gdgag =_gdgag .AppendCurve (_cfdd );};creator :=_cf .NewContentCreator ();creator .Add_q ();if _eedf .FillEnabled {creator .Add_rg (_eedf ._eegb .R (),_eedf ._eegb .G (),_eedf ._eegb .B ());};if _eedf .BorderEnabled {creator .Add_RG (_eedf ._gdfe .R (),_eedf ._gdfe .G (),_eedf ._gdfe .B ());creator .Add_w (_eedf .BorderWidth );};if len (_abcg )> 1{creator .Add_gs (_fg .PdfObjectName (_abcg ));};_gd .DrawBezierPathWithCreator (_gdgag ,creator );creator .Add_h ();if _eedf .FillEnabled &&_eedf .BorderEnabled {creator .Add_B ();}else if _eedf .FillEnabled {creator .Add_f ();}else if _eedf .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_gdaa :=_gdgag .GetBoundingBox ();if _eedf .BorderEnabled {_gdaa .Height +=_eedf .BorderWidth ;_gdaa .Width +=_eedf .BorderWidth ;_gdaa .X -=_eedf .BorderWidth /2;_gdaa .Y -=_eedf .BorderWidth /2;};_fcge :=&_ce .PdfRectangle {};_fcge .Llx =_gdaa .X ;_fcge .Lly =_gdaa .Y ;_fcge .Urx =_gdaa .X +_gdaa .Width ;_fcge .Ury =_gdaa .Y +_gdaa .Height ;return creator .Bytes (),_fcge ,nil ;};func _gfgc (_dggc []byte )(*Image ,error ){_gafgb :=_cd .NewReader (_dggc );_gcfd ,_cfacb :=_ce .ImageHandling .Read (_gafgb );if _cfacb !=nil {_af .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cfacb );return nil ,_cfacb ;};return _begbe (_gcfd );};func (_egfe *Invoice )generateInformationBlocks (_dbdc DrawContext )([]*Block ,DrawContext ,error ){_dfbaa :=_cagb (_egfe ._ggceg );_dfbaa .SetMargins (0,0,0,20);_dddb :=_egfe .drawAddress (_egfe ._gaba );_dddb =append (_dddb ,_dfbaa );_dddb =append (_dddb ,_egfe .drawAddress (_egfe ._ecef )...);_bfgd :=_aeae ();for _ ,_egbcf :=range _dddb {_bfgd .Add (_egbcf );};_fbaeb :=_egfe .drawInformation ();_bgad :=_baga (2);_bgad .SetMargins (0,0,25,0);_agec :=_bgad .NewCell ();_agec .SetIndent (0);_agec .SetContent (_bfgd );_agec =_bgad .NewCell ();_agec .SetContent (_fbaeb );return _bgad .GeneratePageBlocks (_dbdc );};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_fced *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cffca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cffg :=_gd .Circle {X :_fced ._aad -_fced ._cgge /2,Y :ctx .PageHeight -_fced ._dee -_fced ._eaeb /2,Width :_fced ._cgge ,Height :_fced ._eaeb ,Opacity :1.0,BorderWidth :_fced ._begd };if _fced ._ggce !=nil {_cffg .FillEnabled =true ;_cffg .FillColor =_fced ._ggce ;};if _fced ._cga !=nil {_cffg .BorderEnabled =true ;_cffg .BorderColor =_fced ._cga ;_cffg .BorderWidth =_fced ._begd ;};_cdgf ,_ ,_aca :=_cffg .Draw ("");if _aca !=nil {return nil ,ctx ,_aca ;};_aca =_cffca .addContentsByString (string (_cdgf ));if _aca !=nil {return nil ,ctx ,_aca ;};return []*Block {_cffca },ctx ,nil ;};

// SetFontSize sets the font size in document units (points).
func (_bceg *Paragraph )SetFontSize (fontSize float64 ){_bceg ._feccg =fontSize };

// SetAnnotation sets a annotation on a TextChunk.
func (_afbc *TextChunk )SetAnnotation (annotation *_ce .PdfAnnotation ){_afbc ._gcbge =annotation };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_ffed *TableCell )SetBorderLineStyle (style _gd .LineStyle ){_ffed ._cgee =style };