//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_dc "bytes";_g "errors";_fc "fmt";_ab "github.com/unidoc/unichart/render";_c "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/contentstream";_fce "github.com/unidoc/unipdf/v3/contentstream/draw";_af "github.com/unidoc/unipdf/v3/core";
_dd "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_fgc "github.com/unidoc/unipdf/v3/internal/license";_cf "github.com/unidoc/unipdf/v3/internal/transform";_cb "github.com/unidoc/unipdf/v3/model";_aa "image";_b "io";_bf "math";_f "os";_d "sort";
_bg "strconv";_e "strings";_fg "unicode";);

// The Image type is used to draw an image onto PDF.
type Image struct{_daef *_cb .XObjectImage ;_aaff *_cb .Image ;_geeg float64 ;_dbf ,_becd float64 ;_fgeb ,_beag float64 ;_adadf Positioning ;_dgfe HorizontalAlignment ;_ged float64 ;_ebdge float64 ;_baeca float64 ;_acbg Margins ;_aaeg ,_ffgd float64 ;_fae _af .StreamEncoder ;
};

// Text sets the text content of the Paragraph.
func (_ggfg *Paragraph )Text ()string {return _ggfg ._fcbd };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_bdgc *Invoice )TotalLines ()[][2]*InvoiceCell {_gcee :=[][2]*InvoiceCell {_bdgc ._gbbb };_gcee =append (_gcee ,_bdgc ._dacdf ...);return append (_gcee ,_bdgc ._fedc );};

// SetBuyerAddress sets the buyer address of the invoice.
func (_dfb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_dfb ._ggba =address };func (_ffb *Block )addContentsByString (_bbg string )error {_cfd :=_fb .NewContentStreamParser (_bbg );_fcb ,_ccg :=_cfd .Parse ();if _ccg !=nil {return _ccg ;};_ffb ._dg .WrapIfNeeded ();
_fcb .WrapIfNeeded ();*_ffb ._dg =append (*_ffb ._dg ,*_fcb ...);return nil ;};

// SetMargins sets the Paragraph's margins.
func (_acag *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_acag ._bcbb .Left =left ;_acag ._bcbb .Right =right ;_acag ._bcbb .Top =top ;_acag ._bcbb .Bottom =bottom ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_gcb *Invoice )SetTerms (title ,content string ){_gcb ._gdbe =[2]string {title ,content }};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cdda *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgbd :=ctx ;_efafb ,ctx ,_ddffd :=_cdda ._ddfc .GeneratePageBlocks (ctx );if _ddffd !=nil {return _efafb ,ctx ,_ddffd ;};if _cdda ._gfea .IsRelative (){ctx .X =_bgbd .X ;
};if _cdda ._gfea .IsAbsolute (){return _efafb ,_bgbd ,nil ;};return _efafb ,ctx ,nil ;};

// SkipOver skips over a specified number of rows and cols.
func (_fbced *Table )SkipOver (rows ,cols int ){_dgdd :=rows *_fbced ._bbac +cols -1;if _dgdd < 0{_c .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_fbced ._agcb +=_dgdd ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func (_baba *pageTransformations )transformPage (_cgb *_cb .PdfPage )error {if _dbgg :=_baba .applyFlip (_cgb );_dbgg !=nil {return _dbgg ;};return nil ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_ddg *Block )ScaleToWidth (w float64 ){_fab :=w /_ddg ._bfc ;_ddg .Scale (_fab ,_fab )};

// SetStyleRight sets border style for right side.
func (_bbc *border )SetStyleRight (style CellBorderStyle ){_bbc ._ade =style };

// SetBorderColor sets the border color for the path.
func (_fafba *FilledCurve )SetBorderColor (color Color ){_fafba ._bebd =color };var PPMM =float64 (72*1.0/25.4);func _eeg (_gef Color )_cb .PdfColor {if _gef ==nil {_gef =ColorBlack ;};switch _eade :=_gef .(type ){case cmykColor :return _cb .NewPdfColorDeviceCMYK (_eade ._caa ,_eade ._ecd ,_eade ._babb ,_eade ._fdf );
};return _cb .NewPdfColorDeviceRGB (_gef .ToRGB ());};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_eddb *StyledParagraph )Height ()float64 {_eddb .wrapText ();var _edffa float64 ;for _ ,_gcfe :=range _eddb ._defff {var _ggec float64 ;for _ ,_ggbfd :=range _gcfe {_dcdff :=_eddb ._bcaa *_ggbfd .Style .FontSize ;if _dcdff > _ggec {_ggec =_dcdff ;
};};_edffa +=_ggec ;};return _edffa ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_acb *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ccgc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aea :=_fce .Circle {X :_acb ._deff -_acb ._adcb /2,Y :ctx .PageHeight -_acb ._dacf -_acb ._fbef /2,Width :_acb ._adcb ,Height :_acb ._fbef ,Opacity :1.0,BorderWidth :_acb ._gadf };
if _acb ._bfdg ==PositionRelative {_aea .X =ctx .X ;_aea .Y =ctx .PageHeight -ctx .Y -_acb ._fbef ;};if _acb ._abeb !=nil {_aea .FillEnabled =true ;_aea .FillColor =_eeg (_acb ._abeb );};if _acb ._egcf !=nil {_aea .BorderEnabled =false ;if _acb ._gadf > 0{_aea .BorderEnabled =true ;
};_aea .BorderColor =_eeg (_acb ._egcf );_aea .BorderWidth =_acb ._gadf ;};_dcgf ,_ ,_fdfb :=_aea .Draw ("");if _fdfb !=nil {return nil ,ctx ,_fdfb ;};_fdfb =_ccgc .addContentsByString (string (_dcgf ));if _fdfb !=nil {return nil ,ctx ,_fdfb ;};return []*Block {_ccgc },ctx ,nil ;
};

// SetIndent sets the left offset of the list when nested into another list.
func (_gccc *List )SetIndent (indent float64 ){_gccc ._gbdf =indent ;_gccc ._adbgb =false };const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetBorderColor sets the border color.
func (_dbec *Ellipse )SetBorderColor (col Color ){_dbec ._egcf =col };

// SetFillColor sets the fill color.
func (_caff *Ellipse )SetFillColor (col Color ){_caff ._abeb =col };func (_cegab *Invoice )drawSection (_addf ,_dgdgb string )[]*StyledParagraph {var _cgbfg []*StyledParagraph ;if _addf !=""{_dgba :=_egeg (_cegab ._cde );_dgba .SetMargins (0,0,0,5);_dgba .Append (_addf );
_cgbfg =append (_cgbfg ,_dgba );};if _dgdgb !=""{_cfgg :=_egeg (_cegab ._fadd );_cfgg .Append (_dgdgb );_cgbfg =append (_cgbfg ,_cfgg );};return _cgbfg ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_eeba *Invoice )Terms ()(string ,string ){return _eeba ._gdbe [0],_eeba ._gdbe [1]};

// SetBackgroundColor sets the cell's background color.
func (_abef *TableCell )SetBackgroundColor (col Color ){_abef ._fddb =col };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_cbec []_fce .CubicBezierCurve ;FillEnabled bool ;_aceef Color ;BorderEnabled bool ;BorderWidth float64 ;_bebd Color ;};

// Height returns the height of the chart.
func (_fef *Chart )Height ()float64 {return float64 (_fef ._cefg .Height ())};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_ccbd *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcdg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fdeee :=_fce .Rectangle {Opacity :1.0,X :_ccbd ._gbcdf ,Y :ctx .PageHeight -_ccbd ._baggf -_ccbd ._fbgee ,Height :_ccbd ._fbgee ,Width :_ccbd ._eab ,BorderRadiusTopLeft :_ccbd ._aggae ,BorderRadiusTopRight :_ccbd ._fdgg ,BorderRadiusBottomLeft :_ccbd ._gedc ,BorderRadiusBottomRight :_ccbd ._fbab };
if _ccbd ._bggff ==PositionRelative {_fdeee .X =ctx .X ;_fdeee .Y =ctx .PageHeight -ctx .Y -_ccbd ._fbgee ;};if _ccbd ._ffba !=nil {_fdeee .FillEnabled =true ;_fdeee .FillColor =_eeg (_ccbd ._ffba );};if _ccbd ._aege !=nil &&_ccbd ._efffa > 0{_fdeee .BorderEnabled =true ;
_fdeee .BorderColor =_eeg (_ccbd ._aege );_fdeee .BorderWidth =_ccbd ._efffa ;};_fbdca ,_gbfaf :=_gcdg .setOpacity (_ccbd ._ecab ,_ccbd ._bcdc );if _gbfaf !=nil {return nil ,ctx ,_gbfaf ;};_afde ,_ ,_gbfaf :=_fdeee .Draw (_fbdca );if _gbfaf !=nil {return nil ,ctx ,_gbfaf ;
};if _gbfaf =_gcdg .addContentsByString (string (_afde ));_gbfaf !=nil {return nil ,ctx ,_gbfaf ;};return []*Block {_gcdg },ctx ,nil ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_beaee []*TextChunk ;_ecfb TextStyle ;_bcgeg TextStyle ;_caca TextAlignment ;_bacg TextVerticalAlignment ;_bcaa float64 ;_aegb bool ;_edff float64 ;_faaa bool ;_decfe TextOverflow ;_ffcb float64 ;_bcbb Margins ;_geegb Positioning ;
_gfae float64 ;_baegd float64 ;_edfff float64 ;_ggcd float64 ;_defff [][]*TextChunk ;_dagd func (_edbfe *StyledParagraph ,_edbg DrawContext );};

// SetWidth sets line width.
func (_fafb *Curve )SetWidth (width float64 ){_fafb ._afe =width };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gfeb *Chapter )SetShowNumbering (show bool ){_gfeb ._abfd =show ;_gfeb ._fcd .SetText (_gfeb .headingText ());};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_gbfae *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ddgfe []*Block ;_fbdc bool ;_agbf error ;_geae =_gbfae ._dfeb .IsRelative ();_fed =_gbfae ._gffe .Top ;);if _geae &&!_gbfae ._cgdgb &&!_gbfae ._dccbd {_cbga :=_gbfae .ctxHeight (ctx .Width -_gbfae ._gffe .Left -_gbfae ._gffe .Right );
if _cbga > ctx .Height -_gbfae ._gffe .Top &&_cbga <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _ddgfe ,ctx ,_agbf =_gefd ().GeneratePageBlocks (ctx );_agbf !=nil {return nil ,ctx ,_agbf ;};_fbdc =true ;_fed =0;};};_dbcd :=ctx ;_egff :=ctx ;
if _geae {ctx .X +=_gbfae ._gffe .Left ;ctx .Y +=_fed ;ctx .Width -=_gbfae ._gffe .Left +_gbfae ._gffe .Right ;ctx .Height -=_fed ;_egff =ctx ;ctx .X +=_gbfae ._dgdg .Left ;ctx .Y +=_gbfae ._dgdg .Top ;ctx .Width -=_gbfae ._dgdg .Left +_gbfae ._dgdg .Right ;
ctx .Height -=_gbfae ._dgdg .Top ;ctx .Margins .Top +=_gbfae ._dgdg .Top ;ctx .Margins .Bottom +=_gbfae ._dgdg .Bottom ;ctx .Margins .Left +=_gbfae ._dgdg .Left ;ctx .Margins .Right +=_gbfae ._dgdg .Right ;};ctx .Inline =_gbfae ._dccbd ;_adda :=ctx ;_gabgd :=ctx ;
var _eeeb float64 ;for _ ,_cfcgd :=range _gbfae ._baecf {if ctx .Inline {if (ctx .X -_adda .X )+_cfcgd .Width ()<=ctx .Width {ctx .Y =_gabgd .Y ;ctx .Height =_gabgd .Height ;}else {ctx .X =_adda .X ;ctx .Width =_adda .Width ;_gabgd .Y +=_eeeb ;_gabgd .Height -=_eeeb ;
_eeeb =0;};};_gdc ,_bddb ,_dacbf :=_cfcgd .GeneratePageBlocks (ctx );if _dacbf !=nil {_c .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_dacbf );
return nil ,ctx ,_dacbf ;};if len (_gdc )< 1{continue ;};if len (_ddgfe )> 0{_ddgfe [len (_ddgfe )-1].mergeBlocks (_gdc [0]);_ddgfe =append (_ddgfe ,_gdc [1:]...);}else {if _cecf :=_gdc [0]._dg ;_cecf ==nil ||len (*_cecf )==0{_fbdc =true ;};_ddgfe =append (_ddgfe ,_gdc [0:]...);
};if ctx .Inline {if ctx .Page !=_bddb .Page {_adda .Y =ctx .Margins .Top ;_adda .Height =ctx .PageHeight -ctx .Margins .Top ;_gabgd .Y =_adda .Y ;_gabgd .Height =_adda .Height ;_eeeb =_bddb .Height -_adda .Height ;}else {if _fbad :=ctx .Height -_bddb .Height ;
_fbad > _eeeb {_eeeb =_fbad ;};};}else {_bddb .X =ctx .X ;};ctx =_bddb ;};ctx .Inline =_dbcd .Inline ;ctx .Margins =_dbcd .Margins ;if _geae {ctx .X =_dbcd .X ;ctx .Width =_dbcd .Width ;ctx .Y +=_gbfae ._dgdg .Bottom ;ctx .Height -=_gbfae ._dgdg .Bottom ;
};if _gbfae ._ddbd !=nil {_ddgfe ,_agbf =_gbfae .drawBackground (_ddgfe ,_egff ,ctx ,_fbdc );if _agbf !=nil {return nil ,ctx ,_agbf ;};};if _gbfae ._dfeb .IsAbsolute (){return _ddgfe ,_dbcd ,nil ;};ctx .Y +=_gbfae ._gffe .Bottom ;ctx .Height -=_gbfae ._gffe .Bottom ;
return _ddgfe ,ctx ,nil ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_cgcc *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _fafa (x1 ,y1 ,x2 ,y2 )};

// GetCoords returns coordinates of border.
func (_cae *border )GetCoords ()(float64 ,float64 ){return _cae ._bbaa ,_cae ._dbd };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_bcdd *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bcdd ._adg .Left ,_bcdd ._adg .Right ,_bcdd ._adg .Top ,_bcdd ._adg .Bottom ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_gbcdf float64 ;_baggf float64 ;_eab float64 ;_fbgee float64 ;_bggff Positioning ;_ffba Color ;_ecab float64 ;_aege Color ;_efffa float64 ;_bcdc float64 ;_aggae float64 ;_fdgg float64 ;_gedc float64 ;_fbab float64 ;};

// SetPositioning sets Ellipse's position attribute.
func (_dbegg *Ellipse )SetPositioning (position Positioning ){_dbegg ._bfdg =position };

// DrawFooter sets a function to draw a footer on created output pages.
func (_ggac *Creator )DrawFooter (drawFooterFunc func (_dcge *Block ,_agd FooterFunctionArgs )){_ggac ._cfa =drawFooterFunc ;};

// SetLineWidth sets the line width.
func (_aeeg *Line )SetLineWidth (lw float64 ){_aeeg ._bfefd =lw };

// NewFilledCurve returns a instance of filled curve.
func (_gfff *Creator )NewFilledCurve ()*FilledCurve {return _gfcab ()};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_efaf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _efaf ._gbbb [0],_efaf ._gbbb [1]};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_bbfb *Invoice )SetNoteStyle (style TextStyle ){_bbfb ._fadd =style };func (_cbgg *Division )drawBackground (_fdcf []*Block ,_fece ,_deebg DrawContext ,_bbde bool )([]*Block ,error ){_dbgf :=len (_fdcf );if _dbgf ==0||_cbgg ._ddbd ==nil {return _fdcf ,nil ;
};_cbbe :=make ([]*Block ,0,len (_fdcf ));for _beegd ,_aeec :=range _fdcf {var (_defe =_cbgg ._ddbd .BorderRadiusTopLeft ;_gcad =_cbgg ._ddbd .BorderRadiusTopRight ;_gfdbc =_cbgg ._ddbd .BorderRadiusBottomLeft ;_agab =_cbgg ._ddbd .BorderRadiusBottomRight ;
);_dfa :=_fece ;_dfa .Page +=_beegd ;if _beegd ==0{if _bbde {_cbbe =append (_cbbe ,_aeec );continue ;};if _dbgf ==1{_dfa .Height =_deebg .Y -_fece .Y ;};}else {_dfa .X =_dfa .Margins .Left +_cbgg ._gffe .Left ;_dfa .Y =_dfa .Margins .Top ;_dfa .Width =_dfa .PageWidth -_dfa .Margins .Left -_dfa .Margins .Right -_cbgg ._gffe .Left -_cbgg ._gffe .Right ;
if _beegd ==_dbgf -1{_dfa .Height =_deebg .Y -_dfa .Margins .Top -_cbgg ._gffe .Top ;}else {_dfa .Height =_dfa .PageHeight -_dfa .Margins .Top -_dfa .Margins .Bottom ;};if !_bbde {_defe =0;_gcad =0;};};if _dbgf > 1&&_beegd !=_dbgf -1{_gfdbc =0;_agab =0;
};_edd :=_eebc (_dfa .X ,_dfa .Y ,_dfa .Width ,_dfa .Height );_edd .SetFillColor (_cbgg ._ddbd .FillColor );_edd .SetBorderColor (_cbgg ._ddbd .BorderColor );_edd .SetBorderWidth (_cbgg ._ddbd .BorderSize );_edd .SetBorderRadius (_defe ,_gcad ,_gfdbc ,_agab );
_beaa ,_ ,_ebfbf :=_edd .GeneratePageBlocks (_dfa );if _ebfbf !=nil {return nil ,_ebfbf ;};if len (_beaa )==0{continue ;};_dcae :=_beaa [0];if _ebfbf =_dcae .mergeBlocks (_aeec );_ebfbf !=nil {return nil ,_ebfbf ;};_cbbe =append (_cbbe ,_dcae );};return _cbbe ,nil ;
};

// IsAbsolute checks if the positioning is absolute.
func (_bdcg Positioning )IsAbsolute ()bool {return _bdcg ==PositionAbsolute };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_eegb []*_cb .PdfPage ;_bdec map[*_cb .PdfPage ]*Block ;_ebfd map[*_cb .PdfPage ]*pageTransformations ;_baec *_cb .PdfPage ;_aeeb PageSize ;_fcdd DrawContext ;_bgcf Margins ;_caf ,_gdbg float64 ;_bged int ;_gad func (_eaa FrontpageFunctionArgs );
_bfe func (_dbg *TOC )error ;_fgfg func (_bdb *Block ,_efac HeaderFunctionArgs );_cfa func (_beac *Block ,_fdab FooterFunctionArgs );_eba func (_ecdc PageFinalizeFunctionArgs )error ;_edcg func (_bdae *_cb .PdfWriter )error ;_aag bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_cdca *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gdf *_cb .Outline ;_befg *_cb .PdfOutlineTreeNode ;_efd *_cb .PdfAcroForm ;_cfdd _af .PdfObject ;_cege _cb .Optimizer ;_dcgd []*_cb .PdfFont ;_bfde *_cb .PdfFont ;_ffdb *_cb .PdfFont ;};

// SkipRows skips over a specified number of rows in the table.
func (_bedca *Table )SkipRows (num int ){_acad :=num *_bedca ._bbac -1;if _acad < 0{_c .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_bedca ._agcb +=_acad ;};

// Height returns the height of the list.
func (_ggg *List )Height ()float64 {var _adab float64 ;for _ ,_debe :=range _ggg ._bfed {_adab +=_debe ._degd .Height ();};return _adab ;};

// SetOpacity sets opacity for Image.
func (_caccc *Image )SetOpacity (opacity float64 ){_caccc ._baeca =opacity };

// SetText replaces all the text of the paragraph with the specified one.
func (_cdfgb *StyledParagraph )SetText (text string )*TextChunk {_cdfgb .Reset ();return _cdfgb .Append (text );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fege *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcga :=ctx ;_adcd :=[]func (_cebf DrawContext )([]*Block ,DrawContext ,error ){_fege .generateHeaderBlocks ,_fege .generateInformationBlocks ,_fege .generateLineBlocks ,_fege .generateTotalBlocks ,_fege .generateNoteBlocks };
var _fdgd []*Block ;for _ ,_cgcd :=range _adcd {_ebdf ,_dfea ,_dbde :=_cgcd (ctx );if _dbde !=nil {return _fdgd ,ctx ,_dbde ;};if len (_fdgd )==0{_fdgd =_ebdf ;}else if len (_ebdf )> 0{_fdgd [len (_fdgd )-1].mergeBlocks (_ebdf [0]);_fdgd =append (_fdgd ,_ebdf [1:]...);
};ctx =_dfea ;};if _fege ._agegf .IsRelative (){ctx .X =_dcga .X ;};if _fege ._agegf .IsAbsolute (){return _fdgd ,_dcga ,nil ;};return _fdgd ,ctx ,nil ;};

// SetWidthTop sets border width for top.
func (_dbc *border )SetWidthTop (bw float64 ){_dbc ._ca =bw };

// GeneratePageBlocks implements drawable interface.
func (_abbe *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afdd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ddbe :=_abbe ._bbaa ;_ccd :=ctx .PageHeight -_abbe ._dbd ;if _abbe ._fgge !=nil {_bdc :=_fce .Rectangle {Opacity :1.0,X :_abbe ._bbaa ,Y :ctx .PageHeight -_abbe ._dbd -_abbe ._efc ,Height :_abbe ._efc ,Width :_abbe ._cbbc };
_bdc .FillEnabled =true ;_bdc .FillColor =_eeg (_abbe ._fgge );_bdc .BorderEnabled =false ;_fgfc ,_ ,_cdd :=_bdc .Draw ("");if _cdd !=nil {return nil ,ctx ,_cdd ;};_cdd =_afdd .addContentsByString (string (_fgfc ));if _cdd !=nil {return nil ,ctx ,_cdd ;
};};_aff :=_abbe ._ca ;_dacc :=_abbe ._dcdf ;_abbf :=_abbe ._degc ;_gbcd :=_abbe ._abf ;_ccb :=_abbe ._ca ;if _abbe ._bfa ==CellBorderStyleDouble {_ccb +=2*_aff ;};_cac :=_abbe ._dcdf ;if _abbe ._ddd ==CellBorderStyleDouble {_cac +=2*_dacc ;};_bed :=_abbe ._degc ;
if _abbe ._dcff ==CellBorderStyleDouble {_bed +=2*_abbf ;};_agbd :=_abbe ._abf ;if _abbe ._ade ==CellBorderStyleDouble {_agbd +=2*_gbcd ;};_aafc :=(_ccb -_bed )/2;_gac :=(_ccb -_agbd )/2;_adad :=(_cac -_bed )/2;_bfd :=(_cac -_agbd )/2;if _abbe ._ca !=0{_gegb :=_ddbe ;
_cbc :=_ccd ;if _abbe ._bfa ==CellBorderStyleDouble {_cbc -=_aff ;_fea :=_fce .BasicLine {LineColor :_eeg (_abbe ._cfg ),Opacity :1.0,LineWidth :_abbe ._ca ,LineStyle :_abbe .LineStyle ,X1 :_gegb -_ccb /2+_aafc ,Y1 :_cbc +2*_aff ,X2 :_gegb +_ccb /2-_gac +_abbe ._cbbc ,Y2 :_cbc +2*_aff };
_bccd ,_ ,_caec :=_fea .Draw ("");if _caec !=nil {return nil ,ctx ,_caec ;};_caec =_afdd .addContentsByString (string (_bccd ));if _caec !=nil {return nil ,ctx ,_caec ;};};_abce :=_fce .BasicLine {LineWidth :_abbe ._ca ,Opacity :1.0,LineColor :_eeg (_abbe ._cfg ),LineStyle :_abbe .LineStyle ,X1 :_gegb -_ccb /2+_aafc +(_bed -_abbe ._degc ),Y1 :_cbc ,X2 :_gegb +_ccb /2-_gac +_abbe ._cbbc -(_agbd -_abbe ._abf ),Y2 :_cbc };
_faba ,_ ,_bgcd :=_abce .Draw ("");if _bgcd !=nil {return nil ,ctx ,_bgcd ;};_bgcd =_afdd .addContentsByString (string (_faba ));if _bgcd !=nil {return nil ,ctx ,_bgcd ;};};if _abbe ._dcdf !=0{_dea :=_ddbe ;_dcg :=_ccd -_abbe ._efc ;if _abbe ._ddd ==CellBorderStyleDouble {_dcg +=_dacc ;
_eebf :=_fce .BasicLine {LineWidth :_abbe ._dcdf ,Opacity :1.0,LineColor :_eeg (_abbe ._ffea ),LineStyle :_abbe .LineStyle ,X1 :_dea -_cac /2+_adad ,Y1 :_dcg -2*_dacc ,X2 :_dea +_cac /2-_bfd +_abbe ._cbbc ,Y2 :_dcg -2*_dacc };_dbdd ,_ ,_bbga :=_eebf .Draw ("");
if _bbga !=nil {return nil ,ctx ,_bbga ;};_bbga =_afdd .addContentsByString (string (_dbdd ));if _bbga !=nil {return nil ,ctx ,_bbga ;};};_accd :=_fce .BasicLine {LineWidth :_abbe ._dcdf ,Opacity :1.0,LineColor :_eeg (_abbe ._ffea ),LineStyle :_abbe .LineStyle ,X1 :_dea -_cac /2+_adad +(_bed -_abbe ._degc ),Y1 :_dcg ,X2 :_dea +_cac /2-_bfd +_abbe ._cbbc -(_agbd -_abbe ._abf ),Y2 :_dcg };
_agf ,_ ,_edbe :=_accd .Draw ("");if _edbe !=nil {return nil ,ctx ,_edbe ;};_edbe =_afdd .addContentsByString (string (_agf ));if _edbe !=nil {return nil ,ctx ,_edbe ;};};if _abbe ._degc !=0{_cad :=_ddbe ;_ebbd :=_ccd ;if _abbe ._dcff ==CellBorderStyleDouble {_cad +=_abbf ;
_gga :=_fce .BasicLine {LineWidth :_abbe ._degc ,Opacity :1.0,LineColor :_eeg (_abbe ._gfe ),LineStyle :_abbe .LineStyle ,X1 :_cad -2*_abbf ,Y1 :_ebbd +_bed /2+_aafc ,X2 :_cad -2*_abbf ,Y2 :_ebbd -_bed /2-_adad -_abbe ._efc };_ebc ,_ ,_ddag :=_gga .Draw ("");
if _ddag !=nil {return nil ,ctx ,_ddag ;};_ddag =_afdd .addContentsByString (string (_ebc ));if _ddag !=nil {return nil ,ctx ,_ddag ;};};_daa :=_fce .BasicLine {LineWidth :_abbe ._degc ,Opacity :1.0,LineColor :_eeg (_abbe ._gfe ),LineStyle :_abbe .LineStyle ,X1 :_cad ,Y1 :_ebbd +_bed /2+_aafc -(_ccb -_abbe ._ca ),X2 :_cad ,Y2 :_ebbd -_bed /2-_adad -_abbe ._efc +(_cac -_abbe ._dcdf )};
_afa ,_ ,_geb :=_daa .Draw ("");if _geb !=nil {return nil ,ctx ,_geb ;};_geb =_afdd .addContentsByString (string (_afa ));if _geb !=nil {return nil ,ctx ,_geb ;};};if _abbe ._abf !=0{_aaed :=_ddbe +_abbe ._cbbc ;_bbe :=_ccd ;if _abbe ._ade ==CellBorderStyleDouble {_aaed -=_gbcd ;
_ebf :=_fce .BasicLine {LineWidth :_abbe ._abf ,Opacity :1.0,LineColor :_eeg (_abbe ._dec ),LineStyle :_abbe .LineStyle ,X1 :_aaed +2*_gbcd ,Y1 :_bbe +_agbd /2+_gac ,X2 :_aaed +2*_gbcd ,Y2 :_bbe -_agbd /2-_bfd -_abbe ._efc };_edbf ,_ ,_cace :=_ebf .Draw ("");
if _cace !=nil {return nil ,ctx ,_cace ;};_cace =_afdd .addContentsByString (string (_edbf ));if _cace !=nil {return nil ,ctx ,_cace ;};};_dgf :=_fce .BasicLine {LineWidth :_abbe ._abf ,Opacity :1.0,LineColor :_eeg (_abbe ._dec ),LineStyle :_abbe .LineStyle ,X1 :_aaed ,Y1 :_bbe +_agbd /2+_gac -(_ccb -_abbe ._ca ),X2 :_aaed ,Y2 :_bbe -_agbd /2-_bfd -_abbe ._efc +(_cac -_abbe ._dcdf )};
_afb ,_ ,_baa :=_dgf .Draw ("");if _baa !=nil {return nil ,ctx ,_baa ;};_baa =_afdd .addContentsByString (string (_afb ));if _baa !=nil {return nil ,ctx ,_baa ;};};return []*Block {_afdd },ctx ,nil ;};func (_cfeb *StyledParagraph )split (_caag DrawContext )(_gceec ,_dbfa *StyledParagraph ,_dbbbb error ){if _dbbbb =_cfeb .wrapChunks (false );
_dbbbb !=nil {return nil ,nil ,_dbbbb ;};_efge :=func (_ebdb []*TextChunk ,_dbae []*TextChunk )[]*TextChunk {if len (_dbae )==0{return _ebdb ;};_gefae :=len (_ebdb );if _gefae ==0{return append (_ebdb ,_dbae ...);};_ebdb [_gefae -1].Text +=_dbae [0].Text ;
return append (_ebdb ,_dbae [1:]...);};_faag :=func (_facb *StyledParagraph ,_gaed []*TextChunk )*StyledParagraph {if len (_gaed )==0{return nil ;};_eggf :=*_facb ;_eggf ._beaee =_gaed ;return &_eggf ;};var (_eaf float64 ;_gggg []*TextChunk ;_bafg []*TextChunk ;
);for _ ,_ggaf :=range _cfeb ._defff {var _dddc float64 ;_ddec :=make ([]*TextChunk ,0,len (_ggaf ));for _ ,_ccdf :=range _ggaf {if _ddfeg :=_ccdf .Style .FontSize ;_ddfeg > _dddc {_dddc =_ddfeg ;};_ddec =append (_ddec ,_ccdf .clone ());};_dddc *=_cfeb ._bcaa ;
if _cfeb ._geegb .IsRelative (){if _eaf +_dddc > _caag .Height {_bafg =_efge (_bafg ,_ddec );}else {_gggg =_efge (_gggg ,_ddec );};};_eaf +=_dddc ;};_cfeb ._defff =nil ;if len (_bafg )==0{return _cfeb ,nil ,nil ;};return _faag (_cfeb ,_gggg ),_faag (_cfeb ,_bafg ),nil ;
};

// Context returns the current drawing context.
func (_bfg *Creator )Context ()DrawContext {return _bfg ._fcdd };func (_bbbe *StyledParagraph )getTextLineWidth (_bgef []*TextChunk )float64 {var _babgb float64 ;_cdafgc :=len (_bgef );for _fcafb ,_gbfd :=range _bgef {_cegfb :=&_gbfd .Style ;_cbdg :=len (_gbfd .Text );
for _gdcbc ,_bbae :=range _gbfd .Text {if _bbae =='\u000A'{continue ;};_bbfa ,_efdea :=_cegfb .Font .GetRuneMetrics (_bbae );if !_efdea {_c .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bbae );
return -1;};_babgb +=_cegfb .FontSize *_bbfa .Wx *_cegfb .horizontalScale ();if _bbae !=' '&&(_fcafb !=_cdafgc -1||_gdcbc !=_cbdg -1){_babgb +=_cegfb .CharSpacing *1000.0;};};};return _babgb ;};

// SetMargins sets the margins of the chart component.
func (_cbbb *Chart )SetMargins (left ,right ,top ,bottom float64 ){_cbbb ._ceg .Left =left ;_cbbb ._ceg .Right =right ;_cbbb ._ceg .Top =top ;_cbbb ._ceg .Bottom =bottom ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_bggfe *TextChunk )SetAnnotation (annotation *_cb .PdfAnnotation ){_bggfe ._gdda =annotation };

// Width returns the width of the Paragraph.
func (_bcga *Paragraph )Width ()float64 {if _bcga ._cccg &&int (_bcga ._gbfe )> 0{return _bcga ._gbfe ;};return _bcga .getTextWidth ()/1000.0;};func _fafa (_acgbc ,_afdg ,_fgcc ,_bfaa float64 )*Line {_ffgdb :=&Line {};_ffgdb ._eae =_acgbc ;_ffgdb ._adce =_afdg ;
_ffgdb ._ggbe =_fgcc ;_ffgdb ._bceb =_bfaa ;_ffgdb ._ecfd =ColorBlack ;_ffgdb ._bfefd =1.0;return _ffgdb ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_cdg *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_cdg ._bgcf .Left =left ;_cdg ._bgcf .Right =right ;_cdg ._bgcf .Top =top ;_cdg ._bgcf .Bottom =bottom ;};

// Width returns the current page width.
func (_bebf *Creator )Width ()float64 {return _bebf ._caf };

// CreateTableOfContents sets a function to generate table of contents.
func (_begfc *Creator )CreateTableOfContents (genTOCFunc func (_baee *TOC )error ){_begfc ._bfe =genTOCFunc ;};

// AddLine appends a new line to the invoice line items table.
func (_ecdd *Invoice )AddLine (values ...string )[]*InvoiceCell {_cefe :=len (_ecdd ._efdf );var _gccg []*InvoiceCell ;for _dbggad ,_bgde :=range values {_bggc :=_ecdd .newCell (_bgde ,_ecdd ._cfbe );if _dbggad < _cefe {_bggc .Alignment =_ecdd ._efdf [_dbggad ].Alignment ;
};_gccg =append (_gccg ,_bggc );};_ecdd ._bcff =append (_ecdd ._bcff ,_gccg );return _gccg ;};func (_dgcc *Paragraph )getTextWidth ()float64 {_ddfe :=0.0;for _ ,_aggdf :=range _dgcc ._fcbd {if _aggdf =='\u000A'{continue ;};_ebffc ,_adcea :=_dgcc ._afad .GetRuneMetrics (_aggdf );
if !_adcea {_c .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_aggdf ,_aggdf );
return -1;};_ddfe +=_dgcc ._ccfe *_ebffc .Wx ;};return _ddfe ;};

// SetPositioning sets Rectangle's position attribute.
func (_ebgg *Rectangle )SetPositioning (position Positioning ){_ebgg ._bggff =position };const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);

// NewSubchapter creates a new child chapter with the specified title.
func (_fabf *Chapter )NewSubchapter (title string )*Chapter {_efa :=_gabe (_fabf ._fcd ._afad );_efa .FontSize =14;_fabf ._ffd ++;_bec :=_badg (_fabf ,_fabf ._fceb ,_fabf ._bab ,title ,_fabf ._ffd ,_efa );_fabf .Add (_bec );return _bec ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_beda *Creator )NewImage (img *_cb .Image )(*Image ,error ){return _agced (img )};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_eegf *Rectangle )GetCoords ()(float64 ,float64 ){return _eegf ._gbcdf ,_eegf ._baggf };

// GeneratePageBlocks draws the chart onto a block.
func (_cdbb *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebba :=ctx ;_gdg :=_cdbb ._afbb .IsRelative ();var _cgfc []*Block ;if _gdg {_dcffa :=1.0;_cge :=_cdbb ._ceg .Top ;if float64 (_cdbb ._cefg .Height ())> ctx .Height -_cdbb ._ceg .Top {_cgfc =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _agg error ;if _ ,ctx ,_agg =_gefd ().GeneratePageBlocks (ctx );_agg !=nil {return nil ,ctx ,_agg ;};_cge =0;};ctx .X +=_cdbb ._ceg .Left +_dcffa ;ctx .Y +=_cge ;ctx .Width -=_cdbb ._ceg .Left +_cdbb ._ceg .Right +2*_dcffa ;ctx .Height -=_cge ;_cdbb ._cefg .SetWidth (int (ctx .Width ));
}else {ctx .X =_cdbb ._fbfd ;ctx .Y =_cdbb ._agec ;};_fec :=_fb .NewContentCreator ();_fec .Translate (0,ctx .PageHeight );_fec .Scale (1,-1);_fec .Translate (ctx .X ,ctx .Y );_gfca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdbb ._cefg .Render (_dd .NewRenderer (_fec ,_gfca ._ba ),nil );
if _aee :=_gfca .addContentsByString (_fec .String ());_aee !=nil {return nil ,ctx ,_aee ;};if _gdg {_daaa :=_cdbb .Height ()+_cdbb ._ceg .Bottom ;ctx .Y +=_daaa ;ctx .Height -=_daaa ;}else {ctx =_ebba ;};_cgfc =append (_cgfc ,_gfca );return _cgfc ,ctx ,nil ;
};

// SetBorderWidth sets the border width.
func (_ddacc *Polygon )SetBorderWidth (borderWidth float64 ){_ddacc ._gged .BorderWidth =borderWidth };

// SetLogo sets the logo of the invoice.
func (_abcec *Invoice )SetLogo (logo *Image ){_abcec ._dada =logo };

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_dagb *Image )SetMargins (left ,right ,top ,bottom float64 ){_dagb ._acbg .Left =left ;_dagb ._acbg .Right =right ;_dagb ._acbg .Top =top ;_dagb ._acbg .Bottom =bottom ;};func _ebdg (_dbeg ,_afdb ,_agbfa ,_bdfd float64 )*Ellipse {_cdccd :=&Ellipse {};
_cdccd ._deff =_dbeg ;_cdccd ._dacf =_afdb ;_cdccd ._adcb =_agbfa ;_cdccd ._fbef =_bdfd ;_cdccd ._bfdg =PositionAbsolute ;_cdccd ._egcf =ColorBlack ;_cdccd ._gadf =1.0;return _cdccd ;};func _gcafe (_ceee ,_adbe ,_aeee ,_cgbd ,_gfcc ,_acdg float64 )*Curve {_ceac :=&Curve {};
_ceac ._eced =_ceee ;_ceac ._bdce =_adbe ;_ceac ._aedd =_aeee ;_ceac ._ccba =_cgbd ;_ceac ._dbbb =_gfcc ;_ceac ._gcg =_acdg ;_ceac ._ccab =ColorBlack ;_ceac ._afe =1.0;return _ceac ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_cbcc *Image )SetEncoder (encoder _af .StreamEncoder ){_cbcc ._fae =encoder };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_aeda *Creator )NewImageFromGoImage (goimg _aa .Image )(*Image ,error ){return _gadgb (goimg )};

// NewList creates a new list.
func (_dbdde *Creator )NewList ()*List {return _caae (_dbdde .NewTextStyle ())};

// SetNotes sets the notes section of the invoice.
func (_aeea *Invoice )SetNotes (title ,content string ){_aeea ._gbbf =[2]string {title ,content }};

// SetAngle sets the rotation angle of the text.
func (_dgdc *StyledParagraph )SetAngle (angle float64 ){_dgdc ._ffcb =angle };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_gcag *List )Marker ()*TextChunk {return &_gcag ._daee };type rgbColor struct{_cfdc ,_ace ,_bge float64 };

// SetBorderOpacity sets the border opacity.
func (_adec *CurvePolygon )SetBorderOpacity (opacity float64 ){_adec ._geebb =opacity };

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_caa :_bf .Max (_bf .Min (c ,1.0),0.0),_ecd :_bf .Max (_bf .Min (m ,1.0),0.0),_babb :_bf .Max (_bf .Min (y ,1.0),0.0),_fdf :_bf .Max (_bf .Min (k ,1.0),0.0)};};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_gbgb *Creator )Flip (flipH ,flipV bool )error {_beca :=_gbgb .getActivePage ();if _beca ==nil {return _g .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_fgd ,_decf :=_gbgb ._ebfd [_beca ];if !_decf {_fgd =&pageTransformations {};
_gbgb ._ebfd [_beca ]=_fgd ;};_fgd ._gbe =flipH ;_fgd ._cdfa =flipV ;return nil ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_eae float64 ;_adce float64 ;_ggbe float64 ;_bceb float64 ;_ecfd Color ;_bfefd float64 ;};

// SetColorTop sets border color for top.
func (_age *border )SetColorTop (col Color ){_age ._cfg =col };

// SetPos sets absolute positioning with specified coordinates.
func (_begfce *Paragraph )SetPos (x ,y float64 ){_begfce ._gbeaa =PositionAbsolute ;_begfce ._ceeec =x ;_begfce ._abfdg =y ;};

// SetFillColor sets the fill color.
func (_ebe *CurvePolygon )SetFillColor (color Color ){_ebe ._dcfcf .FillColor =_eeg (color )};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_afg *Invoice )SetAddressStyle (style TextStyle ){_afg ._dff =style };

// Margins returns the margins of the component.
func (_eaaeg *Division )Margins ()(_babg ,_gge ,_egca ,_ebfb float64 ){return _eaaeg ._gffe .Left ,_eaaeg ._gffe .Right ,_eaaeg ._gffe .Top ,_eaaeg ._gffe .Bottom ;};

// SetMargins sets the Paragraph's margins.
func (_baafb *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_baafb ._ceff .Left =left ;_baafb ._ceff .Right =right ;_baafb ._ceff .Top =top ;_baafb ._ceff .Bottom =bottom ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_gbga *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_gbga ._bacg =align ;};

// SetBorder sets the cell's border style.
func (_efbc *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_efbc ._aadbb =CellBorderStyleSingle ;_efbc ._ffcd =width ;_efbc ._cafbd =CellBorderStyleSingle ;
_efbc ._gdcc =width ;_efbc ._cbae =CellBorderStyleSingle ;_efbc ._bfdb =width ;_efbc ._edde =CellBorderStyleSingle ;_efbc ._cecbb =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_efbc ._aadbb =CellBorderStyleDouble ;_efbc ._ffcd =width ;
_efbc ._cafbd =CellBorderStyleDouble ;_efbc ._gdcc =width ;_efbc ._cbae =CellBorderStyleDouble ;_efbc ._bfdb =width ;_efbc ._edde =CellBorderStyleDouble ;_efbc ._cecbb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_efbc ._aadbb =style ;
_efbc ._ffcd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_efbc ._cafbd =style ;_efbc ._gdcc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_efbc ._cbae =style ;
_efbc ._bfdb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_efbc ._edde =style ;_efbc ._cecbb =width ;};};

// SetTitleStyle sets the style properties of the invoice title.
func (_ggd *Invoice )SetTitleStyle (style TextStyle ){_ggd ._bbgg =style };

// SetTotal sets the total of the invoice.
func (_cfae *Invoice )SetTotal (value string ){_cfae ._fedc [1].Value =value };func (_gdcb *Image )makeXObject ()error {_dgef :=_gdcb ._fae ;if _dgef ==nil {_dgef =_af .NewFlateEncoder ();};_aac ,_affd :=_cb .NewXObjectImageFromImage (_gdcb ._aaff ,nil ,_dgef );
if _affd !=nil {_c .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_affd );return _affd ;};_gdcb ._daef =_aac ;
return nil ;};

// NewPolyline creates a new polyline.
func (_fge *Creator )NewPolyline (points []_fce .Point )*Polyline {return _egfe (points )};

// SetBorderWidth sets the border width.
func (_bcgd *Ellipse )SetBorderWidth (bw float64 ){_bcgd ._gadf =bw };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_gafg *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_faef ,_fcaf :=_cdba .setOpacity (_gafg ._aebf ,_gafg ._aebf );if _fcaf !=nil {return nil ,ctx ,_fcaf ;};_bbgca :=_gafg ._abdb .Points ;
for _dbga :=range _bbgca {_cgcb :=&_bbgca [_dbga ];_cgcb .Y =ctx .PageHeight -_cgcb .Y ;};_feaa ,_ ,_fcaf :=_gafg ._abdb .Draw (_faef );if _fcaf !=nil {return nil ,ctx ,_fcaf ;};if _fcaf =_cdba .addContentsByString (string (_feaa ));_fcaf !=nil {return nil ,ctx ,_fcaf ;
};return []*Block {_cdba },ctx ,nil ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_geea *Invoice )NoteHeadingStyle ()TextStyle {return _geea ._cde };

// SetBorderColor sets border color.
func (_dcfa *Rectangle )SetBorderColor (col Color ){_dcfa ._aege =col };func _egd (_fcee VectorDrawable ,_aede float64 )float64 {switch _cfee :=_fcee .(type ){case *Paragraph :if _cfee ._cccg {_cfee .SetWidth (_aede );};return _cfee .Height ()+_cfee ._ceff .Top +_cfee ._ceff .Bottom ;
case *StyledParagraph :if _cfee ._aegb {_cfee .SetWidth (_aede );};return _cfee .Height ()+_cfee ._bcbb .Top +_cfee ._bcbb .Bottom ;case marginDrawable :_ ,_ ,_adeb ,_bbgad :=_cfee .GetMargins ();return _cfee .Height ()+_adeb +_bbgad ;default:return _cfee .Height ();
};};

// NewTOCLine creates a new table of contents line with the default style.
func (_agcg *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _gfccg (number ,title ,page ,level ,_agcg .NewTextStyle ());};

// Lines returns all the lines the table of contents has.
func (_eagdd *TOC )Lines ()[]*TOCLine {return _eagdd ._ecgb };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// SetFontSize sets the font size in document units (points).
func (_eead *Paragraph )SetFontSize (fontSize float64 ){_eead ._ccfe =fontSize };

// MoveX moves the drawing context to absolute position x.
func (_bfgc *Creator )MoveX (x float64 ){_bfgc ._fcdd .X =x };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetWidthLeft sets border width for left.
func (_fgf *border )SetWidthLeft (bw float64 ){_fgf ._degc =bw };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);
ColorYellow =ColorRGBFromArithmetic (1,1,0););func _gfa (_bfaf string )(*Image ,error ){_dead ,_bfdab :=_f .Open (_bfaf );if _bfdab !=nil {return nil ,_bfdab ;};defer _dead .Close ();_fbbb ,_bfdab :=_cb .ImageHandling .Read (_dead );if _bfdab !=nil {_c .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bfdab );
return nil ,_bfdab ;};return _agced (_fbbb );};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_gdbf *Division )Height ()float64 {var _fdcc float64 ;for _ ,_efffd :=range _gdbf ._baecf {switch _ecca :=_efffd .(type ){case marginDrawable :_ ,_ ,_bbgc ,_fga :=_ecca .GetMargins ();_fdcc +=_ecca .Height ()+_bbgc +_fga ;default:_fdcc +=_ecca .Height ();
};};return _fdcc ;};

// SetBorderColor sets the cell's border color.
func (_agbdc *TableCell )SetBorderColor (col Color ){_agbdc ._gecf =col ;_agbdc ._debg =col ;_agbdc ._caeda =col ;_agbdc ._ggeg =col ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_cfdc :_bf .Max (_bf .Min (r ,1.0),0.0),_ace :_bf .Max (_bf .Min (g ,1.0),0.0),_bge :_bf .Max (_bf .Min (b ,1.0),0.0)};};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_cdgd *Table )NewCell ()*TableCell {return _cdgd .MultiCell (1,1)};func (_ddfb *Creator )getActivePage ()*_cb .PdfPage {if _ddfb ._baec ==nil {if len (_ddfb ._eegb )==0{return nil ;};return _ddfb ._eegb [len (_ddfb ._eegb )-1];};return _ddfb ._baec ;
};

// BuyerAddress returns the buyer address used in the invoice template.
func (_bgg *Invoice )BuyerAddress ()*InvoiceAddress {return _bgg ._ggba };func (_bdcb *Table )updateRowHeights (_ffbbg float64 ){for _ ,_cdec :=range _bdcb ._caccb {_dcgg :=_cdec .width (_bdcb ._cbbda ,_ffbbg );_bdade :=_bdcb ._cede [_cdec ._ddfbb +_cdec ._bgfcd -2];
if _dfead :=_cdec .height (_dcgg );_dfead > _bdade {_fee :=_dfead /float64 (_cdec ._bgfcd );for _aeaa :=1;_aeaa <=_cdec ._bgfcd ;_aeaa ++{if _fee > _bdcb ._cede [_cdec ._ddfbb +_aeaa -2]{_bdcb ._cede [_cdec ._ddfbb +_aeaa -2]=_fee ;};};};};};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_fabe *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eaae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ccbg ,_dbab :=_eaae .setOpacity (_fabe ._bgec ,_fabe ._geebb );if _dbab !=nil {return nil ,ctx ,_dbab ;
};_ddc :=_fabe ._dcfcf ;_ddc .FillEnabled =_ddc .FillColor !=nil ;_ddc .BorderEnabled =_ddc .BorderColor !=nil &&_ddc .BorderWidth > 0;var (_edga =ctx .PageHeight ;_gaad =_ddc .Rings ;_cgdfdg =make ([][]_fce .CubicBezierCurve ,0,len (_ddc .Rings )););for _ ,_ede :=range _gaad {_gfbb :=make ([]_fce .CubicBezierCurve ,0,len (_ede ));
for _ ,_dfdf :=range _ede {_bbcb :=_dfdf ;_bbcb .P0 .Y =_edga -_bbcb .P0 .Y ;_bbcb .P1 .Y =_edga -_bbcb .P1 .Y ;_bbcb .P2 .Y =_edga -_bbcb .P2 .Y ;_bbcb .P3 .Y =_edga -_bbcb .P3 .Y ;_gfbb =append (_gfbb ,_bbcb );};_cgdfdg =append (_cgdfdg ,_gfbb );};_ddc .Rings =_cgdfdg ;
defer func (){_ddc .Rings =_gaad }();_efgf ,_ ,_dbab :=_ddc .Draw (_ccbg );if _dbab !=nil {return nil ,ctx ,_dbab ;};if _dbab =_eaae .addContentsByString (string (_efgf ));_dbab !=nil {return nil ,ctx ,_dbab ;};return []*Block {_eaae },ctx ,nil ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_ecce *Table )MultiColCell (colspan int )*TableCell {return _ecce .MultiCell (1,colspan )};func _agccb (_gbbba *Block ,_efgef *StyledParagraph ,_baafe [][]*TextChunk ,_eaaa DrawContext )(DrawContext ,[][]*TextChunk ,error ){_faab :=1;_bddg :=_af .PdfObjectName (_fc .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_faab ));
for _gbbba ._ba .HasFontByName (_bddg ){_faab ++;_bddg =_af .PdfObjectName (_fc .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_faab ));};_ggbag :=_gbbba ._ba .SetFontByName (_bddg ,_efgef ._ecfb .Font .ToPdfObject ());if _ggbag !=nil {return _eaaa ,nil ,_ggbag ;
};_faab ++;_gegba :=_bddg ;_fbbae :=_efgef ._ecfb .FontSize ;_gcbe :=_efgef ._geegb .IsRelative ();var _aegf [][]_af .PdfObjectName ;var _aaagc [][]*TextChunk ;var _eebfc float64 ;for _dbcfb ,_cdbcf :=range _baafe {var _ccabc []_af .PdfObjectName ;var _gbbg float64 ;
if len (_cdbcf )> 0{_gbbg =_cdbcf [0].Style .FontSize ;};for _ ,_ecga :=range _cdbcf {_eecf :=_ecga .Style ;if _ecga .Text !=""&&_eecf .FontSize > _gbbg {_gbbg =_eecf .FontSize ;};_bddg =_af .PdfObjectName (_fc .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_faab ));
_cfeeb :=_gbbba ._ba .SetFontByName (_bddg ,_eecf .Font .ToPdfObject ());if _cfeeb !=nil {return _eaaa ,nil ,_cfeeb ;};_ccabc =append (_ccabc ,_bddg );_faab ++;};_gbbg *=_efgef ._bcaa ;if _gcbe &&_eebfc +_gbbg > _eaaa .Height {_aaagc =_baafe [_dbcfb :];
_baafe =_baafe [:_dbcfb ];break ;};_eebfc +=_gbbg ;_aegf =append (_aegf ,_ccabc );};_ddge ,_agae ,_eggge :=_efgef .getLineMetrics (0);_dfgc ,_agdc :=_ddge *_efgef ._bcaa ,_agae *_efgef ._bcaa ;if len (_baafe )==0{return _eaaa ,_aaagc ,nil ;};_gcce :=_fb .NewContentCreator ();
_gcce .Add_q ();_gddf :=_agdc ;if _efgef ._bacg ==TextVerticalAlignmentCenter {_gddf =_agae +(_ddge +_eggge -_agae )/2+(_agdc -_agae )/2;};_faac :=_eaaa .PageHeight -_eaaa .Y -_gddf ;_gcce .Translate (_eaaa .X ,_faac );_bfee :=_faac ;if _efgef ._ffcb !=0{_gcce .RotateDeg (_efgef ._ffcb );
};if _efgef ._decfe ==TextOverflowHidden {_gcce .Add_re (0,-_eebfc +_dfgc +1,_efgef ._edff ,_eebfc ).Add_W ().Add_n ();};_gcce .Add_BT ();var _fbfde []*_fce .BasicLine ;for _aagf ,_fbgf :=range _baafe {_eefe :=_eaaa .X ;var _geabd float64 ;if len (_fbgf )> 0{_geabd =_fbgf [0].Style .FontSize ;
};for _ ,_gebg :=range _fbgf {_acga :=&_gebg .Style ;if _gebg .Text !=""&&_acga .FontSize > _geabd {_geabd =_acga .FontSize ;};};if _aagf !=0{_gcce .Add_TD (0,-_geabd *_efgef ._bcaa );_bfee -=_geabd *_efgef ._bcaa ;};_fbdcd :=_aagf ==len (_baafe )-1;var (_edfa float64 ;
_bdab float64 ;_fgbd float64 ;_bbcde uint ;);var _bfcg []float64 ;for _ ,_agcab :=range _fbgf {_cggg :=&_agcab .Style ;if _cggg .FontSize > _bdab {_bdab =_cggg .FontSize ;};_cdccb ,_fgba :=_cggg .Font .GetRuneMetrics (' ');if !_fgba {return _eaaa ,nil ,_g .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _cacb uint ;var _fegeb float64 ;_bfdag :=len (_agcab .Text );for _eebbb ,_cdab :=range _agcab .Text {if _cdab ==' '{_cacb ++;continue ;};if _cdab =='\u000A'{continue ;};_gfcb ,_geeaf :=_cggg .Font .GetRuneMetrics (_cdab );if !_geeaf {_c .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_cdab );
return _eaaa ,nil ,_g .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_fegeb +=_cggg .FontSize *_gfcb .Wx *_cggg .horizontalScale ();if _eebbb !=_bfdag -1{_fegeb +=_cggg .CharSpacing *1000.0;
};};_bfcg =append (_bfcg ,_fegeb );_edfa +=_fegeb ;_fgbd +=float64 (_cacb )*_cdccb .Wx *_cggg .FontSize *_cggg .horizontalScale ();_bbcde +=_cacb ;};_bdab *=_efgef ._bcaa ;var _gecgg []_af .PdfObject ;_cebbe :=_efgef ._edff *1000.0;if _efgef ._caca ==TextAlignmentJustify {if _bbcde > 0&&!_fbdcd {_fgbd =(_cebbe -_edfa )/float64 (_bbcde )/_fbbae ;
};}else if _efgef ._caca ==TextAlignmentCenter {_eege :=(_cebbe -_edfa -_fgbd )/2;_afed :=_eege /_fbbae ;_gecgg =append (_gecgg ,_af .MakeFloat (-_afed ));_eefe +=_eege /1000.0;}else if _efgef ._caca ==TextAlignmentRight {_dadb :=(_cebbe -_edfa -_fgbd );
_gbdfa :=_dadb /_fbbae ;_gecgg =append (_gecgg ,_af .MakeFloat (-_gbdfa ));_eefe +=_dadb /1000.0;};if len (_gecgg )> 0{_gcce .Add_Tf (_gegba ,_fbbae ).Add_TL (_fbbae *_efgef ._bcaa ).Add_TJ (_gecgg ...);};for _fbfded ,_acef :=range _fbgf {_dadf :=&_acef .Style ;
_geac :=_gegba ;_cdcd :=_fbbae ;_acge :=_dadf .OutlineColor !=nil ;_aagb :=_dadf .HorizontalScaling !=DefaultHorizontalScaling ;_fbddg :=_dadf .OutlineSize !=1;if _fbddg {_gcce .Add_w (_dadf .OutlineSize );};_fdgf :=_dadf .RenderingMode !=TextRenderingModeFill ;
if _fdgf {_gcce .Add_Tr (int64 (_dadf .RenderingMode ));};_gfdgg :=_dadf .CharSpacing !=0;if _gfdgg {_gcce .Add_Tc (_dadf .CharSpacing );};_fagf :=_dadf .TextRise !=0;if _fagf {_gcce .Add_Ts (_dadf .TextRise );};if _efgef ._caca !=TextAlignmentJustify ||_fbdcd {_fdfbe ,_dfcfd :=_dadf .Font .GetRuneMetrics (' ');
if !_dfcfd {return _eaaa ,nil ,_g .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_geac =_aegf [_aagf ][_fbfded ];_cdcd =_dadf .FontSize ;
_fgbd =_fdfbe .Wx *_dadf .horizontalScale ();};_dfdb :=_dadf .Font .Encoder ();var _ggcf []byte ;for _ ,_gffb :=range _acef .Text {if _gffb =='\u000A'{continue ;};if _gffb ==' '{if len (_ggcf )> 0{if _acge {_gcce .SetStrokingColor (_eeg (_dadf .OutlineColor ));
};if _aagb {_gcce .Add_Tz (_dadf .HorizontalScaling );};_gcce .SetNonStrokingColor (_eeg (_dadf .Color )).Add_Tf (_aegf [_aagf ][_fbfded ],_dadf .FontSize ).Add_TJ ([]_af .PdfObject {_af .MakeStringFromBytes (_ggcf )}...);_ggcf =nil ;};if _aagb {_gcce .Add_Tz (DefaultHorizontalScaling );
};_gcce .Add_Tf (_geac ,_cdcd ).Add_TJ ([]_af .PdfObject {_af .MakeFloat (-_fgbd )}...);_bfcg [_fbfded ]+=_fgbd *_cdcd ;}else {if _ ,_bgccb :=_dfdb .RuneToCharcode (_gffb );!_bgccb {_ggbag =UnsupportedRuneError {Message :_fc .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_gffb ,_gffb ),Rune :_gffb };
_eaaa ._cba =append (_eaaa ._cba ,_ggbag );_c .Log .Debug (_ggbag .Error ());if _eaaa ._fceg <=0{continue ;};_gffb =_eaaa ._fceg ;};_ggcf =append (_ggcf ,_dfdb .Encode (string (_gffb ))...);};};if len (_ggcf )> 0{if _acge {_gcce .SetStrokingColor (_eeg (_dadf .OutlineColor ));
};if _aagb {_gcce .Add_Tz (_dadf .HorizontalScaling );};_gcce .SetNonStrokingColor (_eeg (_dadf .Color )).Add_Tf (_aegf [_aagf ][_fbfded ],_dadf .FontSize ).Add_TJ ([]_af .PdfObject {_af .MakeStringFromBytes (_ggcf )}...);};_facf :=_bfcg [_fbfded ]/1000.0;
if _dadf .Underline {_ecabe :=_dadf .UnderlineStyle .Color ;if _ecabe ==nil {_ecabe =_acef .Style .Color ;};_ccda ,_ccec ,_bafd :=_ecabe .ToRGB ();_eceg :=_eefe -_eaaa .X ;_aceg :=_bfee -_faac +_dadf .TextRise -_dadf .UnderlineStyle .Offset ;_fbfde =append (_fbfde ,&_fce .BasicLine {X1 :_eceg ,Y1 :_aceg ,X2 :_eceg +_facf ,Y2 :_aceg ,LineWidth :_acef .Style .UnderlineStyle .Thickness ,LineColor :_cb .NewPdfColorDeviceRGB (_ccda ,_ccec ,_bafd )});
};if _acef ._gdda !=nil {var _aecfc *_af .PdfObjectArray ;if !_acef ._gcdc {switch _gedce :=_acef ._gdda .GetContext ().(type ){case *_cb .PdfAnnotationLink :_aecfc =_af .MakeArray ();_gedce .Rect =_aecfc ;_aegeg ,_efcc :=_gedce .Dest .(*_af .PdfObjectArray );
if _efcc &&_aegeg .Len ()==5{_ebdbc ,_egfd :=_aegeg .Get (1).(*_af .PdfObjectName );if _egfd &&_ebdbc .String ()=="\u0058\u0059\u005a"{_ecacf ,_dbegd :=_af .GetNumberAsFloat (_aegeg .Get (3));if _dbegd ==nil {_aegeg .Set (3,_af .MakeFloat (_eaaa .PageHeight -_ecacf ));
};};};};_acef ._gcdc =true ;};if _aecfc !=nil {_afca :=_fce .NewPoint (_eefe -_eaaa .X ,_bfee +_dadf .TextRise -_faac ).Rotate (_efgef ._ffcb );_afca .X +=_eaaa .X ;_afca .Y +=_faac ;_bffee ,_afgg ,_fccc ,_fefaf :=_eegg (_facf ,_bdab ,_efgef ._ffcb );_afca .X +=_bffee ;
_afca .Y +=_afgg ;_aecfc .Clear ();_aecfc .Append (_af .MakeFloat (_afca .X ));_aecfc .Append (_af .MakeFloat (_afca .Y ));_aecfc .Append (_af .MakeFloat (_afca .X +_fccc ));_aecfc .Append (_af .MakeFloat (_afca .Y +_fefaf ));};_gbbba .AddAnnotation (_acef ._gdda );
};_eefe +=_facf ;if _fbddg {_gcce .Add_w (1.0);};if _acge {_gcce .Add_RG (0.0,0.0,0.0);};if _fdgf {_gcce .Add_Tr (int64 (TextRenderingModeFill ));};if _gfdgg {_gcce .Add_Tc (0);};if _fagf {_gcce .Add_Ts (0);};if _aagb {_gcce .Add_Tz (DefaultHorizontalScaling );
};};};_gcce .Add_ET ();for _ ,_afce :=range _fbfde {_gcce .SetStrokingColor (_afce .LineColor ).Add_w (_afce .LineWidth ).Add_m (_afce .X1 ,_afce .Y1 ).Add_l (_afce .X2 ,_afce .Y2 ).Add_s ();};_gcce .Add_Q ();_ggace :=_gcce .Operations ();_ggace .WrapIfNeeded ();
_gbbba .addContents (_ggace );if _gcbe {_addb :=_eebfc ;_eaaa .Y +=_addb ;_eaaa .Height -=_addb ;if _eaaa .Inline {_eaaa .X +=_efgef .Width ()+_efgef ._bcbb .Right ;};};return _eaaa ,_aaagc ,nil ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;
);

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_fgg *Block )SetMargins (left ,right ,top ,bottom float64 ){_fgg ._bd .Left =left ;_fgg ._bd .Right =right ;_fgg ._bd .Top =top ;_fgg ._bd .Bottom =bottom ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _abfb ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_abe :=&Creator {};_abe ._eegb =[]*_cb .PdfPage {};_abe ._bdec =map[*_cb .PdfPage ]*Block {};_abe ._ebfd =map[*_cb .PdfPage ]*pageTransformations {};_abe .SetPageSize (PageSizeLetter );
_cgdb :=0.1*_abe ._caf ;_abe ._bgcf .Left =_cgdb ;_abe ._bgcf .Right =_cgdb ;_abe ._bgcf .Top =_cgdb ;_abe ._bgcf .Bottom =_cgdb ;var _gbg error ;_abe ._bfde ,_gbg =_cb .NewStandard14Font (_cb .HelveticaName );if _gbg !=nil {_abe ._bfde =_cb .DefaultFont ();
};_abe ._ffdb ,_gbg =_cb .NewStandard14Font (_cb .HelveticaBoldName );if _gbg !=nil {_abe ._bfde =_cb .DefaultFont ();};_abe ._cdca =_abe .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_abe .AddOutlines =true ;
_abe ._gdf =_cb .NewOutline ();_fgc .TrackUse (_abfb );return _abe ;};func (_fdc *Block )setOpacity (_fcg float64 ,_gd float64 )(string ,error ){if (_fcg < 0||_fcg >=1.0)&&(_gd < 0||_gd >=1.0){return "",nil ;};_gf :=0;_ee :=_fc .Sprintf ("\u0047\u0053\u0025\u0064",_gf );
for _fdc ._ba .HasExtGState (_af .PdfObjectName (_ee )){_gf ++;_ee =_fc .Sprintf ("\u0047\u0053\u0025\u0064",_gf );};_fad :=_af .MakeDict ();if _fcg >=0&&_fcg < 1.0{_fad .Set ("\u0063\u0061",_af .MakeFloat (_fcg ));};if _gd >=0&&_gd < 1.0{_fad .Set ("\u0043\u0041",_af .MakeFloat (_gd ));
};_ff :=_fdc ._ba .AddExtGState (_af .PdfObjectName (_ee ),_fad );if _ff !=nil {return "",_ff ;};return _ee ,nil ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;func _agced (_beaag *_cb .Image )(*Image ,error ){_eacff :=float64 (_beaag .Width );_bgafd :=float64 (_beaag .Height );return &Image {_aaff :_beaag ,_fgeb :_eacff ,_beag :_bgafd ,_dbf :_eacff ,_becd :_bgafd ,_geeg :0,_baeca :1.0,_adadf :PositionRelative },nil ;
};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_dg *_fb .ContentStreamOperations ;_ba *_cb .PdfPageResources ;_ef Positioning ;_eff ,_de float64 ;_bfc float64 ;_fd float64 ;_fbc float64 ;_bd Margins ;_ad []*_cb .PdfAnnotation ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_dccg *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _dccg ._daef ==nil {if _gfdgd :=_dccg .makeXObject ();_gfdgd !=nil {return nil ,ctx ,_gfdgd ;};};var _cbbea []*Block ;_cdgf :=ctx ;_aaea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _dccg ._adadf .IsRelative (){ctx .X +=_dccg ._acbg .Left ;ctx .Y +=_dccg ._acbg .Top ;ctx .Width -=_dccg ._acbg .Left +_dccg ._acbg .Right ;ctx .Height -=_dccg ._acbg .Top +_dccg ._acbg .Bottom ;if _dccg ._becd > ctx .Height {_cbbea =append (_cbbea ,_aaea );
_aaea =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fbaa :=ctx ;_fbaa .Y =ctx .Margins .Top +_dccg ._acbg .Top ;_fbaa .X =ctx .Margins .Left +_dccg ._acbg .Left ;_fbaa .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dccg ._acbg .Top -_dccg ._acbg .Bottom ;
_fbaa .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dccg ._acbg .Left -_dccg ._acbg .Right ;ctx =_fbaa ;_cdgf .X =ctx .Margins .Left ;_cdgf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_dccg ._ged ;
ctx .Y =_dccg ._ebdge ;};ctx ,_babf :=_beffe (_aaea ,_dccg ,ctx );if _babf !=nil {return nil ,ctx ,_babf ;};_cbbea =append (_cbbea ,_aaea );if _dccg ._adadf .IsAbsolute (){ctx =_cdgf ;}else {ctx .X =_cdgf .X ;ctx .Y +=_dccg ._acbg .Bottom ;ctx .Width =_cdgf .Width ;
};return _cbbea ,ctx ,nil ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_cgcdd *Paragraph )SetMaxLines (maxLines int ){_cgcdd ._gcba =maxLines ;_cgcdd .wrapText ()};

// Margins returns the margins of the list: left, right, top, bottom.
func (_bfbae *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _bfbae ._fdgdb .Left ,_bfbae ._fdgdb .Right ,_bfbae ._fdgdb .Top ,_bfbae ._fdgdb .Bottom ;};func (_gecb *Invoice )generateInformationBlocks (_bbaf DrawContext )([]*Block ,DrawContext ,error ){_cagc :=_egeg (_gecb ._gbece );
_cagc .SetMargins (0,0,0,20);_ecdg :=_gecb .drawAddress (_gecb ._geaa );_ecdg =append (_ecdg ,_cagc );_ecdg =append (_ecdg ,_gecb .drawAddress (_gecb ._ggba )...);_bbfba :=_dedf ();for _ ,_bggf :=range _ecdg {_bbfba .Add (_bggf );};_dgbd :=_gecb .drawInformation ();
_dcaf :=_bccg (2);_dcaf .SetMargins (0,0,25,0);_gdgc :=_dcaf .NewCell ();_gdgc .SetIndent (0);_gdgc .SetContent (_bbfba );_gdgc =_dcaf .NewCell ();_gdgc .SetContent (_dgbd );return _dcaf .GeneratePageBlocks (_bbaf );};func (_gfdf *Invoice )newCell (_ggcg string ,_ccae InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_ccae ,_ggcg };
};

// Width returns Rectangle's document width.
func (_baea *Rectangle )Width ()float64 {return _baea ._eab };

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_gadge *Ellipse )GetCoords ()(float64 ,float64 ){return _gadge ._deff ,_gadge ._dacf };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_dffc *TOC )SetLineSeparatorStyle (style TextStyle ){_dffc ._bfdaa =style };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_eb :=&Block {};_eb ._dg =&_fb .ContentStreamOperations {};_eb ._ba =_cb .NewPdfPageResources ();_eb ._bfc =width ;_eb ._fd =height ;return _eb ;};

// SetStyleLeft sets border style for left side.
func (_cea *border )SetStyleLeft (style CellBorderStyle ){_cea ._dcff =style };

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_caa :_bf .Min (float64 (c ),100)/100.0,_ecd :_bf .Min (float64 (m ),100)/100.0,_babb :_bf .Min (float64 (y ),100)/100.0,_fdf :_bf .Min (float64 (k ),100)/100.0};};func _caae (_agcca TextStyle )*List {return &List {_daee :TextChunk {Text :"\u2022\u0020",Style :_agcca },_gbdf :0,_adbgb :true ,_aadg :PositionRelative ,_cdfc :_agcca };
};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_cbbca *Chart )SetPos (x ,y float64 ){_cbbca ._afbb =PositionAbsolute ;_cbbca ._fbfd =x ;_cbbca ._agec =y ;};

// Level returns the indentation level of the TOC line.
func (_effc *TOCLine )Level ()uint {return _effc ._ddgcb };

// CurRow returns the currently active cell's row number.
func (_ggecd *Table )CurRow ()int {_bbeb :=(_ggecd ._agcb -1)/_ggecd ._bbac +1;return _bbeb };

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cedfb *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _cedfb ._fgcgf [0],_cedfb ._fgcgf [1]};func (_begc *TableCell )width (_faaea []float64 ,_aaedb float64 )float64 {_ggbeb :=float64 (0.0);for _addd :=0;_addd < _begc ._ggfa ;_addd ++{_ggbeb +=_faaea [_begc ._aaad +_addd -1];
};return _ggbeb *_aaedb ;};

// Scale block by specified factors in the x and y directions.
func (_bba *Block )Scale (sx ,sy float64 ){_gg :=_fb .NewContentCreator ().Scale (sx ,sy ).Operations ();*_bba ._dg =append (*_gg ,*_bba ._dg ...);_bba ._dg .WrapIfNeeded ();_bba ._bfc *=sx ;_bba ._fd *=sy ;};

// NewCell returns a new invoice table cell.
func (_daec *Invoice )NewCell (value string )*InvoiceCell {return _daec .newCell (value ,_daec .NewCellProps ());};

// AppendColumn appends a column to the line items table.
func (_acfa *Invoice )AppendColumn (description string )*InvoiceCell {_dgbc :=_acfa .NewColumn (description );_acfa ._efdf =append (_acfa ._efdf ,_dgbc );return _dgbc ;};

// SetBorderColor sets the border color.
func (_fggc *CurvePolygon )SetBorderColor (color Color ){_fggc ._dcfcf .BorderColor =_eeg (color )};

// SetColorLeft sets border color for left.
func (_gdba *border )SetColorLeft (col Color ){_gdba ._gfe =col };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_cec *Block )SetPos (x ,y float64 ){_cec ._ef =PositionAbsolute ;_cec ._eff =x ;_cec ._de =y };

// SetSubtotal sets the subtotal of the invoice.
func (_abd *Invoice )SetSubtotal (value string ){_abd ._gbbb [1].Value =value };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);func (_abcc *Creator )setActivePage (_fdg *_cb .PdfPage ){_abcc ._baec =_fdg };


// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_abccc *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_cefa :=NewTextChunk (text ,_abccc ._bcgeg );_cefa ._gdda =_gfaeg (url );return _abccc .appendChunk (_cefa );};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_dcfe *Creator )NewPage ()*_cb .PdfPage {_afaf :=_dcfe .newPage ();_dcfe ._eegb =append (_dcfe ._eegb ,_afaf );_dcfe ._fcdd .Page ++;return _afaf ;};func (_dbfg *Invoice )generateLineBlocks (_babab DrawContext )([]*Block ,DrawContext ,error ){_eacc :=_bccg (len (_dbfg ._efdf ));
_eacc .SetMargins (0,0,25,0);for _ ,_caed :=range _dbfg ._efdf {_ccfb :=_egeg (_caed .TextStyle );_ccfb .SetMargins (0,0,1,0);_ccfb .Append (_caed .Value );_bfab :=_eacc .NewCell ();_bfab .SetHorizontalAlignment (_caed .Alignment );_bfab .SetBackgroundColor (_caed .BackgroundColor );
_dbfg .setCellBorder (_bfab ,_caed );_bfab .SetContent (_ccfb );};for _ ,_bebba :=range _dbfg ._bcff {for _ ,_egbb :=range _bebba {_cab :=_egeg (_egbb .TextStyle );_cab .SetMargins (0,0,3,2);_cab .Append (_egbb .Value );_cda :=_eacc .NewCell ();_cda .SetHorizontalAlignment (_egbb .Alignment );
_cda .SetBackgroundColor (_egbb .BackgroundColor );_dbfg .setCellBorder (_cda ,_egbb );_cda .SetContent (_cab );};};return _eacc .GeneratePageBlocks (_babab );};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_ecac *Invoice )AddressStyle ()TextStyle {return _ecac ._dff };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_fcgd *Block )ScaleToHeight (h float64 ){_afd :=h /_fcgd ._fd ;_fcgd .Scale (_afd ,_afd )};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_abcd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbb :=ctx ;if _abcd ._adae .IsRelative (){ctx .X +=_abcd ._adg .Left ;ctx .Y +=_abcd ._adg .Top ;ctx .Width -=_abcd ._adg .Left +_abcd ._adg .Right ;ctx .Height -=_abcd ._adg .Top ;
};_bde ,_gece ,_gfc :=_abcd ._fcd .GeneratePageBlocks (ctx );if _gfc !=nil {return _bde ,ctx ,_gfc ;};ctx =_gece ;_bcg :=ctx .X ;_gfdd :=ctx .Y -_abcd ._fcd .Height ();_gdbbd :=int64 (ctx .Page );_gfbf :=_abcd .headingNumber ();_gfee :=_abcd .headingText ();
if _abcd ._acd {_faf :=_abcd ._fceb .Add (_gfbf ,_abcd ._dafa ,_bg .FormatInt (_gdbbd ,10),_abcd ._cbf );if _abcd ._fceb ._gaff {_faf .SetLink (_gdbbd ,_bcg ,_gfdd );};};if _abcd ._eebb ==nil {_abcd ._eebb =_cb .NewOutlineItem (_gfee ,_cb .NewOutlineDest (_gdbbd -1,_bcg ,_gfdd ));
if _abcd ._cbba !=nil {_abcd ._cbba ._eebb .Add (_abcd ._eebb );}else {_abcd ._bab .Add (_abcd ._eebb );};}else {_ffbd :=&_abcd ._eebb .Dest ;_ffbd .Page =_gdbbd -1;_ffbd .X =_bcg ;_ffbd .Y =_gfdd ;};for _ ,_ebfc :=range _abcd ._eccg {_ffbb ,_bfad ,_beeg :=_ebfc .GeneratePageBlocks (ctx );
if _beeg !=nil {return _bde ,ctx ,_beeg ;};if len (_ffbb )< 1{continue ;};_bde [len (_bde )-1].mergeBlocks (_ffbb [0]);_bde =append (_bde ,_ffbb [1:]...);ctx =_bfad ;};if _abcd ._adae .IsRelative (){ctx .X =_dbb .X ;};if _abcd ._adae .IsAbsolute (){return _bde ,_dbb ,nil ;
};return _bde ,ctx ,nil ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_egae *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _egae ._bgbg [0],_egae ._bgbg [1]};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_baecf []VectorDrawable ;_dfeb Positioning ;_gffe Margins ;_dgdg Margins ;_dccbd bool ;_cgdgb bool ;_ddbd *Background ;};

// SetLevel sets the indentation level of the TOC line.
func (_bfff *TOCLine )SetLevel (level uint ){_bfff ._ddgcb =level ;_bfff ._ddfc ._bcbb .Left =_bfff ._dbee +float64 (_bfff ._ddgcb -1)*_bfff ._cdbff ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_cgdg *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _gcafe (x1 ,y1 ,cx ,cy ,x2 ,y2 );};func (_egga *StyledParagraph )getMaxLineWidth ()float64 {if _egga ._defff ==nil ||len (_egga ._defff )==0{_egga .wrapText ();};var _dgcgg float64 ;
for _ ,_ccbac :=range _egga ._defff {_ebgb :=_egga .getTextLineWidth (_ccbac );if _ebgb > _dgcgg {_dgcgg =_ebgb ;};};return _dgcgg ;};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// SetHeight sets the Image's document height to specified h.
func (_cfbg *Image )SetHeight (h float64 ){_cfbg ._becd =h };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_gaeg *Invoice )NoteStyle ()TextStyle {return _gaeg ._fadd };

// SellerAddress returns the seller address used in the invoice template.
func (_fedf *Invoice )SellerAddress ()*InvoiceAddress {return _fedf ._geaa };func (_cdafg *Paragraph )getMaxLineWidth ()float64 {if _cdafg ._febc ==nil ||len (_cdafg ._febc )==0{_cdafg .wrapText ();};var _dgdb float64 ;for _ ,_aecb :=range _cdafg ._febc {_adge :=_cdafg .getTextLineWidth (_aecb );
if _adge > _dgdb {_dgdb =_adge ;};};return _dgdb ;};

// Title returns the title of the invoice.
func (_dbaf *Invoice )Title ()string {return _dbaf ._fdec };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_aebb int ;_dafa string ;_fcd *Paragraph ;_eccg []Drawable ;_ffd int ;_abfd bool ;_acd bool ;_adae Positioning ;_ddf ,_ddga float64 ;_adg Margins ;_cbba *Chapter ;_fceb *TOC ;_bab *_cb .Outline ;_eebb *_cb .OutlineItem ;_cbf uint ;};


// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_dfac *Line )SetColor (col Color ){_dfac ._ecfd =col };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_dced *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_edef :=[2]*InvoiceCell {_dced .newCell (description ,_dced ._ffde ),_dced .newCell (value ,_dced ._ffde )};_dced ._eeege =append (_dced ._eeege ,_edef );return _edef [0],_edef [1];
};

// String implements error interface.
func (_bcea UnsupportedRuneError )Error ()string {return _bcea .Message };func (_caccg *Creator )initContext (){_caccg ._fcdd .X =_caccg ._bgcf .Left ;_caccg ._fcdd .Y =_caccg ._bgcf .Top ;_caccg ._fcdd .Width =_caccg ._caf -_caccg ._bgcf .Right -_caccg ._bgcf .Left ;
_caccg ._fcdd .Height =_caccg ._gdbg -_caccg ._bgcf .Bottom -_caccg ._bgcf .Top ;_caccg ._fcdd .PageHeight =_caccg ._gdbg ;_caccg ._fcdd .PageWidth =_caccg ._caf ;_caccg ._fcdd .Margins =_caccg ._bgcf ;_caccg ._fcdd ._fceg =_caccg .UnsupportedCharacterReplacement ;
};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_dggb *Division )SetMargins (left ,right ,top ,bottom float64 ){_dggb ._gffe .Left =left ;_dggb ._gffe .Right =right ;_dggb ._gffe .Top =top ;_dggb ._gffe .Bottom =bottom ;};

// Write output of creator to io.Writer interface.
func (_bffc *Creator )Write (ws _b .Writer )error {if _fegg :=_bffc .Finalize ();_fegg !=nil {return _fegg ;};_daed :=_cb .NewPdfWriter ();_daed .SetOptimizer (_bffc ._cege );if _bffc ._efd !=nil {_cegf :=_daed .SetForms (_bffc ._efd );if _cegf !=nil {_c .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cegf );
return _cegf ;};};if _bffc ._befg !=nil {_daed .AddOutlineTree (_bffc ._befg );}else if _bffc ._gdf !=nil &&_bffc .AddOutlines {_daed .AddOutlineTree (&_bffc ._gdf .ToPdfOutline ().PdfOutlineTreeNode );};if _bffc ._cfdd !=nil {if _gbab :=_daed .SetPageLabels (_bffc ._cfdd );
_gbab !=nil {_c .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_gbab );return _gbab ;};};if _bffc ._dcgd !=nil {for _ ,_fbac :=range _bffc ._dcgd {_cfgf :=_fbac .SubsetRegistered ();
if _cfgf !=nil {_c .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_cfgf );return _cfgf ;};};};if _bffc ._edcg !=nil {_cdff :=_bffc ._edcg (&_daed );
if _cdff !=nil {_c .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cdff );return _cdff ;};};for _ ,_cdcf :=range _bffc ._eegb {_gaf :=_daed .AddPage (_cdcf );if _gaf !=nil {_c .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_gaf );
return _gaf ;};};_bafb :=_daed .Write (ws );if _bafb !=nil {return _bafb ;};return nil ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_cfdc :float64 (r )/255.0,_ace :float64 (g )/255.0,_bge :float64 (b )/255.0};};func _eebc (_caea ,_cbdf ,_ggeb ,_bffa float64 )*Rectangle {return &Rectangle {_gbcdf :_caea ,_baggf :_cbdf ,_eab :_ggeb ,_fbgee :_bffa ,_aege :ColorBlack ,_efffa :1.0,_ecab :1.0,_bcdc :1.0,_bggff :PositionAbsolute };
};func (_eddd *Invoice )drawAddress (_bbfce *InvoiceAddress )[]*StyledParagraph {var _adebg []*StyledParagraph ;if _bbfce .Heading !=""{_ddfg :=_egeg (_eddd ._eagc );_ddfg .SetMargins (0,0,0,7);_ddfg .Append (_bbfce .Heading );_adebg =append (_adebg ,_ddfg );
};_bbb :=_egeg (_eddd ._dff );_bbb .SetLineHeight (1.2);_dfaa :=_bbfce .Separator ;if _dfaa ==""{_dfaa =_eddd ._dfdc ;};_gebfg :=_bbfce .City ;if _bbfce .State !=""{if _gebfg !=""{_gebfg +=_dfaa ;};_gebfg +=_bbfce .State ;};if _bbfce .Zip !=""{if _gebfg !=""{_gebfg +=_dfaa ;
};_gebfg +=_bbfce .Zip ;};if _bbfce .Name !=""{_bbb .Append (_bbfce .Name +"\u000a");};if _bbfce .Street !=""{_bbb .Append (_bbfce .Street +"\u000a");};if _bbfce .Street2 !=""{_bbb .Append (_bbfce .Street2 +"\u000a");};if _gebfg !=""{_bbb .Append (_gebfg +"\u000a");
};if _bbfce .Country !=""{_bbb .Append (_bbfce .Country +"\u000a");};_efeb :=_egeg (_eddd ._dff );_efeb .SetLineHeight (1.2);_efeb .SetMargins (0,0,7,0);if _bbfce .Phone !=""{_efeb .Append (_bbfce .fmtLine (_bbfce .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_bbfce .HidePhoneLabel ));
};if _bbfce .Email !=""{_efeb .Append (_bbfce .fmtLine (_bbfce .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_bbfce .HideEmailLabel ));};_adebg =append (_adebg ,_bbb ,_efeb );return _adebg ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetBorderWidth sets the border width.
func (_ggab *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_ggab ._ccfa .BorderWidth =borderWidth ;};

// Height returns the current page height.
func (_gae *Creator )Height ()float64 {return _gae ._gdbg };func (_gbf *pageTransformations )applyFlip (_cbe *_cb .PdfPage )error {_gfbc ,_cbfd :=_gbf ._gbe ,_gbf ._cdfa ;if !_gfbc &&!_cbfd {return nil ;};if _cbe ==nil {return _g .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_degg ,_ffdf :=_cbe .GetMediaBox ();if _ffdf !=nil {return _ffdf ;};_gab ,_ddgc :=_degg .Width (),_degg .Height ();_bbeg ,_ffdf :=_cbe .GetRotate ();if _ffdf !=nil {_c .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_ffdf .Error ());
};if _ffca :=_bbeg %360!=0&&_bbeg %90==0;_ffca {if _ffdg :=(360+_bbeg %360)%360;_ffdg ==90||_ffdg ==270{_gfbc ,_cbfd =_cbfd ,_gfbc ;};};_eca ,_dfd :=1.0,0.0;if _gfbc {_eca ,_dfd =-1.0,-_gab ;};_agea ,_ffdc :=1.0,0.0;if _cbfd {_agea ,_ffdc =-1.0,-_ddgc ;
};_cdbbd :=_fb .NewContentCreator ().Scale (_eca ,_agea ).Translate (_dfd ,_ffdc );_edf ,_ffdf :=_af .MakeStream (_cdbbd .Bytes (),_af .NewFlateEncoder ());if _ffdf !=nil {return _ffdf ;};_cdbc :=_af .MakeArray (_edf );_cdbc .Append (_cbe .GetContentStreamObjs ()...);
_cbe .Contents =_cdbc ;return nil ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_abdb *_fce .Polyline ;_aebf float64 ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_dab *Creator )MoveRight (dx float64 ){_dab ._fcdd .X +=dx };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_ebbf *StyledParagraph )SetWidth (width float64 ){_ebbf ._edff =width ;_ebbf .wrapText ()};

// Rows returns the total number of rows the table has.
func (_dfbb *Table )Rows ()int {return _dfbb ._ccgd };

// SetColor sets the line color.
func (_gfdb *Curve )SetColor (col Color ){_gfdb ._ccab =col };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_ebfe *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _ebfe ._eae ,_ebfe ._adce ,_ebfe ._ggbe ,_ebfe ._bceb ;};func _gadgb (_geda _aa .Image )(*Image ,error ){_dge ,_bdff :=_cb .ImageHandling .NewImageFromGoImage (_geda );if _bdff !=nil {return nil ,_bdff ;
};return _agced (_dge );};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_cceca *TOC )SetLineTitleStyle (style TextStyle ){_cceca ._becbd =style };

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dcede *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dcede ._ebbae =halign ;};func (_dfabe *StyledParagraph )appendChunk (_egaef *TextChunk )*TextChunk {_dfabe ._beaee =append (_dfabe ._beaee ,_egaef );_dfabe .wrapText ();
return _egaef ;};

// Width returns Ellipse's document width.
func (_gfcf *Ellipse )Width ()float64 {return _gfcf ._adcb };func (_agebe *Invoice )generateNoteBlocks (_gcd DrawContext )([]*Block ,DrawContext ,error ){_dfce :=_dedf ();_ddbb :=append ([][2]string {_agebe ._gbbf ,_agebe ._gdbe },_agebe ._gdce ...);for _ ,_dgde :=range _ddbb {if _dgde [1]!=""{_gabga :=_agebe .drawSection (_dgde [0],_dgde [1]);
for _ ,_bdeb :=range _gabga {_dfce .Add (_bdeb );};_cfdg :=_egeg (_agebe ._gbece );_cfdg .SetMargins (0,0,10,0);_dfce .Add (_cfdg );};};return _dfce .GeneratePageBlocks (_gcd );};

// SetFillOpacity sets the fill opacity.
func (_cgea *CurvePolygon )SetFillOpacity (opacity float64 ){_cgea ._bgec =opacity };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_cecda *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_cecda ._bbac {_c .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cecda ._cbbda =widths ;return nil ;};

// SetColorRight sets border color for right.
func (_aga *border )SetColorRight (col Color ){_aga ._dec =col };

// SetLineWidth sets the line width.
func (_fcfc *Polyline )SetLineWidth (lineWidth float64 ){_fcfc ._abdb .LineWidth =lineWidth };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_dga *Creator )SetForms (form *_cb .PdfAcroForm )error {_dga ._efd =form ;return nil };func _efcf (_egcc float64 ,_dcgea float64 )float64 {return _bf .Round (_egcc /_dcgea )*_dcgea };func (_dde *Block )mergeBlocks (_ea *Block )error {_cca :=_dda (_dde ._dg ,_dde ._ba ,_ea ._dg ,_ea ._ba );
if _cca !=nil {return _cca ;};for _ ,_bdd :=range _ea ._ad {_dde .AddAnnotation (_bdd );};return nil ;};

// SetBorderOpacity sets the border opacity.
func (_cdgg *Polygon )SetBorderOpacity (opacity float64 ){_cdgg ._dcb =opacity };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_ccfa *_fce .PolyBezierCurve ;_dfaf float64 ;_fbbbf float64 ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_ece *Creator )NewParagraph (text string )*Paragraph {return _aedgc (text ,_ece .NewTextStyle ())};

// Invoice represents a configurable invoice template.
type Invoice struct{_fdec string ;_dada *Image ;_ggba *InvoiceAddress ;_geaa *InvoiceAddress ;_dfdc string ;_bgbg [2]*InvoiceCell ;_fgcgf [2]*InvoiceCell ;_adeg [2]*InvoiceCell ;_eeege [][2]*InvoiceCell ;_efdf []*InvoiceCell ;_bcff [][]*InvoiceCell ;_gbbb [2]*InvoiceCell ;
_fedc [2]*InvoiceCell ;_dacdf [][2]*InvoiceCell ;_gbbf [2]string ;_gdbe [2]string ;_gdce [][2]string ;_gbece TextStyle ;_cfge TextStyle ;_bbgg TextStyle ;_dff TextStyle ;_eagc TextStyle ;_fadd TextStyle ;_cde TextStyle ;_ffde InvoiceCellProps ;_defb InvoiceCellProps ;
_cfbe InvoiceCellProps ;_eecgg InvoiceCellProps ;_agegf Positioning ;};func _eegg (_dgddf ,_fbdf ,_daff float64 )(_gaae ,_dcdb ,_gcga ,_bfge float64 ){if _daff ==0{return 0,0,_dgddf ,_fbdf ;};_acdd :=_fce .Path {Points :[]_fce .Point {_fce .NewPoint (0,0).Rotate (_daff ),_fce .NewPoint (_dgddf ,0).Rotate (_daff ),_fce .NewPoint (0,_fbdf ).Rotate (_daff ),_fce .NewPoint (_dgddf ,_fbdf ).Rotate (_daff )}}.GetBoundingBox ();
return _acdd .X ,_acdd .Y ,_acdd .Width ,_acdd .Height ;};

// SetAngle sets the rotation angle in degrees.
func (_cgc *Block )SetAngle (angleDeg float64 ){_cgc ._fbc =angleDeg };

// NewPolygon creates a new polygon.
func (_dbeb *Creator )NewPolygon (points [][]_fce .Point )*Polygon {return _becb (points )};func _fac (_edgg []byte )(*Image ,error ){_ebag :=_dc .NewReader (_edgg );_bdgf ,_ffebc :=_cb .ImageHandling .Read (_ebag );if _ffebc !=nil {_c .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ffebc );
return nil ,_ffebc ;};return _agced (_bdgf );};func (_ccabf *Table )wrapRow (_ebecd int ,_feef DrawContext ,_cada float64 )(bool ,error ){if !_ccabf ._bdda {return false ,nil ;};var (_cdga =_ccabf ._caccb [_ebecd ];_edeg =-1;_cdde []*TableCell ;_ceab float64 ;
_gfac bool ;_ecdcd =make ([]float64 ,0,len (_ccabf ._cbbda )););_dceb :=func (_ggagf *TableCell ,_bfec VectorDrawable ,_adbaa bool )*TableCell {_dcaa :=*_ggagf ;_dcaa ._fgec =_bfec ;if _adbaa {_dcaa ._ddfbb ++;};return &_dcaa ;};_cafb :=func (_bfbb int ,_eaec VectorDrawable ){var _gbgag float64 =-1;
if _eaec ==nil {if _eadd :=_ecdcd [_bfbb -_ebecd ];_eadd > _feef .Height {_eaec =_ccabf ._caccb [_bfbb ]._fgec ;_ccabf ._caccb [_bfbb ]._fgec =nil ;_ecdcd [_bfbb -_ebecd ]=0;_gbgag =_eadd ;};};_ggbagd :=_dceb (_ccabf ._caccb [_bfbb ],_eaec ,true );_cdde =append (_cdde ,_ggbagd );
if _gbgag < 0{_gbgag =_ggbagd .height (_feef .Width );};if _gbgag > _ceab {_ceab =_gbgag ;};};for _gaebe :=_ebecd ;_gaebe < len (_ccabf ._caccb );_gaebe ++{_afgc :=_ccabf ._caccb [_gaebe ];if _cdga ._ddfbb !=_afgc ._ddfbb {_edeg =_gaebe ;break ;};_feef .Width =_afgc .width (_ccabf ._cbbda ,_cada );
var _aecd VectorDrawable ;switch _aedeg :=_afgc ._fgec .(type ){case *StyledParagraph :if _eebg :=_afgc .height (_feef .Width );_eebg > _feef .Height {_aabe :=_feef ;_aabe .Height =_bf .Floor (_feef .Height -_aedeg ._bcbb .Top -_aedeg ._bcbb .Bottom -0.5*_aedeg .getTextHeight ());
_acae ,_eefd ,_debf :=_aedeg .split (_aabe );if _debf !=nil {return false ,_debf ;};if _acae !=nil &&_eefd !=nil {_aedeg =_acae ;_afgc =_dceb (_afgc ,_acae ,false );_ccabf ._caccb [_gaebe ]=_afgc ;_aecd =_eefd ;_gfac =true ;};};case *Division :if _cadf :=_afgc .height (_feef .Width );
_cadf > _feef .Height {_bbfeg :=_feef ;_bbfeg .Height =_bf .Floor (_feef .Height -_aedeg ._gffe .Top -_aedeg ._gffe .Bottom );_addc ,_bdac :=_aedeg .split (_bbfeg );if _addc !=nil &&_bdac !=nil {_aedeg =_addc ;_afgc =_dceb (_afgc ,_addc ,false );_ccabf ._caccb [_gaebe ]=_afgc ;
_aecd =_bdac ;_gfac =true ;if _addc ._ddbd !=nil {_addc ._ddbd .BorderRadiusBottomLeft =0;_addc ._ddbd .BorderRadiusBottomRight =0;};if _bdac ._ddbd !=nil {_bdac ._ddbd .BorderRadiusTopLeft =0;_bdac ._ddbd .BorderRadiusTopRight =0;};};};};_ecdcd =append (_ecdcd ,_afgc .height (_feef .Width ));
if _gfac {if _cdde ==nil {_cdde =make ([]*TableCell ,0,len (_ccabf ._cbbda ));for _acfdf :=_ebecd ;_acfdf < _gaebe ;_acfdf ++{_cafb (_acfdf ,nil );};};_cafb (_gaebe ,_aecd );};};var _dgbg float64 ;for _ ,_gfag :=range _ecdcd {if _gfag > _dgbg {_dgbg =_gfag ;
};};if _gfac &&_dgbg < _feef .Height {if _edeg < 0{_edeg =len (_ccabf ._caccb );};_gbff :=_ccabf ._caccb [_edeg -1]._ddfbb +_ccabf ._caccb [_edeg -1]._bgfcd -1;for _bbffe :=_edeg ;_bbffe < len (_ccabf ._caccb );_bbffe ++{_ccabf ._caccb [_bbffe ]._ddfbb ++;
};_ccabf ._caccb =append (_ccabf ._caccb [:_edeg ],append (_cdde ,_ccabf ._caccb [_edeg :]...)...);_ccabf ._cede =append (_ccabf ._cede [:_gbff ],append ([]float64 {_ceab },_ccabf ._cede [_gbff :]...)...);_ccabf ._cede [_cdga ._ddfbb +_cdga ._bgfcd -2]=_dgbg ;
};return _gfac ,nil ;};func (_eggg *Creator )newPage ()*_cb .PdfPage {_fgfe :=_cb .NewPdfPage ();_bfadd :=_eggg ._aeeb [0];_fdgb :=_eggg ._aeeb [1];_fdd :=_cb .PdfRectangle {Llx :0,Lly :0,Urx :_bfadd ,Ury :_fdgb };_fgfe .MediaBox =&_fdd ;_eggg ._caf =_bfadd ;
_eggg ._gdbg =_fdgb ;_eggg .initContext ();return _fgfe ;};

// SetLineHeight sets the line height (1.0 default).
func (_beaeb *StyledParagraph )SetLineHeight (lineheight float64 ){_beaeb ._bcaa =lineheight };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_ddff *Creator )RotateDeg (angleDeg int64 )error {_aggd :=_ddff .getActivePage ();if _aggd ==nil {_c .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _g .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_c .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _baddf int64 ;if _aggd .Rotate !=nil {_baddf =*(_aggd .Rotate );};_baddf +=angleDeg ;_aggd .Rotate =&_baddf ;return nil ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_eddfe *TOCLine )SetLevelOffset (levelOffset float64 ){_eddfe ._cdbff =levelOffset ;_eddfe ._ddfc ._bcbb .Left =_eddfe ._dbee +float64 (_eddfe ._ddgcb -1)*_eddfe ._cdbff ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_eaeb *Paragraph )SetEnableWrap (enableWrap bool ){_eaeb ._cccg =enableWrap ;_eaeb ._fcea =false };

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_edec *TableCell )SetBorderLineStyle (style _fce .LineStyle ){_edec ._fedac =style };

// SetBorderOpacity sets the border opacity.
func (_acgc *Rectangle )SetBorderOpacity (opacity float64 ){_acgc ._bcdc =opacity };func _beffe (_gdga *Block ,_cbed *Image ,_abca DrawContext )(DrawContext ,error ){_cedd :=_abca ;_bceaa :=1;_ggbf :=_af .PdfObjectName (_fc .Sprintf ("\u0049\u006d\u0067%\u0064",_bceaa ));
for _gdga ._ba .HasXObjectByName (_ggbf ){_bceaa ++;_ggbf =_af .PdfObjectName (_fc .Sprintf ("\u0049\u006d\u0067%\u0064",_bceaa ));};_bcdb :=_gdga ._ba .SetXObjectImageByName (_ggbf ,_cbed ._daef );if _bcdb !=nil {return _abca ,_bcdb ;};_eacfe :=0;_cffff :=_af .PdfObjectName (_fc .Sprintf ("\u0047\u0053\u0025\u0064",_eacfe ));
for _gdga ._ba .HasExtGState (_cffff ){_eacfe ++;_cffff =_af .PdfObjectName (_fc .Sprintf ("\u0047\u0053\u0025\u0064",_eacfe ));};_dbcg :=_af .MakeDict ();_dbcg .Set ("\u0042\u004d",_af .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _cbed ._baeca < 1.0{_dbcg .Set ("\u0043\u0041",_af .MakeFloat (_cbed ._baeca ));
_dbcg .Set ("\u0063\u0061",_af .MakeFloat (_cbed ._baeca ));};_bcdb =_gdga ._ba .AddExtGState (_cffff ,_af .MakeIndirectObject (_dbcg ));if _bcdb !=nil {return _abca ,_bcdb ;};_beaad :=_cbed .Width ();_cedc :=_cbed .Height ();_ ,_gbec :=_cbed .rotatedSize ();
_bcgec :=_abca .X ;_gecg :=_abca .PageHeight -_abca .Y -_cedc ;if _cbed ._adadf .IsRelative (){_gecg -=(_gbec -_cedc )/2;switch _cbed ._dgfe {case HorizontalAlignmentCenter :_bcgec +=(_abca .Width -_beaad )/2;case HorizontalAlignmentRight :_bcgec =_abca .PageWidth -_abca .Margins .Right -_cbed ._acbg .Right -_beaad ;
};};_ebaa :=_cbed ._geeg ;_dcca :=_fb .NewContentCreator ();_dcca .Add_gs (_cffff );_dcca .Translate (_bcgec ,_gecg );if _ebaa !=0{_dcca .Translate (_beaad /2,_cedc /2);_dcca .RotateDeg (_ebaa );_dcca .Translate (-_beaad /2,-_cedc /2);};_dcca .Scale (_beaad ,_cedc ).Add_Do (_ggbf );
_gcgd :=_dcca .Operations ();_gcgd .WrapIfNeeded ();_gdga .addContents (_gcgd );if _cbed ._adadf .IsRelative (){_abca .Y +=_gbec ;_abca .Height -=_gbec ;return _abca ,nil ;};return _cedd ,nil ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_aadgc *Table )SetPos (x ,y float64 ){_aadgc ._eaca =PositionAbsolute ;_aadgc ._begfe =x ;_aadgc ._ffbdd =y ;};

// Length calculates and returns the line length.
func (_begg *Line )Length ()float64 {return _bf .Sqrt (_bf .Pow (_begg ._ggbe -_begg ._eae ,2.0)+_bf .Pow (_begg ._bceb -_begg ._adce ,2.0));};

// GeneratePageBlocks generates a page break block.
func (_dfab *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cegeb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_cded :=ctx ;_cded .Y =ctx .Margins .Top ;
_cded .X =ctx .Margins .Left ;_cded .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_cded .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_cded ;return _cegeb ,ctx ,nil ;};func (_aecc *StyledParagraph )getTextWidth ()float64 {var _cbaf float64 ;
_bbcdg :=len (_aecc ._beaee );for _edad ,_cbea :=range _aecc ._beaee {_dccf :=&_cbea .Style ;_dfgd :=len (_cbea .Text );for _aeeaa ,_bfbfc :=range _cbea .Text {if _bfbfc =='\u000A'{continue ;};_gcddc ,_fdde :=_dccf .Font .GetRuneMetrics (_bfbfc );if !_fdde {_c .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bfbfc );
return -1;};_cbaf +=_dccf .FontSize *_gcddc .Wx *_dccf .horizontalScale ();if _bfbfc !=' '&&(_edad !=_bbcdg -1||_aeeaa !=_dfgd -1){_cbaf +=_dccf .CharSpacing *1000.0;};};};return _cbaf ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_cebe *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_bbgf ,_ ,_fe :=d .GeneratePageBlocks (ctx );if _fe !=nil {return _fe ;};if len (_bbgf )!=1{return _g .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_fbe :=range _bbgf {if _dgg :=_cebe .mergeBlocks (_fbe );_dgg !=nil {return _dgg ;};};return nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_ccdg *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ccdg ._bcbb .Left ,_ccdg ._bcbb .Right ,_ccdg ._bcbb .Top ,_ccdg ._bcbb .Bottom ;};

// NewTOC creates a new table of contents.
func (_efff *Creator )NewTOC (title string )*TOC {_cgdfd :=_efff .NewTextStyle ();_cgdfd .Font =_efff ._ffdb ;return _gebe (title ,_efff .NewTextStyle (),_cgdfd );};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_gadc *TOC )SetLinePageStyle (style TextStyle ){_gadc ._fbcec =style };

// SetBorderOpacity sets the border opacity.
func (_febf *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_febf ._fbbbf =opacity };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ced *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ced ._bd .Left ,_ced ._bd .Right ,_ced ._bd .Top ,_ced ._bd .Bottom ;};func (_caefe *Invoice )generateTotalBlocks (_dcfb DrawContext )([]*Block ,DrawContext ,error ){_gdgd :=_bccg (4);
_gdgd .SetMargins (0,0,10,10);_dggg :=[][2]*InvoiceCell {_caefe ._gbbb };_dggg =append (_dggg ,_caefe ._dacdf ...);_dggg =append (_dggg ,_caefe ._fedc );for _ ,_cffc :=range _dggg {_gagd ,_bbfd :=_cffc [0],_cffc [1];if _bbfd .Value ==""{continue ;};_gdgd .SkipCells (2);
_bccdf :=_gdgd .NewCell ();_bccdf .SetBackgroundColor (_gagd .BackgroundColor );_bccdf .SetHorizontalAlignment (_bbfd .Alignment );_caefe .setCellBorder (_bccdf ,_gagd );_fdeeg :=_egeg (_gagd .TextStyle );_fdeeg .SetMargins (0,0,2,1);_fdeeg .Append (_gagd .Value );
_bccdf .SetContent (_fdeeg );_bccdf =_gdgd .NewCell ();_bccdf .SetBackgroundColor (_bbfd .BackgroundColor );_bccdf .SetHorizontalAlignment (_bbfd .Alignment );_caefe .setCellBorder (_bccdf ,_gagd );_fdeeg =_egeg (_bbfd .TextStyle );_fdeeg .SetMargins (0,0,2,1);
_fdeeg .Append (_bbfd .Value );_bccdf .SetContent (_fdeeg );};return _gdgd .GeneratePageBlocks (_dcfb );};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_fegge *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bacd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aaec ,_ ,_fcc :=_fegge .draw ("");if _fcc !=nil {return nil ,ctx ,_fcc ;};_fcc =_bacd .addContentsByString (string (_aaec ));
if _fcc !=nil {return nil ,ctx ,_fcc ;};return []*Block {_bacd },ctx ,nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_deff float64 ;_dacf float64 ;_adcb float64 ;_fbef float64 ;_bfdg Positioning ;_abeb Color ;_egcf Color ;_gadf float64 ;};

// SetBorderColor sets the border color.
func (_aacf *Polygon )SetBorderColor (color Color ){_aacf ._gged .BorderColor =_eeg (color )};

// SetLineColor sets the line color.
func (_ggfe *Polyline )SetLineColor (color Color ){_ggfe ._abdb .LineColor =_eeg (color )};func _dgbf (_abgba *_cb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_abgba ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;func _fbadf (_geacd int64 ,_adcbe ,_eedae ,_bbdd float64 )*_cb .PdfAnnotation {_dbcb :=_cb .NewPdfAnnotationLink ();_gagc :=_cb .NewBorderStyle ();_gagc .SetBorderWidth (0);_dbcb .BS =_gagc .ToPdfObject ();if _geacd < 0{_geacd =0;
};_dbcb .Dest =_af .MakeArray (_af .MakeInteger (_geacd ),_af .MakeName ("\u0058\u0059\u005a"),_af .MakeFloat (_adcbe ),_af .MakeFloat (_eedae ),_af .MakeFloat (_bbdd ));return _dbcb .PdfAnnotation ;};

// SetTitle sets the title of the invoice.
func (_beebb *Invoice )SetTitle (title string ){_beebb ._fdec =title };

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_dbed *Table )MultiCell (rowspan ,colspan int )*TableCell {_dbed ._agcb ++;_aaae :=(_dbed .moveToNextAvailableCell ()-1)%(_dbed ._bbac )+1;_cegfc :=(_dbed ._agcb -1)/_dbed ._bbac +1;for _cegfc > _dbed ._ccgd {_dbed ._ccgd ++;_dbed ._cede =append (_dbed ._cede ,_dbed ._dfbd );
};_gcac :=&TableCell {};_gcac ._ddfbb =_cegfc ;_gcac ._aaad =_aaae ;_gcac ._abg =5;_gcac ._aadbb =CellBorderStyleNone ;_gcac ._fedac =_fce .LineStyleSolid ;_gcac ._ebbae =CellHorizontalAlignmentLeft ;_gcac ._abfga =CellVerticalAlignmentTop ;_gcac ._ffcd =0;
_gcac ._gdcc =0;_gcac ._bfdb =0;_gcac ._cecbb =0;_bafae :=ColorBlack ;_gcac ._gecf =_bafae ;_gcac ._debg =_bafae ;_gcac ._caeda =_bafae ;_gcac ._ggeg =_bafae ;if rowspan < 1{_c .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_dfbda :=_dbed ._ccgd -(_gcac ._ddfbb -1);if rowspan > _dfbda {_c .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_dfbda );
_dbed ._ccgd +=rowspan -1;for _gecfb :=0;_gecfb <=rowspan -_dfbda ;_gecfb ++{_dbed ._cede =append (_dbed ._cede ,_dbed ._dfbd );};};for _ccdfb :=0;_ccdfb < colspan &&_aaae +_ccdfb -1< len (_dbed ._fgff );_ccdfb ++{_dbed ._fgff [_aaae +_ccdfb -1]=rowspan -1;
};_gcac ._bgfcd =rowspan ;if colspan < 1{_c .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_fgged :=_dbed ._bbac -(_gcac ._aaad -1);if colspan > _fgged {_c .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_fgged );
colspan =_fgged ;};_gcac ._ggfa =colspan ;_dbed ._agcb +=colspan -1;_dbed ._caccb =append (_dbed ._caccb ,_gcac );_gcac ._eceb =_dbed ;return _gcac ;};

// SetFillColor sets the fill color.
func (_affc *PolyBezierCurve )SetFillColor (color Color ){_affc ._ccfa .FillColor =_eeg (color )};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_agfc *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _eebc (x ,y ,width ,height );};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_caffe *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_eagd :=range subtable ._caccb {_gcadc :=&TableCell {};*_gcadc =*_eagd ;_gcadc ._eceb =_caffe ;_gcadc ._aaad +=col -1;if _gafd :=_caffe ._bbac -(_gcadc ._aaad -1);_gafd < _gcadc ._ggfa {_caffe ._bbac +=_gcadc ._ggfa -_gafd ;
_caffe .resetColumnWidths ();_c .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_caffe ._bbac );
};_gcadc ._ddfbb +=row -1;_cdbe :=subtable ._cede [_eagd ._ddfbb -1];if _gcadc ._ddfbb > _caffe ._ccgd {for _gcadc ._ddfbb > _caffe ._ccgd {_caffe ._ccgd ++;_caffe ._cede =append (_caffe ._cede ,_caffe ._dfbd );};_caffe ._cede [_gcadc ._ddfbb -1]=_cdbe ;
}else {_caffe ._cede [_gcadc ._ddfbb -1]=_bf .Max (_caffe ._cede [_gcadc ._ddfbb -1],_cdbe );};_caffe ._caccb =append (_caffe ._caccb ,_gcadc );};_d .Slice (_caffe ._caccb ,func (_fcgf ,_fdfe int )bool {_gbbfb :=_caffe ._caccb [_fcgf ]._ddfbb ;_cdfdf :=_caffe ._caccb [_fdfe ]._ddfbb ;
if _gbbfb < _cdfdf {return true ;};if _gbbfb > _cdfdf {return false ;};return _caffe ._caccb [_fcgf ]._aaad < _caffe ._caccb [_fdfe ]._aaad ;});};

// SetFillColor sets the fill color.
func (_adbgc *Polygon )SetFillColor (color Color ){_adbgc ._gged .FillColor =_eeg (color )};

// SkipCells skips over a specified number of cells in the table.
func (_eefdd *Table )SkipCells (num int ){if num < 0{_c .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_eefdd ._agcb +=num ;};

// SetWidthRight sets border width for right.
func (_dfe *border )SetWidthRight (bw float64 ){_dfe ._abf =bw };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_ggag *Image )SetWidth (w float64 ){_ggag ._dbf =w };

// SetWidthBottom sets border width for bottom.
func (_dca *border )SetWidthBottom (bw float64 ){_dca ._dcdf =bw };

// NewPageBreak create a new page break.
func (_ggce *Creator )NewPageBreak ()*PageBreak {return _gefd ()};type border struct{_bbaa float64 ;_dbd float64 ;_cbbc float64 ;_efc float64 ;_fgge Color ;_gfe Color ;_degc float64 ;_ffea Color ;_dcdf float64 ;_dec Color ;_abf float64 ;_cfg Color ;_ca float64 ;
LineStyle _fce .LineStyle ;_dcff CellBorderStyle ;_ade CellBorderStyle ;_bfa CellBorderStyle ;_ddd CellBorderStyle ;};

// Width returns Image's document width.
func (_baeg *Image )Width ()float64 {return _baeg ._dbf };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fgag *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_dafde :=_egeg (_fgag ._cdfc );_dafde .Append (text );_acfb ,_fcegc :=_fgag .Add (_dafde );return _dafde ,_acfb ,_fcegc ;};func (_fcce *Invoice )drawInformation ()*Table {_bead :=_bccg (2);
_cag :=append ([][2]*InvoiceCell {_fcce ._bgbg ,_fcce ._fgcgf ,_fcce ._adeg },_fcce ._eeege ...);for _ ,_fgbb :=range _cag {_cefc ,_ecde :=_fgbb [0],_fgbb [1];if _ecde .Value ==""{continue ;};_ebbab :=_bead .NewCell ();_ebbab .SetBackgroundColor (_cefc .BackgroundColor );
_fcce .setCellBorder (_ebbab ,_cefc );_cgeb :=_egeg (_cefc .TextStyle );_cgeb .Append (_cefc .Value );_cgeb .SetMargins (0,0,2,1);_ebbab .SetContent (_cgeb );_ebbab =_bead .NewCell ();_ebbab .SetBackgroundColor (_ecde .BackgroundColor );_fcce .setCellBorder (_ebbab ,_ecde );
_cgeb =_egeg (_ecde .TextStyle );_cgeb .Append (_ecde .Value );_cgeb .SetMargins (0,0,2,1);_ebbab .SetContent (_cgeb );};return _bead ;};

// SetAngle sets the rotation angle of the text.
func (_fgdg *Paragraph )SetAngle (angle float64 ){_fgdg ._accgb =angle };

// NewTable create a new Table with a specified number of columns.
func (_addg *Creator )NewTable (cols int )*Table {return _bccg (cols )};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_cgg *Creator )MoveDown (dy float64 ){_cgg ._fcdd .Y +=dy };

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_cb .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_dgdeg *Paragraph )SetTextAlignment (align TextAlignment ){_dgdeg ._fedfa =align };

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_edbb *Division )EnablePageWrap (enable bool ){_edbb ._cgdgb =enable };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_eced float64 ;_bdce float64 ;_aedd float64 ;_ccba float64 ;_dbbb float64 ;_gcg float64 ;_ccab Color ;_afe float64 ;};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_adcc *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcgf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bgcc :=_fce .Line {LineWidth :_adcc ._bfefd ,Opacity :1.0,LineColor :_eeg (_adcc ._ecfd ),LineEndingStyle1 :_fce .LineEndingStyleNone ,LineEndingStyle2 :_fce .LineEndingStyleNone ,X1 :_adcc ._eae ,Y1 :ctx .PageHeight -_adcc ._adce ,X2 :_adcc ._ggbe ,Y2 :ctx .PageHeight -_adcc ._bceb };
_bfcb ,_ ,_dbbc :=_bgcc .Draw ("");if _dbbc !=nil {return nil ,ctx ,_dbbc ;};_dbbc =_bcgf .addContentsByString (string (_bfcb ));if _dbbc !=nil {return nil ,ctx ,_dbbc ;};return []*Block {_bcgf },ctx ,nil ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_cdaf *List )Add (item VectorDrawable )(*TextChunk ,error ){_aabd :=&listItem {_degd :item ,_fddf :_cdaf ._daee };switch _ebab :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _ebab ._adbgb {_ebab ._gbdf =15;};default:return nil ,_g .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_cdaf ._bfed =append (_cdaf ._bfed ,_aabd );return &_aabd ._fddf ,nil ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_defg *Image )ScaleToWidth (w float64 ){_dfda :=_defg ._becd /_defg ._dbf ;_defg ._dbf =w ;_defg ._becd =w *_dfda ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// SetNumber sets the number of the invoice.
func (_baab *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_baab ._bgbg [1].Value =number ;return _baab ._bgbg [0],_baab ._bgbg [1];};

// TitleStyle returns the style properties used to render the invoice title.
func (_fadf *Invoice )TitleStyle ()TextStyle {return _fadf ._bbgg };

// Append adds a new text chunk to the paragraph.
func (_gcdd *StyledParagraph )Append (text string )*TextChunk {_bcgdd :=NewTextChunk (text ,_gcdd ._ecfb );return _gcdd .appendChunk (_bcgdd );};func (_eg *Block )drawToPage (_aed *_cb .PdfPage )error {_fbf :=&_fb .ContentStreamOperations {};if _aed .Resources ==nil {_aed .Resources =_cb .NewPdfPageResources ();
};_eec :=_dda (_fbf ,_aed .Resources ,_eg ._dg ,_eg ._ba );if _eec !=nil {return _eec ;};if _eec =_dag (_eg ._ba ,_aed .Resources );_eec !=nil {return _eec ;};if _eec =_aed .AppendContentBytes (_fbf .Bytes (),true );_eec !=nil {return _eec ;};for _ ,_bc :=range _eg ._ad {_aed .AddAnnotation (_bc );
};return nil ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bbfc *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _bbfc ._adeg [0],_bbfc ._adeg [1]};

// SetStyleBottom sets border style for bottom side.
func (_aad *border )SetStyleBottom (style CellBorderStyle ){_aad ._ddd =style };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_feag *Creator )Draw (d Drawable )error {if _feag .getActivePage ()==nil {_feag .NewPage ();};_efde ,_egc ,_ffeb :=d .GeneratePageBlocks (_feag ._fcdd );if _ffeb !=nil {return _ffeb ;};if len (_egc ._cba )> 0{_feag .Errors =append (_feag .Errors ,_egc ._cba ...);
};for _dcfc ,_bagg :=range _efde {if _dcfc > 0{_feag .NewPage ();};_feb :=_feag .getActivePage ();if _ggc ,_bfeg :=_feag ._bdec [_feb ];_bfeg {if _agcc :=_ggc .mergeBlocks (_bagg );_agcc !=nil {return _agcc ;};if _dbgga :=_dag (_bagg ._ba ,_ggc ._ba );
_dbgga !=nil {return _dbgga ;};}else {_feag ._bdec [_feb ]=_bagg ;};};_feag ._fcdd .X =_egc .X ;_feag ._fcdd .Y =_egc .Y ;_feag ._fcdd .Height =_egc .PageHeight -_egc .Y -_egc .Margins .Bottom ;return nil ;};func (_deg *Block )translate (_be ,_acfe float64 ){_gff :=_fb .NewContentCreator ().Translate (_be ,-_acfe ).Operations ();
*_deg ._dg =append (*_gff ,*_deg ._dg ...);_deg ._dg .WrapIfNeeded ();};func _fcca (_dbbg *_cb .PdfAnnotationLink )*_cb .PdfAnnotationLink {if _dbbg ==nil {return nil ;};_dbfgd :=_cb .NewPdfAnnotationLink ();_dbfgd .BS =_dbbg .BS ;_dbfgd .A =_dbbg .A ;
if _dfcc ,_dgggc :=_dbbg .GetAction ();_dgggc ==nil &&_dfcc !=nil {_dbfgd .SetAction (_dfcc );};if _ccce ,_cfcc :=_dbbg .Dest .(*_af .PdfObjectArray );_cfcc {_dbfgd .Dest =_af .MakeArray (_ccce .Elements ()...);};return _dbfgd ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_febbd *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdffd :=_febbd ;if _febbd ._bdda {_cdffd =_febbd .clone ();};return _fdfa (_cdffd ,ctx );};

// WriteToFile writes the Creator output to file specified by path.
func (_fgdb *Creator )WriteToFile (outputPath string )error {_bfda ,_bgaff :=_f .Create (outputPath );if _bgaff !=nil {return _bgaff ;};defer _bfda .Close ();return _fgdb .Write (_bfda );};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_fdb *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fdb ._ceg .Left ,_fdb ._ceg .Right ,_fdb ._ceg .Top ,_fdb ._ceg .Bottom ;};

// SetDate sets the date of the invoice.
func (_bgbf *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_bgbf ._fgcgf [1].Value =date ;return _bgbf ._fgcgf [0],_bgbf ._fgcgf [1];};func (_cdfd rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _cdfd ._cfdc ,_cdfd ._ace ,_cdfd ._bge };


// NewImageFromData creates an Image from image data.
func (_deb *Creator )NewImageFromData (data []byte )(*Image ,error ){return _fac (data )};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
func (_gbeb *Division )Add (d VectorDrawable )error {switch _ddeg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Table ,*Division :case containerDrawable :_dacd ,_beae :=_ddeg .ContainerComponent (_gbeb );if _beae !=nil {return _beae ;
};_def ,_dabd :=_dacd .(VectorDrawable );if !_dabd {return _fc .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_dacd );
};d =_def ;default:return _g .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gbeb ._baecf =append (_gbeb ._baecf ,d );return nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_dgcg *StyledParagraph )SetPos (x ,y float64 ){_dgcg ._geegb =PositionAbsolute ;_dgcg ._gfae =x ;_dgcg ._baegd =y ;};

// SetFillColor sets the fill color.
func (_aefa *Rectangle )SetFillColor (col Color ){_aefa ._ffba =col };func _bfabg (_defaa *_f .File )([]*_cb .PdfPage ,error ){_dgff ,_cfaf :=_cb .NewPdfReader (_defaa );if _cfaf !=nil {return nil ,_cfaf ;};_acgbd ,_cfaf :=_dgff .GetNumPages ();if _cfaf !=nil {return nil ,_cfaf ;
};var _fdgcb []*_cb .PdfPage ;for _gaada :=0;_gaada < _acgbd ;_gaada ++{_dbdf ,_bbagf :=_dgff .GetPage (_gaada +1);if _bbagf !=nil {return nil ,_bbagf ;};_fdgcb =append (_fdgcb ,_dbdf );};return _fdgcb ,nil ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_dagbg *TOC )SetShowLinks (showLinks bool ){_dagbg ._gaff =showLinks };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;var PPI float64 =72;

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_agce *Creator )SetPageLabels (pageLabels _af .PdfObject ){_agce ._cfdd =pageLabels };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_bfed []*listItem ;_fdgdb Margins ;_daee TextChunk ;_gbdf float64 ;_adbgb bool ;_aadg Positioning ;_cdfc TextStyle ;};

// Reset removes all the text chunks the paragraph contains.
func (_cdfg *StyledParagraph )Reset (){_cdfg ._beaee =[]*TextChunk {}};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_aecfg *Invoice )InfoLines ()[][2]*InvoiceCell {_fdbb :=[][2]*InvoiceCell {_aecfg ._bgbg ,_aecfg ._fgcgf ,_aecfg ._adeg };return append (_fdbb ,_aecfg ._eeege ...);};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_dcbc *Table )SetMargins (left ,right ,top ,bottom float64 ){_dcbc ._cfdgg .Left =left ;_dcbc ._cfdgg .Right =right ;_dcbc ._cfdgg .Top =top ;_dcbc ._cfdgg .Bottom =bottom ;};func _bccg (_cgee int )*Table {_bbecd :=&Table {_bbac :_cgee ,_dfbd :10.0,_cbbda :[]float64 {},_cede :[]float64 {},_caccb :[]*TableCell {},_fgff :make ([]int ,_cgee ),_egdc :true };
_bbecd .resetColumnWidths ();return _bbecd ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_cefg _ab .ChartRenderable ;_afbb Positioning ;_fbfd float64 ;_agec float64 ;_ceg Margins ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_efaga *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _efaga ._ceff .Left ,_efaga ._ceff .Right ,_efaga ._ceff .Top ,_efaga ._ceff .Bottom ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bffd *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _dcfbb float64 ;var _geba []*StyledParagraph ;for _ ,_dedc :=range _bffd ._bfed {_adbec :=_egeg (_bffd ._cdfc );_adbec .SetEnableWrap (false );_adbec .SetTextAlignment (TextAlignmentRight );
_adbec .Append (_dedc ._fddf .Text ).Style =_dedc ._fddf .Style ;_cgcg :=_adbec .getTextWidth ()/1000.0/ctx .Width ;if _dcfbb < _cgcg {_dcfbb =_cgcg ;};_geba =append (_geba ,_adbec );};_bgedg :=_bccg (2);_bgedg .SetColumnWidths (_dcfbb ,1-_dcfbb );_bgedg .SetMargins (_bffd ._gbdf ,0,0,0);
for _adaf ,_cedg :=range _bffd ._bfed {_eaaec :=_bgedg .NewCell ();_eaaec .SetIndent (0);_eaaec .SetContent (_geba [_adaf ]);_eaaec =_bgedg .NewCell ();_eaaec .SetIndent (0);_eaaec .SetContent (_cedg ._degd );};return _bgedg .GeneratePageBlocks (ctx );
};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_bfada *TOC )SetLineLevelOffset (levelOffset float64 ){_bfada ._eedad =levelOffset };

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ebb *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeb :=_fb .NewContentCreator ();_ce ,_cef :=_ebb .Width (),_ebb .Height ();if _ebb ._ef .IsRelative (){_aeb .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_cef );}else {_aeb .Translate (_ebb ._eff ,ctx .PageHeight -_ebb ._de -_cef );
};_bb :=_cef ;if _ebb ._fbc !=0{_aeb .Translate (_ce /2,_cef /2);_aeb .RotateDeg (_ebb ._fbc );_aeb .Translate (-_ce /2,-_cef /2);_ ,_bb =_ebb .RotatedSize ();};if _ebb ._ef .IsRelative (){ctx .Y +=_bb ;};_ga :=_ebb .duplicate ();_fbd :=append (*_aeb .Operations (),*_ga ._dg ...);
_fbd .WrapIfNeeded ();_ga ._dg =&_fbd ;return []*Block {_ga },ctx ,nil ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_dfg *Creator )DrawHeader (drawHeaderFunc func (_fcbf *Block ,_bag HeaderFunctionArgs )){_dfg ._fgfg =drawHeaderFunc ;};func (_ggcc *StyledParagraph )getLineMetrics (_dcee int )(_fgefb ,_cccb ,_adgc float64 ){if _ggcc ._defff ==nil ||len (_ggcc ._defff )==0{_ggcc .wrapText ();
};if _dcee < 0||_dcee > len (_ggcc ._defff )-1{_c .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_dcee );
return 0,0,0;};_fag :=_ggcc ._defff [_dcee ];for _ ,_cddd :=range _fag {_bbbfb ,_gddb :=_cddd .Style .Font .GetFontDescriptor ();if _gddb !=nil {_c .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _fcead ,_gbbc float64 ;if _bbbfb !=nil {if _fcead ,_gddb =_bbbfb .GetCapHeight ();_gddb !=nil {_c .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_gddb );
};if _gbbc ,_gddb =_bbbfb .GetDescent ();_gddb !=nil {_c .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_gddb );
};};if int (_fcead )<=0{_c .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_fcead =1000;};if _adde :=_fcead /1000.0*_cddd .Style .FontSize ;_adde > _fgefb {_fgefb =_adde ;};if _gedac :=_cddd .Style .FontSize ;_gedac > _cccb {_cccb =_gedac ;};if _ecgg :=_gbbc /1000.0*_cddd .Style .FontSize ;_ecgg < _adgc {_adgc =_ecgg ;};};return _fgefb ,_cccb ,_adgc ;
};func _gfaeg (_dbcde string )*_cb .PdfAnnotation {_cacef :=_cb .NewPdfAnnotationLink ();_bedf :=_cb .NewBorderStyle ();_bedf .SetBorderWidth (0);_cacef .BS =_bedf .ToPdfObject ();_bcdbg :=_cb .NewPdfActionURI ();_bcdbg .URI =_af .MakeString (_dbcde );
_cacef .SetAction (_bcdbg .PdfAction );return _cacef .PdfAnnotation ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bcbc *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bcbc .Text },nil ;};var _aafcg []string ;var _acebg []rune ;var _ccbgf float64 ;var _abga []float64 ;_edac :=_bcbc .Style ;for _ ,_agbfb :=range _bcbc .Text {if _agbfb =='\u000A'{_aafcg =append (_aafcg ,_e .TrimRightFunc (string (_acebg ),_fg .IsSpace )+string (_agbfb ));
_acebg =nil ;_ccbgf =0;_abga =nil ;continue ;};_ecdf :=_agbfb ==' ';_cgaff ,_fegf :=_edac .Font .GetRuneMetrics (_agbfb );if !_fegf {_c .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_agbfb ,_agbfb ,_edac .Font .BaseFont (),_edac .Font .Subtype ());
_c .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_edac .Font );_c .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_edac .Font .Encoder ());return nil ,_g .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_efbcc :=_edac .FontSize *_cgaff .Wx ;_aebg :=_efbcc ;if !_ecdf {_aebg =_efbcc +_edac .CharSpacing *1000.0;};if _ccbgf +_efbcc > width *1000.0{_bcbd :=-1;if !_ecdf {for _fgaf :=len (_acebg )-1;_fgaf >=0;_fgaf --{if _acebg [_fgaf ]==' '{_bcbd =_fgaf ;
break ;};};};_cbdeg :=string (_acebg );if _bcbd > 0{_cbdeg =string (_acebg [0:_bcbd +1]);_acebg =append (_acebg [_bcbd +1:],_agbfb );_abga =append (_abga [_bcbd +1:],_aebg );_ccbgf =0;for _ ,_dabdg :=range _abga {_ccbgf +=_dabdg ;};}else {if _ecdf {_acebg =[]rune {};
_abga =[]float64 {};_ccbgf =0;}else {_acebg =[]rune {_agbfb };_abga =[]float64 {_aebg };_ccbgf =_aebg ;};};_aafcg =append (_aafcg ,_e .TrimRightFunc (_cbdeg ,_fg .IsSpace ));}else {_acebg =append (_acebg ,_agbfb );_ccbgf +=_aebg ;_abga =append (_abga ,_aebg );
};};if len (_acebg )> 0{_aafcg =append (_aafcg ,string (_acebg ));};return _aafcg ,nil ;};func (_ggff *List )tableHeight (_decb float64 )float64 {var _bgecf float64 ;for _ ,_dbda :=range _ggff ._bfed {switch _cddg :=_dbda ._degd .(type ){case *Paragraph :_ffdfg :=_cddg ;
if _ffdfg ._cccg {_ffdfg .SetWidth (_decb );};_bgecf +=_ffdfg .Height ()+_ffdfg ._ceff .Bottom +_ffdfg ._ceff .Bottom ;_bgecf +=0.5*_ffdfg ._ccfe *_ffdfg ._affa ;case *StyledParagraph :_aefg :=_cddg ;if _aefg ._aegb {_aefg .SetWidth (_decb );};_bgecf +=_aefg .Height ()+_aefg ._bcbb .Top +_aefg ._bcbb .Bottom ;
_bgecf +=0.5*_aefg .getTextHeight ();default:_bgecf +=_dbda ._degd .Height ();};};return _bgecf ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_aaag *Invoice )Notes ()(string ,string ){return _aaag ._gbbf [0],_aaag ._gbbf [1]};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Table
// - *List
// - *Division
// - *Chart
// - *Rectangle
// - *Ellipse
func (_abaeg *TableCell )SetContent (vd VectorDrawable )error {switch _dfff :=vd .(type ){case *Paragraph :if _dfff ._fcea {_dfff ._cccg =true ;};_abaeg ._fgec =vd ;case *StyledParagraph :if _dfff ._faaa {_dfff ._aegb =true ;};_abaeg ._fgec =vd ;case *Image :_abaeg ._fgec =vd ;
case *Table :_abaeg ._fgec =vd ;case *List :_abaeg ._fgec =vd ;case *Division :_abaeg ._fgec =vd ;case *Chart :_abaeg ._fgec =vd ;case *Ellipse :_abaeg ._fgec =vd ;case *Rectangle :_abaeg ._fgec =vd ;default:_c .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _af .ErrTypeError ;};return nil ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_cgcded *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _g .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _g .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _g .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_cgcded ._bdgb =true ;_cgcded ._cgaea =startRow ;_cgcded ._fbbce =endRow ;return nil ;};type pageTransformations struct{_gcaf *_cf .Matrix ;_gbe bool ;_cdfa bool ;};

// Angle returns the block rotation angle in degrees.
func (_da *Block )Angle ()float64 {return _da ._fbc };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_degfa *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffgf :=ctx ;var _ccea []*Block ;_efbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _degfa ._gbeaa .IsRelative (){ctx .X +=_degfa ._ceff .Left ;ctx .Y +=_degfa ._ceff .Top ;
ctx .Width -=_degfa ._ceff .Left +_degfa ._ceff .Right ;ctx .Height -=_degfa ._ceff .Top ;_degfa .SetWidth (ctx .Width );if _degfa .Height ()> ctx .Height {_ccea =append (_ccea ,_efbb );_efbb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bebff :=ctx ;
_bebff .Y =ctx .Margins .Top ;_bebff .X =ctx .Margins .Left +_degfa ._ceff .Left ;_bebff .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bebff .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_degfa ._ceff .Left -_degfa ._ceff .Right ;
ctx =_bebff ;};}else {if int (_degfa ._gbfe )<=0{_degfa .SetWidth (_degfa .getTextWidth ());};ctx .X =_degfa ._ceeec ;ctx .Y =_degfa ._abfdg ;};ctx ,_bgdfg :=_aacg (_efbb ,_degfa ,ctx );if _bgdfg !=nil {_c .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgdfg );
return nil ,ctx ,_bgdfg ;};_ccea =append (_ccea ,_efbb );if _degfa ._gbeaa .IsRelative (){ctx .Y +=_degfa ._ceff .Bottom ;ctx .Height -=_degfa ._ceff .Bottom ;if !ctx .Inline {ctx .X =_ffgf .X ;ctx .Width =_ffgf .Width ;};return _ccea ,ctx ,nil ;};return _ccea ,_ffgf ,nil ;
};

// Cols returns the total number of columns the table has.
func (_aacd *Table )Cols ()int {return _aacd ._bbac };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_eeda *Creator )SetOutlineTree (outlineTree *_cb .PdfOutlineTreeNode ){_eeda ._befg =outlineTree };

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_fbaaf *Table )EnablePageWrap (enable bool ){_fbaaf ._egdc =enable };

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_gcddg *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_geaab :=NewTextChunk (text ,_gcddg ._bcgeg );_geaab ._gdda =_fbadf (page -1,x ,y ,zoom );return _gcddg .appendChunk (_geaab );};

// Logo returns the logo of the invoice.
func (_egac *Invoice )Logo ()*Image {return _egac ._dada };

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_fcbd string ;_afad *_cb .PdfFont ;_ccfe float64 ;_affa float64 ;_eddf Color ;_fedfa TextAlignment ;_cccg bool ;_gbfe float64 ;_gcba int ;_fcea bool ;_accgb float64 ;_ceff Margins ;_gbeaa Positioning ;_ceeec float64 ;_abfdg float64 ;
_agga ,_acbf float64 ;_febc []string ;};func (_daga *Chapter )headingText ()string {_agbe :=_daga ._dafa ;if _beff :=_daga .headingNumber ();_beff !=""{_agbe =_fc .Sprintf ("\u0025\u0073\u0020%\u0073",_beff ,_agbe );};return _agbe ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_gedf *TOC )SetLineStyle (style TextStyle ){_gedf .SetLineNumberStyle (style );_gedf .SetLineTitleStyle (style );_gedf .SetLineSeparatorStyle (style );_gedf .SetLinePageStyle (style );};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_cgbf *Creator )EnableFontSubsetting (font *_cb .PdfFont ){_cgbf ._dcgd =append (_cgbf ._dcgd ,font );};func (_cbg cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_fcda :=_cbg ._fdf ;return 1-(_cbg ._caa *(1-_fcda )+_fcda ),1-(_cbg ._ecd *(1-_fcda )+_fcda ),1-(_cbg ._babb *(1-_fcda )+_fcda );
};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_cedfg *Creator )NewPolyBezierCurve (curves []_fce .CubicBezierCurve )*PolyBezierCurve {return _dcfd (curves );};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_cfeg *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_cfeg ._dgfe =alignment };

// SetText sets the text content of the Paragraph.
func (_bbff *Paragraph )SetText (text string ){_bbff ._fcbd =text };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_dbdea *TOCLine )SetStyle (style TextStyle ){_dbdea .Number .Style =style ;_dbdea .Title .Style =style ;_dbdea .Separator .Style =style ;_dbdea .Page .Style =style ;};

// Columns returns all the columns in the invoice line items table.
func (_egb *Invoice )Columns ()[]*InvoiceCell {return _egb ._efdf };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_bgfcc *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_bfgcc :=&_bgfcc ._ddfc ._bcbb ;return _bgfcc ._dbee ,_bfgcc .Right ,_bfgcc .Top ,_bfgcc .Bottom ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_afdc *List )Width ()float64 {return 0};

// GeneratePageBlocks draws the curve onto page blocks.
func (_cbeb *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dacb :=_fb .NewContentCreator ();_dacb .Add_q ().Add_w (_cbeb ._afe ).SetStrokingColor (_eeg (_cbeb ._ccab )).Add_m (_cbeb ._eced ,ctx .PageHeight -_cbeb ._bdce ).Add_v (_cbeb ._aedd ,ctx .PageHeight -_cbeb ._ccba ,_cbeb ._dbbb ,ctx .PageHeight -_cbeb ._gcg ).Add_S ().Add_Q ();
_begd :=_aab .addContentsByString (_dacb .String ());if _begd !=nil {return nil ,ctx ,_begd ;};return []*Block {_aab },ctx ,nil ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_cfac *Table )EnableRowWrap (enable bool ){_cfac ._bdda =enable };

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_cffg *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_cffg ._cdca =toc ;};func (_ccfg *InvoiceAddress )fmtLine (_dcegf ,_gfddc string ,_eebfa bool )string {if _eebfa {_gfddc ="";};return _fc .Sprintf ("\u0025\u0073\u0025s\u000a",_gfddc ,_dcegf );
};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_fcf *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcf ._acbg .Left ,_fcf ._acbg .Right ,_fcf ._acbg .Top ,_fcf ._acbg .Bottom ;};func (_cggf *TableCell )height (_cgcgf float64 )float64 {var _fgdd float64 ;switch _gfbfb :=_cggf ._fgec .(type ){case *Paragraph :if _gfbfb ._cccg {_gfbfb .SetWidth (_cgcgf -_cggf ._abg -_gfbfb ._ceff .Left -_gfbfb ._ceff .Right );
};_fgdd =_gfbfb .Height ()+_gfbfb ._ceff .Top +_gfbfb ._ceff .Bottom +0.5*_gfbfb ._ccfe *_gfbfb ._affa ;case *StyledParagraph :if _gfbfb ._aegb {_gfbfb .SetWidth (_cgcgf -_cggf ._abg -_gfbfb ._bcbb .Left -_gfbfb ._bcbb .Right );};_fgdd =_gfbfb .Height ()+_gfbfb ._bcbb .Top +_gfbfb ._bcbb .Bottom +0.5*_gfbfb .getTextHeight ();
case *Image :_fgdd =_gfbfb .Height ()+_gfbfb ._acbg .Top +_gfbfb ._acbg .Bottom ;case *Table :_gfbfb .updateRowHeights (_cgcgf -_cggf ._abg -_gfbfb ._cfdgg .Left -_gfbfb ._cfdgg .Right );_fgdd =_gfbfb .Height ()+_gfbfb ._cfdgg .Top +_gfbfb ._cfdgg .Bottom ;
case *List :_fgdd =_gfbfb .tableHeight (_cgcgf -_cggf ._abg )+_gfbfb ._fdgdb .Top +_gfbfb ._fdgdb .Bottom ;case *Division :_fgdd =_gfbfb .ctxHeight (_cgcgf -_cggf ._abg )+_gfbfb ._gffe .Top +_gfbfb ._gffe .Bottom ;case *Chart :_fgdd =_gfbfb .Height ()+_gfbfb ._ceg .Top +_gfbfb ._ceg .Bottom ;
case *Rectangle :_fgdd =_gfbfb .Height ();case *Ellipse :_fgdd =_gfbfb .Height ();};return _fgdd ;};

// MoveY moves the drawing context to absolute position y.
func (_ccgb *Creator )MoveY (y float64 ){_ccgb ._fcdd .Y =y };

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_egg *Creator )PageFinalize (pageFinalizeFunc func (_eeeg PageFinalizeFunctionArgs )error ){_egg ._eba =pageFinalizeFunc ;};

// NewCurvePolygon creates a new curve polygon.
func (_cdcc *Creator )NewCurvePolygon (rings [][]_fce .CubicBezierCurve )*CurvePolygon {return _ffa (rings );};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_fcbc *Creator )MoveTo (x ,y float64 ){_fcbc ._fcdd .X =x ;_fcbc ._fcdd .Y =y };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_gcf *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agfb ,_egef :=_acgg .setOpacity (_gcf ._dfaf ,_gcf ._fbbbf );if _egef !=nil {return nil ,ctx ,_egef ;
};_dace :=_gcf ._ccfa ;_dace .FillEnabled =_dace .FillColor !=nil ;var (_ggaca =ctx .PageHeight ;_dgdeb =_dace .Curves ;_gggb =make ([]_fce .CubicBezierCurve ,0,len (_dace .Curves )););for _gcda :=range _dace .Curves {_cbfg :=_dgdeb [_gcda ];_cbfg .P0 .Y =_ggaca -_cbfg .P0 .Y ;
_cbfg .P1 .Y =_ggaca -_cbfg .P1 .Y ;_cbfg .P2 .Y =_ggaca -_cbfg .P2 .Y ;_cbfg .P3 .Y =_ggaca -_cbfg .P3 .Y ;_gggb =append (_gggb ,_cbfg );};_dace .Curves =_gggb ;defer func (){_dace .Curves =_dgdeb }();_aacc ,_ ,_egef :=_dace .Draw (_agfb );if _egef !=nil {return nil ,ctx ,_egef ;
};if _egef =_acgg .addContentsByString (string (_aacc ));_egef !=nil {return nil ,ctx ,_egef ;};return []*Block {_acgg },ctx ,nil ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_cb .PdfPage )(*Block ,error ){_cg :=&Block {};_cc ,_ae :=page .GetAllContentStreams ();if _ae !=nil {return nil ,_ae ;};_ada :=_fb .NewContentStreamParser (_cc );_ed ,_ae :=_ada .Parse ();if _ae !=nil {return nil ,_ae ;};_ed .WrapIfNeeded ();
_cg ._dg =_ed ;if page .Resources !=nil {_cg ._ba =page .Resources ;}else {_cg ._ba =_cb .NewPdfPageResources ();};_cd ,_ae :=page .GetMediaBox ();if _ae !=nil {return nil ,_ae ;};if _cd .Llx !=0||_cd .Lly !=0{_cg .translate (-_cd .Llx ,_cd .Lly );};_cg ._bfc =_cd .Urx -_cd .Llx ;
_cg ._fd =_cd .Ury -_cd .Lly ;if page .Rotate !=nil {_cg ._fbc =-float64 (*page .Rotate );};return _cg ,nil ;};

// Width returns the Block's width.
func (_ffc *Block )Width ()float64 {return _ffc ._bfc };func _gefd ()*PageBreak {return &PageBreak {}};

// GetOptimizer returns current PDF optimizer.
func (_ecbd *Creator )GetOptimizer ()_cb .Optimizer {return _ecbd ._cege };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_deeg *Creator )SetOptimizer (optimizer _cb .Optimizer ){_deeg ._cege =optimizer };func _bfgf (_ecgcf ,_bacge ,_ggeea TextChunk ,_cbcd uint ,_afgd TextStyle )*TOCLine {_bcfb :=_egeg (_afgd );_bcfb .SetEnableWrap (true );_bcfb .SetTextAlignment (TextAlignmentLeft );
_bcfb .SetMargins (0,0,2,2);_eede :=&TOCLine {_ddfc :_bcfb ,Number :_ecgcf ,Title :_bacge ,Page :_ggeea ,Separator :TextChunk {Text :"\u002e",Style :_afgd },_dbee :0,_ddgcb :_cbcd ,_cdbff :10,_gfea :PositionRelative };_bcfb ._bcbb .Left =_eede ._dbee +float64 (_eede ._ddgcb -1)*_eede ._cdbff ;
_bcfb ._dagd =_eede .prepareParagraph ;return _eede ;};

// SetBorderColor sets the border color.
func (_agaf *PolyBezierCurve )SetBorderColor (color Color ){_agaf ._ccfa .BorderColor =_eeg (color )};const (DefaultHorizontalScaling =100;);

// Inline returns whether the inline mode of the division is active.
func (_fgb *Division )Inline ()bool {return _fgb ._dccbd };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_fefg *TOC )SetHeading (text string ,style TextStyle ){_cdbg :=_fefg .Heading ();_cdbg .Reset ();_cbad :=_cdbg .Append (text );_cbad .Style =style ;};func _dda (_bcc *_fb .ContentStreamOperations ,_efg *_cb .PdfPageResources ,_gb *_fb .ContentStreamOperations ,_eac *_cb .PdfPageResources )error {_ffe :=map[_af .PdfObjectName ]_af .PdfObjectName {};
_efe :=map[_af .PdfObjectName ]_af .PdfObjectName {};_cga :=map[_af .PdfObjectName ]_af .PdfObjectName {};_fff :=map[_af .PdfObjectName ]_af .PdfObjectName {};_gbd :=map[_af .PdfObjectName ]_af .PdfObjectName {};_ddac :=map[_af .PdfObjectName ]_af .PdfObjectName {};
for _ ,_gba :=range *_gb {switch _gba .Operand {case "\u0044\u006f":if len (_gba .Params )==1{if _ega ,_baeb :=_gba .Params [0].(*_af .PdfObjectName );_baeb {if _ ,_fca :=_ffe [*_ega ];!_fca {var _eed _af .PdfObjectName ;_aebd ,_ :=_eac .GetXObjectByName (*_ega );
if _aebd !=nil {_eed =*_ega ;for {_aae ,_ :=_efg .GetXObjectByName (_eed );if _aae ==nil ||_aae ==_aebd {break ;};_eed =_eed +"\u0030";};};_efg .SetXObjectByName (_eed ,_aebd );_ffe [*_ega ]=_eed ;};_abb :=_ffe [*_ega ];_gba .Params [0]=&_abb ;};};case "\u0054\u0066":if len (_gba .Params )==2{if _ddb ,_ecbc :=_gba .Params [0].(*_af .PdfObjectName );
_ecbc {if _ ,_cgf :=_efe [*_ddb ];!_cgf {_fbcb ,_cdb :=_eac .GetFontByName (*_ddb );_abcb :=*_ddb ;if _cdb &&_fbcb !=nil {_abcb =_ffg (_ddb .String (),_fbcb ,_efg );};_efg .SetFontByName (_abcb ,_fbcb );_efe [*_ddb ]=_abcb ;};_gde :=_efe [*_ddb ];_gba .Params [0]=&_gde ;
};};case "\u0043\u0053","\u0063\u0073":if len (_gba .Params )==1{if _dcf ,_bfb :=_gba .Params [0].(*_af .PdfObjectName );_bfb {if _ ,_eee :=_cga [*_dcf ];!_eee {var _beg _af .PdfObjectName ;_fgcg ,_adb :=_eac .GetColorspaceByName (*_dcf );if _adb {_beg =*_dcf ;
for {_bad ,_cbb :=_efg .GetColorspaceByName (_beg );if !_cbb ||_fgcg ==_bad {break ;};_beg =_beg +"\u0030";};_efg .SetColorspaceByName (_beg ,_fgcg );_cga [*_dcf ]=_beg ;}else {_c .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");
};};if _gdbb ,_fde :=_cga [*_dcf ];_fde {_gba .Params [0]=&_gdbb ;}else {_c .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_dcf );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gba .Params )==1{if _fcgdf ,_cfda :=_gba .Params [0].(*_af .PdfObjectName );_cfda {if _ ,_fffc :=_fff [*_fcgdf ];!_fffc {var _bee _af .PdfObjectName ;_bbf ,_fggd :=_eac .GetPatternByName (*_fcgdf );
if _fggd {_bee =*_fcgdf ;for {_ead ,_dcc :=_efg .GetPatternByName (_bee );if !_dcc ||_ead ==_bbf {break ;};_bee =_bee +"\u0030";};_dceg :=_efg .SetPatternByName (_bee ,_bbf .ToPdfObject ());if _dceg !=nil {return _dceg ;};_fff [*_fcgdf ]=_bee ;};};if _gec ,_ggf :=_fff [*_fcgdf ];
_ggf {_gba .Params [0]=&_gec ;};};};case "\u0073\u0068":if len (_gba .Params )==1{if _aaf ,_eecg :=_gba .Params [0].(*_af .PdfObjectName );_eecg {if _ ,_acc :=_gbd [*_aaf ];!_acc {var _geg _af .PdfObjectName ;_ddgf ,_edc :=_eac .GetShadingByName (*_aaf );
if _edc {_geg =*_aaf ;for {_bea ,_cfc :=_efg .GetShadingByName (_geg );if !_cfc ||_ddgf ==_bea {break ;};_geg =_geg +"\u0030";};_gea :=_efg .SetShadingByName (_geg ,_ddgf .ToPdfObject ());if _gea !=nil {_c .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_gea );
return _gea ;};_gbd [*_aaf ]=_geg ;}else {_c .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _gc ,_dafb :=_gbd [*_aaf ];_dafb {_gba .Params [0]=&_gc ;}else {_c .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_aaf );
};};};case "\u0067\u0073":if len (_gba .Params )==1{if _abab ,_fcgg :=_gba .Params [0].(*_af .PdfObjectName );_fcgg {if _ ,_df :=_ddac [*_abab ];!_df {var _bdg _af .PdfObjectName ;_ebg ,_bfbf :=_eac .GetExtGState (*_abab );if _bfbf {_bdg =*_abab ;_gfb :=1;
for {_ccf ,_fdee :=_efg .GetExtGState (_bdg );if !_fdee ||_ebg ==_ccf {break ;};_bdg =_af .PdfObjectName (_fc .Sprintf ("\u0047\u0053\u0025\u0064",_gfb ));_gfb ++;};};_efg .AddExtGState (_bdg ,_ebg );_ddac [*_abab ]=_bdg ;};_ecf :=_ddac [*_abab ];_gba .Params [0]=&_ecf ;
};};};*_bcc =append (*_bcc ,_gba );};return nil ;};func (_ebagc *StyledParagraph )wrapText ()error {return _ebagc .wrapChunks (true )};func (_edb *Block )duplicate ()*Block {_ac :=&Block {};*_ac =*_edb ;_abc :=_fb .ContentStreamOperations {};_abc =append (_abc ,*_edb ._dg ...);
_ac ._dg =&_abc ;return _ac ;};func _becb (_caeb [][]_fce .Point )*Polygon {return &Polygon {_gged :&_fce .Polygon {Points :_caeb },_bdea :1.0,_dcb :1.0};};

// Height returns the total height of all rows.
func (_deaa *Table )Height ()float64 {_eegcf :=float64 (0.0);for _ ,_eagb :=range _deaa ._cede {_eegcf +=_eagb ;};return _eegcf ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// SetStyleTop sets border style for top side.
func (_dggc *border )SetStyleTop (style CellBorderStyle ){_dggc ._bfa =style };func (_bae *Block )transform (_daf _cf .Matrix ){_ec :=_fb .NewContentCreator ().Add_cm (_daf [0],_daf [1],_daf [3],_daf [4],_daf [6],_daf [7]).Operations ();*_bae ._dg =append (*_ec ,*_bae ._dg ...);
_bae ._dg .WrapIfNeeded ();};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_abced *Image )ScaleToHeight (h float64 ){_fadc :=_abced ._dbf /_abced ._becd ;_abced ._becd =h ;_abced ._dbf =h *_fadc ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_bgdd *StyledParagraph )Insert (index uint ,text string )*TextChunk {_fbbde :=uint (len (_bgdd ._beaee ));if index > _fbbde {index =_fbbde ;};_fefa :=NewTextChunk (text ,_bgdd ._ecfb );_bgdd ._beaee =append (_bgdd ._beaee [:index ],append ([]*TextChunk {_fefa },_bgdd ._beaee [index :]...)...);
_bgdd .wrapText ();return _fefa ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };
);func _ffa (_gaa [][]_fce .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_dcfcf :&_fce .CurvePolygon {Rings :_gaa },_bgec :1.0,_geebb :1.0};};

// SetLineOpacity sets the line opacity.
func (_afdf *Polyline )SetLineOpacity (opacity float64 ){_afdf ._aebf =opacity };

// NewChapter creates a new chapter with the specified title as the heading.
func (_fbbc *Creator )NewChapter (title string )*Chapter {_fbbc ._bged ++;_cgae :=_fbbc .NewTextStyle ();_cgae .FontSize =16;return _badg (nil ,_fbbc ._cdca ,_fbbc ._gdf ,title ,_fbbc ._bged ,_cgae );};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_fbbd Drawable )(Drawable ,error );};

// NewInvoice returns an instance of an empty invoice.
func (_bcge *Creator )NewInvoice ()*Invoice {_dgb :=_bcge .NewTextStyle ();_dgb .Font =_bcge ._ffdb ;return _ceeg (_bcge .NewTextStyle (),_dgb );};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func (_cbd *Block )addContents (_eeb *_fb .ContentStreamOperations ){_cbd ._dg .WrapIfNeeded ();_eeb .WrapIfNeeded ();*_cbd ._dg =append (*_cbd ._dg ,*_eeb ...);};func _dae (_bfdc _ab .ChartRenderable )*Chart {return &Chart {_cefg :_bfdc ,_afbb :PositionRelative ,_ceg :Margins {Top :10,Bottom :10}};
};

// SetSideBorderColor sets the cell's side border color.
func (_dgfaa *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_dgfaa ._ggeg =col ;case CellBorderSideBottom :_dgfaa ._debg =col ;case CellBorderSideLeft :_dgfaa ._gecf =col ;case CellBorderSideRight :_dgfaa ._caeda =col ;
};};func _fdfa (_gceb *Table ,_dadfd DrawContext )([]*Block ,DrawContext ,error ){var _gedcb []*Block ;_gdac :=NewBlock (_dadfd .PageWidth ,_dadfd .PageHeight );_gceb .updateRowHeights (_dadfd .Width -_gceb ._cfdgg .Left -_gceb ._cfdgg .Right );_bcab :=_gceb ._cfdgg .Top ;
if _gceb ._eaca .IsRelative ()&&!_gceb ._egdc {_geaabg :=_gceb .Height ();if _geaabg > _dadfd .Height -_gceb ._cfdgg .Top &&_geaabg <=_dadfd .PageHeight -_dadfd .Margins .Top -_dadfd .Margins .Bottom {_gedcb =[]*Block {NewBlock (_dadfd .PageWidth ,_dadfd .PageHeight -_dadfd .Y )};
var _gebd error ;if _ ,_dadfd ,_gebd =_gefd ().GeneratePageBlocks (_dadfd );_gebd !=nil {return nil ,_dadfd ,_gebd ;};_bcab =0;};};_acde :=_dadfd ;if _gceb ._eaca .IsAbsolute (){_dadfd .X =_gceb ._begfe ;_dadfd .Y =_gceb ._ffbdd ;}else {_dadfd .X +=_gceb ._cfdgg .Left ;
_dadfd .Y +=_bcab ;_dadfd .Width -=_gceb ._cfdgg .Left +_gceb ._cfdgg .Right ;_dadfd .Height -=_bcab ;};_ceeed :=_dadfd .Width ;_aedff :=_dadfd .X ;_gbbab :=_dadfd .Y ;_fcgeb :=_dadfd .Height ;_cfbga :=0;_abdge ,_egfg :=-1,-1;if _gceb ._bdgb {for _eafd ,_ggbdg :=range _gceb ._caccb {if _ggbdg ._ddfbb < _gceb ._cgaea {continue ;
};if _ggbdg ._ddfbb > _gceb ._fbbce {break ;};if _abdge < 0{_abdge =_eafd ;};_egfg =_eafd ;};};var (_gega bool ;_edgad int ;_cged int ;_cgccf bool ;_efda int ;_adcdf error ;);for _cdbd :=0;_cdbd < len (_gceb ._caccb );_cdbd ++{_cfca :=_gceb ._caccb [_cdbd ];
_ecedf :=_cfca .width (_gceb ._cbbda ,_ceeed );_feda :=float64 (0.0);for _abdf :=0;_abdf < _cfca ._aaad -1;_abdf ++{_feda +=_gceb ._cbbda [_abdf ]*_ceeed ;};_edbgd :=float64 (0.0);for _cecbc :=_cfbga ;_cecbc < _cfca ._ddfbb -1;_cecbc ++{_edbgd +=_gceb ._cede [_cecbc ];
};_dadfd .Height =_fcgeb -_edbgd ;_cefea :=float64 (0.0);for _aafg :=0;_aafg < _cfca ._bgfcd ;_aafg ++{_cefea +=_gceb ._cede [_cfca ._ddfbb +_aafg -1];};_babdb :=_cgccf &&_cfca ._ddfbb !=_efda ;_efda =_cfca ._ddfbb ;if _babdb ||_cefea > _dadfd .Height {if _gceb ._bdda &&!_cgccf {_cgccf ,_adcdf =_gceb .wrapRow (_cdbd ,_dadfd ,_ceeed );
if _adcdf !=nil {return nil ,_dadfd ,_adcdf ;};if _cgccf {_cdbd --;continue ;};};_gedcb =append (_gedcb ,_gdac );_gdac =NewBlock (_dadfd .PageWidth ,_dadfd .PageHeight );_aedff =_dadfd .Margins .Left +_gceb ._cfdgg .Left ;_gbbab =_dadfd .Margins .Top ;
_dadfd .Height =_dadfd .PageHeight -_dadfd .Margins .Top -_dadfd .Margins .Bottom ;_dadfd .Page ++;_fcgeb =_dadfd .Height ;_cfbga =_cfca ._ddfbb -1;_edbgd =0;_cgccf =false ;if _gceb ._bdgb &&_abdge >=0{_edgad =_cdbd ;_cdbd =_abdge -1;_cged =_cfbga ;_cfbga =_gceb ._cgaea -1;
_gega =true ;continue ;};if _babdb {_cdbd --;continue ;};};_dadfd .Width =_ecedf ;_dadfd .X =_aedff +_feda ;_dadfd .Y =_gbbab +_edbgd ;_dcbcg :=_fbdb (_dadfd .X ,_dadfd .Y ,_ecedf ,_cefea );if _cfca ._fddb !=nil {_dcbcg .SetFillColor (_cfca ._fddb );};
_dcbcg .LineStyle =_cfca ._fedac ;_dcbcg ._dcff =_cfca ._aadbb ;_dcbcg ._ade =_cfca ._cbae ;_dcbcg ._bfa =_cfca ._edde ;_dcbcg ._ddd =_cfca ._cafbd ;if _cfca ._gecf !=nil {_dcbcg .SetColorLeft (_cfca ._gecf );};if _cfca ._debg !=nil {_dcbcg .SetColorBottom (_cfca ._debg );
};if _cfca ._caeda !=nil {_dcbcg .SetColorRight (_cfca ._caeda );};if _cfca ._ggeg !=nil {_dcbcg .SetColorTop (_cfca ._ggeg );};_dcbcg .SetWidthBottom (_cfca ._gdcc );_dcbcg .SetWidthLeft (_cfca ._ffcd );_dcbcg .SetWidthRight (_cfca ._bfdb );_dcbcg .SetWidthTop (_cfca ._cecbb );
_fafag :=_gdac .Draw (_dcbcg );if _fafag !=nil {_c .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fafag );};if _cfca ._fgec !=nil {_gadga :=_cfca ._fgec .Width ();_dabb :=_cfca ._fgec .Height ();_fdgdg :=0.0;switch _cbgfg :=_cfca ._fgec .(type ){case *Paragraph :if _cbgfg ._cccg {_gadga =_cbgfg .getMaxLineWidth ()/1000.0;
};_gadga +=_cbgfg ._ceff .Left +_cbgfg ._ceff .Right ;_dabb +=_cbgfg ._ceff .Top +_cbgfg ._ceff .Bottom ;case *StyledParagraph :if _cbgfg ._aegb {_gadga =_cbgfg .getMaxLineWidth ()/1000.0;};_egdd ,_bggdb ,_ffcc :=_cbgfg .getLineMetrics (0);_agcbd ,_effb :=_egdd *_cbgfg ._bcaa ,_bggdb *_cbgfg ._bcaa ;
if _cbgfg ._bacg ==TextVerticalAlignmentCenter {_fdgdg =_effb -(_bggdb +(_egdd +_ffcc -_bggdb )/2+(_effb -_bggdb )/2);};if len (_cbgfg ._defff )==1{_dabb =_agcbd ;}else {_dabb =_dabb -_effb +_agcbd ;};_fdgdg +=_agcbd -_effb ;switch _cfca ._abfga {case CellVerticalAlignmentTop :_fdgdg +=_agcbd *0.5;
case CellVerticalAlignmentBottom :_fdgdg -=_agcbd *0.5;};_gadga +=_cbgfg ._bcbb .Left +_cbgfg ._bcbb .Right ;_dabb +=_cbgfg ._bcbb .Top +_cbgfg ._bcbb .Bottom ;case *Table :_gadga =_ecedf ;case *List :_gadga =_ecedf ;case *Division :_gadga =_ecedf ;case *Chart :_gadga =_ecedf ;
};switch _cfca ._ebbae {case CellHorizontalAlignmentLeft :_dadfd .X +=_cfca ._abg ;_dadfd .Width -=_cfca ._abg ;case CellHorizontalAlignmentCenter :if _ddgad :=_ecedf -_gadga ;_ddgad > 0{_dadfd .X +=_ddgad /2;_dadfd .Width -=_ddgad /2;};case CellHorizontalAlignmentRight :if _ecedf > _gadga {_dadfd .X =_dadfd .X +_ecedf -_gadga -_cfca ._abg ;
_dadfd .Width -=_cfca ._abg ;};};_bbfe :=_dadfd .Y ;_ccfgg :=_dadfd .Height ;_dadfd .Y +=_fdgdg ;switch _cfca ._abfga {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _ffgg :=_cefea -_dabb ;_ffgg > 0{_dadfd .Y +=_ffgg /2;_dadfd .Height -=_ffgg /2;
};case CellVerticalAlignmentBottom :if _cefea > _dabb {_dadfd .Y =_dadfd .Y +_cefea -_dabb ;_dadfd .Height =_cefea ;};};_adgb :=_gdac .DrawWithContext (_cfca ._fgec ,_dadfd );if _adgb !=nil {_c .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_adgb );
};_dadfd .Y =_bbfe ;_dadfd .Height =_ccfgg ;};_dadfd .Y +=_cefea ;_dadfd .Height -=_cefea ;if _gega &&_cdbd +1> _egfg {_gbbab +=_edbgd +_cefea ;_fcgeb -=_cefea +_edbgd ;_cfbga =_cged ;_cdbd =_edgad -1;_gega =false ;};};_gedcb =append (_gedcb ,_gdac );if _gceb ._eaca .IsAbsolute (){return _gedcb ,_acde ,nil ;
};_dadfd .X =_acde .X ;_dadfd .Width =_acde .Width ;_dadfd .Y +=_gceb ._cfdgg .Bottom ;_dadfd .Height -=_gceb ._cfdgg .Bottom ;return _gedcb ,_dadfd ,nil ;};func (_abcfc *TOCLine )prepareParagraph (_gdff *StyledParagraph ,_bfecf DrawContext ){_dfbg :=_abcfc .Title .Text ;
if _abcfc .Number .Text !=""{_dfbg ="\u0020"+_dfbg ;};_dfbg +="\u0020";_fgebc :=_abcfc .Page .Text ;if _fgebc !=""{_fgebc ="\u0020"+_fgebc ;};_gdff ._beaee =[]*TextChunk {{Text :_abcfc .Number .Text ,Style :_abcfc .Number .Style ,_gdda :_abcfc .getLineLink ()},{Text :_dfbg ,Style :_abcfc .Title .Style ,_gdda :_abcfc .getLineLink ()},{Text :_fgebc ,Style :_abcfc .Page .Style ,_gdda :_abcfc .getLineLink ()}};
_gdff .wrapText ();_gaea :=len (_gdff ._defff );if _gaea ==0{return ;};_bgeg :=_bfecf .Width *1000-_gdff .getTextLineWidth (_gdff ._defff [_gaea -1]);_cbcg :=_gdff .getTextLineWidth ([]*TextChunk {&_abcfc .Separator });_ddbf :=int (_bgeg /_cbcg );_cecfg :=_e .Repeat (_abcfc .Separator .Text ,_ddbf );
_eeffa :=_abcfc .Separator .Style ;_afcb :=_gdff .Insert (2,_cecfg );_afcb .Style =_eeffa ;_afcb ._gdda =_abcfc .getLineLink ();_bgeg =_bgeg -float64 (_ddbf )*_cbcg ;if _bgeg > 500{_gecd ,_afada :=_eeffa .Font .GetRuneMetrics (' ');if _afada &&_bgeg > _gecd .Wx {_gebaa :=int (_bgeg /_gecd .Wx );
if _gebaa > 0{_bbbff :=_eeffa ;_bbbff .FontSize =1;_afcb =_gdff .Insert (2,_e .Repeat ("\u0020",_gebaa ));_afcb .Style =_bbbff ;_afcb ._gdda =_abcfc .getLineLink ();};};};};func (_ffeg *StyledParagraph )wrapChunks (_bafa bool )error {if !_ffeg ._aegb ||int (_ffeg ._edff )<=0{_ffeg ._defff =[][]*TextChunk {_ffeg ._beaee };
return nil ;};_ffeg ._defff =[][]*TextChunk {};var _cceaa []*TextChunk ;var _edgf float64 ;_bggfb :=_fg .IsSpace ;if !_bafa {_bggfb =func (rune )bool {return false };};_caecd :=_efcf (_ffeg ._edff *1000.0,0.000001);for _ ,_dafe :=range _ffeg ._beaee {_acfbc :=_dafe .Style ;
_abcg :=_dafe ._gdda ;var (_cgcdf []rune ;_fdeg []float64 ;);for _ ,_bdef :=range _dafe .Text {if _bdef =='\u000A'{if !_bafa {_cgcdf =append (_cgcdf ,_bdef );};_cceaa =append (_cceaa ,&TextChunk {Text :_e .TrimRightFunc (string (_cgcdf ),_bggfb ),Style :_acfbc ,_gdda :_bgedf (_abcg )});
_ffeg ._defff =append (_ffeg ._defff ,_cceaa );_cceaa =nil ;_edgf =0;_cgcdf =nil ;_fdeg =nil ;continue ;};_faae :=_bdef ==' ';_bbab ,_bceba :=_acfbc .Font .GetRuneMetrics (_bdef );if !_bceba {_c .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bdef );
return _g .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_gcef :=_acfbc .FontSize *_bbab .Wx *_acfbc .horizontalScale ();_agfcb :=_gcef ;if !_faae {_agfcb =_gcef +_acfbc .CharSpacing *1000.0;
};if _edgf +_gcef > _caecd {_dgag :=-1;if !_faae {for _ebgbe :=len (_cgcdf )-1;_ebgbe >=0;_ebgbe --{if _cgcdf [_ebgbe ]==' '{_dgag =_ebgbe ;break ;};};};_fcaa :=string (_cgcdf );if _dgag >=0{_fcaa =string (_cgcdf [0:_dgag +1]);_cgcdf =_cgcdf [_dgag +1:];
_cgcdf =append (_cgcdf ,_bdef );_fdeg =_fdeg [_dgag +1:];_fdeg =append (_fdeg ,_agfcb );_edgf =0;for _ ,_gdgg :=range _fdeg {_edgf +=_gdgg ;};}else {if _faae {_edgf =0;_cgcdf =[]rune {};_fdeg =[]float64 {};}else {_edgf =_agfcb ;_cgcdf =[]rune {_bdef };
_fdeg =[]float64 {_agfcb };};};if !_bafa &&_faae {_fcaa +="\u0020";};_cceaa =append (_cceaa ,&TextChunk {Text :_e .TrimRightFunc (_fcaa ,_bggfb ),Style :_acfbc ,_gdda :_bgedf (_abcg )});_ffeg ._defff =append (_ffeg ._defff ,_cceaa );_cceaa =[]*TextChunk {};
}else {_edgf +=_agfcb ;_cgcdf =append (_cgcdf ,_bdef );_fdeg =append (_fdeg ,_agfcb );};};if len (_cgcdf )> 0{_cceaa =append (_cceaa ,&TextChunk {Text :string (_cgcdf ),Style :_acfbc ,_gdda :_bgedf (_abcg )});};};if len (_cceaa )> 0{_ffeg ._defff =append (_ffeg ._defff ,_cceaa );
};return nil ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_ceag *Creator )SetPageSize (size PageSize ){_ceag ._aeeb =size ;_ceag ._caf =size [0];_ceag ._gdbg =size [1];_bcee :=0.1*_ceag ._caf ;_ceag ._bgcf .Left =_bcee ;_ceag ._bgcf .Right =_bcee ;_ceag ._bgcf .Top =_bcee ;_ceag ._bgcf .Bottom =_bcee ;};


// SetMargins sets the margins of the paragraph.
func (_cbcf *List )SetMargins (left ,right ,top ,bottom float64 ){_cbcf ._fdgdb .Left =left ;_cbcf ._fdgdb .Right =right ;_cbcf ._fdgdb .Top =top ;_cbcf ._fdgdb .Bottom =bottom ;};

// SetBorderWidth sets the border width.
func (_ebbdf *Rectangle )SetBorderWidth (bw float64 ){_ebbdf ._efffa =bw };func (_fbdcg *TextChunk )clone ()*TextChunk {_adag :=*_fbdcg ;_adag ._gdda =_bgedf (_fbdcg ._gdda );return &_adag ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_eadde *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_cbac ,_bfce :=_eadde .Wrap (width );if _bfce !=nil {return nil ,_bfce ;};_aafed :=int (height /_eadde .Style .FontSize );if _aafed >=len (_cbac ){return nil ,nil ;};_dcgda :="\u000a";
_eadde .Text =_e .Replace (_e .Join (_cbac [:_aafed ],"\u0020"),_dcgda +"\u0020",_dcgda ,-1);_bbaca :=_e .Replace (_e .Join (_cbac [_aafed :],"\u0020"),_dcgda +"\u0020",_dcgda ,-1);return NewTextChunk (_bbaca ,_eadde .Style ),nil ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_bgdff *Chapter )GetHeading ()*Paragraph {return _bgdff ._fcd };

// CurCol returns the currently active cell's column number.
func (_cgdff *Table )CurCol ()int {_fbfe :=(_cgdff ._agcb -1)%(_cgdff ._bbac )+1;return _fbfe };

// Add adds a new line with the default style to the table of contents.
func (_efagb *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_fdgc :=_efagb .AddLine (_bfgf (TextChunk {Text :number ,Style :_efagb ._ebfcd },TextChunk {Text :title ,Style :_efagb ._becbd },TextChunk {Text :page ,Style :_efagb ._fbcec },level ,_efagb ._ebcgf ));
if _fdgc ==nil {return nil ;};_faeb :=&_efagb ._bgfd ;_fdgc .SetMargins (_faeb .Left ,_faeb .Right ,_faeb .Top ,_faeb .Bottom );_fdgc .SetLevelOffset (_efagb ._eedad );_fdgc .Separator .Text =_efagb ._cbgac ;_fdgc .Separator .Style =_efagb ._bfdaa ;return _fdgc ;
};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;func (_ddfd *Chapter )headingNumber ()string {var _fbba string ;if _ddfd ._abfd {if _ddfd ._aebb !=0{_fbba =_bg .Itoa (_ddfd ._aebb )+"\u002e";};if _ddfd ._cbba !=nil {_bgaf :=_ddfd ._cbba .headingNumber ();if _bgaf !=""{_fbba =_bgaf +_fbba ;
};};};return _fbba ;};func (_efca *FilledCurve )draw (_ggfb string )([]byte ,*_cb .PdfRectangle ,error ){_acbb :=_fce .NewCubicBezierPath ();for _ ,_eaaegb :=range _efca ._cbec {_acbb =_acbb .AppendCurve (_eaaegb );};creator :=_fb .NewContentCreator ();
creator .Add_q ();if _efca .FillEnabled &&_efca ._aceef !=nil {creator .SetNonStrokingColor (_eeg (_efca ._aceef ));};if _efca .BorderEnabled {if _efca ._bebd !=nil {creator .SetStrokingColor (_eeg (_efca ._bebd ));};creator .Add_w (_efca .BorderWidth );
};if len (_ggfb )> 1{creator .Add_gs (_af .PdfObjectName (_ggfb ));};_fce .DrawBezierPathWithCreator (_acbb ,creator );creator .Add_h ();if _efca .FillEnabled &&_efca .BorderEnabled {creator .Add_B ();}else if _efca .FillEnabled {creator .Add_f ();}else if _efca .BorderEnabled {creator .Add_S ();
};creator .Add_Q ();_ageg :=_acbb .GetBoundingBox ();if _efca .BorderEnabled {_ageg .Height +=_efca .BorderWidth ;_ageg .Width +=_efca .BorderWidth ;_ageg .X -=_efca .BorderWidth /2;_ageg .Y -=_efca .BorderWidth /2;};_dgfa :=&_cb .PdfRectangle {};_dgfa .Llx =_ageg .X ;
_dgfa .Lly =_ageg .Y ;_dgfa .Urx =_ageg .X +_ageg .Width ;_dgfa .Ury =_ageg .Y +_ageg .Height ;return creator .Bytes (),_dgfa ,nil ;};func (_efdd *Table )resetColumnWidths (){_efdd ._cbbda =[]float64 {};_bgaa :=float64 (1.0)/float64 (_efdd ._bbac );for _eaga :=0;
_eaga < _efdd ._bbac ;_eaga ++{_efdd ._cbbda =append (_efdd ._cbbda ,_bgaa );};};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_ecgc *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_bbfg :=&_ecgc ._bgfd ;_bbfg .Left =left ;_bbfg .Right =right ;_bbfg .Top =top ;_bbfg .Bottom =bottom ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_gged *_fce .Polygon ;_bdea float64 ;_dcb float64 ;};func _gfcab ()*FilledCurve {_aceb :=FilledCurve {};_aceb ._cbec =[]_fce .CubicBezierCurve {};return &_aceb ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_cee *Block )Draw (d Drawable )error {_aba :=DrawContext {};_aba .Width =_cee ._bfc ;_aba .Height =_cee ._fd ;_aba .PageWidth =_cee ._bfc ;_aba .PageHeight =_cee ._fd ;_aba .X =0;_aba .Y =0;_ceb ,_ ,_bac :=d .GeneratePageBlocks (_aba );if _bac !=nil {return _bac ;
};if len (_ceb )!=1{return _g .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ecb :=range _ceb {if _db :=_cee .mergeBlocks (_ecb );_db !=nil {return _db ;};};return nil ;
};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_dcdg *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_dcdg ._abfga =valign };func (_effa *TOCLine )getLineLink ()*_cb .PdfAnnotation {if _effa ._fefc <=0{return nil ;};return _fbadf (_effa ._fefc -1,_effa ._bcgece ,_effa ._bbcff ,0);
};func _egeg (_dgaf TextStyle )*StyledParagraph {return &StyledParagraph {_beaee :[]*TextChunk {},_ecfb :_dgaf ,_bcgeg :_dgbf (_dgaf .Font ),_bcaa :1.0,_caca :TextAlignmentLeft ,_aegb :true ,_faaa :true ,_ffcb :0,_edfff :1,_ggcd :1,_geegb :PositionRelative };
};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aadef *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffdgb :=ctx ;_efebb ,ctx ,_cdfff :=_aadef ._acegd .GeneratePageBlocks (ctx );if _cdfff !=nil {return _efebb ,ctx ,_cdfff ;};for _ ,_agge :=range _aadef ._ecgb {_cdcaa :=_agge ._fefc ;
if !_aadef ._gaff {_agge ._fefc =0;};_abdeg ,_bbbd ,_ebbad :=_agge .GeneratePageBlocks (ctx );_agge ._fefc =_cdcaa ;if _ebbad !=nil {return _efebb ,ctx ,_ebbad ;};if len (_abdeg )< 1{continue ;};_efebb [len (_efebb )-1].mergeBlocks (_abdeg [0]);_efebb =append (_efebb ,_abdeg [1:]...);
ctx =_bbbd ;};if _aadef ._cgfa .IsRelative (){ctx .X =_ffdgb .X ;};if _aadef ._cgfa .IsAbsolute (){return _efebb ,_ffdgb ,nil ;};return _efebb ,ctx ,nil ;};

// SetSellerAddress sets the seller address of the invoice.
func (_cfdf *Invoice )SetSellerAddress (address *InvoiceAddress ){_cfdf ._geaa =address };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_fggf *Table )Width ()float64 {return 0};func (_gbddd *TextStyle )horizontalScale ()float64 {return _gbddd .HorizontalScaling /100};

// Indent returns the left offset of the list when nested into another list.
func (_ggee *List )Indent ()float64 {return _ggee ._gbdf };

// TOC returns the table of contents component of the creator.
func (_dbe *Creator )TOC ()*TOC {return _dbe ._cdca };

// Scale scales Image by a constant factor, both width and height.
func (_dad *Image )Scale (xFactor ,yFactor float64 ){_dad ._dbf =xFactor *_dad ._dbf ;_dad ._becd =yFactor *_dad ._becd ;};

// Padding returns the padding of the component.
func (_deggb *Division )Padding ()(_aedcd ,_aadb ,_aaga ,_fbfdd float64 ){return _deggb ._dgdg .Left ,_deggb ._dgdg .Right ,_deggb ._dgdg .Top ,_deggb ._dgdg .Bottom ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};func _bgedf (_gacg *_cb .PdfAnnotation )*_cb .PdfAnnotation {if _gacg ==nil {return nil ;};var _gaga *_cb .PdfAnnotation ;switch _cfcad :=_gacg .GetContext ().(type ){case *_cb .PdfAnnotationLink :if _ccag :=_fcca (_cfcad );
_ccag !=nil {_gaga =_ccag .PdfAnnotation ;};};return _gaga ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_adbg *Division )Width ()float64 {return 0};

// SetColorBottom sets border color for bottom.
func (_bef *border )SetColorBottom (col Color ){_bef ._ffea =col };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_fceg rune ;_cba []error ;};func (_aebee *Paragraph )wrapText ()error {if !_aebee ._cccg ||int (_aebee ._gbfe )<=0{_aebee ._febc =[]string {_aebee ._fcbd };return nil ;};_cgab :=NewTextChunk (_aebee ._fcbd ,TextStyle {Font :_aebee ._afad ,FontSize :_aebee ._ccfe });
_gdcbb ,_abbef :=_cgab .Wrap (_aebee ._gbfe );if _abbef !=nil {return _abbef ;};if _aebee ._gcba > 0&&len (_gdcbb )> _aebee ._gcba {_gdcbb =_gdcbb [:_aebee ._gcba ];};_aebee ._febc =_gdcbb ;return nil ;};

// Width returns the width of the Paragraph.
func (_bdgg *StyledParagraph )Width ()float64 {if _bdgg ._aegb &&int (_bdgg ._edff )> 0{return _bdgg ._edff ;};return _bdgg .getTextWidth ()/1000.0;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_dcffd *Table )MultiRowCell (rowspan int )*TableCell {return _dcffd .MultiCell (rowspan ,1)};

// Height returns the Block's height.
func (_bgd *Block )Height ()float64 {return _bgd ._fd };

// Width returns the cell's width based on the input draw context.
func (_eabc *TableCell )Width (ctx DrawContext )float64 {_egdb :=float64 (0.0);for _gbdd :=0;_gbdd < _eabc ._ggfa ;_gbdd ++{_egdb +=_eabc ._eceb ._cbbda [_eabc ._aaad +_gbdd -1];};_bacgg :=ctx .Width *_egdb ;return _bacgg ;};

// SetFont sets the Paragraph's font.
func (_cbcfa *Paragraph )SetFont (font *_cb .PdfFont ){_cbcfa ._afad =font };

// Height returns Ellipse's document height.
func (_ffga *Ellipse )Height ()float64 {return _ffga ._fbef };

// SetBorderRadius sets the radius of the background corners.
func (_fa *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_fa .BorderRadiusTopLeft =topLeft ;_fa .BorderRadiusTopRight =topRight ;_fa .BorderRadiusBottomLeft =bottomLeft ;_fa .BorderRadiusBottomRight =bottomRight ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_febbb *TOC )SetLineNumberStyle (style TextStyle ){_febbb ._ebfcd =style };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_fccd *Image )SetPos (x ,y float64 ){_fccd ._adadf =PositionAbsolute ;_fccd ._ged =x ;_fccd ._ebdge =y ;};func (_cceg *Division )split (_edea DrawContext )(_dbcf ,_ebcf *Division ){var _dfee float64 ;var _efdc ,_cbde []VectorDrawable ;for _cegc ,_bbcf :=range _cceg ._baecf {_dfee +=_egd (_bbcf ,_edea .Width );
if _dfee < _edea .Height {_efdc =append (_efdc ,_bbcf );}else {_cbde =_cceg ._baecf [_cegc :];break ;};};if len (_efdc )> 0{_dbcf =_dedf ();*_dbcf =*_cceg ;_dbcf ._baecf =_efdc ;if _cceg ._ddbd !=nil {_dbcf ._ddbd =&Background {};*_dbcf ._ddbd =*_cceg ._ddbd ;
};};if len (_cbde )> 0{_ebcf =_dedf ();*_ebcf =*_cceg ;_ebcf ._baecf =_cbde ;if _cceg ._ddbd !=nil {_ebcf ._ddbd =&Background {};*_ebcf ._ddbd =*_cceg ._ddbd ;};};return _dbcf ,_ebcf ;};

// Heading returns the heading component of the table of contents.
func (_caaeb *TOC )Heading ()*StyledParagraph {return _caaeb ._acegd };

// GetRowHeight returns the height of the specified row.
func (_acfd *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_acfd ._cede ){return 0,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _acfd ._cede [row -1],nil ;
};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_efad *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_efdeg *_cb .PdfWriter )error ){_efad ._edcg =pdfWriterAccessFunc ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_dded *Creator )NewStyledParagraph ()*StyledParagraph {return _egeg (_dded .NewTextStyle ())};

// SetFillColor sets the fill color for the path.
func (_gdfg *FilledCurve )SetFillColor (color Color ){_gdfg ._aceef =color };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_cgdf *Chapter )SetIncludeInTOC (includeInTOC bool ){_cgdf ._acd =includeInTOC };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gdda *_cb .PdfAnnotation ;_gcdc bool ;};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_fdad *Creator )AddPage (page *_cb .PdfPage )error {_bfeb ,_gbfa :=page .GetMediaBox ();if _gbfa !=nil {_c .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_gbfa );
return _gbfa ;};_bfeb .Normalize ();_ffgb ,_bbag :=_bfeb .Llx ,_bfeb .Lly ;_cbeg :=_cf .IdentityMatrix ();_gadg ,_gbfa :=page .GetRotate ();if _gbfa !=nil {_c .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_gbfa .Error ());
};_ggbd :=_gadg %360!=0&&_gadg %90==0;if _ggbd {_cce :=float64 ((360+_gadg %360)%360);if _cce ==90{_cbeg =_cbeg .Translate (_bfeb .Width (),0);}else if _cce ==180{_cbeg =_cbeg .Translate (_bfeb .Width (),_bfeb .Height ());}else if _cce ==270{_cbeg =_cbeg .Translate (0,_bfeb .Height ());
};_cbeg =_cbeg .Mult (_cf .RotationMatrix (_cce *_bf .Pi /180));_cbeg =_cbeg .Round (0.000001);_badd :=_fcbfa (_bfeb ,_cbeg );_bfeb =_badd ;_bfeb .Normalize ();};if _ffgb !=0||_bbag !=0{_cbeg =_cf .TranslationMatrix (_ffgb ,_bbag ).Mult (_cbeg );};if !_cbeg .Identity (){_cbeg =_cbeg .Round (0.000001);
_fdad ._ebfd [page ]=&pageTransformations {_gcaf :&_cbeg };};_fdad ._caf =_bfeb .Width ();_fdad ._gdbg =_bfeb .Height ();_fdad .initContext ();_fdad ._eegb =append (_fdad ._eegb ,page );_fdad ._fcdd .Page ++;return nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_ecg *Paragraph )SetLineHeight (lineheight float64 ){_ecg ._affa =lineheight };func (_dgda *Image )rotatedSize ()(float64 ,float64 ){_aagag :=_dgda ._dbf ;_ebec :=_dgda ._becd ;_cecd :=_dgda ._geeg ;if _cecd ==0{return _aagag ,_ebec ;};_gfcag :=_fce .Path {Points :[]_fce .Point {_fce .NewPoint (0,0).Rotate (_cecd ),_fce .NewPoint (_aagag ,0).Rotate (_cecd ),_fce .NewPoint (0,_ebec ).Rotate (_cecd ),_fce .NewPoint (_aagag ,_ebec ).Rotate (_cecd )}}.GetBoundingBox ();
return _gfcag .Width ,_gfcag .Height ;};func (_gcca *Table )clone ()*Table {_dcfgf :=*_gcca ;_dcfgf ._cede =make ([]float64 ,len (_gcca ._cede ));copy (_dcfgf ._cede ,_gcca ._cede );_dcfgf ._cbbda =make ([]float64 ,len (_gcca ._cbbda ));copy (_dcfgf ._cbbda ,_gcca ._cbbda );
_dcfgf ._caccb =make ([]*TableCell ,0,len (_gcca ._caccb ));for _ ,_ggbec :=range _gcca ._caccb {_aefgf :=*_ggbec ;_aefgf ._eceb =&_dcfgf ;_dcfgf ._caccb =append (_dcfgf ._caccb ,&_aefgf );};return &_dcfgf ;};func _gabe (_abgb *_cb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_abgb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_dddf *Invoice )Sections ()[][2]string {return _dddf ._gdce };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_fddb Color ;_fedac _fce .LineStyle ;_aadbb CellBorderStyle ;_gecf Color ;_ffcd float64 ;_cafbd CellBorderStyle ;_debg Color ;_gdcc float64 ;_cbae CellBorderStyle ;_caeda Color ;_bfdb float64 ;_edde CellBorderStyle ;_ggeg Color ;_cecbb float64 ;
_ddfbb ,_aaad int ;_bgfcd int ;_ggfa int ;_fgec VectorDrawable ;_ebbae CellHorizontalAlignment ;_abfga CellVerticalAlignment ;_abg float64 ;_eceb *Table ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_adba *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agag :=ctx ;var _cfdb []*Block ;_baac :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _adba ._geegb .IsRelative (){ctx .X +=_adba ._bcbb .Left ;ctx .Y +=_adba ._bcbb .Top ;
ctx .Width -=_adba ._bcbb .Left +_adba ._bcbb .Right ;ctx .Height -=_adba ._bcbb .Top ;_adba .SetWidth (ctx .Width );}else {if int (_adba ._edff )<=0{_adba .SetWidth (_adba .getTextWidth ()/1000.0);};ctx .X =_adba ._gfae ;ctx .Y =_adba ._baegd ;};if _adba ._dagd !=nil {_adba ._dagd (_adba ,ctx );
};if _aade :=_adba .wrapText ();_aade !=nil {return nil ,ctx ,_aade ;};_gegf :=_adba ._defff ;for {_febb ,_fgbc ,_befd :=_agccb (_baac ,_adba ,_gegf ,ctx );if _befd !=nil {_c .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_befd );return nil ,ctx ,_befd ;
};ctx =_febb ;_cfdb =append (_cfdb ,_baac );if _gegf =_fgbc ;len (_fgbc )==0{break ;};_baac =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_febb =ctx ;_febb .Y =ctx .Margins .Top ;_febb .X =ctx .Margins .Left +_adba ._bcbb .Left ;_febb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
_febb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_adba ._bcbb .Left -_adba ._bcbb .Right ;ctx =_febb ;};if _adba ._geegb .IsRelative (){ctx .Y +=_adba ._bcbb .Bottom ;ctx .Height -=_adba ._bcbb .Bottom ;if !ctx .Inline {ctx .X =_agag .X ;
ctx .Width =_agag .Width ;};return _cfdb ,ctx ,nil ;};return _cfdb ,_agag ,nil ;};func (_eacb *Invoice )setCellBorder (_eefa *TableCell ,_cadg *InvoiceCell ){for _ ,_aded :=range _cadg .BorderSides {_eefa .SetBorder (_aded ,CellBorderStyleSingle ,_cadg .BorderWidth );
};_eefa .SetBorderColor (_cadg .BorderColor );};func _gebe (_gacgb string ,_gagce ,_ecgge TextStyle )*TOC {_acefd :=_ecgge ;_acefd .FontSize =14;_gdbd :=_egeg (_acefd );_gdbd .SetEnableWrap (true );_gdbd .SetTextAlignment (TextAlignmentLeft );_gdbd .SetMargins (0,0,0,5);
_cfddd :=_gdbd .Append (_gacgb );_cfddd .Style =_acefd ;return &TOC {_acegd :_gdbd ,_ecgb :[]*TOCLine {},_ebfcd :_gagce ,_becbd :_gagce ,_bfdaa :_gagce ,_fbcec :_gagce ,_cbgac :"\u002e",_eedad :10,_bgfd :Margins {0,0,2,2},_cgfa :PositionRelative ,_ebcgf :_gagce ,_gaff :true };
};func _badg (_gbb *Chapter ,_edbeb *TOC ,_begb *_cb .Outline ,_gcc string ,_adfd int ,_bgdf TextStyle )*Chapter {var _deeb uint =1;if _gbb !=nil {_deeb =_gbb ._cbf +1;};_bebb :=&Chapter {_aebb :_adfd ,_dafa :_gcc ,_abfd :true ,_acd :true ,_cbba :_gbb ,_fceb :_edbeb ,_bab :_begb ,_eccg :[]Drawable {},_cbf :_deeb };
_cedf :=_aedgc (_bebb .headingText (),_bgdf );_cedf .SetFont (_bgdf .Font );_cedf .SetFontSize (_bgdf .FontSize );_bebb ._fcd =_cedf ;return _bebb ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_bbca *Division )SetPadding (left ,right ,top ,bottom float64 ){_bbca ._dgdg .Left =left ;_bbca ._dgdg .Right =right ;_bbca ._dgdg .Top =top ;_bbca ._dgdg .Bottom =bottom ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_ccgd int ;_bbac int ;_agcb int ;_cbbda []float64 ;_cede []float64 ;_dfbd float64 ;_caccb []*TableCell ;_fgff []int ;_eaca Positioning ;_begfe ,_ffbdd float64 ;_cfdgg Margins ;_bdgb bool ;_cgaea int ;_fbbce int ;_bdda bool ;_egdc bool ;
};

// NewCellProps returns the default properties of an invoice cell.
func (_agca *Invoice )NewCellProps ()InvoiceCellProps {_abdg :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_agca ._gbece ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_abdg ,BorderColor :_abdg ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// NewDivision returns a new Division container component.
func (_ddffc *Creator )NewDivision ()*Division {return _dedf ()};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_dcfg *Paragraph )SetColor (col Color ){_dcfg ._eddf =col };

// SetFillColor sets background color for border.
func (_bgag *border )SetFillColor (col Color ){_bgag ._fgge =col };

// GetMargins returns the left, right, top, bottom Margins.
func (_acbfa *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _acbfa ._cfdgg .Left ,_acbfa ._cfdgg .Right ,_acbfa ._cfdgg .Top ,_acbfa ._cfdgg .Bottom ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_bdbb *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_ffead :=&InvoiceCell {_bdbb ._eecgg ,desc };_cbfb :=&InvoiceCell {_bdbb ._eecgg ,value };_bdbb ._dacdf =append (_bdbb ._dacdf ,[2]*InvoiceCell {_ffead ,_cbfb });return _ffead ,_cbfb ;
};func _fcbfa (_aceee *_cb .PdfRectangle ,_agad _cf .Matrix )*_cb .PdfRectangle {var _febbe _cb .PdfRectangle ;_febbe .Llx ,_febbe .Lly =_agad .Transform (_aceee .Llx ,_aceee .Lly );_febbe .Urx ,_febbe .Ury =_agad .Transform (_aceee .Urx ,_aceee .Ury );
_febbe .Normalize ();return &_febbe ;};

// SetBorderWidth sets the border width.
func (_fgga *CurvePolygon )SetBorderWidth (borderWidth float64 ){_fgga ._dcfcf .BorderWidth =borderWidth ;};

// RotatedSize returns the width and height of the rotated block.
func (_dcd *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_cdf ,_dee :=_eegg (_dcd ._bfc ,_dcd ._fd ,_dcd ._fbc );return _cdf ,_dee ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_bfef *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_bfgb :=uint (len (_bfef ._efdf ));if index > _bfgb {index =_bfgb ;};_bcaf :=_bfef .NewColumn (description );_bfef ._efdf =append (_bfef ._efdf [:index ],append ([]*InvoiceCell {_bcaf },_bfef ._efdf [index :]...)...);
return _bcaf ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_dcfcf *_fce .CurvePolygon ;_bgec float64 ;_geebb float64 ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_geab *Invoice )SetAddressHeadingStyle (style TextStyle ){_geab ._eagc =style };func _aacg (_cacg *Block ,_aeab *Paragraph ,_bbfbag DrawContext )(DrawContext ,error ){_cbcec :=1;_ggfcf :=_af .PdfObjectName ("\u0046\u006f\u006e\u0074"+_bg .Itoa (_cbcec ));
for _cacg ._ba .HasFontByName (_ggfcf ){_cbcec ++;_ggfcf =_af .PdfObjectName ("\u0046\u006f\u006e\u0074"+_bg .Itoa (_cbcec ));};_ecddb :=_cacg ._ba .SetFontByName (_ggfcf ,_aeab ._afad .ToPdfObject ());if _ecddb !=nil {return _bbfbag ,_ecddb ;};_aeab .wrapText ();
_fcgb :=_fb .NewContentCreator ();_fcgb .Add_q ();_babd :=_bbfbag .PageHeight -_bbfbag .Y -_aeab ._ccfe *_aeab ._affa ;_fcgb .Translate (_bbfbag .X ,_babd );if _aeab ._accgb !=0{_fcgb .RotateDeg (_aeab ._accgb );};_fcgb .Add_BT ().SetNonStrokingColor (_eeg (_aeab ._eddf )).Add_Tf (_ggfcf ,_aeab ._ccfe ).Add_TL (_aeab ._ccfe *_aeab ._affa );
for _caac ,_bcgg :=range _aeab ._febc {if _caac !=0{_fcgb .Add_Tstar ();};_bggd :=[]rune (_bcgg );_abdef :=0.0;_eegc :=0;for _cbceg ,_defa :=range _bggd {if _defa ==' '{_eegc ++;continue ;};if _defa =='\u000A'{continue ;};_cbfe ,_cefee :=_aeab ._afad .GetRuneMetrics (_defa );
if !_cefee {_c .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_cbceg ,_defa ,_defa ,_aeab ._afad .BaseFont (),_aeab ._afad .Subtype ());
return _bbfbag ,_g .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_abdef +=_aeab ._ccfe *_cbfe .Wx ;};var _gade []_af .PdfObject ;_geeba ,_gbcdb :=_aeab ._afad .GetRuneMetrics (' ');
if !_gbcdb {return _bbfbag ,_g .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_fcef :=_geeba .Wx ;switch _aeab ._fedfa {case TextAlignmentJustify :if _eegc > 0&&_caac < len (_aeab ._febc )-1{_fcef =(_aeab ._gbfe *1000.0-_abdef )/float64 (_eegc )/_aeab ._ccfe ;
};case TextAlignmentCenter :_gdd :=_abdef +float64 (_eegc )*_fcef *_aeab ._ccfe ;_fffa :=(_aeab ._gbfe *1000.0-_gdd )/2/_aeab ._ccfe ;_gade =append (_gade ,_af .MakeFloat (-_fffa ));case TextAlignmentRight :_cbebd :=_abdef +float64 (_eegc )*_fcef *_aeab ._ccfe ;
_cbbf :=(_aeab ._gbfe *1000.0-_cbebd )/_aeab ._ccfe ;_gade =append (_gade ,_af .MakeFloat (-_cbbf ));};_dfbe :=_aeab ._afad .Encoder ();var _gefa []byte ;for _ ,_afbbb :=range _bggd {if _afbbb =='\u000A'{continue ;};if _afbbb ==' '{if len (_gefa )> 0{_gade =append (_gade ,_af .MakeStringFromBytes (_gefa ));
_gefa =nil ;};_gade =append (_gade ,_af .MakeFloat (-_fcef ));}else {if _ ,_ggddc :=_dfbe .RuneToCharcode (_afbbb );!_ggddc {_ecddb =UnsupportedRuneError {Message :_fc .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_afbbb ,_afbbb ),Rune :_afbbb };
_bbfbag ._cba =append (_bbfbag ._cba ,_ecddb );_c .Log .Debug (_ecddb .Error ());if _bbfbag ._fceg <=0{continue ;};_afbbb =_bbfbag ._fceg ;};_gefa =append (_gefa ,_dfbe .Encode (string (_afbbb ))...);};};if len (_gefa )> 0{_gade =append (_gade ,_af .MakeStringFromBytes (_gefa ));
};_fcgb .Add_TJ (_gade ...);};_fcgb .Add_ET ();_fcgb .Add_Q ();_fcfa :=_fcgb .Operations ();_fcfa .WrapIfNeeded ();_cacg .addContents (_fcfa );if _aeab ._gbeaa .IsRelative (){_cfea :=_aeab .Height ();_bbfbag .Y +=_cfea ;_bbfbag .Height -=_cfea ;if _bbfbag .Inline {_bbfbag .X +=_aeab .Width ()+_aeab ._ceff .Right ;
};};return _bbfbag ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_gfd *Block )AddAnnotation (annotation *_cb .PdfAnnotation ){for _ ,_bgc :=range _gfd ._ad {if _bgc ==annotation {return ;};};_gfd ._ad =append (_gfd ._ad ,annotation );};func _dag (_dgd ,_bga *_cb .PdfPageResources )error {_aef ,_ :=_dgd .GetColorspaces ();
if _aef !=nil &&len (_aef .Colorspaces )> 0{for _egf ,_begf :=range _aef .Colorspaces {_acg :=*_af .MakeName (_egf );if _bga .HasColorspaceByName (_acg ){continue ;};_bgdc :=_bga .SetColorspaceByName (_acg ,_begf );if _bgdc !=nil {return _bgdc ;};};};return nil ;
};

// SetDueDate sets the due date of the invoice.
func (_fggb *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_fggb ._adeg [1].Value =dueDate ;return _fggb ._adeg [0],_fggb ._adeg [1];};type cmykColor struct{_caa ,_ecd ,_babb ,_fdf float64 };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_cbbd :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_c .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cbbd ;
};var _bebc ,_cdfb ,_fdac int ;if len (hexStr )==4{var _bfae ,_gca ,_aaa int ;_ebff ,_cecb :=_fc .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_bfae ,&_gca ,&_aaa );if _cecb !=nil {_c .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_cecb );
return _cbbd ;};if _ebff !=3{_c .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cbbd ;};_bebc =_bfae *16+_bfae ;_cdfb =_gca *16+_gca ;_fdac =_aaa *16+_aaa ;}else {_agc ,_cdc :=_fc .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_bebc ,&_cdfb ,&_fdac );
if _cdc !=nil {_c .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cbbd ;};if _agc !=3{_c .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_agc );
return _cbbd ;};};_bff :=float64 (_bebc )/255.0;_acee :=float64 (_cdfb )/255.0;_cacc :=float64 (_fdac )/255.0;_cbbd ._cfdc =_bff ;_cbbd ._ace =_acee ;_cbbd ._bge =_cacc ;return _cbbd ;};func (_dfec *Division )ctxHeight (_bbgfb float64 )float64 {var _bccc float64 ;
for _ ,_fecg :=range _dfec ._baecf {_bccc +=_egd (_fecg ,_bbgfb );};return _bccc ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_acegd *StyledParagraph ;_ecgb []*TOCLine ;_ebfcd TextStyle ;_becbd TextStyle ;_bfdaa TextStyle ;_fbcec TextStyle ;_cbgac string ;_eedad float64 ;_bgfd Margins ;_cgfa Positioning ;_ebcgf TextStyle ;_gaff bool ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_bdffe *StyledParagraph )SetEnableWrap (enableWrap bool ){_bdffe ._aegb =enableWrap ;_bdffe ._faaa =false ;};func _aedgc (_gacb string ,_affad TextStyle )*Paragraph {_ggdd :=&Paragraph {_fcbd :_gacb ,_afad :_affad .Font ,_ccfe :_affad .FontSize ,_affa :1.0,_cccg :true ,_fcea :true ,_fedfa :TextAlignmentLeft ,_accgb :0,_agga :1,_acbf :1,_gbeaa :PositionRelative };
_ggdd .SetColor (_affad .Color );return _ggdd ;};func (_bdad *pageTransformations )transformBlock (_eda *Block ){if _bdad ._gcaf !=nil {_eda .transform (*_bdad ._gcaf );};};

// AddSection adds a new content section at the end of the invoice.
func (_dbce *Invoice )AddSection (title ,content string ){_dbce ._gdce =append (_dbce ._gdce ,[2]string {title ,content });};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_cffcg *Paragraph )SetWidth (width float64 ){_cffcg ._gbfe =width ;_cffcg .wrapText ()};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_edeag *Image )ConvertToBinary ()error {return _edeag ._aaff .ConvertToBinary ()};

// Lines returns all the rows of the invoice line items table.
func (_accc *Invoice )Lines ()[][]*InvoiceCell {return _accc ._bcff };func _ffg (_adf string ,_gda _af .PdfObject ,_aedc *_cb .PdfPageResources )_af .PdfObjectName {_agb :=_e .TrimRightFunc (_e .TrimSpace (_adf ),func (_deed rune )bool {return _fg .IsNumber (_deed )});
if _agb ==""{_agb ="\u0046\u006f\u006e\u0074";};_gdec :=0;_bgf :=_af .PdfObjectName (_adf );for {_faa ,_dccb :=_aedc .GetFontByName (_bgf );if !_dccb ||_faa ==_gda {break ;};_gdec ++;_bgf =_af .PdfObjectName (_fc .Sprintf ("\u0025\u0073\u0025\u0064",_agb ,_gdec ));
};return _bgf ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_dddg *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _bfgf (number ,title ,page ,level ,style );};

// TextAlignment options for paragraph.
type TextAlignment int ;

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;func (_deae *Paragraph )getTextLineWidth (_bdbg string )float64 {var _gffg float64 ;for _ ,_ebfa :=range _bdbg {if _ebfa =='\u000A'{continue ;};_ccbgg ,_aagc :=_deae ._afad .GetRuneMetrics (_ebfa );if !_aagc {_c .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_ebfa ,_ebfa );
return -1;};_gffg +=_deae ._ccfe *_ccbgg .Wx ;};return _gffg ;};func _dcfd (_aafee []_fce .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_ccfa :&_fce .PolyBezierCurve {Curves :_aafee ,BorderColor :_cb .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_dfaf :1.0,_fbbbf :1.0};
};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_defc *Invoice )SetColumns (cols []*InvoiceCell ){_defc ._efdf =cols };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_dgc *Invoice )SetNoteHeadingStyle (style TextStyle ){_dgc ._cde =style };

// AppendCurve appends a Bezier curve to the filled curve.
func (_gfdg *FilledCurve )AppendCurve (curve _fce .CubicBezierCurve )*FilledCurve {_gfdg ._cbec =append (_gfdg ._cbec ,curve );return _gfdg ;};

// SetBackground sets the background properties of the component.
func (_gbac *Division )SetBackground (background *Background ){_gbac ._ddbd =background };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_aebbe *TOC )SetLineSeparator (separator string ){_aebbe ._cbgac =separator };

// CreateFrontPage sets a function to generate a front Page.
func (_caef *Creator )CreateFrontPage (genFrontPageFunc func (_eega FrontpageFunctionArgs )){_caef ._gad =genFrontPageFunc ;};func (_baaf *Invoice )generateHeaderBlocks (_fbea DrawContext )([]*Block ,DrawContext ,error ){_bcae :=_egeg (_baaf ._bbgg );_bcae .SetEnableWrap (true );
_bcae .Append (_baaf ._fdec );_aca :=_bccg (2);if _baaf ._dada !=nil {_gefe :=_aca .NewCell ();_gefe .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_gefe .SetVerticalAlignment (CellVerticalAlignmentMiddle );_gefe .SetIndent (0);_gefe .SetContent (_baaf ._dada );
_baaf ._dada .ScaleToHeight (_bcae .Height ()+20);}else {_aca .SkipCells (1);};_adea :=_aca .NewCell ();_adea .SetHorizontalAlignment (CellHorizontalAlignmentRight );_adea .SetVerticalAlignment (CellVerticalAlignmentMiddle );_adea .SetContent (_bcae );
return _aca .GeneratePageBlocks (_fbea );};

// SetFillOpacity sets the fill opacity.
func (_egce *Polygon )SetFillOpacity (opacity float64 ){_egce ._bdea =opacity };

// NewColumn returns a new column for the line items invoice table.
func (_dbbbg *Invoice )NewColumn (description string )*InvoiceCell {return _dbbbg .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_abcac *StyledParagraph )SetTextAlignment (align TextAlignment ){_abcac ._caca =align };

// SetRowHeight sets the height for a specified row.
func (_decc *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_decc ._cede ){return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_decc ._cede [row -1]=h ;return nil ;
};func (_fbfb *Table )moveToNextAvailableCell ()int {_bbee :=(_fbfb ._agcb -1)%(_fbfb ._bbac )+1;for {if _bbee -1>=len (_fbfb ._fgff ){return _bbee ;}else if _fbfb ._fgff [_bbee -1]==0{return _bbee ;}else {_fbfb ._agcb ++;_fbfb ._fgff [_bbee -1]--;};_bbee ++;
};};func _egfe (_ggcgf []_fce .Point )*Polyline {return &Polyline {_abdb :&_fce .Polyline {Points :_ggcgf ,LineColor :_cb .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_aebf :1.0};};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_cgcde *Paragraph )Height ()float64 {_cgcde .wrapText ();return float64 (len (_cgcde ._febc ))*_cgcde ._affa *_cgcde ._ccfe ;};func _gfccg (_aagfe ,_gagdc ,_fefag string ,_cead uint ,_edege TextStyle )*TOCLine {return _bfgf (TextChunk {Text :_aagfe ,Style :_edege },TextChunk {Text :_gagdc ,Style :_edege },TextChunk {Text :_fefag ,Style :_edege },_cead ,_edege );
};type listItem struct{_degd VectorDrawable ;_fddf TextChunk ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_bbcfe *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_bbcfe ._ecgb =append (_bbcfe ._ecgb ,line );return line ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_eaafc *TOCLine )LevelOffset ()float64 {return _eaafc ._cdbff };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_adccb *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gaeba ,_dfbf :=_gcgg .setOpacity (_adccb ._bdea ,_adccb ._dcb );if _dfbf !=nil {return nil ,ctx ,_dfbf ;};_abae :=_adccb ._gged ;
_abae .FillEnabled =_abae .FillColor !=nil ;_abae .BorderEnabled =_abae .BorderColor !=nil &&_abae .BorderWidth > 0;_gabge :=_abae .Points ;for _bbec :=range _gabge {for _daad :=range _gabge [_bbec ]{_fcbg :=&_gabge [_bbec ][_daad ];_fcbg .Y =ctx .PageHeight -_fcbg .Y ;
};};_ffaa ,_ ,_dfbf :=_abae .Draw (_gaeba );if _dfbf !=nil {return nil ,ctx ,_dfbf ;};if _dfbf =_gcgg .addContentsByString (string (_ffaa ));_dfbf !=nil {return nil ,ctx ,_dfbf ;};return []*Block {_gcgg },ctx ,nil ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetBorderRadius sets the radius of the rectangle corners.
func (_gaef *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_gaef ._aggae =topLeft ;_gaef ._fdgg =topRight ;_gaef ._gedc =bottomLeft ;_gaef ._fbab =bottomRight ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_fgef *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_fgef ._decfe =textOverflow };type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};func (_ege *Invoice )newColumn (_gfce string ,_fcag CellHorizontalAlignment )*InvoiceCell {_ddeeg :=&InvoiceCell {_ege ._defb ,_gfce };
_ddeeg .Alignment =_fcag ;return _ddeeg ;};

// NewImageFromFile creates an Image from a file.
func (_aedg *Creator )NewImageFromFile (path string )(*Image ,error ){return _gfa (path )};func _dedf ()*Division {return &Division {_cgdgb :true }};

// SetFillOpacity sets the fill opacity.
func (_afga *PolyBezierCurve )SetFillOpacity (opacity float64 ){_afga ._dfaf =opacity };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ab .ChartRenderable )*Chart {return _dae (chart )};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_adaec DrawContext )([]*Block ,DrawContext ,error );};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_ded *Chart )Width ()float64 {return float64 (_ded ._cefg .Width ())};

// SetIndent sets the cell's left indent.
func (_eagdc *TableCell )SetIndent (indent float64 ){_eagdc ._abg =indent };

// SetInline sets the inline mode of the division.
func (_cbdb *Division )SetInline (inline bool ){_cbdb ._dccbd =inline };func (_gefb *StyledParagraph )getTextHeight ()float64 {var _aadbc float64 ;for _ ,_dbded :=range _gefb ._beaee {_bggcc :=_dbded .Style .FontSize *_gefb ._bcaa ;if _bggcc > _aadbc {_aadbc =_bggcc ;
};};return _aadbc ;};

// SetFillOpacity sets the fill opacity.
func (_bbbf *Rectangle )SetFillOpacity (opacity float64 ){_bbbf ._ecab =opacity };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_ccdd *Creator )Finalize ()error {if _ccdd ._aag {return nil ;};_cfcg :=len (_ccdd ._eegb );_feg :=0;if _ccdd ._gad !=nil {_efdg :=*_ccdd ;_ccdd ._eegb =nil ;_ccdd ._baec =nil ;_ccdd .initContext ();_ddbea :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cfcg };
_ccdd ._gad (_ddbea );_feg +=len (_ccdd ._eegb );_ccdd ._eegb =_efdg ._eegb ;_ccdd ._baec =_efdg ._baec ;};if _ccdd .AddTOC {_ccdd .initContext ();_ccdd ._fcdd .Page =_feg +1;if _ccdd ._bfe !=nil {if _cega :=_ccdd ._bfe (_ccdd ._cdca );_cega !=nil {return _cega ;
};};_ddee ,_ ,_bca :=_ccdd ._cdca .GeneratePageBlocks (_ccdd ._fcdd );if _bca !=nil {_c .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_bca );
return _bca ;};_feg +=len (_ddee );_bfba :=_ccdd ._cdca .Lines ();for _ ,_adbd :=range _bfba {_fded ,_cbfc :=_bg .Atoi (_adbd .Page .Text );if _cbfc !=nil {continue ;};_adbd .Page .Text =_bg .Itoa (_fded +_feg );};};_bgb :=false ;var _acgb []*_cb .PdfPage ;
if _ccdd ._gad !=nil {_baca :=*_ccdd ;_ccdd ._eegb =nil ;_ccdd ._baec =nil ;_gfg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cfcg };_ccdd ._gad (_gfg );_cfcg +=len (_ccdd ._eegb );_acgb =_ccdd ._eegb ;_ccdd ._eegb =append (_ccdd ._eegb ,_baca ._eegb ...);
_ccdd ._baec =_baca ._baec ;_bgb =true ;};var _dggd []*_cb .PdfPage ;if _ccdd .AddTOC {_ccdd .initContext ();if _ccdd ._bfe !=nil {if _cfe :=_ccdd ._bfe (_ccdd ._cdca );_cfe !=nil {_c .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_cfe );
return _cfe ;};};_daac :=_ccdd ._cdca .Lines ();for _ ,_ggfc :=range _daac {_ggfc ._fefc +=int64 (_feg );};_bdga ,_ ,_ :=_ccdd ._cdca .GeneratePageBlocks (_ccdd ._fcdd );for _ ,_fegb :=range _bdga {_fegb .SetPos (0,0);_cfcg ++;_eag :=_ccdd .newPage ();
_dggd =append (_dggd ,_eag );_ccdd .setActivePage (_eag );_ccdd .Draw (_fegb );};if _bgb {_cfff :=_acgb ;_aafe :=_ccdd ._eegb [len (_acgb ):];_ccdd ._eegb =append ([]*_cb .PdfPage {},_cfff ...);_ccdd ._eegb =append (_ccdd ._eegb ,_dggd ...);_ccdd ._eegb =append (_ccdd ._eegb ,_aafe ...);
}else {_ccdd ._eegb =append (_dggd ,_ccdd ._eegb ...);};};if _ccdd ._gdf !=nil &&_ccdd .AddOutlines {var _bcb func (_fbed *_cb .OutlineItem );_bcb =func (_fcge *_cb .OutlineItem ){_fcge .Dest .Page +=int64 (_feg );if _gbba :=int (_fcge .Dest .Page );_gbba >=0&&_gbba < len (_ccdd ._eegb ){_fcge .Dest .PageObj =_ccdd ._eegb [_gbba ].GetPageAsIndirectObject ();
}else {_c .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gbba );
};_fcge .Dest .Y =_ccdd ._gdbg -_fcge .Dest .Y ;_geeb :=_fcge .Items ();for _ ,_degga :=range _geeb {_bcb (_degga );};};_fba :=_ccdd ._gdf .Items ();for _ ,_aebe :=range _fba {_bcb (_aebe );};if _ccdd .AddTOC {var _efag int ;if _bgb {_efag =len (_acgb );
};_fbg :=_cb .NewOutlineDest (int64 (_efag ),0,_ccdd ._gdbg );if _efag >=0&&_efag < len (_ccdd ._eegb ){_fbg .PageObj =_ccdd ._eegb [_efag ].GetPageAsIndirectObject ();}else {_c .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_efag );
};_ccdd ._gdf .Insert (0,_cb .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_fbg ));};};for _cced ,_bgcdb :=range _ccdd ._eegb {_ccdd .setActivePage (_bgcdb );if _ccdd ._eba !=nil {_agbb ,_bacb ,_dba :=_bgcdb .Size ();
if _dba !=nil {return _dba ;};_gaeb :=PageFinalizeFunctionArgs {PageNum :_cced +1,PageWidth :_agbb ,PageHeight :_bacb ,TOCPages :len (_dggd ),TotalPages :_cfcg };if _cgfd :=_ccdd ._eba (_gaeb );_cgfd !=nil {_c .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_cgfd );
return _cgfd ;};};if _ccdd ._fgfg !=nil {_degf :=NewBlock (_ccdd ._caf ,_ccdd ._bgcf .Top );_fgfd :=HeaderFunctionArgs {PageNum :_cced +1,TotalPages :_cfcg };_ccdd ._fgfg (_degf ,_fgfd );_degf .SetPos (0,0);if _fbge :=_ccdd .Draw (_degf );_fbge !=nil {_c .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_fbge );
return _fbge ;};};if _ccdd ._cfa !=nil {_eaaf :=NewBlock (_ccdd ._caf ,_ccdd ._bgcf .Bottom );_dfc :=FooterFunctionArgs {PageNum :_cced +1,TotalPages :_cfcg };_ccdd ._cfa (_eaaf ,_dfc );_eaaf .SetPos (0,_ccdd ._gdbg -_eaaf ._fd );if _ebd :=_ccdd .Draw (_eaaf );
_ebd !=nil {_c .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_ebd );return _ebd ;};};_bedc ,_cbgf :=_ccdd ._ebfd [_bgcdb ];if _eacf ,_aeg :=_ccdd ._bdec [_bgcdb ];
_aeg {if _cbgf {_bedc .transformBlock (_eacf );};if _cacf :=_eacf .drawToPage (_bgcdb );_cacf !=nil {_c .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_cced +1,_cacf );
return _cacf ;};};if _cbgf {if _beacg :=_bedc .transformPage (_bgcdb );_beacg !=nil {_c .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_beacg );
return _beacg ;};};};_ccdd ._aag =true ;return nil ;};

// Height returns Rectangle's document height.
func (_dagg *Rectangle )Height ()float64 {return _dagg ._fbgee };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_fggg *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_fggg ._adg .Left =left ;_fggg ._adg .Right =right ;_fggg ._adg .Top =top ;_fggg ._adg .Bottom =bottom ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_bgad *Creator )NewTextStyle ()TextStyle {return _gabe (_bgad ._bfde )};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_ddfc *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_dbee float64 ;_ddgcb uint ;_cdbff float64 ;_gfea Positioning ;_bcgece float64 ;_bbcff float64 ;_fefc int64 ;};

// SetMargins sets the margins TOC line.
func (_fdba *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_fdba ._dbee =left ;_cdee :=&_fdba ._ddfc ._bcbb ;_cdee .Left =_fdba ._dbee +float64 (_fdba ._ddgcb -1)*_fdba ._cdbff ;_cdee .Right =right ;_cdee .Top =top ;_cdee .Bottom =bottom ;};func _ceeg (_cbgb ,_ageb TextStyle )*Invoice {_gbda :=&Invoice {_fdec :"\u0049N\u0056\u004f\u0049\u0043\u0045",_dfdc :"\u002c\u0020",_gbece :_cbgb ,_cfge :_ageb };
_gbda ._geaa =&InvoiceAddress {Separator :_gbda ._dfdc };_gbda ._ggba =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gbda ._dfdc };_fbaaa :=ColorRGBFrom8bit (245,245,245);_gedd :=ColorRGBFrom8bit (155,155,155);_gbda ._bbgg =_ageb ;
_gbda ._bbgg .Color =_gedd ;_gbda ._bbgg .FontSize =20;_gbda ._dff =_cbgb ;_gbda ._eagc =_ageb ;_gbda ._fadd =_cbgb ;_gbda ._cde =_ageb ;_gbda ._ffde =_gbda .NewCellProps ();_gbda ._ffde .BackgroundColor =_fbaaa ;_gbda ._ffde .TextStyle =_ageb ;_gbda ._defb =_gbda .NewCellProps ();
_gbda ._defb .TextStyle =_ageb ;_gbda ._defb .BackgroundColor =_fbaaa ;_gbda ._defb .BorderColor =_fbaaa ;_gbda ._cfbe =_gbda .NewCellProps ();_gbda ._cfbe .BorderColor =_fbaaa ;_gbda ._cfbe .BorderSides =[]CellBorderSide {CellBorderSideBottom };_gbda ._cfbe .Alignment =CellHorizontalAlignmentRight ;
_gbda ._eecgg =_gbda .NewCellProps ();_gbda ._eecgg .Alignment =CellHorizontalAlignmentRight ;_gbda ._bgbg =[2]*InvoiceCell {_gbda .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gbda ._ffde ),_gbda .newCell ("",_gbda ._ffde )};
_gbda ._fgcgf =[2]*InvoiceCell {_gbda .newCell ("\u0044\u0061\u0074\u0065",_gbda ._ffde ),_gbda .newCell ("",_gbda ._ffde )};_gbda ._adeg =[2]*InvoiceCell {_gbda .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gbda ._ffde ),_gbda .newCell ("",_gbda ._ffde )};
_gbda ._gbbb =[2]*InvoiceCell {_gbda .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gbda ._eecgg ),_gbda .newCell ("",_gbda ._eecgg )};_fbda :=_gbda ._eecgg ;_fbda .TextStyle =_ageb ;_fbda .BackgroundColor =_fbaaa ;_fbda .BorderColor =_fbaaa ;
_gbda ._fedc =[2]*InvoiceCell {_gbda .newCell ("\u0054\u006f\u0074a\u006c",_fbda ),_gbda .newCell ("",_fbda )};_gbda ._gbbf =[2]string {"\u004e\u006f\u0074e\u0073",""};_gbda ._gdbe =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_gbda ._efdf =[]*InvoiceCell {_gbda .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gbda .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gbda .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gbda .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gbda ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_cfef *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _ebdg (xc ,yc ,width ,height );};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_cbce *Invoice )AddressHeadingStyle ()TextStyle {return _cbce ._cfge };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_abad *TOCLine )SetLink (page int64 ,x ,y float64 ){_abad ._bcgece =x ;_abad ._bbcff =y ;_abad ._fefc =page ;_bbcaf :=_abad ._ddfc ._bcgeg .Color ;_abad .Number .Style .Color =_bbcaf ;_abad .Title .Style .Color =_bbcaf ;_abad .Separator .Style .Color =_bbcaf ;
_abad .Page .Style .Color =_bbcaf ;};

// Add adds a new Drawable to the chapter.
func (_gebf *Chapter )Add (d Drawable )error {if Drawable (_gebf )==d {_c .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _fbdd :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_gebf ._eccg =append (_gebf ._eccg ,d );case containerDrawable :_fbb ,_eef :=_fbdd .ContainerComponent (_gebf );if _eef !=nil {return _eef ;};_gebf ._eccg =append (_gebf ._eccg ,_fbb );
default:_c .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_abfg *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _abfg ._fedc [0],_abfg ._fedc [1]};

// SetAngle sets Image rotation angle in degrees.
func (_bdcgf *Image )SetAngle (angle float64 ){_bdcgf ._geeg =angle };

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_geca *Image )GetHorizontalAlignment ()HorizontalAlignment {return _geca ._dgfe };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func _fbdb (_accg ,_bdf ,_gbc ,_dcea float64 )*border {_fbdg :=&border {};_fbdg ._bbaa =_accg ;_fbdg ._dbd =_bdf ;_fbdg ._cbbc =_gbc ;_fbdg ._efc =_dcea ;_fbdg ._cfg =ColorBlack ;_fbdg ._ffea =ColorBlack ;
_fbdg ._gfe =ColorBlack ;_fbdg ._dec =ColorBlack ;_fbdg ._ca =0;_fbdg ._dcdf =0;_fbdg ._degc =0;_fbdg ._abf =0;_fbdg .LineStyle =_fce .LineStyleSolid ;return _fbdg ;};

// IsRelative checks if the positioning is relative.
func (_gfbe Positioning )IsRelative ()bool {return _gfbe ==PositionRelative };

// Height returns Image's document height.
func (_eebd *Image )Height ()float64 {return _eebd ._becd };