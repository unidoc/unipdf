//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_b "bytes";_c "errors";_ab "fmt";_d "github.com/unidoc/unipdf/v3/common";_gf "github.com/unidoc/unipdf/v3/contentstream";_gc "github.com/unidoc/unipdf/v3/contentstream/draw";_cad "github.com/unidoc/unipdf/v3/core";_ga "github.com/unidoc/unipdf/v3/model";_fc "image";_f "io";_g "math";_ef "os";_e "sort";_efa "strconv";_ca "strings";_fa "unicode";);

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ggg *Creator )MoveDown (dy float64 ){_ggg ._bgac .Y +=dy };func (_ffgd positioning )isAbsolute ()bool {return _ffgd ==_eeae };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);func _gca (_bab ,_eggc *_ga .PdfPageResources )error {_caa ,_ :=_bab .GetColorspaces ();if _caa !=nil &&len (_caa .Colorspaces )> 0{for _gad ,_bdc :=range _caa .Colorspaces {_agd :=*_cad .MakeName (_gad );if _eggc .HasColorspaceByName (_agd ){continue ;};_eea :=_eggc .SetColorspaceByName (_agd ,_bdc );if _eea !=nil {return _eea ;};};};return nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_adbee string ;_daaa *Image ;_deea *InvoiceAddress ;_fcd *InvoiceAddress ;_aef string ;_effc [2]*InvoiceCell ;_babe [2]*InvoiceCell ;_bac [2]*InvoiceCell ;_eaf [][2]*InvoiceCell ;_cegd []*InvoiceCell ;_gcgb [][]*InvoiceCell ;_aed [2]*InvoiceCell ;_aagd [2]*InvoiceCell ;_gfef [][2]*InvoiceCell ;_aea [2]string ;_agge [2]string ;_fddg [][2]string ;_dfdf TextStyle ;_dfcfe TextStyle ;_fcab TextStyle ;_dfbf TextStyle ;_gcbg TextStyle ;_ecccg TextStyle ;_ddgb TextStyle ;_cdeg InvoiceCellProps ;_beaa InvoiceCellProps ;_aedd InvoiceCellProps ;_bffe InvoiceCellProps ;_ceaf positioning ;};

// SetWidth sets line width.
func (_bffg *Curve )SetWidth (width float64 ){_bffg ._ggdb =width };

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_eeff *TableCell )SetContent (vd VectorDrawable )error {switch _adfc :=vd .(type ){case *Paragraph :if _adfc ._eggd {_adfc ._deba =true ;};_eeff ._gbgf =vd ;case *StyledParagraph :if _adfc ._edggb {_adfc ._cdec =true ;};_eeff ._gbgf =vd ;case *Image :_eeff ._gbgf =vd ;case *Table :_eeff ._gbgf =vd ;case *List :_eeff ._gbgf =vd ;case *Division :_eeff ._gbgf =vd ;default:_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _cad .ErrTypeError ;};return nil ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_bged *Creator )DrawFooter (drawFooterFunc func (_faec *Block ,_badg FooterFunctionArgs )){_bged ._gde =drawFooterFunc ;};

// SetStyleRight sets border style for right side.
func (_beee *border )SetStyleRight (style CellBorderStyle ){_beee ._gga =style };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_cf *_gf .ContentStreamOperations ;_dg *_ga .PdfPageResources ;_ea positioning ;_eg ,_gcc float64 ;_cfe float64 ;_gfa float64 ;_de float64 ;_abf margins ;_gg []*_ga .PdfAnnotation ;};func _gfgc (_gfac ,_bgbf ,_cbgf TextChunk ,_cddd uint ,_dfeee TextStyle )*TOCLine {_decb :=_afae (_dfeee );_decb .SetEnableWrap (true );_decb .SetTextAlignment (TextAlignmentLeft );_decb .SetMargins (0,0,2,2);_dece :=&TOCLine {_gfeg :_decb ,Number :_gfac ,Title :_bgbf ,Page :_cbgf ,Separator :TextChunk {Text :"\u002e",Style :_dfeee },_egdc :0,_cagc :_cddd ,_aedde :10,_efbe :_fabc };_decb ._ebee ._dea =_dece ._egdc +float64 (_dece ._cagc -1)*_dece ._aedde ;_decb ._edfb =_dece .prepareParagraph ;return _dece ;};

// SetFillColor sets background color for border.
func (_cdd *border )SetFillColor (col Color ){_cdd ._cba =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// Width returns Image's document width.
func (_baa *Image )Width ()float64 {return _baa ._ffecf };func (_ba *Block )addContents (_bc *_gf .ContentStreamOperations ){_ba ._cf .WrapIfNeeded ();_bc .WrapIfNeeded ();*_ba ._cf =append (*_ba ._cf ,*_bc ...);};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// Width returns the current page width.
func (_ebbd *Creator )Width ()float64 {return _ebbd ._dbag };

// AddTotalLine adds a new line in the invoice totals table.
func (_gggg *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gbaa :=&InvoiceCell {_gggg ._bffe ,desc };_gffd :=&InvoiceCell {_gggg ._bffe ,value };_gggg ._gfef =append (_gggg ._gfef ,[2]*InvoiceCell {_gbaa ,_gffd });return _gbaa ,_gffd ;};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_bcdg :=rgbColor {};_bcdg ._fef =float64 (r )/255.0;_bcdg ._eba =float64 (g )/255.0;_bcdg ._befb =float64 (b )/255.0;return _bcdg ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_bgda *Invoice )SetColumns (cols []*InvoiceCell ){_bgda ._cegd =cols };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_beac *Creator )EnableFontSubsetting (font *_ga .PdfFont ){_beac ._eag =append (_beac ._eag ,font )};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aeaa *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aeaa ._ebee ._dea ,_aeaa ._ebee ._aaf ,_aeaa ._ebee ._bdbd ,_aeaa ._ebee ._bgb ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_acc *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _afcf (number ,title ,page ,level ,_acc .NewTextStyle ());};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gdcf *StyledParagraph )SetTextAlignment (align TextAlignment ){_gdcf ._fgacf =align };func _bcff (_adcg TextStyle )*List {return &List {_dbba :TextChunk {Text :"\u2022\u0020",Style :_adcg },_bcbf :0,_dbce :true ,_gagf :_fabc ,_acgd :_adcg };};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_daf *Creator )SetForms (form *_ga .PdfAcroForm )error {_daf ._cgg =form ;return nil };func _dfbc (_eagd []byte )(*Image ,error ){_gfbe :=_b .NewReader (_eagd );_dabg ,_afc :=_ga .ImageHandling .Read (_gfbe );if _afc !=nil {_d .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_afc );return nil ,_afc ;};return _ggec (_dabg );};func (_gba rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _gba ._fef ,_gba ._eba ,_gba ._befb };func _efda (_cgaf string ,_cfcdc TextStyle )*Paragraph {_dfeeb :=&Paragraph {_dgea :_cgaf ,_ffgce :_cfcdc .Font ,_bfgb :_cfcdc .FontSize ,_agcd :1.0,_deba :true ,_eggd :true ,_fadfa :TextAlignmentLeft ,_beeef :0,_dcae :1,_gdfa :1,_decc :_fabc };_dfeeb .SetColor (_cfcdc .Color );return _dfeeb ;};

// GetCoords returns coordinates of border.
func (_fba *border )GetCoords ()(float64 ,float64 ){return _fba ._cfd ,_fba ._fbe };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dgae *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dgae ._ced ._dea =left ;_dgae ._ced ._aaf =right ;_dgae ._ced ._bdbd =top ;_dgae ._ced ._bgb =bottom ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_dafd *TOC )SetLineSeparatorStyle (style TextStyle ){_dafd ._afac =style };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_gcaec *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_gcaec .Text },nil ;};var _fdggg []string ;var _aceb []rune ;var _gccfd float64 ;var _dddb []float64 ;_abaf :=_gcaec .Style ;_bdgcf :=[]rune (_gcaec .Text );for _ ,_bgeg :=range _bdgcf {if _bgeg =='\u000A'{_fdggg =append (_fdggg ,_ca .TrimRightFunc (string (_aceb ),_fa .IsSpace )+string (_bgeg ));_aceb =nil ;_gccfd =0;_dddb =nil ;continue ;};_fdegg :=_bgeg ==' ';_cafa ,_ebga :=_abaf .Font .GetRuneMetrics (_bgeg );if !_ebga {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bgeg ,_bgeg ,_abaf .Font .BaseFont (),_abaf .Font .Subtype ());_d .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_abaf .Font );_d .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_abaf .Font .Encoder ());return nil ,_c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_eegef :=_abaf .FontSize *_cafa .Wx ;_cedgb :=_eegef ;if !_fdegg {_cedgb =_eegef +_abaf .CharSpacing *1000.0;};if _gccfd +_eegef > width *1000.0{_bdfe :=-1;if !_fdegg {for _fgff :=len (_aceb )-1;_fgff >=0;_fgff --{if _aceb [_fgff ]==' '{_bdfe =_fgff ;break ;};};};_fbdgd :=string (_aceb );if _bdfe > 0{_fbdgd =string (_aceb [0:_bdfe +1]);_aceb =append (_aceb [_bdfe +1:],_bgeg );_dddb =append (_dddb [_bdfe +1:],_cedgb );_gccfd =0;for _ ,_caaf :=range _dddb {_gccfd +=_caaf ;};}else {if _fdegg {_aceb =[]rune {};_dddb =[]float64 {};_gccfd =0;}else {_aceb =[]rune {_bgeg };_dddb =[]float64 {_cedgb };_gccfd =_cedgb ;};};_fdggg =append (_fdggg ,_ca .TrimRightFunc (_fbdgd ,_fa .IsSpace ));}else {_aceb =append (_aceb ,_bgeg );_gccfd +=_cedgb ;_dddb =append (_dddb ,_cedgb );};};if len (_aceb )> 0{_fdggg =append (_fdggg ,string (_aceb ));};return _fdggg ,nil ;};func (_eade *Paragraph )getTextLineWidth (_gaca string )float64 {var _bacd float64 ;for _ ,_ceda :=range _gaca {if _ceda =='\u000A'{continue ;};_gddf ,_gecf :=_eade ._ffgce .GetRuneMetrics (_ceda );if !_gecf {_d .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_ceda ,_ceda );return -1;};_bacd +=_eade ._bfgb *_gddf .Wx ;};return _bacd ;};func _dac (_gfbc _fc .Image )(*Image ,error ){_dgec ,_cddb :=_ga .ImageHandling .NewImageFromGoImage (_gfbc );if _cddb !=nil {return nil ,_cddb ;};return _ggec (_dgec );};

// Add adds a new line with the default style to the table of contents.
func (_edfdag *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_dcfe :=_edfdag .AddLine (_gfgc (TextChunk {Text :number ,Style :_edfdag ._gdfd },TextChunk {Text :title ,Style :_edfdag ._bgge },TextChunk {Text :page ,Style :_edfdag ._edde },level ,_edfdag ._cabfe ));if _dcfe ==nil {return nil ;};_agdaa :=&_edfdag ._edda ;_dcfe .SetMargins (_agdaa ._dea ,_agdaa ._aaf ,_agdaa ._bdbd ,_agdaa ._bgb );_dcfe .SetLevelOffset (_edfdag ._cdeee );_dcfe .Separator .Text =_edfdag ._cgfdf ;_dcfe .Separator .Style =_edfdag ._afac ;return _dcfe ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetLevel sets the indentation level of the TOC line.
func (_cadc *TOCLine )SetLevel (level uint ){_cadc ._cagc =level ;_cadc ._gfeg ._ebee ._dea =_cadc ._egdc +float64 (_cadc ._cagc -1)*_cadc ._aedde ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_ddgc *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bege :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _fbag []string ;_fbag =append (_fbag ,_ab .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_ddgc ._ggdb ));_fbag =append (_fbag ,_ab .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_ddgc ._ebdd [0],_ddgc ._ebdd [1],_ddgc ._ebdd [2]));_fbag =append (_fbag ,_ab .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_ddgc ._acbg ,ctx .PageHeight -_ddgc ._eadc ));_fbag =append (_fbag ,_ab .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_ddgc ._egfad ,ctx .PageHeight -_ddgc ._gcgcg ,_ddgc ._dbaa ,ctx .PageHeight -_ddgc ._bbfe ));_dfcf :=_bege .addContentsByString (_ca .Join (_fbag ,"\u000a"));if _dfcf !=nil {return nil ,ctx ,_dfcf ;};return []*Block {_bege },ctx ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aeggd *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbbf :=ctx ;_bbeb ,ctx ,_dabc :=_aeggd ._gfeg .GeneratePageBlocks (ctx );if _dabc !=nil {return _bbeb ,ctx ,_dabc ;};if _aeggd ._efbe .isRelative (){ctx .X =_gbbf .X ;};if _aeggd ._efbe .isAbsolute (){return _bbeb ,_gbbf ,nil ;};return _bbeb ,ctx ,nil ;};func _aabd (_afeg ,_dffa ,_dagg ,_gfagc float64 )*Rectangle {_eeed :=&Rectangle {};_eeed ._deefa =_afeg ;_eeed ._dagf =_dffa ;_eeed ._bcgfb =_dagg ;_eeed ._ffbf =_gfagc ;_eeed ._gace =_ga .NewPdfColorDeviceRGB (0,0,0);_eeed ._eaba =1.0;return _eeed ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_fgc *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _gfgc (number ,title ,page ,level ,style );};var PPMM =float64 (72*1.0/25.4);

// AddLine appends a new line to the invoice line items table.
func (_ffge *Invoice )AddLine (values ...string )[]*InvoiceCell {_dgg :=len (_ffge ._cegd );var _fdc []*InvoiceCell ;for _ada ,_dcdc :=range values {_bbda :=_ffge .newCell (_dcdc ,_ffge ._aedd );if _ada < _dgg {_bbda .Alignment =_ffge ._cegd [_ada ].Alignment ;};_fdc =append (_fdc ,_bbda );};_ffge ._gcgb =append (_ffge ._gcgb ,_fdc );return _fdc ;};

// Scale block by specified factors in the x and y directions.
func (_abbe *Block )Scale (sx ,sy float64 ){_cfc :=_gf .NewContentCreator ().Scale (sx ,sy ).Operations ();*_abbe ._cf =append (*_cfc ,*_abbe ._cf ...);_abbe ._cf .WrapIfNeeded ();_abbe ._cfe *=sx ;_abbe ._gfa *=sy ;};func (_cag *Block )addContentsByString (_ac string )error {_be :=_gf .NewContentStreamParser (_ac );_dd ,_bca :=_be .Parse ();if _bca !=nil {return _bca ;};_cag ._cf .WrapIfNeeded ();_dd .WrapIfNeeded ();*_cag ._cf =append (*_cag ._cf ,*_dd ...);return nil ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_dbge *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dbge ._afd ._dea ,_dbge ._afd ._aaf ,_dbge ._afd ._bdbd ,_dbge ._afd ._bgb ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_ddfge *TextChunk )SetAnnotation (annotation *_ga .PdfAnnotation ){_ddfge ._gbbg =annotation };func _fcfa (_cfcda int )*Table {_edbgd :=&Table {_ggag :_cfcda ,_agdc :10.0,_agae :[]float64 {},_cefdb :[]float64 {},_bfgf :[]*TableCell {}};_edbgd .resetColumnWidths ();return _edbgd ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_afaec *Table )MultiColCell (colspan int )*TableCell {return _afaec .newCell (colspan )};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_bcgdb *Creator )NewImageFromGoImage (goimg _fc .Image )(*Image ,error ){return _dac (goimg )};

// SetIndent sets the cell's left indent.
func (_ffecd *TableCell )SetIndent (indent float64 ){_ffecd ._ddcf =indent };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_fccf *Invoice )Terms ()(string ,string ){return _fccf ._agge [0],_fccf ._agge [1]};type margins struct{_dea float64 ;_aaf float64 ;_bdbd float64 ;_bgb float64 ;};func (_dbgd *TOCLine )getLineLink ()*_ga .PdfAnnotation {if _dbgd ._dged <=0{return nil ;};return _bcgb (_dbgd ._dged -1,_dbgd ._ffbee ,_dbgd ._geeb ,0);};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_ce *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ce ._geeg ._dea ,_ce ._geeg ._aaf ,_ce ._geeg ._bdbd ,_ce ._geeg ._bgb ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_ccgf *Creator )DrawHeader (drawHeaderFunc func (_edca *Block ,_fbec HeaderFunctionArgs )){_ccgf ._bcgf =drawHeaderFunc ;};

// SetAngle sets the rotation angle of the text.
func (_ecde *Paragraph )SetAngle (angle float64 ){_ecde ._beeef =angle };

// Width returns the width of the Paragraph.
func (_bece *StyledParagraph )Width ()float64 {if _bece ._cdec &&int (_bece ._gdff )> 0{return _bece ._gdff ;};return _bece .getTextWidth ()/1000.0;};

// SetLineHeight sets the line height (1.0 default).
func (_dbef *Paragraph )SetLineHeight (lineheight float64 ){_dbef ._agcd =lineheight };type positioning int ;

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_gcgc *Creator )MoveRight (dx float64 ){_gcgc ._bgac .X +=dx };

// Reset removes all the text chunks the paragraph contains.
func (_fcf *StyledParagraph )Reset (){_fcf ._facc =[]*TextChunk {}};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_abbg *Creator )SetPageSize (size PageSize ){_abbg ._egfa =size ;_abbg ._dbag =size [0];_abbg ._ffd =size [1];_ffea :=0.1*_abbg ._dbag ;_abbg ._ced ._dea =_ffea ;_abbg ._ced ._aaf =_ffea ;_abbg ._ced ._bdbd =_ffea ;_abbg ._ced ._bgb =_ffea ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dfgg *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_dffb :=_afae (_dfgg ._acgd );_dffb .Append (text );_gfge ,_gcef :=_dfgg .Add (_dffb );return _dffb ,_gfge ,_gcef ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_gdfg *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _cabg []*Block ;_gbfe :=ctx ;if _gdfg ._bgga .isRelative (){ctx .X +=_gdfg ._ecb ._dea ;ctx .Y +=_gdfg ._ecb ._bdbd ;ctx .Width -=_gdfg ._ecb ._dea +_gdfg ._ecb ._aaf ;ctx .Height -=_gdfg ._ecb ._bdbd +_gdfg ._ecb ._bgb ;};ctx .Inline =_gdfg ._fbdb ;_dfbb :=ctx ;_feca :=ctx ;var _dgeb float64 ;for _ ,_cceg :=range _gdfg ._ggac {if ctx .Inline {if (ctx .X -_dfbb .X )+_cceg .Width ()<=ctx .Width {ctx .Y =_feca .Y ;ctx .Height =_feca .Height ;}else {ctx .X =_dfbb .X ;ctx .Width =_dfbb .Width ;_feca .Y +=_dgeb ;_feca .Height -=_dgeb ;_dgeb =0;};};_agea ,_acbgd ,_gbdb :=_cceg .GeneratePageBlocks (ctx );if _gbdb !=nil {_d .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_gbdb );return nil ,ctx ,_gbdb ;};if len (_agea )< 1{continue ;};if len (_cabg )> 0{_cabg [len (_cabg )-1].mergeBlocks (_agea [0]);_cabg =append (_cabg ,_agea [1:]...);}else {_cabg =append (_cabg ,_agea [0:]...);};if ctx .Inline {if ctx .Page !=_acbgd .Page {_dfbb .Y =ctx .Margins ._bdbd ;_dfbb .Height =ctx .PageHeight -ctx .Margins ._bdbd ;_feca .Y =_dfbb .Y ;_feca .Height =_dfbb .Height ;_dgeb =_acbgd .Height -_dfbb .Height ;}else {if _egaf :=ctx .Height -_acbgd .Height ;_egaf > _dgeb {_dgeb =_egaf ;};};}else {_acbgd .X =ctx .X ;};ctx =_acbgd ;};ctx .Inline =_gbfe .Inline ;if _gdfg ._bgga .isRelative (){ctx .X =_gbfe .X ;};if _gdfg ._bgga .isAbsolute (){return _cabg ,_gbfe ,nil ;};return _cabg ,ctx ,nil ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_cfdf *Table )SetMargins (left ,right ,top ,bottom float64 ){_cfdf ._cgfg ._dea =left ;_cfdf ._cgfg ._aaf =right ;_cfdf ._cgfg ._bdbd =top ;_cfdf ._cgfg ._bgb =bottom ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_efgg *_ga .PdfColorDeviceRGB ;_bbeda _gc .LineStyle ;_abfd CellBorderStyle ;_aeef *_ga .PdfColorDeviceRGB ;_baeg float64 ;_aggf CellBorderStyle ;_cgcdc *_ga .PdfColorDeviceRGB ;_ecaa float64 ;_becc CellBorderStyle ;_cgcba *_ga .PdfColorDeviceRGB ;_fgcc float64 ;_cgfc CellBorderStyle ;_adeb *_ga .PdfColorDeviceRGB ;_bbgae float64 ;_aaca ,_eggg int ;_cccb int ;_cbac int ;_gbgf VectorDrawable ;_deaag CellHorizontalAlignment ;_aafca CellVerticalAlignment ;_ddcf float64 ;_gegdf *Table ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_caaa *Paragraph )SetWidth (width float64 ){_caaa ._cebe =width ;_caaa .wrapText ()};

// AddSection adds a new content section at the end of the invoice.
func (_eacc *Invoice )AddSection (title ,content string ){_eacc ._fddg =append (_eacc ._fddg ,[2]string {title ,content });};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_dgaf *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_cbfec :=NewTextChunk (text ,_dgaf ._fgace );_cbfec ._gbbg =_bcgb (page -1,x ,y ,zoom );return _dgaf .appendChunk (_cbfec );};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_gbac *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_faa :=&_gbac ._gfeg ._ebee ;return _gbac ._egdc ,_faa ._aaf ,_faa ._bdbd ,_faa ._bgb ;};func _dedg (_fdga string )*_ga .PdfAnnotation {_aabce :=_ga .NewPdfAnnotationLink ();_bebc :=_ga .NewBorderStyle ();_bebc .SetBorderWidth (0);_aabce .BS =_bebc .ToPdfObject ();_cdee :=_ga .NewPdfActionURI ();_cdee .URI =_cad .MakeString (_fdga );_aabce .SetAction (_cdee .PdfAction );return _aabce .PdfAnnotation ;};func _aged (_cbbd *Block ,_bdgd *Image ,_gda DrawContext )(DrawContext ,error ){_facf :=_gda ;_ebaf :=1;_aaeg :=_cad .PdfObjectName (_ab .Sprintf ("\u0049\u006d\u0067%\u0064",_ebaf ));for _cbbd ._dg .HasXObjectByName (_aaeg ){_ebaf ++;_aaeg =_cad .PdfObjectName (_ab .Sprintf ("\u0049\u006d\u0067%\u0064",_ebaf ));};_ecea :=_cbbd ._dg .SetXObjectImageByName (_aaeg ,_bdgd ._gdcb );if _ecea !=nil {return _gda ,_ecea ;};_eagfc :=0;_bec :=_cad .PdfObjectName (_ab .Sprintf ("\u0047\u0053\u0025\u0064",_eagfc ));for _cbbd ._dg .HasExtGState (_bec ){_eagfc ++;_bec =_cad .PdfObjectName (_ab .Sprintf ("\u0047\u0053\u0025\u0064",_eagfc ));};_bebb :=_cad .MakeDict ();_bebb .Set ("\u0042\u004d",_cad .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _bdgd ._fggb < 1.0{_bebb .Set ("\u0043\u0041",_cad .MakeFloat (_bdgd ._fggb ));_bebb .Set ("\u0063\u0061",_cad .MakeFloat (_bdgd ._fggb ));};_ecea =_cbbd ._dg .AddExtGState (_bec ,_cad .MakeIndirectObject (_bebb ));if _ecea !=nil {return _gda ,_ecea ;};_dgaa :=_bdgd .Width ();_bbba :=_bdgd .Height ();_ ,_debdf :=_bdgd .rotatedSize ();_fccg :=_gda .X ;_cfacc :=_gda .PageHeight -_gda .Y -_bbba ;if _bdgd ._bcdd .isRelative (){_cfacc -=(_debdf -_bbba )/2;switch _bdgd ._bceag {case HorizontalAlignmentCenter :_fccg +=(_gda .Width -_dgaa )/2;case HorizontalAlignmentRight :_fccg =_gda .PageWidth -_gda .Margins ._aaf -_bdgd ._afd ._aaf -_dgaa ;};};_acddg :=_bdgd ._bbeg ;_cdf :=_gf .NewContentCreator ();_cdf .Add_gs (_bec );_cdf .Translate (_fccg ,_cfacc );if _acddg !=0{_cdf .Translate (_dgaa /2,_bbba /2);_cdf .RotateDeg (_acddg );_cdf .Translate (-_dgaa /2,-_bbba /2);};_cdf .Scale (_dgaa ,_bbba ).Add_Do (_aaeg );_bgfc :=_cdf .Operations ();_bgfc .WrapIfNeeded ();_cbbd .addContents (_bgfc );if _bdgd ._bcdd .isRelative (){_gda .Y +=_debdf ;_gda .Height -=_debdf ;return _gda ,nil ;};return _facf ,nil ;};func (_ddee *Invoice )drawAddress (_gbge *InvoiceAddress )[]*StyledParagraph {var _ecbe []*StyledParagraph ;if _gbge .Heading !=""{_cgbf :=_afae (_ddee ._gcbg );_cgbf .SetMargins (0,0,0,7);_cgbf .Append (_gbge .Heading );_ecbe =append (_ecbe ,_cgbf );};_fcga :=_afae (_ddee ._dfbf );_fcga .SetLineHeight (1.2);_gagc :=_gbge .Separator ;if _gagc ==""{_gagc =_ddee ._aef ;};_gbcd :=_gbge .City ;if _gbge .State !=""{if _gbcd !=""{_gbcd +=_gagc ;};_gbcd +=_gbge .State ;};if _gbge .Zip !=""{if _gbcd !=""{_gbcd +=_gagc ;};_gbcd +=_gbge .Zip ;};if _gbge .Name !=""{_fcga .Append (_gbge .Name +"\u000a");};if _gbge .Street !=""{_fcga .Append (_gbge .Street +"\u000a");};if _gbge .Street2 !=""{_fcga .Append (_gbge .Street2 +"\u000a");};if _gbcd !=""{_fcga .Append (_gbcd +"\u000a");};if _gbge .Country !=""{_fcga .Append (_gbge .Country +"\u000a");};_gdedd :=_afae (_ddee ._dfbf );_gdedd .SetLineHeight (1.2);_gdedd .SetMargins (0,0,7,0);if _gbge .Phone !=""{_gdedd .Append (_ab .Sprintf ("\u0050\u0068\u006f\u006e\u0065\u003a\u0020\u0025\u0073\u000a",_gbge .Phone ));};if _gbge .Email !=""{_gdedd .Append (_ab .Sprintf ("\u0045\u006d\u0061\u0069\u006c\u003a\u0020\u0025\u0073\u000a",_gbge .Email ));};_ecbe =append (_ecbe ,_fcga ,_gdedd );return _ecbe ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// NewChapter creates a new chapter with the specified title as the heading.
func (_agec *Creator )NewChapter (title string )*Chapter {_agec ._ggdd ++;_bgad :=_agec .NewTextStyle ();_bgad .FontSize =16;return _dabf (nil ,_agec ._dec ,_agec ._gfd ,title ,_agec ._ggdd ,_bgad );};func (_baed *StyledParagraph )appendChunk (_bcba *TextChunk )*TextChunk {_baed ._facc =append (_baed ._facc ,_bcba );_baed .wrapText ();return _bcba ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_dage *StyledParagraph )SetEnableWrap (enableWrap bool ){_dage ._cdec =enableWrap ;_dage ._edggb =false ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ccd *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ccd ._abf ._dea ,_ccd ._abf ._aaf ,_ccd ._abf ._bdbd ,_ccd ._abf ._bgb ;};

// NewTable create a new Table with a specified number of columns.
func (_dcgf *Creator )NewTable (cols int )*Table {return _fcfa (cols )};type listItem struct{_cfaca VectorDrawable ;_ggacf TextChunk ;};

// SetPos sets absolute positioning with specified coordinates.
func (_edfdc *Paragraph )SetPos (x ,y float64 ){_edfdc ._decc =_eeae ;_edfdc ._begf =x ;_edfdc ._acfb =y ;};

// SetFillColor sets the fill color for the path.
func (_cedc *FilledCurve )SetFillColor (color Color ){_cedc ._egc =_ga .NewPdfColorDeviceRGB (color .ToRGB ());};

// TOC returns the table of contents component of the creator.
func (_bcga *Creator )TOC ()*TOC {return _bcga ._dec };func (_efdg *Table )newCell (_dcf int )*TableCell {_efdg ._bcfg ++;_dega :=(_efdg ._bcfg -1)/_efdg ._ggag +1;for _dega > _efdg ._egbbd {_efdg ._egbbd ++;_efdg ._cefdb =append (_efdg ._cefdb ,_efdg ._agdc );};_eeag :=(_efdg ._bcfg -1)%(_efdg ._ggag )+1;_bdfb :=&TableCell {};_bdfb ._aaca =_dega ;_bdfb ._eggg =_eeag ;_bdfb ._cccb =1;_bdfb ._ddcf =5;_bdfb ._abfd =CellBorderStyleNone ;_bdfb ._bbeda =_gc .LineStyleSolid ;_bdfb ._deaag =CellHorizontalAlignmentLeft ;_bdfb ._aafca =CellVerticalAlignmentTop ;_bdfb ._baeg =0;_bdfb ._ecaa =0;_bdfb ._fgcc =0;_bdfb ._bbgae =0;_bacg :=ColorBlack ;_bdfb ._aeef =_ga .NewPdfColorDeviceRGB (_bacg .ToRGB ());_bdfb ._cgcdc =_ga .NewPdfColorDeviceRGB (_bacg .ToRGB ());_bdfb ._cgcba =_ga .NewPdfColorDeviceRGB (_bacg .ToRGB ());_bdfb ._adeb =_ga .NewPdfColorDeviceRGB (_bacg .ToRGB ());if _dcf < 1{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_dcf );_dcf =1;};_bcaa :=_efdg ._ggag -(_bdfb ._eggg -1);if _dcf > _bcaa {_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_dcf ,_bcaa );_dcf =_bcaa ;};_bdfb ._cbac =_dcf ;_efdg ._bcfg +=_dcf -1;_efdg ._bfgf =append (_efdg ._bfgf ,_bdfb );_bdfb ._gegdf =_efdg ;return _bdfb ;};

// Scale scales Image by a constant factor, both width and height.
func (_dagad *Image )Scale (xFactor ,yFactor float64 ){_dagad ._ffecf =xFactor *_dagad ._ffecf ;_dagad ._adege =yFactor *_dagad ._adege ;};

// SetText sets the text content of the Paragraph.
func (_dccg *Paragraph )SetText (text string ){_dccg ._dgea =text };

// GeneratePageBlocks generates a page break block.
func (_agedc *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fega :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_fcdg :=ctx ;_fcdg .Y =ctx .Margins ._bdbd ;_fcdg .X =ctx .Margins ._dea ;_fcdg .Height =ctx .PageHeight -ctx .Margins ._bdbd -ctx .Margins ._bgb ;_fcdg .Width =ctx .PageWidth -ctx .Margins ._dea -ctx .Margins ._aaf ;ctx =_fcdg ;return _fega ,ctx ,nil ;};

// NewFilledCurve returns a instance of filled curve.
func (_fbac *Creator )NewFilledCurve ()*FilledCurve {return _dfdb ()};

// New creates a new instance of the PDF Creator.
func New ()*Creator {_cbd :=&Creator {};_cbd ._edg =[]*_ga .PdfPage {};_cbd ._dbg =map[*_ga .PdfPage ]*Block {};_cbd .SetPageSize (PageSizeLetter );_bedf :=0.1*_cbd ._dbag ;_cbd ._ced ._dea =_bedf ;_cbd ._ced ._aaf =_bedf ;_cbd ._ced ._bdbd =_bedf ;_cbd ._ced ._bgb =_bedf ;var _dbab error ;_cbd ._acdd ,_dbab =_ga .NewStandard14Font (_ga .HelveticaName );if _dbab !=nil {_cbd ._acdd =_ga .DefaultFont ();};_cbd ._dgfc ,_dbab =_ga .NewStandard14Font (_ga .HelveticaBoldName );if _dbab !=nil {_cbd ._acdd =_ga .DefaultFont ();};_cbd ._dec =_cbd .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_cbd .AddOutlines =true ;_cbd ._gfd =_ga .NewOutline ();return _cbd ;};

// SetNotes sets the notes section of the invoice.
func (_cbcfd *Invoice )SetNotes (title ,content string ){_cbcfd ._aea =[2]string {title ,content }};func (_degd *StyledParagraph )getTextHeight ()float64 {var _dagb float64 ;for _ ,_efe :=range _degd ._facc {_cff :=_efe .Style .FontSize *_degd ._bgdg ;if _cff > _dagb {_dagb =_cff ;};};return _dagb ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_acad *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_acad ._ggag {_d .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_acad ._agae =widths ;return nil ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_fbdf *Invoice )SetTerms (title ,content string ){_fbdf ._agge =[2]string {title ,content }};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_acbg float64 ;_eadc float64 ;_egfad float64 ;_gcgcg float64 ;_dbaa float64 ;_bbfe float64 ;_ebdd *_ga .PdfColorDeviceRGB ;_ggdb float64 ;};

// Append adds a new text chunk to the paragraph.
func (_eeb *StyledParagraph )Append (text string )*TextChunk {_aagb :=NewTextChunk (text ,_eeb ._adfe );return _eeb .appendChunk (_aagb );};func (_ega *Chapter )headingNumber ()string {var _cdedc string ;if _ega ._cfeg {if _ega ._abcf !=0{_cdedc =_efa .Itoa (_ega ._abcf )+"\u002e";};if _ega ._cded !=nil {_fbc :=_ega ._cded .headingNumber ();if _fbc !=""{_cdedc =_fbc +_cdedc ;};};};return _cdedc ;};func (_dba *Block )mergeBlocks (_fae *Block )error {_gbd :=_dbb (_dba ._cf ,_dba ._dg ,_fae ._cf ,_fae ._dg );if _gbd !=nil {return _gbd ;};for _ ,_fcg :=range _fae ._gg {_dba .AddAnnotation (_fcg );};return nil ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ccff *Image )ScaleToWidth (w float64 ){_eab :=_ccff ._adege /_ccff ._ffecf ;_ccff ._ffecf =w ;_ccff ._adege =w *_eab ;};

// NewPageBreak create a new page break.
func (_dfff *Creator )NewPageBreak ()*PageBreak {return _abcfa ()};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fcaba *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _fcaba ._bac [0],_fcaba ._bac [1]};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_bcge *Paragraph )Height ()float64 {_bcge .wrapText ();return float64 (len (_bcge ._cae ))*_bcge ._agcd *_bcge ._bfgb ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_feg *Invoice )SetNoteHeadingStyle (style TextStyle ){_feg ._ddgb =style };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_ffgab *Paragraph )SetEnableWrap (enableWrap bool ){_ffgab ._deba =enableWrap ;_ffgab ._eggd =false ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_gcbfc *List )Width ()float64 {return 0};func _caae (_gcdea ,_fafde ,_aagde float64 )(_cbaaf ,_fada ,_geef ,_gdgg float64 ){if _aagde ==0{return 0,0,_gcdea ,_fafde ;};_dgeac :=_gc .Path {Points :[]_gc .Point {_gc .NewPoint (0,0).Rotate (_aagde ),_gc .NewPoint (_gcdea ,0).Rotate (_aagde ),_gc .NewPoint (0,_fafde ).Rotate (_aagde ),_gc .NewPoint (_gcdea ,_fafde ).Rotate (_aagde )}}.GetBoundingBox ();return _dgeac .X ,_dgeac .Y ,_dgeac .Width ,_dgeac .Height ;};

// SetSubtotal sets the subtotal of the invoice.
func (_dda *Invoice )SetSubtotal (value string ){_dda ._aed [1].Value =value };

// SetBorderColor sets border color.
func (_ecee *Rectangle )SetBorderColor (col Color ){_ecee ._gace =_ga .NewPdfColorDeviceRGB (col .ToRGB ());};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_df :=&Block {};_df ._cf =&_gf .ContentStreamOperations {};_df ._dg =_ga .NewPdfPageResources ();_df ._cfe =width ;_df ._gfa =height ;return _df ;};func _cbfe ()*Division {return &Division {_ggac :[]VectorDrawable {}}};

// GetMargins returns the left, right, top, bottom Margins.
func (_aabaf *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aabaf ._cgfg ._dea ,_aabaf ._cgfg ._aaf ,_aabaf ._cgfg ._bdbd ,_aabaf ._cgfg ._bgb ;};

// WriteToFile writes the Creator output to file specified by path.
func (_age *Creator )WriteToFile (outputPath string )error {_egfb ,_cgd :=_ef .Create (outputPath );if _cgd !=nil {return _cgd ;};defer _egfb .Close ();return _age .Write (_egfb );};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_bcbc *TOC )SetLinePageStyle (style TextStyle ){_bcbc ._edde =style };func (_deef *Invoice )newCell (_gbae string ,_bfge InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_bfge ,_gbae };};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_facc []*TextChunk ;_adfe TextStyle ;_fgace TextStyle ;_fgacf TextAlignment ;_bgdg float64 ;_cdec bool ;_gdff float64 ;_edggb bool ;_efcf float64 ;_ebee margins ;_gebe positioning ;_adaec float64 ;_cbad float64 ;_dgff float64 ;_bae float64 ;_edac [][]*TextChunk ;_edfb func (_ceeb *StyledParagraph ,_aabf DrawContext );};type rgbColor struct{_fef ,_eba ,_befb float64 };

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_egbbd int ;_ggag int ;_bcfg int ;_agae []float64 ;_cefdb []float64 ;_agdc float64 ;_bfgf []*TableCell ;_eddd positioning ;_abcgg ,_bgdd float64 ;_cgfg margins ;_aeag bool ;_abfa int ;_eege int ;};func (_cee *Invoice )drawSection (_gcde ,_aagc string )[]*StyledParagraph {var _bgcc []*StyledParagraph ;if _gcde !=""{_ebf :=_afae (_cee ._ddgb );_ebf .SetMargins (0,0,0,5);_ebf .Append (_gcde );_bgcc =append (_bgcc ,_ebf );};if _aagc !=""{_ebec :=_afae (_cee ._ecccg );_ebec .Append (_aagc );_bgcc =append (_bgcc ,_ebec );};return _bgcc ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_egbf *StyledParagraph )Insert (index uint ,text string )*TextChunk {_fccc :=uint (len (_egbf ._facc ));if index > _fccc {index =_fccc ;};_cbdad :=NewTextChunk (text ,_egbf ._adfe );_egbf ._facc =append (_egbf ._facc [:index ],append ([]*TextChunk {_cbdad },_egbf ._facc [index :]...)...);_egbf .wrapText ();return _cbdad ;};

// SetStyleTop sets border style for top side.
func (_bed *border )SetStyleTop (style CellBorderStyle ){_bed ._dgf =style };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_dfee *Chapter )SetIncludeInTOC (includeInTOC bool ){_dfee ._ebb =includeInTOC };

// CreateTableOfContents sets a function to generate table of contents.
func (_abd *Creator )CreateTableOfContents (genTOCFunc func (_afb *TOC )error ){_abd ._efcc =genTOCFunc };func _ggec (_bfcg *_ga .Image )(*Image ,error ){_efgd :=float64 (_bfcg .Width );_edce :=float64 (_bfcg .Height );return &Image {_gdb :_bfcg ,_cddc :_efgd ,_cddg :_edce ,_ffecf :_efgd ,_adege :_edce ,_bbeg :0,_fggb :1.0,_bcdd :_fabc },nil ;};func (_bfdf *Image )makeXObject ()error {_ggf :=_bfdf ._abfb ;if _ggf ==nil {_ggf =_cad .NewFlateEncoder ();};_ebeb ,_ddda :=_ga .NewXObjectImageFromImage (_bfdf ._gdb ,nil ,_ggf );if _ddda !=nil {_d .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ddda );return _ddda ;};_bfdf ._gdcb =_ebeb ;return nil ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_bfgc *Table )SetPos (x ,y float64 ){_bfgc ._eddd =_eeae ;_bfgc ._abcgg =x ;_bfgc ._bgdd =y };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_fggef *TOC )SetLineNumberStyle (style TextStyle ){_fggef ._gdfd =style };

// The Image type is used to draw an image onto PDF.
type Image struct{_gdcb *_ga .XObjectImage ;_gdb *_ga .Image ;_bbeg float64 ;_ffecf ,_adege float64 ;_cddc ,_cddg float64 ;_bcdd positioning ;_bceag HorizontalAlignment ;_cfbf float64 ;_fbdbe float64 ;_fggb float64 ;_afd margins ;_egfe ,_gcbf float64 ;_abfb _cad .StreamEncoder ;};

// SetTotal sets the total of the invoice.
func (_ddff *Invoice )SetTotal (value string ){_ddff ._aagd [1].Value =value };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aafc *Paragraph )SetTextAlignment (align TextAlignment ){_aafc ._fadfa =align };func (_ddbc *List )tableHeight (_cga float64 )float64 {var _feec float64 ;for _ ,_gea :=range _ddbc ._fecab {switch _gffb :=_gea ._cfaca .(type ){case *Paragraph :_bcdfg :=_gffb ;if _bcdfg ._deba {_bcdfg .SetWidth (_cga );};_feec +=_bcdfg .Height ()+_bcdfg ._gfed ._bgb +_bcdfg ._gfed ._bgb ;_feec +=0.5*_bcdfg ._bfgb *_bcdfg ._agcd ;case *StyledParagraph :_dbaab :=_gffb ;if _dbaab ._cdec {_dbaab .SetWidth (_cga );};_feec +=_dbaab .Height ()+_dbaab ._ebee ._bdbd +_dbaab ._ebee ._bgb ;_feec +=0.5*_dbaab .getTextHeight ();default:_feec +=_gea ._cfaca .Height ();};};return _feec ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_bbgd *Invoice )AddressStyle ()TextStyle {return _bbgd ._dfbf };func (_bceb positioning )isRelative ()bool {return _bceb ==_fabc };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fecb *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _fecb ._effc [0],_fecb ._effc [1]};

// GetOptimizer returns current PDF optimizer.
func (_gafd *Creator )GetOptimizer ()_ga .Optimizer {return _gafd ._gada };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// NewImage create a new image from a unidoc image (model.Image).
func (_bdde *Creator )NewImage (img *_ga .Image )(*Image ,error ){return _ggec (img )};func (_gcf *Invoice )generateHeaderBlocks (_gcfg DrawContext )([]*Block ,DrawContext ,error ){_cdb :=_afae (_gcf ._fcab );_cdb .SetEnableWrap (true );_cdb .Append (_gcf ._adbee );_acdb :=_fcfa (2);if _gcf ._daaa !=nil {_ggfc :=_acdb .NewCell ();_ggfc .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_ggfc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ggfc .SetIndent (0);_ggfc .SetContent (_gcf ._daaa );_gcf ._daaa .ScaleToHeight (_cdb .Height ()+20);}else {_acdb .SkipCells (1);};_fbgff :=_acdb .NewCell ();_fbgff .SetHorizontalAlignment (CellHorizontalAlignmentRight );_fbgff .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fbgff .SetContent (_cdb );return _acdb .GeneratePageBlocks (_gcfg );};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_begc *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _caeb []*Block ;_agde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egbg :=ctx ;if _begc ._eddd .isAbsolute (){ctx .X =_begc ._abcgg ;ctx .Y =_begc ._bgdd ;}else {ctx .X +=_begc ._cgfg ._dea ;ctx .Y +=_begc ._cgfg ._bdbd ;ctx .Width -=_begc ._cgfg ._dea +_begc ._cgfg ._aaf ;ctx .Height -=_begc ._cgfg ._bgb +_begc ._cgfg ._bdbd ;};_cgeb :=ctx .Width ;_gbcde :=ctx .X ;_aecgce :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._bgb ;_decd :=ctx .Height ;_ggabg :=0;_ebcab :=-1;_gefc :=-1;for _eega ,_fcdd :=range _begc ._bfgf {_fbaba :=float64 (0.0);for _gacgc :=0;_gacgc < _fcdd ._cbac ;_gacgc ++{_fbaba +=_begc ._agae [_fcdd ._eggg +_gacgc -1];};_gadf :=float64 (0.0);for _addd :=0;_addd < _fcdd ._eggg -1;_addd ++{_gadf +=_begc ._agae [_addd ]*_cgeb ;};_adbaa :=float64 (0.0);for _eagb :=_ggabg ;_eagb < _fcdd ._aaca -1;_eagb ++{_adbaa +=_begc ._cefdb [_eagb ];};_deeg :=_fbaba *_cgeb ;_edbb :=float64 (0.0);for _afbg :=0;_afbg < _fcdd ._cccb ;_afbg ++{_edbb +=_begc ._cefdb [_fcdd ._aaca +_afbg -1];};if _begc ._aeag {if _fcdd ._aaca >=_begc ._abfa &&_fcdd ._aaca <=_begc ._eege {if _ebcab < 0{_ebcab =_eega ;};_gefc =_eega ;};};switch _dcgc :=_fcdd ._gbgf .(type ){case *Paragraph :_ccbf :=_dcgc ;if _ccbf ._deba {_ccbf .SetWidth (_deeg -_fcdd ._ddcf );};_gab :=_ccbf .Height ()+_ccbf ._gfed ._bgb +_ccbf ._gfed ._bgb ;_gab +=0.5*_ccbf ._bfgb *_ccbf ._agcd ;if _gab > _edbb {_gfdg :=_gab -_edbb ;_begc ._cefdb [_fcdd ._aaca +_fcdd ._cccb -2]+=_gfdg ;};case *StyledParagraph :_cbgc :=_dcgc ;if _cbgc ._cdec {_cbgc .SetWidth (_deeg -_fcdd ._ddcf );};_fbfg :=_cbgc .Height ()+_cbgc ._ebee ._bdbd +_cbgc ._ebee ._bgb ;_fbfg +=0.5*_cbgc .getTextHeight ();if _fbfg > _edbb {_cgef :=_fbfg -_edbb ;_begc ._cefdb [_fcdd ._aaca +_fcdd ._cccb -2]+=_cgef ;};case *Image :_ebebf :=_dcgc ;_ebda :=_ebebf .Height ()+_ebebf ._afd ._bdbd +_ebebf ._afd ._bgb ;if _ebda > _edbb {_bdgc :=_ebda -_edbb ;_begc ._cefdb [_fcdd ._aaca +_fcdd ._cccb -2]+=_bdgc ;};case *Table :_edcg :=_dcgc ;_ecega :=_edcg .Height ()+_edcg ._cgfg ._bdbd +_edcg ._cgfg ._bgb ;if _ecega > _edbb {_bdaeb :=_ecega -_edbb ;_begc ._cefdb [_fcdd ._aaca +_fcdd ._cccb -2]+=_bdaeb ;};case *List :_ffca :=_dcgc ;_aecc :=_ffca .tableHeight (_deeg -_fcdd ._ddcf )+_ffca ._gbb ._bdbd +_ffca ._gbb ._bgb ;if _aecc > _edbb {_gacc :=_aecc -_edbb ;_begc ._cefdb [_fcdd ._aaca +_fcdd ._cccb -2]+=_gacc ;};case *Division :_agfc :=_dcgc ;_dbebb :=ctx ;_dbebb .X =_gadf ;_dbebb .Y =_adbaa ;_dbebb .Width =_deeg ;_dedb ,_ ,_adce :=_agfc .GeneratePageBlocks (_dbebb );if _adce !=nil {return nil ,ctx ,_adce ;};if len (_dedb )> 1{_cgbcb :=_dbebb .Height -_edbb ;if _cgbcb > _edbb {_ffbb :=_cgbcb -_edbb ;_begc ._cefdb [_fcdd ._aaca +_fcdd ._cccb -2]+=_ffbb ;};};_cbfg :=_agfc .Height ()+_agfc ._ecb ._bdbd +_agfc ._ecb ._bgb ;if _cbfg > _edbb {_bfea :=_cbfg -_edbb ;_begc ._cefdb [_fcdd ._aaca +_fcdd ._cccb -2]+=_bfea ;};};};var _bcbg bool ;var _gggbe ,_geaa int ;for _edfda :=0;_edfda < len (_begc ._bfgf );_edfda ++{_ebaed :=_begc ._bfgf [_edfda ];_cefag :=float64 (0.0);for _ffef :=0;_ffef < _ebaed ._cbac ;_ffef ++{_cefag +=_begc ._agae [_ebaed ._eggg +_ffef -1];};_gbef :=float64 (0.0);for _cecf :=0;_cecf < _ebaed ._eggg -1;_cecf ++{_gbef +=_begc ._agae [_cecf ]*_cgeb ;};_ddaa :=float64 (0.0);for _aafe :=_ggabg ;_aafe < _ebaed ._aaca -1;_aafe ++{_ddaa +=_begc ._cefdb [_aafe ];};_gbfb :=_cefag *_cgeb ;_efbc :=float64 (0.0);for _ageb :=0;_ageb < _ebaed ._cccb ;_ageb ++{_efbc +=_begc ._cefdb [_ebaed ._aaca +_ageb -1];};ctx .Height =_decd -_ddaa ;if _efbc > ctx .Height {_caeb =append (_caeb ,_agde );_agde =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbcde =ctx .Margins ._dea ;_aecgce =ctx .Margins ._bdbd ;ctx .Height =ctx .PageHeight -ctx .Margins ._bdbd -ctx .Margins ._bgb ;ctx .Page ++;_decd =ctx .Height ;_ggabg =_ebaed ._aaca -1;_ddaa =0;if _begc ._aeag &&_ebcab >=0{_gggbe =_edfda ;_edfda =_ebcab -1;_geaa =_ggabg ;_ggabg =_begc ._abfa -1;_bcbg =true ;continue ;};};ctx .Width =_gbfb ;ctx .X =_gbcde +_gbef ;ctx .Y =_aecgce +_ddaa ;_gfbd :=_gbf (ctx .X ,ctx .Y ,_gbfb ,_efbc );if _ebaed ._efgg !=nil {_fcdf :=_ebaed ._efgg .R ();_edab :=_ebaed ._efgg .G ();_becaf :=_ebaed ._efgg .B ();_gfbd .SetFillColor (ColorRGBFromArithmetic (_fcdf ,_edab ,_becaf ));};_gfbd .LineStyle =_ebaed ._bbeda ;_gfbd ._cbg =_ebaed ._abfd ;_gfbd ._gga =_ebaed ._becc ;_gfbd ._dgf =_ebaed ._cgfc ;_gfbd ._gcaa =_ebaed ._aggf ;if _ebaed ._aeef !=nil {_gfbd .SetColorLeft (ColorRGBFromArithmetic (_ebaed ._aeef .R (),_ebaed ._aeef .G (),_ebaed ._aeef .B ()));};if _ebaed ._cgcdc !=nil {_gfbd .SetColorBottom (ColorRGBFromArithmetic (_ebaed ._cgcdc .R (),_ebaed ._cgcdc .G (),_ebaed ._cgcdc .B ()));};if _ebaed ._cgcba !=nil {_gfbd .SetColorRight (ColorRGBFromArithmetic (_ebaed ._cgcba .R (),_ebaed ._cgcba .G (),_ebaed ._cgcba .B ()));};if _ebaed ._adeb !=nil {_gfbd .SetColorTop (ColorRGBFromArithmetic (_ebaed ._adeb .R (),_ebaed ._adeb .G (),_ebaed ._adeb .B ()));};_gfbd .SetWidthBottom (_ebaed ._ecaa );_gfbd .SetWidthLeft (_ebaed ._baeg );_gfbd .SetWidthRight (_ebaed ._fgcc );_gfbd .SetWidthTop (_ebaed ._bbgae );_cbaa :=_agde .Draw (_gfbd );if _cbaa !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cbaa );};if _ebaed ._gbgf !=nil {_beeg :=_ebaed ._gbgf .Width ();_aece :=_ebaed ._gbgf .Height ();_bgcbb :=0.0;switch _fcage :=_ebaed ._gbgf .(type ){case *Paragraph :if _fcage ._deba {_beeg =_fcage .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _fcage ._cdec {_beeg =_fcage .getMaxLineWidth ()/1000.0;};_efba ,_deab :=_fcage .getLineHeight (0);if len (_fcage ._edac )==1{_aece =_efba ;}else {_aece =_aece -_deab +_efba ;};_bgcbb =_efba -_deab ;switch _ebaed ._aafca {case CellVerticalAlignmentTop :_bgcbb +=_efba *0.5;case CellVerticalAlignmentBottom :_bgcbb -=_efba *0.5;};case *Table :_beeg =_gbfb ;case *List :_beeg =_gbfb ;};switch _ebaed ._deaag {case CellHorizontalAlignmentLeft :ctx .X +=_ebaed ._ddcf ;ctx .Width -=_ebaed ._ddcf ;case CellHorizontalAlignmentCenter :_gaac :=_gbfb -_beeg ;if _gaac > 0{ctx .X +=_gaac /2;ctx .Width -=_gaac /2;};case CellHorizontalAlignmentRight :if _gbfb > _beeg {ctx .X =ctx .X +_gbfb -_beeg -_ebaed ._ddcf ;ctx .Width -=_ebaed ._ddcf ;};};ctx .Y +=_bgcbb ;switch _ebaed ._aafca {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_gbea :=_efbc -_aece ;if _gbea > 0{ctx .Y +=_gbea /2;ctx .Height -=_gbea /2;};case CellVerticalAlignmentBottom :if _efbc > _aece {ctx .Y =ctx .Y +_efbc -_aece ;ctx .Height =_efbc ;};};_cedce :=_agde .DrawWithContext (_ebaed ._gbgf ,ctx );if _cedce !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cedce );};ctx .Y -=_bgcbb ;};ctx .Y +=_efbc ;ctx .Height -=_efbc ;if _bcbg &&_edfda +1> _gefc {_aecgce +=_ddaa +_efbc ;_decd -=_efbc +_ddaa ;_ggabg =_geaa ;_edfda =_gggbe -1;_bcbg =false ;};};_caeb =append (_caeb ,_agde );if _begc ._eddd .isAbsolute (){return _caeb ,_egbg ,nil ;};ctx .X =_egbg .X ;ctx .Width =_egbg .Width ;ctx .Y +=_begc ._cgfg ._bgb ;ctx .Height -=_begc ._cgfg ._bgb ;return _caeb ,ctx ,nil ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_gagb *Invoice )TitleStyle ()TextStyle {return _gagb ._fcab };func _gbec (_afabb *_ef .File )([]*_ga .PdfPage ,error ){_eeeb ,_ecbgad :=_ga .NewPdfReader (_afabb );if _ecbgad !=nil {return nil ,_ecbgad ;};_bbbea ,_ecbgad :=_eeeb .GetNumPages ();if _ecbgad !=nil {return nil ,_ecbgad ;};var _cbcdd []*_ga .PdfPage ;for _cbfa :=0;_cbfa < _bbbea ;_cbfa ++{_dfefa ,_dbcfd :=_eeeb .GetPage (_cbfa +1);if _dbcfd !=nil {return nil ,_dbcfd ;};_cbcdd =append (_cbcdd ,_dfefa );};return _cbcdd ,nil ;};func (_feff *Creator )getActivePage ()*_ga .PdfPage {if _feff ._gafg ==nil {if len (_feff ._edg )==0{return nil ;};return _feff ._edg [len (_feff ._edg )-1];};return _feff ._gafg ;};var PPI float64 =72;

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_fadg []_gc .CubicBezierCurve ;FillEnabled bool ;_egc *_ga .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_eaddd *_ga .PdfColorDeviceRGB ;};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_bcdc *Division )Width ()float64 {return 0};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_dabfa *Invoice )InfoLines ()[][2]*InvoiceCell {_fddf :=[][2]*InvoiceCell {_dabfa ._effc ,_dabfa ._babe ,_dabfa ._bac };return append (_fddf ,_dabfa ._eaf ...);};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_fee *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_fee ._geeg ._dea =left ;_fee ._geeg ._aaf =right ;_fee ._geeg ._bdbd =top ;_fee ._geeg ._bgb =bottom ;};func (_fabf *TOCLine )prepareParagraph (_deaf *StyledParagraph ,_baee DrawContext ){_debf :=_fabf .Title .Text ;if _fabf .Number .Text !=""{_debf ="\u0020"+_debf ;};_debf +="\u0020";_dcgb :=_fabf .Page .Text ;if _dcgb !=""{_dcgb ="\u0020"+_dcgb ;};_deaf ._facc =[]*TextChunk {{Text :_fabf .Number .Text ,Style :_fabf .Number .Style ,_gbbg :_fabf .getLineLink ()},{Text :_debf ,Style :_fabf .Title .Style ,_gbbg :_fabf .getLineLink ()},{Text :_dcgb ,Style :_fabf .Page .Style ,_gbbg :_fabf .getLineLink ()}};_deaf .wrapText ();_deedd :=len (_deaf ._edac );if _deedd ==0{return ;};_ggca :=_baee .Width *1000-_deaf .getTextLineWidth (_deaf ._edac [_deedd -1]);_baddg :=_deaf .getTextLineWidth ([]*TextChunk {&_fabf .Separator });_ecfb :=int (_ggca /_baddg );_gfcf :=_ca .Repeat (_fabf .Separator .Text ,_ecfb );_ddfged :=_fabf .Separator .Style ;_bagg :=_deaf .Insert (2,_gfcf );_bagg .Style =_ddfged ;_bagg ._gbbg =_fabf .getLineLink ();_ggca =_ggca -float64 (_ecfb )*_baddg ;if _ggca > 500{_afgdb ,_eaefd :=_ddfged .Font .GetRuneMetrics (' ');if _eaefd &&_ggca > _afgdb .Wx {_bddee :=int (_ggca /_afgdb .Wx );if _bddee > 0{_dfgf :=_ddfged ;_dfgf .FontSize =1;_bagg =_deaf .Insert (2,_ca .Repeat ("\u0020",_bddee ));_bagg .Style =_dfgf ;_bagg ._gbbg =_fabf .getLineLink ();};};};};

// SetLineHeight sets the line height (1.0 default).
func (_ebcb *StyledParagraph )SetLineHeight (lineheight float64 ){_ebcb ._bgdg =lineheight };

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_cafc *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _dcee (xc ,yc ,width ,height );};

// SkipRows skips over a specified number of rows in the table.
func (_acef *Table )SkipRows (num int ){_ecgef :=num *_acef ._ggag -1;if _ecgef < 0{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_acef ._bcfg +=_ecgef ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cbdb *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_def :=[2]*InvoiceCell {_cbdb .newCell (description ,_cbdb ._cdeg ),_cbdb .newCell (value ,_cbdb ._cdeg )};_cbdb ._eaf =append (_cbdb ._eaf ,_def );return _def [0],_def [1];};

// SetStyleBottom sets border style for bottom side.
func (_bga *border )SetStyleBottom (style CellBorderStyle ){_bga ._gcaa =style };func _fgegb (_ffcee *_ga .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_ffcee ,FontSize :10};};func _fed (_cacb string )(*Image ,error ){_dabd ,_cebf :=_ef .Open (_cacb );if _cebf !=nil {return nil ,_cebf ;};defer _dabd .Close ();_ggae ,_cebf :=_ga .ImageHandling .Read (_dabd );if _cebf !=nil {_d .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cebf );return nil ,_cebf ;};return _ggec (_ggae );};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_dcceb *TOC )SetLineLevelOffset (levelOffset float64 ){_dcceb ._cdeee =levelOffset };

// Heading returns the heading component of the table of contents.
func (_gfedf *TOC )Heading ()*StyledParagraph {return _gfedf ._gcgd };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_abce *Invoice )SetNoteStyle (style TextStyle ){_abce ._ecccg =style };

// SetBackgroundColor sets the cell's background color.
func (_bgdf *TableCell )SetBackgroundColor (col Color ){_bgdf ._efgg =_ga .NewPdfColorDeviceRGB (col .ToRGB ());};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_egec *List )Add (item VectorDrawable )(*TextChunk ,error ){_abgdc :=&listItem {_cfaca :item ,_ggacf :_egec ._dbba };switch _bbdg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _bbdg ._dbce {_bbdg ._bcbf =15;};default:return nil ,_c .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_egec ._fecab =append (_egec ._fecab ,_abgdc );return &_abgdc ._ggacf ,nil ;};

// NewCell returns a new invoice table cell.
func (_abgd *Invoice )NewCell (value string )*InvoiceCell {return _abgd .newCell (value ,_abgd .NewCellProps ());};func (_effg *Paragraph )wrapText ()error {if !_effg ._deba ||int (_effg ._cebe )<=0{_effg ._cae =[]string {_effg ._dgea };return nil ;};_ebebe :=NewTextChunk (_effg ._dgea ,TextStyle {Font :_effg ._ffgce ,FontSize :_effg ._bfgb });_cadf ,_cfcc :=_ebebe .Wrap (_effg ._cebe );if _cfcc !=nil {return _cfcc ;};_effg ._cae =_cadf ;return nil ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_daeb *TOCLine )SetStyle (style TextStyle ){_daeb .Number .Style =style ;_daeb .Title .Style =style ;_daeb .Separator .Style =style ;_daeb .Page .Style =style ;};

// CurRow returns the currently active cell's row number.
func (_daba *Table )CurRow ()int {_gacgf :=(_daba ._bcfg -1)/_daba ._ggag +1;return _gacgf };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_fdeg *Creator )RotateDeg (angleDeg int64 )error {_gbc :=_fdeg .getActivePage ();if _gbc ==nil {_d .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_d .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _aada int64 ;if _gbc .Rotate !=nil {_aada =*(_gbc .Rotate );};_aada +=angleDeg ;_gbc .Rotate =&_aada ;return nil ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_aec *Block )Draw (d Drawable )error {_egf :=DrawContext {};_egf .Width =_aec ._cfe ;_egf .Height =_aec ._gfa ;_egf .PageWidth =_aec ._cfe ;_egf .PageHeight =_aec ._gfa ;_egf .X =0;_egf .Y =0;_eae ,_ ,_aee :=d .GeneratePageBlocks (_egf );if _aee !=nil {return _aee ;};if len (_eae )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_gd :=range _eae {if _bcg :=_aec .mergeBlocks (_gd );_bcg !=nil {return _bcg ;};};return nil ;};func (_cg *Block )duplicate ()*Block {_cde :=&Block {};*_cde =*_cg ;_abb :=_gf .ContentStreamOperations {};for _ ,_ee :=range *_cg ._cf {_abb =append (_abb ,_ee );};_cde ._cf =&_abb ;return _cde ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_egcb *Image )ConvertToBinary ()error {return _egcb ._gdb .ConvertToBinary ()};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_gaeda *TOCLine )SetLink (page int64 ,x ,y float64 ){_gaeda ._ffbee =x ;_gaeda ._geeb =y ;_gaeda ._dged =page ;_gfde :=_gaeda ._gfeg ._fgace .Color ;_gaeda .Number .Style .Color =_gfde ;_gaeda .Title .Style .Color =_gfde ;_gaeda .Separator .Style .Color =_gfde ;_gaeda .Page .Style .Color =_gfde ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_bdggd *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_bdggd ._deaag =halign ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_gfeg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_egdc float64 ;_cagc uint ;_aedde float64 ;_efbe positioning ;_ffbee float64 ;_geeb float64 ;_dged int64 ;};

// SetBorderColor sets the border color.
func (_ecbg *Ellipse )SetBorderColor (col Color ){_ecbg ._gddg =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetWidthTop sets border width for top.
func (_faea *border )SetWidthTop (bw float64 ){_faea ._beed =bw };

// CreateFrontPage sets a function to generate a front Page.
func (_ddcd *Creator )CreateFrontPage (genFrontPageFunc func (_geec FrontpageFunctionArgs )){_ddcd ._bdbe =genFrontPageFunc ;};

// SetBorderColor sets the cell's border color.
func (_ffbe *TableCell )SetBorderColor (col Color ){_ffbe ._aeef =_ga .NewPdfColorDeviceRGB (col .ToRGB ());_ffbe ._cgcdc =_ga .NewPdfColorDeviceRGB (col .ToRGB ());_ffbe ._cgcba =_ga .NewPdfColorDeviceRGB (col .ToRGB ());_ffbe ._adeb =_ga .NewPdfColorDeviceRGB (col .ToRGB ());};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_cedg float64 ;_cbag float64 ;_ggfg float64 ;_edcea float64 ;_addeg *_ga .PdfColorDeviceRGB ;_bbgc float64 ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_edg []*_ga .PdfPage ;_dbg map[*_ga .PdfPage ]*Block ;_gafg *_ga .PdfPage ;_egfa PageSize ;_bgac DrawContext ;_ced margins ;_dbag ,_ffd float64 ;_ggdd int ;_bdbe func (_cfbc FrontpageFunctionArgs );_efcc func (_caga *TOC )error ;_bcgf func (_aff *Block ,_dde HeaderFunctionArgs );_gde func (_cbc *Block ,_ddg FooterFunctionArgs );_bbg func (_cbaf *_ga .PdfWriter )error ;_gbdg bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_dec *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gfd *_ga .Outline ;_fgab *_ga .PdfOutlineTreeNode ;_cgg *_ga .PdfAcroForm ;_dccb _cad .PdfObject ;_gada _ga .Optimizer ;_eag []*_ga .PdfFont ;_acdd *_ga .PdfFont ;_dgfc *_ga .PdfFont ;};

// Width returns the cell's width based on the input draw context.
func (_dcce *TableCell )Width (ctx DrawContext )float64 {_bfec :=float64 (0.0);for _cgbd :=0;_cgbd < _dcce ._cbac ;_cgbd ++{_bfec +=_dcce ._gegdf ._agae [_dcce ._eggg +_cgbd -1];};_aeec :=ctx .Width *_bfec ;return _aeec ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_ceb *Creator )Draw (d Drawable )error {if _ceb .getActivePage ()==nil {_ceb .NewPage ();};_dcbb ,_cfef ,_bage :=d .GeneratePageBlocks (_ceb ._bgac );if _bage !=nil {return _bage ;};for _aadd ,_bbae :=range _dcbb {if _aadd > 0{_ceb .NewPage ();};_bbgf :=_ceb .getActivePage ();if _agaf ,_edfd :=_ceb ._dbg [_bbgf ];_edfd {if _cfab :=_agaf .mergeBlocks (_bbae );_cfab !=nil {return _cfab ;};if _dgcc :=_gca (_bbae ._dg ,_agaf ._dg );_dgcc !=nil {return _dgcc ;};}else {_ceb ._dbg [_bbgf ]=_bbae ;};};_ceb ._bgac .X =_cfef .X ;_ceb ._bgac .Y =_cfef .Y ;_ceb ._bgac .Height =_cfef .PageHeight -_cfef .Y -_cfef .Margins ._bgb ;return nil ;};func (_caggg *Paragraph )getMaxLineWidth ()float64 {if _caggg ._cae ==nil ||len (_caggg ._cae )==0{_caggg .wrapText ();};var _acca float64 ;for _ ,_fcdgg :=range _caggg ._cae {_cbff :=_caggg .getTextLineWidth (_fcdgg );if _cbff > _acca {_acca =_cbff ;};};return _acca ;};

// SetMargins sets the Paragraph's margins.
func (_fdfa *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_fdfa ._ebee ._dea =left ;_fdfa ._ebee ._aaf =right ;_fdfa ._ebee ._bdbd =top ;_fdfa ._ebee ._bgb =bottom ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_cdde *Creator )MoveTo (x ,y float64 ){_cdde ._bgac .X =x ;_cdde ._bgac .Y =y };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_bfcc *Creator )NewTextStyle ()TextStyle {return _fceaf (_bfcc ._acdd )};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_bcfcc *TOC )SetHeading (text string ,style TextStyle ){_fbdc :=_bcfcc .Heading ();_fbdc .Reset ();_fbdff :=_fbdc .Append (text );_fbdff .Style =style ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_aeea *Invoice )SetBuyerAddress (address *InvoiceAddress ){_aeea ._deea =address };func _gbf (_cfbb ,_bff ,_agc ,_fcge float64 )*border {_ccb :=&border {};_ccb ._cfd =_cfbb ;_ccb ._fbe =_bff ;_ccb ._fdg =_agc ;_ccb ._eec =_fcge ;_ccb ._fcc =_ga .NewPdfColorDeviceRGB (0,0,0);_ccb ._cbb =_ga .NewPdfColorDeviceRGB (0,0,0);_ccb ._gec =_ga .NewPdfColorDeviceRGB (0,0,0);_ccb ._bgcb =_ga .NewPdfColorDeviceRGB (0,0,0);_ccb ._beed =0;_ccb ._ebca =0;_ccb ._edc =0;_ccb ._fac =0;_ccb .LineStyle =_gc .LineStyleSolid ;return _ccb ;};

// SetBorderColor sets the border color for the path.
func (_ccce *FilledCurve )SetBorderColor (color Color ){_ccce ._eaddd =_ga .NewPdfColorDeviceRGB (color .ToRGB ());};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_bccc *List )Marker ()*TextChunk {return &_bccc ._dbba };

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_bbd *Image )SetMargins (left ,right ,top ,bottom float64 ){_bbd ._afd ._dea =left ;_bbd ._afd ._aaf =right ;_bbd ._afd ._bdbd =top ;_bbd ._afd ._bgb =bottom ;};func (_dfce *Invoice )generateNoteBlocks (_ecgbc DrawContext )([]*Block ,DrawContext ,error ){_geb :=_cbfe ();_eafd :=append ([][2]string {_dfce ._aea ,_dfce ._agge },_dfce ._fddg ...);for _ ,_cfba :=range _eafd {if _cfba [1]!=""{_ffda :=_dfce .drawSection (_cfba [0],_cfba [1]);for _ ,_gfgd :=range _ffda {_geb .Add (_gfgd );};_ffce :=_afae (_dfce ._dfdf );_ffce .SetMargins (0,0,10,0);_geb .Add (_ffce );};};return _geb .GeneratePageBlocks (_ecgbc );};

// SetBorderWidth sets the border width.
func (_egcg *Rectangle )SetBorderWidth (bw float64 ){_egcg ._eaba =bw };

// CurCol returns the currently active cell's column number.
func (_bcdda *Table )CurCol ()int {_cefg :=(_bcdda ._bcfg -1)%(_bcdda ._ggag )+1;return _cefg };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_deefa float64 ;_dagf float64 ;_bcgfb float64 ;_ffbf float64 ;_fceg *_ga .PdfColorDeviceRGB ;_gace *_ga .PdfColorDeviceRGB ;_eaba float64 ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_gcgd *StyledParagraph ;_aaae []*TOCLine ;_gdfd TextStyle ;_bgge TextStyle ;_afac TextStyle ;_edde TextStyle ;_cgfdf string ;_cdeee float64 ;_edda margins ;_ggad positioning ;_cabfe TextStyle ;_fbgc bool ;};

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_g .Max (_g .Min (r ,1.0),0.0);g =_g .Max (_g .Min (g ,1.0),0.0);b =_g .Max (_g .Min (b ,1.0),0.0);_eaegg :=rgbColor {};_eaegg ._fef =r ;_eaegg ._eba =g ;_eaegg ._befb =b ;return _eaegg ;};func (_bceaf *Creator )setActivePage (_bdbb *_ga .PdfPage ){_bceaf ._gafg =_bdbb };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_ace *Block )SetMargins (left ,right ,top ,bottom float64 ){_ace ._abf ._dea =left ;_ace ._abf ._aaf =right ;_ace ._abf ._bdbd =top ;_ace ._abf ._bgb =bottom ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_dgea string ;_ffgce *_ga .PdfFont ;_bfgb float64 ;_agcd float64 ;_cebc _ga .PdfColorDeviceRGB ;_fadfa TextAlignment ;_deba bool ;_cebe float64 ;_eggd bool ;_beeef float64 ;_gfed margins ;_decc positioning ;_begf float64 ;_acfb float64 ;_dcae ,_gdfa float64 ;_cae []string ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};func (_cfbcb *Paragraph )getTextWidth ()float64 {_egfbab :=0.0;for _ ,_acac :=range _cfbcb ._dgea {if _acac =='\u000A'{continue ;};_beaab ,_efdb :=_cfbcb ._ffgce .GetRuneMetrics (_acac );if !_efdb {_d .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_acac ,_acac );return -1;};_egfbab +=_cfbcb ._bfgb *_beaab .Wx ;};return _egfbab ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_bacb *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbeb :=ctx ;var _bcffa []*Block ;_gcaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bacb ._gebe .isRelative (){ctx .X +=_bacb ._ebee ._dea ;ctx .Y +=_bacb ._ebee ._bdbd ;ctx .Width -=_bacb ._ebee ._dea +_bacb ._ebee ._aaf ;ctx .Height -=_bacb ._ebee ._bdbd +_bacb ._ebee ._bgb ;_bacb .SetWidth (ctx .Width );}else {if int (_bacb ._gdff )<=0{_bacb .SetWidth (_bacb .getTextWidth ());};ctx .X =_bacb ._adaec ;ctx .Y =_bacb ._cbad ;};if _bacb ._edfb !=nil {_bacb ._edfb (_bacb ,ctx );};if _ecgd :=_bacb .wrapText ();_ecgd !=nil {return nil ,ctx ,_ecgd ;};_ggbc :=_bacb ._edac ;for {_degg ,_fbacf ,_ebff :=_fagf (_gcaf ,_bacb ,_ggbc ,ctx );if _ebff !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebff );return nil ,ctx ,_ebff ;};ctx =_degg ;_bcffa =append (_bcffa ,_gcaf );if _ggbc =_fbacf ;len (_fbacf )==0{break ;};_gcaf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_degg =ctx ;_degg .Y =ctx .Margins ._bdbd ;_degg .X =ctx .Margins ._dea +_bacb ._ebee ._dea ;_degg .Height =ctx .PageHeight -ctx .Margins ._bdbd -ctx .Margins ._bgb -_bacb ._ebee ._bgb ;_degg .Width =ctx .PageWidth -ctx .Margins ._dea -ctx .Margins ._aaf -_bacb ._ebee ._dea -_bacb ._ebee ._aaf ;ctx =_degg ;};if _bacb ._gebe .isRelative (){ctx .X -=_bacb ._ebee ._dea ;ctx .Width =_dbeb .Width ;return _bcffa ,ctx ,nil ;};return _bcffa ,_dbeb ,nil ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetOpacity sets opacity for Image.
func (_dcd *Image )SetOpacity (opacity float64 ){_dcd ._fggb =opacity };func _fagf (_fcecf *Block ,_cgfe *StyledParagraph ,_abgdf [][]*TextChunk ,_gbdf DrawContext )(DrawContext ,[][]*TextChunk ,error ){_cbe :=1;_ggaeg :=_cad .PdfObjectName (_ab .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cbe ));for _fcecf ._dg .HasFontByName (_ggaeg ){_cbe ++;_ggaeg =_cad .PdfObjectName (_ab .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cbe ));};_gdce :=_fcecf ._dg .SetFontByName (_ggaeg ,_cgfe ._adfe .Font .ToPdfObject ());if _gdce !=nil {return _gbdf ,nil ,_gdce ;};_cbe ++;_bbed :=_ggaeg ;_dgce :=_cgfe ._adfe .FontSize ;_cace :=_cgfe ._gebe .isRelative ();var _bdbbf [][]_cad .PdfObjectName ;var _cebcd float64 ;var _cddbf [][]*TextChunk ;var _cbee float64 ;for _afab ,_cccf :=range _abgdf {var _cdfg []_cad .PdfObjectName ;var _gegd float64 ;for _ ,_bcgfba :=range _cccf {_dfgb :=_bcgfba .Style ;if _afab ==0&&_dfgb .FontSize > _cebcd {_cebcd =_dfgb .FontSize ;};if _dfgb .FontSize > _gegd {_gegd =_dfgb .FontSize ;};_ggaeg =_cad .PdfObjectName (_ab .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_cbe ));_bfga :=_fcecf ._dg .SetFontByName (_ggaeg ,_dfgb .Font .ToPdfObject ());if _bfga !=nil {return _gbdf ,nil ,_bfga ;};_cdfg =append (_cdfg ,_ggaeg );_cbe ++;};_gegd *=_cgfe ._bgdg ;if _cace &&_cbee +_gegd > _gbdf .Height {_cddbf =_abgdf [_afab :];_abgdf =_abgdf [:_afab ];break ;};_cbee +=_gegd ;_bdbbf =append (_bdbbf ,_cdfg );};_bbgg :=_gf .NewContentCreator ();_bbgg .Add_q ();_gfcc :=_gbdf .PageHeight -_gbdf .Y -_cebcd *_cgfe ._bgdg ;_bbgg .Translate (_gbdf .X ,_gfcc );if _cgfe ._efcf !=0{_bbgg .RotateDeg (_cgfe ._efcf );};_bbgg .Add_BT ();_aaagf :=_gfcc ;for _abdb ,_dfcd :=range _abgdf {_fgee :=_gbdf .X ;if _abdb !=0{_bbgg .Add_Tstar ();};_bfef :=_abdb ==len (_abgdf )-1;var (_cabd float64 ;_fcgb float64 ;_cdgfd float64 ;_fcea uint ;);var _gdae []float64 ;for _ ,_bdcg :=range _dfcd {_fggbc :=&_bdcg .Style ;if _fggbc .FontSize > _fcgb {_fcgb =_fggbc .FontSize ;};_gccb ,_gegg :=_fggbc .Font .GetRuneMetrics (' ');if !_gegg {return _gbdf ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _deaeb uint ;var _abca float64 ;_bggbc :=len (_bdcg .Text );for _fcda ,_ebbda :=range _bdcg .Text {if _ebbda ==' '{_deaeb ++;continue ;};if _ebbda =='\u000A'{continue ;};_fade ,_gdfeb :=_fggbc .Font .GetRuneMetrics (_ebbda );if !_gdfeb {_d .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_ebbda );return _gbdf ,nil ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_abca +=_fggbc .FontSize *_fade .Wx ;if _fcda !=_bggbc -1{_abca +=_fggbc .CharSpacing *1000.0;};};_gdae =append (_gdae ,_abca );_cabd +=_abca ;_cdgfd +=float64 (_deaeb )*_gccb .Wx *_fggbc .FontSize ;_fcea +=_deaeb ;};_fcgb *=_cgfe ._bgdg ;var _ccfea []_cad .PdfObject ;_adcf :=_cgfe ._gdff *1000.0;if _cgfe ._fgacf ==TextAlignmentJustify {if _fcea > 0&&!_bfef {_cdgfd =(_adcf -_cabd )/float64 (_fcea )/_dgce ;};}else if _cgfe ._fgacf ==TextAlignmentCenter {_fcac :=(_adcf -_cabd -_cdgfd )/2;_efde :=_fcac /_dgce ;_ccfea =append (_ccfea ,_cad .MakeFloat (-_efde ));_fgee +=_fcac /1000.0;}else if _cgfe ._fgacf ==TextAlignmentRight {_cbdg :=(_adcf -_cabd -_cdgfd );_deed :=_cbdg /_dgce ;_ccfea =append (_ccfea ,_cad .MakeFloat (-_deed ));_fgee +=_cbdg /1000.0;};if len (_ccfea )> 0{_bbgg .Add_Tf (_bbed ,_dgce ).Add_TL (_dgce *_cgfe ._bgdg ).Add_TJ (_ccfea ...);};for _ggeeb ,_acbe :=range _dfcd {_gaaad :=&_acbe .Style ;_bcdfe ,_egbb ,_cdbd :=_gaaad .Color .ToRGB ();_aefb :=_bbed ;_debe :=_dgce ;_bbgg .Add_Tr (int64 (_gaaad .RenderingMode ));_bbgg .Add_Tc (_gaaad .CharSpacing );if _cgfe ._fgacf !=TextAlignmentJustify ||_bfef {_cfbd ,_abbf :=_gaaad .Font .GetRuneMetrics (' ');if !_abbf {return _gbdf ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_aefb =_bdbbf [_abdb ][_ggeeb ];_debe =_gaaad .FontSize ;_cdgfd =_cfbd .Wx ;};_gfaa :=_gaaad .Font .Encoder ();var _aacb []byte ;for _ ,_acdg :=range _acbe .Text {if _bcdfe =='\u000A'{continue ;};if _acdg ==' '{if len (_aacb )> 0{_bbgg .Add_rg (_bcdfe ,_egbb ,_cdbd ).Add_Tf (_bdbbf [_abdb ][_ggeeb ],_gaaad .FontSize ).Add_TL (_gaaad .FontSize *_cgfe ._bgdg ).Add_TJ ([]_cad .PdfObject {_cad .MakeStringFromBytes (_aacb )}...);_aacb =nil ;};_bbgg .Add_Tf (_aefb ,_debe ).Add_TL (_debe *_cgfe ._bgdg ).Add_TJ ([]_cad .PdfObject {_cad .MakeFloat (-_cdgfd )}...);_gdae [_ggeeb ]+=_cdgfd *_debe ;}else {if _ ,_cccee :=_gfaa .RuneToCharcode (_acdg );!_cccee {_d .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_acdg ,_acdg );continue ;};_aacb =append (_aacb ,_gfaa .Encode (string (_acdg ))...);};};if len (_aacb )> 0{_bbgg .Add_rg (_bcdfe ,_egbb ,_cdbd ).Add_Tf (_bdbbf [_abdb ][_ggeeb ],_gaaad .FontSize ).Add_TL (_gaaad .FontSize *_cgfe ._bgdg ).Add_TJ ([]_cad .PdfObject {_cad .MakeStringFromBytes (_aacb )}...);};_cgcaf :=_gdae [_ggeeb ]/1000.0;if _acbe ._gbbg !=nil {var _cbeg *_cad .PdfObjectArray ;if !_acbe ._agage {switch _fegf :=_acbe ._gbbg .GetContext ().(type ){case *_ga .PdfAnnotationLink :_cbeg =_cad .MakeArray ();_fegf .Rect =_cbeg ;_ggcg ,_dacd :=_fegf .Dest .(*_cad .PdfObjectArray );if _dacd &&_ggcg .Len ()==5{_ccec ,_fbcd :=_ggcg .Get (1).(*_cad .PdfObjectName );if _fbcd &&_ccec .String ()=="\u0058\u0059\u005a"{_bffge ,_effgd :=_cad .GetNumberAsFloat (_ggcg .Get (3));if _effgd ==nil {_ggcg .Set (3,_cad .MakeFloat (_gbdf .PageHeight -_bffge ));};};};};_acbe ._agage =true ;};if _cbeg !=nil {_dfcff :=_gc .NewPoint (_fgee -_gbdf .X ,_aaagf -_gfcc ).Rotate (_cgfe ._efcf );_dfcff .X +=_gbdf .X ;_dfcff .Y +=_gfcc ;_gbeb ,_debae ,_cfff ,_ebdca :=_caae (_cgcaf ,_fcgb ,_cgfe ._efcf );_dfcff .X +=_gbeb ;_dfcff .Y +=_debae ;_cbeg .Clear ();_cbeg .Append (_cad .MakeFloat (_dfcff .X ));_cbeg .Append (_cad .MakeFloat (_dfcff .Y ));_cbeg .Append (_cad .MakeFloat (_dfcff .X +_cfff ));_cbeg .Append (_cad .MakeFloat (_dfcff .Y +_ebdca ));};_fcecf .AddAnnotation (_acbe ._gbbg );};_fgee +=_cgcaf ;_bbgg .Add_Tr (int64 (TextRenderingModeFill ));_bbgg .Add_Tc (0);};_aaagf -=_fcgb ;};_bbgg .Add_ET ();_bbgg .Add_Q ();_ffaf :=_bbgg .Operations ();_ffaf .WrapIfNeeded ();_fcecf .addContents (_ffaf );if _cace {_ddfe :=_cbee +_cgfe ._ebee ._bgb ;_gbdf .Y +=_ddfe ;_gbdf .Height -=_ddfe ;if _gbdf .Inline {_gbdf .X +=_cgfe .Width ()+_cgfe ._ebee ._aaf ;};};return _gbdf ,_cddbf ,nil ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_ceg *Image )ScaleToHeight (h float64 ){_dgbe :=_ceg ._ffecf /_ceg ._adege ;_ceg ._adege =h ;_ceg ._ffecf =h *_dgbe ;};func (_ccgb *FilledCurve )draw (_eeef string )([]byte ,*_ga .PdfRectangle ,error ){_bcbe :=_gc .NewCubicBezierPath ();for _ ,_afgd :=range _ccgb ._fadg {_bcbe =_bcbe .AppendCurve (_afgd );};creator :=_gf .NewContentCreator ();creator .Add_q ();if _ccgb .FillEnabled {creator .Add_rg (_ccgb ._egc .R (),_ccgb ._egc .G (),_ccgb ._egc .B ());};if _ccgb .BorderEnabled {creator .Add_RG (_ccgb ._eaddd .R (),_ccgb ._eaddd .G (),_ccgb ._eaddd .B ());creator .Add_w (_ccgb .BorderWidth );};if len (_eeef )> 1{creator .Add_gs (_cad .PdfObjectName (_eeef ));};_gc .DrawBezierPathWithCreator (_bcbe ,creator );creator .Add_h ();if _ccgb .FillEnabled &&_ccgb .BorderEnabled {creator .Add_B ();}else if _ccgb .FillEnabled {creator .Add_f ();}else if _ccgb .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_gfbba :=_bcbe .GetBoundingBox ();if _ccgb .BorderEnabled {_gfbba .Height +=_ccgb .BorderWidth ;_gfbba .Width +=_ccgb .BorderWidth ;_gfbba .X -=_ccgb .BorderWidth /2;_gfbba .Y -=_ccgb .BorderWidth /2;};_cgdf :=&_ga .PdfRectangle {};_cgdf .Llx =_gfbba .X ;_cgdf .Lly =_gfbba .Y ;_cgdf .Urx =_gfbba .X +_gfbba .Width ;_cgdf .Ury =_gfbba .Y +_gfbba .Height ;return creator .Bytes (),_cgdf ,nil ;};

// RotatedSize returns the width and height of the rotated block.
func (_eac *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_cb ,_ecg :=_caae (_eac ._cfe ,_eac ._gfa ,_eac ._de );return _cb ,_ecg ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_ffbbd *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_bcad ,_gdffe :=_ffbbd .Wrap (width );if _gdffe !=nil {return nil ,_gdffe ;};_dbbab :=int (height /_ffbbd .Style .FontSize );if _dbbab >=len (_bcad ){return nil ,nil ;};_bbbe :="\u000a";_ffbbd .Text =_ca .Replace (_ca .Join (_bcad [:_dbbab ],"\u0020"),_bbbe +"\u0020",_bbbe ,-1);_ggcff :=_ca .Replace (_ca .Join (_bcad [_dbbab :],"\u0020"),_bbbe +"\u0020",_bbbe ,-1);return NewTextChunk (_ggcff ,_ffbbd .Style ),nil ;};

// NewTOC creates a new table of contents.
func (_befc *Creator )NewTOC (title string )*TOC {_geed :=_befc .NewTextStyle ();_geed .Font =_befc ._dgfc ;return _fbcdf (title ,_befc .NewTextStyle (),_geed );};

// MoveY moves the drawing context to absolute position y.
func (_gcae *Creator )MoveY (y float64 ){_gcae ._bgac .Y =y };func (_fag *Block )translate (_ag ,_ffc float64 ){_cdg :=_gf .NewContentCreator ().Translate (_ag ,-_ffc ).Operations ();*_fag ._cf =append (*_cdg ,*_fag ._cf ...);_fag ._cf .WrapIfNeeded ();};

// SetMargins sets the Paragraph's margins.
func (_ecab *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_ecab ._gfed ._dea =left ;_ecab ._gfed ._aaf =right ;_ecab ._gfed ._bdbd =top ;_ecab ._gfed ._bgb =bottom ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fddb *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _fddb ._aed [0],_fddb ._aed [1]};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gcd *Invoice )SetAddressStyle (style TextStyle ){_gcd ._dfbf =style };

// SetDueDate sets the due date of the invoice.
func (_fgbf *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_fgbf ._bac [1].Value =dueDate ;return _fgbf ._bac [0],_fgbf ._bac [1];};

// NewCellProps returns the default properties of an invoice cell.
func (_ecac *Invoice )NewCellProps ()InvoiceCellProps {_facba :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_ecac ._dfdf ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_facba ,BorderColor :_facba ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};type border struct{_cfd float64 ;_fbe float64 ;_fdg float64 ;_eec float64 ;_cba *_ga .PdfColorDeviceRGB ;_gec *_ga .PdfColorDeviceRGB ;_edc float64 ;_cbb *_ga .PdfColorDeviceRGB ;_ebca float64 ;_bgcb *_ga .PdfColorDeviceRGB ;_fac float64 ;_fcc *_ga .PdfColorDeviceRGB ;_beed float64 ;LineStyle _gc .LineStyle ;_cbg CellBorderStyle ;_gga CellBorderStyle ;_dgf CellBorderStyle ;_gcaa CellBorderStyle ;};

// SetPos sets absolute positioning with specified coordinates.
func (_bcae *StyledParagraph )SetPos (x ,y float64 ){_bcae ._gebe =_eeae ;_bcae ._adaec =x ;_bcae ._cbad =y ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_egbe *Invoice )Notes ()(string ,string ){return _egbe ._aea [0],_egbe ._aea [1]};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dgbec *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _dgbec ._babe [0],_dgbec ._babe [1]};

// SetColorLeft sets border color for left.
func (_fgg *border )SetColorLeft (col Color ){_fgg ._gec =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_ggac []VectorDrawable ;_bgga positioning ;_ecb margins ;_fbdb bool ;};

// SkipOver skips over a specified number of rows and cols.
func (_ddeg *Table )SkipOver (rows ,cols int ){_gcdb :=rows *_ddeg ._ggag +cols -1;if _gcdb < 0{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ddeg ._bcfg +=_gcdb ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_gegc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_gegc ._aaae =append (_gegc ._aaae ,line );return line ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_fffc DrawContext )([]*Block ,DrawContext ,error );};func _bdd (_babg string ,_eccg _cad .PdfObject ,_ffee *_ga .PdfPageResources )_cad .PdfObjectName {_gae :=_ca .TrimRightFunc (_ca .TrimSpace (_babg ),func (_egd rune )bool {return _fa .IsNumber (_egd )});if _gae ==""{_gae ="\u0046\u006f\u006e\u0074";};_bef :=0;_fad :=_cad .PdfObjectName (_babg );for {_fab ,_gffg :=_ffee .GetFontByName (_fad );if !_gffg ||_fab ==_eccg {break ;};_bef ++;_fad =_cad .PdfObjectName (_ab .Sprintf ("\u0025\u0073\u0025\u0064",_gae ,_bef ));};return _fad ;};

// SetHeight sets the Image's document height to specified h.
func (_ecag *Image )SetHeight (h float64 ){_ecag ._adege =h };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;};func _dabf (_acdf *Chapter ,_bgfb *TOC ,_ccee *_ga .Outline ,_bdce string ,_fec int ,_daa TextStyle )*Chapter {var _cfgd uint =1;if _acdf !=nil {_cfgd =_acdf ._abge +1;};_acbf :=&Chapter {_abcf :_fec ,_acg :_bdce ,_cfeg :true ,_ebb :true ,_cded :_acdf ,_efaf :_bgfb ,_abfe :_ccee ,_dfg :[]Drawable {},_abge :_cfgd };_dbcg :=_efda (_acbf .headingText (),_daa );_dbcg .SetFont (_daa .Font );_dbcg .SetFontSize (_daa .FontSize );_acbf ._eadd =_dbcg ;return _acbf ;};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_bfcd *Ellipse )GetCoords ()(float64 ,float64 ){return _bfcd ._afg ,_bfcd ._cfcd };

// SellerAddress returns the seller address used in the invoice template.
func (_dacb *Invoice )SellerAddress ()*InvoiceAddress {return _dacb ._fcd };

// SetBorder sets the cell's border style.
func (_aabac *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_aabac ._abfd =CellBorderStyleSingle ;_aabac ._baeg =width ;_aabac ._aggf =CellBorderStyleSingle ;_aabac ._ecaa =width ;_aabac ._becc =CellBorderStyleSingle ;_aabac ._fgcc =width ;_aabac ._cgfc =CellBorderStyleSingle ;_aabac ._bbgae =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_aabac ._abfd =CellBorderStyleDouble ;_aabac ._baeg =width ;_aabac ._aggf =CellBorderStyleDouble ;_aabac ._ecaa =width ;_aabac ._becc =CellBorderStyleDouble ;_aabac ._fgcc =width ;_aabac ._cgfc =CellBorderStyleDouble ;_aabac ._bbgae =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_aabac ._abfd =style ;_aabac ._baeg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_aabac ._aggf =style ;_aabac ._ecaa =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_aabac ._becc =style ;_aabac ._fgcc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_aabac ._cgfc =style ;_aabac ._bbgae =width ;};};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_ccba *Creator )NewStyledParagraph ()*StyledParagraph {return _afae (_ccba .NewTextStyle ())};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dfaab *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _gccf float64 ;var _fea []*StyledParagraph ;for _ ,_aaafc :=range _dfaab ._fecab {_bdgg :=_afae (_dfaab ._acgd );_bdgg .SetEnableWrap (false );_bdgg .SetTextAlignment (TextAlignmentRight );_bdgg .Append (_aaafc ._ggacf .Text ).Style =_aaafc ._ggacf .Style ;_fgeg :=_bdgg .getTextWidth ()/1000.0/ctx .Width ;if _gccf < _fgeg {_gccf =_fgeg ;};_fea =append (_fea ,_bdgg );};_cbda :=_fcfa (2);_cbda .SetColumnWidths (_gccf ,1-_gccf );_cbda .SetMargins (_dfaab ._bcbf ,0,0,0);for _adca ,_fcbd :=range _dfaab ._fecab {_bgbc :=_cbda .NewCell ();_bgbc .SetIndent (0);_bgbc .SetContent (_fea [_adca ]);_bgbc =_cbda .NewCell ();_bgbc .SetIndent (0);_bgbc .SetContent (_fcbd ._cfaca );};return _cbda .GeneratePageBlocks (ctx );};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_ggbd *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aabc :=ctx ;var _fggg []*Block ;_bddg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ggbd ._decc .isRelative (){ctx .X +=_ggbd ._gfed ._dea ;ctx .Y +=_ggbd ._gfed ._bdbd ;ctx .Width -=_ggbd ._gfed ._dea +_ggbd ._gfed ._aaf ;ctx .Height -=_ggbd ._gfed ._bdbd +_ggbd ._gfed ._bgb ;_ggbd .SetWidth (ctx .Width );if _ggbd .Height ()> ctx .Height {_fggg =append (_fggg ,_bddg );_bddg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cefd :=ctx ;_cefd .Y =ctx .Margins ._bdbd ;_cefd .X =ctx .Margins ._dea +_ggbd ._gfed ._dea ;_cefd .Height =ctx .PageHeight -ctx .Margins ._bdbd -ctx .Margins ._bgb -_ggbd ._gfed ._bgb ;_cefd .Width =ctx .PageWidth -ctx .Margins ._dea -ctx .Margins ._aaf -_ggbd ._gfed ._dea -_ggbd ._gfed ._aaf ;ctx =_cefd ;};}else {if int (_ggbd ._cebe )<=0{_ggbd .SetWidth (_ggbd .getTextWidth ());};ctx .X =_ggbd ._begf ;ctx .Y =_ggbd ._acfb ;};ctx ,_cafce :=_gbcg (_bddg ,_ggbd ,ctx );if _cafce !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cafce );return nil ,ctx ,_cafce ;};_fggg =append (_fggg ,_bddg );if _ggbd ._decc .isRelative (){ctx .X -=_ggbd ._gfed ._dea ;ctx .Width =_aabc .Width ;return _fggg ,ctx ,nil ;};return _fggg ,_aabc ,nil ;};func _debde (_adba ,_efaa ,_ggbb ,_cea ,_abda ,_geedc float64 )*Curve {_gef :=&Curve {};_gef ._acbg =_adba ;_gef ._eadc =_efaa ;_gef ._egfad =_ggbb ;_gef ._gcgcg =_cea ;_gef ._dbaa =_abda ;_gef ._bbfe =_geedc ;_gef ._ebdd =_ga .NewPdfColorDeviceRGB (0,0,0);_gef ._ggdb =1.0;return _gef ;};

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_eccgf *Division )Height ()float64 {_bbff :=0.0;_fgec :=0.0;for _ ,_ddfd :=range _eccgf ._ggac {_cdgf ,_gaff :=_ddfd .Width (),_ddfd .Height ();switch _begd :=_ddfd .(type ){case *Paragraph :_dbccc :=_begd ;_cdgf +=_dbccc ._gfed ._dea +_dbccc ._gfed ._aaf ;_gaff +=_dbccc ._gfed ._bdbd +_dbccc ._gfed ._bgb ;case *StyledParagraph :_efd :=_begd ;_cdgf +=_efd ._ebee ._dea +_efd ._ebee ._aaf ;_gaff +=_efd ._ebee ._bdbd +_efd ._ebee ._bgb ;};_bbff +=_gaff ;_fgec =_bbff ;};return _fgec ;};

// SetMargins sets the margins of the paragraph.
func (_gfdc *List )SetMargins (left ,right ,top ,bottom float64 ){_gfdc ._gbb ._dea =left ;_gfdc ._gbb ._aaf =right ;_gfdc ._gbb ._bdbd =top ;_gfdc ._gbb ._bgb =bottom ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_agcg *Image )SetPos (x ,y float64 ){_agcg ._bcdd =_eeae ;_agcg ._cfbf =x ;_agcg ._fbdbe =y };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_dcg *Block )ScaleToHeight (h float64 ){_fb :=h /_dcg ._gfa ;_dcg .Scale (_fb ,_fb )};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_ffec *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _debde (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Rows returns the total number of rows the table has.
func (_debgc *Table )Rows ()int {return _debgc ._egbbd };

// SetDate sets the date of the invoice.
func (_egcd *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_egcd ._babe [1].Value =date ;return _egcd ._babe [0],_egcd ._babe [1];};

// Logo returns the logo of the invoice.
func (_gecc *Invoice )Logo ()*Image {return _gecc ._daaa };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ga .PdfPage )(*Block ,error ){_gfe :=&Block {};_ff ,_ec :=page .GetAllContentStreams ();if _ec !=nil {return nil ,_ec ;};_bf :=_gf .NewContentStreamParser (_ff );_cd ,_ec :=_bf .Parse ();if _ec !=nil {return nil ,_ec ;};_cd .WrapIfNeeded ();_gfe ._cf =_cd ;if page .Resources !=nil {_gfe ._dg =page .Resources ;}else {_gfe ._dg =_ga .NewPdfPageResources ();};_ead ,_ec :=page .GetMediaBox ();if _ec !=nil {return nil ,_ec ;};if _ead .Llx !=0||_ead .Lly !=0{_gfe .translate (-_ead .Llx ,_ead .Lly );};_gfe ._cfe =_ead .Urx -_ead .Llx ;_gfe ._gfa =_ead .Ury -_ead .Lly ;if page .Rotate !=nil {_gfe ._de =-float64 (*page .Rotate );};return _gfe ,nil ;};func _afae (_ecgbd TextStyle )*StyledParagraph {return &StyledParagraph {_facc :[]*TextChunk {},_adfe :_ecgbd ,_fgace :_fgegb (_ecgbd .Font ),_bgdg :1.0,_fgacf :TextAlignmentLeft ,_cdec :true ,_edggb :true ,_efcf :0,_dgff :1,_bae :1,_gebe :_fabc };};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_af *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ae :=_gf .NewContentCreator ();_dc ,_gb :=_af .Width (),_af .Height ();if _af ._ea .isRelative (){_ae .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_gb );}else {_ae .Translate (_af ._eg ,ctx .PageHeight -_af ._gcc -_gb );};_ed :=_gb ;if _af ._de !=0{_ae .Translate (_dc /2,_gb /2);_ae .RotateDeg (_af ._de );_ae .Translate (-_dc /2,-_gb /2);_ ,_ed =_af .RotatedSize ();};if _af ._ea .isRelative (){ctx .Y +=_ed ;};_fg :=_af .duplicate ();_cfa :=append (*_ae .Operations (),*_fg ._cf ...);_cfa .WrapIfNeeded ();_fg ._cf =&_cfa ;return []*Block {_fg },ctx ,nil ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_abcf int ;_acg string ;_eadd *Paragraph ;_dfg []Drawable ;_aab int ;_cfeg bool ;_ebb bool ;_aag positioning ;_adc ,_dbc float64 ;_geeg margins ;_cded *Chapter ;_efaf *TOC ;_abfe *_ga .Outline ;_gfec *_ga .OutlineItem ;_abge uint ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_fecab []*listItem ;_gbb margins ;_dbba TextChunk ;_bcbf float64 ;_dbce bool ;_gagf positioning ;_acgd TextStyle ;};func _abcfa ()*PageBreak {return &PageBreak {}};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_dbgg *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _dbgg ._gdcb ==nil {if _ecdd :=_dbgg .makeXObject ();_ecdd !=nil {return nil ,ctx ,_ecdd ;};};var _gaaf []*Block ;_cdgd :=ctx ;_baag :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dbgg ._bcdd .isRelative (){if _dbgg ._adege > ctx .Height {_gaaf =append (_gaaf ,_baag );_baag =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fbf :=ctx ;_fbf .Y =ctx .Margins ._bdbd ;_fbf .X =ctx .Margins ._dea +_dbgg ._afd ._dea ;_fbf .Height =ctx .PageHeight -ctx .Margins ._bdbd -ctx .Margins ._bgb -_dbgg ._afd ._bgb ;_fbf .Width =ctx .PageWidth -ctx .Margins ._dea -ctx .Margins ._aaf -_dbgg ._afd ._dea -_dbgg ._afd ._aaf ;ctx =_fbf ;}else {ctx .Y +=_dbgg ._afd ._bdbd ;ctx .Height -=_dbgg ._afd ._bdbd +_dbgg ._afd ._bgb ;ctx .X +=_dbgg ._afd ._dea ;ctx .Width -=_dbgg ._afd ._dea +_dbgg ._afd ._aaf ;};}else {ctx .X =_dbgg ._cfbf ;ctx .Y =_dbgg ._fbdbe ;};ctx ,_afcd :=_aged (_baag ,_dbgg ,ctx );if _afcd !=nil {return nil ,ctx ,_afcd ;};_gaaf =append (_gaaf ,_baag );if _dbgg ._bcdd .isAbsolute (){ctx =_cdgd ;}else {ctx .Y +=_dbgg ._afd ._bgb ;ctx .Height -=_dbgg ._afd ._bgb ;};return _gaaf ,ctx ,nil ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_aagdb *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _c .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_aagdb ._aeag =true ;_aagdb ._abfa =startRow ;_aagdb ._eege =endRow ;return nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_bdag *TableCell )SetBorderLineStyle (style _gc .LineStyle ){_bdag ._bbeda =style };

// SetColorTop sets border color for top.
func (_edbg *border )SetColorTop (col Color ){_edbg ._fcc =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_fbcf *Table )NewCell ()*TableCell {return _fbcf .newCell (1)};

// Height returns the total height of all rows.
func (_cfgg *Table )Height ()float64 {_dfdbd :=float64 (0.0);for _ ,_beca :=range _cfgg ._cefdb {_dfdbd +=_beca ;};return _dfdbd ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_fbaab *Line )SetColor (col Color ){_fbaab ._addeg =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_gged *Division )Add (d VectorDrawable )error {_ebdf :=false ;switch d .(type ){case *Paragraph :_ebdf =true ;case *StyledParagraph :_ebdf =true ;case *Image :_ebdf =true ;};if !_ebdf {return _c .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gged ._ggac =append (_gged ._ggac ,d );return nil ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_aafd *StyledParagraph )Height ()float64 {_aafd .wrapText ();var _ececa float64 ;for _ ,_abab :=range _aafd ._edac {var _dbgeg float64 ;for _ ,_fege :=range _abab {_agbcg :=_aafd ._bgdg *_fege .Style .FontSize ;if _agbcg > _dbgeg {_dbgeg =_agbcg ;};};_ececa +=_dbgeg ;};return _ececa ;};func _bcgb (_dddd int64 ,_cfbae ,_acba ,_abaa float64 )*_ga .PdfAnnotation {_cbeb :=_ga .NewPdfAnnotationLink ();_fdec :=_ga .NewBorderStyle ();_fdec .SetBorderWidth (0);_cbeb .BS =_fdec .ToPdfObject ();if _dddd < 0{_dddd =0;};_cbeb .Dest =_cad .MakeArray (_cad .MakeInteger (_dddd ),_cad .MakeName ("\u0058\u0059\u005a"),_cad .MakeFloat (_cfbae ),_cad .MakeFloat (_acba ),_cad .MakeFloat (_abaa ));return _cbeb .PdfAnnotation ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_cbbc *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _cbbc ._cedg ,_cbbc ._cbag ,_cbbc ._ggfg ,_cbbc ._edcea ;};

// GeneratePageBlocks implements drawable interface.
func (_ccg *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aggg :=_ccg ._cfd ;_bffc :=ctx .PageHeight -_ccg ._fbe ;if _ccg ._cba !=nil {_dee :=_gc .Rectangle {Opacity :1.0,X :_ccg ._cfd ,Y :ctx .PageHeight -_ccg ._fbe -_ccg ._eec ,Height :_ccg ._eec ,Width :_ccg ._fdg };_dee .FillEnabled =true ;_dee .FillColor =_ccg ._cba ;_dee .BorderEnabled =false ;_gedd ,_ ,_dff :=_dee .Draw ("");if _dff !=nil {return nil ,ctx ,_dff ;};_dff =_adec .addContentsByString (string (_gedd ));if _dff !=nil {return nil ,ctx ,_dff ;};};_geg :=_ccg ._beed ;_aba :=_ccg ._ebca ;_edd :=_ccg ._edc ;_eccc :=_ccg ._fac ;_cfg :=_ccg ._beed ;if _ccg ._dgf ==CellBorderStyleDouble {_cfg +=2*_geg ;};_bfg :=_ccg ._ebca ;if _ccg ._gcaa ==CellBorderStyleDouble {_bfg +=2*_aba ;};_ecdb :=_ccg ._edc ;if _ccg ._cbg ==CellBorderStyleDouble {_ecdb +=2*_edd ;};_bgg :=_ccg ._fac ;if _ccg ._gga ==CellBorderStyleDouble {_bgg +=2*_eccc ;};if _ccg ._beed !=0{_abg :=_aggg ;_fe :=_bffc ;if _ccg ._dgf ==CellBorderStyleDouble {_fe -=_geg ;_bggb :=_gc .BasicLine {};_bggb .X1 =_abg -_cfg /2;_bggb .Y1 =_fe +2*_geg ;_bggb .X2 =_abg +_ccg ._fdg +_cfg /2;_bggb .Y2 =_fe +2*_geg ;_bggb .LineColor =_ccg ._fcc ;_bggb .LineWidth =_ccg ._beed ;_bggb .LineStyle =_ccg .LineStyle ;_dfe ,_ ,_ddf :=_bggb .Draw ("");if _ddf !=nil {return nil ,ctx ,_ddf ;};_ddf =_adec .addContentsByString (string (_dfe ));if _ddf !=nil {return nil ,ctx ,_ddf ;};};_cada :=_gc .BasicLine {LineWidth :_ccg ._beed ,Opacity :1.0,LineColor :_ccg ._fcc ,X1 :_abg -_cfg /2+(_ecdb -_ccg ._edc ),Y1 :_fe ,X2 :_abg +_ccg ._fdg +_cfg /2-(_bgg -_ccg ._fac ),Y2 :_fe ,LineStyle :_ccg .LineStyle };_cfdb ,_ ,_efc :=_cada .Draw ("");if _efc !=nil {return nil ,ctx ,_efc ;};_efc =_adec .addContentsByString (string (_cfdb ));if _efc !=nil {return nil ,ctx ,_efc ;};};if _ccg ._ebca !=0{_agag :=_aggg ;_fdf :=_bffc -_ccg ._eec ;if _ccg ._gcaa ==CellBorderStyleDouble {_fdf +=_aba ;_faca :=_gc .BasicLine {LineWidth :_ccg ._ebca ,Opacity :1.0,LineColor :_ccg ._cbb ,X1 :_agag -_bfg /2,Y1 :_fdf -2*_aba ,X2 :_agag +_ccg ._fdg +_bfg /2,Y2 :_fdf -2*_aba ,LineStyle :_ccg .LineStyle };_gdg ,_ ,_ggd :=_faca .Draw ("");if _ggd !=nil {return nil ,ctx ,_ggd ;};_ggd =_adec .addContentsByString (string (_gdg ));if _ggd !=nil {return nil ,ctx ,_ggd ;};};_egb :=_gc .BasicLine {LineWidth :_ccg ._ebca ,Opacity :1.0,LineColor :_ccg ._cbb ,X1 :_agag -_bfg /2+(_ecdb -_ccg ._edc ),Y1 :_fdf ,X2 :_agag +_ccg ._fdg +_bfg /2-(_bgg -_ccg ._fac ),Y2 :_fdf ,LineStyle :_ccg .LineStyle };_bbb ,_ ,_acf :=_egb .Draw ("");if _acf !=nil {return nil ,ctx ,_acf ;};_acf =_adec .addContentsByString (string (_bbb ));if _acf !=nil {return nil ,ctx ,_acf ;};};if _ccg ._edc !=0{_bea :=_aggg ;_agbe :=_bffc ;if _ccg ._cbg ==CellBorderStyleDouble {_bea +=_edd ;_dag :=_gc .BasicLine {LineWidth :_ccg ._edc ,Opacity :1.0,LineColor :_ccg ._gec ,X1 :_bea -2*_edd ,Y1 :_agbe +_ecdb /2,X2 :_bea -2*_edd ,Y2 :_agbe -_ccg ._eec -_ecdb /2,LineStyle :_ccg .LineStyle };_bfb ,_ ,_eaeg :=_dag .Draw ("");if _eaeg !=nil {return nil ,ctx ,_eaeg ;};_eaeg =_adec .addContentsByString (string (_bfb ));if _eaeg !=nil {return nil ,ctx ,_eaeg ;};};_eca :=_gc .BasicLine {LineWidth :_ccg ._edc ,Opacity :1.0,LineColor :_ccg ._gec ,X1 :_bea ,Y1 :_agbe +_ecdb /2-(_cfg -_ccg ._beed ),X2 :_bea ,Y2 :_agbe -_ccg ._eec -_ecdb /2+(_bfg -_ccg ._ebca ),LineStyle :_ccg .LineStyle };_bggba ,_ ,_bce :=_eca .Draw ("");if _bce !=nil {return nil ,ctx ,_bce ;};_bce =_adec .addContentsByString (string (_bggba ));if _bce !=nil {return nil ,ctx ,_bce ;};};if _ccg ._fac !=0{_gbgd :=_aggg +_ccg ._fdg ;_ffgc :=_bffc ;if _ccg ._gga ==CellBorderStyleDouble {_gbgd -=_eccc ;_ecgb :=_gc .BasicLine {LineWidth :_ccg ._fac ,Opacity :1.0,LineColor :_ccg ._bgcb ,X1 :_gbgd +2*_eccc ,Y1 :_ffgc +_bgg /2,X2 :_gbgd +2*_eccc ,Y2 :_ffgc -_ccg ._eec -_bgg /2,LineStyle :_ccg .LineStyle };_acdc ,_ ,_eaee :=_ecgb .Draw ("");if _eaee !=nil {return nil ,ctx ,_eaee ;};_eaee =_adec .addContentsByString (string (_acdc ));if _eaee !=nil {return nil ,ctx ,_eaee ;};};_fbd :=_gc .BasicLine {LineWidth :_ccg ._fac ,Opacity :1.0,LineColor :_ccg ._bgcb ,X1 :_gbgd ,Y1 :_ffgc +_bgg /2-(_cfg -_ccg ._beed ),X2 :_gbgd ,Y2 :_ffgc -_ccg ._eec -_bgg /2+(_bfg -_ccg ._ebca ),LineStyle :_ccg .LineStyle };_dfeb ,_ ,_fgge :=_fbd .Draw ("");if _fgge !=nil {return nil ,ctx ,_fgge ;};_fgge =_adec .addContentsByString (string (_dfeb ));if _fgge !=nil {return nil ,ctx ,_fgge ;};};return []*Block {_adec },ctx ,nil ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_eedb *Invoice )Sections ()[][2]string {return _eedb ._fddg };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_gffe *StyledParagraph )SetWidth (width float64 ){_gffe ._gdff =width ;_gffe .wrapText ()};func (_fdaaa *Invoice )setCellBorder (_cgfd *TableCell ,_ecbf *InvoiceCell ){for _ ,_aaaf :=range _ecbf .BorderSides {_cgfd .SetBorder (_aaaf ,CellBorderStyleSingle ,_ecbf .BorderWidth );};_cgfd .SetBorderColor (_ecbf .BorderColor );};

// Margins returns the margins of the list: left, right, top, bottom.
func (_fedf *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _fedf ._gbb ._dea ,_fedf ._gbb ._aaf ,_fedf ._gbb ._bdbd ,_fedf ._gbb ._bgb ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_fdaa *Invoice )SetTitleStyle (style TextStyle ){_fdaa ._fcab =style };func (_fd *Block )drawToPage (_gfad *_ga .PdfPage )error {_cgc ,_bd :=_gfad .GetAllContentStreams ();if _bd !=nil {return _bd ;};_gcb :=_gf .NewContentStreamParser (_cgc );_ffe ,_bd :=_gcb .Parse ();if _bd !=nil {return _bd ;};_ffe .WrapIfNeeded ();if _gfad .Resources ==nil {_gfad .Resources =_ga .NewPdfPageResources ();};_bd =_dbb (_ffe ,_gfad .Resources ,_fd ._cf ,_fd ._dg );if _bd !=nil {return _bd ;};if _bd =_gca (_fd ._dg ,_gfad .Resources );_bd !=nil {return _bd ;};_bd =_gfad .SetContentStreams ([]string {string (_ffe .Bytes ())},_cad .NewFlateEncoder ());if _bd !=nil {return _bd ;};for _ ,_bg :=range _fd ._gg {_gfad .AddAnnotation (_bg );};return nil ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;func _dfdb ()*FilledCurve {_fdgg :=FilledCurve {};_fdgg ._fadg =[]_gc .CubicBezierCurve {};return &_fdgg ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_ecec *Chapter )NewSubchapter (title string )*Chapter {_acde :=_fceaf (_ecec ._eadd ._ffgce );_acde .FontSize =14;_ecec ._aab ++;_ede :=_dabf (_ecec ,_ecec ._efaf ,_ecec ._abfe ,title ,_ecec ._aab ,_acde );_ecec .Add (_ede );return _ede ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fage *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdcb :=ctx ;_accd :=[]func (_cacg DrawContext )([]*Block ,DrawContext ,error ){_fage .generateHeaderBlocks ,_fage .generateInformationBlocks ,_fage .generateLineBlocks ,_fage .generateTotalBlocks ,_fage .generateNoteBlocks };var _adae []*Block ;for _ ,_fcbg :=range _accd {_gagd ,_aead ,_bcecf :=_fcbg (ctx );if _bcecf !=nil {return _adae ,ctx ,_bcecf ;};if len (_adae )==0{_adae =_gagd ;}else if len (_gagd )> 0{_adae [len (_adae )-1].mergeBlocks (_gagd [0]);_adae =append (_adae ,_gagd [1:]...);};ctx =_aead ;};if _fage ._ceaf .isRelative (){ctx .X =_fdcb .X ;};if _fage ._ceaf .isAbsolute (){return _adae ,_fdcb ,nil ;};return _adae ,ctx ,nil ;};

// Inline returns whether the inline mode of the division is active.
func (_ggda *Division )Inline ()bool {return _ggda ._fbdb };

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;func _afcf (_edad ,_fbga ,_cbcd string ,_fcagf uint ,_bddgg TextStyle )*TOCLine {return _gfgc (TextChunk {Text :_edad ,Style :_bddgg },TextChunk {Text :_fbga ,Style :_bddgg },TextChunk {Text :_cbcd ,Style :_bddgg },_fcagf ,_bddgg );};

// DrawWithContext draws the Block using the specified drawing context.
func (_ffg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_db ,_ ,_beg :=d .GeneratePageBlocks (ctx );if _beg !=nil {return _beg ;};if len (_db )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ffb :=range _db {if _bgc :=_ffg .mergeBlocks (_ffb );_bgc !=nil {return _bgc ;};};return nil ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_fggc *Invoice )SetAddressHeadingStyle (style TextStyle ){_fggc ._gcbg =style };func (_aac *Chapter )headingText ()string {_bcgd :=_aac ._acg ;if _gfag :=_aac .headingNumber ();_gfag !=""{_bcgd =_ab .Sprintf ("\u0025\u0073\u0020%\u0073",_gfag ,_bcgd );};return _bcgd ;};

// SetColorBottom sets border color for bottom.
func (_bda *border )SetColorBottom (col Color ){_bda ._cbb =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_adcc *Image )SetWidth (w float64 ){_adcc ._ffecf =w };

// SetFont sets the Paragraph's font.
func (_ggbg *Paragraph )SetFont (font *_ga .PdfFont ){_ggbg ._ffgce =font };

// SetRowHeight sets the height for a specified row.
func (_fdbbc *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_fdbbc ._cefdb ){return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdbbc ._cefdb [row -1]=h ;return nil ;};func (_ccdg *StyledParagraph )getTextWidth ()float64 {var _gfeb float64 ;_fbcc :=len (_ccdg ._facc );for _fdbbg ,_cdgdd :=range _ccdg ._facc {_gagdf :=&_cdgdd .Style ;_aegga :=len (_cdgdd .Text );for _bbga ,_cebfd :=range _cdgdd .Text {if _cebfd =='\u000A'{continue ;};_bfe ,_fegeb :=_gagdf .Font .GetRuneMetrics (_cebfd );if !_fegeb {_d .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cebfd );return -1;};_gfeb +=_gagdf .FontSize *_bfe .Wx ;if _cebfd !=' '&&(_fdbbg !=_fbcc -1||_bbga !=_aegga -1){_gfeb +=_gagdf .CharSpacing *1000.0;};};};return _gfeb ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Angle returns the block rotation angle in degrees.
func (_cfee *Block )Angle ()float64 {return _cfee ._de };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_bggff *TOC )SetLineSeparator (separator string ){_bggff ._cgfdf =separator };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_acfa *Creator )SetOutlineTree (outlineTree *_ga .PdfOutlineTreeNode ){_acfa ._fgab =outlineTree };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gbbg *_ga .PdfAnnotation ;_agage bool ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_gccc *List )SetIndent (indent float64 ){_gccc ._bcbf =indent ;_gccc ._dbce =false };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_agafa *Invoice )AddressHeadingStyle ()TextStyle {return _agafa ._dfcfe };

// Height returns the current page height.
func (_gdf *Creator )Height ()float64 {return _gdf ._ffd };

// SetFontSize sets the font size in document units (points).
func (_edgf *Paragraph )SetFontSize (fontSize float64 ){_edgf ._bfgb =fontSize };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_ccfe *Chapter )SetShowNumbering (show bool ){_ccfe ._cfeg =show ;_ccfe ._eadd .SetText (_ccfe .headingText ());};

// AppendCurve appends a Bezier curve to the filled curve.
func (_eeg *FilledCurve )AppendCurve (curve _gc .CubicBezierCurve )*FilledCurve {_eeg ._fadg =append (_eeg ._fadg ,curve );return _eeg ;};

// Lines returns all the rows of the invoice line items table.
func (_agedd *Invoice )Lines ()[][]*InvoiceCell {return _agedd ._gcgb };func (_cdcce *Invoice )generateTotalBlocks (_aecgg DrawContext )([]*Block ,DrawContext ,error ){_fggbb :=_fcfa (4);_fggbb .SetMargins (0,0,10,10);_agbc :=[][2]*InvoiceCell {_cdcce ._aed };_agbc =append (_agbc ,_cdcce ._gfef ...);_agbc =append (_agbc ,_cdcce ._aagd );for _ ,_ddcda :=range _agbc {_fdfc ,_gaae :=_ddcda [0],_ddcda [1];if _gaae .Value ==""{continue ;};_fggbb .SkipCells (2);_gadb :=_fggbb .NewCell ();_gadb .SetBackgroundColor (_fdfc .BackgroundColor );_gadb .SetHorizontalAlignment (_gaae .Alignment );_cdcce .setCellBorder (_gadb ,_fdfc );_bbffc :=_afae (_fdfc .TextStyle );_bbffc .SetMargins (0,0,2,1);_bbffc .Append (_fdfc .Value );_gadb .SetContent (_bbffc );_gadb =_fggbb .NewCell ();_gadb .SetBackgroundColor (_gaae .BackgroundColor );_gadb .SetHorizontalAlignment (_gaae .Alignment );_cdcce .setCellBorder (_gadb ,_fdfc );_bbffc =_afae (_gaae .TextStyle );_bbffc .SetMargins (0,0,2,1);_bbffc .Append (_gaae .Value );_gadb .SetContent (_bbffc );};return _fggbb .GeneratePageBlocks (_aecgg );};

// SetLineWidth sets the line width.
func (_cgbb *Line )SetLineWidth (lw float64 ){_cgbb ._bbgc =lw };func _geda (_fafd ,_bccb ,_deae ,_afed float64 )*Line {_gbcf :=&Line {};_gbcf ._cedg =_fafd ;_gbcf ._cbag =_bccb ;_gbcf ._ggfg =_deae ;_gbcf ._edcea =_afed ;_gbcf ._addeg =_ga .NewPdfColorDeviceRGB (0,0,0);_gbcf ._bbgc =1.0;return _gbcf ;};

// Title returns the title of the invoice.
func (_cabf *Invoice )Title ()string {return _cabf ._adbee };

// NewDivision returns a new Division container component.
func (_addc *Creator )NewDivision ()*Division {return _cbfe ()};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetEncoder sets the encoding/compression mechanism for the image.
func (_aca *Image )SetEncoder (encoder _cad .StreamEncoder ){_aca ._abfb =encoder };

// NewColumn returns a new column for the line items invoice table.
func (_gacg *Invoice )NewColumn (description string )*InvoiceCell {return _gacg .newColumn (description ,CellHorizontalAlignmentLeft );};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_ebdc :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ebdc ;};var _fcgc ,_agcae ,_fbgf int ;if len (hexStr )==4{var _gaed ,_beb ,_edf int ;_ffa ,_cdgg :=_ab .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_gaed ,&_beb ,&_edf );if _cdgg !=nil {_d .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_cdgg );return _ebdc ;};if _ffa !=3{_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ebdc ;};_fcgc =_gaed *16+_gaed ;_agcae =_beb *16+_beb ;_fbgf =_edf *16+_edf ;}else {_cfeee ,_fde :=_ab .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fcgc ,&_agcae ,&_fbgf );if _fde !=nil {_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ebdc ;};if _cfeee !=3{_d .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_cfeee );return _ebdc ;};};_ddce :=float64 (_fcgc )/255.0;_gfc :=float64 (_agcae )/255.0;_ebae :=float64 (_fbgf )/255.0;_ebdc ._fef =_ddce ;_ebdc ._eba =_gfc ;_ebdc ._befb =_ebae ;return _ebdc ;};func (_fgedd *Invoice )generateInformationBlocks (_agba DrawContext )([]*Block ,DrawContext ,error ){_aedg :=_afae (_fgedd ._dfdf );_aedg .SetMargins (0,0,0,20);_gced :=_fgedd .drawAddress (_fgedd ._fcd );_gced =append (_gced ,_aedg );_gced =append (_gced ,_fgedd .drawAddress (_fgedd ._deea )...);_caba :=_cbfe ();for _ ,_agbb :=range _gced {_caba .Add (_agbb );};_dbd :=_fgedd .drawInformation ();_aegg :=_fcfa (2);_aegg .SetMargins (0,0,25,0);_dfaa :=_aegg .NewCell ();_dfaa .SetIndent (0);_dfaa .SetContent (_caba );_dfaa =_aegg .NewCell ();_dfaa .SetContent (_dbd );return _aegg .GeneratePageBlocks (_agba );};

// NewImageFromData creates an Image from image data.
func (_fadf *Creator )NewImageFromData (data []byte )(*Image ,error ){return _dfbc (data )};

// Cols returns the total number of columns the table has.
func (_adg *Table )Cols ()int {return _adg ._ggag };

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_fge *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bba :=ctx ;if _fge ._aag .isRelative (){ctx .X +=_fge ._geeg ._dea ;ctx .Y +=_fge ._geeg ._bdbd ;ctx .Width -=_fge ._geeg ._dea +_fge ._geeg ._aaf ;ctx .Height -=_fge ._geeg ._bdbd ;};_ecfd ,_fbg ,_babgc :=_fge ._eadd .GeneratePageBlocks (ctx );if _babgc !=nil {return _ecfd ,ctx ,_babgc ;};ctx =_fbg ;_cafd :=ctx .X ;_dbac :=ctx .Y -_fge ._eadd .Height ();_cef :=int64 (ctx .Page );_agf :=_fge .headingNumber ();_ccab :=_fge .headingText ();if _fge ._ebb {_fffg :=_fge ._efaf .Add (_agf ,_fge ._acg ,_efa .FormatInt (_cef ,10),_fge ._abge );if _fge ._efaf ._fbgc {_fffg .SetLink (_cef ,_cafd ,_dbac );};};if _fge ._gfec ==nil {_fge ._gfec =_ga .NewOutlineItem (_ccab ,_ga .NewOutlineDest (_cef -1,_cafd ,_dbac ));if _fge ._cded !=nil {_fge ._cded ._gfec .Add (_fge ._gfec );}else {_fge ._abfe .Add (_fge ._gfec );};}else {_fgac :=&_fge ._gfec .Dest ;_fgac .Page =_cef -1;_fgac .X =_cafd ;_fgac .Y =_dbac ;};for _ ,_adeg :=range _fge ._dfg {_fdbb ,_adbe ,_feeb :=_adeg .GeneratePageBlocks (ctx );if _feeb !=nil {return _ecfd ,ctx ,_feeb ;};if len (_fdbb )< 1{continue ;};_ecfd [len (_ecfd )-1].mergeBlocks (_fdbb [0]);_ecfd =append (_ecfd ,_fdbb [1:]...);ctx =_adbe ;};if _fge ._aag .isRelative (){ctx .X =_bba .X ;};if _fge ._aag .isAbsolute (){return _ecfd ,_bba ,nil ;};return _ecfd ,ctx ,nil ;};

// Width returns the Block's width.
func (_egg *Block )Width ()float64 {return _egg ._cfe };

// Lines returns all the lines the table of contents has.
func (_eafb *TOC )Lines ()[]*TOCLine {return _eafb ._aaae };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_faeb *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_gdaee :=&_faeb ._edda ;_gdaee ._dea =left ;_gdaee ._aaf =right ;_gdaee ._bdbd =top ;_gdaee ._bgb =bottom ;};

// SetBorderWidth sets the border width.
func (_beff *Ellipse )SetBorderWidth (bw float64 ){_beff ._bdf =bw };func (_gdd *Creator )initContext (){_gdd ._bgac .X =_gdd ._ced ._dea ;_gdd ._bgac .Y =_gdd ._ced ._bdbd ;_gdd ._bgac .Width =_gdd ._dbag -_gdd ._ced ._aaf -_gdd ._ced ._dea ;_gdd ._bgac .Height =_gdd ._ffd -_gdd ._ced ._bgb -_gdd ._ced ._bdbd ;_gdd ._bgac .PageHeight =_gdd ._ffd ;_gdd ._bgac .PageWidth =_gdd ._dbag ;_gdd ._bgac .Margins =_gdd ._ced ;};

// SetAngle sets the rotation angle in degrees.
func (_dge *Block )SetAngle (angleDeg float64 ){_dge ._de =angleDeg };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_acbc *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bbe *_ga .PdfWriter )error ){_acbc ._bbg =pdfWriterAccessFunc ;};

// Length calculates and returns the line length.
func (_feb *Line )Length ()float64 {return _g .Sqrt (_g .Pow (_feb ._ggfg -_feb ._cedg ,2.0)+_g .Pow (_feb ._edcea -_feb ._cbag ,2.0));};

// SetNumber sets the number of the invoice.
func (_dfdg *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_dfdg ._effc [1].Value =number ;return _dfdg ._effc [0],_dfdg ._effc [1];};

// Height returns the Block's height.
func (_eb *Block )Height ()float64 {return _eb ._gfa };

// LevelOffset returns the amount of space an indentation level occupies.
func (_cddda *TOCLine )LevelOffset ()float64 {return _cddda ._aedde };

// SetText replaces all the text of the paragraph with the specified one.
func (_edee *StyledParagraph )SetText (text string )*TextChunk {_edee .Reset ();return _edee .Append (text );};

// NewImageFromFile creates an Image from a file.
func (_eaege *Creator )NewImageFromFile (path string )(*Image ,error ){return _fed (path )};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_bbab *Paragraph )SetColor (col Color ){_aecgc :=_ga .NewPdfColorDeviceRGB (col .ToRGB ());_bbab ._cebc =*_aecgc ;};

// SetWidthLeft sets border width for left.
func (_bgd *border )SetWidthLeft (bw float64 ){_bgd ._edc =bw };

// SetColor sets the line color.
func (_fbgfc *Curve )SetColor (col Color ){_fbgfc ._ebdd =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetLogo sets the logo of the invoice.
func (_fccgb *Invoice )SetLogo (logo *Image ){_fccgb ._daaa =logo };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_da *Block )AddAnnotation (annotation *_ga .PdfAnnotation ){for _ ,_cc :=range _da ._gg {if _cc ==annotation {return ;};};_da ._gg =append (_da ._gg ,annotation );};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_ga .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};func _dcee (_geea ,_egfba ,_dfa ,_bcf float64 )*Ellipse {_ddfg :=&Ellipse {};_ddfg ._afg =_geea ;_ddfg ._cfcd =_egfba ;_ddfg ._geegc =_dfa ;_ddfg ._edcf =_bcf ;_ddfg ._gddg =_ga .NewPdfColorDeviceRGB (0,0,0);_ddfg ._bdf =1.0;return _ddfg ;};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_cagg *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdag :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fcag :=_gc .Line {LineWidth :_cagg ._bbgc ,Opacity :1.0,LineColor :_cagg ._addeg ,LineEndingStyle1 :_gc .LineEndingStyleNone ,LineEndingStyle2 :_gc .LineEndingStyleNone ,X1 :_cagg ._cedg ,Y1 :ctx .PageHeight -_cagg ._cbag ,X2 :_cagg ._ggfg ,Y2 :ctx .PageHeight -_cagg ._edcea };_acdea ,_ ,_bdaf :=_fcag .Draw ("");if _bdaf !=nil {return nil ,ctx ,_bdaf ;};_bdaf =_cdag .addContentsByString (string (_acdea ));if _bdaf !=nil {return nil ,ctx ,_bdaf ;};return []*Block {_cdag },ctx ,nil ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_eabg *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_dbda :=range subtable ._bfgf {_fcfaa :=&TableCell {};*_fcfaa =*_dbda ;_fcfaa ._gegdf =_eabg ;_fcfaa ._eggg +=col -1;if _bgff :=_eabg ._ggag -(_fcfaa ._eggg -1);_bgff < _fcfaa ._cbac {_eabg ._ggag +=_fcfaa ._cbac -_bgff ;_eabg .resetColumnWidths ();_d .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_eabg ._ggag );};_fcfaa ._aaca +=row -1;_fccfg :=subtable ._cefdb [_dbda ._aaca -1];if _fcfaa ._aaca > _eabg ._egbbd {for _fcfaa ._aaca > _eabg ._egbbd {_eabg ._egbbd ++;_eabg ._cefdb =append (_eabg ._cefdb ,_eabg ._agdc );};_eabg ._cefdb [_fcfaa ._aaca -1]=_fccfg ;}else {_eabg ._cefdb [_fcfaa ._aaca -1]=_g .Max (_eabg ._cefdb [_fcfaa ._aaca -1],_fccfg );};_eabg ._bfgf =append (_eabg ._bfgf ,_fcfaa );};_e .Slice (_eabg ._bfgf ,func (_ffde ,_cdba int )bool {_dfda :=_eabg ._bfgf [_ffde ]._aaca ;_geege :=_eabg ._bfgf [_cdba ]._aaca ;if _dfda < _geege {return true ;};if _dfda > _geege {return false ;};return _eabg ._bfgf [_ffde ]._eggg < _eabg ._bfgf [_cdba ]._eggg ;});};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_bdcd *Creator )NewParagraph (text string )*Paragraph {return _efda (text ,_bdcd .NewTextStyle ())};

// NewInvoice returns an instance of an empty invoice.
func (_fabb *Creator )NewInvoice ()*Invoice {_aacg :=_fabb .NewTextStyle ();_aacg .Font =_fabb ._dgfc ;return _egag (_fabb .NewTextStyle (),_aacg );};func _dbb (_ebd *_gf .ContentStreamOperations ,_aeg *_ga .PdfPageResources ,_dfb *_gf .ContentStreamOperations ,_dae *_ga .PdfPageResources )error {_aegd :=map[_cad .PdfObjectName ]_cad .PdfObjectName {};_cda :=map[_cad .PdfObjectName ]_cad .PdfObjectName {};_bdb :=map[_cad .PdfObjectName ]_cad .PdfObjectName {};_efga :=map[_cad .PdfObjectName ]_cad .PdfObjectName {};_egge :=map[_cad .PdfObjectName ]_cad .PdfObjectName {};_cfae :=map[_cad .PdfObjectName ]_cad .PdfObjectName {};for _ ,_dfd :=range *_dfb {switch _dfd .Operand {case "\u0044\u006f":if len (_dfd .Params )==1{if _gcbc ,_ccf :=_dfd .Params [0].(*_cad .PdfObjectName );_ccf {if _ ,_bee :=_aegd [*_gcbc ];!_bee {var _bad _cad .PdfObjectName ;_gaa ,_ :=_dae .GetXObjectByName (*_gcbc );if _gaa !=nil {_bad =*_gcbc ;for {_dcb ,_ :=_aeg .GetXObjectByName (_bad );if _dcb ==nil ||_dcb ==_gaa {break ;};_bad =_bad +"\u0030";};};_aeg .SetXObjectByName (_bad ,_gaa );_aegd [*_gcbc ]=_bad ;};_bafb :=_aegd [*_gcbc ];_dfd .Params [0]=&_bafb ;};};case "\u0054\u0066":if len (_dfd .Params )==2{if _gfb ,_dgc :=_dfd .Params [0].(*_cad .PdfObjectName );_dgc {if _ ,_acb :=_cda [*_gfb ];!_acb {_caf ,_fgf :=_dae .GetFontByName (*_gfb );_aad :=*_gfb ;if _fgf &&_caf !=nil {_aad =_bdd (_gfb .String (),_caf ,_aeg );};_aeg .SetFontByName (_aad ,_caf );_cda [*_gfb ]=_aad ;};_bfd :=_cda [*_gfb ];_dfd .Params [0]=&_bfd ;};};case "\u0043\u0053","\u0063\u0073":if len (_dfd .Params )==1{if _fdb ,_ebgg :=_dfd .Params [0].(*_cad .PdfObjectName );_ebgg {if _ ,_bge :=_bdb [*_fdb ];!_bge {var _efb _cad .PdfObjectName ;_adb ,_ccdf :=_dae .GetColorspaceByName (*_fdb );if _ccdf {_efb =*_fdb ;for {_bcd ,_eef :=_aeg .GetColorspaceByName (_efb );if !_eef ||_adb ==_bcd {break ;};_efb =_efb +"\u0030";};_aeg .SetColorspaceByName (_efb ,_adb );_bdb [*_fdb ]=_efb ;}else {_d .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _cca ,_edb :=_bdb [*_fdb ];_edb {_dfd .Params [0]=&_cca ;}else {_d .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_fdb );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_dfd .Params )==1{if _bb ,_gff :=_dfd .Params [0].(*_cad .PdfObjectName );_gff {if _ ,_dfc :=_efga [*_bb ];!_dfc {var _bag _cad .PdfObjectName ;_cfb ,_fff :=_dae .GetPatternByName (*_bb );if _fff {_bag =*_bb ;for {_ebc ,_dfcb :=_aeg .GetPatternByName (_bag );if !_dfcb ||_ebc ==_cfb {break ;};_bag =_bag +"\u0030";};_deb :=_aeg .SetPatternByName (_bag ,_cfb .ToPdfObject ());if _deb !=nil {return _deb ;};_efga [*_bb ]=_bag ;};};if _cac ,_agb :=_efga [*_bb ];_agb {_dfd .Params [0]=&_cac ;};};};case "\u0073\u0068":if len (_dfd .Params )==1{if _cfac ,_aecg :=_dfd .Params [0].(*_cad .PdfObjectName );_aecg {if _ ,_abc :=_egge [*_cfac ];!_abc {var _ece _cad .PdfObjectName ;_eed ,_ecge :=_dae .GetShadingByName (*_cfac );if _ecge {_ece =*_cfac ;for {_eaec ,_gbg :=_aeg .GetShadingByName (_ece );if !_gbg ||_eed ==_eaec {break ;};_ece =_ece +"\u0030";};_dab :=_aeg .SetShadingByName (_ece ,_eed .ToPdfObject ());if _dab !=nil {_d .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_dab );return _dab ;};_egge [*_cfac ]=_ece ;}else {_d .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _fda ,_aga :=_egge [*_cfac ];_aga {_dfd .Params [0]=&_fda ;}else {_d .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_cfac );};};};case "\u0067\u0073":if len (_dfd .Params )==1{if _dcc ,_agg :=_dfd .Params [0].(*_cad .PdfObjectName );_agg {if _ ,_ddc :=_cfae [*_dcc ];!_ddc {var _aae _cad .PdfObjectName ;_fgb ,_ecd :=_dae .GetExtGState (*_dcc );if _ecd {_aae =*_dcc ;_gee :=1;for {_bgf ,_gbe :=_aeg .GetExtGState (_aae );if !_gbe ||_fgb ==_bgf {break ;};_aae =_cad .PdfObjectName (_ab .Sprintf ("\u0047\u0053\u0025\u0064",_gee ));_gee ++;};};_aeg .AddExtGState (_aae ,_fgb );_cfae [*_dcc ]=_aae ;};_acd :=_cfae [*_dcc ];_dfd .Params [0]=&_acd ;};};};*_ebd =append (*_ebd ,_dfd );};return nil ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_cfge *Creator )Finalize ()error {if _cfge ._gbdg {return nil ;};_dce :=len (_cfge ._edg );_aaba :=0;if _cfge ._bdbe !=nil {_aaba ++;};if _cfge .AddTOC {_cfge .initContext ();_cfge ._bgac .Page =_aaba +1;if _cfge ._efcc !=nil {if _bbce :=_cfge ._efcc (_cfge ._dec );_bbce !=nil {return _bbce ;};};_agcc ,_ ,_gcg :=_cfge ._dec .GeneratePageBlocks (_cfge ._bgac );if _gcg !=nil {_d .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_gcg );return _gcg ;};_aaba +=len (_agcc );_dgb :=_cfge ._dec .Lines ();for _ ,_bdae :=range _dgb {_gaaa ,_ded :=_efa .Atoi (_bdae .Page .Text );if _ded !=nil {continue ;};_bdae .Page .Text =_efa .Itoa (_gaaa +_aaba );};};_daea :=false ;if _cfge ._bdbe !=nil {_dce ++;_deca :=_cfge .newPage ();_cfge ._edg =append ([]*_ga .PdfPage {_deca },_cfge ._edg ...);_cfge .setActivePage (_deca );_afbe :=FrontpageFunctionArgs {PageNum :1,TotalPages :_dce };_cfge ._bdbe (_afbe );_daea =true ;};if _cfge .AddTOC {_cfge .initContext ();if _cfge ._efcc !=nil {if _eee :=_cfge ._efcc (_cfge ._dec );_eee !=nil {_d .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_eee );return _eee ;};};_fgea :=_cfge ._dec .Lines ();for _ ,_ebbf :=range _fgea {_ebbf ._dged +=int64 (_aaba );};var _ddfb []*_ga .PdfPage ;_bcec ,_ ,_ :=_cfge ._dec .GeneratePageBlocks (_cfge ._bgac );for _ ,_gbdd :=range _bcec {_gbdd .SetPos (0,0);_dce ++;_debd :=_cfge .newPage ();_ddfb =append (_ddfb ,_debd );_cfge .setActivePage (_debd );_cfge .Draw (_gbdd );};if _daea {_bbf :=_cfge ._edg [0];_cgf :=_cfge ._edg [1:];_cfge ._edg =append ([]*_ga .PdfPage {_bbf },_ddfb ...);_cfge ._edg =append (_cfge ._edg ,_cgf ...);}else {_cfge ._edg =append (_ddfb ,_cfge ._edg ...);};};if _cfge ._gfd !=nil &&_cfge .AddOutlines {var _daga func (_cec *_ga .OutlineItem );_daga =func (_ebed *_ga .OutlineItem ){_ebed .Dest .Page +=int64 (_aaba );if _eddf :=int (_ebed .Dest .Page );_eddf >=0&&_eddf < len (_cfge ._edg ){_ebed .Dest .PageObj =_cfge ._edg [_eddf ].GetPageAsIndirectObject ();}else {_d .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_eddf );};_ebed .Dest .Y =_cfge ._ffd -_ebed .Dest .Y ;_fbdg :=_ebed .Items ();for _ ,_eff :=range _fbdg {_daga (_eff );};};_bddc :=_cfge ._gfd .Items ();for _ ,_beae :=range _bddc {_daga (_beae );};if _cfge .AddTOC {var _gdfe int ;if _daea {_gdfe =1;};_bebe :=_ga .NewOutlineDest (int64 (_gdfe ),0,_cfge ._ffd );if _gdfe >=0&&_gdfe < len (_cfge ._edg ){_bebe .PageObj =_cfge ._edg [_gdfe ].GetPageAsIndirectObject ();}else {_d .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gdfe );};_cfge ._gfd .Insert (0,_ga .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_bebe ));};};for _cfgc ,_ceff :=range _cfge ._edg {_cfge .setActivePage (_ceff );if _cfge ._bcgf !=nil {_eagf :=NewBlock (_cfge ._dbag ,_cfge ._ced ._bdbd );_cbcf :=HeaderFunctionArgs {PageNum :_cfgc +1,TotalPages :_dce };_cfge ._bcgf (_eagf ,_cbcf );_eagf .SetPos (0,0);if _aceg :=_cfge .Draw (_eagf );_aceg !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_aceg );return _aceg ;};};if _cfge ._gde !=nil {_ddced :=NewBlock (_cfge ._dbag ,_cfge ._ced ._bgb );_cab :=FooterFunctionArgs {PageNum :_cfgc +1,TotalPages :_dce };_cfge ._gde (_ddced ,_cab );_ddced .SetPos (0,_cfge ._ffd -_ddced ._gfa );if _gdc :=_cfge .Draw (_ddced );_gdc !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_gdc );return _gdc ;};};_ffab ,_bcb :=_cfge ._dbg [_ceff ];if !_bcb {continue ;};if _adf :=_ffab .drawToPage (_ceff );_adf !=nil {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_cfgc +1,_adf );return _adf ;};};_cfge ._gbdg =true ;return nil ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_edeb *Invoice )BuyerAddress ()*InvoiceAddress {return _edeb ._deea };

// AddPage adds the specified page to the creator.
func (_cgcc *Creator )AddPage (page *_ga .PdfPage )error {_afa ,_ffcd :=page .GetMediaBox ();if _ffcd !=nil {_d .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_ffcd );return _ffcd ;};_cgcc ._bgac .X =_afa .Llx +_cgcc ._ced ._dea ;_cgcc ._bgac .Y =_cgcc ._ced ._bdbd ;_cgcc ._bgac .PageHeight =_afa .Ury -_afa .Lly ;_cgcc ._bgac .PageWidth =_afa .Urx -_afa .Llx ;_cgcc ._edg =append (_cgcc ._edg ,page );_cgcc ._bgac .Page ++;return nil ;};

// SkipCells skips over a specified number of cells in the table.
func (_ggbe *Table )SkipCells (num int ){if num < 0{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ggbe ._bcfg +=num ;};

// SetInline sets the inline mode of the division.
func (_bedb *Division )SetInline (inline bool ){_bedb ._fbdb =inline };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_bfgg *Invoice )NoteHeadingStyle ()TextStyle {return _bfgg ._ddgb };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// SetMargins sets the margins TOC line.
func (_fecg *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_fecg ._egdc =left ;_cegb :=&_fecg ._gfeg ._ebee ;_cegb ._dea =_fecg ._egdc +float64 (_fecg ._cagc -1)*_fecg ._aedde ;_cegb ._aaf =right ;_cegb ._bdbd =top ;_cegb ._bgb =bottom ;};func _gbcg (_dcde *Block ,_bgee *Paragraph ,_agbd DrawContext )(DrawContext ,error ){_fbecd :=1;_abgg :=_cad .PdfObjectName ("\u0046\u006f\u006e\u0074"+_efa .Itoa (_fbecd ));for _dcde ._dg .HasFontByName (_abgg ){_fbecd ++;_abgg =_cad .PdfObjectName ("\u0046\u006f\u006e\u0074"+_efa .Itoa (_fbecd ));};_decac :=_dcde ._dg .SetFontByName (_abgg ,_bgee ._ffgce .ToPdfObject ());if _decac !=nil {return _agbd ,_decac ;};_bgee .wrapText ();_cfdge :=_gf .NewContentCreator ();_cfdge .Add_q ();_gdcd :=_agbd .PageHeight -_agbd .Y -_bgee ._bfgb *_bgee ._agcd ;_cfdge .Translate (_agbd .X ,_gdcd );if _bgee ._beeef !=0{_cfdge .RotateDeg (_bgee ._beeef );};_cfdge .Add_BT ().Add_rg (_bgee ._cebc .R (),_bgee ._cebc .G (),_bgee ._cebc .B ()).Add_Tf (_abgg ,_bgee ._bfgb ).Add_TL (_bgee ._bfgb *_bgee ._agcd );for _deaa ,_daed :=range _bgee ._cae {if _deaa !=0{_cfdge .Add_Tstar ();};_debg :=[]rune (_daed );_gccg :=0.0;_ffgg :=0;for _cgcb ,_bfaf :=range _debg {if _bfaf ==' '{_ffgg ++;continue ;};if _bfaf =='\u000A'{continue ;};_bde ,_eaccb :=_bgee ._ffgce .GetRuneMetrics (_bfaf );if !_eaccb {_d .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_cgcb ,_bfaf ,_bfaf ,_bgee ._ffgce .BaseFont (),_bgee ._ffgce .Subtype ());return _agbd ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_gccg +=_bgee ._bfgb *_bde .Wx ;};var _caca []_cad .PdfObject ;_cfea ,_afbb :=_bgee ._ffgce .GetRuneMetrics (' ');if !_afbb {return _agbd ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_eafc :=_cfea .Wx ;switch _bgee ._fadfa {case TextAlignmentJustify :if _ffgg > 0&&_deaa < len (_bgee ._cae )-1{_eafc =(_bgee ._cebe *1000.0-_gccg )/float64 (_ffgg )/_bgee ._bfgb ;};case TextAlignmentCenter :_fedg :=_gccg +float64 (_ffgg )*_eafc *_bgee ._bfgb ;_baab :=(_bgee ._cebe *1000.0-_fedg )/2/_bgee ._bfgb ;_caca =append (_caca ,_cad .MakeFloat (-_baab ));case TextAlignmentRight :_fcec :=_gccg +float64 (_ffgg )*_eafc *_bgee ._bfgb ;_aaaa :=(_bgee ._cebe *1000.0-_fcec )/_bgee ._bfgb ;_caca =append (_caca ,_cad .MakeFloat (-_aaaa ));};_ddcc :=_bgee ._ffgce .Encoder ();var _gccfg []byte ;for _ ,_daac :=range _debg {if _daac =='\u000A'{continue ;};if _daac ==' '{if len (_gccfg )> 0{_caca =append (_caca ,_cad .MakeStringFromBytes (_gccfg ));_gccfg =nil ;};_caca =append (_caca ,_cad .MakeFloat (-_eafc ));}else {if _ ,_ggaeb :=_ddcc .RuneToCharcode (_daac );!_ggaeb {_d .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_daac ,_daac );continue ;};_gccfg =append (_gccfg ,_ddcc .Encode (string (_daac ))...);};};if len (_gccfg )> 0{_caca =append (_caca ,_cad .MakeStringFromBytes (_gccfg ));};_cfdge .Add_TJ (_caca ...);};_cfdge .Add_ET ();_cfdge .Add_Q ();_gbcgd :=_cfdge .Operations ();_gbcgd .WrapIfNeeded ();_dcde .addContents (_gbcgd );if _bgee ._decc .isRelative (){_fdfb :=_bgee .Height ()+_bgee ._gfed ._bgb ;_agbd .Y +=_fdfb ;_agbd .Height -=_fdfb ;if _agbd .Inline {_agbd .X +=_bgee .Width ()+_bgee ._gfed ._aaf ;};};return _agbd ,nil ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fgfa *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _fgfa ._aagd [0],_fgfa ._aagd [1]};func (_cceb *StyledParagraph )getMaxLineWidth ()float64 {if _cceb ._edac ==nil ||len (_cceb ._edac )==0{_cceb .wrapText ();};var _egagf float64 ;for _ ,_cddeg :=range _cceb ._edac {_fccfb :=_cceb .getTextLineWidth (_cddeg );if _fccfb > _egagf {_egagf =_fccfb ;};};return _egagf ;};func _fdcf (_gedf *_ga .PdfAnnotationLink )*_ga .PdfAnnotationLink {if _gedf ==nil {return nil ;};_dafa :=_ga .NewPdfAnnotationLink ();_dafa .BS =_gedf .BS ;_dafa .A =_gedf .A ;if _gegdd ,_adee :=_gedf .GetAction ();_adee ==nil &&_gegdd !=nil {_dafa .SetAction (_gegdd );};if _fdbbca ,_befcf :=_gedf .Dest .(*_cad .PdfObjectArray );_befcf {_dafa .Dest =_cad .MakeArray (_fdbbca .Elements ()...);};return _dafa ;};func (_faf *Invoice )generateLineBlocks (_dfdge DrawContext )([]*Block ,DrawContext ,error ){_efad :=_fcfa (len (_faf ._cegd ));_efad .SetMargins (0,0,25,0);for _ ,_fadfd :=range _faf ._cegd {_bcdf :=_afae (_fadfd .TextStyle );_bcdf .SetMargins (0,0,1,0);_bcdf .Append (_fadfd .Value );_ffcg :=_efad .NewCell ();_ffcg .SetHorizontalAlignment (_fadfd .Alignment );_ffcg .SetBackgroundColor (_fadfd .BackgroundColor );_faf .setCellBorder (_ffcg ,_fadfd );_ffcg .SetContent (_bcdf );};for _ ,_bbcd :=range _faf ._gcgb {for _ ,_ege :=range _bbcd {_cge :=_afae (_ege .TextStyle );_cge .SetMargins (0,0,3,2);_cge .Append (_ege .Value );_dded :=_efad .NewCell ();_dded .SetHorizontalAlignment (_ege .Alignment );_dded .SetBackgroundColor (_ege .BackgroundColor );_faf .setCellBorder (_dded ,_ege );_dded .SetContent (_cge );};};return _efad .GeneratePageBlocks (_dfdge );};

// Height returns Image's document height.
func (_fgfc *Image )Height ()float64 {return _fgfc ._adege };

// AppendColumn appends a column to the line items table.
func (_dad *Invoice )AppendColumn (description string )*InvoiceCell {_deg :=_dad .NewColumn (description );_dad ._cegd =append (_dad ._cegd ,_deg );return _deg ;};

// SetColorRight sets border color for right.
func (_bfa *border )SetColorRight (col Color ){_bfa ._bgcb =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetFillColor sets the fill color.
func (_cgga *Ellipse )SetFillColor (col Color ){_cgga ._bfcce =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// Width returns the width of the Paragraph.
func (_dacg *Paragraph )Width ()float64 {if _dacg ._deba &&int (_dacg ._cebe )> 0{return _dacg ._cebe ;};return _dacg .getTextWidth ()/1000.0;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;func (_fbad *Image )rotatedSize ()(float64 ,float64 ){_ddea :=_fbad ._ffecf ;_gagg :=_fbad ._adege ;_cdac :=_fbad ._bbeg ;if _cdac ==0{return _ddea ,_gagg ;};_abcg :=_gc .Path {Points :[]_gc .Point {_gc .NewPoint (0,0).Rotate (_cdac ),_gc .NewPoint (_ddea ,0).Rotate (_cdac ),_gc .NewPoint (0,_gagg ).Rotate (_cdac ),_gc .NewPoint (_ddea ,_gagg ).Rotate (_cdac )}}.GetBoundingBox ();return _abcg .Width ,_abcg .Height ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_bcfc *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebbc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agda ,_ ,_aeca :=_bcfc .draw ("");_aeca =_ebbc .addContentsByString (string (_agda ));if _aeca !=nil {return nil ,ctx ,_aeca ;};return []*Block {_ebbc },ctx ,nil ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_fcgf *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfbf :=_gc .Circle {X :_fcgf ._afg -_fcgf ._geegc /2,Y :ctx .PageHeight -_fcgf ._cfcd -_fcgf ._edcf /2,Width :_fcgf ._geegc ,Height :_fcgf ._edcf ,Opacity :1.0,BorderWidth :_fcgf ._bdf };if _fcgf ._bfcce !=nil {_bfbf .FillEnabled =true ;_bfbf .FillColor =_fcgf ._bfcce ;};if _fcgf ._gddg !=nil {_bfbf .BorderEnabled =true ;_bfbf .BorderColor =_fcgf ._gddg ;_bfbf .BorderWidth =_fcgf ._bdf ;};_gbab ,_ ,_fged :=_bfbf .Draw ("");if _fged !=nil {return nil ,ctx ,_fged ;};_fged =_cgb .addContentsByString (string (_gbab ));if _fged !=nil {return nil ,ctx ,_fged ;};return []*Block {_cgb },ctx ,nil ;};func (_gdcbd *Invoice )drawInformation ()*Table {_adde :=_fcfa (2);_fbaa :=append ([][2]*InvoiceCell {_gdcbd ._effc ,_gdcbd ._babe ,_gdcbd ._bac },_gdcbd ._eaf ...);for _ ,_ffga :=range _fbaa {_fgd ,_ggab :=_ffga [0],_ffga [1];if _ggab .Value ==""{continue ;};_cegg :=_adde .NewCell ();_cegg .SetBackgroundColor (_fgd .BackgroundColor );_gdcbd .setCellBorder (_cegg ,_fgd );_cbbde :=_afae (_fgd .TextStyle );_cbbde .Append (_fgd .Value );_cbbde .SetMargins (0,0,2,1);_cegg .SetContent (_cbbde );_cegg =_adde .NewCell ();_cegg .SetBackgroundColor (_ggab .BackgroundColor );_gdcbd .setCellBorder (_cegg ,_ggab );_cbbde =_afae (_ggab .TextStyle );_cbbde .Append (_ggab .Value );_cbbde .SetMargins (0,0,2,1);_cegg .SetContent (_cbbde );};return _adde ;};func _egag (_gded ,_fbab TextStyle )*Invoice {_begea :=&Invoice {_adbee :"\u0049N\u0056\u004f\u0049\u0043\u0045",_aef :"\u002c\u0020",_dfdf :_gded ,_dfcfe :_fbab };_begea ._fcd =&InvoiceAddress {Separator :_begea ._aef };_begea ._deea =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_begea ._aef };_ggcf :=ColorRGBFrom8bit (245,245,245);_facd :=ColorRGBFrom8bit (155,155,155);_begea ._fcab =_fbab ;_begea ._fcab .Color =_facd ;_begea ._fcab .FontSize =20;_begea ._dfbf =_gded ;_begea ._gcbg =_fbab ;_begea ._ecccg =_gded ;_begea ._ddgb =_fbab ;_begea ._cdeg =_begea .NewCellProps ();_begea ._cdeg .BackgroundColor =_ggcf ;_begea ._cdeg .TextStyle =_fbab ;_begea ._beaa =_begea .NewCellProps ();_begea ._beaa .TextStyle =_fbab ;_begea ._beaa .BackgroundColor =_ggcf ;_begea ._beaa .BorderColor =_ggcf ;_begea ._aedd =_begea .NewCellProps ();_begea ._aedd .BorderColor =_ggcf ;_begea ._aedd .BorderSides =[]CellBorderSide {CellBorderSideBottom };_begea ._aedd .Alignment =CellHorizontalAlignmentRight ;_begea ._bffe =_begea .NewCellProps ();_begea ._bffe .Alignment =CellHorizontalAlignmentRight ;_begea ._effc =[2]*InvoiceCell {_begea .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_begea ._cdeg ),_begea .newCell ("",_begea ._cdeg )};_begea ._babe =[2]*InvoiceCell {_begea .newCell ("\u0044\u0061\u0074\u0065",_begea ._cdeg ),_begea .newCell ("",_begea ._cdeg )};_begea ._bac =[2]*InvoiceCell {_begea .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_begea ._cdeg ),_begea .newCell ("",_begea ._cdeg )};_begea ._aed =[2]*InvoiceCell {_begea .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_begea ._bffe ),_begea .newCell ("",_begea ._bffe )};_aggd :=_begea ._bffe ;_aggd .TextStyle =_fbab ;_aggd .BackgroundColor =_ggcf ;_aggd .BorderColor =_ggcf ;_begea ._aagd =[2]*InvoiceCell {_begea .newCell ("\u0054\u006f\u0074a\u006c",_aggd ),_begea .newCell ("",_aggd )};_begea ._aea =[2]string {"\u004e\u006f\u0074e\u0073",""};_begea ._agge =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_begea ._cegd =[]*InvoiceCell {_begea .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_begea .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_begea .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_begea .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _begea ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_ecbga *Invoice )TotalLines ()[][2]*InvoiceCell {_gggb :=[][2]*InvoiceCell {_ecbga ._aed };_gggb =append (_gggb ,_ecbga ._gfef ...);return append (_gggb ,_ecbga ._aagd );};

// SetFillColor sets the fill color.
func (_deee *Rectangle )SetFillColor (col Color ){_deee ._fceg =_ga .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_dcea *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _aabd (x ,y ,width ,height );};

// NewList creates a new list.
func (_dbcc *Creator )NewList ()*List {return _bcff (_dbcc .NewTextStyle ())};

// SetSellerAddress sets the seller address of the invoice.
func (_bbee *Invoice )SetSellerAddress (address *InvoiceAddress ){_bbee ._fcd =address };func (_cgcd *StyledParagraph )getTextLineWidth (_dagfe []*TextChunk )float64 {var _fdde float64 ;_ggabe :=len (_dagfe );for _fedb ,_aaag :=range _dagfe {_degc :=&_aaag .Style ;_daaf :=len (_aaag .Text );for _cgca ,_caaaf :=range _aaag .Text {if _caaaf =='\u000A'{continue ;};_cacaf ,_gccfc :=_degc .Font .GetRuneMetrics (_caaaf );if !_gccfc {_d .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_caaaf );return -1;};_fdde +=_degc .FontSize *_cacaf .Wx ;if _caaaf !=' '&&(_fedb !=_ggabe -1||_cgca !=_daaf -1){_fdde +=_degc .CharSpacing *1000.0;};};};return _fdde ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_ggb *Block )SetPos (x ,y float64 ){_ggb ._ea =_eeae ;_ggb ._eg =x ;_ggb ._gcc =y };

// MoveX moves the drawing context to absolute position x.
func (_cfed *Creator )MoveX (x float64 ){_cfed ._bgac .X =x };

// Height returns the height of the list.
func (_dca *List )Height ()float64 {var _dfef float64 ;for _ ,_fdbe :=range _dca ._fecab {_dfef +=_fdbe ._cfaca .Height ();};return _dfef ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_eaef *Creator )NewPage ()*_ga .PdfPage {_ggba :=_eaef .newPage ();_eaef ._edg =append (_eaef ._edg ,_ggba );_eaef ._bgac .Page ++;return _ggba ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_afg float64 ;_cfcd float64 ;_geegc float64 ;_edcf float64 ;_bfcce *_ga .PdfColorDeviceRGB ;_gddg *_ga .PdfColorDeviceRGB ;_bdf float64 ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_aa *Block )ScaleToWidth (w float64 ){_cdc :=w /_aa ._cfe ;_aa .Scale (_cdc ,_cdc )};

// GetRowHeight returns the height of the specified row.
func (_gfgec *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_gfgec ._cefdb ){return 0,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _gfgec ._cefdb [row -1],nil ;};

// SetTitle sets the title of the invoice.
func (_acfd *Invoice )SetTitle (title string ){_acfd ._adbee =title };

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_egda *Chapter )GetHeading ()*Paragraph {return _egda ._eadd };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_fdd *Creator )SetPageLabels (pageLabels _cad .PdfObject ){_fdd ._dccb =pageLabels };

// SetStyleLeft sets border style for left side.
func (_fga *border )SetStyleLeft (style CellBorderStyle ){_fga ._cbg =style };

// SetAngle sets the rotation angle of the text.
func (_fcfb *StyledParagraph )SetAngle (angle float64 ){_fcfb ._efcf =angle };

// Indent returns the left offset of the list when nested into another list.
func (_ageac *List )Indent ()float64 {return _ageac ._bcbf };func _fceaf (_adegd *_ga .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_adegd ,FontSize :10};};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ecaac *TOC )SetLineTitleStyle (style TextStyle ){_ecaac ._bgge =style };

// SetAngle sets Image rotation angle in degrees.
func (_dede *Image )SetAngle (angle float64 ){_dede ._bbeg =angle };

// SetShowLinks sets visibility of links for the TOC lines.
func (_cdedcd *TOC )SetShowLinks (showLinks bool ){_cdedcd ._fbgc =showLinks };

// InsertColumn inserts a column in the line items table at the specified index.
func (_cgbc *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_edfce :=uint (len (_cgbc ._cegd ));if index > _edfce {index =_edfce ;};_bcc :=_cgbc .NewColumn (description );_cgbc ._cegd =append (_cgbc ._cegd [:index ],append ([]*InvoiceCell {_bcc },_cgbc ._cegd [index :]...)...);return _bcc ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_fbce *TOC )SetLineStyle (style TextStyle ){_fbce .SetLineNumberStyle (style );_fbce .SetLineTitleStyle (style );_fbce .SetLineSeparatorStyle (style );_fbce .SetLinePageStyle (style );};func (_efbg *StyledParagraph )getLineHeight (_efdf int )(_dcad ,_gdbf float64 ){if _efbg ._edac ==nil ||len (_efbg ._edac )==0{_efbg .wrapText ();};if _efdf < 0||_efdf > len (_efbg ._edac )-1{_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_efdf );return 0,0;};_fffdf :=_efbg ._edac [_efdf ];for _ ,_bcee :=range _fffdf {_dgecc ,_facac :=_bcee .Style .Font .GetFontDescriptor ();if _facac !=nil {_d .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _fccd float64 ;if _dgecc !=nil {if _fccd ,_facac =_dgecc .GetCapHeight ();_facac !=nil {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_facac );};};if int (_fccd )<=0{_d .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_fccd =1000;};_cefa :=_fccd /1000.0*_bcee .Style .FontSize *_efbg ._bgdg ;if _cefa > _dcad {_dcad =_cefa ;};_cefa =_efbg ._bgdg *_bcee .Style .FontSize ;if _cefa > _gdbf {_gdbf =_cefa ;};};return _dcad ,_gdbf ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_gbgdd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_gbgdd ._dec =toc ;};func (_dbe *Creator )newPage ()*_ga .PdfPage {_ecdg :=_ga .NewPdfPage ();_add :=_dbe ._egfa [0];_gecg :=_dbe ._egfa [1];_ccca :=_ga .PdfRectangle {Llx :0,Lly :0,Urx :_add ,Ury :_gecg };_ecdg .MediaBox =&_ccca ;_dbe ._dbag =_add ;_dbe ._ffd =_gecg ;_dbe .initContext ();return _ecdg ;};func _fbcdf (_bccbb string ,_gdbg ,_gbba TextStyle )*TOC {_facbb :=_gbba ;_facbb .FontSize =14;_decg :=_afae (_facbb );_decg .SetEnableWrap (true );_decg .SetTextAlignment (TextAlignmentLeft );_decg .SetMargins (0,0,0,5);_fgfcf :=_decg .Append (_bccbb );_fgfcf .Style =_facbb ;return &TOC {_gcgd :_decg ,_aaae :[]*TOCLine {},_gdfd :_gdbg ,_bgge :_gdbg ,_afac :_gdbg ,_edde :_gdbg ,_cgfdf :"\u002e",_cdeee :10,_edda :margins {0,0,2,2},_ggad :_fabc ,_cabfe :_gdbg ,_fbgc :true };};

// Level returns the indentation level of the TOC line.
func (_bgffd *TOCLine )Level ()uint {return _bgffd ._cagc };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_aeb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_aeb ._aafca =valign };func (_fdea *Invoice )newColumn (_cefe string ,_bggf CellHorizontalAlignment )*InvoiceCell {_aede :=&InvoiceCell {_fdea ._beaa ,_cefe };_aede .Alignment =_bggf ;return _aede ;};

// Columns returns all the columns in the invoice line items table.
func (_gdgd *Invoice )Columns ()[]*InvoiceCell {return _gdgd ._cegd };

// Write output of creator to io.Writer interface.
func (_edfc *Creator )Write (ws _f .Writer )error {if _ebef :=_edfc .Finalize ();_ebef !=nil {return _ebef ;};_cdcc :=_ga .NewPdfWriter ();_cdcc .SetOptimizer (_edfc ._gada );if _edfc ._cgg !=nil {_abdc :=_cdcc .SetForms (_edfc ._cgg );if _abdc !=nil {_d .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_abdc );return _abdc ;};};if _edfc ._fgab !=nil {_cdcc .AddOutlineTree (_edfc ._fgab );}else if _edfc ._gfd !=nil &&_edfc .AddOutlines {_cdcc .AddOutlineTree (&_edfc ._gfd .ToPdfOutline ().PdfOutlineTreeNode );};if _edfc ._dccb !=nil {if _gfbb :=_cdcc .SetPageLabels (_edfc ._dccb );_gfbb !=nil {_d .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_gfbb );return _gfbb ;};};if _edfc ._eag !=nil {for _ ,_cfdg :=range _edfc ._eag {_edgg :=_cfdg .SubsetRegistered ();if _edgg !=nil {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_edgg );return _edgg ;};};};if _edfc ._bbg !=nil {_dbcf :=_edfc ._bbg (&_cdcc );if _dbcf !=nil {_d .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_dbcf );return _dbcf ;};};for _ ,_cbfd :=range _edfc ._edg {_cdab :=_cdcc .AddPage (_cbfd );if _cdab !=nil {_d .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_cdab );return _cdab ;};};_gce :=_cdcc .Write (ws );if _gce !=nil {return _gce ;};return nil ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_bbfd *Table )Width ()float64 {return 0};const (_fabc positioning =iota ;_eeae ;);

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gdcbe *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ecdc :=ctx ;_afcg ,ctx ,_fgecb :=_gdcbe ._gcgd .GeneratePageBlocks (ctx );if _fgecb !=nil {return _afcg ,ctx ,_fgecb ;};for _ ,_dffg :=range _gdcbe ._aaae {_eded :=_dffg ._dged ;if !_gdcbe ._fbgc {_dffg ._dged =0;};_dgdd ,_fagg ,_fafc :=_dffg .GeneratePageBlocks (ctx );_dffg ._dged =_eded ;if _fafc !=nil {return _afcg ,ctx ,_fafc ;};if len (_dgdd )< 1{continue ;};_afcg [len (_afcg )-1].mergeBlocks (_dgdd [0]);_afcg =append (_afcg ,_dgdd [1:]...);ctx =_fagg ;};if _gdcbe ._ggad .isRelative (){ctx .X =_ecdc .X ;};if _gdcbe ._ggad .isAbsolute (){return _afcg ,_ecdc ,nil ;};return _afcg ,ctx ,nil ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_febc *TOCLine )SetLevelOffset (levelOffset float64 ){_febc ._aedde =levelOffset ;_febc ._gfeg ._ebee ._dea =_febc ._egdc +float64 (_febc ._cagc -1)*_febc ._aedde ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_dcga *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfeeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfdbg :=_gc .Rectangle {Opacity :1.0,X :_dcga ._deefa ,Y :ctx .PageHeight -_dcga ._dagf -_dcga ._ffbf ,Height :_dcga ._ffbf ,Width :_dcga ._bcgfb };if _dcga ._fceg !=nil {_dfdbg .FillEnabled =true ;_dfdbg .FillColor =_dcga ._fceg ;};if _dcga ._gace !=nil &&_dcga ._eaba > 0{_dfdbg .BorderEnabled =true ;_dfdbg .BorderColor =_dcga ._gace ;_dfdbg .BorderWidth =_dcga ._eaba ;};_gbeg ,_ ,_cadg :=_dfdbg .Draw ("");if _cadg !=nil {return nil ,ctx ,_cadg ;};_cadg =_cfeeb .addContentsByString (string (_gbeg ));if _cadg !=nil {return nil ,ctx ,_cadg ;};return []*Block {_cfeeb },ctx ,nil ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_bbdc *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_ebcd :=NewTextChunk (text ,_bbdc ._fgace );_ebcd ._gbbg =_dedg (url );return _bbdc .appendChunk (_ebcd );};

// Text sets the text content of the Paragraph.
func (_accc *Paragraph )Text ()string {return _accc ._dgea };func (_dggb *Table )resetColumnWidths (){_dggb ._agae =[]float64 {};_fedff :=float64 (1.0)/float64 (_dggb ._ggag );for _badd :=0;_badd < _dggb ._ggag ;_badd ++{_dggb ._agae =append (_dggb ._agae ,_fedff );};};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_fgbc *Creator )SetOptimizer (optimizer _ga .Optimizer ){_fgbc ._gada =optimizer };

// Add adds a new Drawable to the chapter.
func (_fgae *Chapter )Add (d Drawable )error {if Drawable (_fgae )==d {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_fgae ._dfg =append (_fgae ._dfg ,d );default:_d .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_bedg *Image )GetHorizontalAlignment ()HorizontalAlignment {return _bedg ._bceag };func (_bcgec *StyledParagraph )wrapText ()error {if !_bcgec ._cdec ||int (_bcgec ._gdff )<=0{_bcgec ._edac =[][]*TextChunk {_bcgec ._facc };return nil ;};_bcgec ._edac =[][]*TextChunk {};var _gdde []*TextChunk ;var _cccag float64 ;_gebd :=func (_dcgd *_ga .PdfAnnotation )*_ga .PdfAnnotation {if _dcgd ==nil {return nil ;};var _bgcg *_ga .PdfAnnotation ;switch _afcb :=_dcgd .GetContext ().(type ){case *_ga .PdfAnnotationLink :if _adcge :=_fdcf (_afcb );_adcge !=nil {_bgcg =_adcge .PdfAnnotation ;};};return _bgcg ;};for _ ,_fdgb :=range _bcgec ._facc {_afbf :=_fdgb .Style ;_geegf :=_fdgb ._gbbg ;var (_ffcea []rune ;_cdgb []float64 ;);for _ ,_eagg :=range _fdgb .Text {if _eagg =='\u000A'{_gdde =append (_gdde ,&TextChunk {Text :_ca .TrimRightFunc (string (_ffcea ),_fa .IsSpace ),Style :_afbf ,_gbbg :_gebd (_geegf )});_bcgec ._edac =append (_bcgec ._edac ,_gdde );_gdde =nil ;_cccag =0;_ffcea =nil ;_cdgb =nil ;continue ;};_fcaf :=_eagg ==' ';_gcbb ,_gafge :=_afbf .Font .GetRuneMetrics (_eagg );if !_gafge {_d .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_eagg );return _c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_ccfge :=_afbf .FontSize *_gcbb .Wx ;_aadae :=_ccfge ;if !_fcaf {_aadae =_ccfge +_afbf .CharSpacing *1000.0;};if _cccag +_ccfge > _bcgec ._gdff *1000.0{_gbbb :=-1;if !_fcaf {for _gfefd :=len (_ffcea )-1;_gfefd >=0;_gfefd --{if _ffcea [_gfefd ]==' '{_gbbb =_gfefd ;break ;};};};_gagbg :=string (_ffcea );if _gbbb >=0{_gagbg =string (_ffcea [0:_gbbb +1]);_ffcea =_ffcea [_gbbb +1:];_ffcea =append (_ffcea ,_eagg );_cdgb =_cdgb [_gbbb +1:];_cdgb =append (_cdgb ,_aadae );_cccag =0;for _ ,_bacc :=range _cdgb {_cccag +=_bacc ;};}else {if _fcaf {_cccag =0;_ffcea =[]rune {};_cdgb =[]float64 {};}else {_cccag =_aadae ;_ffcea =[]rune {_eagg };_cdgb =[]float64 {_aadae };};};_gdde =append (_gdde ,&TextChunk {Text :_ca .TrimRightFunc (string (_gagbg ),_fa .IsSpace ),Style :_afbf ,_gbbg :_gebd (_geegf )});_bcgec ._edac =append (_bcgec ._edac ,_gdde );_gdde =[]*TextChunk {};}else {_cccag +=_aadae ;_ffcea =append (_ffcea ,_eagg );_cdgb =append (_cdgb ,_aadae );};};if len (_ffcea )> 0{_gdde =append (_gdde ,&TextChunk {Text :string (_ffcea ),Style :_afbf ,_gbbg :_gebd (_geegf )});};};if len (_gdde )> 0{_bcgec ._edac =append (_bcgec ._edac ,_gdde );};return nil ;};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_acae *Rectangle )GetCoords ()(float64 ,float64 ){return _acae ._deefa ,_acae ._dagf };

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_fdee *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _geda (x1 ,y1 ,x2 ,y2 )};

// SetWidthRight sets border width for right.
func (_fbeb *border )SetWidthRight (bw float64 ){_fbeb ._fac =bw };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_fbfe *Invoice )NoteStyle ()TextStyle {return _fbfe ._ecccg };

// Context returns the current drawing context.
func (_ddb *Creator )Context ()DrawContext {return _ddb ._bgac };

// SetWidthBottom sets border width for bottom.
func (_fcb *border )SetWidthBottom (bw float64 ){_fcb ._ebca =bw };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aace *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aace ._gfed ._dea ,_aace ._gfed ._aaf ,_aace ._gfed ._bdbd ,_aace ._gfed ._bgb ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_gfecc *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_gfecc ._bceag =alignment };