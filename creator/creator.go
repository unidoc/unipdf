//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_b "bytes";_f "errors";_ae "fmt";_ca "github.com/unidoc/unipdf/v3/common";_eff "github.com/unidoc/unipdf/v3/contentstream";_bd "github.com/unidoc/unipdf/v3/contentstream/draw";_ce "github.com/unidoc/unipdf/v3/core";_ef "github.com/unidoc/unipdf/v3/internal/license";
_ee "github.com/unidoc/unipdf/v3/internal/transform";_ffb "github.com/unidoc/unipdf/v3/model";_c "image";_e "io";_bf "math";_fa "os";_ff "sort";_af "strconv";_aff "strings";_g "unicode";);

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_eeee *Chapter )SetIncludeInTOC (includeInTOC bool ){_eeee ._cacf =includeInTOC };func (_fefa *Table )newCell (_faeb int )*TableCell {_fefa ._ecced ++;_cfgc :=(_fefa ._ecced -1)/_fefa ._dgdba +1;for _cfgc > _fefa ._cdeg {_fefa ._cdeg ++;_fefa ._egcc =append (_fefa ._egcc ,_fefa ._ebgeb );
};_baadf :=(_fefa ._ecced -1)%(_fefa ._dgdba )+1;_ccff :=&TableCell {};_ccff ._aadbf =_cfgc ;_ccff ._ggcga =_baadf ;_ccff ._cdfg =1;_ccff ._decca =5;_ccff ._abde =CellBorderStyleNone ;_ccff ._eabff =_bd .LineStyleSolid ;_ccff ._bedb =CellHorizontalAlignmentLeft ;
_ccff ._eabab =CellVerticalAlignmentTop ;_ccff ._cfddg =0;_ccff ._ecae =0;_ccff ._gbcd =0;_ccff ._fdgc =0;_fdbag :=ColorBlack ;_ccff ._fegc =_fdbag ;_ccff ._gcac =_fdbag ;_ccff ._afdf =_fdbag ;_ccff ._ggecc =_fdbag ;if _faeb < 1{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_faeb );
_faeb =1;};_babdd :=_fefa ._dgdba -(_ccff ._ggcga -1);if _faeb > _babdd {_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_faeb ,_babdd );
_faeb =_babdd ;};_ccff ._dbfgc =_faeb ;_fefa ._ecced +=_faeb -1;_fefa ._cfcg =append (_fefa ._cfcg ,_ccff );_ccff ._afee =_fefa ;return _ccff ;};func (_bacg *Invoice )generateTotalBlocks (_gedb DrawContext )([]*Block ,DrawContext ,error ){_fbefe :=_cgcge (4);
_fbefe .SetMargins (0,0,10,10);_aaabb :=[][2]*InvoiceCell {_bacg ._aegb };_aaabb =append (_aaabb ,_bacg ._bcc ...);_aaabb =append (_aaabb ,_bacg ._gebb );for _ ,_ggfgc :=range _aaabb {_bede ,_ggec :=_ggfgc [0],_ggfgc [1];if _ggec .Value ==""{continue ;
};_fbefe .SkipCells (2);_caeeb :=_fbefe .NewCell ();_caeeb .SetBackgroundColor (_bede .BackgroundColor );_caeeb .SetHorizontalAlignment (_ggec .Alignment );_bacg .setCellBorder (_caeeb ,_bede );_faeg :=_ebgd (_bede .TextStyle );_faeg .SetMargins (0,0,2,1);
_faeg .Append (_bede .Value );_caeeb .SetContent (_faeg );_caeeb =_fbefe .NewCell ();_caeeb .SetBackgroundColor (_ggec .BackgroundColor );_caeeb .SetHorizontalAlignment (_ggec .Alignment );_bacg .setCellBorder (_caeeb ,_bede );_faeg =_ebgd (_ggec .TextStyle );
_faeg .SetMargins (0,0,2,1);_faeg .Append (_ggec .Value );_caeeb .SetContent (_faeg );};return _fbefe .GeneratePageBlocks (_gedb );};

// Height returns the total height of all rows.
func (_gafc *Table )Height ()float64 {_ebcc :=float64 (0.0);for _ ,_dfdc :=range _gafc ._egcc {_ebcc +=_dfdc ;};return _ebcc ;};func _egd (_bgad string ,_egg _ce .PdfObject ,_baae *_ffb .PdfPageResources )_ce .PdfObjectName {_cca :=_aff .TrimRightFunc (_aff .TrimSpace (_bgad ),func (_fdc rune )bool {return _g .IsNumber (_fdc )});
if _cca ==""{_cca ="\u0046\u006f\u006e\u0074";};_ddg :=0;_ddba :=_ce .PdfObjectName (_bgad );for {_ega ,_ggf :=_baae .GetFontByName (_ddba );if !_ggf ||_ega ==_egg {break ;};_ddg ++;_ddba =_ce .PdfObjectName (_ae .Sprintf ("\u0025\u0073\u0025\u0064",_cca ,_ddg ));
};return _ddba ;};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_cfdcf *Rectangle )GetCoords ()(float64 ,float64 ){return _cfdcf ._afgf ,_cfdcf ._dccg };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_dbeda *TOC )SetLineTitleStyle (style TextStyle ){_dbeda ._bdbg =style };

// TOC returns the table of contents component of the creator.
func (_abec *Creator )TOC ()*TOC {return _abec ._fag };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_afeb *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_dage *_ffb .PdfWriter )error ){_afeb ._dgf =pdfWriterAccessFunc ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_fcfb :_bf .Max (_bf .Min (c ,1.0),0.0),_agd :_bf .Max (_bf .Min (m ,1.0),0.0),_gea :_bf .Max (_bf .Min (y ,1.0),0.0),_efa :_bf .Max (_bf .Min (k ,1.0),0.0)};};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_bbdbg *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdgf :=_bbdbg ;if _bbdbg ._fcda {_bdgf =_bbdbg .clone ();};return _ffgdd (_bdgf ,ctx );};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_aeeg *_bd .Polyline ;_edef float64 ;};

// Inline returns whether the inline mode of the division is active.
func (_efgd *Division )Inline ()bool {return _efgd ._gefg };

// SetMargins sets the margins TOC line.
func (_eaege *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_eaege ._fdbdb =left ;_afaaf :=&_eaege ._cbbgg ._abed ;_afaaf .Left =_eaege ._fdbdb +float64 (_eaege ._bedc -1)*_eaege ._cecg ;_afaaf .Right =right ;_afaaf .Top =top ;_afaaf .Bottom =bottom ;
};

// NewChapter creates a new chapter with the specified title as the heading.
func (_gbfc *Creator )NewChapter (title string )*Chapter {_gbfc ._gbb ++;_dbd :=_gbfc .NewTextStyle ();_dbd .FontSize =16;return _dee (nil ,_gbfc ._fag ,_gbfc ._dge ,title ,_gbfc ._gbb ,_dbd );};

// NewList creates a new list.
func (_cdeb *Creator )NewList ()*List {return _ecce (_cdeb .NewTextStyle ())};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// MoveX moves the drawing context to absolute position x.
func (_ggfe *Creator )MoveX (x float64 ){_ggfe ._acag .X =x };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ggef *Creator )SetPageLabels (pageLabels _ce .PdfObject ){_ggef ._fagc =pageLabels };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_gccb *Creator )Finalize ()error {if _gccb ._gfgfa {return nil ;};_baab :=len (_gccb ._aca );_dade :=0;if _gccb ._edg !=nil {_dade ++;};if _gccb .AddTOC {_gccb .initContext ();_gccb ._acag .Page =_dade +1;if _gccb ._dgaf !=nil {if _aee :=_gccb ._dgaf (_gccb ._fag );
_aee !=nil {return _aee ;};};_egdd ,_ ,_ebbba :=_gccb ._fag .GeneratePageBlocks (_gccb ._acag );if _ebbba !=nil {_ca .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_ebbba );
return _ebbba ;};_dade +=len (_egdd );_cebd :=_gccb ._fag .Lines ();for _ ,_bdag :=range _cebd {_cbeef ,_gfee :=_af .Atoi (_bdag .Page .Text );if _gfee !=nil {continue ;};_bdag .Page .Text =_af .Itoa (_cbeef +_dade );};};_bbffe :=false ;if _gccb ._edg !=nil {_baab ++;
_bfbf :=_gccb .newPage ();_gccb ._aca =append ([]*_ffb .PdfPage {_bfbf },_gccb ._aca ...);_gccb .setActivePage (_bfbf );_aaff :=FrontpageFunctionArgs {PageNum :1,TotalPages :_baab };_gccb ._edg (_aaff );_bbffe =true ;};var _ggb []*_ffb .PdfPage ;if _gccb .AddTOC {_gccb .initContext ();
if _gccb ._dgaf !=nil {if _bddb :=_gccb ._dgaf (_gccb ._fag );_bddb !=nil {_ca .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bddb );return _bddb ;};
};_afde :=_gccb ._fag .Lines ();for _ ,_eafe :=range _afde {_eafe ._ddbf +=int64 (_dade );};_ecgbe ,_ ,_ :=_gccb ._fag .GeneratePageBlocks (_gccb ._acag );for _ ,_badb :=range _ecgbe {_badb .SetPos (0,0);_baab ++;_add :=_gccb .newPage ();_ggb =append (_ggb ,_add );
_gccb .setActivePage (_add );_gccb .Draw (_badb );};if _bbffe {_abecc :=_gccb ._aca [0];_cce :=_gccb ._aca [1:];_gccb ._aca =append ([]*_ffb .PdfPage {_abecc },_ggb ...);_gccb ._aca =append (_gccb ._aca ,_cce ...);}else {_gccb ._aca =append (_ggb ,_gccb ._aca ...);
};};if _gccb ._dge !=nil &&_gccb .AddOutlines {var _ggcg func (_cbdc *_ffb .OutlineItem );_ggcg =func (_dea *_ffb .OutlineItem ){_dea .Dest .Page +=int64 (_dade );if _bfbd :=int (_dea .Dest .Page );_bfbd >=0&&_bfbd < len (_gccb ._aca ){_dea .Dest .PageObj =_gccb ._aca [_bfbd ].GetPageAsIndirectObject ();
}else {_ca .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bfbd );
};_dea .Dest .Y =_gccb ._bbeg -_dea .Dest .Y ;_aeg :=_dea .Items ();for _ ,_dcbe :=range _aeg {_ggcg (_dcbe );};};_aefg :=_gccb ._dge .Items ();for _ ,_bfbfe :=range _aefg {_ggcg (_bfbfe );};if _gccb .AddTOC {var _aagb int ;if _bbffe {_aagb =1;};_bce :=_ffb .NewOutlineDest (int64 (_aagb ),0,_gccb ._bbeg );
if _aagb >=0&&_aagb < len (_gccb ._aca ){_bce .PageObj =_gccb ._aca [_aagb ].GetPageAsIndirectObject ();}else {_ca .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_aagb );
};_gccb ._dge .Insert (0,_ffb .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_bce ));};};for _egeg ,_agb :=range _gccb ._aca {_gccb .setActivePage (_agb );if _gccb ._beba !=nil {_geag ,_acea ,_aebd :=_agb .Size ();
if _aebd !=nil {return _aebd ;};_gbd :=PageFinalizeFunctionArgs {PageNum :_egeg +1,PageWidth :_geag ,PageHeight :_acea ,TOCPages :len (_ggb ),TotalPages :_baab };if _afag :=_gccb ._beba (_gbd );_afag !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_afag );
return _afag ;};};if _gccb ._gdb !=nil {_cgc :=NewBlock (_gccb ._bddd ,_gccb ._bbe .Top );_cgf :=HeaderFunctionArgs {PageNum :_egeg +1,TotalPages :_baab };_gccb ._gdb (_cgc ,_cgf );_cgc .SetPos (0,0);if _bgae :=_gccb .Draw (_cgc );_bgae !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_bgae );
return _bgae ;};};if _gccb ._efd !=nil {_beg :=NewBlock (_gccb ._bddd ,_gccb ._bbe .Bottom );_eec :=FooterFunctionArgs {PageNum :_egeg +1,TotalPages :_baab };_gccb ._efd (_beg ,_eec );_beg .SetPos (0,_gccb ._bbeg -_beg ._afb );if _fdbb :=_gccb .Draw (_beg );
_fdbb !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_fdbb );return _fdbb ;};};_ddcf ,_aggb :=_gccb ._gfgf [_agb ];if !_aggb {continue ;};if _degb ,_ecaa :=_gccb ._efae [_agb ];
_ecaa {_ddcf .transform (_degb );};if _aabf :=_ddcf .drawToPage (_agb );_aabf !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_egeg +1,_aabf );
return _aabf ;};};_gccb ._gfgfa =true ;return nil ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_aca []*_ffb .PdfPage ;_gfgf map[*_ffb .PdfPage ]*Block ;_efae map[*_ffb .PdfPage ]_ee .Matrix ;_ecc *_ffb .PdfPage ;_fga PageSize ;_acag DrawContext ;_bbe Margins ;_bddd ,_bbeg float64 ;_gbb int ;_edg func (_bbea FrontpageFunctionArgs );
_dgaf func (_aba *TOC )error ;_gdb func (_bagg *Block ,_gfa HeaderFunctionArgs );_efd func (_dfea *Block ,_ccga FooterFunctionArgs );_beba func (_fbgdd PageFinalizeFunctionArgs )error ;_dgf func (_gece *_ffb .PdfWriter )error ;_gfgfa bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_fag *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_dge *_ffb .Outline ;_fdca *_ffb .PdfOutlineTreeNode ;_fcgec *_ffb .PdfAcroForm ;_fagc _ce .PdfObject ;_ade _ffb .Optimizer ;_becc []*_ffb .PdfFont ;_dbc *_ffb .PdfFont ;_ecgc *_ffb .PdfFont ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_caea *Creator )NewPage ()*_ffb .PdfPage {_fbacg :=_caea .newPage ();_caea ._aca =append (_caea ._aca ,_fbacg );_caea ._acag .Page ++;return _fbacg ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_efag *Invoice )SetAddressStyle (style TextStyle ){_efag ._bgec =style };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_ddfd *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_ddfd ._fgdf .Left =left ;_ddfd ._fgdf .Right =right ;_ddfd ._fgdf .Top =top ;_ddfd ._fgdf .Bottom =bottom ;};

// SetMargins sets the margins of the paragraph.
func (_bagd *List )SetMargins (left ,right ,top ,bottom float64 ){_bagd ._ggde .Left =left ;_bagd ._ggde .Right =right ;_bagd ._ggde .Top =top ;_bagd ._ggde .Bottom =bottom ;};

// AddSection adds a new content section at the end of the invoice.
func (_fbba *Invoice )AddSection (title ,content string ){_fbba ._fbaf =append (_fbba ._fbaf ,[2]string {title ,content });};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_facgd *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_caaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_edfbc ,_fgdcb :=_caaf .setOpacity (_facgd ._edef ,_facgd ._edef );if _fgdcb !=nil {return nil ,ctx ,_fgdcb ;
};_cceaf :=_facgd ._aeeg .Points ;for _fedc :=range _cceaf {_cdaa :=&_cceaf [_fedc ];_cdaa .Y =ctx .PageHeight -_cdaa .Y ;};_acac ,_ ,_fgdcb :=_facgd ._aeeg .Draw (_edfbc );if _fgdcb !=nil {return nil ,ctx ,_fgdcb ;};if _fgdcb =_caaf .addContentsByString (string (_acac ));
_fgdcb !=nil {return nil ,ctx ,_fgdcb ;};return []*Block {_caaf },ctx ,nil ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_cggd *Line )SetColor (col Color ){_cggd ._daa =col };

// Columns returns all the columns in the invoice line items table.
func (_eeed *Invoice )Columns ()[]*InvoiceCell {return _eeed ._fbdb };func (_ead *Creator )initContext (){_ead ._acag .X =_ead ._bbe .Left ;_ead ._acag .Y =_ead ._bbe .Top ;_ead ._acag .Width =_ead ._bddd -_ead ._bbe .Right -_ead ._bbe .Left ;_ead ._acag .Height =_ead ._bbeg -_ead ._bbe .Bottom -_ead ._bbe .Top ;
_ead ._acag .PageHeight =_ead ._bbeg ;_ead ._acag .PageWidth =_ead ._bddd ;_ead ._acag .Margins =_ead ._bbe ;};

// NewTable create a new Table with a specified number of columns.
func (_ecag *Creator )NewTable (cols int )*Table {return _cgcge (cols )};

// SetStyleLeft sets border style for left side.
func (_bge *border )SetStyleLeft (style CellBorderStyle ){_bge ._ggd =style };

// SetBorderColor sets the border color.
func (_ffca *Ellipse )SetBorderColor (col Color ){_ffca ._cecfd =col };

// SetMargins sets the Paragraph's margins.
func (_gbdag *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_gbdag ._abeae .Left =left ;_gbdag ._abeae .Right =right ;_gbdag ._abeae .Top =top ;_gbdag ._abeae .Bottom =bottom ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_aea :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _aea ;
};var _agdb ,_ecea ,_ddc int ;if len (hexStr )==4{var _cgb ,_aef ,_ceag int ;_ggac ,_cffc :=_ae .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_cgb ,&_aef ,&_ceag );if _cffc !=nil {_ca .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_cffc );
return _aea ;};if _ggac !=3{_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _aea ;};_agdb =_cgb *16+_cgb ;_ecea =_aef *16+_aef ;_ddc =_ceag *16+_ceag ;}else {_bdgda ,_gfc :=_ae .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_agdb ,&_ecea ,&_ddc );
if _gfc !=nil {_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _aea ;};if _bdgda !=3{_ca .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bdgda );
return _aea ;};};_egfa :=float64 (_agdb )/255.0;_bgb :=float64 (_ecea )/255.0;_gfg :=float64 (_ddc )/255.0;_aea ._deb =_egfa ;_aea ._cfbd =_bgb ;_aea ._feaf =_gfg ;return _aea ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_dc *Block )AddAnnotation (annotation *_ffb .PdfAnnotation ){for _ ,_eef :=range _dc ._fbb {if _eef ==annotation {return ;};};_dc ._fbb =append (_dc ._fbb ,annotation );};func (_baefb *Invoice )generateHeaderBlocks (_fbec DrawContext )([]*Block ,DrawContext ,error ){_gdde :=_ebgd (_baefb ._gdca );
_gdde .SetEnableWrap (true );_gdde .Append (_baefb ._dbe );_adfbg :=_cgcge (2);if _baefb ._adcf !=nil {_bcca :=_adfbg .NewCell ();_bcca .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bcca .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bcca .SetIndent (0);
_bcca .SetContent (_baefb ._adcf );_baefb ._adcf .ScaleToHeight (_gdde .Height ()+20);}else {_adfbg .SkipCells (1);};_eaee :=_adfbg .NewCell ();_eaee .SetHorizontalAlignment (CellHorizontalAlignmentRight );_eaee .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_eaee .SetContent (_gdde );return _adfbg .GeneratePageBlocks (_fbec );};

// DrawWithContext draws the Block using the specified drawing context.
func (_dg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_gaa ,_ ,_bec :=d .GeneratePageBlocks (ctx );if _bec !=nil {return _bec ;};if len (_gaa )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_gbf :=range _gaa {if _effd :=_dg .mergeBlocks (_gbf );_effd !=nil {return _effd ;};};return nil ;};

// SetMargins sets the Paragraph's margins.
func (_gdfe *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_gdfe ._abed .Left =left ;_gdfe ._abed .Right =right ;_gdfe ._abed .Top =top ;_gdfe ._abed .Bottom =bottom ;};

// Height returns the current page height.
func (_faea *Creator )Height ()float64 {return _faea ._bbeg };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_gafcd *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_ccdfa :=&_gafcd ._cbbgg ._abed ;return _gafcd ._fdbdb ,_ccdfa .Right ,_ccdfa .Top ,_ccdfa .Bottom ;};

// SkipCells skips over a specified number of cells in the table.
func (_bbge *Table )SkipCells (num int ){if num < 0{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_bbge ._ecced +=num ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_cbafd *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_cbafd .Text },nil ;};var _dgcf []string ;var _geac []rune ;var _egfbg float64 ;var _fdda []float64 ;_fdbda :=_cbafd .Style ;for _ ,_caddd :=range _cbafd .Text {if _caddd =='\u000A'{_dgcf =append (_dgcf ,_aff .TrimRightFunc (string (_geac ),_g .IsSpace )+string (_caddd ));
_geac =nil ;_egfbg =0;_fdda =nil ;continue ;};_dfab :=_caddd ==' ';_eccaa ,_gfgec :=_fdbda .Font .GetRuneMetrics (_caddd );if !_gfgec {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_caddd ,_caddd ,_fdbda .Font .BaseFont (),_fdbda .Font .Subtype ());
_ca .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_fdbda .Font );_ca .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_fdbda .Font .Encoder ());return nil ,_f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_edee :=_fdbda .FontSize *_eccaa .Wx ;_bdfb :=_edee ;if !_dfab {_bdfb =_edee +_fdbda .CharSpacing *1000.0;};if _egfbg +_edee > width *1000.0{_gafa :=-1;if !_dfab {for _gaac :=len (_geac )-1;_gaac >=0;_gaac --{if _geac [_gaac ]==' '{_gafa =_gaac ;break ;
};};};_cdege :=string (_geac );if _gafa > 0{_cdege =string (_geac [0:_gafa +1]);_geac =append (_geac [_gafa +1:],_caddd );_fdda =append (_fdda [_gafa +1:],_bdfb );_egfbg =0;for _ ,_dcacc :=range _fdda {_egfbg +=_dcacc ;};}else {if _dfab {_geac =[]rune {};
_fdda =[]float64 {};_egfbg =0;}else {_geac =[]rune {_caddd };_fdda =[]float64 {_bdfb };_egfbg =_bdfb ;};};_dgcf =append (_dgcf ,_aff .TrimRightFunc (_cdege ,_g .IsSpace ));}else {_geac =append (_geac ,_caddd );_egfbg +=_bdfb ;_fdda =append (_fdda ,_bdfb );
};};if len (_geac )> 0{_dgcf =append (_dgcf ,string (_geac ));};return _dgcf ,nil ;};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_fbef *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _aaeg (x ,y ,width ,height );};

// GeneratePageBlocks generates a page break block.
func (_dgdg *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgeec :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_acgc :=ctx ;_acgc .Y =ctx .Margins .Top ;
_acgc .X =ctx .Margins .Left ;_acgc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_acgc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_acgc ;return _dgeec ,ctx ,nil ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_afff *Creator )MoveRight (dx float64 ){_afff ._acag .X +=dx };

// SetStyleTop sets border style for top side.
func (_aedc *border )SetStyleTop (style CellBorderStyle ){_aedc ._bag =style };func (_ffgg *Invoice )drawAddress (_cdff *InvoiceAddress )[]*StyledParagraph {var _ebcf []*StyledParagraph ;if _cdff .Heading !=""{_abad :=_ebgd (_ffgg ._deed );_abad .SetMargins (0,0,0,7);
_abad .Append (_cdff .Heading );_ebcf =append (_ebcf ,_abad );};_bddca :=_ebgd (_ffgg ._bgec );_bddca .SetLineHeight (1.2);_fgdg :=_cdff .Separator ;if _fgdg ==""{_fgdg =_ffgg ._gedf ;};_bcbf :=_cdff .City ;if _cdff .State !=""{if _bcbf !=""{_bcbf +=_fgdg ;
};_bcbf +=_cdff .State ;};if _cdff .Zip !=""{if _bcbf !=""{_bcbf +=_fgdg ;};_bcbf +=_cdff .Zip ;};if _cdff .Name !=""{_bddca .Append (_cdff .Name +"\u000a");};if _cdff .Street !=""{_bddca .Append (_cdff .Street +"\u000a");};if _cdff .Street2 !=""{_bddca .Append (_cdff .Street2 +"\u000a");
};if _bcbf !=""{_bddca .Append (_bcbf +"\u000a");};if _cdff .Country !=""{_bddca .Append (_cdff .Country +"\u000a");};_ecbfa :=_ebgd (_ffgg ._bgec );_ecbfa .SetLineHeight (1.2);_ecbfa .SetMargins (0,0,7,0);if _cdff .Phone !=""{_ecbfa .Append (_cdff .fmtLine (_cdff .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_cdff .HidePhoneLabel ));
};if _cdff .Email !=""{_ecbfa .Append (_cdff .fmtLine (_cdff .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_cdff .HideEmailLabel ));};_ebcf =append (_ebcf ,_bddca ,_ecbfa );return _ebcf ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_baec *Invoice )SetTitleStyle (style TextStyle ){_baec ._gdca =style };func (_efb *Paragraph )wrapText ()error {if !_efb ._ggbe ||int (_efb ._ceae )<=0{_efb ._afgg =[]string {_efb ._ggacg };return nil ;};_babf :=NewTextChunk (_efb ._ggacg ,TextStyle {Font :_efb ._gagd ,FontSize :_efb ._fge });
_fgde ,_egdc :=_babf .Wrap (_efb ._ceae );if _egdc !=nil {return _egdc ;};if _efb ._bbeag > 0&&len (_fgde )> _efb ._bbeag {_fgde =_fgde [:_efb ._bbeag ];};_efb ._afgg =_fgde ;return nil ;};func _fdcca (_abae string ,_feeb TextStyle )*Paragraph {_cedg :=&Paragraph {_ggacg :_abae ,_gagd :_feeb .Font ,_fge :_feeb .FontSize ,_efgdb :1.0,_ggbe :true ,_fedg :true ,_ebfb :TextAlignmentLeft ,_gggb :0,_bggba :1,_edfb :1,_agfce :PositionRelative };
_cedg .SetColor (_feeb .Color );return _cedg ;};func _cagf (_cffg ,_acad ,_eaeb ,_fgcc ,_bdfe ,_fbegb float64 )*Curve {_ggcbf :=&Curve {};_ggcbf ._acb =_cffg ;_ggcbf ._ccdf =_acad ;_ggcbf ._fded =_eaeb ;_ggcbf ._gfec =_fgcc ;_ggcbf ._ddff =_bdfe ;_ggcbf ._fbc =_fbegb ;
_ggcbf ._acgg =ColorBlack ;_ggcbf ._bebf =1.0;return _ggcbf ;};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_bfeb *Ellipse )GetCoords ()(float64 ,float64 ){return _bfeb ._ffcb ,_bfeb ._dda };func _efdb ()*Division {return &Division {_agab :[]VectorDrawable {}}};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_ccec *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agfb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dced ,_cdgg :=_agfb .setOpacity (_ccec ._gddb ,_ccec ._acbd );if _cdgg !=nil {return nil ,ctx ,_cdgg ;};
_ggge :=_ccec ._fcbg ;_ggge .FillEnabled =_ggge .FillColor !=nil ;_ggge .BorderEnabled =_ggge .BorderColor !=nil &&_ggge .BorderWidth > 0;var (_edgg =ctx .PageHeight ;_bcff =_ggge .Rings ;_eagg =make ([][]_bd .CubicBezierCurve ,0,len (_ggge .Rings )););
for _ ,_ffc :=range _bcff {_ebdg :=make ([]_bd .CubicBezierCurve ,0,len (_ffc ));for _ ,_fgf :=range _ffc {_eda :=_fgf ;_eda .P0 .Y =_edgg -_eda .P0 .Y ;_eda .P1 .Y =_edgg -_eda .P1 .Y ;_eda .P2 .Y =_edgg -_eda .P2 .Y ;_eda .P3 .Y =_edgg -_eda .P3 .Y ;
_ebdg =append (_ebdg ,_eda );};_eagg =append (_eagg ,_ebdg );};_ggge .Rings =_eagg ;defer func (){_ggge .Rings =_bcff }();_geda ,_ ,_cdgg :=_ggge .Draw (_dced );if _cdgg !=nil {return nil ,ctx ,_cdgg ;};if _cdgg =_agfb .addContentsByString (string (_geda ));
_cdgg !=nil {return nil ,ctx ,_cdgg ;};return []*Block {_agfb },ctx ,nil ;};func (_cf *Block )addContentsByString (_bb string )error {_dfb :=_eff .NewContentStreamParser (_bb );_bc ,_bbb :=_dfb .Parse ();if _bbb !=nil {return _bbb ;};_cf ._fb .WrapIfNeeded ();
_bc .WrapIfNeeded ();*_cf ._fb =append (*_cf ._fb ,*_bc ...);return nil ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_fgba *List )Marker ()*TextChunk {return &_fgba ._gaaf };

// SetOpacity sets opacity for Image.
func (_ccae *Image )SetOpacity (opacity float64 ){_ccae ._fagg =opacity };const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);func (_bcbd *StyledParagraph )split (_cbad DrawContext )(_cfbba ,_bced *StyledParagraph ,_gdbc error ){if _gdbc =_bcbd .wrapChunks (false );
_gdbc !=nil {return nil ,nil ,_gdbc ;};_cfdg :=func (_cedgd []*TextChunk ,_fgag []*TextChunk )[]*TextChunk {if len (_fgag )==0{return _cedgd ;};_dedbe :=len (_cedgd );if _dedbe ==0{return append (_cedgd ,_fgag ...);};_cedgd [_dedbe -1].Text +=_fgag [0].Text ;
return append (_cedgd ,_fgag [1:]...);};_edad :=func (_bebc *StyledParagraph ,_bfdb []*TextChunk )*StyledParagraph {if len (_bfdb )==0{return nil ;};_faeab :=*_bebc ;_faeab ._eecg =_bfdb ;return &_faeab ;};var (_geca float64 ;_edfbb []*TextChunk ;_bdad []*TextChunk ;
);for _ ,_cdffc :=range _bcbd ._bcfb {var _gfbg float64 ;_gbagc :=make ([]*TextChunk ,0,len (_cdffc ));for _ ,_fdab :=range _cdffc {if _dacb :=_fdab .Style .FontSize ;_dacb > _gfbg {_gfbg =_dacb ;};_gbagc =append (_gbagc ,_fdab .clone ());};_gfbg *=_bcbd ._efdf ;
if _bcbd ._gebf .IsRelative (){if _geca +_gfbg > _cbad .Height {_bdad =_cfdg (_bdad ,_gbagc );}else {_edfbb =_cfdg (_edfbb ,_gbagc );};};_geca +=_gfbg ;};_bcbd ._bcfb =nil ;if len (_bdad )==0{return _bcbd ,nil ,nil ;};return _edad (_bcbd ,_edfbb ),_edad (_bcbd ,_bdad ),nil ;
};

// SetBorderWidth sets the border width.
func (_gcf *CurvePolygon )SetBorderWidth (borderWidth float64 ){_gcf ._fcbg .BorderWidth =borderWidth };

// SetBorderOpacity sets the border opacity.
func (_dfd *CurvePolygon )SetBorderOpacity (opacity float64 ){_dfd ._acbd =opacity };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_cec *Block )Draw (d Drawable )error {_egc :=DrawContext {};_egc .Width =_cec ._afd ;_egc .Height =_cec ._afb ;_egc .PageWidth =_cec ._afd ;_egc .PageHeight =_cec ._afb ;_egc .X =0;_egc .Y =0;_fc ,_ ,_abf :=d .GeneratePageBlocks (_egc );if _abf !=nil {return _abf ;
};if len (_fc )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_bda :=range _fc {if _ddb :=_cec .mergeBlocks (_bda );_ddb !=nil {return _ddb ;};};return nil ;
};

// The Image type is used to draw an image onto PDF.
type Image struct{_bbbg *_ffb .XObjectImage ;_dggd *_ffb .Image ;_cbed float64 ;_fcd ,_gfgd float64 ;_dgcc ,_dagea float64 ;_ggfg Positioning ;_fbge HorizontalAlignment ;_gcag float64 ;_bbcb float64 ;_fagg float64 ;_ddcb Margins ;_cebdd ,_fgdb float64 ;
_efe _ce .StreamEncoder ;};

// NewInvoice returns an instance of an empty invoice.
func (_febg *Creator )NewInvoice ()*Invoice {_ged :=_febg .NewTextStyle ();_ged .Font =_febg ._ecgc ;return _facg (_febg .NewTextStyle (),_ged );};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_faag *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _faag ._bgbde [0],_faag ._bgbde [1]};

// SetLineWidth sets the line width.
func (_cead *Line )SetLineWidth (lw float64 ){_cead ._bacc =lw };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_da *Block )ScaleToWidth (w float64 ){_dd :=w /_da ._afd ;_da .Scale (_dd ,_dd )};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_fcdg *Invoice )NoteHeadingStyle ()TextStyle {return _fcdg ._fbbe };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_ddfa *StyledParagraph ;_bacb []*TOCLine ;_cgab TextStyle ;_bdbg TextStyle ;_adag TextStyle ;_cegc TextStyle ;_fabb string ;_egbd float64 ;_faaf Margins ;_baga Positioning ;_cabe TextStyle ;_bdefa bool ;};

// SetWidthLeft sets border width for left.
func (_ccgg *border )SetWidthLeft (bw float64 ){_ccgg ._ggcc =bw };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_abcd *TOC )SetLineLevelOffset (levelOffset float64 ){_abcd ._egbd =levelOffset };

// Level returns the indentation level of the TOC line.
func (_aebcg *TOCLine )Level ()uint {return _aebcg ._bedc };func _dee (_gdgf *Chapter ,_gag *TOC ,_fcca *_ffb .Outline ,_bddc string ,_fgbf int ,_caf TextStyle )*Chapter {var _fbe uint =1;if _gdgf !=nil {_fbe =_gdgf ._cag +1;};_gadd :=&Chapter {_gef :_fgbf ,_cadf :_bddc ,_efg :true ,_cacf :true ,_efgb :_gdgf ,_acd :_gag ,_fcf :_fcca ,_edb :[]Drawable {},_cag :_fbe };
_cde :=_fdcca (_gadd .headingText (),_caf );_cde .SetFont (_caf .Font );_cde .SetFontSize (_caf .FontSize );_gadd ._degf =_cde ;return _gadd ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_gef int ;_cadf string ;_degf *Paragraph ;_edb []Drawable ;_cab int ;_efg bool ;_cacf bool ;_abfb Positioning ;_ecgd ,_ecb float64 ;_fgdf Margins ;_efgb *Chapter ;_acd *TOC ;_fcf *_ffb .Outline ;_gdfd *_ffb .OutlineItem ;_cag uint ;
};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_feecg *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_dbed :=[2]*InvoiceCell {_feecg .newCell (description ,_feecg ._gcd ),_feecg .newCell (value ,_feecg ._gcd )};_feecg ._fdde =append (_feecg ._fdde ,_dbed );return _dbed [0],_dbed [1];
};func (_ebff *Invoice )generateNoteBlocks (_dgddg DrawContext )([]*Block ,DrawContext ,error ){_feg :=_efdb ();_fegb :=append ([][2]string {_ebff ._cagb ,_ebff ._fdcab },_ebff ._fbaf ...);for _ ,_fcba :=range _fegb {if _fcba [1]!=""{_bgab :=_ebff .drawSection (_fcba [0],_fcba [1]);
for _ ,_cgaf :=range _bgab {_feg .Add (_cgaf );};_feefd :=_ebgd (_ebff ._fgae );_feefd .SetMargins (0,0,10,0);_feg .Add (_feefd );};};return _feg .GeneratePageBlocks (_dgddg );};func _bdce (_afbge string )*_ffb .PdfAnnotation {_fgcd :=_ffb .NewPdfAnnotationLink ();
_faga :=_ffb .NewBorderStyle ();_faga .SetBorderWidth (0);_fgcd .BS =_faga .ToPdfObject ();_bfefc :=_ffb .NewPdfActionURI ();_bfefc .URI =_ce .MakeString (_afbge );_fgcd .SetAction (_bfefc .PdfAction );return _fgcd .PdfAnnotation ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_deb :_bf .Max (_bf .Min (r ,1.0),0.0),_cfbd :_bf .Max (_bf .Min (g ,1.0),0.0),_feaf :_bf .Max (_bf .Min (b ,1.0),0.0)};};

// DrawHeader sets a function to draw a header on created output pages.
func (_ffgf *Creator )DrawHeader (drawHeaderFunc func (_cfga *Block ,_dcb HeaderFunctionArgs )){_ffgf ._gdb =drawHeaderFunc ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gba *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _gba ._bbg [0],_gba ._bbg [1]};

// SetSubtotal sets the subtotal of the invoice.
func (_gagg *Invoice )SetSubtotal (value string ){_gagg ._aegb [1].Value =value };func (_eg *Block )transform (_ebd _ee .Matrix ){_aeb :=_eff .NewContentCreator ().Add_cm (_ebd [0],_ebd [1],_ebd [3],_ebd [4],_ebd [6],_ebd [7]).Operations ();*_eg ._fb =append (*_aeb ,*_eg ._fb ...);
_eg ._fb .WrapIfNeeded ();};

// SetFillOpacity sets the fill opacity.
func (_ebgc *PolyBezierCurve )SetFillOpacity (opacity float64 ){_ebgc ._eefdc =opacity };func (_cd *Block )mergeBlocks (_gg *Block )error {_beb :=_cfc (_cd ._fb ,_cd ._d ,_gg ._fb ,_gg ._d );if _beb !=nil {return _beb ;};for _ ,_egf :=range _gg ._fbb {_cd .AddAnnotation (_egf );
};return nil ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_fb *_eff .ContentStreamOperations ;_d *_ffb .PdfPageResources ;_gb Positioning ;_ad ,_gd float64 ;_afd float64 ;_afb float64 ;_fg float64 ;_bff Margins ;_fbb []*_ffb .PdfAnnotation ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fdbd *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _fdbd ._aegb [0],_fdbd ._aegb [1]};

// Height returns the height of the list.
func (_geae *List )Height ()float64 {var _abgee float64 ;for _ ,_adea :=range _geae ._baece {_abgee +=_adea ._gbbc .Height ();};return _abgee ;};

// SkipRows skips over a specified number of rows in the table.
func (_fgfad *Table )SkipRows (num int ){_egfe :=num *_fgfad ._dgdba -1;if _egfe < 0{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_fgfad ._ecced +=_egfe ;};

// CurCol returns the currently active cell's column number.
func (_dbda *Table )CurCol ()int {_egef :=(_dbda ._ecced -1)%(_dbda ._dgdba )+1;return _egef };

// SetBorderColor sets border color.
func (_addc *Rectangle )SetBorderColor (col Color ){_addc ._begf =col };

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;func (_aagc *Table )clone ()*Table {_cfdcda :=*_aagc ;_cfdcda ._egcc =make ([]float64 ,len (_aagc ._egcc ));copy (_cfdcda ._egcc ,_aagc ._egcc );_cfdcda ._baecg =make ([]float64 ,len (_aagc ._baecg ));copy (_cfdcda ._baecg ,_aagc ._baecg );
_cfdcda ._cfcg =make ([]*TableCell ,0,len (_aagc ._cfcg ));for _ ,_fddg :=range _aagc ._cfcg {_cfbe :=*_fddg ;_cfbe ._afee =&_cfdcda ;_cfdcda ._cfcg =append (_cfdcda ._cfcg ,&_cfbe );};return &_cfdcda ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_bcf *Creator )NewPolyBezierCurve (curves []_bd .CubicBezierCurve )*PolyBezierCurve {return _gbfg (curves );};

// SetColor sets the line color.
func (_cdbd *Curve )SetColor (col Color ){_cdbd ._acgg =col };type border struct{_cg float64 ;_fdcc float64 ;_fca float64 ;_ceab float64 ;_eag Color ;_gaae Color ;_ggcc float64 ;_dba Color ;_dce float64 ;_cee Color ;_edf float64 ;_bcdd Color ;_gaec float64 ;
LineStyle _bd .LineStyle ;_ggd CellBorderStyle ;_daf CellBorderStyle ;_bag CellBorderStyle ;_edd CellBorderStyle ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_bbdc *Paragraph )SetColor (col Color ){_bbdc ._bcfe =col };

// SetLineOpacity sets the line opacity.
func (_efcd *Polyline )SetLineOpacity (opacity float64 ){_efcd ._edef =opacity };

// SetStyleRight sets border style for right side.
func (_bba *border )SetStyleRight (style CellBorderStyle ){_bba ._daf =style };

// SetLevel sets the indentation level of the TOC line.
func (_aaacg *TOCLine )SetLevel (level uint ){_aaacg ._bedc =level ;_aaacg ._cbbgg ._abed .Left =_aaacg ._fdbdb +float64 (_aaacg ._bedc -1)*_aaacg ._cecg ;};

// Write output of creator to io.Writer interface.
func (_feec *Creator )Write (ws _e .Writer )error {if _bddba :=_feec .Finalize ();_bddba !=nil {return _bddba ;};_gddc :=_ffb .NewPdfWriter ();_gddc .SetOptimizer (_feec ._ade );if _feec ._fcgec !=nil {_fcbd :=_gddc .SetForms (_feec ._fcgec );if _fcbd !=nil {_ca .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fcbd );
return _fcbd ;};};if _feec ._fdca !=nil {_gddc .AddOutlineTree (_feec ._fdca );}else if _feec ._dge !=nil &&_feec .AddOutlines {_gddc .AddOutlineTree (&_feec ._dge .ToPdfOutline ().PdfOutlineTreeNode );};if _feec ._fagc !=nil {if _cfce :=_gddc .SetPageLabels (_feec ._fagc );
_cfce !=nil {_ca .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_cfce );return _cfce ;};};if _feec ._becc !=nil {for _ ,_fcfd :=range _feec ._becc {_fec :=_fcfd .SubsetRegistered ();
if _fec !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_fec );return _fec ;};};};if _feec ._dgf !=nil {_eebg :=_feec ._dgf (&_gddc );
if _eebg !=nil {_ca .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_eebg );return _eebg ;};};for _ ,_dggf :=range _feec ._aca {_gbdb :=_gddc .AddPage (_dggf );if _gbdb !=nil {_ca .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_gbdb );
return _gbdb ;};};_effdd :=_gddc .Write (ws );if _effdd !=nil {return _effdd ;};return nil ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_acb float64 ;_ccdf float64 ;_fded float64 ;_gfec float64 ;_ddff float64 ;_fbc float64 ;_acgg Color ;_bebf float64 ;};func (_aga *Creator )setActivePage (_ddgc *_ffb .PdfPage ){_aga ._ecc =_ddgc };func (_cggf *StyledParagraph )getLineMetrics (_gccc int )(_gegdf ,_bcage ,_fbefg float64 ){if _cggf ._bcfb ==nil ||len (_cggf ._bcfb )==0{_cggf .wrapText ();
};if _gccc < 0||_gccc > len (_cggf ._bcfb )-1{_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_gccc );
return 0,0,0;};_edc :=_cggf ._bcfb [_gccc ];for _ ,_ffbf :=range _edc {_ffea ,_deab :=_ffbf .Style .Font .GetFontDescriptor ();if _deab !=nil {_ca .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _babd ,_ffgd float64 ;if _ffea !=nil {if _babd ,_deab =_ffea .GetCapHeight ();_deab !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_deab );
};if _ffgd ,_deab =_ffea .GetDescent ();_deab !=nil {_ca .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_deab );
};};if int (_babd )<=0{_ca .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_babd =1000;};if _bgdf :=_babd /1000.0*_ffbf .Style .FontSize ;_bgdf > _gegdf {_gegdf =_bgdf ;};if _aadb :=_ffbf .Style .FontSize ;_aadb > _bcage {_bcage =_aadb ;};if _efdc :=_ffgd /1000.0*_ffbf .Style .FontSize ;_efdc < _fbefg {_fbefg =_efdc ;};};return _gegdf ,_bcage ,_fbefg ;
};

// GetRowHeight returns the height of the specified row.
func (_dbadf *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_dbadf ._egcc ){return 0,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _dbadf ._egcc [row -1],nil ;
};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_gca *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_gca ._bbe .Left =left ;_gca ._bbe .Right =right ;_gca ._bbe .Top =top ;_gca ._bbe .Bottom =bottom ;};

// SetFillColor sets the fill color.
func (_ggfee *Rectangle )SetFillColor (col Color ){_ggfee ._gaf =col };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_cdac *Creator )AddPage (page *_ffb .PdfPage )error {_aded ,_ceb :=page .GetMediaBox ();if _ceb !=nil {_ca .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_ceb );
return _ceb ;};_aded .Normalize ();_cbde ,_gde :=_aded .Llx ,_aded .Lly ;_dadd :=_ee .IdentityMatrix ();_dgg :=page .Rotate ;_ccca :=_dgg !=nil &&*_dgg %360!=0&&*_dgg %90==0;if _ccca {_ceba :=float64 ((360+*page .Rotate %360)%360);if _ceba ==90{_dadd =_dadd .Translate (_aded .Width (),0);
}else if _ceba ==180{_dadd =_dadd .Translate (_aded .Width (),_aded .Height ());}else if _ceba ==270{_dadd =_dadd .Translate (0,_aded .Height ());};_dadd =_dadd .Mult (_ee .RotationMatrix (_ceba *_bf .Pi /180));_dadd =_dadd .Round (0.000001);_abea :=_bfceeg (_aded ,_dadd );
_aded =_abea ;_aded .Normalize ();};if _cbde !=0||_gde !=0{_dadd =_ee .TranslationMatrix (_cbde ,_gde ).Mult (_dadd );};if !_dadd .Identity (){if _cdac ._efae ==nil {_cdac ._efae =map[*_ffb .PdfPage ]_ee .Matrix {};};_dadd =_dadd .Round (0.000001);_cdac ._efae [page ]=_dadd ;
};_cdac ._bddd =_aded .Width ();_cdac ._bbeg =_aded .Height ();_cdac .initContext ();_cdac ._aca =append (_cdac ._aca ,page );_cdac ._acag .Page ++;return nil ;};

// NewImageFromData creates an Image from image data.
func (_dfgf *Creator )NewImageFromData (data []byte )(*Image ,error ){return _ggga (data )};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_dgef *Image )ScaleToHeight (h float64 ){_feag :=_dgef ._fcd /_dgef ._gfgd ;_dgef ._gfgd =h ;_dgef ._fcd =h *_feag ;};

// NewCell returns a new invoice table cell.
func (_gddd *Invoice )NewCell (value string )*InvoiceCell {return _gddd .newCell (value ,_gddd .NewCellProps ());};func _cge (_cbfd ,_bca ,_agc ,_fed float64 )*border {_fcb :=&border {};_fcb ._cg =_cbfd ;_fcb ._fdcc =_bca ;_fcb ._fca =_agc ;_fcb ._ceab =_fed ;
_fcb ._bcdd =ColorBlack ;_fcb ._dba =ColorBlack ;_fcb ._gaae =ColorBlack ;_fcb ._cee =ColorBlack ;_fcb ._gaec =0;_fcb ._dce =0;_fcb ._ggcc =0;_fcb ._edf =0;_fcb .LineStyle =_bd .LineStyleSolid ;return _fcb ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_bcgg *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgda :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_acga ,_dcag :=_bgda .setOpacity (_bcgg ._eefdc ,_bcgg ._ceda );if _dcag !=nil {return nil ,ctx ,_dcag ;
};_accd :=_bcgg ._bfccb ;_accd .FillEnabled =_accd .FillColor !=nil ;var (_gegg =ctx .PageHeight ;_dbcc =_accd .Curves ;_efec =make ([]_bd .CubicBezierCurve ,0,len (_accd .Curves )););for _gfdg :=range _accd .Curves {_dfcfc :=_dbcc [_gfdg ];_dfcfc .P0 .Y =_gegg -_dfcfc .P0 .Y ;
_dfcfc .P1 .Y =_gegg -_dfcfc .P1 .Y ;_dfcfc .P2 .Y =_gegg -_dfcfc .P2 .Y ;_dfcfc .P3 .Y =_gegg -_dfcfc .P3 .Y ;_efec =append (_efec ,_dfcfc );};_accd .Curves =_efec ;defer func (){_accd .Curves =_dbcc }();_dgeg ,_ ,_dcag :=_accd .Draw (_acga );if _dcag !=nil {return nil ,ctx ,_dcag ;
};if _dcag =_bgda .addContentsByString (string (_dgeg ));_dcag !=nil {return nil ,ctx ,_dcag ;};return []*Block {_bgda },ctx ,nil ;};func _bcab ()*FilledCurve {_eggc :=FilledCurve {};_eggc ._cgac =[]_bd .CubicBezierCurve {};return &_eggc ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_afdc *TOC )SetLinePageStyle (style TextStyle ){_afdc ._cegc =style };

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_afae *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _gcbf []*Block ;_bfce :=ctx ;if _afae ._gdbg .IsRelative (){ctx .X +=_afae ._cdgd .Left ;ctx .Y +=_afae ._cdgd .Top ;ctx .Width -=_afae ._cdgd .Left +_afae ._cdgd .Right ;
ctx .Height -=_afae ._cdgd .Top +_afae ._cdgd .Bottom ;};ctx .Inline =_afae ._gefg ;_fggd :=ctx ;_gbbb :=ctx ;var _fcfe float64 ;for _ ,_bgbd :=range _afae ._agab {if ctx .Inline {if (ctx .X -_fggd .X )+_bgbd .Width ()<=ctx .Width {ctx .Y =_gbbb .Y ;ctx .Height =_gbbb .Height ;
}else {ctx .X =_fggd .X ;ctx .Width =_fggd .Width ;_gbbb .Y +=_fcfe ;_gbbb .Height -=_fcfe ;_fcfe =0;};};_ccfb ,_cgd ,_baef :=_bgbd .GeneratePageBlocks (ctx );if _baef !=nil {_ca .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_baef );
return nil ,ctx ,_baef ;};if len (_ccfb )< 1{continue ;};if len (_gcbf )> 0{_gcbf [len (_gcbf )-1].mergeBlocks (_ccfb [0]);_gcbf =append (_gcbf ,_ccfb [1:]...);}else {_gcbf =append (_gcbf ,_ccfb [0:]...);};if ctx .Inline {if ctx .Page !=_cgd .Page {_fggd .Y =ctx .Margins .Top ;
_fggd .Height =ctx .PageHeight -ctx .Margins .Top ;_gbbb .Y =_fggd .Y ;_gbbb .Height =_fggd .Height ;_fcfe =_cgd .Height -_fggd .Height ;}else {if _gfd :=ctx .Height -_cgd .Height ;_gfd > _fcfe {_fcfe =_gfd ;};};}else {_cgd .X =ctx .X ;};ctx =_cgd ;};ctx .Inline =_bfce .Inline ;
if _afae ._gdbg .IsRelative (){ctx .X =_bfce .X ;};if _afae ._gdbg .IsAbsolute (){return _gcbf ,_bfce ,nil ;};return _gcbf ,ctx ,nil ;};func _eefc (_bcac ,_effdc ,_dbf ,_bded float64 )*Ellipse {_aede :=&Ellipse {};_aede ._ffcb =_bcac ;_aede ._dda =_effdc ;
_aede ._ddec =_dbf ;_aede ._bbce =_bded ;_aede ._cecfd =ColorBlack ;_aede ._aaffc =1.0;return _aede ;};func _eedad (_edgf [][]_bd .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_fcbg :&_bd .CurvePolygon {Rings :_edgf },_gddb :1.0,_acbd :1.0};};


// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_dbb *Division )Height ()float64 {var _bae float64 ;for _ ,_aae :=range _dbb ._agab {switch _bddf :=_aae .(type ){case *Paragraph :_bae +=_bddf .Height ()+_bddf ._abeae .Top +_bddf ._abeae .Bottom ;case *StyledParagraph :_bae +=_bddf .Height ()+_bddf ._abed .Top +_bddf ._abed .Bottom ;
default:_bae +=_bddf .Height ();};};return _bae ;};func _adga (_ebac *_ffb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_ebac ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_agde *Creator )SetForms (form *_ffb .PdfAcroForm )error {_agde ._fcgec =form ;return nil };

// IsAbsolute checks if the positioning is absolute.
func (_acf Positioning )IsAbsolute ()bool {return _acf ==PositionAbsolute };func (_ggcf *Paragraph )getTextLineWidth (_edfbe string )float64 {var _efad float64 ;for _ ,_bdb :=range _edfbe {if _bdb =='\u000A'{continue ;};_ggdfb ,_gccbd :=_ggcf ._gagd .GetRuneMetrics (_bdb );
if !_gccbd {_ca .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bdb ,_bdb );
return -1;};_efad +=_ggcf ._fge *_ggdfb .Wx ;};return _efad ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_dgd *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _dgd ._bbbg ==nil {if _efcf :=_dgd .makeXObject ();_efcf !=nil {return nil ,ctx ,_efcf ;};};var _ebdf []*Block ;_adede :=ctx ;_bgd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _dgd ._ggfg .IsRelative (){ctx .X +=_dgd ._ddcb .Left ;ctx .Y +=_dgd ._ddcb .Top ;ctx .Width -=_dgd ._ddcb .Left +_dgd ._ddcb .Right ;ctx .Height -=_dgd ._ddcb .Top +_dgd ._ddcb .Bottom ;if _dgd ._gfgd > ctx .Height {_ebdf =append (_ebdf ,_bgd );_bgd =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_eeg :=ctx ;_eeg .Y =ctx .Margins .Top +_dgd ._ddcb .Top ;_eeg .X =ctx .Margins .Left +_dgd ._ddcb .Left ;_eeg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dgd ._ddcb .Top -_dgd ._ddcb .Bottom ;_eeg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dgd ._ddcb .Left -_dgd ._ddcb .Right ;
ctx =_eeg ;_adede .X =ctx .Margins .Left ;_adede .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_dgd ._gcag ;ctx .Y =_dgd ._bbcb ;};ctx ,_ffec :=_bac (_bgd ,_dgd ,ctx );if _ffec !=nil {return nil ,ctx ,_ffec ;};_ebdf =append (_ebdf ,_bgd );
if _dgd ._ggfg .IsAbsolute (){ctx =_adede ;}else {ctx .X =_adede .X ;ctx .Y +=_dgd ._ddcb .Bottom ;ctx .Width =_adede .Width ;};return _ebdf ,ctx ,nil ;};

// SetText sets the text content of the Paragraph.
func (_ebeg *Paragraph )SetText (text string ){_ebeg ._ggacg =text };func _gbcf (_gcae ,_fgagf ,_dbgc float64 )(_bdea ,_gagc ,_faegd ,_abac float64 ){if _dbgc ==0{return 0,0,_gcae ,_fgagf ;};_gfgea :=_bd .Path {Points :[]_bd .Point {_bd .NewPoint (0,0).Rotate (_dbgc ),_bd .NewPoint (_gcae ,0).Rotate (_dbgc ),_bd .NewPoint (0,_fgagf ).Rotate (_dbgc ),_bd .NewPoint (_gcae ,_fgagf ).Rotate (_dbgc )}}.GetBoundingBox ();
return _gfgea .X ,_gfgea .Y ,_gfgea .Width ,_gfgea .Height ;};

// SetSellerAddress sets the seller address of the invoice.
func (_bdef *Invoice )SetSellerAddress (address *InvoiceAddress ){_bdef ._efea =address };

// SetFillOpacity sets the fill opacity.
func (_dbba *Polygon )SetFillOpacity (opacity float64 ){_dbba ._aaacc =opacity };

// NewPageBreak create a new page break.
func (_afbf *Creator )NewPageBreak ()*PageBreak {return _fgbe ()};func (_gcbe *List )tableHeight (_bfaa float64 )float64 {var _egbb float64 ;for _ ,_dgaa :=range _gcbe ._baece {switch _agdeg :=_dgaa ._gbbc .(type ){case *Paragraph :_cfgd :=_agdeg ;if _cfgd ._ggbe {_cfgd .SetWidth (_bfaa );
};_egbb +=_cfgd .Height ()+_cfgd ._abeae .Bottom +_cfgd ._abeae .Bottom ;_egbb +=0.5*_cfgd ._fge *_cfgd ._efgdb ;case *StyledParagraph :_abaf :=_agdeg ;if _abaf ._adbb {_abaf .SetWidth (_bfaa );};_egbb +=_abaf .Height ()+_abaf ._abed .Top +_abaf ._abed .Bottom ;
_egbb +=0.5*_abaf .getTextHeight ();default:_egbb +=_dgaa ._gbbc .Height ();};};return _egbb ;};

// SetWidthBottom sets border width for bottom.
func (_cfd *border )SetWidthBottom (bw float64 ){_cfd ._dce =bw };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_dgdb *Paragraph )SetTextAlignment (align TextAlignment ){_dgdb ._ebfb =align };

// SetFillColor sets background color for border.
func (_fbfd *border )SetFillColor (col Color ){_fbfd ._eag =col };

// SetEnableWrap sets the line wrapping enabled flag.
func (_ebfd *StyledParagraph )SetEnableWrap (enableWrap bool ){_ebfd ._adbb =enableWrap ;_ebfd ._ceca =false ;};func (_eeeg *Invoice )drawInformation ()*Table {_dacd :=_cgcge (2);_aad :=append ([][2]*InvoiceCell {_eeeg ._geef ,_eeeg ._bbg ,_eeeg ._bgbde },_eeeg ._fdde ...);
for _ ,_cfcfe :=range _aad {_bfgf ,_dcbec :=_cfcfe [0],_cfcfe [1];if _dcbec .Value ==""{continue ;};_cgcg :=_dacd .NewCell ();_cgcg .SetBackgroundColor (_bfgf .BackgroundColor );_eeeg .setCellBorder (_cgcg ,_bfgf );_dcda :=_ebgd (_bfgf .TextStyle );_dcda .Append (_bfgf .Value );
_dcda .SetMargins (0,0,2,1);_cgcg .SetContent (_dcda );_cgcg =_dacd .NewCell ();_cgcg .SetBackgroundColor (_dcbec .BackgroundColor );_eeeg .setCellBorder (_cgcg ,_dcbec );_dcda =_ebgd (_dcbec .TextStyle );_dcda .Append (_dcbec .Value );_dcda .SetMargins (0,0,2,1);
_cgcg .SetContent (_dcda );};return _dacd ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_gdce *Image )ConvertToBinary ()error {return _gdce ._dggd .ConvertToBinary ()};

// SetFillColor sets the fill color.
func (_bab *CurvePolygon )SetFillColor (color Color ){_bab ._fcbg .FillColor =_cbae (color )};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_cga *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _geee (x1 ,y1 ,x2 ,y2 )};func _ggga (_bgf []byte )(*Image ,error ){_fcce :=_b .NewReader (_bgf );_fbcb ,_dbgf :=_ffb .ImageHandling .Read (_fcce );if _dbgf !=nil {_ca .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dbgf );
return nil ,_dbgf ;};return _abab (_fbcb );};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_bagf *List )Width ()float64 {return 0};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_cgac []_bd .CubicBezierCurve ;FillEnabled bool ;_ecbf Color ;BorderEnabled bool ;BorderWidth float64 ;_aacb Color ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_eged *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_egega :=NewTextChunk (text ,_eged ._dbcgc );_egega ._gbbe =_bdce (url );return _eged .appendChunk (_egega );};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gbbe *_ffb .PdfAnnotation ;_cggfc bool ;};

// Append adds a new text chunk to the paragraph.
func (_dfdg *StyledParagraph )Append (text string )*TextChunk {_cbga :=NewTextChunk (text ,_dfdg ._cdef );return _dfdg .appendChunk (_cbga );};

// Invoice represents a configurable invoice template.
type Invoice struct{_dbe string ;_adcf *Image ;_daef *InvoiceAddress ;_efea *InvoiceAddress ;_gedf string ;_geef [2]*InvoiceCell ;_bbg [2]*InvoiceCell ;_bgbde [2]*InvoiceCell ;_fdde [][2]*InvoiceCell ;_fbdb []*InvoiceCell ;_facce [][]*InvoiceCell ;_aegb [2]*InvoiceCell ;
_gebb [2]*InvoiceCell ;_bcc [][2]*InvoiceCell ;_cagb [2]string ;_fdcab [2]string ;_fbaf [][2]string ;_fgae TextStyle ;_agcg TextStyle ;_gdca TextStyle ;_bgec TextStyle ;_deed TextStyle ;_fadf TextStyle ;_fbbe TextStyle ;_gcd InvoiceCellProps ;_bbaa InvoiceCellProps ;
_ebfe InvoiceCellProps ;_dcd InvoiceCellProps ;_acba Positioning ;};func _cbae (_bbbe Color )_ffb .PdfColor {if _bbbe ==nil {_bbbe =ColorBlack ;};switch _bcba :=_bbbe .(type ){case cmykColor :return _ffb .NewPdfColorDeviceCMYK (_bcba ._fcfb ,_bcba ._agd ,_bcba ._gea ,_bcba ._efa );
};return _ffb .NewPdfColorDeviceRGB (_bbbe .ToRGB ());};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_ccge *Chapter )GetHeading ()*Paragraph {return _ccge ._degf };

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_bbdb *Invoice )SetAddressHeadingStyle (style TextStyle ){_bbdb ._deed =style };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_cfgcc *TOCLine )SetLevelOffset (levelOffset float64 ){_cfgcc ._cecg =levelOffset ;_cfgcc ._cbbgg ._abed .Left =_cfgcc ._fdbdb +float64 (_cfgcc ._bedc -1)*_cfgcc ._cecg ;};

// SetAngle sets the rotation angle of the text.
func (_ebg *Paragraph )SetAngle (angle float64 ){_ebg ._gggb =angle };

// GetOptimizer returns current PDF optimizer.
func (_fcgd *Creator )GetOptimizer ()_ffb .Optimizer {return _fcgd ._ade };

// SetSideBorderColor sets the cell's side border color.
func (_deccf *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_deccf ._ggecc =col ;case CellBorderSideBottom :_deccf ._gcac =col ;case CellBorderSideLeft :_deccf ._fegc =col ;case CellBorderSideRight :_deccf ._afdf =col ;
};};func (_cadg *Invoice )generateLineBlocks (_edec DrawContext )([]*Block ,DrawContext ,error ){_ccdb :=_cgcge (len (_cadg ._fbdb ));_ccdb .SetMargins (0,0,25,0);for _ ,_bggb :=range _cadg ._fbdb {_dcac :=_ebgd (_bggb .TextStyle );_dcac .SetMargins (0,0,1,0);
_dcac .Append (_bggb .Value );_cbef :=_ccdb .NewCell ();_cbef .SetHorizontalAlignment (_bggb .Alignment );_cbef .SetBackgroundColor (_bggb .BackgroundColor );_cadg .setCellBorder (_cbef ,_bggb );_cbef .SetContent (_dcac );};for _ ,_cgeb :=range _cadg ._facce {for _ ,_facf :=range _cgeb {_gddbd :=_ebgd (_facf .TextStyle );
_gddbd .SetMargins (0,0,3,2);_gddbd .Append (_facf .Value );_defe :=_ccdb .NewCell ();_defe .SetHorizontalAlignment (_facf .Alignment );_defe .SetBackgroundColor (_facf .BackgroundColor );_cadg .setCellBorder (_defe ,_facf );_defe .SetContent (_gddbd );
};};return _ccdb .GeneratePageBlocks (_edec );};

// Width returns the current page width.
func (_bdc *Creator )Width ()float64 {return _bdc ._bddd };

// Width returns the Block's width.
func (_fbf *Block )Width ()float64 {return _fbf ._afd };func (_aafa *Image )makeXObject ()error {_ddgb :=_aafa ._efe ;if _ddgb ==nil {_ddgb =_ce .NewFlateEncoder ();};_dbad ,_affe :=_ffb .NewXObjectImageFromImage (_aafa ._dggd ,nil ,_ddgb );if _affe !=nil {_ca .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_affe );
return _affe ;};_aafa ._bbbg =_dbad ;return nil ;};

// SellerAddress returns the seller address used in the invoice template.
func (_fcdb *Invoice )SellerAddress ()*InvoiceAddress {return _fcdb ._efea };

// DrawFooter sets a function to draw a footer on created output pages.
func (_ebbb *Creator )DrawFooter (drawFooterFunc func (_gdac *Block ,_gcc FooterFunctionArgs )){_ebbb ._efd =drawFooterFunc ;};var PPI float64 =72;

// CreateFrontPage sets a function to generate a front Page.
func (_fgg *Creator )CreateFrontPage (genFrontPageFunc func (_fac FrontpageFunctionArgs )){_fgg ._edg =genFrontPageFunc ;};

// SkipOver skips over a specified number of rows and cols.
func (_edgb *Table )SkipOver (rows ,cols int ){_edac :=rows *_edgb ._dgdba +cols -1;if _edac < 0{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_edgb ._ecced +=_edac ;};

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_agff *Table )EnableRowWrap (enable bool ){_agff ._fcda =enable };

// SetText replaces all the text of the paragraph with the specified one.
func (_eedg *StyledParagraph )SetText (text string )*TextChunk {_eedg .Reset ();return _eedg .Append (text );};func _ffgdd (_afagg *Table ,_fgfa DrawContext )([]*Block ,DrawContext ,error ){var _adfda []*Block ;_gfgb :=NewBlock (_fgfa .PageWidth ,_fgfa .PageHeight );
_bfeff :=_fgfa ;if _afagg ._gggbb .IsAbsolute (){_fgfa .X =_afagg ._agbg ;_fgfa .Y =_afagg ._eccea ;}else {_fgfa .X +=_afagg ._bgaad .Left ;_fgfa .Y +=_afagg ._bgaad .Top ;_fgfa .Width -=_afagg ._bgaad .Left +_afagg ._bgaad .Right ;_fgfa .Height -=_afagg ._bgaad .Bottom +_afagg ._bgaad .Top ;
};_bgcb :=_fgfa .Width ;_eecdb :=_fgfa .X ;_affdee :=_fgfa .Y ;_fgfa .Height =_fgfa .PageHeight -_fgfa .Y -_fgfa .Margins .Bottom ;_bebfd :=_fgfa .Height ;_eagd :=0;_gega ,_dcfdbd :=-1,-1;for _gefa ,_gdbe :=range _afagg ._cfcg {_badg :=_gdbe .width (_afagg ._baecg ,_bgcb );
if _afagg ._egcg {if _gdbe ._aadbf >=_afagg ._cddb &&_gdbe ._aadbf <=_afagg ._efdca {if _gega < 0{_gega =_gefa ;};_dcfdbd =_gefa ;};};_gdfb :=_afagg ._egcc [_gdbe ._aadbf +_gdbe ._cdfg -2];if _eeegc :=_gdbe .height (_badg );_eeegc > _gdfb {_afagg ._egcc [_gdbe ._aadbf +_gdbe ._cdfg -2]=_eeegc ;
};};var (_dcfg bool ;_bffg int ;_fdbdd int ;_caeee bool ;_deedd int ;_aecaa error ;);for _cage :=0;_cage < len (_afagg ._cfcg );_cage ++{_efead :=_afagg ._cfcg [_cage ];_bgff :=_efead .width (_afagg ._baecg ,_bgcb );_afad :=float64 (0.0);for _cbac :=0;
_cbac < _efead ._ggcga -1;_cbac ++{_afad +=_afagg ._baecg [_cbac ]*_bgcb ;};_cbfac :=float64 (0.0);for _eafgd :=_eagd ;_eafgd < _efead ._aadbf -1;_eafgd ++{_cbfac +=_afagg ._egcc [_eafgd ];};_fgfa .Height =_bebfd -_cbfac ;_cbbf :=float64 (0.0);for _dfde :=0;
_dfde < _efead ._cdfg ;_dfde ++{_cbbf +=_afagg ._egcc [_efead ._aadbf +_dfde -1];};_baag :=_caeee &&_efead ._aadbf !=_deedd ;_deedd =_efead ._aadbf ;if _baag ||_cbbf > _fgfa .Height {if _afagg ._fcda &&!_caeee {_caeee ,_aecaa =_afagg .wrapRow (_cage ,_fgfa ,_bgcb );
if _aecaa !=nil {return nil ,_fgfa ,_aecaa ;};if _caeee {_cage --;continue ;};};_adfda =append (_adfda ,_gfgb );_gfgb =NewBlock (_fgfa .PageWidth ,_fgfa .PageHeight );_eecdb =_fgfa .Margins .Left ;_affdee =_fgfa .Margins .Top ;_fgfa .Height =_fgfa .PageHeight -_fgfa .Margins .Top -_fgfa .Margins .Bottom ;
_fgfa .Page ++;_bebfd =_fgfa .Height ;_eagd =_efead ._aadbf -1;_cbfac =0;_caeee =false ;if _afagg ._egcg &&_gega >=0{_bffg =_cage ;_cage =_gega -1;_fdbdd =_eagd ;_eagd =_afagg ._cddb -1;_dcfg =true ;continue ;};if _baag {_cage --;continue ;};};_fgfa .Width =_bgff ;
_fgfa .X =_eecdb +_afad ;_fgfa .Y =_affdee +_cbfac ;_cdad :=_cge (_fgfa .X ,_fgfa .Y ,_bgff ,_cbbf );if _efead ._cfac !=nil {_cdad .SetFillColor (_efead ._cfac );};_cdad .LineStyle =_efead ._eabff ;_cdad ._ggd =_efead ._abde ;_cdad ._daf =_efead ._accfe ;
_cdad ._bag =_efead ._egbbg ;_cdad ._edd =_efead ._cfdfe ;if _efead ._fegc !=nil {_cdad .SetColorLeft (_efead ._fegc );};if _efead ._gcac !=nil {_cdad .SetColorBottom (_efead ._gcac );};if _efead ._afdf !=nil {_cdad .SetColorRight (_efead ._afdf );};if _efead ._ggecc !=nil {_cdad .SetColorTop (_efead ._ggecc );
};_cdad .SetWidthBottom (_efead ._ecae );_cdad .SetWidthLeft (_efead ._cfddg );_cdad .SetWidthRight (_efead ._gbcd );_cdad .SetWidthTop (_efead ._fdgc );_fccf :=_gfgb .Draw (_cdad );if _fccf !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fccf );
};if _efead ._daac !=nil {_ccggf :=_efead ._daac .Width ();_bagfc :=_efead ._daac .Height ();_abeac :=0.0;switch _ggcd :=_efead ._daac .(type ){case *Paragraph :if _ggcd ._ggbe {_ccggf =_ggcd .getMaxLineWidth ()/1000.0;};_ccggf +=_ggcd ._abeae .Left +_ggcd ._abeae .Right ;
_bagfc +=_ggcd ._abeae .Top +_ggcd ._abeae .Bottom ;case *StyledParagraph :if _ggcd ._adbb {_ccggf =_ggcd .getMaxLineWidth ()/1000.0;};_abdf ,_begc ,_eaaa :=_ggcd .getLineMetrics (0);_eegc ,_gbgg :=_abdf *_ggcd ._efdf ,_begc *_ggcd ._efdf ;if _ggcd ._dccgd ==TextVerticalAlignmentCenter {_abeac =_gbgg -(_begc +(_abdf +_eaaa -_begc )/2+(_gbgg -_begc )/2);
};if len (_ggcd ._bcfb )==1{_bagfc =_eegc ;}else {_bagfc =_bagfc -_gbgg +_eegc ;};_abeac +=_eegc -_gbgg ;switch _efead ._eabab {case CellVerticalAlignmentTop :_abeac +=_eegc *0.5;case CellVerticalAlignmentBottom :_abeac -=_eegc *0.5;};_ccggf +=_ggcd ._abed .Left +_ggcd ._abed .Right ;
_bagfc +=_ggcd ._abed .Top +_ggcd ._abed .Bottom ;case *Table :_ccggf =_bgff ;case *List :_ccggf =_bgff ;};switch _efead ._bedb {case CellHorizontalAlignmentLeft :_fgfa .X +=_efead ._decca ;_fgfa .Width -=_efead ._decca ;case CellHorizontalAlignmentCenter :if _gabdb :=_bgff -_ccggf ;
_gabdb > 0{_fgfa .X +=_gabdb /2;_fgfa .Width -=_gabdb /2;};case CellHorizontalAlignmentRight :if _bgff > _ccggf {_fgfa .X =_fgfa .X +_bgff -_ccggf -_efead ._decca ;_fgfa .Width -=_efead ._decca ;};};_fgfa .Y +=_abeac ;switch _efead ._eabab {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _gedcg :=_cbbf -_bagfc ;
_gedcg > 0{_fgfa .Y +=_gedcg /2;_fgfa .Height -=_gedcg /2;};case CellVerticalAlignmentBottom :if _cbbf > _bagfc {_fgfa .Y =_fgfa .Y +_cbbf -_bagfc ;_fgfa .Height =_cbbf ;};};_abeb :=_gfgb .DrawWithContext (_efead ._daac ,_fgfa );if _abeb !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_abeb );
};_fgfa .Y -=_abeac ;};_fgfa .Y +=_cbbf ;_fgfa .Height -=_cbbf ;if _dcfg &&_cage +1> _dcfdbd {_affdee +=_cbfac +_cbbf ;_bebfd -=_cbbf +_cbfac ;_eagd =_fdbdd ;_cage =_bffg -1;_dcfg =false ;};};_adfda =append (_adfda ,_gfgb );if _afagg ._gggbb .IsAbsolute (){return _adfda ,_bfeff ,nil ;
};_fgfa .X =_bfeff .X ;_fgfa .Width =_bfeff .Width ;_fgfa .Y +=_afagg ._bgaad .Bottom ;_fgfa .Height -=_afagg ._bgaad .Bottom ;return _adfda ,_fgfa ,nil ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);func (_dfeg *StyledParagraph )wrapText ()error {return _dfeg .wrapChunks (true )};


// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_eab *Creator )RotateDeg (angleDeg int64 )error {_cebc :=_eab .getActivePage ();if _cebc ==nil {_ca .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _f .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_ca .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _fbed int64 ;if _cebc .Rotate !=nil {_fbed =*(_cebc .Rotate );};_fbed +=angleDeg ;_cebc .Rotate =&_fbed ;return nil ;};

// SetLineWidth sets the line width.
func (_bafg *Polyline )SetLineWidth (lineWidth float64 ){_bafg ._aeeg .LineWidth =lineWidth };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_bcbc *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_gdff :=_ebgd (_bcbc ._abgcc );_gdff .Append (text );_dgca ,_eaa :=_bcbc .Add (_gdff );return _gdff ,_dgca ,_eaa ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_aecd *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aecd ._ddcb .Left ,_aecd ._ddcb .Right ,_aecd ._ddcb .Top ,_aecd ._ddcb .Bottom ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bcbbg *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bcbbg ._daef =address };func (_cecf rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _cecf ._deb ,_cecf ._cfbd ,_cecf ._feaf ;};

// SetPos sets absolute positioning with specified coordinates.
func (_bcefe *Paragraph )SetPos (x ,y float64 ){_bcefe ._agfce =PositionAbsolute ;_bcefe ._aacg =x ;_bcefe ._fccag =y ;};func (_fcdd *TOCLine )getLineLink ()*_ffb .PdfAnnotation {if _fcdd ._ddbf <=0{return nil ;};return _feafc (_fcdd ._ddbf -1,_fcdd ._egec ,_fcdd ._bagc ,0);
};

// NewCellProps returns the default properties of an invoice cell.
func (_bedf *Invoice )NewCellProps ()InvoiceCellProps {_fadg :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_bedf ._fgae ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_fadg ,BorderColor :_fadg ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};func _gdcf (_cedfe *_fa .File )([]*_ffb .PdfPage ,error ){_dfacc ,_ecbbd :=_ffb .NewPdfReader (_cedfe );if _ecbbd !=nil {return nil ,_ecbbd ;};_daff ,_ecbbd :=_dfacc .GetNumPages ();if _ecbbd !=nil {return nil ,_ecbbd ;};var _addd []*_ffb .PdfPage ;for _eccfg :=0;
_eccfg < _daff ;_eccfg ++{_ccgb ,_baff :=_dfacc .GetPage (_eccfg +1);if _baff !=nil {return nil ,_baff ;};_addd =append (_addd ,_ccgb );};return _addd ,nil ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_becfd *Invoice )AddressStyle ()TextStyle {return _becfd ._bgec };

// SetDate sets the date of the invoice.
func (_gedc *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_gedc ._bbg [1].Value =date ;return _gedc ._bbg [0],_gedc ._bbg [1];};

// SetLineHeight sets the line height (1.0 default).
func (_dgec *StyledParagraph )SetLineHeight (lineheight float64 ){_dgec ._efdf =lineheight };

// Notes returns the notes section of the invoice as a title-content pair.
func (_caeb *Invoice )Notes ()(string ,string ){return _caeb ._cagb [0],_caeb ._cagb [1]};

// SetColorRight sets border color for right.
func (_ege *border )SetColorRight (col Color ){_ege ._cee =col };

// Title returns the title of the invoice.
func (_ebec *Invoice )Title ()string {return _ebec ._dbe };func (_cbf *Block )addContents (_aag *_eff .ContentStreamOperations ){_cbf ._fb .WrapIfNeeded ();_aag .WrapIfNeeded ();*_cbf ._fb =append (*_cbf ._fb ,*_aag ...);};

// SetBorderColor sets the border color.
func (_affba *CurvePolygon )SetBorderColor (color Color ){_affba ._fcbg .BorderColor =_cbae (color )};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_eaba *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _ebga (number ,title ,page ,level ,style );};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_fffcd *Table )SetPos (x ,y float64 ){_fffcd ._gggbb =PositionAbsolute ;_fffcd ._agbg =x ;_fffcd ._eccea =y ;};func _feafc (_egegb int64 ,_ebcd ,_bbgd ,_gegc float64 )*_ffb .PdfAnnotation {_bbef :=_ffb .NewPdfAnnotationLink ();_fafg :=_ffb .NewBorderStyle ();
_fafg .SetBorderWidth (0);_bbef .BS =_fafg .ToPdfObject ();if _egegb < 0{_egegb =0;};_bbef .Dest =_ce .MakeArray (_ce .MakeInteger (_egegb ),_ce .MakeName ("\u0058\u0059\u005a"),_ce .MakeFloat (_ebcd ),_ce .MakeFloat (_bbgd ),_ce .MakeFloat (_gegc ));return _bbef .PdfAnnotation ;
};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_bfeg *Creator )NewStyledParagraph ()*StyledParagraph {return _ebgd (_bfeg .NewTextStyle ())};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_cdea *TOC )SetLineSeparator (separator string ){_cdea ._fabb =separator };func (_dadde *Table )wrapRow (_ggdc int ,_agaf DrawContext ,_ffcd float64 )(bool ,error ){if !_dadde ._fcda {return false ,nil ;};var (_eadgc =_dadde ._cfcg [_ggdc ];_fege =-1;
_afba []*TableCell ;_fdcd float64 ;_cbgab bool ;_cfed =make ([]float64 ,0,len (_dadde ._baecg )););_bffb :=func (_cgebg *TableCell ,_acgd VectorDrawable ,_gedad bool )*TableCell {_bcaec :=*_cgebg ;_bcaec ._daac =_acgd ;if _gedad {_bcaec ._aadbf ++;};return &_bcaec ;
};_cgafd :=func (_dgceg int ,_aacgd VectorDrawable ){var _fgcba float64 =-1;if _aacgd ==nil {if _baabe :=_cfed [_dgceg -_ggdc ];_baabe > _agaf .Height {_aacgd =_dadde ._cfcg [_dgceg ]._daac ;_dadde ._cfcg [_dgceg ]._daac =nil ;_cfed [_dgceg -_ggdc ]=0;
_fgcba =_baabe ;};};_fdga :=_bffb (_dadde ._cfcg [_dgceg ],_aacgd ,true );_afba =append (_afba ,_fdga );if _fgcba < 0{_fgcba =_fdga .height (_agaf .Width );};if _fgcba > _fdcd {_fdcd =_fgcba ;};};for _abcea :=_ggdc ;_abcea < len (_dadde ._cfcg );_abcea ++{_gcdg :=_dadde ._cfcg [_abcea ];
if _eadgc ._aadbf !=_gcdg ._aadbf {_fege =_abcea ;break ;};_agaf .Width =_gcdg .width (_dadde ._baecg ,_ffcd );var _cecec VectorDrawable ;switch _fggfe :=_gcdg ._daac .(type ){case *StyledParagraph :if _cgdb :=_gcdg .height (_agaf .Width );_cgdb > _agaf .Height {_edaf :=_agaf ;
_edaf .Height =_bf .Floor (_agaf .Height -_fggfe ._abed .Top -_fggfe ._abed .Bottom -0.5*_fggfe .getTextHeight ());_acgdb ,_afeg ,_bbbb :=_fggfe .split (_edaf );if _bbbb !=nil {return false ,_bbbb ;};if _acgdb !=nil &&_afeg !=nil {_fggfe =_acgdb ;_gcdg =_bffb (_gcdg ,_acgdb ,false );
_dadde ._cfcg [_abcea ]=_gcdg ;_cecec =_afeg ;_cbgab =true ;};};};_cfed =append (_cfed ,_gcdg .height (_agaf .Width ));if _cbgab {if _afba ==nil {_afba =make ([]*TableCell ,0,len (_dadde ._baecg ));for _cedba :=_ggdc ;_cedba < _abcea ;_cedba ++{_cgafd (_cedba ,nil );
};};_cgafd (_abcea ,_cecec );};};var _cega float64 ;for _ ,_ebeba :=range _cfed {if _ebeba > _cega {_cega =_ebeba ;};};if _cbgab &&_cega < _agaf .Height {if _fege < 0{_fege =len (_dadde ._cfcg );};_ecfb :=_dadde ._cfcg [_fege -1]._aadbf +_dadde ._cfcg [_fege -1]._cdfg -1;
for _edbe :=_fege ;_edbe < len (_dadde ._cfcg );_edbe ++{_dadde ._cfcg [_edbe ]._aadbf ++;};_dadde ._cfcg =append (_dadde ._cfcg [:_fege ],append (_afba ,_dadde ._cfcg [_fege :]...)...);_dadde ._egcc =append (_dadde ._egcc [:_ecfb ],append ([]float64 {_fdcd },_dadde ._egcc [_ecfb :]...)...);
_dadde ._egcc [_eadgc ._aadbf +_eadgc ._cdfg -2]=_cega ;};return _cbgab ,nil ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_cefd *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_ecdb :=&_cefd ._faaf ;_ecdb .Left =left ;_ecdb .Right =right ;_ecdb .Top =top ;_ecdb .Bottom =bottom ;};func (_ccfe *Chapter )headingText ()string {_ebb :=_ccfe ._cadf ;if _gebgc :=_ccfe .headingNumber ();
_gebgc !=""{_ebb =_ae .Sprintf ("\u0025\u0073\u0020%\u0073",_gebgc ,_ebb );};return _ebb ;};func (_fbeg *Creator )newPage ()*_ffb .PdfPage {_dgee :=_ffb .NewPdfPage ();_aeca :=_fbeg ._fga [0];_cfef :=_fbeg ._fga [1];_fgdc :=_ffb .PdfRectangle {Llx :0,Lly :0,Urx :_aeca ,Ury :_cfef };
_dgee .MediaBox =&_fgdc ;_fbeg ._bddd =_aeca ;_fbeg ._bbeg =_cfef ;_fbeg .initContext ();return _dgee ;};

// SetFillColor sets the fill color for the path.
func (_bfeca *FilledCurve )SetFillColor (color Color ){_bfeca ._ecbf =color };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_cebdf *Image )SetPos (x ,y float64 ){_cebdf ._ggfg =PositionAbsolute ;_cebdf ._gcag =x ;_cebdf ._bbcb =y ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_caac *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _f .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_caac ._egcg =true ;_caac ._cddb =startRow ;_caac ._efdca =endRow ;return nil ;};

// SetFillColor sets the fill color.
func (_ddbc *PolyBezierCurve )SetFillColor (color Color ){_ddbc ._bfccb .FillColor =_cbae (color )};func (_cddg *StyledParagraph )getTextWidth ()float64 {var _ggee float64 ;_caafg :=len (_cddg ._eecg );for _acda ,_bgbe :=range _cddg ._eecg {_gfgca :=&_bgbe .Style ;
_gabe :=len (_bgbe .Text );for _egadf ,_dbeg :=range _bgbe .Text {if _dbeg =='\u000A'{continue ;};_bdac ,_bcbe :=_gfgca .Font .GetRuneMetrics (_dbeg );if !_bcbe {_ca .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dbeg );
return -1;};_ggee +=_gfgca .FontSize *_bdac .Wx *_gfgca .horizontalScale ();if _dbeg !=' '&&(_acda !=_caafg -1||_egadf !=_gabe -1){_ggee +=_gfgca .CharSpacing *1000.0;};};};return _ggee ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_dfgb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_dfgb ._eabab =valign };

// GeneratePageBlocks implements drawable interface.
func (_geb *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_afea :=_geb ._cg ;_gbed :=ctx .PageHeight -_geb ._fdcc ;if _geb ._eag !=nil {_eefa :=_bd .Rectangle {Opacity :1.0,X :_geb ._cg ,Y :ctx .PageHeight -_geb ._fdcc -_geb ._ceab ,Height :_geb ._ceab ,Width :_geb ._fca };
_eefa .FillEnabled =true ;_eefa .FillColor =_cbae (_geb ._eag );_eefa .BorderEnabled =false ;_cfcb ,_ ,_fgb :=_eefa .Draw ("");if _fgb !=nil {return nil ,ctx ,_fgb ;};_fgb =_bde .addContentsByString (string (_cfcb ));if _fgb !=nil {return nil ,ctx ,_fgb ;
};};_bfdd :=_geb ._gaec ;_fbbf :=_geb ._dce ;_adgd :=_geb ._ggcc ;_eeb :=_geb ._edf ;_gce :=_geb ._gaec ;if _geb ._bag ==CellBorderStyleDouble {_gce +=2*_bfdd ;};_gdd :=_geb ._dce ;if _geb ._edd ==CellBorderStyleDouble {_gdd +=2*_fbbf ;};_adce :=_geb ._ggcc ;
if _geb ._ggd ==CellBorderStyleDouble {_adce +=2*_adgd ;};_daeg :=_geb ._edf ;if _geb ._daf ==CellBorderStyleDouble {_daeg +=2*_eeb ;};if _geb ._gaec !=0{_eggg :=_afea ;_bcb :=_gbed ;if _geb ._bag ==CellBorderStyleDouble {_bcb -=_bfdd ;_bfcf :=_bd .BasicLine {};
_bfcf .X1 =_eggg -_gce /2;_bfcf .Y1 =_bcb +2*_bfdd ;_bfcf .X2 =_eggg +_geb ._fca +_gce /2;_bfcf .Y2 =_bcb +2*_bfdd ;_bfcf .LineColor =_cbae (_geb ._bcdd );_bfcf .LineWidth =_geb ._gaec ;_bfcf .LineStyle =_geb .LineStyle ;_afgd ,_ ,_ggcb :=_bfcf .Draw ("");
if _ggcb !=nil {return nil ,ctx ,_ggcb ;};_ggcb =_bde .addContentsByString (string (_afgd ));if _ggcb !=nil {return nil ,ctx ,_ggcb ;};};_cace :=_bd .BasicLine {LineWidth :_geb ._gaec ,Opacity :1.0,LineColor :_cbae (_geb ._bcdd ),X1 :_eggg -_gce /2+(_adce -_geb ._ggcc ),Y1 :_bcb ,X2 :_eggg +_geb ._fca +_gce /2-(_daeg -_geb ._edf ),Y2 :_bcb ,LineStyle :_geb .LineStyle };
_fbag ,_ ,_gebg :=_cace .Draw ("");if _gebg !=nil {return nil ,ctx ,_gebg ;};_gebg =_bde .addContentsByString (string (_fbag ));if _gebg !=nil {return nil ,ctx ,_gebg ;};};if _geb ._dce !=0{_dcc :=_afea ;_feb :=_gbed -_geb ._ceab ;if _geb ._edd ==CellBorderStyleDouble {_feb +=_fbbf ;
_fbd :=_bd .BasicLine {LineWidth :_geb ._dce ,Opacity :1.0,LineColor :_cbae (_geb ._dba ),X1 :_dcc -_gdd /2,Y1 :_feb -2*_fbbf ,X2 :_dcc +_geb ._fca +_gdd /2,Y2 :_feb -2*_fbbf ,LineStyle :_geb .LineStyle };_feef ,_ ,_gge :=_fbd .Draw ("");if _gge !=nil {return nil ,ctx ,_gge ;
};_gge =_bde .addContentsByString (string (_feef ));if _gge !=nil {return nil ,ctx ,_gge ;};};_fcge :=_bd .BasicLine {LineWidth :_geb ._dce ,Opacity :1.0,LineColor :_cbae (_geb ._dba ),X1 :_dcc -_gdd /2+(_adce -_geb ._ggcc ),Y1 :_feb ,X2 :_dcc +_geb ._fca +_gdd /2-(_daeg -_geb ._edf ),Y2 :_feb ,LineStyle :_geb .LineStyle };
_dag ,_ ,_deg :=_fcge .Draw ("");if _deg !=nil {return nil ,ctx ,_deg ;};_deg =_bde .addContentsByString (string (_dag ));if _deg !=nil {return nil ,ctx ,_deg ;};};if _geb ._ggcc !=0{_cdg :=_afea ;_edfd :=_gbed ;if _geb ._ggd ==CellBorderStyleDouble {_cdg +=_adgd ;
_acce :=_bd .BasicLine {LineWidth :_geb ._ggcc ,Opacity :1.0,LineColor :_cbae (_geb ._gaae ),X1 :_cdg -2*_adgd ,Y1 :_edfd +_adce /2,X2 :_cdg -2*_adgd ,Y2 :_edfd -_geb ._ceab -_adce /2,LineStyle :_geb .LineStyle };_dcgc ,_ ,_gdcc :=_acce .Draw ("");if _gdcc !=nil {return nil ,ctx ,_gdcc ;
};_gdcc =_bde .addContentsByString (string (_dcgc ));if _gdcc !=nil {return nil ,ctx ,_gdcc ;};};_bcde :=_bd .BasicLine {LineWidth :_geb ._ggcc ,Opacity :1.0,LineColor :_cbae (_geb ._gaae ),X1 :_cdg ,Y1 :_edfd +_adce /2-(_gce -_geb ._gaec ),X2 :_cdg ,Y2 :_edfd -_geb ._ceab -_adce /2+(_gdd -_geb ._dce ),LineStyle :_geb .LineStyle };
_dege ,_ ,_bdg :=_bcde .Draw ("");if _bdg !=nil {return nil ,ctx ,_bdg ;};_bdg =_bde .addContentsByString (string (_dege ));if _bdg !=nil {return nil ,ctx ,_bdg ;};};if _geb ._edf !=0{_ccf :=_afea +_geb ._fca ;_dgc :=_gbed ;if _geb ._daf ==CellBorderStyleDouble {_ccf -=_eeb ;
_acg :=_bd .BasicLine {LineWidth :_geb ._edf ,Opacity :1.0,LineColor :_cbae (_geb ._cee ),X1 :_ccf +2*_eeb ,Y1 :_dgc +_daeg /2,X2 :_ccf +2*_eeb ,Y2 :_dgc -_geb ._ceab -_daeg /2,LineStyle :_geb .LineStyle };_cae ,_ ,_cccd :=_acg .Draw ("");if _cccd !=nil {return nil ,ctx ,_cccd ;
};_cccd =_bde .addContentsByString (string (_cae ));if _cccd !=nil {return nil ,ctx ,_cccd ;};};_gdg :=_bd .BasicLine {LineWidth :_geb ._edf ,Opacity :1.0,LineColor :_cbae (_geb ._cee ),X1 :_ccf ,Y1 :_dgc +_daeg /2-(_gce -_geb ._gaec ),X2 :_ccf ,Y2 :_dgc -_geb ._ceab -_daeg /2+(_gdd -_geb ._dce ),LineStyle :_geb .LineStyle };
_abd ,_ ,_cdfa :=_gdg .Draw ("");if _cdfa !=nil {return nil ,ctx ,_cdfa ;};_cdfa =_bde .addContentsByString (string (_abd ));if _cdfa !=nil {return nil ,ctx ,_cdfa ;};};return []*Block {_bde },ctx ,nil ;};

// SetBorderOpacity sets the border opacity.
func (_affde *Polygon )SetBorderOpacity (opacity float64 ){_affde ._fbdeb =opacity };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_ffcb float64 ;_dda float64 ;_ddec float64 ;_bbce float64 ;_dacea Color ;_cecfd Color ;_aaffc float64 ;};func _dbg (_gad ,_gdf *_ffb .PdfPageResources )error {_adf ,_ :=_gad .GetColorspaces ();if _adf !=nil &&len (_adf .Colorspaces )> 0{for _afbb ,_aaca :=range _adf .Colorspaces {_fdd :=*_ce .MakeName (_afbb );
if _gdf .HasColorspaceByName (_fdd ){continue ;};_cfg :=_gdf .SetColorspaceByName (_fdd ,_aaca );if _cfg !=nil {return _cfg ;};};};return nil ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_deb :float64 (r )/255.0,_cfbd :float64 (g )/255.0,_feaf :float64 (b )/255.0};};

// Context returns the current drawing context.
func (_gdec *Creator )Context ()DrawContext {return _gdec ._acag };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_dcbf *Creator )NewTextStyle ()TextStyle {return _adga (_dcbf ._dbc )};

// NewTOCLine creates a new table of contents line with the default style.
func (_adde *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _dcfa (number ,title ,page ,level ,_adde .NewTextStyle ());};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_bbga *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gddeg :=_bd .Rectangle {Opacity :1.0,X :_bbga ._afgf ,Y :ctx .PageHeight -_bbga ._dccg -_bbga ._bcgga ,Height :_bbga ._bcgga ,Width :_bbga ._eggcc };
if _bbga ._gaf !=nil {_gddeg .FillEnabled =true ;_gddeg .FillColor =_cbae (_bbga ._gaf );};if _bbga ._begf !=nil &&_bbga ._aegc > 0{_gddeg .BorderEnabled =true ;_gddeg .BorderColor =_cbae (_bbga ._begf );_gddeg .BorderWidth =_bbga ._aegc ;};_fccea ,_aebdb :=_cbb .setOpacity (_bbga ._dgce ,_bbga ._fdcaea );
if _aebdb !=nil {return nil ,ctx ,_aebdb ;};_egcb ,_ ,_aebdb :=_gddeg .Draw (_fccea );if _aebdb !=nil {return nil ,ctx ,_aebdb ;};if _aebdb =_cbb .addContentsByString (string (_egcb ));_aebdb !=nil {return nil ,ctx ,_aebdb ;};return []*Block {_cbb },ctx ,nil ;
};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};func (_adgdg *TOCLine )prepareParagraph (_gdea *StyledParagraph ,_aagd DrawContext ){_ecdaa :=_adgdg .Title .Text ;if _adgdg .Number .Text !=""{_ecdaa ="\u0020"+_ecdaa ;};_ecdaa +="\u0020";_dgcfe :=_adgdg .Page .Text ;
if _dgcfe !=""{_dgcfe ="\u0020"+_dgcfe ;};_gdea ._eecg =[]*TextChunk {{Text :_adgdg .Number .Text ,Style :_adgdg .Number .Style ,_gbbe :_adgdg .getLineLink ()},{Text :_ecdaa ,Style :_adgdg .Title .Style ,_gbbe :_adgdg .getLineLink ()},{Text :_dgcfe ,Style :_adgdg .Page .Style ,_gbbe :_adgdg .getLineLink ()}};
_gdea .wrapText ();_adcfc :=len (_gdea ._bcfb );if _adcfc ==0{return ;};_ggfef :=_aagd .Width *1000-_gdea .getTextLineWidth (_gdea ._bcfb [_adcfc -1]);_dbac :=_gdea .getTextLineWidth ([]*TextChunk {&_adgdg .Separator });_ggfca :=int (_ggfef /_dbac );_cbgfd :=_aff .Repeat (_adgdg .Separator .Text ,_ggfca );
_ffbc :=_adgdg .Separator .Style ;_fead :=_gdea .Insert (2,_cbgfd );_fead .Style =_ffbc ;_fead ._gbbe =_adgdg .getLineLink ();_ggfef =_ggfef -float64 (_ggfca )*_dbac ;if _ggfef > 500{_ddgd ,_bbffa :=_ffbc .Font .GetRuneMetrics (' ');if _bbffa &&_ggfef > _ddgd .Wx {_abaa :=int (_ggfef /_ddgd .Wx );
if _abaa > 0{_gdgg :=_ffbc ;_gdgg .FontSize =1;_fead =_gdea .Insert (2,_aff .Repeat ("\u0020",_abaa ));_fead .Style =_gdgg ;_fead ._gbbe =_adgdg .getLineLink ();};};};};func (_adfa *Paragraph )getTextWidth ()float64 {_cafe :=0.0;for _ ,_gff :=range _adfa ._ggacg {if _gff =='\u000A'{continue ;
};_ecca ,_cfdc :=_adfa ._gagd .GetRuneMetrics (_gff );if !_cfdc {_ca .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gff ,_gff );
return -1;};_cafe +=_adfa ._fge *_ecca .Wx ;};return _cafe ;};

// Rows returns the total number of rows the table has.
func (_ggcgb *Table )Rows ()int {return _ggcgb ._cdeg };func (_acceb *Invoice )newCell (_edfc string ,_abfd InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_abfd ,_edfc };};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_dcgd *Paragraph )SetWidth (width float64 ){_dcgd ._ceae =width ;_dcgd .wrapText ()};

// AddTotalLine adds a new line in the invoice totals table.
func (_bbbgf *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_egde :=&InvoiceCell {_bbbgf ._dcd ,desc };_geceg :=&InvoiceCell {_bbbgf ._dcd ,value };_bbbgf ._bcc =append (_bbbgf ._bcc ,[2]*InvoiceCell {_egde ,_geceg });return _egde ,_geceg ;
};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_eeaa *Table )Width ()float64 {return 0};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_cabf *TOC )SetLineNumberStyle (style TextStyle ){_cabf ._cgab =style };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_ebf *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _cagf (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bceb *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _bceb ._gebb [0],_bceb ._gebb [1]};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bdge *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _bdge ._geef [0],_bdge ._geef [1]};

// SetColorTop sets border color for top.
func (_cfcf *border )SetColorTop (col Color ){_cfcf ._bcdd =col };func _fgbe ()*PageBreak {return &PageBreak {}};func (_db *Block )setOpacity (_eb float64 ,_de float64 )(string ,error ){if (_eb < 0||_eb >=1.0)&&(_de < 0||_de >=1.0){return "",nil ;};_fd :=0;
_ea :=_ae .Sprintf ("\u0047\u0053\u0025\u0064",_fd );for _db ._d .HasExtGState (_ce .PdfObjectName (_ea )){_fd ++;_ea =_ae .Sprintf ("\u0047\u0053\u0025\u0064",_fd );};_cc :=_ce .MakeDict ();if _eb >=0&&_eb < 1.0{_cc .Set ("\u0063\u0061",_ce .MakeFloat (_eb ));
};if _de >=0&&_de < 1.0{_cc .Set ("\u0043\u0041",_ce .MakeFloat (_de ));};_eae :=_db ._d .AddExtGState (_ce .PdfObjectName (_ea ),_cc );if _eae !=nil {return "",_eae ;};return _ea ,nil ;};func _geee (_fgfg ,_eecd ,_gcbc ,_bcef float64 )*Line {_dgbb :=&Line {};
_dgbb ._aadd =_fgfg ;_dgbb ._becfa =_eecd ;_dgbb ._cade =_gcbc ;_dgbb ._ccce =_bcef ;_dgbb ._daa =ColorBlack ;_dgbb ._bacc =1.0;return _dgbb ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_defa *Creator )SetPageSize (size PageSize ){_defa ._fga =size ;_defa ._bddd =size [0];_defa ._bbeg =size [1];_cbee :=0.1*_defa ._bddd ;_defa ._bbe .Left =_cbee ;_defa ._bbe .Right =_cbee ;_defa ._bbe .Top =_cbee ;_defa ._bbe .Bottom =_cbee ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gegd *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _egff float64 ;var _ebeb []*StyledParagraph ;for _ ,_dcae :=range _gegd ._baece {_gbag :=_ebgd (_gegd ._abgcc );_gbag .SetEnableWrap (false );_gbag .SetTextAlignment (TextAlignmentRight );
_gbag .Append (_dcae ._dcdf .Text ).Style =_dcae ._dcdf .Style ;_bcce :=_gbag .getTextWidth ()/1000.0/ctx .Width ;if _egff < _bcce {_egff =_bcce ;};_ebeb =append (_ebeb ,_gbag );};_ccde :=_cgcge (2);_ccde .SetColumnWidths (_egff ,1-_egff );_ccde .SetMargins (_gegd ._dbfg ,0,0,0);
for _acfb ,_eccg :=range _gegd ._baece {_gbgd :=_ccde .NewCell ();_gbgd .SetIndent (0);_gbgd .SetContent (_ebeb [_acfb ]);_gbgd =_ccde .NewCell ();_gbgd .SetIndent (0);_gbgd .SetContent (_eccg ._gbbc );};return _ccde .GeneratePageBlocks (ctx );};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_bdcdb *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_gfef :=range subtable ._cfcg {_agbdg :=&TableCell {};*_agbdg =*_gfef ;_agbdg ._afee =_bdcdb ;_agbdg ._ggcga +=col -1;if _fdbc :=_bdcdb ._dgdba -(_agbdg ._ggcga -1);_fdbc < _agbdg ._dbfgc {_bdcdb ._dgdba +=_agbdg ._dbfgc -_fdbc ;
_bdcdb .resetColumnWidths ();_ca .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_bdcdb ._dgdba );
};_agbdg ._aadbf +=row -1;_ffgb :=subtable ._egcc [_gfef ._aadbf -1];if _agbdg ._aadbf > _bdcdb ._cdeg {for _agbdg ._aadbf > _bdcdb ._cdeg {_bdcdb ._cdeg ++;_bdcdb ._egcc =append (_bdcdb ._egcc ,_bdcdb ._ebgeb );};_bdcdb ._egcc [_agbdg ._aadbf -1]=_ffgb ;
}else {_bdcdb ._egcc [_agbdg ._aadbf -1]=_bf .Max (_bdcdb ._egcc [_agbdg ._aadbf -1],_ffgb );};_bdcdb ._cfcg =append (_bdcdb ._cfcg ,_agbdg );};_ff .Slice (_bdcdb ._cfcg ,func (_eefg ,_faed int )bool {_gedgc :=_bdcdb ._cfcg [_eefg ]._aadbf ;_agbe :=_bdcdb ._cfcg [_faed ]._aadbf ;
if _gedgc < _agbe {return true ;};if _gedgc > _agbe {return false ;};return _bdcdb ._cfcg [_eefg ]._ggcga < _bdcdb ._cfcg [_faed ]._ggcga ;});};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;
);

// SetWidthTop sets border width for top.
func (_abe *border )SetWidthTop (bw float64 ){_abe ._gaec =bw };func _aaeg (_befd ,_cbeg ,_bgdd ,_ccfbe float64 )*Rectangle {return &Rectangle {_afgf :_befd ,_dccg :_cbeg ,_eggcc :_bgdd ,_bcgga :_ccfbe ,_begf :ColorBlack ,_aegc :1.0,_dgce :1.0,_fdcaea :1.0};
};

// SetInline sets the inline mode of the division.
func (_cebdc *Division )SetInline (inline bool ){_cebdc ._gefg =inline };func (_defc *Table )resetColumnWidths (){_defc ._baecg =[]float64 {};_baba :=float64 (1.0)/float64 (_defc ._dgdba );for _agae :=0;_agae < _defc ._dgdba ;_agae ++{_defc ._baecg =append (_defc ._baecg ,_baba );
};};func (_agf cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_eed :=_agf ._efa ;return 1-(_agf ._fcfb *(1-_eed )+_eed ),1-(_agf ._agd *(1-_eed )+_eed ),1-(_agf ._gea *(1-_eed )+_eed );};

// SetTotal sets the total of the invoice.
func (_edeg *Invoice )SetTotal (value string ){_edeg ._gebb [1].Value =value };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_caa *Invoice )Sections ()[][2]string {return _caa ._fbaf };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_agg *Creator )SetOutlineTree (outlineTree *_ffb .PdfOutlineTreeNode ){_agg ._fdca =outlineTree };func (_gc *Block )drawToPage (_fbgg *_ffb .PdfPage )error {_cfe :=&_eff .ContentStreamOperations {};if _fbgg .Resources ==nil {_fbgg .Resources =_ffb .NewPdfPageResources ();
};_efc :=_cfc (_cfe ,_fbgg .Resources ,_gc ._fb ,_gc ._d );if _efc !=nil {return _efc ;};if _efc =_dbg (_gc ._d ,_fbgg .Resources );_efc !=nil {return _efc ;};if _efc =_fbgg .AppendContentBytes (_cfe .Bytes (),true );_efc !=nil {return _efc ;};for _ ,_bfd :=range _gc ._fbb {_fbgg .AddAnnotation (_bfd );
};return nil ;};func _bfceeg (_gbdaf *_ffb .PdfRectangle ,_beea _ee .Matrix )*_ffb .PdfRectangle {var _caad _ffb .PdfRectangle ;_caad .Llx ,_caad .Lly =_beea .Transform (_gbdaf .Llx ,_gbdaf .Lly );_caad .Urx ,_caad .Ury =_beea .Transform (_gbdaf .Urx ,_gbdaf .Ury );
_caad .Normalize ();return &_caad ;};

// SetTitle sets the title of the invoice.
func (_baeff *Invoice )SetTitle (title string ){_baeff ._dbe =title };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ece *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ece ._bff .Left ,_ece ._bff .Right ,_ece ._bff .Top ,_ece ._bff .Bottom ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_dfff *Image )GetHorizontalAlignment ()HorizontalAlignment {return _dfff ._fbge };

// TextAlignment options for paragraph.
type TextAlignment int ;const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_dfcf *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_dfcf ._fbge =alignment };

// SetColorBottom sets border color for bottom.
func (_bbff *border )SetColorBottom (col Color ){_bbff ._dba =col };

// Lines returns all the lines the table of contents has.
func (_aegbe *TOC )Lines ()[]*TOCLine {return _aegbe ._bacb };

// InsertColumn inserts a column in the line items table at the specified index.
func (_febb *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_gadg :=uint (len (_febb ._fbdb ));if index > _gadg {index =_gadg ;};_eea :=_febb .NewColumn (description );_febb ._fbdb =append (_febb ._fbdb [:index ],append ([]*InvoiceCell {_eea },_febb ._fbdb [index :]...)...);
return _eea ;};

// SetBorderOpacity sets the border opacity.
func (_fddb *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_fddb ._ceda =opacity };

// Scale scales Image by a constant factor, both width and height.
func (_bfba *Image )Scale (xFactor ,yFactor float64 ){_bfba ._fcd =xFactor *_bfba ._fcd ;_bfba ._gfgd =yFactor *_bfba ._gfgd ;};const (DefaultHorizontalScaling =100;);

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// Add adds a new Drawable to the chapter.
func (_cbea *Chapter )Add (d Drawable )error {if Drawable (_cbea )==d {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cfec :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_cbea ._edb =append (_cbea ._edb ,d );case containerDrawable :_egb ,_dfbc :=_cfec .ContainerComponent (_cbea );if _dfbc !=nil {return _dfbc ;};
_cbea ._edb =append (_cbea ._edb ,_egb );default:_ca .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_cedad *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_cedad ._ebba =textOverflow ;};

// SetFont sets the Paragraph's font.
func (_dbbg *Paragraph )SetFont (font *_ffb .PdfFont ){_dbbg ._gagd =font };func _ebgd (_bead TextStyle )*StyledParagraph {return &StyledParagraph {_eecg :[]*TextChunk {},_cdef :_bead ,_dbcgc :_cbbg (_bead .Font ),_efdf :1.0,_cbeag :TextAlignmentLeft ,_adbb :true ,_ceca :true ,_dccbc :0,_bfga :1,_fgeb :1,_gebf :PositionRelative };
};

// SetEnableWrap sets the line wrapping enabled flag.
func (_dega *Paragraph )SetEnableWrap (enableWrap bool ){_dega ._ggbe =enableWrap ;_dega ._fedg =false };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_cgfg *Invoice )SetNoteStyle (style TextStyle ){_cgfg ._fadf =style };

// Indent returns the left offset of the list when nested into another list.
func (_fcff *List )Indent ()float64 {return _fcff ._dbfg };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };
);

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_gegbf *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efbec :=ctx ;var _ggfc []*Block ;_fcec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gegbf ._gebf .IsRelative (){ctx .X +=_gegbf ._abed .Left ;ctx .Y +=_gegbf ._abed .Top ;
ctx .Width -=_gegbf ._abed .Left +_gegbf ._abed .Right ;ctx .Height -=_gegbf ._abed .Top +_gegbf ._abed .Bottom ;_gegbf .SetWidth (ctx .Width );}else {if int (_gegbf ._ffeb )<=0{_gegbf .SetWidth (_gegbf .getTextWidth ()/1000.0);};ctx .X =_gegbf ._egfb ;
ctx .Y =_gegbf ._cdagf ;};if _gegbf ._eaeee !=nil {_gegbf ._eaeee (_gegbf ,ctx );};if _caba :=_gegbf .wrapText ();_caba !=nil {return nil ,ctx ,_caba ;};_bgfb :=_gegbf ._bcfb ;for {_aafaf ,_dcfdb ,_ebffb :=_gfgda (_fcec ,_gegbf ,_bgfb ,ctx );if _ebffb !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebffb );
return nil ,ctx ,_ebffb ;};ctx =_aafaf ;_ggfc =append (_ggfc ,_fcec );if _bgfb =_dcfdb ;len (_dcfdb )==0{break ;};_fcec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_aafaf =ctx ;_aafaf .Y =ctx .Margins .Top ;_aafaf .X =ctx .Margins .Left +_gegbf ._abed .Left ;
_aafaf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gegbf ._abed .Bottom ;_aafaf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gegbf ._abed .Left -_gegbf ._abed .Right ;ctx =_aafaf ;};if _gegbf ._gebf .IsRelative (){ctx .X -=_gegbf ._abed .Left ;
ctx .Width =_efbec .Width ;return _ggfc ,ctx ,nil ;};return _ggfc ,_efbec ,nil ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_ba *Block )SetPos (x ,y float64 ){_ba ._gb =PositionAbsolute ;_ba ._ad =x ;_ba ._gd =y };func _cgcge (_bbgg int )*Table {_cfcbc :=&Table {_dgdba :_bbgg ,_ebgeb :10.0,_baecg :[]float64 {},_egcc :[]float64 {},_cfcg :[]*TableCell {}};_cfcbc .resetColumnWidths ();
return _cfcbc ;};

// Logo returns the logo of the invoice.
func (_bfabg *Invoice )Logo ()*Image {return _bfabg ._adcf };

// SetIndent sets the cell's left indent.
func (_gbdd *TableCell )SetIndent (indent float64 ){_gbdd ._decca =indent };

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_bfcfd *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfcee :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bggd :=_bd .Circle {X :_bfcfd ._ffcb -_bfcfd ._ddec /2,Y :ctx .PageHeight -_bfcfd ._dda -_bfcfd ._bbce /2,Width :_bfcfd ._ddec ,Height :_bfcfd ._bbce ,Opacity :1.0,BorderWidth :_bfcfd ._aaffc };
if _bfcfd ._dacea !=nil {_bggd .FillEnabled =true ;_bggd .FillColor =_cbae (_bfcfd ._dacea );};if _bfcfd ._cecfd !=nil {_bggd .BorderEnabled =true ;_bggd .BorderColor =_cbae (_bfcfd ._cecfd );_bggd .BorderWidth =_bfcfd ._aaffc ;};_cebb ,_ ,_bfef :=_bggd .Draw ("");
if _bfef !=nil {return nil ,ctx ,_bfef ;};_bfef =_bfcee .addContentsByString (string (_cebb ));if _bfef !=nil {return nil ,ctx ,_bfef ;};return []*Block {_bfcee },ctx ,nil ;};

// Width returns Image's document width.
func (_bgea *Image )Width ()float64 {return _bgea ._fcd };

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_gabd *Invoice )InfoLines ()[][2]*InvoiceCell {_acdd :=[][2]*InvoiceCell {_gabd ._geef ,_gabd ._bbg ,_gabd ._bgbde };return append (_acdd ,_gabd ._fdde ...);};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_fdbg *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _eefc (xc ,yc ,width ,height );};

// NewFilledCurve returns a instance of filled curve.
func (_bfdg *Creator )NewFilledCurve ()*FilledCurve {return _bcab ()};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_fdaf *Creator )NewImageFromGoImage (goimg _c .Image )(*Image ,error ){return _faff (goimg )};func _ddge (_daea *Block ,_fcbdb *Paragraph ,_eddb DrawContext )(DrawContext ,error ){_beab :=1;_faec :=_ce .PdfObjectName ("\u0046\u006f\u006e\u0074"+_af .Itoa (_beab ));
for _daea ._d .HasFontByName (_faec ){_beab ++;_faec =_ce .PdfObjectName ("\u0046\u006f\u006e\u0074"+_af .Itoa (_beab ));};_abce :=_daea ._d .SetFontByName (_faec ,_fcbdb ._gagd .ToPdfObject ());if _abce !=nil {return _eddb ,_abce ;};_fcbdb .wrapText ();
_fgea :=_eff .NewContentCreator ();_fgea .Add_q ();_dfdb :=_eddb .PageHeight -_eddb .Y -_fcbdb ._fge *_fcbdb ._efgdb ;_fgea .Translate (_eddb .X ,_dfdb );if _fcbdb ._gggb !=0{_fgea .RotateDeg (_fcbdb ._gggb );};_fgea .Add_BT ().SetNonStrokingColor (_cbae (_fcbdb ._bcfe )).Add_Tf (_faec ,_fcbdb ._fge ).Add_TL (_fcbdb ._fge *_fcbdb ._efgdb );
for _egad ,_gace :=range _fcbdb ._afgg {if _egad !=0{_fgea .Add_Tstar ();};_ggag :=[]rune (_gace );_ebfa :=0.0;_fbcc :=0;for _gaaff ,_effe :=range _ggag {if _effe ==' '{_fbcc ++;continue ;};if _effe =='\u000A'{continue ;};_fcbdf ,_bceg :=_fcbdb ._gagd .GetRuneMetrics (_effe );
if !_bceg {_ca .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_gaaff ,_effe ,_effe ,_fcbdb ._gagd .BaseFont (),_fcbdb ._gagd .Subtype ());
return _eddb ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_ebfa +=_fcbdb ._fge *_fcbdf .Wx ;};var _bbege []_ce .PdfObject ;_cdec ,_ggcfc :=_fcbdb ._gagd .GetRuneMetrics (' ');
if !_ggcfc {return _eddb ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ebbd :=_cdec .Wx ;switch _fcbdb ._ebfb {case TextAlignmentJustify :if _fbcc > 0&&_egad < len (_fcbdb ._afgg )-1{_ebbd =(_fcbdb ._ceae *1000.0-_ebfa )/float64 (_fbcc )/_fcbdb ._fge ;
};case TextAlignmentCenter :_bccb :=_ebfa +float64 (_fbcc )*_ebbd *_fcbdb ._fge ;_gaed :=(_fcbdb ._ceae *1000.0-_bccb )/2/_fcbdb ._fge ;_bbege =append (_bbege ,_ce .MakeFloat (-_gaed ));case TextAlignmentRight :_cbaee :=_ebfa +float64 (_fbcc )*_ebbd *_fcbdb ._fge ;
_afca :=(_fcbdb ._ceae *1000.0-_cbaee )/_fcbdb ._fge ;_bbege =append (_bbege ,_ce .MakeFloat (-_afca ));};_aaaca :=_fcbdb ._gagd .Encoder ();var _ecda []byte ;for _ ,_ceef :=range _ggag {if _ceef =='\u000A'{continue ;};if _ceef ==' '{if len (_ecda )> 0{_bbege =append (_bbege ,_ce .MakeStringFromBytes (_ecda ));
_ecda =nil ;};_bbege =append (_bbege ,_ce .MakeFloat (-_ebbd ));}else {if _ ,_dcfc :=_aaaca .RuneToCharcode (_ceef );!_dcfc {_ca .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ceef ,_ceef );
continue ;};_ecda =append (_ecda ,_aaaca .Encode (string (_ceef ))...);};};if len (_ecda )> 0{_bbege =append (_bbege ,_ce .MakeStringFromBytes (_ecda ));};_fgea .Add_TJ (_bbege ...);};_fgea .Add_ET ();_fgea .Add_Q ();_gdfc :=_fgea .Operations ();_gdfc .WrapIfNeeded ();
_daea .addContents (_gdfc );if _fcbdb ._agfce .IsRelative (){_bade :=_fcbdb .Height ()+_fcbdb ._abeae .Bottom ;_eddb .Y +=_bade ;_eddb .Height -=_bade ;if _eddb .Inline {_eddb .X +=_fcbdb .Width ()+_fcbdb ._abeae .Right ;};};return _eddb ,nil ;};

// SetBorderWidth sets the border width.
func (_bfg *Ellipse )SetBorderWidth (bw float64 ){_bfg ._aaffc =bw };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_gebd *Paragraph )Height ()float64 {_gebd .wrapText ();return float64 (len (_gebd ._afgg ))*_gebd ._efgdb *_gebd ._fge ;};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_aadd float64 ;_becfa float64 ;_cade float64 ;_ccce float64 ;_daa Color ;_bacc float64 ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};func (_aec *Block )translate (_gbe ,_dfa float64 ){_ecf :=_eff .NewContentCreator ().Translate (_gbe ,-_dfa ).Operations ();*_aec ._fb =append (*_ecf ,*_aec ._fb ...);_aec ._fb .WrapIfNeeded ();
};

// LevelOffset returns the amount of space an indentation level occupies.
func (_gagda *TOCLine )LevelOffset ()float64 {return _gagda ._cecg };func (_gbcc *TableCell )height (_edbea float64 )float64 {var _bbee float64 ;switch _bfgc :=_gbcc ._daac .(type ){case *Paragraph :if _bfgc ._ggbe {_bfgc .SetWidth (_edbea -_gbcc ._decca -_bfgc ._abeae .Left -_bfgc ._abeae .Right );
};_bbee =_bfgc .Height ()+_bfgc ._abeae .Top +_bfgc ._abeae .Bottom +0.5*_bfgc ._fge *_bfgc ._efgdb ;case *StyledParagraph :if _bfgc ._adbb {_bfgc .SetWidth (_edbea -_gbcc ._decca -_bfgc ._abed .Left -_bfgc ._abed .Right );};_bbee =_bfgc .Height ()+_bfgc ._abed .Top +_bfgc ._abed .Bottom +0.5*_bfgc .getTextHeight ();
case *Image :_bbee =_bfgc .Height ()+_bfgc ._ddcb .Top +_bfgc ._ddcb .Bottom ;case *Table :_bbee =_bfgc .Height ()+_bfgc ._bgaad .Top +_bfgc ._bgaad .Bottom ;case *List :_bbee =_bfgc .tableHeight (_edbea -_gbcc ._decca )+_bfgc ._ggde .Top +_bfgc ._ggde .Bottom ;
case *Division :_bbee =_bfgc .ctxHeight (_edbea -_gbcc ._decca )+_bfgc ._cdgd .Top +_bfgc ._cdgd .Bottom ;};return _bbee ;};

// SetBorder sets the cell's border style.
func (_becg *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_becg ._abde =CellBorderStyleSingle ;_becg ._cfddg =width ;_becg ._cfdfe =CellBorderStyleSingle ;
_becg ._ecae =width ;_becg ._accfe =CellBorderStyleSingle ;_becg ._gbcd =width ;_becg ._egbbg =CellBorderStyleSingle ;_becg ._fdgc =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_becg ._abde =CellBorderStyleDouble ;_becg ._cfddg =width ;
_becg ._cfdfe =CellBorderStyleDouble ;_becg ._ecae =width ;_becg ._accfe =CellBorderStyleDouble ;_becg ._gbcd =width ;_becg ._egbbg =CellBorderStyleDouble ;_becg ._fdgc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_becg ._abde =style ;
_becg ._cfddg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_becg ._cfdfe =style ;_becg ._ecae =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_becg ._accfe =style ;
_becg ._gbcd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_becg ._egbbg =style ;_becg ._fdgc =width ;};};func _abab (_agfc *_ffb .Image )(*Image ,error ){_cfdf :=float64 (_agfc .Width );_deef :=float64 (_agfc .Height );
return &Image {_dggd :_agfc ,_dgcc :_cfdf ,_dagea :_deef ,_fcd :_cfdf ,_gfgd :_deef ,_cbed :0,_fagg :1.0,_ggfg :PositionRelative },nil ;};

// NewCurvePolygon creates a new curve polygon.
func (_cfa *Creator )NewCurvePolygon (rings [][]_bd .CubicBezierCurve )*CurvePolygon {return _eedad (rings );};

// SetBorderWidth sets the border width.
func (_gffe *Polygon )SetBorderWidth (borderWidth float64 ){_gffe ._gbgc .BorderWidth =borderWidth };

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_bcae *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abgd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_becfe :=_bd .Line {LineWidth :_bcae ._bacc ,Opacity :1.0,LineColor :_cbae (_bcae ._daa ),LineEndingStyle1 :_bd .LineEndingStyleNone ,LineEndingStyle2 :_bd .LineEndingStyleNone ,X1 :_bcae ._aadd ,Y1 :ctx .PageHeight -_bcae ._becfa ,X2 :_bcae ._cade ,Y2 :ctx .PageHeight -_bcae ._ccce };
_egee ,_ ,_dedb :=_becfe .Draw ("");if _dedb !=nil {return nil ,ctx ,_dedb ;};_dedb =_abgd .addContentsByString (string (_egee ));if _dedb !=nil {return nil ,ctx ,_dedb ;};return []*Block {_abgd },ctx ,nil ;};func _ggea (_dcfd string )(*Image ,error ){_cbaa ,_gbg :=_fa .Open (_dcfd );
if _gbg !=nil {return nil ,_gbg ;};defer _cbaa .Close ();_cefc ,_gbg :=_ffb .ImageHandling .Read (_cbaa );if _gbg !=nil {_ca .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gbg );
return nil ,_gbg ;};return _abab (_cefc );};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;
TextRenderingModeClip ;);

// SetBorderColor sets the cell's border color.
func (_ccdc *TableCell )SetBorderColor (col Color ){_ccdc ._fegc =col ;_ccdc ._gcac =col ;_ccdc ._afdf =col ;_ccdc ._ggecc =col ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_ecdae *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_ecdae ._dccgd =align ;};func (_acec *StyledParagraph )wrapChunks (_aaed bool )error {if !_acec ._adbb ||int (_acec ._ffeb )<=0{_acec ._bcfb =[][]*TextChunk {_acec ._eecg };
return nil ;};_acec ._bcfb =[][]*TextChunk {};var _ddfg []*TextChunk ;var _ffgfb float64 ;_adgg :=_g .IsSpace ;if !_aaed {_adgg =func (rune )bool {return false };};for _ ,_baeg :=range _acec ._eecg {_cece :=_baeg .Style ;_aaaba :=_baeg ._gbbe ;var (_febf []rune ;
_ffefe []float64 ;);for _ ,_ccbc :=range _baeg .Text {if _ccbc =='\u000A'{if !_aaed {_febf =append (_febf ,_ccbc );};_ddfg =append (_ddfg ,&TextChunk {Text :_aff .TrimRightFunc (string (_febf ),_adgg ),Style :_cece ,_gbbe :_gcef (_aaaba )});_acec ._bcfb =append (_acec ._bcfb ,_ddfg );
_ddfg =nil ;_ffgfb =0;_febf =nil ;_ffefe =nil ;continue ;};_efbe :=_ccbc ==' ';_eafa ,_debd :=_cece .Font .GetRuneMetrics (_ccbc );if !_debd {_ca .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ccbc );
return _f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_aeag :=_cece .FontSize *_eafa .Wx *_cece .horizontalScale ();_gdae :=_aeag ;if !_efbe {_gdae =_aeag +_cece .CharSpacing *1000.0;
};if _ffgfb +_aeag > _acec ._ffeb *1000.0{_eabc :=-1;if !_efbe {for _abca :=len (_febf )-1;_abca >=0;_abca --{if _febf [_abca ]==' '{_eabc =_abca ;break ;};};};_fafa :=string (_febf );if _eabc >=0{_fafa =string (_febf [0:_eabc +1]);_febf =_febf [_eabc +1:];
_febf =append (_febf ,_ccbc );_ffefe =_ffefe [_eabc +1:];_ffefe =append (_ffefe ,_gdae );_ffgfb =0;for _ ,_fgfd :=range _ffefe {_ffgfb +=_fgfd ;};}else {if _efbe {_ffgfb =0;_febf =[]rune {};_ffefe =[]float64 {};}else {_ffgfb =_gdae ;_febf =[]rune {_ccbc };
_ffefe =[]float64 {_gdae };};};if !_aaed &&_efbe {_fafa +="\u0020";};_ddfg =append (_ddfg ,&TextChunk {Text :_aff .TrimRightFunc (_fafa ,_adgg ),Style :_cece ,_gbbe :_gcef (_aaaba )});_acec ._bcfb =append (_acec ._bcfb ,_ddfg );_ddfg =[]*TextChunk {};}else {_ffgfb +=_gdae ;
_febf =append (_febf ,_ccbc );_ffefe =append (_ffefe ,_gdae );};};if len (_febf )> 0{_ddfg =append (_ddfg ,&TextChunk {Text :string (_febf ),Style :_cece ,_gbbe :_gcef (_aaaba )});};};if len (_ddfg )> 0{_acec ._bcfb =append (_acec ._bcfb ,_ddfg );};return nil ;
};

// SetNotes sets the notes section of the invoice.
func (_dgba *Invoice )SetNotes (title ,content string ){_dgba ._cagb =[2]string {title ,content }};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// Text sets the text content of the Paragraph.
func (_fef *Paragraph )Text ()string {return _fef ._ggacg };

// SetLineColor sets the line color.
func (_geab *Polyline )SetLineColor (color Color ){_geab ._aeeg .LineColor =_cbae (color )};

// SetHeight sets the Image's document height to specified h.
func (_gdge *Image )SetHeight (h float64 ){_gdge ._gfgd =h };

// SetDueDate sets the due date of the invoice.
func (_abc *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_abc ._bgbde [1].Value =dueDate ;return _abc ._bgbde [0],_abc ._bgbde [1];};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_caff *StyledParagraph )Insert (index uint ,text string )*TextChunk {_faac :=uint (len (_caff ._eecg ));if index > _faac {index =_faac ;};_eaef :=NewTextChunk (text ,_caff ._cdef );_caff ._eecg =append (_caff ._eecg [:index ],append ([]*TextChunk {_eaef },_caff ._eecg [index :]...)...);
_caff .wrapText ();return _eaef ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_fcffd *Table )SetMargins (left ,right ,top ,bottom float64 ){_fcffd ._bgaad .Left =left ;_fcffd ._bgaad .Right =right ;_fcffd ._bgaad .Top =top ;_fcffd ._bgaad .Bottom =bottom ;};

// SetBorderOpacity sets the border opacity.
func (_aaaf *Rectangle )SetBorderOpacity (opacity float64 ){_aaaf ._fdcaea =opacity };

// SetShowLinks sets visibility of links for the TOC lines.
func (_fbga *TOC )SetShowLinks (showLinks bool ){_fbga ._bdefa =showLinks };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_bcag *Creator )PageFinalize (pageFinalizeFunc func (_adef PageFinalizeFunctionArgs )error ){_bcag ._beba =pageFinalizeFunc ;};func _cfc (_ded *_eff .ContentStreamOperations ,_geg *_ffb .PdfPageResources ,_dde *_eff .ContentStreamOperations ,_afa *_ffb .PdfPageResources )error {_bfb :=map[_ce .PdfObjectName ]_ce .PdfObjectName {};
_fae :=map[_ce .PdfObjectName ]_ce .PdfObjectName {};_fdg :=map[_ce .PdfObjectName ]_ce .PdfObjectName {};_bfa :=map[_ce .PdfObjectName ]_ce .PdfObjectName {};_baf :=map[_ce .PdfObjectName ]_ce .PdfObjectName {};_bg :=map[_ce .PdfObjectName ]_ce .PdfObjectName {};
for _ ,_cbc :=range *_dde {switch _cbc .Operand {case "\u0044\u006f":if len (_cbc .Params )==1{if _fcc ,_becd :=_cbc .Params [0].(*_ce .PdfObjectName );_becd {if _ ,_fgd :=_bfb [*_fcc ];!_fgd {var _ebc _ce .PdfObjectName ;_fbgd ,_ :=_afa .GetXObjectByName (*_fcc );
if _fbgd !=nil {_ebc =*_fcc ;for {_cad ,_ :=_geg .GetXObjectByName (_ebc );if _cad ==nil ||_cad ==_fbgd {break ;};_ebc =_ebc +"\u0030";};};_geg .SetXObjectByName (_ebc ,_fbgd );_bfb [*_fcc ]=_ebc ;};_adg :=_bfb [*_fcc ];_cbc .Params [0]=&_adg ;};};case "\u0054\u0066":if len (_cbc .Params )==2{if _cdf ,_cadd :=_cbc .Params [0].(*_ce .PdfObjectName );
_cadd {if _ ,_cedb :=_fae [*_cdf ];!_cedb {_ecg ,_aaa :=_afa .GetFontByName (*_cdf );_fee :=*_cdf ;if _aaa &&_ecg !=nil {_fee =_egd (_cdf .String (),_ecg ,_geg );};_geg .SetFontByName (_fee ,_ecg );_fae [*_cdf ]=_fee ;};_afc :=_fae [*_cdf ];_cbc .Params [0]=&_afc ;
};};case "\u0043\u0053","\u0063\u0073":if len (_cbc .Params )==1{if _age ,_cfcd :=_cbc .Params [0].(*_ce .PdfObjectName );_cfcd {if _ ,_ccg :=_fdg [*_age ];!_ccg {var _afg _ce .PdfObjectName ;_gae ,_ffd :=_afa .GetColorspaceByName (*_age );if _ffd {_afg =*_age ;
for {_dfaf ,_cbcf :=_geg .GetColorspaceByName (_afg );if !_cbcf ||_gae ==_dfaf {break ;};_afg =_afg +"\u0030";};_geg .SetColorspaceByName (_afg ,_gae );_fdg [*_age ]=_afg ;}else {_ca .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");
};};if _ddf ,_bbf :=_fdg [*_age ];_bbf {_cbc .Params [0]=&_ddf ;}else {_ca .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_age );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_cbc .Params )==1{if _ddee ,_aaf :=_cbc .Params [0].(*_ce .PdfObjectName );_aaf {if _ ,_dec :=_bfa [*_ddee ];!_dec {var _aed _ce .PdfObjectName ;_ggc ,_cba :=_afa .GetPatternByName (*_ddee );
if _cba {_aed =*_ddee ;for {_gfe ,_adc :=_geg .GetPatternByName (_aed );if !_adc ||_gfe ==_ggc {break ;};_aed =_aed +"\u0030";};_bcd :=_geg .SetPatternByName (_aed ,_ggc .ToPdfObject ());if _bcd !=nil {return _bcd ;};_bfa [*_ddee ]=_aed ;};};if _dac ,_bgg :=_bfa [*_ddee ];
_bgg {_cbc .Params [0]=&_dac ;};};};case "\u0073\u0068":if len (_cbc .Params )==1{if _gda ,_acc :=_cbc .Params [0].(*_ce .PdfObjectName );_acc {if _ ,_dfc :=_baf [*_gda ];!_dfc {var _fbff _ce .PdfObjectName ;_bffe ,_dcg :=_afa .GetShadingByName (*_gda );
if _dcg {_fbff =*_gda ;for {_dae ,_cbe :=_geg .GetShadingByName (_fbff );if !_cbe ||_bffe ==_dae {break ;};_fbff =_fbff +"\u0030";};_gee :=_geg .SetShadingByName (_fbff ,_bffe .ToPdfObject ());if _gee !=nil {_ca .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_gee );
return _gee ;};_baf [*_gda ]=_fbff ;}else {_ca .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _ed ,_geea :=_baf [*_gda ];_geea {_cbc .Params [0]=&_ed ;}else {_ca .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_gda );
};};};case "\u0067\u0073":if len (_cbc .Params )==1{if _gab ,_bfc :=_cbc .Params [0].(*_ce .PdfObjectName );_bfc {if _ ,_bfcc :=_bg [*_gab ];!_bfcc {var _dgb _ce .PdfObjectName ;_abg ,_ffdc :=_afa .GetExtGState (*_gab );if _ffdc {_dgb =*_gab ;_cfb :=1;
for {_ffe ,_becb :=_geg .GetExtGState (_dgb );if !_becb ||_abg ==_ffe {break ;};_dgb =_ce .PdfObjectName (_ae .Sprintf ("\u0047\u0053\u0025\u0064",_cfb ));_cfb ++;};};_geg .AddExtGState (_dgb ,_abg );_bg [*_gab ]=_dgb ;};_afef :=_bg [*_gab ];_cbc .Params [0]=&_afef ;
};};};*_ded =append (*_ded ,_cbc );};return nil ;};func (_daec *Paragraph )getMaxLineWidth ()float64 {if _daec ._afgg ==nil ||len (_daec ._afgg )==0{_daec .wrapText ();};var _bgc float64 ;for _ ,_ecfdf :=range _daec ._afgg {_fcbf :=_daec .getTextLineWidth (_ecfdf );
if _fcbf > _bgc {_bgc =_fcbf ;};};return _bgc ;};

// SetWidthRight sets border width for right.
func (_cecb *border )SetWidthRight (bw float64 ){_cecb ._edf =bw };

// SetPos sets absolute positioning with specified coordinates.
func (_gcbg *StyledParagraph )SetPos (x ,y float64 ){_gcbg ._gebf =PositionAbsolute ;_gcbg ._egfb =x ;_gcbg ._cdagf =y ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_becbf *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _becbf ._abeae .Left ,_becbf ._abeae .Right ,_becbf ._abeae .Top ,_becbf ._abeae .Bottom ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_dabc *Table )NewCell ()*TableCell {return _dabc .newCell (1)};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_def *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_def ._fag =toc ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_eddc *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _eddc ._aadd ,_eddc ._becfa ,_eddc ._cade ,_eddc ._ccce ;};func (_aaab *Division )ctxHeight (_cbfdg float64 )float64 {var _gbda float64 ;for _ ,_bbd :=range _aaab ._agab {switch _ecbb :=_bbd .(type ){case *Paragraph :if _ecbb ._ggbe {_ecbb .SetWidth (_cbfdg );
};_gbda +=_ecbb .Height ()+_ecbb ._abeae .Top +_ecbb ._abeae .Bottom ;case *StyledParagraph :if _ecbb ._adbb {_ecbb .SetWidth (_cbfdg );};_gbda +=_ecbb .Height ()+_ecbb ._abed .Top +_ecbb ._abed .Bottom ;default:_gbda +=_ecbb .Height ();};};return _gbda ;
};

// WriteToFile writes the Creator output to file specified by path.
func (_faa *Creator )WriteToFile (outputPath string )error {_ggca ,_ebe :=_fa .Create (outputPath );if _ebe !=nil {return _ebe ;};defer _ggca .Close ();return _faa .Write (_ggca );};

// NewColumn returns a new column for the line items invoice table.
func (_afdea *Invoice )NewColumn (description string )*InvoiceCell {return _afdea .newColumn (description ,CellHorizontalAlignmentLeft );};

// Margins returns the margins of the list: left, right, top, bottom.
func (_cfag *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _cfag ._ggde .Left ,_cfag ._ggde .Right ,_cfag ._ggde .Top ,_cfag ._ggde .Bottom ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_cbd *Block )ScaleToHeight (h float64 ){_adaa :=h /_cbd ._afb ;_cbd .Scale (_adaa ,_adaa )};

// SetFillColor sets the fill color.
func (_fbgddc *Polygon )SetFillColor (color Color ){_fbgddc ._gbgc .FillColor =_cbae (color )};

// AddLine adds a new line with the provided style to the table of contents.
func (_abdd *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_abdd ._bacb =append (_abdd ._bacb ,line );return line ;};

// SetBorderColor sets the border color.
func (_cedd *Polygon )SetBorderColor (color Color ){_cedd ._gbgc .BorderColor =_cbae (color )};func _beca (_dcdd string ,_dadc ,_bccd TextStyle )*TOC {_cdca :=_bccd ;_cdca .FontSize =14;_aggd :=_ebgd (_cdca );_aggd .SetEnableWrap (true );_aggd .SetTextAlignment (TextAlignmentLeft );
_aggd .SetMargins (0,0,0,5);_dfba :=_aggd .Append (_dcdd );_dfba .Style =_cdca ;return &TOC {_ddfa :_aggd ,_bacb :[]*TOCLine {},_cgab :_dadc ,_bdbg :_dadc ,_adag :_dadc ,_cegc :_dadc ,_fabb :"\u002e",_egbd :10,_faaf :Margins {0,0,2,2},_baga :PositionRelative ,_cabe :_dadc ,_bdefa :true };
};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_cbbgg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_fdbdb float64 ;_bedc uint ;_cecg float64 ;_cfcec Positioning ;_egec float64 ;_bagc float64 ;_ddbf int64 ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_acddf *Invoice )Terms ()(string ,string ){return _acddf ._fdcab [0],_acddf ._fdcab [1]};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aebgd *StyledParagraph )SetTextAlignment (align TextAlignment ){_aebgd ._cbeag =align };

// NewSubchapter creates a new child chapter with the specified title.
func (_bcg *Chapter )NewSubchapter (title string )*Chapter {_fda :=_adga (_bcg ._degf ._gagd );_fda .FontSize =14;_bcg ._cab ++;_becf :=_dee (_bcg ,_bcg ._acd ,_bcg ._fcf ,title ,_bcg ._cab ,_fda );_bcg .Add (_becf );return _becf ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_gfab *Creator )SetOptimizer (optimizer _ffb .Optimizer ){_gfab ._ade =optimizer };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_eede *Creator )EnableFontSubsetting (font *_ffb .PdfFont ){_eede ._becc =append (_eede ._becc ,font );};func _gbfg (_bee []_bd .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_bfccb :&_bd .PolyBezierCurve {Curves :_bee ,BorderColor :_ffb .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_eefdc :1.0,_ceda :1.0};
};func (_ebfg *StyledParagraph )getTextLineWidth (_cefa []*TextChunk )float64 {var _dgcad float64 ;_ebge :=len (_cefa );for _acdfb ,_cbgb :=range _cefa {_efcdg :=&_cbgb .Style ;_abba :=len (_cbgb .Text );for _abaeb ,_ccee :=range _cbgb .Text {if _ccee =='\u000A'{continue ;
};_ddfdb ,_efga :=_efcdg .Font .GetRuneMetrics (_ccee );if !_efga {_ca .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ccee );
return -1;};_dgcad +=_efcdg .FontSize *_ddfdb .Wx *_efcdg .horizontalScale ();if _ccee !=' '&&(_acdfb !=_ebge -1||_abaeb !=_abba -1){_dgcad +=_efcdg .CharSpacing *1000.0;};};};return _dgcad ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_bfec *Creator )Draw (d Drawable )error {if _bfec .getActivePage ()==nil {_bfec .NewPage ();};_eeda ,_ggg ,_afaa :=d .GeneratePageBlocks (_bfec ._acag );if _afaa !=nil {return _afaa ;};for _dadg ,_eacg :=range _eeda {if _dadg > 0{_bfec .NewPage ();
};_bcbb :=_bfec .getActivePage ();if _cafc ,_bcaf :=_bfec ._gfgf [_bcbb ];_bcaf {if _fbbg :=_cafc .mergeBlocks (_eacg );_fbbg !=nil {return _fbbg ;};if _dfcd :=_dbg (_eacg ._d ,_cafc ._d );_dfcd !=nil {return _dfcd ;};}else {_bfec ._gfgf [_bcbb ]=_eacg ;
};};_bfec ._acag .X =_ggg .X ;_bfec ._acag .Y =_ggg .Y ;_bfec ._acag .Height =_ggg .PageHeight -_ggg .Y -_ggg .Margins .Bottom ;return nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_afda *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _afda ._abed .Left ,_afda ._abed .Right ,_afda ._abed .Top ,_afda ._abed .Bottom ;};

// SetLogo sets the logo of the invoice.
func (_abb *Invoice )SetLogo (logo *Image ){_abb ._adcf =logo };

// SetBorderColor sets the border color for the path.
func (_cfaa *FilledCurve )SetBorderColor (color Color ){_cfaa ._aacb =color };

// NewPolyline creates a new polyline.
func (_gcb *Creator )NewPolyline (points []_bd .Point )*Polyline {return _eecdd (points )};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_acbf *StyledParagraph )SetWidth (width float64 ){_acbf ._ffeb =width ;_acbf .wrapText ()};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_cfac Color ;_eabff _bd .LineStyle ;_abde CellBorderStyle ;_fegc Color ;_cfddg float64 ;_cfdfe CellBorderStyle ;_gcac Color ;_ecae float64 ;_accfe CellBorderStyle ;_afdf Color ;_gbcd float64 ;_egbbg CellBorderStyle ;_ggecc Color ;
_fdgc float64 ;_aadbf ,_ggcga int ;_cdfg int ;_dbfgc int ;_daac VectorDrawable ;_bedb CellHorizontalAlignment ;_eabab CellVerticalAlignment ;_decca float64 ;_afee *Table ;};type listItem struct{_gbbc VectorDrawable ;_dcdf TextChunk ;};

// IsRelative checks if the positioning is relative.
func (_affb Positioning )IsRelative ()bool {return _affb ==PositionRelative };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_afgf float64 ;_dccg float64 ;_eggcc float64 ;_bcgga float64 ;_gaf Color ;_dgce float64 ;_begf Color ;_aegc float64 ;_fdcaea float64 ;};

// Width returns the cell's width based on the input draw context.
func (_agafg *TableCell )Width (ctx DrawContext )float64 {_cdebf :=float64 (0.0);for _ebgf :=0;_ebgf < _agafg ._dbfgc ;_ebgf ++{_cdebf +=_agafg ._afee ._baecg [_agafg ._ggcga +_ebgf -1];};_badef :=ctx .Width *_cdebf ;return _badef ;};func (_dceg *Invoice )generateInformationBlocks (_cgca DrawContext )([]*Block ,DrawContext ,error ){_agad :=_ebgd (_dceg ._fgae );
_agad .SetMargins (0,0,0,20);_gfbd :=_dceg .drawAddress (_dceg ._efea );_gfbd =append (_gfbd ,_agad );_gfbd =append (_gfbd ,_dceg .drawAddress (_dceg ._daef )...);_aedcg :=_efdb ();for _ ,_dbaa :=range _gfbd {_aedcg .Add (_dbaa );};_gfcd :=_dceg .drawInformation ();
_babb :=_cgcge (2);_babb .SetMargins (0,0,25,0);_aebc :=_babb .NewCell ();_aebc .SetIndent (0);_aebc .SetContent (_aedcg );_aebc =_babb .NewCell ();_aebc .SetContent (_gfcd );return _babb .GeneratePageBlocks (_cgca );};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_daedg *TOC )SetHeading (text string ,style TextStyle ){_agbf :=_daedg .Heading ();_agbf .Reset ();_bbfa :=_agbf .Append (text );_bbfa .Style =style ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_cdeg int ;_dgdba int ;_ecced int ;_baecg []float64 ;_egcc []float64 ;_ebgeb float64 ;_cfcg []*TableCell ;_gggbb Positioning ;_agbg ,_eccea float64 ;_bgaad Margins ;_egcg bool ;_cddb int ;_efdca int ;_fcda bool ;};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_ddcfa *Division )Width ()float64 {return 0};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_gf :=&Block {};_gf ._fb =&_eff .ContentStreamOperations {};_gf ._d =_ffb .NewPdfPageResources ();_gf ._afd =width ;_gf ._afb =height ;return _gf ;};func (_dfe *Block )duplicate ()*Block {_adb :=&Block {};
*_adb =*_dfe ;_ab :=_eff .ContentStreamOperations {};_ab =append (_ab ,*_dfe ._fb ...);_adb ._fb =&_ab ;return _adb ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_eacf *Paragraph )SetMaxLines (maxLines int ){_eacf ._bbeag =maxLines ;_eacf .wrapText ()};

// Height returns the Block's height.
func (_cb *Block )Height ()float64 {return _cb ._afb };

// Reset removes all the text chunks the paragraph contains.
func (_geggf *StyledParagraph )Reset (){_geggf ._eecg =[]*TextChunk {}};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_gebe *List )Add (item VectorDrawable )(*TextChunk ,error ){_ddcbb :=&listItem {_gbbc :item ,_dcdf :_gebe ._gaaf };switch _afdd :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _afdd ._edda {_afdd ._dbfg =15;};default:return nil ,_f .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_gebe ._baece =append (_gebe ._baece ,_ddcbb );return &_ddcbb ._dcdf ,nil ;};

// Heading returns the heading component of the table of contents.
func (_fcea *TOC )Heading ()*StyledParagraph {return _fcea ._ddfa };func _fedge (_eegb [][]_bd .Point )*Polygon {return &Polygon {_gbgc :&_bd .Polygon {Points :_eegb },_aaacc :1.0,_fbdeb :1.0};};

// Width returns the width of the Paragraph.
func (_dgbe *Paragraph )Width ()float64 {if _dgbe ._ggbe &&int (_dgbe ._ceae )> 0{return _dgbe ._ceae ;};return _dgbe .getTextWidth ()/1000.0;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_gfgg *TableCell )width (_effb []float64 ,_ebdgc float64 )float64 {_abdbd :=float64 (0.0);for _ddgea :=0;_ddgea < _gfgg ._dbfgc ;_ddgea ++{_abdbd +=_effb [_gfgg ._ggcga +_ddgea -1];};return _abdbd *_ebdgc ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_cafa *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_degd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dace :=_eff .NewContentCreator ();_dace .Add_q ().Add_w (_cafa ._bebf ).SetStrokingColor (_cbae (_cafa ._acgg )).Add_m (_cafa ._acb ,ctx .PageHeight -_cafa ._ccdf ).Add_v (_cafa ._fded ,ctx .PageHeight -_cafa ._gfec ,_cafa ._ddff ,ctx .PageHeight -_cafa ._fbc ).Add_S ().Add_Q ();
_cef :=_degd .addContentsByString (_dace .String ());if _cef !=nil {return nil ,ctx ,_cef ;};return []*Block {_degd },ctx ,nil ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_cabc *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_cabc ._dgdba {_ca .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cabc ._baecg =widths ;return nil ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_edggf *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dded :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_facc ,_ ,_gbbbb :=_edggf .draw ("");if _gbbbb !=nil {return nil ,ctx ,_gbbbb ;};_gbbbb =_dded .addContentsByString (string (_facc ));
if _gbbbb !=nil {return nil ,ctx ,_gbbbb ;};return []*Block {_dded },ctx ,nil ;};func (_aceb *StyledParagraph )getTextHeight ()float64 {var _cbgc float64 ;for _ ,_fagd :=range _aceb ._eecg {_cfea :=_fagd .Style .FontSize *_aceb ._efdf ;if _cfea > _cbgc {_cbgc =_cfea ;
};};return _cbgc ;};

// NewPolygon creates a new polygon.
func (_fab *Creator )NewPolygon (points [][]_bd .Point )*Polygon {return _fedge (points )};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_eefcd *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aadbg :=ctx ;_aaabd ,ctx ,_efcff :=_eefcd ._ddfa .GeneratePageBlocks (ctx );if _efcff !=nil {return _aaabd ,ctx ,_efcff ;};for _ ,_bbdf :=range _eefcd ._bacb {_acggc :=_bbdf ._ddbf ;
if !_eefcd ._bdefa {_bbdf ._ddbf =0;};_cceee ,_bedd ,_deccaf :=_bbdf .GeneratePageBlocks (ctx );_bbdf ._ddbf =_acggc ;if _deccaf !=nil {return _aaabd ,ctx ,_deccaf ;};if len (_cceee )< 1{continue ;};_aaabd [len (_aaabd )-1].mergeBlocks (_cceee [0]);_aaabd =append (_aaabd ,_cceee [1:]...);
ctx =_bedd ;};if _eefcd ._baga .IsRelative (){ctx .X =_aadbg .X ;};if _eefcd ._baga .IsAbsolute (){return _aaabd ,_aadbg ,nil ;};return _aaabd ,ctx ,nil ;};

// Add adds a new line with the default style to the table of contents.
func (_abebc *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_dfegb :=_abebc .AddLine (_ebga (TextChunk {Text :number ,Style :_abebc ._cgab },TextChunk {Text :title ,Style :_abebc ._bdbg },TextChunk {Text :page ,Style :_abebc ._cegc },level ,_abebc ._cabe ));
if _dfegb ==nil {return nil ;};_gfeb :=&_abebc ._faaf ;_dfegb .SetMargins (_gfeb .Left ,_gfeb .Right ,_gfeb .Top ,_gfeb .Bottom );_dfegb .SetLevelOffset (_abebc ._egbd );_dfegb .Separator .Text =_abebc ._fabb ;_dfegb .Separator .Style =_abebc ._adag ;return _dfegb ;
};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_fgdgd *TableCell )SetBorderLineStyle (style _bd .LineStyle ){_fgdgd ._eabff =style };

// SetWidth sets line width.
func (_afgb *Curve )SetWidth (width float64 ){_afgb ._bebf =width };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_cgg *Chapter )SetShowNumbering (show bool ){_cgg ._efg =show ;_cgg ._degf .SetText (_cgg .headingText ());};func _bac (_gedac *Block ,_ggdf *Image ,_gbdf DrawContext )(DrawContext ,error ){_fffc :=_gbdf ;_bfab :=1;_dccb :=_ce .PdfObjectName (_ae .Sprintf ("\u0049\u006d\u0067%\u0064",_bfab ));
for _gedac ._d .HasXObjectByName (_dccb ){_bfab ++;_dccb =_ce .PdfObjectName (_ae .Sprintf ("\u0049\u006d\u0067%\u0064",_bfab ));};_dcef :=_gedac ._d .SetXObjectImageByName (_dccb ,_ggdf ._bbbg );if _dcef !=nil {return _gbdf ,_dcef ;};_efac :=0;_eabae :=_ce .PdfObjectName (_ae .Sprintf ("\u0047\u0053\u0025\u0064",_efac ));
for _gedac ._d .HasExtGState (_eabae ){_efac ++;_eabae =_ce .PdfObjectName (_ae .Sprintf ("\u0047\u0053\u0025\u0064",_efac ));};_fce :=_ce .MakeDict ();_fce .Set ("\u0042\u004d",_ce .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _ggdf ._fagg < 1.0{_fce .Set ("\u0043\u0041",_ce .MakeFloat (_ggdf ._fagg ));
_fce .Set ("\u0063\u0061",_ce .MakeFloat (_ggdf ._fagg ));};_dcef =_gedac ._d .AddExtGState (_eabae ,_ce .MakeIndirectObject (_fce ));if _dcef !=nil {return _gbdf ,_dcef ;};_fad :=_ggdf .Width ();_abdb :=_ggdf .Height ();_ ,_egdg :=_ggdf .rotatedSize ();
_fdedb :=_gbdf .X ;_abgc :=_gbdf .PageHeight -_gbdf .Y -_abdb ;if _ggdf ._ggfg .IsRelative (){_abgc -=(_egdg -_abdb )/2;switch _ggdf ._fbge {case HorizontalAlignmentCenter :_fdedb +=(_gbdf .Width -_fad )/2;case HorizontalAlignmentRight :_fdedb =_gbdf .PageWidth -_gbdf .Margins .Right -_ggdf ._ddcb .Right -_fad ;
};};_begg :=_ggdf ._cbed ;_adcg :=_eff .NewContentCreator ();_adcg .Add_gs (_eabae );_adcg .Translate (_fdedb ,_abgc );if _begg !=0{_adcg .Translate (_fad /2,_abdb /2);_adcg .RotateDeg (_begg );_adcg .Translate (-_fad /2,-_abdb /2);};_adcg .Scale (_fad ,_abdb ).Add_Do (_dccb );
_gegb :=_adcg .Operations ();_gegb .WrapIfNeeded ();_gedac .addContents (_gegb );if _ggdf ._ggfg .IsRelative (){_gbdf .Y +=_egdg ;_gbdf .Height -=_egdg ;return _gbdf ,nil ;};return _fffc ,nil ;};

// SetFillOpacity sets the fill opacity.
func (_efgbe *Rectangle )SetFillOpacity (opacity float64 ){_efgbe ._dgce =opacity };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_efdd *TOCLine )SetStyle (style TextStyle ){_efdd .Number .Style =style ;_efdd .Title .Style =style ;_efdd .Separator .Style =style ;_efdd .Page .Style =style ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_fcfb :_bf .Min (float64 (c ),100)/100.0,_agd :_bf .Min (float64 (m ),100)/100.0,_gea :_bf .Min (float64 (y ),100)/100.0,_efa :_bf .Min (float64 (k ),100)/100.0};};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_cefe *Image )SetMargins (left ,right ,top ,bottom float64 ){_cefe ._ddcb .Left =left ;_cefe ._ddcb .Right =right ;_cefe ._ddcb .Top =top ;_cefe ._ddcb .Bottom =bottom ;};

// SetRowHeight sets the height for a specified row.
func (_ddab *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_ddab ._egcc ){return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddab ._egcc [row -1]=h ;return nil ;
};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_dcf DrawContext )([]*Block ,DrawContext ,error );};

// Cols returns the total number of columns the table has.
func (_cdbe *Table )Cols ()int {return _cdbe ._dgdba };

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ffgfd *TOC )SetLineStyle (style TextStyle ){_ffgfd .SetLineNumberStyle (style );_ffgfd .SetLineTitleStyle (style );_ffgfd .SetLineSeparatorStyle (style );_ffgfd .SetLinePageStyle (style );};

// SetIndent sets the left offset of the list when nested into another list.
func (_eadc *List )SetIndent (indent float64 ){_eadc ._dbfg =indent ;_eadc ._edda =false };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_bed *Image )SetWidth (w float64 ){_bed ._fcd =w };

// CurRow returns the currently active cell's row number.
func (_cbeb *Table )CurRow ()int {_cbff :=(_cbeb ._ecced -1)/_cbeb ._dgdba +1;return _cbff };

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_gaba *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cff :=ctx ;if _gaba ._abfb .IsRelative (){ctx .X +=_gaba ._fgdf .Left ;ctx .Y +=_gaba ._fgdf .Top ;ctx .Width -=_gaba ._fgdf .Left +_gaba ._fgdf .Right ;ctx .Height -=_gaba ._fgdf .Top ;
};_bdgd ,_gga ,_dga :=_gaba ._degf .GeneratePageBlocks (ctx );if _dga !=nil {return _bdgd ,ctx ,_dga ;};ctx =_gga ;_cbcd :=ctx .X ;_edfe :=ctx .Y -_gaba ._degf .Height ();_cccdc :=int64 (ctx .Page );_dfg :=_gaba .headingNumber ();_aagf :=_gaba .headingText ();
if _gaba ._cacf {_aebg :=_gaba ._acd .Add (_dfg ,_gaba ._cadf ,_af .FormatInt (_cccdc ,10),_gaba ._cag );if _gaba ._acd ._bdefa {_aebg .SetLink (_cccdc ,_cbcd ,_edfe );};};if _gaba ._gdfd ==nil {_gaba ._gdfd =_ffb .NewOutlineItem (_aagf ,_ffb .NewOutlineDest (_cccdc -1,_cbcd ,_edfe ));
if _gaba ._efgb !=nil {_gaba ._efgb ._gdfd .Add (_gaba ._gdfd );}else {_gaba ._fcf .Add (_gaba ._gdfd );};}else {_fbac :=&_gaba ._gdfd .Dest ;_fbac .Page =_cccdc -1;_fbac .X =_cbcd ;_fbac .Y =_edfe ;};for _ ,_ggaf :=range _gaba ._edb {_ffg ,_bbc ,_bad :=_ggaf .GeneratePageBlocks (ctx );
if _bad !=nil {return _bdgd ,ctx ,_bad ;};if len (_ffg )< 1{continue ;};_bdgd [len (_bdgd )-1].mergeBlocks (_ffg [0]);_bdgd =append (_bdgd ,_ffg [1:]...);ctx =_bbc ;};if _gaba ._abfb .IsRelative (){ctx .X =_cff .X ;};if _gaba ._abfb .IsAbsolute (){return _bdgd ,_cff ,nil ;
};return _bdgd ,ctx ,nil ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_fcbg *_bd .CurvePolygon ;_gddb float64 ;_acbd float64 ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_fbeb *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbeb ._bgaad .Left ,_fbeb ._bgaad .Right ,_fbeb ._bgaad .Top ,_fbeb ._bgaad .Bottom ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ge *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fde :=_eff .NewContentCreator ();_cedf ,_ga :=_ge .Width (),_ge .Height ();if _ge ._gb .IsRelative (){_fde .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_ga );}else {_fde .Translate (_ge ._ad ,ctx .PageHeight -_ge ._gd -_ga );
};_dff :=_ga ;if _ge ._fg !=0{_fde .Translate (_cedf /2,_ga /2);_fde .RotateDeg (_ge ._fg );_fde .Translate (-_cedf /2,-_ga /2);_ ,_dff =_ge .RotatedSize ();};if _ge ._gb .IsRelative (){ctx .Y +=_dff ;};_eefd :=_ge .duplicate ();_bfe :=append (*_fde .Operations (),*_eefd ._fb ...);
_bfe .WrapIfNeeded ();_eefd ._fb =&_bfe ;return []*Block {_eefd },ctx ,nil ;};func _facg (_ffef ,_cgdd TextStyle )*Invoice {_ggccg :=&Invoice {_dbe :"\u0049N\u0056\u004f\u0049\u0043\u0045",_gedf :"\u002c\u0020",_fgae :_ffef ,_agcg :_cgdd };_ggccg ._efea =&InvoiceAddress {Separator :_ggccg ._gedf };
_ggccg ._daef =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_ggccg ._gedf };_bef :=ColorRGBFrom8bit (245,245,245);_dece :=ColorRGBFrom8bit (155,155,155);_ggccg ._gdca =_cgdd ;_ggccg ._gdca .Color =_dece ;_ggccg ._gdca .FontSize =20;
_ggccg ._bgec =_ffef ;_ggccg ._deed =_cgdd ;_ggccg ._fadf =_ffef ;_ggccg ._fbbe =_cgdd ;_ggccg ._gcd =_ggccg .NewCellProps ();_ggccg ._gcd .BackgroundColor =_bef ;_ggccg ._gcd .TextStyle =_cgdd ;_ggccg ._bbaa =_ggccg .NewCellProps ();_ggccg ._bbaa .TextStyle =_cgdd ;
_ggccg ._bbaa .BackgroundColor =_bef ;_ggccg ._bbaa .BorderColor =_bef ;_ggccg ._ebfe =_ggccg .NewCellProps ();_ggccg ._ebfe .BorderColor =_bef ;_ggccg ._ebfe .BorderSides =[]CellBorderSide {CellBorderSideBottom };_ggccg ._ebfe .Alignment =CellHorizontalAlignmentRight ;
_ggccg ._dcd =_ggccg .NewCellProps ();_ggccg ._dcd .Alignment =CellHorizontalAlignmentRight ;_ggccg ._geef =[2]*InvoiceCell {_ggccg .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_ggccg ._gcd ),_ggccg .newCell ("",_ggccg ._gcd )};
_ggccg ._bbg =[2]*InvoiceCell {_ggccg .newCell ("\u0044\u0061\u0074\u0065",_ggccg ._gcd ),_ggccg .newCell ("",_ggccg ._gcd )};_ggccg ._bgbde =[2]*InvoiceCell {_ggccg .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_ggccg ._gcd ),_ggccg .newCell ("",_ggccg ._gcd )};
_ggccg ._aegb =[2]*InvoiceCell {_ggccg .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_ggccg ._dcd ),_ggccg .newCell ("",_ggccg ._dcd )};_bbbge :=_ggccg ._dcd ;_bbbge .TextStyle =_cgdd ;_bbbge .BackgroundColor =_bef ;_bbbge .BorderColor =_bef ;
_ggccg ._gebb =[2]*InvoiceCell {_ggccg .newCell ("\u0054\u006f\u0074a\u006c",_bbbge ),_ggccg .newCell ("",_bbbge )};_ggccg ._cagb =[2]string {"\u004e\u006f\u0074e\u0073",""};_ggccg ._fdcab =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_ggccg ._fbdb =[]*InvoiceCell {_ggccg .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_ggccg .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_ggccg .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_ggccg .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _ggccg ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_dedbb *TableCell )SetContent (vd VectorDrawable )error {switch _cegb :=vd .(type ){case *Paragraph :if _cegb ._fedg {_cegb ._ggbe =true ;};_dedbb ._daac =vd ;case *StyledParagraph :if _cegb ._ceca {_cegb ._adbb =true ;};_dedbb ._daac =vd ;case *Image :_dedbb ._daac =vd ;
case *Table :_dedbb ._daac =vd ;case *List :_dedbb ._daac =vd ;case *Division :_dedbb ._daac =vd ;default:_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _ce .ErrTypeError ;};return nil ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_dfaa *Creator )MoveTo (x ,y float64 ){_dfaa ._acag .X =x ;_dfaa ._acag .Y =y };

// TitleStyle returns the style properties used to render the invoice title.
func (_ecde *Invoice )TitleStyle ()TextStyle {return _ecde ._gdca };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_beff *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_deead :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dgge ,_geed :=_deead .setOpacity (_beff ._aaacc ,_beff ._fbdeb );if _geed !=nil {return nil ,ctx ,_geed ;};
_degc :=_beff ._gbgc ;_degc .FillEnabled =_degc .FillColor !=nil ;_degc .BorderEnabled =_degc .BorderColor !=nil &&_degc .BorderWidth > 0;_ggff :=_degc .Points ;for _cfeb :=range _ggff {for _fbbaf :=range _ggff [_cfeb ]{_bddbac :=&_ggff [_cfeb ][_fbbaf ];
_bddbac .Y =ctx .PageHeight -_bddbac .Y ;};};_becfab ,_ ,_geed :=_degc .Draw (_dgge );if _geed !=nil {return nil ,ctx ,_geed ;};if _geed =_deead .addContentsByString (string (_becfab ));_geed !=nil {return nil ,ctx ,_geed ;};return []*Block {_deead },ctx ,nil ;
};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_afe *Block )SetMargins (left ,right ,top ,bottom float64 ){_afe ._bff .Left =left ;_afe ._bff .Right =right ;_afe ._bff .Top =top ;_afe ._bff .Bottom =bottom ;};

// Scale block by specified factors in the x and y directions.
func (_baa *Block )Scale (sx ,sy float64 ){_ag :=_eff .NewContentCreator ().Scale (sx ,sy ).Operations ();*_baa ._fb =append (*_ag ,*_baa ._fb ...);_baa ._fb .WrapIfNeeded ();_baa ._afd *=sx ;_baa ._afb *=sy ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_cccec *Table )MultiColCell (colspan int )*TableCell {return _cccec .newCell (colspan )};func (_fddf *StyledParagraph )appendChunk (_eege *TextChunk )*TextChunk {_fddf ._eecg =append (_fddf ._eecg ,_eege );_fddf .wrapText ();return _eege ;};

// SetBorderWidth sets the border width.
func (_fadc *Rectangle )SetBorderWidth (bw float64 ){_fadc ._aegc =bw };

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_ffb .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// Width returns the width of the Paragraph.
func (_aabd *StyledParagraph )Width ()float64 {if _aabd ._adbb &&int (_aabd ._ffeb )> 0{return _aabd ._ffeb ;};return _aabd .getTextWidth ()/1000.0;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_fadb *Invoice )BuyerAddress ()*InvoiceAddress {return _fadb ._daef };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_cfge *Invoice )TotalLines ()[][2]*InvoiceCell {_gdab :=[][2]*InvoiceCell {_cfge ._aegb };_gdab =append (_gdab ,_cfge ._bcc ...);return append (_gdab ,_cfge ._gebb );};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_gdcd *Division )Add (d VectorDrawable )error {switch _adec :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image :case containerDrawable :_fecb ,_ceg :=_adec .ContainerComponent (_gdcd );if _ceg !=nil {return _ceg ;};_bcdc ,_efgf :=_fecb .(VectorDrawable );
if !_efgf {return _ae .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_fecb );
};d =_bcdc ;default:return _f .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gdcd ._agab =append (_gdcd ._agab ,d );return nil ;};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_agab []VectorDrawable ;_gdbg Positioning ;_cdgd Margins ;_gefg bool ;};

// SetFillColor sets the fill color.
func (_fdddb *Ellipse )SetFillColor (col Color ){_fdddb ._dacea =col };

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_cdag *Invoice )SetNoteHeadingStyle (style TextStyle ){_cdag ._fbbe =style };

// GetCoords returns coordinates of border.
func (_aab *border )GetCoords ()(float64 ,float64 ){return _aab ._cg ,_aab ._fdcc };

// AddLine appends a new line to the invoice line items table.
func (_faaga *Invoice )AddLine (values ...string )[]*InvoiceCell {_dcaf :=len (_faaga ._fbdb );var _fbdd []*InvoiceCell ;for _bfaf ,_bbca :=range values {_eega :=_faaga .newCell (_bbca ,_faaga ._ebfe );if _bfaf < _dcaf {_eega .Alignment =_faaga ._fbdb [_bfaf ].Alignment ;
};_fbdd =append (_fbdd ,_eega );};_faaga ._facce =append (_faaga ._facce ,_fbdd );return _fbdd ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_ggacg string ;_gagd *_ffb .PdfFont ;_fge float64 ;_efgdb float64 ;_bcfe Color ;_ebfb TextAlignment ;_ggbe bool ;_ceae float64 ;_bbeag int ;_fedg bool ;_gggb float64 ;_abeae Margins ;_agfce Positioning ;_aacg float64 ;_fccag float64 ;
_bggba ,_edfb float64 ;_afgg []string ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ffb .PdfPage )(*Block ,error ){_df :=&Block {};_ec ,_ced :=page .GetAllContentStreams ();if _ced !=nil {return nil ,_ced ;};_ecd :=_eff .NewContentStreamParser (_ec );_cea ,_ced :=_ecd .Parse ();if _ced !=nil {return nil ,_ced ;
};_cea .WrapIfNeeded ();_df ._fb =_cea ;if page .Resources !=nil {_df ._d =page .Resources ;}else {_df ._d =_ffb .NewPdfPageResources ();};_aa ,_ced :=page .GetMediaBox ();if _ced !=nil {return nil ,_ced ;};if _aa .Llx !=0||_aa .Lly !=0{_df .translate (-_aa .Llx ,_aa .Lly );
};_df ._afd =_aa .Urx -_aa .Llx ;_df ._afb =_aa .Ury -_aa .Lly ;if page .Rotate !=nil {_df ._fg =-float64 (*page .Rotate );};return _df ,nil ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_dfec *Invoice )SetTerms (title ,content string ){_dfec ._fdcab =[2]string {title ,content }};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _ecgb ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_deea :=&Creator {};_deea ._aca =[]*_ffb .PdfPage {};_deea ._gfgf =map[*_ffb .PdfPage ]*Block {};_deea .SetPageSize (PageSizeLetter );_gfge :=0.1*_deea ._bddd ;
_deea ._bbe .Left =_gfge ;_deea ._bbe .Right =_gfge ;_deea ._bbe .Top =_gfge ;_deea ._bbe .Bottom =_gfge ;var _ace error ;_deea ._dbc ,_ace =_ffb .NewStandard14Font (_ffb .HelveticaName );if _ace !=nil {_deea ._dbc =_ffb .DefaultFont ();};_deea ._ecgc ,_ace =_ffb .NewStandard14Font (_ffb .HelveticaBoldName );
if _ace !=nil {_deea ._dbc =_ffb .DefaultFont ();};_deea ._fag =_deea .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_deea .AddOutlines =true ;_deea ._dge =_ffb .NewOutline ();_ef .TrackUse (_ecgb );
return _deea ;};

// NewDivision returns a new Division container component.
func (_cdb *Creator )NewDivision ()*Division {return _efdb ()};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func (_egbg *InvoiceAddress )fmtLine (_abgg ,_gcfb string ,_agbd bool )string {if _agbd {_gcfb ="";};return _ae .Sprintf ("\u0025\u0073\u0025s\u000a",_gcfb ,_abgg );};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_caga *Image )SetEncoder (encoder _ce .StreamEncoder ){_caga ._efe =encoder };func (_baed *Invoice )drawSection (_eeca ,_dcbb string )[]*StyledParagraph {var _geff []*StyledParagraph ;if _eeca !=""{_fcfda :=_ebgd (_baed ._fbbe );_fcfda .SetMargins (0,0,0,5);
_fcfda .Append (_eeca );_geff =append (_geff ,_fcfda );};if _dcbb !=""{_gdddb :=_ebgd (_baed ._fadf );_gdddb .Append (_dcbb );_geff =append (_geff ,_gdddb );};return _geff ;};

// SetBackgroundColor sets the cell's background color.
func (_dgefa *TableCell )SetBackgroundColor (col Color ){_dgefa ._cfac =col };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_fbdfd *Invoice )AddressHeadingStyle ()TextStyle {return _fbdfd ._agcg };

// Length calculates and returns the line length.
func (_gbab *Line )Length ()float64 {return _bf .Sqrt (_bf .Pow (_gbab ._cade -_gbab ._aadd ,2.0)+_bf .Pow (_gbab ._ccce -_gbab ._becfa ,2.0));};

// Lines returns all the rows of the invoice line items table.
func (_fbde *Invoice )Lines ()[][]*InvoiceCell {return _fbde ._facce };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_abdg *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_gfcc ,_aecf :=_abdg .Wrap (width );if _aecf !=nil {return nil ,_aecf ;};_dfbcf :=int (height /_abdg .Style .FontSize );if _dfbcf >=len (_gfcc ){return nil ,nil ;};_dgbbd :="\u000a";
_abdg .Text =_aff .Replace (_aff .Join (_gfcc [:_dfbcf ],"\u0020"),_dgbbd +"\u0020",_dgbbd ,-1);_babfc :=_aff .Replace (_aff .Join (_gfcc [_dfbcf :],"\u0020"),_dgbbd +"\u0020",_dgbbd ,-1);return NewTextChunk (_babfc ,_abdg .Style ),nil ;};

// SetColorLeft sets border color for left.
func (_ecfd *border )SetColorLeft (col Color ){_ecfd ._gaae =col };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fada *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eedc :=ctx ;_bgge :=[]func (_acdf DrawContext )([]*Block ,DrawContext ,error ){_fada .generateHeaderBlocks ,_fada .generateInformationBlocks ,_fada .generateLineBlocks ,_fada .generateTotalBlocks ,_fada .generateNoteBlocks };
var _eefb []*Block ;for _ ,_cbca :=range _bgge {_cbgf ,_afbg ,_fdef :=_cbca (ctx );if _fdef !=nil {return _eefb ,ctx ,_fdef ;};if len (_eefb )==0{_eefb =_cbgf ;}else if len (_cbgf )> 0{_eefb [len (_eefb )-1].mergeBlocks (_cbgf [0]);_eefb =append (_eefb ,_cbgf [1:]...);
};ctx =_afbg ;};if _fada ._acba .IsRelative (){ctx .X =_eedc .X ;};if _fada ._acba .IsAbsolute (){return _eefb ,_eedc ,nil ;};return _eefb ,ctx ,nil ;};

// MoveY moves the drawing context to absolute position y.
func (_agdf *Creator )MoveY (y float64 ){_agdf ._acag .Y =y };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_fgaea *StyledParagraph )Height ()float64 {_fgaea .wrapText ();var _dbbge float64 ;for _ ,_dbgee :=range _fgaea ._bcfb {var _ffa float64 ;for _ ,_eaeg :=range _dbgee {_fcdf :=_fgaea ._efdf *_eaeg .Style .FontSize ;if _fcdf > _ffa {_ffa =_fcdf ;};
};_dbbge +=_ffa ;};return _dbbge ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;func _faff (_adae _c .Image )(*Image ,error ){_bdgb ,_gdga :=_ffb .ImageHandling .NewImageFromGoImage (_adae );if _gdga !=nil {return nil ,_gdga ;};return _abab (_bdgb );};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// CreateTableOfContents sets a function to generate table of contents.
func (_gfce *Creator )CreateTableOfContents (genTOCFunc func (_bea *TOC )error ){_gfce ._dgaf =genTOCFunc ;};func (_cbfgc *TextChunk )clone ()*TextChunk {_bdgeg :=*_cbfgc ;_bdgeg ._gbbe =_gcef (_cbfgc ._gbbe );return &_bdgeg ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_ddca *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_cfgee :=NewTextChunk (text ,_ddca ._dbcgc );_cfgee ._gbbe =_feafc (page -1,x ,y ,zoom );return _ddca .appendChunk (_cfgee );};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_egac *Image )ScaleToWidth (w float64 ){_fff :=_egac ._gfgd /_egac ._fcd ;_egac ._fcd =w ;_egac ._gfgd =w *_fff ;};type cmykColor struct{_fcfb ,_agd ,_gea ,_efa float64 };

// RotatedSize returns the width and height of the rotated block.
func (_ccc *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_be ,_ada :=_gbcf (_ccc ._afd ,_ccc ._afb ,_ccc ._fg );return _be ,_ada ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_gagf *Creator )MoveDown (dy float64 ){_gagf ._acag .Y +=dy };

// Height returns Image's document height.
func (_dbcg *Image )Height ()float64 {return _dbcg ._gfgd };func _cbbg (_gfde *_ffb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_gfde ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Angle returns the block rotation angle in degrees.
func (_fgc *Block )Angle ()float64 {return _fgc ._fg };func _gfgda (_gcde *Block ,_gcbcf *StyledParagraph ,_dbdc [][]*TextChunk ,_cefad DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bcefeb :=1;_ddd :=_ce .PdfObjectName (_ae .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bcefeb ));
for _gcde ._d .HasFontByName (_ddd ){_bcefeb ++;_ddd =_ce .PdfObjectName (_ae .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bcefeb ));};_becce :=_gcde ._d .SetFontByName (_ddd ,_gcbcf ._cdef .Font .ToPdfObject ());if _becce !=nil {return _cefad ,nil ,_becce ;
};_bcefeb ++;_caag :=_ddd ;_dgcd :=_gcbcf ._cdef .FontSize ;_fgac :=_gcbcf ._gebf .IsRelative ();var _dgfa [][]_ce .PdfObjectName ;var _gdddbb [][]*TextChunk ;var _fbcg float64 ;for _cceab ,_cege :=range _dbdc {var _gedg []_ce .PdfObjectName ;var _aaec float64 ;
for _ ,_eeba :=range _cege {_ebcfg :=_eeba .Style ;if _ebcfg .FontSize > _aaec {_aaec =_ebcfg .FontSize ;};_ddd =_ce .PdfObjectName (_ae .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bcefeb ));_gbca :=_gcde ._d .SetFontByName (_ddd ,_ebcfg .Font .ToPdfObject ());
if _gbca !=nil {return _cefad ,nil ,_gbca ;};_gedg =append (_gedg ,_ddd );_bcefeb ++;};_aaec *=_gcbcf ._efdf ;if _fgac &&_fbcg +_aaec > _cefad .Height {_gdddbb =_dbdc [_cceab :];_dbdc =_dbdc [:_cceab ];break ;};_fbcg +=_aaec ;_dgfa =append (_dgfa ,_gedg );
};_faee ,_bcdgc ,_adfd :=_gcbcf .getLineMetrics (0);_aefc ,_gcbb :=_faee *_gcbcf ._efdf ,_bcdgc *_gcbcf ._efdf ;_babfg :=_eff .NewContentCreator ();_babfg .Add_q ();_eagc :=_gcbb ;if _gcbcf ._dccgd ==TextVerticalAlignmentCenter {_eagc =_bcdgc +(_faee +_adfd -_bcdgc )/2+(_gcbb -_bcdgc )/2;
};_dddg :=_cefad .PageHeight -_cefad .Y -_eagc ;_babfg .Translate (_cefad .X ,_dddg );_adggg :=_dddg ;if _gcbcf ._dccbc !=0{_babfg .RotateDeg (_gcbcf ._dccbc );};if _gcbcf ._ebba ==TextOverflowHidden {_babfg .Add_re (0,-_fbcg +_aefc +1,_gcbcf ._ffeb ,_fbcg ).Add_W ().Add_n ();
};_babfg .Add_BT ();var _bffd []*_bd .BasicLine ;for _ccdea ,_fced :=range _dbdc {_gegf :=_cefad .X ;if _ccdea !=0{_babfg .Add_Tstar ();};_bfgd :=_ccdea ==len (_dbdc )-1;var (_faffb float64 ;_ceaef float64 ;_ggacb float64 ;_caffb uint ;);var _ddcc []float64 ;
for _ ,_ceeb :=range _fced {_feea :=&_ceeb .Style ;if _feea .FontSize > _ceaef {_ceaef =_feea .FontSize ;};_abcb ,_eedge :=_feea .Font .GetRuneMetrics (' ');if !_eedge {return _cefad ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _gcdd uint ;var _dgegf float64 ;_cbge :=len (_ceeb .Text );for _bcee ,_cggde :=range _ceeb .Text {if _cggde ==' '{_gcdd ++;continue ;};if _cggde =='\u000A'{continue ;};_eecf ,_ccaf :=_feea .Font .GetRuneMetrics (_cggde );if !_ccaf {_ca .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_cggde );
return _cefad ,nil ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dgegf +=_feea .FontSize *_eecf .Wx *_feea .horizontalScale ();if _bcee !=_cbge -1{_dgegf +=_feea .CharSpacing *1000.0;
};};_ddcc =append (_ddcc ,_dgegf );_faffb +=_dgegf ;_ggacb +=float64 (_gcdd )*_abcb .Wx *_feea .FontSize *_feea .horizontalScale ();_caffb +=_gcdd ;};_ceaef *=_gcbcf ._efdf ;var _ddffb []_ce .PdfObject ;_aabb :=_gcbcf ._ffeb *1000.0;if _gcbcf ._cbeag ==TextAlignmentJustify {if _caffb > 0&&!_bfgd {_ggacb =(_aabb -_faffb )/float64 (_caffb )/_dgcd ;
};}else if _gcbcf ._cbeag ==TextAlignmentCenter {_agga :=(_aabb -_faffb -_ggacb )/2;_aafae :=_agga /_dgcd ;_ddffb =append (_ddffb ,_ce .MakeFloat (-_aafae ));_gegf +=_agga /1000.0;}else if _gcbcf ._cbeag ==TextAlignmentRight {_bcaa :=(_aabb -_faffb -_ggacb );
_dfge :=_bcaa /_dgcd ;_ddffb =append (_ddffb ,_ce .MakeFloat (-_dfge ));_gegf +=_bcaa /1000.0;};if len (_ddffb )> 0{_babfg .Add_Tf (_caag ,_dgcd ).Add_TL (_dgcd *_gcbcf ._efdf ).Add_TJ (_ddffb ...);};var _bfed float64 ;for _aabe ,_edde :=range _fced {_bdcd :=&_edde .Style ;
if _bdcd .FontSize > _bfed {_bfed =_bdcd .FontSize ;};_agfa :=_caag ;_daaf :=_dgcd ;_cgbf :=_bdcd .OutlineColor !=nil ;_faecb :=_bdcd .HorizontalScaling !=DefaultHorizontalScaling ;_baeced :=_bdcd .OutlineSize !=1;if _baeced {_babfg .Add_w (_bdcd .OutlineSize );
};_deeb :=_bdcd .RenderingMode !=TextRenderingModeFill ;if _deeb {_babfg .Add_Tr (int64 (_bdcd .RenderingMode ));};_dbcbc :=_bdcd .CharSpacing !=0;if _dbcbc {_babfg .Add_Tc (_bdcd .CharSpacing );};_dcfe :=_bdcd .TextRise !=0;if _dcfe {_babfg .Add_Ts (_bdcd .TextRise );
};if _gcbcf ._cbeag !=TextAlignmentJustify ||_bfgd {_febgd ,_cged :=_bdcd .Font .GetRuneMetrics (' ');if !_cged {return _cefad ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_agfa =_dgfa [_ccdea ][_aabe ];_daaf =_bdcd .FontSize ;_ggacb =_febgd .Wx *_bdcd .horizontalScale ();};_gagfe :=_bdcd .Font .Encoder ();var _cfff []byte ;for _ ,_aedee :=range _edde .Text {if _aedee =='\u000A'{continue ;};if _aedee ==' '{if len (_cfff )> 0{if _cgbf {_babfg .SetStrokingColor (_cbae (_bdcd .OutlineColor ));
};if _faecb {_babfg .Add_Tz (_bdcd .HorizontalScaling );};_babfg .SetNonStrokingColor (_cbae (_bdcd .Color )).Add_Tf (_dgfa [_ccdea ][_aabe ],_bdcd .FontSize ).Add_TJ ([]_ce .PdfObject {_ce .MakeStringFromBytes (_cfff )}...);_cfff =nil ;};if _faecb {_babfg .Add_Tz (DefaultHorizontalScaling );
};_babfg .Add_Tf (_agfa ,_daaf ).Add_TJ ([]_ce .PdfObject {_ce .MakeFloat (-_ggacb )}...);_ddcc [_aabe ]+=_ggacb *_daaf ;}else {if _ ,_dfgc :=_gagfe .RuneToCharcode (_aedee );!_dfgc {_ca .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_aedee ,_aedee );
continue ;};_cfff =append (_cfff ,_gagfe .Encode (string (_aedee ))...);};};if len (_cfff )> 0{if _cgbf {_babfg .SetStrokingColor (_cbae (_bdcd .OutlineColor ));};if _faecb {_babfg .Add_Tz (_bdcd .HorizontalScaling );};_babfg .SetNonStrokingColor (_cbae (_bdcd .Color )).Add_Tf (_dgfa [_ccdea ][_aabe ],_bdcd .FontSize ).Add_TJ ([]_ce .PdfObject {_ce .MakeStringFromBytes (_cfff )}...);
};_cgcgf :=_ddcc [_aabe ]/1000.0;if _bdcd .Underline {_eccee :=_bdcd .UnderlineStyle .Color ;if _eccee ==nil {_eccee =_edde .Style .Color ;};_gcad ,_eabf ,_eddaf :=_eccee .ToRGB ();_cgbd :=_gegf -_cefad .X ;_aegf :=_adggg -_dddg +_bdcd .TextRise -_bdcd .UnderlineStyle .Offset ;
_bffd =append (_bffd ,&_bd .BasicLine {X1 :_cgbd ,Y1 :_aegf ,X2 :_cgbd +_cgcgf ,Y2 :_aegf ,LineWidth :_edde .Style .UnderlineStyle .Thickness ,LineColor :_ffb .NewPdfColorDeviceRGB (_gcad ,_eabf ,_eddaf )});};if _edde ._gbbe !=nil {var _dggb *_ce .PdfObjectArray ;
if !_edde ._cggfc {switch _cgce :=_edde ._gbbe .GetContext ().(type ){case *_ffb .PdfAnnotationLink :_dggb =_ce .MakeArray ();_cgce .Rect =_dggb ;_ccgc ,_gfeg :=_cgce .Dest .(*_ce .PdfObjectArray );if _gfeg &&_ccgc .Len ()==5{_aecc ,_abeab :=_ccgc .Get (1).(*_ce .PdfObjectName );
if _abeab &&_aecc .String ()=="\u0058\u0059\u005a"{_eead ,_ebbe :=_ce .GetNumberAsFloat (_ccgc .Get (3));if _ebbe ==nil {_ccgc .Set (3,_ce .MakeFloat (_cefad .PageHeight -_eead ));};};};};_edde ._cggfc =true ;};if _dggb !=nil {_ddag :=_bd .NewPoint (_gegf -_cefad .X ,_adggg +_bdcd .TextRise -_dddg ).Rotate (_gcbcf ._dccbc );
_ddag .X +=_cefad .X ;_ddag .Y +=_dddg ;_eecc ,_befda ,_eebb ,_ccbcb :=_gbcf (_cgcgf ,_ceaef ,_gcbcf ._dccbc );_ddag .X +=_eecc ;_ddag .Y +=_befda ;_dggb .Clear ();_dggb .Append (_ce .MakeFloat (_ddag .X ));_dggb .Append (_ce .MakeFloat (_ddag .Y ));_dggb .Append (_ce .MakeFloat (_ddag .X +_eebb ));
_dggb .Append (_ce .MakeFloat (_ddag .Y +_ccbcb ));};_gcde .AddAnnotation (_edde ._gbbe );};_gegf +=_cgcgf ;if _baeced {_babfg .Add_w (1.0);};if _cgbf {_babfg .Add_RG (0.0,0.0,0.0);};if _deeb {_babfg .Add_Tr (int64 (TextRenderingModeFill ));};if _dbcbc {_babfg .Add_Tc (0);
};if _dcfe {_babfg .Add_Ts (0);};if _faecb {_babfg .Add_Tz (DefaultHorizontalScaling );};};_babfg .Add_TL (_bfed *_gcbcf ._efdf );_adggg -=_ceaef ;};_babfg .Add_ET ();for _ ,_ddce :=range _bffd {_babfg .SetStrokingColor (_ddce .LineColor ).Add_w (_ddce .LineWidth ).Add_m (_ddce .X1 ,_ddce .Y1 ).Add_l (_ddce .X2 ,_ddce .Y2 ).Add_s ();
};_babfg .Add_Q ();_dcagf :=_babfg .Operations ();_dcagf .WrapIfNeeded ();_gcde .addContents (_dcagf );if _fgac {_acbe :=_fbcg +_gcbcf ._abed .Bottom ;_cefad .Y +=_acbe ;_cefad .Height -=_acbe ;if _cefad .Inline {_cefad .X +=_gcbcf .Width ()+_gcbcf ._abed .Right ;
};};return _cefad ,_gdddbb ,nil ;};func (_fdba *StyledParagraph )getMaxLineWidth ()float64 {if _fdba ._bcfb ==nil ||len (_fdba ._bcfb )==0{_fdba .wrapText ();};var _dgddd float64 ;for _ ,_decc :=range _fdba ._bcfb {_cafff :=_fdba .getTextLineWidth (_decc );
if _cafff > _dgddd {_dgddd =_cafff ;};};return _dgddd ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_baece []*listItem ;_ggde Margins ;_gaaf TextChunk ;_dbfg float64 ;_edda bool ;_bdcf Positioning ;_abgcc TextStyle ;};func (_aedf *TextStyle )horizontalScale ()float64 {return _aedf .HorizontalScaling /100};

// SetFontSize sets the font size in document units (points).
func (_afdg *Paragraph )SetFontSize (fontSize float64 ){_afdg ._fge =fontSize };

// SetAngle sets Image rotation angle in degrees.
func (_edab *Image )SetAngle (angle float64 ){_edab ._cbed =angle };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_eadg *Invoice )NoteStyle ()TextStyle {return _eadg ._fadf };

// AppendCurve appends a Bezier curve to the filled curve.
func (_cdfe *FilledCurve )AppendCurve (curve _bd .CubicBezierCurve )*FilledCurve {_cdfe ._cgac =append (_cdfe ._cgac ,curve );return _cdfe ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_geaa *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbcg :=ctx ;_egcbb ,ctx ,_bcgd :=_geaa ._cbbgg .GeneratePageBlocks (ctx );if _bcgd !=nil {return _egcbb ,ctx ,_bcgd ;};if _geaa ._cfcec .IsRelative (){ctx .X =_gbcg .X ;
};if _geaa ._cfcec .IsAbsolute (){return _egcbb ,_gbcg ,nil ;};return _egcbb ,ctx ,nil ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_bfccb *_bd .PolyBezierCurve ;_eefdc float64 ;_ceda float64 ;};

// SetNumber sets the number of the invoice.
func (_eadf *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_eadf ._geef [1].Value =number ;return _eadf ._geef [0],_eadf ._geef [1];};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// SetLineHeight sets the line height (1.0 default).
func (_cdfef *Paragraph )SetLineHeight (lineheight float64 ){_cdfef ._efgdb =lineheight };type rgbColor struct{_deb ,_cfbd ,_feaf float64 };func (_dbge *FilledCurve )draw (_ccgae string )([]byte ,*_ffb .PdfRectangle ,error ){_agea :=_bd .NewCubicBezierPath ();
for _ ,_baad :=range _dbge ._cgac {_agea =_agea .AppendCurve (_baad );};creator :=_eff .NewContentCreator ();creator .Add_q ();if _dbge .FillEnabled &&_dbge ._ecbf !=nil {creator .SetNonStrokingColor (_cbae (_dbge ._ecbf ));};if _dbge .BorderEnabled {if _dbge ._aacb !=nil {creator .SetStrokingColor (_cbae (_dbge ._aacb ));
};creator .Add_w (_dbge .BorderWidth );};if len (_ccgae )> 1{creator .Add_gs (_ce .PdfObjectName (_ccgae ));};_bd .DrawBezierPathWithCreator (_agea ,creator );creator .Add_h ();if _dbge .FillEnabled &&_dbge .BorderEnabled {creator .Add_B ();}else if _dbge .FillEnabled {creator .Add_f ();
}else if _dbge .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_gcab :=_agea .GetBoundingBox ();if _dbge .BorderEnabled {_gcab .Height +=_dbge .BorderWidth ;_gcab .Width +=_dbge .BorderWidth ;_gcab .X -=_dbge .BorderWidth /2;_gcab .Y -=_dbge .BorderWidth /2;
};_bfea :=&_ffb .PdfRectangle {};_bfea .Llx =_gcab .X ;_bfea .Lly =_gcab .Y ;_bfea .Urx =_gcab .X +_gcab .Width ;_bfea .Ury =_gcab .Y +_gcab .Height ;return creator .Bytes (),_bfea ,nil ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_afce *TOCLine )SetLink (page int64 ,x ,y float64 ){_afce ._egec =x ;_afce ._bagc =y ;_afce ._ddbf =page ;_ecab :=_afce ._cbbgg ._dbcgc .Color ;_afce .Number .Style .Color =_ecab ;_afce .Title .Style .Color =_ecab ;_afce .Separator .Style .Color =_ecab ;
_afce .Page .Style .Color =_ecab ;};

// SetBorderWidth sets the border width.
func (_fgee *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_fgee ._bfccb .BorderWidth =borderWidth ;};func (_dca *Image )rotatedSize ()(float64 ,float64 ){_dgdd :=_dca ._fcd ;_ede :=_dca ._gfgd ;_fcbb :=_dca ._cbed ;if _fcbb ==0{return _dgdd ,_ede ;
};_febd :=_bd .Path {Points :[]_bd .Point {_bd .NewPoint (0,0).Rotate (_fcbb ),_bd .NewPoint (_dgdd ,0).Rotate (_fcbb ),_bd .NewPoint (0,_ede ).Rotate (_fcbb ),_bd .NewPoint (_dgdd ,_ede ).Rotate (_fcbb )}}.GetBoundingBox ();return _febd .Width ,_febd .Height ;
};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cdadc *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cdadc ._bedb =halign ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_dcce *Invoice )SetColumns (cols []*InvoiceCell ){_dcce ._fbdb =cols };func (_bcge *Invoice )setCellBorder (_affd *TableCell ,_defaa *InvoiceCell ){for _ ,_gfb :=range _defaa .BorderSides {_affd .SetBorder (_gfb ,CellBorderStyleSingle ,_defaa .BorderWidth );
};_affd .SetBorderColor (_defaa .BorderColor );};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// NewTOC creates a new table of contents.
func (_cggb *Creator )NewTOC (title string )*TOC {_caee :=_cggb .NewTextStyle ();_caee .Font =_cggb ._ecgc ;return _beca (title ,_cggb .NewTextStyle (),_caee );};

// NewImage create a new image from a unidoc image (model.Image).
func (_degfb *Creator )NewImage (img *_ffb .Image )(*Image ,error ){return _abab (img )};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_ffad *TOC )SetLineSeparatorStyle (style TextStyle ){_ffad ._adag =style };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;func _ecbc (_bbcc *_ffb .PdfAnnotationLink )*_ffb .PdfAnnotationLink {if _bbcc ==nil {return nil ;};_bgdg :=_ffb .NewPdfAnnotationLink ();_bgdg .BS =_bbcc .BS ;_bgdg .A =_bbcc .A ;if _aaee ,_daed :=_bbcc .GetAction ();_daed ==nil &&_aaee !=nil {_bgdg .SetAction (_aaee );
};if _dfda ,_bddfe :=_bbcc .Dest .(*_ce .PdfObjectArray );_bddfe {_bgdg .Dest =_ce .MakeArray (_dfda .Elements ()...);};return _bgdg ;};

// SetBorderColor sets the border color.
func (_abfdc *PolyBezierCurve )SetBorderColor (color Color ){_abfdc ._bfccb .BorderColor =_cbae (color )};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_eecg []*TextChunk ;_cdef TextStyle ;_dbcgc TextStyle ;_cbeag TextAlignment ;_dccgd TextVerticalAlignment ;_efdf float64 ;_adbb bool ;_ffeb float64 ;_ceca bool ;_ebba TextOverflow ;_dccbc float64 ;_abed Margins ;_gebf Positioning ;
_egfb float64 ;_cdagf float64 ;_bfga float64 ;_fgeb float64 ;_bcfb [][]*TextChunk ;_eaeee func (_agcd *StyledParagraph ,_bfeba DrawContext );};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_gbgc *_bd .Polygon ;_aaacc float64 ;_fbdeb float64 ;};

// SetStyleBottom sets border style for bottom side.
func (_bdf *border )SetStyleBottom (style CellBorderStyle ){_bdf ._edd =style };func _ecce (_facb TextStyle )*List {return &List {_gaaf :TextChunk {Text :"\u2022\u0020",Style :_facb },_dbfg :0,_edda :true ,_bdcf :PositionRelative ,_abgcc :_facb };};func _ebga (_ggdb ,_dfcfg ,_dcegb TextChunk ,_adaf uint ,_fgcdc TextStyle )*TOCLine {_cecd :=_ebgd (_fgcdc );
_cecd .SetEnableWrap (true );_cecd .SetTextAlignment (TextAlignmentLeft );_cecd .SetMargins (0,0,2,2);_gbage :=&TOCLine {_cbbgg :_cecd ,Number :_ggdb ,Title :_dfcfg ,Page :_dcegb ,Separator :TextChunk {Text :"\u002e",Style :_fgcdc },_fdbdb :0,_bedc :_adaf ,_cecg :10,_cfcec :PositionRelative };
_cecd ._abed .Left =_gbage ._fdbdb +float64 (_gbage ._bedc -1)*_gbage ._cecg ;_cecd ._eaeee =_gbage .prepareParagraph ;return _gbage ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);
ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););var PPMM =float64 (72*1.0/25.4);

// SetAngle sets the rotation angle of the text.
func (_ddgf *StyledParagraph )SetAngle (angle float64 ){_ddgf ._dccbc =angle };

// AppendColumn appends a column to the line items table.
func (_decb *Invoice )AppendColumn (description string )*InvoiceCell {_abfe :=_decb .NewColumn (description );_decb ._fbdb =append (_decb ._fbdb ,_abfe );return _abfe ;};

// NewImageFromFile creates an Image from a file.
func (_fbdf *Creator )NewImageFromFile (path string )(*Image ,error ){return _ggea (path )};

// SetAngle sets the rotation angle in degrees.
func (_fe *Block )SetAngle (angleDeg float64 ){_fe ._fg =angleDeg };func (_cda *Creator )getActivePage ()*_ffb .PdfPage {if _cda ._ecc ==nil {if len (_cda ._aca )==0{return nil ;};return _cda ._aca [len (_cda ._aca )-1];};return _cda ._ecc ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_ccd *Creator )NewParagraph (text string )*Paragraph {return _fdcca (text ,_ccd .NewTextStyle ())};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_bgaa *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gdee :=ctx ;var _gaab []*Block ;_cfbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bgaa ._agfce .IsRelative (){ctx .X +=_bgaa ._abeae .Left ;ctx .Y +=_bgaa ._abeae .Top ;
ctx .Width -=_bgaa ._abeae .Left +_bgaa ._abeae .Right ;ctx .Height -=_bgaa ._abeae .Top +_bgaa ._abeae .Bottom ;_bgaa .SetWidth (ctx .Width );if _bgaa .Height ()> ctx .Height {_gaab =append (_gaab ,_cfbb );_cfbb =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_fggf :=ctx ;_fggf .Y =ctx .Margins .Top ;_fggf .X =ctx .Margins .Left +_bgaa ._abeae .Left ;_fggf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bgaa ._abeae .Bottom ;_fggf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bgaa ._abeae .Left -_bgaa ._abeae .Right ;
ctx =_fggf ;};}else {if int (_bgaa ._ceae )<=0{_bgaa .SetWidth (_bgaa .getTextWidth ());};ctx .X =_bgaa ._aacg ;ctx .Y =_bgaa ._fccag ;};ctx ,_gaeb :=_ddge (_cfbb ,_bgaa ,ctx );if _gaeb !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gaeb );
return nil ,ctx ,_gaeb ;};_gaab =append (_gaab ,_cfbb );if _bgaa ._agfce .IsRelative (){ctx .X -=_bgaa ._abeae .Left ;ctx .Width =_gdee .Width ;return _gaab ,ctx ,nil ;};return _gaab ,_gdee ,nil ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_cbfg *TextChunk )SetAnnotation (annotation *_ffb .PdfAnnotation ){_cbfg ._gbbe =annotation };type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_abef Drawable )(Drawable ,error );};func _dcfa (_gbcb ,_ccag ,_eccf string ,_cafd uint ,_dfac TextStyle )*TOCLine {return _ebga (TextChunk {Text :_gbcb ,Style :_dfac },TextChunk {Text :_ccag ,Style :_dfac },TextChunk {Text :_eccf ,Style :_dfac },_cafd ,_dfac );
};func _gcef (_bgce *_ffb .PdfAnnotation )*_ffb .PdfAnnotation {if _bgce ==nil {return nil ;};var _efdbf *_ffb .PdfAnnotation ;switch _aceag :=_bgce .GetContext ().(type ){case *_ffb .PdfAnnotationLink :if _fafb :=_ecbc (_aceag );_fafb !=nil {_efdbf =_fafb .PdfAnnotation ;
};};return _efdbf ;};func (_daege *Invoice )newColumn (_eaea string ,_gfac CellHorizontalAlignment )*InvoiceCell {_bcdee :=&InvoiceCell {_daege ._bbaa ,_eaea };_bcdee .Alignment =_gfac ;return _bcdee ;};

// SetFillOpacity sets the fill opacity.
func (_fcgg *CurvePolygon )SetFillOpacity (opacity float64 ){_fcgg ._gddb =opacity };func (_bddcd *Chapter )headingNumber ()string {var _aafe string ;if _bddcd ._efg {if _bddcd ._gef !=0{_aafe =_af .Itoa (_bddcd ._gef )+"\u002e";};if _bddcd ._efgb !=nil {_dfad :=_bddcd ._efgb .headingNumber ();
if _dfad !=""{_aafe =_dfad +_aafe ;};};};return _aafe ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_adbg *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _adbg ._fgdf .Left ,_adbg ._fgdf .Right ,_adbg ._fgdf .Top ,_adbg ._fgdf .Bottom ;};func _eecdd (_gebc []_bd .Point )*Polyline {return &Polyline {_aeeg :&_bd .Polyline {Points :_gebc ,LineColor :_ffb .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_edef :1.0};
};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);