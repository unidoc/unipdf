//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_c "bytes";_e "encoding/xml";_d "errors";_fb "fmt";_g "github.com/gorilla/i18n/linebreak";_ef "github.com/unidoc/unichart/render";_da "github.com/unidoc/unipdf/v3/common";_ebc "github.com/unidoc/unipdf/v3/contentstream";_bg "github.com/unidoc/unipdf/v3/contentstream/draw";
_dd "github.com/unidoc/unipdf/v3/core";_aeb "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_aad "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_ga "github.com/unidoc/unipdf/v3/internal/license";_bc "github.com/unidoc/unipdf/v3/internal/transform";
_fee "github.com/unidoc/unipdf/v3/model";_aa "golang.org/x/text/unicode/bidi";_a "image";_fg "io";_fa "math";_fd "os";_ae "regexp";_b "sort";_fe "strconv";_cf "strings";_ff "text/template";_eb "unicode";);

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_ebdcd *_bg .Polygon ;_aacf float64 ;_ecbgf float64 ;_ecad Color ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_bgaad *RadialShading )SetBackgroundColor (backgroundColor Color ){_bgaad ._ecef .SetBackgroundColor (backgroundColor );};func (_cfg *Block )duplicate ()*Block {_ec :=&Block {};*_ec =*_cfg ;_dae :=_ebc .ContentStreamOperations {};_dae =append (_dae ,*_cfg ._db ...);
_ec ._db =&_dae ;return _ec ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_abbbg *TOC )SetShowLinks (showLinks bool ){_abbbg ._ffag =showLinks };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetBorderOpacity sets the border opacity.
func (_cbff *Polygon )SetBorderOpacity (opacity float64 ){_cbff ._ecbgf =opacity };

// NewTable create a new Table with a specified number of columns.
func (_ffgg *Creator )NewTable (cols int )*Table {return _agegf (cols )};

// AppendColumn appends a column to the line items table.
func (_gecbf *Invoice )AppendColumn (description string )*InvoiceCell {_badga :=_gecbf .NewColumn (description );_gecbf ._eaafb =append (_gecbf ._eaafb ,_badga );return _badga ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_dbdd *RadialShading )SetAntiAlias (enable bool ){_dbdd ._ecef .SetAntiAlias (enable )};

// Notes returns the notes section of the invoice as a title-content pair.
func (_dfgg *Invoice )Notes ()(string ,string ){return _dfgg ._egdda [0],_dfgg ._egdda [1]};func (_afgf *Invoice )generateHeaderBlocks (_agad DrawContext )([]*Block ,DrawContext ,error ){_adfb :=_dccc (_afgf ._effe );_adfb .SetEnableWrap (true );_adfb .Append (_afgf ._faea );
_bdeb :=_agegf (2);if _afgf ._gaffd !=nil {_bbfd :=_bdeb .NewCell ();_bbfd .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bbfd .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bbfd .SetIndent (0);_bbfd .SetContent (_afgf ._gaffd );_afgf ._gaffd .ScaleToHeight (_adfb .Height ()+20);
}else {_bdeb .SkipCells (1);};_gdff :=_bdeb .NewCell ();_gdff .SetHorizontalAlignment (CellHorizontalAlignmentRight );_gdff .SetVerticalAlignment (CellVerticalAlignmentMiddle );_gdff .SetContent (_adfb );return _bdeb .GeneratePageBlocks (_agad );};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_gdag *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_gdag ._gcag .Left =left ;_gdag ._gcag .Right =right ;_gdag ._gcag .Top =top ;_gdag ._gcag .Bottom =bottom ;};

// Padding returns the padding of the component.
func (_aafc *Division )Padding ()(_edba ,_cgdc ,_dfdb ,_fbgab float64 ){return _aafc ._deca .Left ,_aafc ._deca .Right ,_aafc ._deca .Top ,_aafc ._deca .Bottom ;};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_cfff *_aeb .GraphicSVG ;_ebgcc Positioning ;_cad float64 ;_debcc float64 ;_dadde Margins ;};

// SetText sets the text content of the Paragraph.
func (_baga *Paragraph )SetText (text string ){_baga ._fagf =text };

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_acag *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_acag ._fafa =dashArray ;_acag ._ccgd =dashPhase ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_adeb []*TextChunk ;_cefc TextStyle ;_fecf TextStyle ;_fdge TextAlignment ;_cfebc TextVerticalAlignment ;_gbbd float64 ;_egge bool ;_cdba float64 ;_dffeg bool ;_cbbga bool ;_ebbd TextOverflow ;_bbfc float64 ;_eebag Margins ;
_eege Positioning ;_fggg float64 ;_gaba float64 ;_cega float64 ;_gdcf float64 ;_cfcf [][]*TextChunk ;_dbff func (_bcfcb *StyledParagraph ,_dbca DrawContext );};func _ceefe (_ecgebb *_fee .PdfAnnotationLink )*_fee .PdfAnnotationLink {if _ecgebb ==nil {return nil ;
};_ffbef :=_fee .NewPdfAnnotationLink ();_ffbef .BS =_ecgebb .BS ;_ffbef .A =_ecgebb .A ;if _cebbe ,_dfaa :=_ecgebb .GetAction ();_dfaa ==nil &&_cebbe !=nil {_ffbef .SetAction (_cebbe );};if _begdc ,_fgeg :=_ecgebb .Dest .(*_dd .PdfObjectArray );_fgeg {_ffbef .Dest =_dd .MakeArray (_begdc .Elements ()...);
};return _ffbef ;};

// EnableWordWrap sets the paragraph word wrap flag.
func (_bfdda *StyledParagraph )EnableWordWrap (val bool ){_bfdda ._dffeg =val };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        â€¢ This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_fegg []*listItem ;_bffg Margins ;_dabcb TextChunk ;_cfffc float64 ;_ggeg bool ;_aaab Positioning ;_bdbe TextStyle ;};

// Width returns the width of the Paragraph.
func (_agga *StyledParagraph )Width ()float64 {if _agga ._egge &&int (_agga ._cdba )> 0{return _agga ._cdba ;};return _agga .getTextWidth ()/1000.0;};var PPI float64 =72;

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// InsertColumn inserts a column in the line items table at the specified index.
func (_agdd *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_ggfc :=uint (len (_agdd ._eaafb ));if index > _ggfc {index =_ggfc ;};_aecc :=_agdd .NewColumn (description );_agdd ._eaafb =append (_agdd ._eaafb [:index ],append ([]*InvoiceCell {_aecc },_agdd ._eaafb [index :]...)...);
return _aecc ;};

// SetFillColor sets the fill color.
func (_cbgb *CurvePolygon )SetFillColor (color Color ){_cbgb ._agf =color ;_cbgb ._aaee .FillColor =_cfd (color );};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_bbgcb *GraphicSVG )SetPos (x ,y float64 ){_bbgcb ._ebgcc =PositionAbsolute ;_bbgcb ._cad =x ;_bbgcb ._debcc =y ;};

// SetFontSize sets the font size in document units (points).
func (_bccgg *Paragraph )SetFontSize (fontSize float64 ){_bccgg ._bgef =fontSize };

// Lines returns all the lines the table of contents has.
func (_fdcde *TOC )Lines ()[]*TOCLine {return _fdcde ._bbfe };

// AddLine adds a new line with the provided style to the table of contents.
func (_egbd *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_egbd ._bbfe =append (_egbd ._bbfe ,line );return line ;};

// Columns returns all the columns in the invoice line items table.
func (_bebgb *Invoice )Columns ()[]*InvoiceCell {return _bebgb ._eaafb };

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_cdeb *Division )Height ()float64 {var _bea float64 ;for _ ,_gacd :=range _cdeb ._aegg {switch _gffd :=_gacd .(type ){case marginDrawable :_ ,_ ,_gedf ,_agba :=_gffd .GetMargins ();_bea +=_gffd .Height ()+_gedf +_agba ;default:_bea +=_gffd .Height ();
};};return _bea ;};

// Style returns the style of the line.
func (_dabf *Line )Style ()_bg .LineStyle {return _dabf ._gffb };func (_faac *pageTransformations )transformPage (_fdg *_fee .PdfPage )error {if _dfda :=_faac .applyFlip (_fdg );_dfda !=nil {return _dfda ;};return nil ;};

// NewTOC creates a new table of contents.
func (_dfac *Creator )NewTOC (title string )*TOC {_aegc :=_dfac .NewTextStyle ();_aegc .Font =_dfac ._gbad ;return _cged (title ,_dfac .NewTextStyle (),_aegc );};

// Add adds a new line with the default style to the table of contents.
func (_egagc *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_feefa :=_egagc .AddLine (_bege (TextChunk {Text :number ,Style :_egagc ._bbda },TextChunk {Text :title ,Style :_egagc ._gaebe },TextChunk {Text :page ,Style :_egagc ._ddege },level ,_egagc ._dcdcg ));
if _feefa ==nil {return nil ;};_eecdf :=&_egagc ._fdgc ;_feefa .SetMargins (_eecdf .Left ,_eecdf .Right ,_eecdf .Top ,_eecdf .Bottom );_feefa .SetLevelOffset (_egagc ._gfdfe );_feefa .Separator .Text =_egagc ._gabb ;_feefa .Separator .Style =_egagc ._ffedc ;
return _feefa ;};func (_bdcbg *templateProcessor )addNodeText (_ggfea *templateNode ,_beded string )error {_fdgef :=_ggfea ._bdced ;if _fdgef ==nil {return nil ;};switch _ccde :=_fdgef .(type ){case *TextChunk :_ccde .Text =_beded ;case *Paragraph :switch _ggfea ._bdbga .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _ggfea ._bdgb !=nil {if _geebg ,_gdcdf :=_ggfea ._bdgb ._bdced .(*Chapter );
_gdcdf {_geebg ._cdb =_beded ;_ccde .SetText (_geebg .headingText ());};};default:_ccde .SetText (_beded );};};return nil ;};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_bgec *Ellipse )FillOpacity ()float64 {return _bgec ._eeec };

// GeneratePageBlocks draws the curve onto page blocks.
func (_ddcb *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agde :=_ebc .NewContentCreator ();_agde .Add_q ().Add_w (_ddcb ._cgfc ).SetStrokingColor (_cfd (_ddcb ._gabg )).Add_m (_ddcb ._dggg ,ctx .PageHeight -_ddcb ._cea ).Add_v (_ddcb ._beg ,ctx .PageHeight -_ddcb ._febag ,_ddcb ._bda ,ctx .PageHeight -_ddcb ._ccbc ).Add_S ().Add_Q ();
_effa :=_fbcg .addContentsByString (_agde .String ());if _effa !=nil {return nil ,ctx ,_effa ;};return []*Block {_fbcg },ctx ,nil ;};

// SetDueDate sets the due date of the invoice.
func (_cbfg *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_cbfg ._edgf [1].Value =dueDate ;return _cbfg ._edgf [0],_cbfg ._edgf [1];};func (_deff rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _deff ._ade ,_deff ._fcc ,_deff ._fbe };


// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_gfaff *List )Width ()float64 {return 0};

// Scale block by specified factors in the x and y directions.
func (_fbac *Block )Scale (sx ,sy float64 ){_ecg :=_ebc .NewContentCreator ().Scale (sx ,sy ).Operations ();*_fbac ._db =append (*_ecg ,*_fbac ._db ...);_fbac ._db .WrapIfNeeded ();_fbac ._bab *=sx ;_fbac ._egb *=sy ;};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_egee *Rectangle )SetPositioning (position Positioning ){_egee ._fgaa =position };

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_ade :float64 (r )/255.0,_fcc :float64 (g )/255.0,_fbe :float64 (b )/255.0};};func _dee (_dadb ,_agd *_fee .PdfPageResources )error {_ccb ,_ :=_dadb .GetColorspaces ();if _ccb !=nil &&len (_ccb .Colorspaces )> 0{for _bff ,_gad :=range _ccb .Colorspaces {_eeaa :=*_dd .MakeName (_bff );
if _agd .HasColorspaceByName (_eeaa ){continue ;};_gdb :=_agd .SetColorspaceByName (_eeaa ,_gad );if _gdb !=nil {return _gdb ;};};};return nil ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_adbc *Chapter )SetIncludeInTOC (includeInTOC bool ){_adbc ._bge =includeInTOC };func _bbcf (_aafcf ,_faba ,_addfe ,_bagc float64 )*Line {return &Line {_bcgf :_aafcf ,_fgba :_faba ,_ecec :_addfe ,_daac :_bagc ,_bec :ColorBlack ,_dcfe :1.0,_bdfc :1.0,_fafa :[]int64 {1,1},_aede :PositionAbsolute };
};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_fee .PdfPage )(*Block ,error ){_bga :=&Block {};_ge ,_aae :=page .GetAllContentStreams ();if _aae !=nil {return nil ,_aae ;};_gfa :=_ebc .NewContentStreamParser (_ge );_dab ,_aae :=_gfa .Parse ();if _aae !=nil {return nil ,_aae ;
};_dab .WrapIfNeeded ();_bga ._db =_dab ;if page .Resources !=nil {_bga ._gf =page .Resources ;}else {_bga ._gf =_fee .NewPdfPageResources ();};_cfe ,_aae :=page .GetMediaBox ();if _aae !=nil {return nil ,_aae ;};if _cfe .Llx !=0||_cfe .Lly !=0{_bga .translate (-_cfe .Llx ,_cfe .Lly );
};_bga ._bab =_cfe .Urx -_cfe .Llx ;_bga ._egb =_cfe .Ury -_cfe .Lly ;if page .Rotate !=nil {_bga ._gc =-float64 (*page .Rotate );};return _bga ,nil ;};func _eca (_bgbf *Chapter ,_dgcae *TOC ,_gdaf *_fee .Outline ,_ddbb string ,_fgca int ,_cag TextStyle )*Chapter {var _cfgd uint =1;
if _bgbf !=nil {_cfgd =_bgbf ._gfacd +1;};_adce :=&Chapter {_feba :_fgca ,_cdb :_ddbb ,_dadd :true ,_bge :true ,_deea :_bgbf ,_ede :_dgcae ,_ecga :_gdaf ,_cbf :[]Drawable {},_gfacd :_cfgd };_cbfa :=_beeg (_adce .headingText (),_cag );_cbfa .SetFont (_cag .Font );
_cbfa .SetFontSize (_cag .FontSize );_adce ._ddc =_cbfa ;return _adce ;};

// IsRelative checks if the positioning is relative.
func (_aaf Positioning )IsRelative ()bool {return _aaf ==PositionRelative };

// SetTitle sets the title of the invoice.
func (_eeadd *Invoice )SetTitle (title string ){_eeadd ._faea =title };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_efdd *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _efdd ._efbg .Left ,_efdd ._efbg .Right ,_efdd ._efbg .Top ,_efdd ._efbg .Bottom ;};func (_acdd *templateProcessor )parseFitModeAttr (_bggf ,_aeaaa string )FitMode {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_bggf ,_aeaaa );
_abded :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_aeaaa ];return _abded ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;
HorizontalAlignmentRight ;);

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_eccd *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_ddga :=NewTextChunk (text ,_eccd ._fecf );_ddga ._beebgd =_gabgca (page -1,x ,y ,zoom );return _eccd .appendChunk (_ddga );};

// SetEnableWrap sets the line wrapping enabled flag.
func (_ebff *Paragraph )SetEnableWrap (enableWrap bool ){_ebff ._ccee =enableWrap ;_ebff ._ecfa =false };func _eefb (_cbgaf ,_egcab ,_fgdg ,_fbfe float64 )*Rectangle {return &Rectangle {_cfbab :_cbgaf ,_cffbf :_egcab ,_bfddd :_fgdg ,_abfd :_fbfe ,_fgaa :PositionAbsolute ,_ffdfg :1.0,_eggbc :ColorBlack ,_egde :1.0,_cgbf :1.0};
};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_fdcd *StyledParagraph )Height ()float64 {_fdcd .wrapText ();var _cabcg float64 ;for _ ,_ddeb :=range _fdcd ._cfcf {var _fdbc float64 ;for _ ,_gdfaf :=range _ddeb {_fgcbd :=_fdcd ._gbbd *_gdfaf .Style .FontSize ;if _fgcbd > _fdbc {_fdbc =_fgcbd ;
};};_cabcg +=_fdbc ;};return _cabcg ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_cfbacb *Table )NewCell ()*TableCell {return _cfbacb .MultiCell (1,1)};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aacb *Paragraph )SetTextAlignment (align TextAlignment ){_aacb ._afcfe =align };

// Scale scales the ellipse dimensions by the specified factors.
func (_cbcb *Ellipse )Scale (xFactor ,yFactor float64 ){_cbcb ._baeg =xFactor *_cbcb ._baeg ;_cbcb ._afaf =yFactor *_cbcb ._afaf ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_gfada *Creator )CreateTableOfContents (genTOCFunc func (_gacf *TOC )error ){_gfada ._cdfg =genTOCFunc ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_eebc *Paragraph )Height ()float64 {_eebc .wrapText ();return float64 (len (_eebc ._fcda ))*_eebc ._adgg *_eebc ._bgef ;};

// MoveY moves the drawing context to absolute position y.
func (_aceda *Creator )MoveY (y float64 ){_aceda ._ddd .Y =y };

// String implements error interface.
func (_fdba UnsupportedRuneError )Error ()string {return _fdba .Message };

// Height returns the height of the line.
func (_adbd *Line )Height ()float64 {_bece :=_adbd ._bdfc ;if _adbd ._bcgf ==_adbd ._ecec {_bece /=2;};return _fa .Abs (_adbd ._daac -_adbd ._fgba )+_bece ;};

// CurRow returns the currently active cell's row number.
func (_bedab *Table )CurRow ()int {_degage :=(_bedab ._gacbf -1)/_bedab ._fcfd +1;return _degage };

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_gfcde *Invoice )SetAddressHeadingStyle (style TextStyle ){_gfcde ._dbbf =style };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_dggg float64 ;_cea float64 ;_beg float64 ;_febag float64 ;_bda float64 ;_ccbc float64 ;_gabg Color ;_cgfc float64 ;};func (_bagcd *StyledParagraph )getMaxLineWidth ()float64 {if _bagcd ._cfcf ==nil ||len (_bagcd ._cfcf )==0{_bagcd .wrapText ();
};var _ggcfg float64 ;for _ ,_bbge :=range _bagcd ._cfcf {_acagd :=_bagcd .getTextLineWidth (_bbge );if _acagd > _ggcfg {_ggcfg =_acagd ;};};return _ggcfg ;};const (DefaultHorizontalScaling =100;);

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_aage *Creator )Draw (d Drawable )error {if _aage .getActivePage ()==nil {_aage .NewPage ();};_gcgc ,_affb ,_fgec :=d .GeneratePageBlocks (_aage ._ddd );if _fgec !=nil {return _fgec ;};if len (_affb ._ggce )> 0{_aage .Errors =append (_aage .Errors ,_affb ._ggce ...);
};for _bfdg ,_cabe :=range _gcgc {if _bfdg > 0{_aage .NewPage ();};_fgbe :=_aage .getActivePage ();if _gdfbc ,_efc :=_aage ._adcea [_fgbe ];_efc {if _ebda :=_gdfbc .mergeBlocks (_cabe );_ebda !=nil {return _ebda ;};if _dbaa :=_dee (_cabe ._gf ,_gdfbc ._gf );
_dbaa !=nil {return _dbaa ;};}else {_aage ._adcea [_fgbe ]=_cabe ;};};_aage ._ddd .X =_affb .X ;_aage ._ddd .Y =_affb .Y ;_aage ._ddd .Height =_affb .PageHeight -_affb .Y -_affb .Margins .Bottom ;return nil ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_dcd *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _acac (x1 ,y1 ,cx ,cy ,x2 ,y2 );};func _gccg (_ddbf *_fee .Image )(*Image ,error ){_afac :=float64 (_ddbf .Width );_ecdg :=float64 (_ddbf .Height );return &Image {_dgaec :_ddbf ,_bfdf :_afac ,_eaaa :_ecdg ,_edda :_afac ,_eega :_ecdg ,_dbbd :0,_edcd :1.0,_agagd :PositionRelative },nil ;
};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_eddfc *LinearShading )SetBackgroundColor (backgroundColor Color ){_eddfc ._adece .SetBackgroundColor (backgroundColor );};

// SellerAddress returns the seller address used in the invoice template.
func (_cfdc *Invoice )SellerAddress ()*InvoiceAddress {return _cfdc ._dfbd };func _ceaf (_bagg *Block ,_egfb *Image ,_debg DrawContext )(DrawContext ,error ){_bfebg :=_debg ;_gbff :=1;_gegb :=_dd .PdfObjectName (_fb .Sprintf ("\u0049\u006d\u0067%\u0064",_gbff ));
for _bagg ._gf .HasXObjectByName (_gegb ){_gbff ++;_gegb =_dd .PdfObjectName (_fb .Sprintf ("\u0049\u006d\u0067%\u0064",_gbff ));};_fddde :=_bagg ._gf .SetXObjectImageByName (_gegb ,_egfb ._aaae );if _fddde !=nil {return _debg ,_fddde ;};_degc :=0;_cbd :=_dd .PdfObjectName (_fb .Sprintf ("\u0047\u0053\u0025\u0064",_degc ));
for _bagg ._gf .HasExtGState (_cbd ){_degc ++;_cbd =_dd .PdfObjectName (_fb .Sprintf ("\u0047\u0053\u0025\u0064",_degc ));};_debaf :=_dd .MakeDict ();_debaf .Set ("\u0042\u004d",_dd .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _egfb ._edcd < 1.0{_debaf .Set ("\u0043\u0041",_dd .MakeFloat (_egfb ._edcd ));
_debaf .Set ("\u0063\u0061",_dd .MakeFloat (_egfb ._edcd ));};_fddde =_bagg ._gf .AddExtGState (_cbd ,_dd .MakeIndirectObject (_debaf ));if _fddde !=nil {return _debg ,_fddde ;};_dcfc :=_egfb .Width ();_bcdb :=_egfb .Height ();_ ,_cfcc :=_egfb .rotatedSize ();
_gbcg :=_debg .X ;_cdde :=_debg .PageHeight -_debg .Y -_bcdb ;if _egfb ._agagd .IsRelative (){_cdde -=(_cfcc -_bcdb )/2;switch _egfb ._eeef {case HorizontalAlignmentCenter :_gbcg +=(_debg .Width -_dcfc )/2;case HorizontalAlignmentRight :_gbcg =_debg .PageWidth -_debg .Margins .Right -_egfb ._dgb .Right -_dcfc ;
};};_dddg :=_egfb ._dbbd ;_gbec :=_ebc .NewContentCreator ();_gbec .Add_gs (_cbd );_gbec .Translate (_gbcg ,_cdde );if _dddg !=0{_gbec .Translate (_dcfc /2,_bcdb /2);_gbec .RotateDeg (_dddg );_gbec .Translate (-_dcfc /2,-_bcdb /2);};_gbec .Scale (_dcfc ,_bcdb ).Add_Do (_gegb );
_afcf :=_gbec .Operations ();_afcf .WrapIfNeeded ();_bagg .addContents (_afcf );if _egfb ._agagd .IsRelative (){_debg .Y +=_cfcc ;_debg .Height -=_cfcc ;return _debg ,nil ;};return _bfebg ,nil ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;
TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);

// SetSellerAddress sets the seller address of the invoice.
func (_beedcc *Invoice )SetSellerAddress (address *InvoiceAddress ){_beedcc ._dfbd =address };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_addb *LinearShading )AddPatternResource (block *Block )(_cfcce _dd .PdfObjectName ,_adae error ){_ffbb :=1;_gdgge :=_dd .PdfObjectName ("\u0050"+_fe .Itoa (_ffbb ));for block ._gf .HasPatternByName (_gdgge ){_ffbb ++;_gdgge =_dd .PdfObjectName ("\u0050"+_fe .Itoa (_ffbb ));
};if _deeaa :=block ._gf .SetPatternByName (_gdgge ,_addb .ToPdfShadingPattern ().ToPdfObject ());_deeaa !=nil {return "",_deeaa ;};return _gdgge ,nil ;};func _bcgdb (_ggca string ,_cefe bool )string {_eacc :=_ggca ;if _eacc ==""{return "";};_gfca :=_aa .Paragraph {};
_ ,_dafdg :=_gfca .SetString (_ggca );if _dafdg !=nil {return _eacc ;};_cccgc ,_dafdg :=_gfca .Order ();if _dafdg !=nil {return _eacc ;};_bbffe :=_cccgc .NumRuns ();_dgaag :=make ([]string ,_bbffe );for _bgccg :=0;_bgccg < _cccgc .NumRuns ();_bgccg ++{_abgaf :=_cccgc .Run (_bgccg );
_cgfba :=_abgaf .String ();if _abgaf .Direction ()==_aa .RightToLeft {_cgfba =_aa .ReverseString (_cgfba );};if _cefe {_dgaag [_bgccg ]=_cgfba ;}else {_dgaag [_bbffe -1]=_cgfba ;};_bbffe --;};if len (_dgaag )!=_cccgc .NumRuns (){return _ggca ;};_eacc =_cf .Join (_dgaag ,"");
return _eacc ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_fbg *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ee :=_ebc .NewContentCreator ();_bad ,_eba :=_fbg .Width (),_fbg .Height ();if _fbg ._eg .IsRelative (){_ee .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_eba );}else {_ee .Translate (_fbg ._ba ,ctx .PageHeight -_fbg ._cd -_eba );
};_aaa :=_eba ;if _fbg ._gc !=0{_ee .Translate (_bad /2,_eba /2);_ee .RotateDeg (_fbg ._gc );_ee .Translate (-_bad /2,-_eba /2);_ ,_aaa =_fbg .RotatedSize ();};if _fbg ._eg .IsRelative (){ctx .Y +=_aaa ;};_ca :=_fbg .duplicate ();_bbb :=append (*_ee .Operations (),*_ca ._db ...);
_bbb .WrapIfNeeded ();_ca ._db =&_bbb ;return []*Block {_ca },ctx ,nil ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_bag *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_bag ._fbed .Left =left ;_bag ._fbed .Right =right ;_bag ._fbed .Top =top ;_bag ._fbed .Bottom =bottom ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_daba *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_eadb :=range subtable ._afbaa {_beefe :=&TableCell {};*_beefe =*_eadb ;_beefe ._fagfd =_daba ;_beefe ._faga +=col -1;if _eefcea :=_daba ._fcfd -(_beefe ._faga -1);_eefcea < _beefe ._cdefg {_daba ._fcfd +=_beefe ._cdefg -_eefcea ;
_daba .resetColumnWidths ();_da .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_daba ._fcfd );
};_beefe ._eeadc +=row -1;_fccad :=subtable ._agda [_eadb ._eeadc -1];if _beefe ._eeadc > _daba ._edde {for _beefe ._eeadc > _daba ._edde {_daba ._edde ++;_daba ._agda =append (_daba ._agda ,_daba ._gbbe );};_daba ._agda [_beefe ._eeadc -1]=_fccad ;}else {_daba ._agda [_beefe ._eeadc -1]=_fa .Max (_daba ._agda [_beefe ._eeadc -1],_fccad );
};_daba ._afbaa =append (_daba ._afbaa ,_beefe );};_b .Slice (_daba ._afbaa ,func (_fcbc ,_dbcaa int )bool {_eece :=_daba ._afbaa [_fcbc ]._eeadc ;_fcad :=_daba ._afbaa [_dbcaa ]._eeadc ;if _eece < _fcad {return true ;};if _eece > _fcad {return false ;
};return _daba ._afbaa [_fcbc ]._faga < _daba ._afbaa [_dbcaa ]._faga ;});};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_agbgb *Rectangle )SetCoords (x ,y float64 ){_agbgb ._cfbab =x ;_agbgb ._cffbf =y };

// SetBorderColor sets the border color for the path.
func (_dfec *FilledCurve )SetBorderColor (color Color ){_dfec ._afdae =color };

// SetTitleStyle sets the style properties of the invoice title.
func (_fdaf *Invoice )SetTitleStyle (style TextStyle ){_fdaf ._effe =style };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_gcfe *Paragraph )SetWidth (width float64 ){_gcfe ._bgdg =width ;_gcfe .wrapText ()};func _beeg (_gafaa string ,_fbbb TextStyle )*Paragraph {_cffb :=&Paragraph {_fagf :_gafaa ,_gbdaa :_fbbb .Font ,_bgef :_fbbb .FontSize ,_adgg :1.0,_ccee :true ,_ecfa :true ,_afcfe :TextAlignmentLeft ,_abgcb :0,_fbaa :1,_egag :1,_fgecf :PositionRelative };
_cffb .SetColor (_fbbb .Color );return _cffb ;};

// SetAngle sets the rotation angle of the text.
func (_ceaa *StyledParagraph )SetAngle (angle float64 ){_ceaa ._bbfc =angle };func (_bgd *InvoiceAddress )fmtLine (_ccaa ,_eac string ,_gadf bool )string {if _gadf {_eac ="";};return _fb .Sprintf ("\u0025\u0073\u0025s\u000a",_eac ,_ccaa );};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_cdbe *Division )SetPadding (left ,right ,top ,bottom float64 ){_cdbe ._deca .Left =left ;_cdbe ._deca .Right =right ;_cdbe ._deca .Top =top ;_cdbe ._deca .Bottom =bottom ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ef .ChartRenderable )*Chart {return _agae (chart )};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_cecgd *FilledCurve )draw (_ggfd *Block ,_cddg string )([]byte ,*_fee .PdfRectangle ,error ){_fbd :=_bg .NewCubicBezierPath ();for _ ,_ceeeb :=range _cecgd ._ddfce {_fbd =_fbd .AppendCurve (_ceeeb );
};creator :=_ebc .NewContentCreator ();creator .Add_q ();if _cecgd .FillEnabled &&_cecgd ._efgf !=nil {_ccbe :=_cfd (_cecgd ._efgf );_aeca :=_aacgba (_ggfd ,_ccbe ,_cecgd ._efgf ,func ()Rectangle {_geg :=_bg .NewCubicBezierPath ();for _ ,_bgce :=range _cecgd ._ddfce {_geg =_geg .AppendCurve (_bgce );
};_ageb :=_geg .GetBoundingBox ();if _cecgd .BorderEnabled {_ageb .Height +=_cecgd .BorderWidth ;_ageb .Width +=_cecgd .BorderWidth ;_ageb .X -=_cecgd .BorderWidth /2;_ageb .Y -=_cecgd .BorderWidth /2;};return Rectangle {_cfbab :_ageb .X ,_cffbf :_ageb .Y ,_bfddd :_ageb .Width ,_abfd :_ageb .Height };
});if _aeca !=nil {return nil ,nil ,_aeca ;};creator .SetNonStrokingColor (_ccbe );};if _cecgd .BorderEnabled {if _cecgd ._afdae !=nil {creator .SetStrokingColor (_cfd (_cecgd ._afdae ));};creator .Add_w (_cecgd .BorderWidth );};if len (_cddg )> 1{creator .Add_gs (_dd .PdfObjectName (_cddg ));
};_bg .DrawBezierPathWithCreator (_fbd ,creator );creator .Add_h ();if _cecgd .FillEnabled &&_cecgd .BorderEnabled {creator .Add_B ();}else if _cecgd .FillEnabled {creator .Add_f ();}else if _cecgd .BorderEnabled {creator .Add_S ();};creator .Add_Q ();
_cgeb :=_fbd .GetBoundingBox ();if _cecgd .BorderEnabled {_cgeb .Height +=_cecgd .BorderWidth ;_cgeb .Width +=_cecgd .BorderWidth ;_cgeb .X -=_cecgd .BorderWidth /2;_cgeb .Y -=_cecgd .BorderWidth /2;};_daga :=&_fee .PdfRectangle {};_daga .Llx =_cgeb .X ;
_daga .Lly =_cgeb .Y ;_daga .Urx =_cgeb .X +_cgeb .Width ;_daga .Ury =_cgeb .Y +_cgeb .Height ;return creator .Bytes (),_daga ,nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_aefe *List )Indent ()float64 {return _aefe ._cfffc };func (_fecda *templateProcessor )parseList (_afbab *templateNode )(interface{},error ){_gdegg :=_fecda .creator .NewList ();for _ ,_dgbf :=range _afbab ._bdbga .Attr {_daed :=_dgbf .Value ;switch _gcgd :=_dgbf .Name .Local ;
_gcgd {case "\u0069\u006e\u0064\u0065\u006e\u0074":_gdegg .SetIndent (_fecda .parseFloatAttr (_gcgd ,_daed ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dcccd :=_fecda .parseMarginAttr (_gcgd ,_daed );_gdegg .SetMargins (_dcccd .Left ,_dcccd .Right ,_dcccd .Top ,_dcccd .Bottom );
default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gcgd );
};};return _gdegg ,nil ;};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_dec *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _acea (xc ,yc ,width ,height );};

// NewDivision returns a new Division container component.
func (_aaef *Creator )NewDivision ()*Division {return _fgee ()};func (_acdg *templateProcessor )parseFloatAttr (_dgdag ,_cgaed string )float64 {_da .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_dgdag ,_cgaed );
_bacb ,_ :=_fe .ParseFloat (_cgaed ,64);return _bacb ;};func (_cccb *templateProcessor )parseListItem (_fbbag *templateNode )(interface{},error ){if _fbbag ._bdgb ==nil {_da .Log .Error ("\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_cedeg ;};_bffc ,_dece :=_fbbag ._bdgb ._bdced .(*List );if !_dece {_da .Log .Error ("\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_cedeg ;};_cfffb :=_fagg ();_cfffb ._aeaf =_bffc ._dabcb ;return _cfffb ,nil ;};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;
TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// CurCol returns the currently active cell's column number.
func (_cdfad *Table )CurCol ()int {_fadgb :=(_cdfad ._gacbf -1)%(_cdfad ._fcfd )+1;return _fadgb };func (_cgba *StyledParagraph )getTextHeight ()float64 {var _cgca float64 ;for _ ,_bdce :=range _cgba ._adeb {_gaddc :=_bdce .Style .FontSize *_cgba ._gbbd ;
if _gaddc > _cgca {_cgca =_gaddc ;};};return _cgca ;};func _dccc (_ccec TextStyle )*StyledParagraph {return &StyledParagraph {_adeb :[]*TextChunk {},_cefc :_ccec ,_fecf :_geed (_ccec .Font ),_gbbd :1.0,_fdge :TextAlignmentLeft ,_egge :true ,_cbbga :true ,_dffeg :false ,_bbfc :0,_cega :1,_gdcf :1,_eege :PositionRelative };
};

// SetFillColor sets the fill color for the path.
func (_fae *FilledCurve )SetFillColor (color Color ){_fae ._efgf =color };func (_bbbbf *StyledParagraph )getLineMetrics (_beeae int )(_gfbda ,_bgag ,_ffegcc float64 ){if _bbbbf ._cfcf ==nil ||len (_bbbbf ._cfcf )==0{_bbbbf .wrapText ();};if _beeae < 0||_beeae > len (_bbbbf ._cfcf )-1{_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_beeae );
return 0,0,0;};_cffcc :=_bbbbf ._cfcf [_beeae ];for _ ,_fdgbe :=range _cffcc {_aaea :=_eccgb (_fdgbe .Style .Font ,_fdgbe .Style .FontSize );if _aaea ._fdae > _gfbda {_gfbda =_aaea ._fdae ;};if _aaea ._ebggb < _ffegcc {_ffegcc =_aaea ._ebggb ;};if _fgdce :=_fdgbe .Style .FontSize ;
_fgdce > _bgag {_bgag =_fgdce ;};};return _gfbda ,_bgag ,_ffegcc ;};func (_cdge *templateProcessor )loadImageFromSrc (_dgeebab string )(*Image ,error ){if _dgeebab ==""{_da .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_gaeg ;};_beff :=_cf .Split (_dgeebab ,"\u002c");for _ ,_bedac :=range _beff {_bedac =_cf .TrimSpace (_bedac );if _bedac ==""{continue ;};_efea ,_gdfga :=_cdge ._deag .ImageMap [_bedac ];if _gdfga {return _gccg (_efea );};if _debf :=_cdge .parseAttrPropList (_bedac );
len (_debf )> 0{if _acgcfg ,_fabef :=_debf ["\u0070\u0061\u0074\u0068"];_fabef {if _adggcd ,_fcbde :=_edae (_acgcfg );_fcbde !=nil {_da .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_acgcfg ,_fcbde );
}else {return _adggcd ,nil ;};};};};_da .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_dgeebab );return nil ,_gaeg ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_ffb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _bege (number ,title ,page ,level ,style );};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_ggdb *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ggdb ._dadde .Left ,_ggdb ._dadde .Right ,_ggdb ._dadde .Top ,_ggdb ._dadde .Bottom ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_feea *Creator )DrawFooter (drawFooterFunc func (_fdgb *Block ,_cfdff FooterFunctionArgs )){_feea ._fdf =drawFooterFunc ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_dbcg *Line )SetColor (color Color ){_dbcg ._bec =color };

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_caad *Ellipse )GetCoords ()(float64 ,float64 ){return _caad ._gbd ,_caad ._efd };func (_ebffc *templateProcessor )parseStyledParagraph (_gfde *templateNode )(interface{},error ){_fafag :=_ebffc .creator .NewStyledParagraph ();for _ ,_feadc :=range _gfde ._bdbga .Attr {_adaga :=_feadc .Value ;
switch _gfbg :=_feadc .Name .Local ;_gfbg {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_fafag .SetTextAlignment (_ebffc .parseTextAlignmentAttr (_gfbg ,_adaga ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_fafag .SetTextVerticalAlignment (_ebffc .parseTextVerticalAlignmentAttr (_gfbg ,_adaga ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_fafag .SetLineHeight (_ebffc .parseFloatAttr (_gfbg ,_adaga ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_agade :=_ebffc .parseMarginAttr (_gfbg ,_adaga );_fafag .SetMargins (_agade .Left ,_agade .Right ,_agade .Top ,_agade .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_fafag .SetEnableWrap (_ebffc .parseBoolAttr (_gfbg ,_adaga ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_fafag .EnableWordWrap (_ebffc .parseBoolAttr (_gfbg ,_adaga ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_fafag .SetTextOverflow (_ebffc .parseTextOverflowAttr (_gfbg ,_adaga ));case "\u0078":_fafag .SetPos (_ebffc .parseFloatAttr (_gfbg ,_adaga ),_fafag ._gaba );case "\u0079":_fafag .SetPos (_fafag ._fggg ,_ebffc .parseFloatAttr (_gfbg ,_adaga ));
case "\u0061\u006e\u0067l\u0065":_fafag .SetAngle (_ebffc .parseFloatAttr (_gfbg ,_adaga ));default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0073\u0074\u0079l\u0065\u0064 \u0070\u0061\u0072\u0061\u0067\u0072a\u0070h \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gfbg );
};};return _fafag ,nil ;};func _cfd (_cdcg Color )_fee .PdfColor {if _cdcg ==nil {_cdcg =ColorBlack ;};switch _gdeb :=_cdcg .(type ){case cmykColor :return _fee .NewPdfColorDeviceCMYK (_gdeb ._bcc ,_gdeb ._gdg ,_gdeb ._fbba ,_gdeb ._dgdaf );case *LinearShading :return _fee .NewPdfColorPatternType2 ();
case *RadialShading :return _fee .NewPdfColorPatternType3 ();};return _fee .NewPdfColorDeviceRGB (_cdcg .ToRGB ());};func _fcff (_gcefd *_fee .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_gcefd ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func (_ddecb *Division )split (_eaaf DrawContext )(_egecf ,_bgca *Division ){var (_agca float64 ;_dgfc ,_dfef []VectorDrawable ;);_faaa :=_eaaf .Width -_ddecb ._ceeba .Left -_ddecb ._ceeba .Right -_ddecb ._deca .Left -_ddecb ._deca .Right ;for _dbac ,_dfgc :=range _ddecb ._aegg {_agca +=_gfedb (_dfgc ,_faaa );
if _agca < _eaaf .Height {_dgfc =append (_dgfc ,_dfgc );}else {_dfef =_ddecb ._aegg [_dbac :];break ;};};if len (_dgfc )> 0{_egecf =_fgee ();*_egecf =*_ddecb ;_egecf ._aegg =_dgfc ;if _ddecb ._dgce !=nil {_egecf ._dgce =&Background {};*_egecf ._dgce =*_ddecb ._dgce ;
};};if len (_dfef )> 0{_bgca =_fgee ();*_bgca =*_ddecb ;_bgca ._aegg =_dfef ;if _ddecb ._dgce !=nil {_bgca ._dgce =&Background {};*_bgca ._dgce =*_ddecb ._dgce ;};};return _egecf ,_bgca ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_fbcb *Chapter )NewSubchapter (title string )*Chapter {_dabc :=_fcff (_fbcb ._ddc ._gbdaa );_dabc .FontSize =14;_fbcb ._aff ++;_bdf :=_eca (_fbcb ,_fbcb ._ede ,_fbcb ._ecga ,title ,_fbcb ._aff ,_dabc );_fbcb .Add (_bdf );return _bdf ;};

// BorderWidth returns the border width of the ellipse.
func (_agbg *Ellipse )BorderWidth ()float64 {return _agbg ._bedef };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_eff *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_eff ._bbdf .Left =left ;_eff ._bbdf .Right =right ;_eff ._bbdf .Top =top ;_eff ._bbdf .Bottom =bottom ;};

// SetBorderOpacity sets the border opacity.
func (_addc *CurvePolygon )SetBorderOpacity (opacity float64 ){_addc ._efeb =opacity };

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_cfcff *Table )EnablePageWrap (enable bool ){_cfcff ._edcc =enable };

// SetIndent sets the left offset of the list when nested into another list.
func (_adfbc *List )SetIndent (indent float64 ){_adfbc ._cfffc =indent ;_adfbc ._ggeg =false };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aaed *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fbdg float64 ;var _eabc []*StyledParagraph ;for _ ,_cafd :=range _aaed ._fegg {_ccgca :=_dccc (_aaed ._bdbe );_ccgca .SetEnableWrap (false );_ccgca .SetTextAlignment (TextAlignmentRight );
_ccgca .Append (_cafd ._aeaf .Text ).Style =_cafd ._aeaf .Style ;_abeg :=_ccgca .getTextWidth ()/1000.0/ctx .Width ;if _fbdg < _abeg {_fbdg =_abeg ;};_eabc =append (_eabc ,_ccgca );};_egac :=_agegf (2);_egac .SetColumnWidths (_fbdg ,1-_fbdg );_egac .SetMargins (_aaed ._bffg .Left +_aaed ._cfffc ,_aaed ._bffg .Right ,_aaed ._bffg .Top ,_aaed ._bffg .Bottom );
_egac .EnableRowWrap (true );for _bbaf ,_cdaf :=range _aaed ._fegg {_fedf :=_egac .NewCell ();_fedf .SetIndent (0);_fedf .SetContent (_eabc [_bbaf ]);_fedf =_egac .NewCell ();_fedf .SetIndent (0);_fedf .SetContent (_cdaf ._eaca );};return _egac .GeneratePageBlocks (ctx );
};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_ffcg *Invoice )SetNoteHeadingStyle (style TextStyle ){_ffcg ._fadg =style };

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_aaeg *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _eefb (x ,y ,width ,height );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bccge *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faacbc :=ctx ;_cbbdc ,ctx ,_aacde :=_bccge ._bfaa .GeneratePageBlocks (ctx );if _aacde !=nil {return _cbbdc ,ctx ,_aacde ;};for _ ,_adggg :=range _bccge ._bbfe {_dgabb :=_adggg ._edbf ;
if !_bccge ._ffag {_adggg ._edbf =0;};_cgddb ,_cbgec ,_ggef :=_adggg .GeneratePageBlocks (ctx );_adggg ._edbf =_dgabb ;if _ggef !=nil {return _cbbdc ,ctx ,_ggef ;};if len (_cgddb )< 1{continue ;};_cbbdc [len (_cbbdc )-1].mergeBlocks (_cgddb [0]);_cbbdc =append (_cbbdc ,_cgddb [1:]...);
ctx =_cbgec ;};if _bccge ._eebf .IsRelative (){ctx .X =_faacbc .X ;};if _bccge ._eebf .IsAbsolute (){return _cbbdc ,_faacbc ,nil ;};return _cbbdc ,ctx ,nil ;};func (_ecbcg *Table )moveToNextAvailableCell ()int {_gcfc :=(_ecbcg ._gacbf -1)%(_ecbcg ._fcfd )+1;
for {if _gcfc -1>=len (_ecbcg ._gbdga ){if _ecbcg ._gbdga [0]==0{return _gcfc ;};_gcfc =1;}else if _ecbcg ._gbdga [_gcfc -1]==0{return _gcfc ;};_ecbcg ._gacbf ++;_ecbcg ._gbdga [_gcfc -1]--;_gcfc ++;};};func (_dfgdd *templateProcessor )parseTable (_adaf *templateNode )(interface{},error ){var _eefgb int64 ;
for _ ,_dagbg :=range _adaf ._bdbga .Attr {_ecbe :=_dagbg .Value ;switch _gcdce :=_dagbg .Name .Local ;_gcdce {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_eefgb =_dfgdd .parseInt64Attr (_gcdce ,_ecbe );};};if _eefgb <=0{_da .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_eefgb );
_eefgb =1;};_dacac :=_dfgdd .creator .NewTable (int (_eefgb ));for _ ,_dcff :=range _adaf ._bdbga .Attr {_afbf :=_dcff .Value ;switch _gddb :=_dcff .Name .Local ;_gddb {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_dacac .SetColumnWidths (_dfgdd .parseFloatArray (_gddb ,_afbf )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_cbafg :=_dfgdd .parseMarginAttr (_gddb ,_afbf );_dacac .SetMargins (_cbafg .Left ,_cbafg .Right ,_cbafg .Top ,_cbafg .Bottom );case "\u0078":_dacac .SetPos (_dfgdd .parseFloatAttr (_gddb ,_afbf ),_dacac ._fedc );
case "\u0079":_dacac .SetPos (_dacac ._bccdf ,_dfgdd .parseFloatAttr (_gddb ,_afbf ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_dacac ._cfcgb =int (_dfgdd .parseInt64Attr (_gddb ,_afbf ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_dacac ._bgda =int (_dfgdd .parseInt64Attr (_gddb ,_afbf ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_dacac .EnableRowWrap (_dfgdd .parseBoolAttr (_gddb ,_afbf ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_dacac .EnablePageWrap (_dfgdd .parseBoolAttr (_gddb ,_afbf ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_da .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_gddb );
};};if _dacac ._cfcgb !=0&&_dacac ._bgda !=0{_eaec :=_dacac .SetHeaderRows (_dacac ._cfcgb ,_dacac ._bgda );if _eaec !=nil {_da .Log .Debug ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_eaec );
};}else {_dacac ._cfcgb =0;_dacac ._bgda =0;};return _dacac ,nil ;};func _gfedb (_cdaa VectorDrawable ,_aacgb float64 )float64 {switch _gdc :=_cdaa .(type ){case *Paragraph :if _gdc ._ccee {_gdc .SetWidth (_aacgb -_gdc ._efbg .Left -_gdc ._efbg .Right );
};return _gdc .Height ()+_gdc ._efbg .Top +_gdc ._efbg .Bottom ;case *StyledParagraph :if _gdc ._egge {_gdc .SetWidth (_aacgb -_gdc ._eebag .Left -_gdc ._eebag .Right );};return _gdc .Height ()+_gdc ._eebag .Top +_gdc ._eebag .Bottom ;case *Image :_gdc .applyFitMode (_aacgb );
return _gdc .Height ()+_gdc ._dgb .Top +_gdc ._dgb .Bottom ;case *Rectangle :_gdc .applyFitMode (_aacgb );return _gdc .Height ()+_gdc ._gcag .Top +_gdc ._gcag .Bottom +_gdc ._egde ;case *Ellipse :_gdc .applyFitMode (_aacgb );return _gdc .Height ()+_gdc ._fbed .Top +_gdc ._fbed .Bottom ;
case *Division :return _gdc .ctxHeight (_aacgb )+_gdc ._ceeba .Top +_gdc ._ceeba .Bottom +_gdc ._deca .Top +_gdc ._deca .Bottom ;case *Table :_gdc .updateRowHeights (_aacgb -_gdc ._dceg .Left -_gdc ._dceg .Right );return _gdc .Height ()+_gdc ._dceg .Top +_gdc ._dceg .Bottom ;
case *List :return _gdc .ctxHeight (_aacgb )+_gdc ._bffg .Top +_gdc ._bffg .Bottom ;case marginDrawable :_ ,_ ,_dffe ,_agdg :=_gdc .GetMargins ();return _gdc .Height ()+_dffe +_agdg ;default:return _gdc .Height ();};};

// Positioning returns the type of positioning the line is set to use.
func (_fddb *Line )Positioning ()Positioning {return _fddb ._aede };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_geeb *Invoice )AddressHeadingStyle ()TextStyle {return _geeb ._dbge };func _fagg ()*listItem {return &listItem {}};func (_ebbe *StyledParagraph )getTextWidth ()float64 {var _fgea float64 ;_gdcdc :=len (_ebbe ._adeb );for _edff ,_ebga :=range _ebbe ._adeb {_dgecg :=&_ebga .Style ;
_becc :=len (_ebga .Text );for _gfda ,_fgeb :=range _ebga .Text {if _fgeb =='\u000A'{continue ;};_cgbc ,_cdag :=_dgecg .Font .GetRuneMetrics (_fgeb );if !_cdag {_da .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fgeb );
return -1;};_fgea +=_dgecg .FontSize *_cgbc .Wx *_dgecg .horizontalScale ();if _fgeb !=' '&&(_edff !=_gdcdc -1||_gfda !=_becc -1){_fgea +=_dgecg .CharSpacing *1000.0;};};};return _fgea ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_bcfe *LinearShading )ToPdfShadingPattern ()*_fee .PdfShadingPatternType2 {_bgga ,_ggff ,_baea :=_bcfe ._adece ._bbcfd .ToRGB ();_ccaad :=_bcfe .shadingModel ();_ccaad .PdfShading .Background =_dd .MakeArrayFromFloats ([]float64 {_bgga ,_ggff ,_baea });
_bbee :=_fee .NewPdfShadingPatternType2 ();_bbee .Shading =_ccaad ;return _bbee ;};var _bee =_ae .MustCompile ("\u005c\u0064\u002b");

// Width returns the width of the specified text chunk.
func (_aged *TextChunk )Width ()float64 {var (_geabc float64 ;_dabca =_aged .Style ;);for _ ,_aagfe :=range _aged .Text {_affea ,_eaecg :=_dabca .Font .GetRuneMetrics (_aagfe );if !_eaecg {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_aagfe ,_aagfe ,_dabca .Font .BaseFont (),_dabca .Font .Subtype ());
_da .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_dabca .Font );_da .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_dabca .Font .Encoder ());};_dgdefc :=_dabca .FontSize *_affea .Wx ;_eded :=_dgdefc ;if _aagfe !=' '{_eded =_dgdefc +_dabca .CharSpacing *1000.0;
};_geabc +=_eded ;};return _geabc /1000.0;};

// GetCoords returns coordinates of border.
func (_gcga *border )GetCoords ()(float64 ,float64 ){return _gcga ._bgg ,_gcga ._ebg };

// SetBackgroundColor sets the cell's background color.
func (_ebaea *TableCell )SetBackgroundColor (col Color ){_ebaea ._cafg =col };func (_fdd *Creator )newPage ()*_fee .PdfPage {_cgg :=_fee .NewPdfPage ();_fdfa :=_fdd ._gee [0];_dfca :=_fdd ._gee [1];_aacg :=_fee .PdfRectangle {Llx :0,Lly :0,Urx :_fdfa ,Ury :_dfca };
_cgg .MediaBox =&_aacg ;_fdd ._aef =_fdfa ;_fdd ._cec =_dfca ;_fdd .initContext ();return _cgg ;};func (_be *Block )setOpacity (_bf float64 ,_bd float64 )(string ,error ){if (_bf < 0||_bf >=1.0)&&(_bd < 0||_bd >=1.0){return "",nil ;};_dg :=0;_de :=_fb .Sprintf ("\u0047\u0053\u0025\u0064",_dg );
for _be ._gf .HasExtGState (_dd .PdfObjectName (_de )){_dg ++;_de =_fb .Sprintf ("\u0047\u0053\u0025\u0064",_dg );};_aac :=_dd .MakeDict ();if _bf >=0&&_bf < 1.0{_aac .Set ("\u0063\u0061",_dd .MakeFloat (_bf ));};if _bd >=0&&_bd < 1.0{_aac .Set ("\u0043\u0041",_dd .MakeFloat (_bd ));
};_bgc :=_be ._gf .AddExtGState (_dd .PdfObjectName (_de ),_aac );if _bgc !=nil {return "",_bgc ;};return _de ,nil ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_dbdef *Line )SetMargins (left ,right ,top ,bottom float64 ){_dbdef ._cfdcg .Left =left ;_dbdef ._cfdcg .Right =right ;_dbdef ._cfdcg .Top =top ;_dbdef ._cfdcg .Bottom =bottom ;};func (_feef *Invoice )generateLineBlocks (_eebec DrawContext )([]*Block ,DrawContext ,error ){_fgfa :=_agegf (len (_feef ._eaafb ));
_fgfa .SetMargins (0,0,25,0);for _ ,_gddg :=range _feef ._eaafb {_gafa :=_dccc (_gddg .TextStyle );_gafa .SetMargins (0,0,1,0);_gafa .Append (_gddg .Value );_gbda :=_fgfa .NewCell ();_gbda .SetHorizontalAlignment (_gddg .Alignment );_gbda .SetBackgroundColor (_gddg .BackgroundColor );
_feef .setCellBorder (_gbda ,_gddg );_gbda .SetContent (_gafa );};for _ ,_fafc :=range _feef ._ccbed {for _ ,_dgfg :=range _fafc {_aaca :=_dccc (_dgfg .TextStyle );_aaca .SetMargins (0,0,3,2);_aaca .Append (_dgfg .Value );_ggdc :=_fgfa .NewCell ();_ggdc .SetHorizontalAlignment (_dgfg .Alignment );
_ggdc .SetBackgroundColor (_dgfg .BackgroundColor );_feef .setCellBorder (_ggdc ,_dgfg );_ggdc .SetContent (_aaca );};};return _fgfa .GeneratePageBlocks (_eebec );};

// Vertical returns total vertical (top + bottom) margin.
func (_aada *Margins )Vertical ()float64 {return _aada .Bottom +_aada .Top };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_dddfg *StyledParagraph )SetWidth (width float64 ){_dddfg ._cdba =width ;_dddfg .wrapText ()};func (_ebae *Invoice )drawInformation ()*Table {_acgb :=_agegf (2);_eceg :=append ([][2]*InvoiceCell {_ebae ._agebg ,_ebae ._gfbd ,_ebae ._edgf },_ebae ._dbbdg ...);
for _ ,_dfbg :=range _eceg {_dbacg ,_fgbdd :=_dfbg [0],_dfbg [1];if _fgbdd .Value ==""{continue ;};_fdde :=_acgb .NewCell ();_fdde .SetBackgroundColor (_dbacg .BackgroundColor );_ebae .setCellBorder (_fdde ,_dbacg );_ecaf :=_dccc (_dbacg .TextStyle );_ecaf .Append (_dbacg .Value );
_ecaf .SetMargins (0,0,2,1);_fdde .SetContent (_ecaf );_fdde =_acgb .NewCell ();_fdde .SetBackgroundColor (_fgbdd .BackgroundColor );_ebae .setCellBorder (_fdde ,_fgbdd );_ecaf =_dccc (_fgbdd .TextStyle );_ecaf .Append (_fgbdd .Value );_ecaf .SetMargins (0,0,2,1);
_fdde .SetContent (_ecaf );};return _acgb ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// NewFilledCurve returns a instance of filled curve.
func (_ebdg *Creator )NewFilledCurve ()*FilledCurve {return _cdbf ()};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_afae *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _afae ._abb [0],_afae ._abb [1]};

// Height returns the height of the ellipse.
func (_fcfb *Ellipse )Height ()float64 {return _fcfb ._afaf };

// SetDate sets the date of the invoice.
func (_fdce *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_fdce ._gfbd [1].Value =date ;return _fdce ._gfbd [0],_fdce ._gfbd [1];};

// NewCell returns a new invoice table cell.
func (_adccb *Invoice )NewCell (value string )*InvoiceCell {return _adccb .newCell (value ,_adccb .NewCellProps ());};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_cafg Color ;_gaeaa _bg .LineStyle ;_fgfda CellBorderStyle ;_gefeb Color ;_bcdfe float64 ;_gefeba CellBorderStyle ;_fcgg Color ;_fabe float64 ;_egea CellBorderStyle ;_fgdgg Color ;_bdga float64 ;_acdfc CellBorderStyle ;_gcac Color ;
_cbcbcg float64 ;_eeadc ,_faga int ;_dbbfc int ;_cdefg int ;_cfdd VectorDrawable ;_cdfcd CellHorizontalAlignment ;_egfeb CellVerticalAlignment ;_bdff float64 ;_fagfd *Table ;};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// SetBorderColor sets the border color.
func (_aebg *Polygon )SetBorderColor (color Color ){_aebg ._ebdcd .BorderColor =_cfd (color )};

// SetFillOpacity sets the fill opacity.
func (_afcca *Polygon )SetFillOpacity (opacity float64 ){_afcca ._aacf =opacity };

// Positioning returns the type of positioning the ellipse is set to use.
func (_ecae *Ellipse )Positioning ()Positioning {return _ecae ._bbgc };

// NewImageFromFile creates an Image from a file.
func (_dff *Creator )NewImageFromFile (path string )(*Image ,error ){return _edae (path )};func _eeg (_afd string ,_ecc _dd .PdfObject ,_ddf *_fee .PdfPageResources )_dd .PdfObjectName {_dbedg :=_cf .TrimRightFunc (_cf .TrimSpace (_afd ),func (_dccf rune )bool {return _eb .IsNumber (_dccf )});
if _dbedg ==""{_dbedg ="\u0046\u006f\u006e\u0074";};_eaf :=0;_eae :=_dd .PdfObjectName (_afd );for {_bac ,_bba :=_ddf .GetFontByName (_eae );if !_bba ||_bac ==_ecc {break ;};_eaf ++;_eae =_dd .PdfObjectName (_fb .Sprintf ("\u0025\u0073\u0025\u0064",_dbedg ,_eaf ));
};return _eae ;};

// FitMode returns the fit mode of the image.
func (_dagb *Image )FitMode ()FitMode {return _dagb ._eged };

// Width returns the width of the graphic svg.
func (_ddca *GraphicSVG )Width ()float64 {return _ddca ._cfff .Width };

// SetFillOpacity sets the fill opacity of the ellipse.
func (_dabe *Ellipse )SetFillOpacity (opacity float64 ){_dabe ._eeec =opacity };

// SetInline sets the inline mode of the division.
func (_dafe *Division )SetInline (inline bool ){_dafe ._agag =inline };func (_daf *Block )mergeBlocks (_bca *Block )error {_gef :=_gcg (_daf ._db ,_daf ._gf ,_bca ._db ,_bca ._gf );if _gef !=nil {return _gef ;};for _ ,_gg :=range _bca ._aee {_daf .AddAnnotation (_gg );
};return nil ;};func (_fdca *Invoice )generateNoteBlocks (_afgfa DrawContext )([]*Block ,DrawContext ,error ){_gggd :=_fgee ();_gaaf :=append ([][2]string {_fdca ._egdda ,_fdca ._bfda },_fdca ._eeda ...);for _ ,_fdfb :=range _gaaf {if _fdfb [1]!=""{_dccgb :=_fdca .drawSection (_fdfb [0],_fdfb [1]);
for _ ,_bcceb :=range _dccgb {_gggd .Add (_bcceb );};_ecea :=_dccc (_fdca ._gbecb );_ecea .SetMargins (0,0,10,0);_gggd .Add (_ecea );};};return _gggd .GeneratePageBlocks (_afgfa );};func _eccgb (_fgacg *_fee .PdfFont ,_cgcbc float64 )*fontMetrics {_ccagf :=&fontMetrics {};
if _fgacg ==nil {_da .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");return _ccagf ;};_adfba ,_beedg :=_fgacg .GetFontDescriptor ();if _beedg !=nil {_da .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_beedg );
return _ccagf ;};if _ccagf ._fdae ,_beedg =_adfba .GetCapHeight ();_beedg !=nil {_da .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_beedg );
};if int (_ccagf ._fdae )<=0{_da .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_ccagf ._fdae =1000;};_ccagf ._fdae *=_cgcbc /1000.0;if _ccagf ._ffedb ,_beedg =_adfba .GetXHeight ();_beedg !=nil {_da .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_beedg );
};_ccagf ._ffedb *=_cgcbc /1000.0;if _ccagf ._aaefg ,_beedg =_adfba .GetAscent ();_beedg !=nil {_da .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_beedg );
};_ccagf ._aaefg *=_cgcbc /1000.0;if _ccagf ._ebggb ,_beedg =_adfba .GetDescent ();_beedg !=nil {_da .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_beedg );
};_ccagf ._ebggb *=_cgcbc /1000.0;return _ccagf ;};func (_dgaga *templateProcessor )parseTextRenderingModeAttr (_fcggb ,_dabbg string )TextRenderingMode {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fcggb ,_dabbg );
_ffda :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_dabbg ];
return _ffda ;};

// SetStyleLeft sets border style for left side.
func (_gfed *border )SetStyleLeft (style CellBorderStyle ){_gfed ._ece =style };

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_cfec *GraphicSVG )ScaleToHeight (h float64 ){_fceae :=_cfec ._cfff .Width /_cfec ._cfff .Height ;_cfec ._cfff .Height =h ;_cfec ._cfff .Width =h *_fceae ;_cfec ._cfff .SetScaling (_fceae ,_fceae );};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_bcad *Invoice )Sections ()[][2]string {return _bcad ._eeda };func (_abee *Ellipse )applyFitMode (_ceee float64 ){_ceee -=_abee ._fbed .Left +_abee ._fbed .Right ;switch _abee ._ffgf {case FitModeFillWidth :_abee .ScaleToWidth (_ceee );};};

// IsAbsolute checks if the positioning is absolute.
func (_edef Positioning )IsAbsolute ()bool {return _edef ==PositionAbsolute };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_feba int ;_cdb string ;_ddc *Paragraph ;_cbf []Drawable ;_aff int ;_dadd bool ;_bge bool ;_cfeb Positioning ;_eecg ,_ebce float64 ;_bcbb Margins ;_deea *Chapter ;_ede *TOC ;_ecga *_fee .Outline ;_ddfg *_fee .OutlineItem ;_gfacd uint ;
};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_bbbcb *Ellipse )BorderOpacity ()float64 {return _bbbcb ._gdgd };func (_gabdcb *Paragraph )getTextWidth ()float64 {_gced :=0.0;for _ ,_gege :=range _gabdcb ._fagf {if _gege =='\u000A'{continue ;};_edgg ,_aded :=_gabdcb ._gbdaa .GetRuneMetrics (_gege );
if !_aded {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gege ,_gege );
return -1;};_gced +=_gabdcb ._bgef *_edgg .Wx ;};return _gced ;};

// Cols returns the total number of columns the table has.
func (_gade *Table )Cols ()int {return _gade ._fcfd };

// SetBorderColor sets the border color.
func (_cbaa *PolyBezierCurve )SetBorderColor (color Color ){_cbaa ._cceb .BorderColor =_cfd (color )};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_cbe *Block )SetMargins (left ,right ,top ,bottom float64 ){_cbe ._gb .Left =left ;_cbe ._gb .Right =right ;_cbe ._gb .Top =top ;_cbe ._gb .Bottom =bottom ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_gfcb *TOC )SetLinePageStyle (style TextStyle ){_gfcb ._ddege =style };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_cdbd *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cdbd ._dgb .Left ,_cdbd ._dgb .Right ,_cdbd ._dgb .Top ,_cdbd ._dgb .Bottom ;};

// NewCellProps returns the default properties of an invoice cell.
func (_faacb *Invoice )NewCellProps ()InvoiceCellProps {_eebe :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_faacb ._gbecb ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_eebe ,BorderColor :_eebe ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};const (PositionRelative Positioning =iota ;PositionAbsolute ;);func (_dgeeba *templateProcessor )parsePageBreak (_aafa *templateNode )(interface{},error ){return _gaffdg (),nil ;};func (_edf *Chapter )headingNumber ()string {var _badg string ;if _edf ._dadd {if _edf ._feba !=0{_badg =_fe .Itoa (_edf ._feba )+"\u002e";
};if _edf ._deea !=nil {_ccd :=_edf ._deea .headingNumber ();if _ccd !=""{_badg =_ccd +_badg ;};};};return _badg ;};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_dafb *Creator )SetOptimizer (optimizer _fee .Optimizer ){_dafb ._cecf =optimizer };

// Height returns the Block's height.
func (_cdd *Block )Height ()float64 {return _cdd ._egb };

// SetWidthBottom sets border width for bottom.
func (_afa *border )SetWidthBottom (bw float64 ){_afa ._eec =bw };

// SetWidth sets the width of the rectangle.
func (_debba *Rectangle )SetWidth (width float64 ){_debba ._bfddd =width };func (_cgac *templateProcessor )parseTextVerticalAlignmentAttr (_fffb ,_cbcc string )TextVerticalAlignment {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fffb ,_cbcc );
_fbfgb :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_cbcc ];return _fbfgb ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_gca *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_gca ._bcbb .Left =left ;_gca ._bcbb .Right =right ;_gca ._bcbb .Top =top ;_gca ._bcbb .Bottom =bottom ;};

// GeneratePageBlocks generates a page break block.
func (_gaccf *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeeabc :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_fbde :=ctx ;_fbde .Y =ctx .Margins .Top ;
_fbde .X =ctx .Margins .Left ;_fbde .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_fbde .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_fbde ;return _aeeabc ,ctx ,nil ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fgce *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _fgce ._decgf [0],_fgce ._decgf [1];};

// Positioning returns the type of positioning the rectangle is set to use.
func (_dcbf *Rectangle )Positioning ()Positioning {return _dcbf ._fgaa };func (_fbcad *templateProcessor )parseChart (_geefe *templateNode )(interface{},error ){var _bggc string ;for _ ,_cddec :=range _geefe ._bdbga .Attr {_bcbea :=_cddec .Value ;switch _dcgc :=_cddec .Name .Local ;
_dcgc {case "\u0073\u0072\u0063":_bggc =_bcbea ;};};if _bggc ==""{_da .Log .Error ("\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_gaeg ;};_gacbc ,_gdef :=_fbcad ._deag .ChartMap [_bggc ];if !_gdef {_da .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_bggc );
return nil ,_gaeg ;};_bcbee :=NewChart (_gacbc );for _ ,_eebed :=range _geefe ._bdbga .Attr {_ebeac :=_eebed .Value ;switch _fdcdf :=_eebed .Name .Local ;_fdcdf {case "\u0078":_bcbee .SetPos (_fbcad .parseFloatAttr (_fdcdf ,_ebeac ),_bcbee ._abfg );case "\u0079":_bcbee .SetPos (_bcbee ._gfcd ,_fbcad .parseFloatAttr (_fdcdf ,_ebeac ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ggfdg :=_fbcad .parseMarginAttr (_fdcdf ,_ebeac );_bcbee .SetMargins (_ggfdg .Left ,_ggfdg .Right ,_ggfdg .Top ,_ggfdg .Bottom );case "\u0077\u0069\u0064t\u0068":_bcbee ._edbg .SetWidth (int (_fbcad .parseFloatAttr (_fdcdf ,_ebeac )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_bcbee ._edbg .SetHeight (int (_fbcad .parseFloatAttr (_fdcdf ,_ebeac )));case "\u0073\u0072\u0063":break ;default:_da .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fdcdf );
};};return _bcbee ,nil ;};

// SetLineColor sets the line color.
func (_cafa *Polyline )SetLineColor (color Color ){_cafa ._dadfd .LineColor =_cfd (color )};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_bbff *Ellipse )ScaleToHeight (h float64 ){_efaf :=_bbff ._baeg /_bbff ._afaf ;_bbff ._afaf =h ;_bbff ._baeg =h *_efaf ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_bada *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_bada ._aaecd =&_fee .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func _bege (_gbde ,_agbb ,_febaa TextChunk ,_bdagf uint ,_egeg TextStyle )*TOCLine {_bgbfc :=_dccc (_egeg );
_bgbfc .SetEnableWrap (true );_bgbfc .SetTextAlignment (TextAlignmentLeft );_bgbfc .SetMargins (0,0,2,2);_fafbe :=&TOCLine {_dabee :_bgbfc ,Number :_gbde ,Title :_agbb ,Page :_febaa ,Separator :TextChunk {Text :"\u002e",Style :_egeg },_gfgb :0,_bbec :_bdagf ,_eedde :10,_bgfaa :PositionRelative };
_bgbfc ._eebag .Left =_fafbe ._gfgb +float64 (_fafbe ._bbec -1)*_fafbe ._eedde ;_bgbfc ._dbff =_fafbe .prepareParagraph ;return _fafbe ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dfgdf *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adad :=ctx ;_bcgc :=[]func (_badcf DrawContext )([]*Block ,DrawContext ,error ){_dfgdf .generateHeaderBlocks ,_dfgdf .generateInformationBlocks ,_dfgdf .generateLineBlocks ,_dfgdf .generateTotalBlocks ,_dfgdf .generateNoteBlocks };
var _bcgg []*Block ;for _ ,_eddb :=range _bcgc {_ceea ,_gfbdf ,_ddcg :=_eddb (ctx );if _ddcg !=nil {return _bcgg ,ctx ,_ddcg ;};if len (_bcgg )==0{_bcgg =_ceea ;}else if len (_ceea )> 0{_bcgg [len (_bcgg )-1].mergeBlocks (_ceea [0]);_bcgg =append (_bcgg ,_ceea [1:]...);
};ctx =_gfbdf ;};if _dfgdf ._ddfd .IsRelative (){ctx .X =_adad .X ;};if _dfgdf ._ddfd .IsAbsolute (){return _bcgg ,_adad ,nil ;};return _bcgg ,ctx ,nil ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_dgfb *TableCell )SetContent (vd VectorDrawable )error {switch _agabf :=vd .(type ){case *Paragraph :if _agabf ._ecfa {_agabf ._ccee =true ;};_dgfb ._cfdd =vd ;case *StyledParagraph :if _agabf ._cbbga {_agabf ._egge =true ;};_dgfb ._cfdd =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_dgfb ._cfdd =vd ;
default:_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _dd .ErrTypeError ;};return nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_gbd float64 ;_efd float64 ;_baeg float64 ;_afaf float64 ;_bbgc Positioning ;_dbeaf Color ;_eeec float64 ;_fdfd Color ;_bedef float64 ;_gdgd float64 ;_fbed Margins ;_ffgf FitMode ;};

// SetTotal sets the total of the invoice.
func (_ddcbf *Invoice )SetTotal (value string ){_ddcbf ._abb [1].Value =value };func (_ceca *templateProcessor )parseLinkAttr (_fbedb ,_ddcce string )*_fee .PdfAnnotation {_ddcce =_cf .TrimSpace (_ddcce );if _cf .HasPrefix (_ddcce ,"\u0075\u0072\u006c(\u0027")&&_cf .HasSuffix (_ddcce ,"\u0027\u0029")&&len (_ddcce )> 7{return _gfgag (_ddcce [5:len (_ddcce )-2]);
};if _cf .HasPrefix (_ddcce ,"\u0070\u0061\u0067e\u0028")&&_cf .HasSuffix (_ddcce ,"\u0029")&&len (_ddcce )> 6{var (_fgbg error ;_gcggg int64 ;_adde float64 ;_eacdf float64 ;_bgeed =1.0;_acagcf =_cf .Split (_ddcce [5:len (_ddcce )-1],"\u002c"););_gcggg ,_fgbg =_fe .ParseInt (_cf .TrimSpace (_acagcf [0]),10,64);
if _fgbg !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fgbg );return nil ;};if len (_acagcf )>=2{_adde ,_fgbg =_fe .ParseFloat (_cf .TrimSpace (_acagcf [1]),64);
if _fgbg !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fgbg );
return nil ;};};if len (_acagcf )>=3{_eacdf ,_fgbg =_fe .ParseFloat (_cf .TrimSpace (_acagcf [2]),64);if _fgbg !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fgbg );
return nil ;};};if len (_acagcf )>=4{_bgeed ,_fgbg =_fe .ParseFloat (_cf .TrimSpace (_acagcf [3]),64);if _fgbg !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_fgbg );
return nil ;};};return _gabgca (_gcggg -1,_adde ,_eacdf ,_bgeed );};return nil ;};func (_cggbb *templateProcessor )parseFloatArray (_bebdf ,_bedd string )[]float64 {_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bebdf ,_bedd );
_eecd :=_cf .Fields (_bedd );_cace :=make ([]float64 ,0,len (_eecd ));for _ ,_bcbc :=range _eecd {_gceb ,_ :=_fe .ParseFloat (_bcbc ,64);_cace =append (_cace ,_gceb );};return _cace ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_fcd *Creator )DrawTemplate (r _fg .Reader ,data interface{},options *TemplateOptions )error {return _gcdc (_fcd ,r ,data ,options ,_fcd );};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_gfba *RadialShading )AddShadingResource (block *Block )(_aafdb _dd .PdfObjectName ,_fabg error ){_ffegc :=1;_aafdb =_dd .PdfObjectName ("\u0053\u0068"+_fe .Itoa (_ffegc ));for block ._gf .HasShadingByName (_aafdb ){_ffegc ++;_aafdb =_dd .PdfObjectName ("\u0053\u0068"+_fe .Itoa (_ffegc ));
};if _bagac :=block ._gf .SetShadingByName (_aafdb ,_gfba .shadingModel ().ToPdfObject ());_bagac !=nil {return "",_bagac ;};return _aafdb ,nil ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetLineHeight sets the line height (1.0 default).
func (_cegca *Paragraph )SetLineHeight (lineheight float64 ){_cegca ._adgg =lineheight };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_bdfg *Creator )EnableFontSubsetting (font *_fee .PdfFont ){_bdfg ._gbc =append (_bdfg ._gbc ,font )};func _aegf (_bfaf string )(*GraphicSVG ,error ){_afdbc ,_gefd :=_aeb .ParseFromString (_bfaf );if _gefd !=nil {return nil ,_gefd ;};return _caac (_afdbc );
};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bfgbaa *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eebabd :=ctx ;_fgggd ,ctx ,_bdfed :=_bfgbaa ._dabee .GeneratePageBlocks (ctx );if _bdfed !=nil {return _fgggd ,ctx ,_bdfed ;};if _bfgbaa ._bgfaa .IsRelative (){ctx .X =_eebabd .X ;
};if _bfgbaa ._bgfaa .IsAbsolute (){return _fgggd ,_eebabd ,nil ;};return _fgggd ,ctx ,nil ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// AddColorStop add color stop info for rendering gradient color.
func (_dbfg *RadialShading )AddColorStop (color Color ,point float64 ){_dbfg ._ecef .AddColorStop (color ,point );};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline };};func (_cgae *Invoice )generateInformationBlocks (_dadf DrawContext )([]*Block ,DrawContext ,error ){_dda :=_dccc (_cgae ._gbecb );
_dda .SetMargins (0,0,0,20);_ecee :=_cgae .drawAddress (_cgae ._dfbd );_ecee =append (_ecee ,_dda );_ecee =append (_ecee ,_cgae .drawAddress (_cgae ._aedg )...);_fcbg :=_fgee ();for _ ,_cgaa :=range _ecee {_fcbg .Add (_cgaa );};_gafc :=_cgae .drawInformation ();
_beae :=_agegf (2);_beae .SetMargins (0,0,25,0);_dcbd :=_beae .NewCell ();_dcbd .SetIndent (0);_dcbd .SetContent (_fcbg );_dcbd =_beae .NewCell ();_dcbd .SetContent (_gafc );return _beae .GeneratePageBlocks (_dadf );};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_eeed DrawContext )([]*Block ,DrawContext ,error );};func _fabcd (_gaee []_bg .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_cceb :&_bg .PolyBezierCurve {Curves :_gaee ,BorderColor :_fee .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_aabg :1.0,_ebef :1.0};
};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_ddfc *Creator )SetOutlineTree (outlineTree *_fee .PdfOutlineTreeNode ){_ddfc ._eaa =outlineTree };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ecacf *Image )ScaleToWidth (w float64 ){_fgdf :=_ecacf ._eega /_ecacf ._edda ;_ecacf ._edda =w ;_ecacf ._eega =w *_fgdf ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_bfaa *StyledParagraph ;_bbfe []*TOCLine ;_bbda TextStyle ;_gaebe TextStyle ;_ffedc TextStyle ;_ddege TextStyle ;_gabb string ;_gfdfe float64 ;_fdgc Margins ;_eebf Positioning ;_dcdcg TextStyle ;_ffag bool ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// FitMode returns the fit mode of the line.
func (_ffaa *Line )FitMode ()FitMode {return _ffaa ._fgcc };

// SetSubtotal sets the subtotal of the invoice.
func (_aefa *Invoice )SetSubtotal (value string ){_aefa ._decgf [1].Value =value };

// LineWidth returns the width of the line.
func (_deec *Line )LineWidth ()float64 {return _deec ._bdfc };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bace *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _bace ._edgf [0],_bace ._edgf [1]};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _ff .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_fg .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_fee .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_fee .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ef .ChartRenderable ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_gefe *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_gcb :=[2]*InvoiceCell {_gefe .newCell (description ,_gefe ._bdc ),_gefe .newCell (value ,_gefe ._bdc )};_gefe ._dbbdg =append (_gefe ._dbbdg ,_gcb );return _gcb [0],_gcb [1];
};

// AddColorStop add color stop information for rendering gradient.
func (_ecgef *shading )AddColorStop (color Color ,point float64 ){_ecgef ._ccff =append (_ecgef ._ccff ,_fafb (color ,point ));};func (_fffe *Division )ctxHeight (_egcd float64 )float64 {_egcd -=_fffe ._ceeba .Left +_fffe ._ceeba .Right +_fffe ._deca .Left +_fffe ._deca .Right ;
var _gfea float64 ;for _ ,_bdde :=range _fffe ._aegg {_gfea +=_gfedb (_bdde ,_egcd );};return _gfea ;};

// SetMargins sets the margins of the chart component.
func (_gccd *Chart )SetMargins (left ,right ,top ,bottom float64 ){_gccd ._cgc .Left =left ;_gccd ._cgc .Right =right ;_gccd ._cgc .Top =top ;_gccd ._cgc .Bottom =bottom ;};

// SetLineWidth sets the line width.
func (_acbc *Polyline )SetLineWidth (lineWidth float64 ){_acbc ._dadfd .LineWidth =lineWidth };type componentRenderer interface{Draw (_dcebf Drawable )error ;};

// SetMargins sets the Paragraph's margins.
func (_acggb *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_acggb ._eebag .Left =left ;_acggb ._eebag .Right =right ;_acggb ._eebag .Top =top ;_acggb ._eebag .Bottom =bottom ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_acagc *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_agdca :=_dccc (_acagc ._bdbe );_agdca .Append (text );_gabdc ,_debd :=_acagc .Add (_agdca );return _agdca ,_gabdc ,_debd ;};

// GetRowHeight returns the height of the specified row.
func (_afee *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_afee ._agda ){return 0,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _afee ._agda [row -1],nil ;
};

// AddLine appends a new line to the invoice line items table.
func (_dcef *Invoice )AddLine (values ...string )[]*InvoiceCell {_gcfg :=len (_dcef ._eaafb );var _gabd []*InvoiceCell ;for _dfbc ,_cdfe :=range values {_aedf :=_dcef .newCell (_cdfe ,_dcef ._dbdg );if _dfbc < _gcfg {_aedf .Alignment =_dcef ._eaafb [_dfbc ].Alignment ;
};_gabd =append (_gabd ,_aedf );};_dcef ._ccbed =append (_dcef ._ccbed ,_gabd );return _gabd ;};

// Reset removes all the text chunks the paragraph contains.
func (_geegb *StyledParagraph )Reset (){_geegb ._adeb =[]*TextChunk {}};func (_abgef *Table )wrapContent (_eaafg DrawContext )error {if _abgef ._cfbac {return nil ;};_eacde :=func (_dagd *TableCell ,_dagda int ,_febagg int ,_ffed int )(_abgaa int ){if _ffed < 1{return -1;
};_dgdgf :=0;for _aeegc :=_febagg +1;_aeegc < len (_abgef ._afbaa )-1;_aeegc ++{_ddgec :=_abgef ._afbaa [_aeegc ];if _ddgec ._eeadc ==_ffed {_dgdgf =_aeegc ;if (_ddgec ._faga < _dagd ._faga &&_abgef ._fcfd > _ddgec ._faga )||_dagd ._faga < _abgef ._fcfd {continue ;
};break ;};};_egcfee :=float64 (0.0);for _ccgg :=0;_ccgg < _dagd ._dbbfc ;_ccgg ++{_egcfee +=_abgef ._agda [_dagd ._eeadc +_ccgg -1];};_dddbe :=float64 (0.0);for _bcbf :=0;_bcbf < _dagd ._cdefg ;_bcbf ++{_dddbe +=_abgef ._fadgg [_dagd ._faga +_bcbf -1];
};var (_bdee VectorDrawable ;_afafd =false ;);switch _ddac :=_dagd ._cfdd .(type ){case *StyledParagraph :_cfcgf :=_eaafg ;_cfcgf .Height =_fa .Floor (_egcfee -_ddac ._eebag .Top -_ddac ._eebag .Bottom -0.5*_ddac .getTextHeight ());_cfcgf .Width =_dddbe ;
_fgdda ,_dbdad ,_ggegb :=_ddac .split (_cfcgf );if _ggegb !=nil {_da .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_ggegb .Error ());
};if _fgdda !=nil &&_dbdad !=nil {_abgef ._afbaa [_febagg ]._cfdd =_fgdda ;_bdee =_dbdad ;_afafd =true ;};};_abgef ._afbaa [_febagg ]._dbbfc =_dagd ._dbbfc ;_eaafg .Height =_eaafg .PageHeight -_eaafg .Margins .Top -_eaafg .Margins .Bottom ;_fceb :=_dagd .cloneProps (nil );
if _afafd {_fceb ._cfdd =_bdee ;};_fceb ._dbbfc =_dagda -1;_fceb ._eeadc =_ffed +1;_fceb ._faga =_dagd ._faga ;_abgef ._afbaa =append (_abgef ._afbaa [:_dgdgf +1],append ([]*TableCell {_fceb },_abgef ._afbaa [_dgdgf +1:]...)...);return _dgdgf +1;};_ccfcf :=float64 (0.0);
_egeef :=0;_baag :=-1;for _eggga ,_dfacg :=range _abgef ._afbaa {if _baag ==_eggga {_egeef =_dfacg ._eeadc ;_ccfcf =0.0;};if _dfacg ._dbbfc < 2{if _egeef < _dfacg ._eeadc &&_eggga > _baag &&_ccfcf < _eaafg .Height {_ccfcf +=_abgef ._agda [_dfacg ._eeadc -1];
};_egeef =_dfacg ._eeadc ;continue ;};_acbce :=float64 (0.0);_cgad :=-1;_dgagb :=-1;_fbdb :=0;for _gfff :=0;_gfff < _dfacg ._dbbfc ;_gfff ++{if (_acbce +_abgef ._agda [_dfacg ._eeadc +_gfff -1])> (_eaafg .Height -_ccfcf ){_fbdb --;break ;};_acbce +=_abgef ._agda [_dfacg ._eeadc +_gfff -1];
_dgagb =_dfacg ._eeadc +_gfff -1;_cgad =_dfacg ._dbbfc -_gfff +1;_fbdb ++;};if _cgad > 0&&_dfacg ._dbbfc > _fbdb {_dfacg ._dbbfc =_fbdb ;_baag =_eacde (_dfacg ,_cgad ,_eggga ,_dgagb );_egeef =_dgagb ;};};return nil ;};func _dgbg (_ggde ,_gddd TextStyle )*Invoice {_agdc :=&Invoice {_faea :"\u0049N\u0056\u004f\u0049\u0043\u0045",_eafaf :"\u002c\u0020",_gbecb :_ggde ,_dbge :_gddd };
_agdc ._dfbd =&InvoiceAddress {Separator :_agdc ._eafaf };_agdc ._aedg =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_agdc ._eafaf };_ffgd :=ColorRGBFrom8bit (245,245,245);_aacgg :=ColorRGBFrom8bit (155,155,155);_agdc ._effe =_gddd ;
_agdc ._effe .Color =_aacgg ;_agdc ._effe .FontSize =20;_agdc ._bdbg =_ggde ;_agdc ._dbbf =_gddd ;_agdc ._dabeb =_ggde ;_agdc ._fadg =_gddd ;_agdc ._bdc =_agdc .NewCellProps ();_agdc ._bdc .BackgroundColor =_ffgd ;_agdc ._bdc .TextStyle =_gddd ;_agdc ._ggee =_agdc .NewCellProps ();
_agdc ._ggee .TextStyle =_gddd ;_agdc ._ggee .BackgroundColor =_ffgd ;_agdc ._ggee .BorderColor =_ffgd ;_agdc ._dbdg =_agdc .NewCellProps ();_agdc ._dbdg .BorderColor =_ffgd ;_agdc ._dbdg .BorderSides =[]CellBorderSide {CellBorderSideBottom };_agdc ._dbdg .Alignment =CellHorizontalAlignmentRight ;
_agdc ._afdac =_agdc .NewCellProps ();_agdc ._afdac .Alignment =CellHorizontalAlignmentRight ;_agdc ._agebg =[2]*InvoiceCell {_agdc .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_agdc ._bdc ),_agdc .newCell ("",_agdc ._bdc )};
_agdc ._gfbd =[2]*InvoiceCell {_agdc .newCell ("\u0044\u0061\u0074\u0065",_agdc ._bdc ),_agdc .newCell ("",_agdc ._bdc )};_agdc ._edgf =[2]*InvoiceCell {_agdc .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_agdc ._bdc ),_agdc .newCell ("",_agdc ._bdc )};
_agdc ._decgf =[2]*InvoiceCell {_agdc .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_agdc ._afdac ),_agdc .newCell ("",_agdc ._afdac )};_aeffd :=_agdc ._afdac ;_aeffd .TextStyle =_gddd ;_aeffd .BackgroundColor =_ffgd ;_aeffd .BorderColor =_ffgd ;
_agdc ._abb =[2]*InvoiceCell {_agdc .newCell ("\u0054\u006f\u0074a\u006c",_aeffd ),_agdc .newCell ("",_aeffd )};_agdc ._egdda =[2]string {"\u004e\u006f\u0074e\u0073",""};_agdc ._bfda =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_agdc ._eaafb =[]*InvoiceCell {_agdc .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_agdc .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_agdc .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_agdc .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _agdc ;};

// SetAnchor set gradient position anchor.
// Default to center.
func (_cadd *RadialShading )SetAnchor (anchor AnchorPoint ){_cadd ._egaae =anchor };

// Level returns the indentation level of the TOC line.
func (_fdebg *TOCLine )Level ()uint {return _fdebg ._bbec };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_edfb *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdgf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eefe ,_ggebc :=_bdgf .setOpacity (_edfb ._eadf ,_edfb ._eadf );if _ggebc !=nil {return nil ,ctx ,_ggebc ;};
_aceb :=_edfb ._dadfd .Points ;for _cbbee :=range _aceb {_bead :=&_aceb [_cbbee ];_bead .Y =ctx .PageHeight -_bead .Y ;};_gcefg ,_ ,_ggebc :=_edfb ._dadfd .Draw (_eefe );if _ggebc !=nil {return nil ,ctx ,_ggebc ;};if _ggebc =_bdgf .addContentsByString (string (_gcefg ));
_ggebc !=nil {return nil ,ctx ,_ggebc ;};return []*Block {_bdgf },ctx ,nil ;};func _fcgca (_ffggf *_fd .File )([]*_fee .PdfPage ,error ){_bfebf ,_dafgg :=_fee .NewPdfReader (_ffggf );if _dafgg !=nil {return nil ,_dafgg ;};_dbgg ,_dafgg :=_bfebf .GetNumPages ();
if _dafgg !=nil {return nil ,_dafgg ;};var _cebe []*_fee .PdfPage ;for _egdf :=0;_egdf < _dbgg ;_egdf ++{_dbfab ,_baee :=_bfebf .GetPage (_egdf +1);if _baee !=nil {return nil ,_baee ;};_cebe =append (_cebe ,_dbfab );};return _cebe ,nil ;};type rgbColor struct{_ade ,_fcc ,_fbe float64 };


// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _aegf (svgStr )};

// Height returns the height of the graphic svg.
func (_bfcb *GraphicSVG )Height ()float64 {return _bfcb ._cfff .Height };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_gacaf *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_gacaf ._ebbd =textOverflow ;};

// SetBorderOpacity sets the border opacity of the ellipse.
func (_bdgcg *Ellipse )SetBorderOpacity (opacity float64 ){_bdgcg ._gdgd =opacity };

// Height returns Image's document height.
func (_cdac *Image )Height ()float64 {return _cdac ._eega };

// Invoice represents a configurable invoice template.
type Invoice struct{_faea string ;_gaffd *Image ;_aedg *InvoiceAddress ;_dfbd *InvoiceAddress ;_eafaf string ;_agebg [2]*InvoiceCell ;_gfbd [2]*InvoiceCell ;_edgf [2]*InvoiceCell ;_dbbdg [][2]*InvoiceCell ;_eaafb []*InvoiceCell ;_ccbed [][]*InvoiceCell ;
_decgf [2]*InvoiceCell ;_abb [2]*InvoiceCell ;_gcffc [][2]*InvoiceCell ;_egdda [2]string ;_bfda [2]string ;_eeda [][2]string ;_gbecb TextStyle ;_dbge TextStyle ;_effe TextStyle ;_bdbg TextStyle ;_dbbf TextStyle ;_dabeb TextStyle ;_fadg TextStyle ;_bdc InvoiceCellProps ;
_ggee InvoiceCellProps ;_dbdg InvoiceCellProps ;_afdac InvoiceCellProps ;_ddfd Positioning ;};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_defd *Ellipse )SetPositioning (position Positioning ){_defd ._bbgc =position };

// Horizontal returns total horizontal (left + right) margin.
func (_ace *Margins )Horizontal ()float64 {return _ace .Left +_ace .Right };

// NewInvoice returns an instance of an empty invoice.
func (_faae *Creator )NewInvoice ()*Invoice {_ecdbb :=_faae .NewTextStyle ();_ecdbb .Font =_faae ._gbad ;return _dgbg (_faae .NewTextStyle (),_ecdbb );};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_bfg *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bfg ._gb .Left ,_bfg ._gb .Right ,_bfg ._gb .Top ,_bfg ._gb .Bottom ;};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_dbdb *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fgdc []*Block ;_ffd =NewBlock (ctx .PageWidth ,ctx .PageHeight );_beedc =ctx ;);_eaeaa :=_dbdb ._bbgc .IsRelative ();if _eaeaa {_dbdb .applyFitMode (ctx .Width );
ctx .X +=_dbdb ._fbed .Left ;ctx .Y +=_dbdb ._fbed .Top ;ctx .Width -=_dbdb ._fbed .Left +_dbdb ._fbed .Right ;ctx .Height -=_dbdb ._fbed .Top +_dbdb ._fbed .Bottom ;if _dbdb ._afaf > ctx .Height {_fgdc =append (_fgdc ,_ffd );_ffd =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_cgbb :=ctx ;_cgbb .Y =ctx .Margins .Top +_dbdb ._fbed .Top ;_cgbb .X =ctx .Margins .Left +_dbdb ._fbed .Left ;_cgbb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dbdb ._fbed .Top -_dbdb ._fbed .Bottom ;_cgbb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dbdb ._fbed .Left -_dbdb ._fbed .Right ;
ctx =_cgbb ;};}else {ctx .X =_dbdb ._gbd -_dbdb ._baeg /2;ctx .Y =_dbdb ._efd -_dbdb ._afaf /2;};_cef :=_bg .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_dbdb ._afaf ,Width :_dbdb ._baeg ,Height :_dbdb ._afaf ,BorderWidth :_dbdb ._bedef ,Opacity :1.0};
if _dbdb ._dbeaf !=nil {_cef .FillEnabled =true ;_dffg :=_cfd (_dbdb ._dbeaf );_ebdf :=_aacgba (_ffd ,_dffg ,_dbdb ._dbeaf ,func ()Rectangle {return Rectangle {_cfbab :_cef .X ,_cffbf :_cef .Y ,_bfddd :_cef .Width ,_abfd :_cef .Height };});if _ebdf !=nil {return nil ,ctx ,_ebdf ;
};_cef .FillColor =_dffg ;};if _dbdb ._fdfd !=nil {_cef .BorderEnabled =false ;if _dbdb ._bedef > 0{_cef .BorderEnabled =true ;};_cef .BorderColor =_cfd (_dbdb ._fdfd );_cef .BorderWidth =_dbdb ._bedef ;};_gaec ,_effc :=_ffd .setOpacity (_dbdb ._eeec ,_dbdb ._gdgd );
if _effc !=nil {return nil ,ctx ,_effc ;};_decg ,_ ,_effc :=_cef .Draw (_gaec );if _effc !=nil {return nil ,ctx ,_effc ;};_effc =_ffd .addContentsByString (string (_decg ));if _effc !=nil {return nil ,ctx ,_effc ;};if _eaeaa {ctx .X =_beedc .X ;ctx .Width =_beedc .Width ;
ctx .Y +=_dbdb ._afaf +_dbdb ._fbed .Bottom ;ctx .Height -=_dbdb ._afaf ;}else {ctx =_beedc ;};_fgdc =append (_fgdc ,_ffd );return _fgdc ,ctx ,nil ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_aaae *_fee .XObjectImage ;_dgaec *_fee .Image ;_dbbd float64 ;_edda ,_eega float64 ;_bfdf ,_eaaa float64 ;_agagd Positioning ;_eeef HorizontalAlignment ;_gbcdd float64 ;_egbgf float64 ;_edcd float64 ;_dgb Margins ;_egca ,_cddb float64 ;
_fcgd _dd .StreamEncoder ;_eged FitMode ;};func _edafc (_dgdefb *templateProcessor ,_gdge *templateNode )(interface{},error ){return _dgdefb .parseListMarker (_gdge );};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_ddafb *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_baegc :=&_ddafb ._fdgc ;_baegc .Left =left ;_baegc .Right =right ;_baegc .Top =top ;_baegc .Bottom =bottom ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetBorderColor sets the cell's border color.
func (_ccbg *TableCell )SetBorderColor (col Color ){_ccbg ._gefeb =col ;_ccbg ._fcgg =col ;_ccbg ._fgdgg =col ;_ccbg ._gcac =col ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;func (_aecd *templateProcessor )parseFontAttr (_bcec ,_ceeea string )*_fee .PdfFont {_da .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bcec ,_ceeea );
_eacac :=_aecd .creator ._eedd ;if _ceeea ==""{return _eacac ;};_dcda :=_cf .Split (_ceeea ,"\u002c");for _ ,_bcbgg :=range _dcda {_bcbgg =_cf .TrimSpace (_bcbgg );if _bcbgg ==""{continue ;};_ffba ,_faaca :=_aecd ._deag .FontMap [_ceeea ];if _faaca {return _ffba ;
};_fgad ,_faaca :=map[string ]_fee .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_fee .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_fee .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_fee .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_fee .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_fee .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_fee .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_fee .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_fee .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_fee .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_fee .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_fee .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_fee .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_fee .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_fee .TimesBoldItalicName }[_ceeea ];
if _faaca {if _eegba ,_adbgd :=_fee .NewStandard14Font (_fgad );_adbgd ==nil {return _eegba ;};};if _bfded :=_aecd .parseAttrPropList (_bcbgg );len (_bfded )> 0{if _gdefa ,_bebed :=_bfded ["\u0070\u0061\u0074\u0068"];_bebed {_ccad :=_fee .NewPdfFontFromTTFFile ;
if _aebge ,_cgebg :=_bfded ["\u0074\u0079\u0070\u0065"];_cgebg &&_aebge =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_ccad =_fee .NewCompositePdfFontFromTTFFile ;};if _gcdf ,_ebbg :=_ccad (_gdefa );_ebbg !=nil {_da .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_gdefa ,_ebbg );
}else {return _gcdf ;};};};};return _eacac ;};

// SetColorBottom sets border color for bottom.
func (_fea *border )SetColorBottom (col Color ){_fea ._beed =col };func _dgga (_eddfcb *templateProcessor ,_bgdef *templateNode )(interface{},error ){return _eddfcb .parseTableCell (_bgdef );};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cefg *Invoice )NoteHeadingStyle ()TextStyle {return _cefg ._fadg };

// SetPositioning sets the positioning of the line (absolute or relative).
func (_bccg *Line )SetPositioning (positioning Positioning ){_bccg ._aede =positioning };

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_fdbbf *LinearShading )AddShadingResource (block *Block )(_dgfef _dd .PdfObjectName ,_dged error ){_gfddg :=1;_dgfef =_dd .PdfObjectName ("\u0053\u0068"+_fe .Itoa (_gfddg ));for block ._gf .HasShadingByName (_dgfef ){_gfddg ++;_dgfef =_dd .PdfObjectName ("\u0053\u0068"+_fe .Itoa (_gfddg ));
};if _aaaf :=block ._gf .SetShadingByName (_dgfef ,_fdbbf .shadingModel ().ToPdfObject ());_aaaf !=nil {return "",_aaaf ;};return _dgfef ,nil ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_ffbf *StyledParagraph )Insert (index uint ,text string )*TextChunk {_ggdf :=uint (len (_ffbf ._adeb ));if index > _ggdf {index =_ggdf ;};_ddedf :=NewTextChunk (text ,_ffbf ._cefc );_ffbf ._adeb =append (_ffbf ._adeb [:index ],append ([]*TextChunk {_ddedf },_ffbf ._adeb [index :]...)...);
_ffbf .wrapText ();return _ddedf ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_dfc *Chapter )GetHeading ()*Paragraph {return _dfc ._ddc };

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ceff *Line )SetFitMode (fitMode FitMode ){_ceff ._fgcc =fitMode };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_ecge *Invoice )Terms ()(string ,string ){return _ecge ._bfda [0],_ecge ._bfda [1]};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ebd :=&Block {};_ebd ._db =&_ebc .ContentStreamOperations {};_ebd ._gf =_fee .NewPdfPageResources ();_ebd ._bab =width ;_ebd ._egb =height ;return _ebd ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_dfcg *Division )EnablePageWrap (enable bool ){_dfcg ._fgg =enable };func _acea (_efca ,_eced ,_acgge ,_baaf float64 )*Ellipse {return &Ellipse {_gbd :_efca ,_efd :_eced ,_baeg :_acgge ,_afaf :_baaf ,_bbgc :PositionAbsolute ,_eeec :1.0,_fdfd :ColorBlack ,_bedef :1.0,_gdgd :1.0};
};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_aeed *Rectangle )Height ()float64 {return _aeed ._abfd };func _ggad (_fbdgg *Creator ,_abdcc []byte ,_gfbdb *TemplateOptions ,_gead componentRenderer )*templateProcessor {if _gfbdb ==nil {_gfbdb =&TemplateOptions {};};_gfbdb .init ();if _gead ==nil {_gead =_fbdgg ;
};return &templateProcessor {creator :_fbdgg ,_ffcd :_abdcc ,_deag :_gfbdb ,_cgcaa :_gead };};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_edbd *Table )MultiCell (rowspan ,colspan int )*TableCell {_edbd ._gacbf ++;_cdead :=(_edbd .moveToNextAvailableCell ()-1)%(_edbd ._fcfd )+1;_abcb :=(_edbd ._gacbf -1)/_edbd ._fcfd +1;for _abcb > _edbd ._edde {_edbd ._edde ++;_edbd ._agda =append (_edbd ._agda ,_edbd ._gbbe );
};_gdga :=&TableCell {};_gdga ._eeadc =_abcb ;_gdga ._faga =_cdead ;_gdga ._bdff =5;_gdga ._fgfda =CellBorderStyleNone ;_gdga ._gaeaa =_bg .LineStyleSolid ;_gdga ._cdfcd =CellHorizontalAlignmentLeft ;_gdga ._egfeb =CellVerticalAlignmentTop ;_gdga ._bcdfe =0;
_gdga ._fabe =0;_gdga ._bdga =0;_gdga ._cbcbcg =0;_bbga :=ColorBlack ;_gdga ._gefeb =_bbga ;_gdga ._fcgg =_bbga ;_gdga ._fgdgg =_bbga ;_gdga ._gcac =_bbga ;if rowspan < 1{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_dgab :=_edbd ._edde -(_gdga ._eeadc -1);if rowspan > _dgab {_da .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_dgab );
_edbd ._edde +=rowspan -1;for _bcgb :=0;_bcgb <=rowspan -_dgab ;_bcgb ++{_edbd ._agda =append (_edbd ._agda ,_edbd ._gbbe );};};for _fefgb :=0;_fefgb < colspan &&_cdead +_fefgb -1< len (_edbd ._gbdga );_fefgb ++{_edbd ._gbdga [_cdead +_fefgb -1]=rowspan -1;
};_gdga ._dbbfc =rowspan ;if colspan < 1{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_gdfba :=_edbd ._fcfd -(_gdga ._faga -1);if colspan > _gdfba {_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_gdfba );
colspan =_gdfba ;};_gdga ._cdefg =colspan ;_edbd ._gacbf +=colspan -1;_edbd ._afbaa =append (_edbd ._afbaa ,_gdga );_gdga ._fagfd =_edbd ;return _gdga ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_bgbc *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_bgbc ._fcfd {_da .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bgbc ._fadgg =widths ;return nil ;};

// Title returns the title of the invoice.
func (_gbfa *Invoice )Title ()string {return _gbfa ._faea };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_cdea *Block )ScaleToWidth (w float64 ){_fc :=w /_cdea ._bab ;_cdea .Scale (_fc ,_fc )};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dbfe *Rectangle )SetFitMode (fitMode FitMode ){_dbfe ._fefc =fitMode };func _bafd (_dabebc float64 ,_gagd float64 ,_dfccf float64 ,_ecgb float64 ,_dccd []*ColorPoint )*RadialShading {return &RadialShading {_ecef :&shading {_bbcfd :ColorWhite ,_fbfeg :false ,_gcefb :[]bool {false ,false },_ccff :_dccd },_cbbeee :_dabebc ,_gbfb :_gagd ,_cgfcf :_dfccf ,_bbdd :_ecgb ,_egaae :AnchorCenter };
};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_eccga *Chart )Width ()float64 {return float64 (_eccga ._edbg .Width ())};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_edag *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_edag ._cfebc =align ;};func (_cgdcc *shading )generatePdfFunctions ()[]_fee .PdfFunction {if len (_cgdcc ._ccff )==0{return nil ;}else if len (_cgdcc ._ccff )<=2{_ffdfc ,_bdcg ,_ffdg :=_cgdcc ._ccff [0]._abfba .ToRGB ();
_gadd ,_fdeb ,_efcfd :=_cgdcc ._ccff [len (_cgdcc ._ccff )-1]._abfba .ToRGB ();return []_fee .PdfFunction {&_fee .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_ffdfc ,_bdcg ,_ffdg },C1 :[]float64 {_gadd ,_fdeb ,_efcfd }}};
}else {_efgaa :=[]_fee .PdfFunction {};_gbae :=[]float64 {};for _bcagf :=0;_bcagf < len (_cgdcc ._ccff )-1;_bcagf ++{_begd ,_ebgfb ,_cdbca :=_cgdcc ._ccff [_bcagf ]._abfba .ToRGB ();_fgfd ,_bbgf ,_abcf :=_cgdcc ._ccff [_bcagf +1]._abfba .ToRGB ();_dfefb :=&_fee .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_begd ,_ebgfb ,_cdbca },C1 :[]float64 {_fgfd ,_bbgf ,_abcf }};
_efgaa =append (_efgaa ,_dfefb );if _bcagf > 0{_gbae =append (_gbae ,_cgdcc ._ccff [_bcagf ]._gfeg );};};_ebfg :=[]float64 {};for range _efgaa {_ebfg =append (_ebfg ,[]float64 {0.0,1.0}...);};return []_fee .PdfFunction {&_fee .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_efgaa ,Bounds :_gbae ,Encode :_ebfg }};
};};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_gbaa *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// Heading returns the heading component of the table of contents.
func (_eggfd *TOC )Heading ()*StyledParagraph {return _eggfd ._bfaa };func (_bgaa *Paragraph )getTextLineWidth (_eaad string )float64 {var _gfab float64 ;for _ ,_gggdb :=range _eaad {if _gggdb =='\u000A'{continue ;};_eeadf ,_ebddf :=_bgaa ._gbdaa .GetRuneMetrics (_gggdb );
if !_ebddf {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gggdb ,_gggdb );
return -1;};_gfab +=_bgaa ._bgef *_eeadf .Wx ;};return _gfab ;};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_aec *Chapter )Add (d Drawable )error {if Drawable (_aec )==d {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _afda :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_aec ._cbf =append (_aec ._cbf ,d );case containerDrawable :_dbf ,_dgege :=_afda .ContainerComponent (_aec );
if _dgege !=nil {return _dgege ;};_aec ._cbf =append (_aec ._cbf ,_dbf );default:_da .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// Width returns the Block's width.
func (_gfb *Block )Width ()float64 {return _gfb ._bab };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_bageg *TOC )SetLineSeparator (separator string ){_bageg ._gabb =separator };

// SetColor sets the line color.
func (_cfaa *Curve )SetColor (col Color ){_cfaa ._gabg =col };type templateTag struct{_gagf map[string ]struct{};_agdb func (*templateProcessor ,*templateNode )(interface{},error );};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_bdca *Rectangle )ScaleToWidth (w float64 ){_eacf :=_bdca ._abfd /_bdca ._bfddd ;_bdca ._bfddd =w ;_bdca ._abfd =w *_eacf ;};type pageTransformations struct{_gbgd *_bc .Matrix ;_ceeg bool ;_agc bool ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_edaa *Invoice )SetTerms (title ,content string ){_edaa ._bfda =[2]string {title ,content }};func (_gecd *Invoice )drawAddress (_gfacdc *InvoiceAddress )[]*StyledParagraph {var _eacd []*StyledParagraph ;if _gfacdc .Heading !=""{_ebfd :=_dccc (_gecd ._dbbf );
_ebfd .SetMargins (0,0,0,7);_ebfd .Append (_gfacdc .Heading );_eacd =append (_eacd ,_ebfd );};_degag :=_dccc (_gecd ._bdbg );_degag .SetLineHeight (1.2);_adbf :=_gfacdc .Separator ;if _adbf ==""{_adbf =_gecd ._eafaf ;};_febg :=_gfacdc .City ;if _gfacdc .State !=""{if _febg !=""{_febg +=_adbf ;
};_febg +=_gfacdc .State ;};if _gfacdc .Zip !=""{if _febg !=""{_febg +=_adbf ;};_febg +=_gfacdc .Zip ;};if _gfacdc .Name !=""{_degag .Append (_gfacdc .Name +"\u000a");};if _gfacdc .Street !=""{_degag .Append (_gfacdc .Street +"\u000a");};if _gfacdc .Street2 !=""{_degag .Append (_gfacdc .Street2 +"\u000a");
};if _febg !=""{_degag .Append (_febg +"\u000a");};if _gfacdc .Country !=""{_degag .Append (_gfacdc .Country +"\u000a");};_fcfg :=_dccc (_gecd ._bdbg );_fcfg .SetLineHeight (1.2);_fcfg .SetMargins (0,0,7,0);if _gfacdc .Phone !=""{_fcfg .Append (_gfacdc .fmtLine (_gfacdc .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_gfacdc .HidePhoneLabel ));
};if _gfacdc .Email !=""{_fcfg .Append (_gfacdc .fmtLine (_gfacdc .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_gfacdc .HideEmailLabel ));};_eacd =append (_eacd ,_degag ,_fcfg );return _eacd ;};func _abcbd (_acdba ,_eaafc ,_ecbaf float64 )(_eegf ,_bfee ,_cefff ,_bfge float64 ){if _ecbaf ==0{return 0,0,_acdba ,_eaafc ;
};_afcae :=_bg .Path {Points :[]_bg .Point {_bg .NewPoint (0,0).Rotate (_ecbaf ),_bg .NewPoint (_acdba ,0).Rotate (_ecbaf ),_bg .NewPoint (0,_eaafc ).Rotate (_ecbaf ),_bg .NewPoint (_acdba ,_eaafc ).Rotate (_ecbaf )}}.GetBoundingBox ();return _afcae .X ,_afcae .Y ,_afcae .Width ,_afcae .Height ;
};func (_afce *Image )makeXObject ()error {_bgee :=_afce ._fcgd ;if _bgee ==nil {_bgee =_dd .NewFlateEncoder ();};_eafd ,_fdff :=_fee .NewXObjectImageFromImage (_afce ._dgaec ,nil ,_bgee );if _fdff !=nil {_da .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fdff );
return _fdff ;};_afce ._aaae =_eafd ;return nil ;};func _edae (_cgfg string )(*Image ,error ){_gcfd ,_bdba :=_fd .Open (_cgfg );if _bdba !=nil {return nil ,_bdba ;};defer _gcfd .Close ();_bdbaa ,_bdba :=_fee .ImageHandling .Read (_gcfd );if _bdba !=nil {_da .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bdba );
return nil ,_bdba ;};return _gccg (_bdbaa );};var PPMM =float64 (72*1.0/25.4);func (_bbe *Block )addContentsByString (_fgd string )error {_fba :=_ebc .NewContentStreamParser (_fgd );_cg ,_bbbb :=_fba .Parse ();if _bbbb !=nil {return _bbbb ;};_bbe ._db .WrapIfNeeded ();
_cg .WrapIfNeeded ();*_bbe ._db =append (*_bbe ._db ,*_cg ...);return nil ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_ebad *Invoice )BuyerAddress ()*InvoiceAddress {return _ebad ._aedg };type border struct{_bgg float64 ;_ebg float64 ;_dgda float64 ;_aed float64 ;_aeea Color ;_ege Color ;_bbd float64 ;_beed Color ;_eec float64 ;_ecba Color ;_cee float64 ;_bfgc Color ;
_gab float64 ;LineStyle _bg .LineStyle ;_ece CellBorderStyle ;_eccg CellBorderStyle ;_cffc CellBorderStyle ;_beb CellBorderStyle ;};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_caaa *Rectangle )GetCoords ()(float64 ,float64 ){return _caaa ._cfbab ,_caaa ._cffbf };

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_aeccg *Table )MultiRowCell (rowspan int )*TableCell {return _aeccg .MultiCell (rowspan ,1)};func (_cbaf *templateProcessor )run ()error {_fegb :=_e .NewDecoder (_c .NewReader (_cbaf ._ffcd ));var _fegcd *templateNode ;for {_adbae ,_agcg :=_fegb .Token ();
if _agcg !=nil {if _agcg ==_fg .EOF {return nil ;};return _agcg ;};if _adbae ==nil {break ;};switch _ecfe :=_adbae .(type ){case _e .StartElement :_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_ecfe .Name .Local );
_gaecc ,_fdfbe :=_accae [_ecfe .Name .Local ];if !_fdfbe {_da .Log .Debug ("\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074a\u0067\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075t\u0070\u0075t\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ecfe .Name .Local );
continue ;};_fegcd =&templateNode {_bdbga :_ecfe ,_bdgb :_fegcd };if _dfegb :=_gaecc ._agdb ;_dfegb !=nil {_fegcd ._bdced ,_agcg =_dfegb (_cbaf ,_fegcd );if _agcg !=nil {return _agcg ;};};case _e .EndElement :_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_ecfe .Name .Local );
if _fegcd !=nil {if _fegcd ._bdced !=nil {if _babbf :=_cbaf .renderNode (_fegcd );_babbf !=nil {return _babbf ;};};_fegcd =_fegcd ._bdgb ;};case _e .CharData :if _fegcd !=nil &&_fegcd ._bdced !=nil {if _cfcb :=_cbaf .addNodeText (_fegcd ,string (_ecfe ));
_cfcb !=nil {return _cfcb ;};};case _e .Comment :_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_ecfe ));
};};return nil ;};

// SetWidth sets line width.
func (_affcb *Curve )SetWidth (width float64 ){_affcb ._cgfc =width };

// SetFillOpacity sets the fill opacity of the rectangle.
func (_gbef *Rectangle )SetFillOpacity (opacity float64 ){_gbef ._ffdfg =opacity };

// Opacity returns the opacity of the line.
func (_dfeg *Line )Opacity ()float64 {return _dfeg ._dcfe };func (_fece *Invoice )newColumn (_ecbgd string ,_bbbf CellHorizontalAlignment )*InvoiceCell {_bagb :=&InvoiceCell {_fece ._ggee ,_ecbgd };_bagb .Alignment =_bbbf ;return _bagb ;};

// FitMode returns the fit mode of the rectangle.
func (_dgeb *Rectangle )FitMode ()FitMode {return _dgeb ._fefc };

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_ddcc *Invoice )AddressStyle ()TextStyle {return _ddcc ._bdbg };

// FillColor returns the fill color of the rectangle.
func (_cdbc *Rectangle )FillColor ()Color {return _cdbc ._cdgf };

// SetBorderRadius sets the radius of the rectangle corners.
func (_dfed *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_dfed ._egdce =topLeft ;_dfed ._edac =topRight ;_dfed ._cdfge =bottomLeft ;_dfed ._cfef =bottomRight ;};func (_accg *templateProcessor )parseLinearGradientAttr (creator *Creator ,_afgc string )Color {_efaac :=ColorBlack ;
if _afgc ==""{return _efaac ;};_fafcc :=creator .NewLinearGradientColor ([]*ColorPoint {});_fafcc .SetExtends (true ,true );var (_defg =_cf .Split (_afgc [16:len (_afgc )-1],"\u002c");_cbced =_cf .TrimSpace (_defg [0]););if _cf .HasSuffix (_cbced ,"\u0064\u0065\u0067"){_fgda ,_efag :=_fe .ParseFloat (_cbced [:len (_cbced )-3],64);
if _efag !=nil {_da .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_efag );}else {_fafcc .SetAngle (_fgda );
};_defg =_defg [1:];};_bedeed ,_babd :=_accg .processGradientColorPair (_defg );if _bedeed ==nil ||_babd ==nil {return _efaac ;};for _facg :=0;_facg < len (_bedeed );_facg ++{_fafcc .AddColorStop (_bedeed [_facg ],_babd [_facg ]);};return _fafcc ;};

// SetFillColor sets the fill color of the rectangle.
func (_adee *Rectangle )SetFillColor (col Color ){_adee ._cdgf =col };

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_dbec *Paragraph )SetColor (col Color ){_dbec ._cfae =col };func (_cabb *TOCLine )prepareParagraph (_dcfdg *StyledParagraph ,_efgdd DrawContext ){_cdcgf :=_cabb .Title .Text ;if _cabb .Number .Text !=""{_cdcgf ="\u0020"+_cdcgf ;};_cdcgf +="\u0020";
_dabaf :=_cabb .Page .Text ;if _dabaf !=""{_dabaf ="\u0020"+_dabaf ;};_dcfdg ._adeb =[]*TextChunk {{Text :_cabb .Number .Text ,Style :_cabb .Number .Style ,_beebgd :_cabb .getLineLink ()},{Text :_cdcgf ,Style :_cabb .Title .Style ,_beebgd :_cabb .getLineLink ()},{Text :_dabaf ,Style :_cabb .Page .Style ,_beebgd :_cabb .getLineLink ()}};
_dcfdg .wrapText ();_abcd :=len (_dcfdg ._cfcf );if _abcd ==0{return ;};_afabg :=_efgdd .Width *1000-_dcfdg .getTextLineWidth (_dcfdg ._cfcf [_abcd -1]);_edfe :=_dcfdg .getTextLineWidth ([]*TextChunk {&_cabb .Separator });_afga :=int (_afabg /_edfe );_bacef :=_cf .Repeat (_cabb .Separator .Text ,_afga );
_cfeg :=_cabb .Separator .Style ;_eegga :=_dcfdg .Insert (2,_bacef );_eegga .Style =_cfeg ;_eegga ._beebgd =_cabb .getLineLink ();_afabg =_afabg -float64 (_afga )*_edfe ;if _afabg > 500{_acbcc ,_cgcc :=_cfeg .Font .GetRuneMetrics (' ');if _cgcc &&_afabg > _acbcc .Wx {_abdeb :=int (_afabg /_acbcc .Wx );
if _abdeb > 0{_cfege :=_cfeg ;_cfege .FontSize =1;_eegga =_dcfdg .Insert (2,_cf .Repeat ("\u0020",_abdeb ));_eegga .Style =_cfege ;_eegga ._beebgd =_cabb .getLineLink ();};};};};func _fgbc (_bccc *_fee .PdfRectangle ,_eadc _bc .Matrix )*_fee .PdfRectangle {var _fgfb _fee .PdfRectangle ;
_fgfb .Llx ,_fgfb .Lly =_eadc .Transform (_bccc .Llx ,_bccc .Lly );_fgfb .Urx ,_fgfb .Ury =_eadc .Transform (_bccc .Urx ,_bccc .Ury );_fgfb .Normalize ();return &_fgfb ;};func (_gccc *templateProcessor )parseCellBorderStyleAttr (_bcada ,_dbfb string )CellBorderStyle {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_bcada ,_dbfb );
_bgaeg :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_dbfb ];return _bgaeg ;};

// SetFillColor sets the fill color.
func (_ffce *Polygon )SetFillColor (color Color ){_ffce ._ecad =color ;_ffce ._ebdcd .FillColor =_cfd (color );};func _gcabd (_dgedd *templateProcessor ,_fcdcf *templateNode )(interface{},error ){return _dgedd .parseList (_fcdcf );};func (_gcef *Line )computeCoords (_bfga DrawContext )(_gbbg ,_fggc ,_edec ,_aaec float64 ){_gbbg =_bfga .X ;
_edec =_gbbg +_gcef ._ecec -_gcef ._bcgf ;_dddb :=_gcef ._bdfc ;if _gcef ._bcgf ==_gcef ._ecec {_dddb /=2;};if _gcef ._fgba < _gcef ._daac {_fggc =_bfga .PageHeight -_bfga .Y -_dddb ;_aaec =_fggc -_gcef ._daac +_gcef ._fgba ;}else {_aaec =_bfga .PageHeight -_bfga .Y -_dddb ;
_fggc =_aaec -_gcef ._fgba +_gcef ._daac ;};switch _gcef ._fgcc {case FitModeFillWidth :_edec =_gbbg +_bfga .Width ;};return _gbbg ,_fggc ,_edec ,_aaec ;};func (_abbb *templateProcessor )parseTextAlignmentAttr (_dfgfg ,_bafbf string )TextAlignment {_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dfgfg ,_bafbf );
_gbfcf :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_bafbf ];
return _gbfcf ;};func (_agbe *Table )wrapRow (_begga int ,_aeebfc DrawContext ,_ggeed float64 )(bool ,error ){if !_agbe ._cfbac {return false ,nil ;};var (_fega =_agbe ._afbaa [_begga ];_dcbeg =-1;_aedd []*TableCell ;_bcade float64 ;_aedb bool ;_egcfe =make ([]float64 ,0,len (_agbe ._fadgg ));
);_daea :=func (_badd *TableCell ,_eegg VectorDrawable ,_cdga bool )*TableCell {_bcdbg :=*_badd ;_bcdbg ._cfdd =_eegg ;if _cdga {_bcdbg ._eeadc ++;};return &_bcdbg ;};_aaffa :=func (_bffaeg int ,_bafce VectorDrawable ){var _bcgcb float64 =-1;if _bafce ==nil {if _aadf :=_egcfe [_bffaeg -_begga ];
_aadf > _aeebfc .Height {_bafce =_agbe ._afbaa [_bffaeg ]._cfdd ;_agbe ._afbaa [_bffaeg ]._cfdd =nil ;_egcfe [_bffaeg -_begga ]=0;_bcgcb =_aadf ;};};_cggf :=_daea (_agbe ._afbaa [_bffaeg ],_bafce ,true );_aedd =append (_aedd ,_cggf );if _bcgcb < 0{_bcgcb =_cggf .height (_aeebfc .Width );
};if _bcgcb > _bcade {_bcade =_bcgcb ;};};for _dfff :=_begga ;_dfff < len (_agbe ._afbaa );_dfff ++{_ccfc :=_agbe ._afbaa [_dfff ];if _fega ._eeadc !=_ccfc ._eeadc {_dcbeg =_dfff ;break ;};_aeebfc .Width =_ccfc .width (_agbe ._fadgg ,_ggeed );_ccdb :=_ccfc .height (_aeebfc .Width );
var _bcgfc VectorDrawable ;switch _cgbfd :=_ccfc ._cfdd .(type ){case *StyledParagraph :if _ccdb > _aeebfc .Height {_bdgda :=_aeebfc ;_bdgda .Height =_fa .Floor (_aeebfc .Height -_cgbfd ._eebag .Top -_cgbfd ._eebag .Bottom -0.5*_cgbfd .getTextHeight ());
_fafbd ,_dfae ,_cdeag :=_cgbfd .split (_bdgda );if _cdeag !=nil {return false ,_cdeag ;};if _fafbd !=nil &&_dfae !=nil {_cgbfd =_fafbd ;_ccfc =_daea (_ccfc ,_fafbd ,false );_agbe ._afbaa [_dfff ]=_ccfc ;_bcgfc =_dfae ;_aedb =true ;};_ccdb =_ccfc .height (_aeebfc .Width );
};case *Division :if _ccdb > _aeebfc .Height {_abbd :=_aeebfc ;_abbd .Height =_fa .Floor (_aeebfc .Height -_cgbfd ._ceeba .Top -_cgbfd ._ceeba .Bottom );_fgga ,_caafe :=_cgbfd .split (_abbd );if _fgga !=nil &&_caafe !=nil {_cgbfd =_fgga ;_ccfc =_daea (_ccfc ,_fgga ,false );
_agbe ._afbaa [_dfff ]=_ccfc ;_bcgfc =_caafe ;_aedb =true ;if _fgga ._dgce !=nil {_fgga ._dgce .BorderRadiusBottomLeft =0;_fgga ._dgce .BorderRadiusBottomRight =0;};if _caafe ._dgce !=nil {_caafe ._dgce .BorderRadiusTopLeft =0;_caafe ._dgce .BorderRadiusTopRight =0;
};_ccdb =_ccfc .height (_aeebfc .Width );};};case *List :if _ccdb > _aeebfc .Height {_aefagb :=_aeebfc ;_aefagb .Height =_fa .Floor (_aeebfc .Height -_cgbfd ._bffg .Vertical ());_bfdgd ,_aefgf :=_cgbfd .split (_aefagb );if _bfdgd !=nil {_cgbfd =_bfdgd ;
_ccfc =_daea (_ccfc ,_bfdgd ,false );_agbe ._afbaa [_dfff ]=_ccfc ;};if _aefgf !=nil {_bcgfc =_aefgf ;_aedb =true ;};_ccdb =_ccfc .height (_aeebfc .Width );};};_egcfe =append (_egcfe ,_ccdb );if _aedb {if _aedd ==nil {_aedd =make ([]*TableCell ,0,len (_agbe ._fadgg ));
for _fgbab :=_begga ;_fgbab < _dfff ;_fgbab ++{_aaffa (_fgbab ,nil );};};_aaffa (_dfff ,_bcgfc );};};var _gcbg float64 ;for _ ,_ggbfg :=range _egcfe {if _ggbfg > _gcbg {_gcbg =_ggbfg ;};};if _aedb &&_gcbg < _aeebfc .Height {if _dcbeg < 0{_dcbeg =len (_agbe ._afbaa );
};_ffdfa :=_agbe ._afbaa [_dcbeg -1]._eeadc +_agbe ._afbaa [_dcbeg -1]._dbbfc -1;for _beeaf :=_dcbeg ;_beeaf < len (_agbe ._afbaa );_beeaf ++{_agbe ._afbaa [_beeaf ]._eeadc ++;};_agbe ._afbaa =append (_agbe ._afbaa [:_dcbeg ],append (_aedd ,_agbe ._afbaa [_dcbeg :]...)...);
_agbe ._agda =append (_agbe ._agda [:_ffdfa ],append ([]float64 {_bcade },_agbe ._agda [_ffdfa :]...)...);_agbe ._agda [_fega ._eeadc +_fega ._dbbfc -2]=_gcbg ;};return _aedb ,nil ;};func _ceab (_ffea []_bg .Point )*Polyline {return &Polyline {_dadfd :&_bg .Polyline {Points :_ffea ,LineColor :_fee .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_eadf :1.0};
};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_agaee *Table )EnableRowWrap (enable bool ){_agaee ._cfbac =enable };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_eggg :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _eggg ;
};var _fdbd ,_debc ,_cegc int ;if len (hexStr )==4{var _aabd ,_gcgaf ,_bfeb int ;_bcee ,_edc :=_fb .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_aabd ,&_gcgaf ,&_bfeb );if _edc !=nil {_da .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_edc );
return _eggg ;};if _bcee !=3{_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _eggg ;};_fdbd =_aabd *16+_aabd ;_debc =_gcgaf *16+_gcgaf ;_cegc =_bfeb *16+_bfeb ;}else {_fec ,_dega :=_fb .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fdbd ,&_debc ,&_cegc );
if _dega !=nil {_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _eggg ;};if _fec !=3{_da .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_fec );
return _eggg ;};};_fbge :=float64 (_fdbd )/255.0;_faa :=float64 (_debc )/255.0;_dfgd :=float64 (_cegc )/255.0;_eggg ._ade =_fbge ;_eggg ._fcc =_faa ;_eggg ._fbe =_dfgd ;return _eggg ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_fcgc *Image )ScaleToHeight (h float64 ){_fcce :=_fcgc ._edda /_fcgc ._eega ;_fcgc ._eega =h ;_fcgc ._edda =h *_fcce ;};func (_adeff *Rectangle )applyFitMode (_bbgb float64 ){_bbgb -=_adeff ._gcag .Left +_adeff ._gcag .Right +_adeff ._egde ;switch _adeff ._fefc {case FitModeFillWidth :_adeff .ScaleToWidth (_bbgb );
};};type shading struct{_bbcfd Color ;_fbfeg bool ;_gcefb []bool ;_ccff []*ColorPoint ;};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_eede *Image )SetFitMode (fitMode FitMode ){_eede ._eged =fitMode };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_bcab *Creator )MoveTo (x ,y float64 ){_bcab ._ddd .X =x ;_bcab ._ddd .Y =y };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_bcgde *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_degf :=ctx ;var _aefg []*Block ;_acgd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bcgde ._eege .IsRelative (){ctx .X +=_bcgde ._eebag .Left ;ctx .Y +=_bcgde ._eebag .Top ;
ctx .Width -=_bcgde ._eebag .Left +_bcgde ._eebag .Right ;ctx .Height -=_bcgde ._eebag .Top ;_bcgde .SetWidth (ctx .Width );}else {if int (_bcgde ._cdba )<=0{_bcgde .SetWidth (_bcgde .getTextWidth ()/1000.0);};ctx .X =_bcgde ._fggg ;ctx .Y =_bcgde ._gaba ;
};if _bcgde ._dbff !=nil {_bcgde ._dbff (_bcgde ,ctx );};if _edaaa :=_bcgde .wrapText ();_edaaa !=nil {return nil ,ctx ,_edaaa ;};_eegad :=_bcgde ._cfcf ;for {_daccd ,_bdfeg ,_cbgef :=_fadcf (_acgd ,_bcgde ,_eegad ,ctx );if _cbgef !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cbgef );
return nil ,ctx ,_cbgef ;};ctx =_daccd ;_aefg =append (_aefg ,_acgd );if _eegad =_bdfeg ;len (_bdfeg )==0{break ;};_acgd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_daccd =ctx ;_daccd .Y =ctx .Margins .Top ;_daccd .X =ctx .Margins .Left +_bcgde ._eebag .Left ;
_daccd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_daccd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bcgde ._eebag .Left -_bcgde ._eebag .Right ;ctx =_daccd ;};if _bcgde ._eege .IsRelative (){ctx .Y +=_bcgde ._eebag .Bottom ;
ctx .Height -=_bcgde ._eebag .Bottom ;if !ctx .Inline {ctx .X =_degf .X ;ctx .Width =_degf .Width ;};return _aefg ,ctx ,nil ;};return _aefg ,_degf ,nil ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_ggbg *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbeb :=ctx ;if _ggbg ._cfeb .IsRelative (){ctx .X +=_ggbg ._bcbb .Left ;ctx .Y +=_ggbg ._bcbb .Top ;ctx .Width -=_ggbg ._bcbb .Left +_ggbg ._bcbb .Right ;ctx .Height -=_ggbg ._bcbb .Top ;
};_cfb ,_abde ,_bdgc :=_ggbg ._ddc .GeneratePageBlocks (ctx );if _bdgc !=nil {return _cfb ,ctx ,_bdgc ;};ctx =_abde ;_agaa :=ctx .X ;_dfa :=ctx .Y -_ggbg ._ddc .Height ();_bgf :=int64 (ctx .Page );_fbgd :=_ggbg .headingNumber ();_edd :=_ggbg .headingText ();
if _ggbg ._bge {_bfa :=_ggbg ._ede .Add (_fbgd ,_ggbg ._cdb ,_fe .FormatInt (_bgf ,10),_ggbg ._gfacd );if _ggbg ._ede ._ffag {_bfa .SetLink (_bgf ,_agaa ,_dfa );};};if _ggbg ._ddfg ==nil {_ggbg ._ddfg =_fee .NewOutlineItem (_edd ,_fee .NewOutlineDest (_bgf -1,_agaa ,_dfa ));
if _ggbg ._deea !=nil {_ggbg ._deea ._ddfg .Add (_ggbg ._ddfg );}else {_ggbg ._ecga .Add (_ggbg ._ddfg );};}else {_ega :=&_ggbg ._ddfg .Dest ;_ega .Page =_bgf -1;_ega .X =_agaa ;_ega .Y =_dfa ;};for _ ,_ddgf :=range _ggbg ._cbf {_cdef ,_egaf ,_ddee :=_ddgf .GeneratePageBlocks (ctx );
if _ddee !=nil {return _cfb ,ctx ,_ddee ;};if len (_cdef )< 1{continue ;};_cfb [len (_cfb )-1].mergeBlocks (_cdef [0]);_cfb =append (_cfb ,_cdef [1:]...);ctx =_egaf ;};if _ggbg ._cfeb .IsRelative (){ctx .X =_cbeb .X ;};if _ggbg ._cfeb .IsAbsolute (){return _cfb ,_cbeb ,nil ;
};return _cfb ,ctx ,nil ;};

// BorderColor returns the border color of the rectangle.
func (_gcgff *Rectangle )BorderColor ()Color {return _gcgff ._eggbc };

// NewList creates a new list.
func (_ebgc *Creator )NewList ()*List {return _egcf (_ebgc .NewTextStyle ())};

// SkipOver skips over a specified number of rows and cols.
func (_acfg *Table )SkipOver (rows ,cols int ){_dgge :=rows *_acfg ._fcfd +cols -1;if _dgge < 0{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_acfg ._gacbf +=_dgge ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_edge *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_geegc :=_edge ;if _edge ._cfbac {_geegc =_edge .clone ();};return _fffdc (_geegc ,ctx );};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_aceaa *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_babf :=&_aceaa ._dabee ._eebag ;return _aceaa ._gfgb ,_babf .Right ,_babf .Top ,_babf .Bottom ;};func (_gbgeg *TableCell )height (_agbgg float64 )float64 {var _eaae float64 ;switch _bedgd :=_gbgeg ._cfdd .(type ){case *Paragraph :if _bedgd ._ccee {_bedgd .SetWidth (_agbgg -_gbgeg ._bdff -_bedgd ._efbg .Left -_bedgd ._efbg .Right );
};_eaae =_bedgd .Height ()+_bedgd ._efbg .Top +_bedgd ._efbg .Bottom +0.5*_bedgd ._bgef *_bedgd ._adgg ;case *StyledParagraph :if _bedgd ._egge {_bedgd .SetWidth (_agbgg -_gbgeg ._bdff -_bedgd ._eebag .Left -_bedgd ._eebag .Right );};_eaae =_bedgd .Height ()+_bedgd ._eebag .Top +_bedgd ._eebag .Bottom +0.5*_bedgd .getTextHeight ();
case *Image :_bedgd .applyFitMode (_agbgg -_gbgeg ._bdff );_eaae =_bedgd .Height ()+_bedgd ._dgb .Top +_bedgd ._dgb .Bottom ;case *Table :_bedgd .updateRowHeights (_agbgg -_gbgeg ._bdff -_bedgd ._dceg .Left -_bedgd ._dceg .Right );_eaae =_bedgd .Height ()+_bedgd ._dceg .Top +_bedgd ._dceg .Bottom ;
case *List :_eaae =_bedgd .ctxHeight (_agbgg -_gbgeg ._bdff )+_bedgd ._bffg .Top +_bedgd ._bffg .Bottom ;case *Division :_eaae =_bedgd .ctxHeight (_agbgg -_gbgeg ._bdff )+_bedgd ._ceeba .Top +_bedgd ._ceeba .Bottom +_bedgd ._deca .Top +_bedgd ._deca .Bottom ;
case *Chart :_eaae =_bedgd .Height ()+_bedgd ._cgc .Top +_bedgd ._cgc .Bottom ;case *Rectangle :_bedgd .applyFitMode (_agbgg -_gbgeg ._bdff );_eaae =_bedgd .Height ()+_bedgd ._gcag .Top +_bedgd ._gcag .Bottom +_bedgd ._egde ;case *Ellipse :_bedgd .applyFitMode (_agbgg -_gbgeg ._bdff );
_eaae =_bedgd .Height ()+_bedgd ._fbed .Top +_bedgd ._fbed .Bottom ;case *Line :_eaae =_bedgd .Height ()+_bedgd ._cfdcg .Top +_bedgd ._cfdcg .Bottom ;};return _eaae ;};func _ddbc (_ffeff *templateProcessor ,_dagaf *templateNode )(interface{},error ){return _ffeff .parseStyledParagraph (_dagaf );
};

// SetSideBorderColor sets the cell's side border color.
func (_cfgdc *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_cfgdc ._gcac =col ;_cfgdc ._fcgg =col ;_cfgdc ._gefeb =col ;_cfgdc ._fgdgg =col ;case CellBorderSideTop :_cfgdc ._gcac =col ;case CellBorderSideBottom :_cfgdc ._fcgg =col ;
case CellBorderSideLeft :_cfgdc ._gefeb =col ;case CellBorderSideRight :_cfgdc ._fgdgg =col ;};};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_fee .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetWidthTop sets border width for top.
func (_cgb *border )SetWidthTop (bw float64 ){_cgb ._gab =bw };

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_ecef *shading ;_aaecd *_fee .PdfRectangle ;_egaae AnchorPoint ;_cbbeee float64 ;_gbfb float64 ;_cgfcf float64 ;_bbdd float64 ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_eeca *Invoice )TitleStyle ()TextStyle {return _eeca ._effe };

// Width returns the cell's width based on the input draw context.
func (_fdbdc *TableCell )Width (ctx DrawContext )float64 {_gaabe :=float64 (0.0);for _cfbb :=0;_cfbb < _fdbdc ._cdefg ;_cfbb ++{_gaabe +=_fdbdc ._fagfd ._fadgg [_fdbdc ._faga +_cfbb -1];};_dcge :=ctx .Width *_gaabe ;return _dcge ;};

// AddSection adds a new content section at the end of the invoice.
func (_fdbb *Invoice )AddSection (title ,content string ){_fdbb ._eeda =append (_fdbb ._eeda ,[2]string {title ,content });};

// SetFillColor sets the fill color.
func (_gggg *PolyBezierCurve )SetFillColor (color Color ){_gggg ._dcfb =color ;_gggg ._cceb .FillColor =_cfd (color );};func (_eddg *List )markerWidth ()float64 {var _eggb float64 ;for _ ,_gdba :=range _eddg ._fegg {_gfee :=_dccc (_eddg ._bdbe );_gfee .SetEnableWrap (false );
_gfee .SetTextAlignment (TextAlignmentRight );_gfee .Append (_gdba ._aeaf .Text ).Style =_gdba ._aeaf .Style ;_faag :=_gfee .getTextWidth ()/1000.0;if _eggb < _faag {_eggb =_faag ;};};return _eggb ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_aebf *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gabc []*Block ;_gafab =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gcded =ctx ;_begce =_aebf ._egde /2;);_gbgef :=_aebf ._fgaa .IsRelative ();if _gbgef {_aebf .applyFitMode (ctx .Width );
ctx .X +=_aebf ._gcag .Left +_begce ;ctx .Y +=_aebf ._gcag .Top +_begce ;ctx .Width -=_aebf ._gcag .Left +_aebf ._gcag .Right ;ctx .Height -=_aebf ._gcag .Top +_aebf ._gcag .Bottom ;if _aebf ._abfd > ctx .Height {_gabc =append (_gabc ,_gafab );_gafab =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_gbfd :=ctx ;_gbfd .Y =ctx .Margins .Top +_aebf ._gcag .Top +_begce ;_gbfd .X =ctx .Margins .Left +_aebf ._gcag .Left +_begce ;_gbfd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_aebf ._gcag .Top -_aebf ._gcag .Bottom ;
_gbfd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_aebf ._gcag .Left -_aebf ._gcag .Right ;ctx =_gbfd ;};}else {ctx .X =_aebf ._cfbab ;ctx .Y =_aebf ._cffbf ;};_babg :=_bg .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_aebf ._abfd ,Width :_aebf ._bfddd ,Height :_aebf ._abfd ,BorderRadiusTopLeft :_aebf ._egdce ,BorderRadiusTopRight :_aebf ._edac ,BorderRadiusBottomLeft :_aebf ._cdfge ,BorderRadiusBottomRight :_aebf ._cfef ,Opacity :1.0};
if _aebf ._cdgf !=nil {_babg .FillEnabled =true ;_afed :=_cfd (_aebf ._cdgf );_ebgdd :=_aacgba (_gafab ,_afed ,_aebf ._cdgf ,func ()Rectangle {return Rectangle {_cfbab :_babg .X ,_cffbf :_babg .Y ,_bfddd :_babg .Width ,_abfd :_babg .Height };});if _ebgdd !=nil {return nil ,ctx ,_ebgdd ;
};_babg .FillColor =_afed ;};if _aebf ._eggbc !=nil &&_aebf ._egde > 0{_babg .BorderEnabled =true ;_babg .BorderColor =_cfd (_aebf ._eggbc );_babg .BorderWidth =_aebf ._egde ;};_gaea ,_eeee :=_gafab .setOpacity (_aebf ._ffdfg ,_aebf ._cgbf );if _eeee !=nil {return nil ,ctx ,_eeee ;
};_eecag ,_ ,_eeee :=_babg .Draw (_gaea );if _eeee !=nil {return nil ,ctx ,_eeee ;};if _eeee =_gafab .addContentsByString (string (_eecag ));_eeee !=nil {return nil ,ctx ,_eeee ;};if _gbgef {ctx .X =_gcded .X ;ctx .Width =_gcded .Width ;_gageb :=_aebf ._abfd +_begce ;
ctx .Y +=_gageb +_aebf ._gcag .Bottom ;ctx .Height -=_gageb ;}else {ctx =_gcded ;};_gabc =append (_gabc ,_gafab );return _gabc ,ctx ,nil ;};func _egcf (_gbeeg TextStyle )*List {return &List {_dabcb :TextChunk {Text :"\u2022\u0020",Style :_gbeeg },_cfffc :0,_ggeg :true ,_aaab :PositionRelative ,_bdbe :_gbeeg };
};func (_fbbae *Paragraph )getMaxLineWidth ()float64 {if _fbbae ._fcda ==nil ||len (_fbbae ._fcda )==0{_fbbae .wrapText ();};var _aabf float64 ;for _ ,_degad :=range _fbbae ._fcda {_cccef :=_fbbae .getTextLineWidth (_degad );if _cccef > _aabf {_aabf =_cccef ;
};};return _aabf ;};

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_adfaf *Rectangle )FillOpacity ()float64 {return _adfaf ._ffdfg };

// SetRowHeight sets the height for a specified row.
func (_ccef *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_ccef ._agda ){return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ccef ._agda [row -1]=h ;return nil ;
};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_fdda *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func (_ddfe *StyledParagraph )wrapWordChunks (){if !_ddfe ._dffeg {return ;};var (_gfbag []*TextChunk ;_dcbe *_fee .PdfFont ;);for _ ,_cceca :=range _ddfe ._adeb {_ddaa :=[]rune (_cceca .Text );
if _dcbe ==nil {_dcbe =_cceca .Style .Font ;};_bgcc :=_cceca ._beebgd ;_adcb :=_cceca .VerticalAlignment ;if len (_gfbag )> 0{if len (_ddaa )==1&&_eb .IsPunct (_ddaa [0])&&_cceca .Style .Font ==_dcbe {_cbcdg :=[]rune (_gfbag [len (_gfbag )-1].Text );_gfbag [len (_gfbag )-1].Text =string (append (_cbcdg ,_ddaa [0]));
continue ;}else {_ ,_dgdef :=_fe .Atoi (_cceca .Text );if _dgdef ==nil {_bage :=[]rune (_gfbag [len (_gfbag )-1].Text );_bbac :=len (_bage );if _bbac >=2{_ ,_adbbf :=_fe .Atoi (string (_bage [_bbac -2]));if _adbbf ==nil &&_eb .IsPunct (_bage [_bbac -1]){_gfbag [len (_gfbag )-1].Text =string (append (_bage ,_ddaa ...));
continue ;};};};};};_ffcaa ,_ffec :=_gbac (_cceca .Text );if _ffec !=nil {_da .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_ffec );
_ffcaa =[]string {_cceca .Text };};for _ ,_gefc :=range _ffcaa {_egga :=NewTextChunk (_gefc ,_cceca .Style );_egga ._beebgd =_gfbde (_bgcc );_egga .VerticalAlignment =_adcb ;_gfbag =append (_gfbag ,_egga );};_dcbe =_cceca .Style .Font ;};if len (_gfbag )> 0{_ddfe ._adeb =_gfbag ;
};};

// WriteToFile writes the Creator output to file specified by path.
func (_eedb *Creator )WriteToFile (outputPath string )error {_babc ,_bfbb :=_fd .Create (outputPath );if _bfbb !=nil {return _bfbb ;};defer _babc .Close ();return _eedb .Write (_babc );};func (_bfde *StyledParagraph )wrapChunks (_efbf bool )error {if !_bfde ._egge ||int (_bfde ._cdba )<=0{_bfde ._cfcf =[][]*TextChunk {_bfde ._adeb };
return nil ;};if _bfde ._dffeg {_bfde .wrapWordChunks ();};_bfde ._cfcf =[][]*TextChunk {};var _cbge []*TextChunk ;var _afafc float64 ;_agea :=_eb .IsSpace ;if !_efbf {_agea =func (rune )bool {return false };};_aecf :=_gfcee (_bfde ._cdba *1000.0,0.000001);
for _ ,_gdggc :=range _bfde ._adeb {_edaeg :=_gdggc .Style ;_dgagg :=_gdggc ._beebgd ;_ebgfd :=_gdggc .VerticalAlignment ;var (_feadg []rune ;_ecaeg []float64 ;);_eeedb :=_cfcbf (_gdggc .Text );for _ ,_bcdf :=range _gdggc .Text {if _bcdf =='\u000A'{if !_efbf {_feadg =append (_feadg ,_bcdf );
};_cbge =append (_cbge ,&TextChunk {Text :_cf .TrimRightFunc (string (_feadg ),_agea ),Style :_edaeg ,_beebgd :_gfbde (_dgagg ),VerticalAlignment :_ebgfd });_bfde ._cfcf =append (_bfde ._cfcf ,_cbge );_cbge =nil ;_afafc =0;_feadg =nil ;_ecaeg =nil ;continue ;
};_cgcg :=_bcdf ==' ';_aaff ,_befee :=_edaeg .Font .GetRuneMetrics (_bcdf );if !_befee {_da .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bcdf );
return _d .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_fbfb :=_edaeg .FontSize *_aaff .Wx *_edaeg .horizontalScale ();_ceac :=_fbfb ;if !_cgcg {_ceac =_fbfb +_edaeg .CharSpacing *1000.0;
};if _afafc +_fbfb > _aecf {_ffdd :=-1;if !_cgcg {for _eeeg :=len (_feadg )-1;_eeeg >=0;_eeeg --{if _feadg [_eeeg ]==' '{_ffdd =_eeeg ;break ;};};};if _bfde ._dffeg {if len (_cbge )> 0{_bfde ._cfcf =append (_bfde ._cfcf ,_cbge );_cbge =[]*TextChunk {};
};_feadg =append (_feadg ,_bcdf );_ecaeg =append (_ecaeg ,_ceac );if _ffdd >=0{_feadg =_feadg [_ffdd +1:];_ecaeg =_ecaeg [_ffdd +1:];};_afafc =0;for _ ,_aafbf :=range _ecaeg {_afafc +=_aafbf ;};if _afafc > _aecf {_begbb :=string (_feadg [:len (_feadg )-1]);
_begbb =_bcgdb (_begbb ,_eeedb );if !_efbf &&_cgcg {_begbb +="\u0020";};_cbge =append (_cbge ,&TextChunk {Text :_cf .TrimRightFunc (_begbb ,_agea ),Style :_edaeg ,_beebgd :_gfbde (_dgagg ),VerticalAlignment :_ebgfd });_bfde ._cfcf =append (_bfde ._cfcf ,_cbge );
_cbge =[]*TextChunk {};_feadg =[]rune {_bcdf };_ecaeg =[]float64 {_ceac };_afafc =_ceac ;};continue ;};_feede :=string (_feadg );if _ffdd >=0{_feede =string (_feadg [0:_ffdd +1]);_feadg =_feadg [_ffdd +1:];_feadg =append (_feadg ,_bcdf );_ecaeg =_ecaeg [_ffdd +1:];
_ecaeg =append (_ecaeg ,_ceac );_afafc =0;for _ ,_bddd :=range _ecaeg {_afafc +=_bddd ;};}else {if _cgcg {_afafc =0;_feadg =[]rune {};_ecaeg =[]float64 {};}else {_afafc =_ceac ;_feadg =[]rune {_bcdf };_ecaeg =[]float64 {_ceac };};};_feede =_bcgdb (_feede ,_eeedb );
if !_efbf &&_cgcg {_feede +="\u0020";};_cbge =append (_cbge ,&TextChunk {Text :_cf .TrimRightFunc (_feede ,_agea ),Style :_edaeg ,_beebgd :_gfbde (_dgagg ),VerticalAlignment :_ebgfd });_bfde ._cfcf =append (_bfde ._cfcf ,_cbge );_cbge =[]*TextChunk {};
}else {_afafc +=_ceac ;_feadg =append (_feadg ,_bcdf );_ecaeg =append (_ecaeg ,_ceac );};};if len (_feadg )> 0{_cbeeb :=_bcgdb (string (_feadg ),_eeedb );_cbge =append (_cbge ,&TextChunk {Text :_cbeeb ,Style :_edaeg ,_beebgd :_gfbde (_dgagg ),VerticalAlignment :_ebgfd });
};};if len (_cbge )> 0{_bfde ._cfcf =append (_bfde ._cfcf ,_cbge );};return nil ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetStyleRight sets border style for right side.
func (_gba *border )SetStyleRight (style CellBorderStyle ){_gba ._eccg =style };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_eeae *Image )ConvertToBinary ()error {return _eeae ._dgaec .ConvertToBinary ()};

// SetAngle sets Image rotation angle in degrees.
func (_dgcea *Image )SetAngle (angle float64 ){_dgcea ._dbbd =angle };

// Color returns the color of the line.
func (_cdae *Line )Color ()Color {return _cdae ._bec };

// SetPos sets absolute positioning with specified coordinates.
func (_egaga *Paragraph )SetPos (x ,y float64 ){_egaga ._fgecf =PositionAbsolute ;_egaga ._gbfc =x ;_egaga ._bfcd =y ;};

// Context returns the current drawing context.
func (_fceg *Creator )Context ()DrawContext {return _fceg ._ddd };func (_cdfgb *templateProcessor )parseBoolAttr (_ddegd ,_eadfb string )bool {_da .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ddegd ,_eadfb );
_dfbf ,_ :=_fe .ParseBool (_eadfb );return _eadfb ==""||_dfbf ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_dgbfc *TOC )SetLineNumberStyle (style TextStyle ){_dgbfc ._bbda =style };func (_eebaf *List )ctxHeight (_fccd float64 )float64 {_fccd -=_eebaf ._cfffc ;var _defdd float64 ;for _ ,_fgac :=range _eebaf ._fegg {_defdd +=_fgac .ctxHeight (_fccd );};
return _defdd ;};type listItem struct{_eaca VectorDrawable ;_aeaf TextChunk ;};func (_eafe *templateProcessor )parseTextChunk (_eebabb *templateNode ,_fdfdg *TextChunk )(interface{},error ){if _eebabb ._bdgb ==nil {_da .Log .Error ("\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_cedeg ;};var (_cbbb =_eafe .creator .NewTextStyle ();_eafb bool ;);for _ ,_geab :=range _eebabb ._bdbga .Attr {if _geab .Name .Local =="\u006c\u0069\u006e\u006b"{_cegad ,_daag :=_eebabb ._bdgb ._bdced .(*StyledParagraph );if !_daag {_da .Log .Error ("\u004c\u0069\u006e\u006b\u0020\u0061t\u0074\u0072\u0069b\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069c\u0061\u0062\u006c\u0065\u0020to\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b");
_eafb =true ;}else {_cbbb =_cegad ._fecf ;};break ;};};if _fdfdg ==nil {_fdfdg =NewTextChunk ("",_cbbb );};for _ ,_gfege :=range _eebabb ._bdbga .Attr {_cbbf :=_gfege .Value ;switch _ebaf :=_gfege .Name .Local ;_ebaf {case "\u0063\u006f\u006co\u0072":_fdfdg .Style .Color =_eafe .parseColorAttr (_ebaf ,_cbbf );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_fdfdg .Style .OutlineColor =_eafe .parseColorAttr (_ebaf ,_cbbf );case "\u0066\u006f\u006e\u0074":_fdfdg .Style .Font =_eafe .parseFontAttr (_ebaf ,_cbbf );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_fdfdg .Style .FontSize =_eafe .parseFloatAttr (_ebaf ,_cbbf );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_fdfdg .Style .OutlineSize =_eafe .parseFloatAttr (_ebaf ,_cbbf );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_fdfdg .Style .CharSpacing =_eafe .parseFloatAttr (_ebaf ,_cbbf );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_fdfdg .Style .HorizontalScaling =_eafe .parseFloatAttr (_ebaf ,_cbbf );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_fdfdg .Style .RenderingMode =_eafe .parseTextRenderingModeAttr (_ebaf ,_cbbf );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_fdfdg .Style .Underline =_eafe .parseBoolAttr (_ebaf ,_cbbf );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_fdfdg .Style .UnderlineStyle .Color =_eafe .parseColorAttr (_ebaf ,_cbbf );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_fdfdg .Style .UnderlineStyle .Offset =_eafe .parseFloatAttr (_ebaf ,_cbbf );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_fdfdg .Style .UnderlineStyle .Thickness =_eafe .parseFloatAttr (_ebaf ,_cbbf );
case "\u006c\u0069\u006e\u006b":if !_eafb {_fdfdg ._beebgd =_eafe .parseLinkAttr (_ebaf ,_cbbf );};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_fdfdg .Style .TextRise =_eafe .parseFloatAttr (_ebaf ,_cbbf );default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ebaf );
};};return _fdfdg ,nil ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ecbcgb *TOC )SetLineTitleStyle (style TextStyle ){_ecbcgb ._gaebe =style };const (FitModeNone FitMode =iota ;FitModeFillWidth ;);

// Inline returns whether the inline mode of the division is active.
func (_abfcd *Division )Inline ()bool {return _abfcd ._agag };func (_dfbce *StyledParagraph )split (_caee DrawContext )(_eecb ,_gaeab *StyledParagraph ,_ebaec error ){if _ebaec =_dfbce .wrapChunks (false );_ebaec !=nil {return nil ,nil ,_ebaec ;};if len (_dfbce ._cfcf )==1&&_dfbce ._gbbd > _caee .Height {return _dfbce ,nil ,nil ;
};_efccd :=func (_beccd []*TextChunk ,_abcfc []*TextChunk )[]*TextChunk {if len (_abcfc )==0{return _beccd ;};_edabb :=len (_beccd );if _edabb ==0{return append (_beccd ,_abcfc ...);};if _beccd [_edabb -1].Style ==_abcfc [0].Style {_beccd [_edabb -1].Text +=_abcfc [0].Text ;
}else {_beccd =append (_beccd ,_abcfc [0]);};return append (_beccd ,_abcfc [1:]...);};_aafca :=func (_dbfc *StyledParagraph ,_abbf []*TextChunk )*StyledParagraph {if len (_abbf )==0{return nil ;};_bfbef :=*_dbfc ;_bfbef ._adeb =_abbf ;return &_bfbef ;};
var (_ffebe float64 ;_cced []*TextChunk ;_dfcce []*TextChunk ;);for _ ,_gebf :=range _dfbce ._cfcf {var _abcaf float64 ;_gcdd :=make ([]*TextChunk ,0,len (_gebf ));for _ ,_faggf :=range _gebf {if _bged :=_faggf .Style .FontSize ;_bged > _abcaf {_abcaf =_bged ;
};_gcdd =append (_gcdd ,_faggf .clone ());};_abcaf *=_dfbce ._gbbd ;if _dfbce ._eege .IsRelative (){if _ffebe +_abcaf > _caee .Height {_dfcce =_efccd (_dfcce ,_gcdd );}else {_cced =_efccd (_cced ,_gcdd );};};_ffebe +=_abcaf ;};_dfbce ._cfcf =nil ;if len (_dfcce )==0{return _dfbce ,nil ,nil ;
};return _aafca (_dfbce ,_cced ),_aafca (_dfbce ,_dfcce ),nil ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _geaa ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_cdeaf :=&Creator {};_cdeaf ._adbg =[]*_fee .PdfPage {};_cdeaf ._adcea =map[*_fee .PdfPage ]*Block {};_cdeaf ._ecbb =map[*_fee .PdfPage ]*pageTransformations {};
_cdeaf .SetPageSize (PageSizeLetter );_bacf :=0.1*_cdeaf ._aef ;_cdeaf ._bbdf .Left =_bacf ;_cdeaf ._bbdf .Right =_bacf ;_cdeaf ._bbdf .Top =_bacf ;_cdeaf ._bbdf .Bottom =_bacf ;var _debb error ;_cdeaf ._eedd ,_debb =_fee .NewStandard14Font (_fee .HelveticaName );
if _debb !=nil {_cdeaf ._eedd =_fee .DefaultFont ();};_cdeaf ._gbad ,_debb =_fee .NewStandard14Font (_fee .HelveticaBoldName );if _debb !=nil {_cdeaf ._eedd =_fee .DefaultFont ();};_cdeaf ._fgde =_cdeaf .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_cdeaf .AddOutlines =true ;_cdeaf ._aeff =_fee .NewOutline ();_ga .TrackUse (_geaa );return _cdeaf ;};

// SetSideBorderWidth sets the cell's side border width.
func (_dfbdf *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_dfbdf ._cbcbcg =width ;_dfbdf ._fabe =width ;_dfbdf ._bcdfe =width ;_dfbdf ._bdga =width ;case CellBorderSideTop :_dfbdf ._cbcbcg =width ;
case CellBorderSideBottom :_dfbdf ._fabe =width ;case CellBorderSideLeft :_dfbdf ._bcdfe =width ;case CellBorderSideRight :_dfbdf ._bdga =width ;};};func _cfbfe (_gccb string )(*GraphicSVG ,error ){_gbf ,_abea :=_aeb .ParseFromFile (_gccb );if _abea !=nil {return nil ,_abea ;
};return _caac (_gbf );};func _fbgda (_efabcf *templateProcessor ,_ffab *templateNode )(interface{},error ){return _efabcf .parseImage (_ffab );};

// Scale scales the rectangle dimensions by the specified factors.
func (_aafd *Rectangle )Scale (xFactor ,yFactor float64 ){_aafd ._bfddd =xFactor *_aafd ._bfddd ;_aafd ._abfd =yFactor *_aafd ._abfd ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_ea *Block )SetPos (x ,y float64 ){_ea ._eg =PositionAbsolute ;_ea ._ba =x ;_ea ._cd =y };

// GeneratePageBlocks draws the chart onto a block.
func (_dfgb *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfbe :=ctx ;_deb :=_dfgb ._gge .IsRelative ();var _ffge []*Block ;if _deb {_bdda :=1.0;_ecbf :=_dfgb ._cgc .Top ;if float64 (_dfgb ._edbg .Height ())> ctx .Height -_dfgb ._cgc .Top {_ffge =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _aag error ;if _ ,ctx ,_aag =_gaffdg ().GeneratePageBlocks (ctx );_aag !=nil {return nil ,ctx ,_aag ;};_ecbf =0;};ctx .X +=_dfgb ._cgc .Left +_bdda ;ctx .Y +=_ecbf ;ctx .Width -=_dfgb ._cgc .Left +_dfgb ._cgc .Right +2*_bdda ;ctx .Height -=_ecbf ;_dfgb ._edbg .SetWidth (int (ctx .Width ));
}else {ctx .X =_dfgb ._gfcd ;ctx .Y =_dfgb ._abfg ;};_abe :=_ebc .NewContentCreator ();_abe .Translate (0,ctx .PageHeight );_abe .Scale (1,-1);_abe .Translate (ctx .X ,ctx .Y );_eef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfgb ._edbg .Render (_aad .NewRenderer (_abe ,_eef ._gf ),nil );
if _afdg :=_eef .addContentsByString (_abe .String ());_afdg !=nil {return nil ,ctx ,_afdg ;};if _deb {_ebgf :=_dfgb .Height ()+_dfgb ._cgc .Bottom ;ctx .Y +=_ebgf ;ctx .Height -=_ebgf ;}else {ctx =_bfbe ;};_ffge =append (_ffge ,_eef );return _ffge ,ctx ,nil ;
};func (_fbcag *RadialShading )shadingModel ()*_fee .PdfShadingType3 {_aeede ,_adeg ,_edbc :=_fbcag ._ecef ._bbcfd .ToRGB ();var _cecb _bg .Point ;switch _fbcag ._egaae {case AnchorBottomLeft :_cecb =_bg .Point {X :_fbcag ._aaecd .Llx ,Y :_fbcag ._aaecd .Lly };
case AnchorBottomRight :_cecb =_bg .Point {X :_fbcag ._aaecd .Urx ,Y :_fbcag ._aaecd .Ury -_fbcag ._aaecd .Height ()};case AnchorTopLeft :_cecb =_bg .Point {X :_fbcag ._aaecd .Llx ,Y :_fbcag ._aaecd .Lly +_fbcag ._aaecd .Height ()};case AnchorTopRight :_cecb =_bg .Point {X :_fbcag ._aaecd .Urx ,Y :_fbcag ._aaecd .Ury };
case AnchorLeft :_cecb =_bg .Point {X :_fbcag ._aaecd .Llx ,Y :_fbcag ._aaecd .Lly +_fbcag ._aaecd .Height ()/2};case AnchorTop :_cecb =_bg .Point {X :_fbcag ._aaecd .Llx +_fbcag ._aaecd .Width ()/2,Y :_fbcag ._aaecd .Ury };case AnchorRight :_cecb =_bg .Point {X :_fbcag ._aaecd .Urx ,Y :_fbcag ._aaecd .Lly +_fbcag ._aaecd .Height ()/2};
case AnchorBottom :_cecb =_bg .Point {X :_fbcag ._aaecd .Urx +_fbcag ._aaecd .Width ()/2,Y :_fbcag ._aaecd .Lly };default:_cecb =_bg .NewPoint (_fbcag ._aaecd .Llx +_fbcag ._aaecd .Width ()/2,_fbcag ._aaecd .Lly +_fbcag ._aaecd .Height ()/2);};_eabg :=_fbcag ._cgfcf ;
_gafcf :=_fbcag ._bbdd ;_dfga :=_cecb .X +_fbcag ._cbbeee ;_eccgf :=_cecb .Y +_fbcag ._gbfb ;if _eabg ==-1.0{_eabg =0.0;};if _gafcf ==-1.0{var _caaaa []float64 ;_gaacf :=_fa .Pow (_dfga -_fbcag ._aaecd .Llx ,2)+_fa .Pow (_eccgf -_fbcag ._aaecd .Lly ,2);
_caaaa =append (_caaaa ,_fa .Abs (_gaacf ));_gbdg :=_fa .Pow (_dfga -_fbcag ._aaecd .Llx ,2)+_fa .Pow (_fbcag ._aaecd .Lly +_fbcag ._aaecd .Height ()-_eccgf ,2);_caaaa =append (_caaaa ,_fa .Abs (_gbdg ));_bdef :=_fa .Pow (_fbcag ._aaecd .Urx -_dfga ,2)+_fa .Pow (_eccgf -_fbcag ._aaecd .Ury -_fbcag ._aaecd .Height (),2);
_caaaa =append (_caaaa ,_fa .Abs (_bdef ));_dcgb :=_fa .Pow (_fbcag ._aaecd .Urx -_dfga ,2)+_fa .Pow (_fbcag ._aaecd .Ury -_eccgf ,2);_caaaa =append (_caaaa ,_fa .Abs (_dcgb ));_b .Slice (_caaaa ,func (_ebcdb ,_gcffg int )bool {return _ebcdb > _gcffg });
_gafcf =_fa .Sqrt (_caaaa [0]);};_bcbg :=&_fee .PdfRectangle {Llx :_dfga -_gafcf ,Lly :_eccgf -_gafcf ,Urx :_dfga +_gafcf ,Ury :_eccgf +_gafcf };_acdb :=_fee .NewPdfShadingType3 ();_acdb .PdfShading .ShadingType =_dd .MakeInteger (3);_acdb .PdfShading .ColorSpace =_fee .NewPdfColorspaceDeviceRGB ();
_acdb .PdfShading .Background =_dd .MakeArrayFromFloats ([]float64 {_aeede ,_adeg ,_edbc });_acdb .PdfShading .BBox =_bcbg ;_acdb .PdfShading .AntiAlias =_dd .MakeBool (_fbcag ._ecef ._fbfeg );_acdb .Coords =_dd .MakeArrayFromFloats ([]float64 {_dfga ,_eccgf ,_eabg ,_dfga ,_eccgf ,_gafcf });
_acdb .Domain =_dd .MakeArrayFromFloats ([]float64 {0.0,1.0});_acdb .Extend =_dd .MakeArray (_dd .MakeBool (_fbcag ._ecef ._gcefb [0]),_dd .MakeBool (_fbcag ._ecef ._gcefb [1]));_acdb .Function =_fbcag ._ecef .generatePdfFunctions ();return _acdb ;};func _fadcf (_bgae *Block ,_agaec *StyledParagraph ,_bddfd [][]*TextChunk ,_dcede DrawContext )(DrawContext ,[][]*TextChunk ,error ){_aceba :=1;
_geff :=_dd .PdfObjectName (_fb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aceba ));for _bgae ._gf .HasFontByName (_geff ){_aceba ++;_geff =_dd .PdfObjectName (_fb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aceba ));};_fadf :=_bgae ._gf .SetFontByName (_geff ,_agaec ._cefc .Font .ToPdfObject ());
if _fadf !=nil {return _dcede ,nil ,_fadf ;};_aceba ++;_eedg :=_geff ;_cbgbf :=_agaec ._cefc .FontSize ;_begg :=_agaec ._eege .IsRelative ();var _dcgf [][]_dd .PdfObjectName ;var _cffcf [][]*TextChunk ;var _efgfc float64 ;for _fccgc ,_ffgdd :=range _bddfd {var _aebd []_dd .PdfObjectName ;
var _gbeb float64 ;if len (_ffgdd )> 0{_gbeb =_ffgdd [0].Style .FontSize ;};for _ ,_cgdd :=range _ffgdd {_eefc :=_cgdd .Style ;if _cgdd .Text !=""&&_eefc .FontSize > _gbeb {_gbeb =_eefc .FontSize ;};_geff =_dd .PdfObjectName (_fb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aceba ));
_ecbc :=_bgae ._gf .SetFontByName (_geff ,_eefc .Font .ToPdfObject ());if _ecbc !=nil {return _dcede ,nil ,_ecbc ;};_aebd =append (_aebd ,_geff );_aceba ++;};_gbeb *=_agaec ._gbbd ;if _begg &&_efgfc +_gbeb > _dcede .Height {_cffcf =_bddfd [_fccgc :];_bddfd =_bddfd [:_fccgc ];
break ;};_efgfc +=_gbeb ;_dcgf =append (_dcgf ,_aebd );};_eegc ,_gfgae ,_addcb :=_agaec .getLineMetrics (0);_ccgf ,_fdac :=_eegc *_agaec ._gbbd ,_gfgae *_agaec ._gbbd ;if len (_bddfd )==0{return _dcede ,_cffcf ,nil ;};_egafc :=_ebc .NewContentCreator ();
_egafc .Add_q ();_cage :=_fdac ;if _agaec ._cfebc ==TextVerticalAlignmentCenter {_cage =_gfgae +(_eegc +_addcb -_gfgae )/2+(_fdac -_gfgae )/2;};_bfed :=_dcede .PageHeight -_dcede .Y -_cage ;_egafc .Translate (_dcede .X ,_bfed );_bgeeb :=_bfed ;if _agaec ._bbfc !=0{_egafc .RotateDeg (_agaec ._bbfc );
};if _agaec ._ebbd ==TextOverflowHidden {_egafc .Add_re (0,-_efgfc +_ccgf +1,_agaec ._cdba ,_efgfc ).Add_W ().Add_n ();};_egafc .Add_BT ();_gaeb :=0.0;var _agbag []*_bg .BasicLine ;for _fada ,_gfcdb :=range _bddfd {_abda :=_dcede .X ;var _affe float64 ;
if len (_gfcdb )> 0{_affe =_gfcdb [0].Style .FontSize ;};_eegc ,_ ,_addcb =_agaec .getLineMetrics (_fada );_fdac =(_eegc +_addcb );for _ ,_cdgcg :=range _gfcdb {_edeff :=&_cdgcg .Style ;if _cdgcg .Text !=""&&_edeff .FontSize > _affe {_affe =_edeff .FontSize ;
};if _fdac > _affe {_affe =_fdac ;};};if _fada !=0{_egafc .Add_TD (0,-_affe *_agaec ._gbbd +_gaeb );_bgeeb -=_affe *_agaec ._gbbd +_gaeb ;_gaeb =0.0;};_ecfag :=_fada ==len (_bddfd )-1;var (_dcfg float64 ;_bfdfc float64 ;_gbdaac *fontMetrics ;_adecee float64 ;
_cfefg uint ;);var _cagg []float64 ;for _ ,_fcfca :=range _gfcdb {_gccbe :=&_fcfca .Style ;if _gccbe .FontSize > _bfdfc {_bfdfc =_gccbe .FontSize ;_gbdaac =_eccgb (_fcfca .Style .Font ,_gccbe .FontSize );};if _fdac > _bfdfc {_bfdfc =_fdac ;};_aagbb ,_ffff :=_gccbe .Font .GetRuneMetrics (' ');
if !_ffff {return _dcede ,nil ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _ebde uint ;var _affd float64 ;_bdcff :=len (_fcfca .Text );
for _dfegf ,_gaeed :=range _fcfca .Text {if _gaeed ==' '{_ebde ++;continue ;};if _gaeed =='\u000A'{continue ;};_bafc ,_cfcg :=_gccbe .Font .GetRuneMetrics (_gaeed );if !_cfcg {_da .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_gaeed );
return _dcede ,nil ,_d .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_affd +=_gccbe .FontSize *_bafc .Wx *_gccbe .horizontalScale ();if _dfegf !=_bdcff -1{_affd +=_gccbe .CharSpacing *1000.0;
};};_cagg =append (_cagg ,_affd );_dcfg +=_affd ;_adecee +=float64 (_ebde )*_aagbb .Wx *_gccbe .FontSize *_gccbe .horizontalScale ();_cfefg +=_ebde ;};_bfdfc *=_agaec ._gbbd ;var _egbgff []_dd .PdfObject ;_ecgbb :=_agaec ._cdba *1000.0;if _agaec ._fdge ==TextAlignmentJustify {if _cfefg > 0&&!_ecfag {_adecee =(_ecgbb -_dcfg )/float64 (_cfefg )/_cbgbf ;
};}else if _agaec ._fdge ==TextAlignmentCenter {_eabd :=(_ecgbb -_dcfg -_adecee )/2;_cfee :=_eabd /_cbgbf ;_egbgff =append (_egbgff ,_dd .MakeFloat (-_cfee ));_abda +=_eabd /1000.0;}else if _agaec ._fdge ==TextAlignmentRight {_gfdf :=(_ecgbb -_dcfg -_adecee );
_ccceg :=_gfdf /_cbgbf ;_egbgff =append (_egbgff ,_dd .MakeFloat (-_ccceg ));_abda +=_gfdf /1000.0;};if len (_egbgff )> 0{_egafc .Add_Tf (_eedg ,_cbgbf ).Add_TL (_cbgbf *_agaec ._gbbd ).Add_TJ (_egbgff ...);};_acde :=0.0;for _bdfef ,_geecg :=range _gfcdb {_fbcbd :=&_geecg .Style ;
_aabge :=_eedg ;_cfgccf :=_cbgbf ;_cbgeb :=_fbcbd .OutlineColor !=nil ;_bfcfa :=_fbcbd .HorizontalScaling !=DefaultHorizontalScaling ;_gfcdc :=_fbcbd .OutlineSize !=1;if _gfcdc {_egafc .Add_w (_fbcbd .OutlineSize );};_gcfff :=_fbcbd .RenderingMode !=TextRenderingModeFill ;
if _gcfff {_egafc .Add_Tr (int64 (_fbcbd .RenderingMode ));};_afbb :=_fbcbd .CharSpacing !=0;if _afbb {_egafc .Add_Tc (_fbcbd .CharSpacing );};_fagc :=_fbcbd .TextRise !=0;if _fagc {_egafc .Add_Ts (_fbcbd .TextRise );};if _geecg .VerticalAlignment !=TextVerticalAlignmentBaseline {_ebfc :=_eccgb (_geecg .Style .Font ,_fbcbd .FontSize );
switch _geecg .VerticalAlignment {case TextVerticalAlignmentCenter :_acde =_gbdaac ._ffedb /2-_ebfc ._ffedb /2;case TextVerticalAlignmentBottom :_acde =_gbdaac ._ebggb -_ebfc ._ebggb ;case TextVerticalAlignmentTop :_acde =_gfgae -_fbcbd .FontSize ;};if _acde !=0.0{_egafc .Translate (0,_acde );
};};if _agaec ._fdge !=TextAlignmentJustify ||_ecfag {_ddba ,_baggb :=_fbcbd .Font .GetRuneMetrics (' ');if !_baggb {return _dcede ,nil ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_aabge =_dcgf [_fada ][_bdfef ];_cfgccf =_fbcbd .FontSize ;_adecee =_ddba .Wx *_fbcbd .horizontalScale ();};_cbcee :=_fbcbd .Font .Encoder ();var _decdb []byte ;for _ ,_edaee :=range _geecg .Text {if _edaee =='\u000A'{continue ;};if _edaee ==' '{if len (_decdb )> 0{if _cbgeb {_egafc .SetStrokingColor (_cfd (_fbcbd .OutlineColor ));
};if _bfcfa {_egafc .Add_Tz (_fbcbd .HorizontalScaling );};_egafc .SetNonStrokingColor (_cfd (_fbcbd .Color )).Add_Tf (_dcgf [_fada ][_bdfef ],_fbcbd .FontSize ).Add_TJ ([]_dd .PdfObject {_dd .MakeStringFromBytes (_decdb )}...);_decdb =nil ;};if _bfcfa {_egafc .Add_Tz (DefaultHorizontalScaling );
};_egafc .Add_Tf (_aabge ,_cfgccf ).Add_TJ ([]_dd .PdfObject {_dd .MakeFloat (-_adecee )}...);_cagg [_bdfef ]+=_adecee *_cfgccf ;}else {if _ ,_fadaf :=_cbcee .RuneToCharcode (_edaee );!_fadaf {_fadf =UnsupportedRuneError {Message :_fb .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_edaee ,_edaee ),Rune :_edaee };
_dcede ._ggce =append (_dcede ._ggce ,_fadf );_da .Log .Debug (_fadf .Error ());if _dcede ._cbc <=0{continue ;};_edaee =_dcede ._cbc ;};_decdb =append (_decdb ,_cbcee .Encode (string (_edaee ))...);};};if len (_decdb )> 0{if _cbgeb {_egafc .SetStrokingColor (_cfd (_fbcbd .OutlineColor ));
};if _bfcfa {_egafc .Add_Tz (_fbcbd .HorizontalScaling );};_egafc .SetNonStrokingColor (_cfd (_fbcbd .Color )).Add_Tf (_dcgf [_fada ][_bdfef ],_fbcbd .FontSize ).Add_TJ ([]_dd .PdfObject {_dd .MakeStringFromBytes (_decdb )}...);};_cgddg :=_cagg [_bdfef ]/1000.0;
if _fbcbd .Underline {_fbad :=_fbcbd .UnderlineStyle .Color ;if _fbad ==nil {_fbad =_geecg .Style .Color ;};_aeba ,_fabge ,_cbcbc :=_fbad .ToRGB ();_gebc :=_abda -_dcede .X ;_egbc :=_bgeeb -_bfed +_fbcbd .TextRise -_fbcbd .UnderlineStyle .Offset ;_agbag =append (_agbag ,&_bg .BasicLine {X1 :_gebc ,Y1 :_egbc ,X2 :_gebc +_cgddg ,Y2 :_egbc ,LineWidth :_geecg .Style .UnderlineStyle .Thickness ,LineColor :_fee .NewPdfColorDeviceRGB (_aeba ,_fabge ,_cbcbc )});
};if _geecg ._beebgd !=nil {var _bdgd *_dd .PdfObjectArray ;if !_geecg ._bacff {switch _dcdd :=_geecg ._beebgd .GetContext ().(type ){case *_fee .PdfAnnotationLink :_bdgd =_dd .MakeArray ();_dcdd .Rect =_bdgd ;_cbca ,_acefd :=_dcdd .Dest .(*_dd .PdfObjectArray );
if _acefd &&_cbca .Len ()==5{_gebfg ,_dbddd :=_cbca .Get (1).(*_dd .PdfObjectName );if _dbddd &&_gebfg .String ()=="\u0058\u0059\u005a"{_afcgg ,_ddge :=_dd .GetNumberAsFloat (_cbca .Get (3));if _ddge ==nil {_cbca .Set (3,_dd .MakeFloat (_dcede .PageHeight -_afcgg ));
};};};};_geecg ._bacff =true ;};if _bdgd !=nil {_abga :=_bg .NewPoint (_abda -_dcede .X ,_bgeeb +_fbcbd .TextRise -_bfed ).Rotate (_agaec ._bbfc );_abga .X +=_dcede .X ;_abga .Y +=_bfed ;_ebdfg ,_aefag ,_ddaf ,_dgdd :=_abcbd (_cgddg ,_bfdfc ,_agaec ._bbfc );
_abga .X +=_ebdfg ;_abga .Y +=_aefag ;_bdgd .Clear ();_bdgd .Append (_dd .MakeFloat (_abga .X ));_bdgd .Append (_dd .MakeFloat (_abga .Y ));_bdgd .Append (_dd .MakeFloat (_abga .X +_ddaf ));_bdgd .Append (_dd .MakeFloat (_abga .Y +_dgdd ));};_bgae .AddAnnotation (_geecg ._beebgd );
};_abda +=_cgddg ;if _gfcdc {_egafc .Add_w (1.0);};if _cbgeb {_egafc .Add_RG (0.0,0.0,0.0);};if _gcfff {_egafc .Add_Tr (int64 (TextRenderingModeFill ));};if _afbb {_egafc .Add_Tc (0);};if _fagc {_egafc .Add_Ts (0);};if _bfcfa {_egafc .Add_Tz (DefaultHorizontalScaling );
};if _acde !=0.0{_egafc .Translate (0,-_acde );_acde =0.0;};};};_egafc .Add_ET ();for _ ,_fffd :=range _agbag {_egafc .SetStrokingColor (_fffd .LineColor ).Add_w (_fffd .LineWidth ).Add_m (_fffd .X1 ,_fffd .Y1 ).Add_l (_fffd .X2 ,_fffd .Y2 ).Add_s ();};
_egafc .Add_Q ();_acdf :=_egafc .Operations ();_acdf .WrapIfNeeded ();_bgae .addContents (_acdf );if _begg {_gffc :=_efgfc ;_dcede .Y +=_gffc ;_dcede .Height -=_gffc ;if _dcede .Inline {_dcede .X +=_agaec .Width ()+_agaec ._eebag .Right ;};};return _dcede ,_cffcf ,nil ;
};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_baff *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_baff ._eeef =alignment };

// SetMargins sets the margins TOC line.
func (_faacbe *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_faacbe ._gfgb =left ;_gecga :=&_faacbe ._dabee ._eebag ;_gecga .Left =_faacbe ._gfgb +float64 (_faacbe ._bbec -1)*_faacbe ._eedde ;_gecga .Right =right ;_gecga .Top =top ;_gecga .Bottom =bottom ;
};func _ccea (_gfggc *Block ,_faaga *Paragraph ,_agff DrawContext )(DrawContext ,error ){_ebag :=1;_afab :=_dd .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fe .Itoa (_ebag ));for _gfggc ._gf .HasFontByName (_afab ){_ebag ++;_afab =_dd .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fe .Itoa (_ebag ));
};_eaff :=_gfggc ._gf .SetFontByName (_afab ,_faaga ._gbdaa .ToPdfObject ());if _eaff !=nil {return _agff ,_eaff ;};_faaga .wrapText ();_efdde :=_ebc .NewContentCreator ();_efdde .Add_q ();_faaf :=_agff .PageHeight -_agff .Y -_faaga ._bgef *_faaga ._adgg ;
_efdde .Translate (_agff .X ,_faaf );if _faaga ._abgcb !=0{_efdde .RotateDeg (_faaga ._abgcb );};_dgag :=_cfd (_faaga ._cfae );_eaff =_aacgba (_gfggc ,_dgag ,_faaga ._cfae ,func ()Rectangle {return Rectangle {_cfbab :_agff .X ,_cffbf :_faaf ,_bfddd :_faaga .getMaxLineWidth ()/1000.0,_abfd :_faaga .Height ()};
});if _eaff !=nil {return _agff ,_eaff ;};_efdde .Add_BT ().SetNonStrokingColor (_dgag ).Add_Tf (_afab ,_faaga ._bgef ).Add_TL (_faaga ._bgef *_faaga ._adgg );for _bdfe ,_edfa :=range _faaga ._fcda {if _bdfe !=0{_efdde .Add_Tstar ();};_dceb :=[]rune (_edfa );
_fbgdf :=0.0;_aebb :=0;for _eggd ,_fgcda :=range _dceb {if _fgcda ==' '{_aebb ++;continue ;};if _fgcda =='\u000A'{continue ;};_fbgb ,_adggc :=_faaga ._gbdaa .GetRuneMetrics (_fgcda );if !_adggc {_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_eggd ,_fgcda ,_fgcda ,_faaga ._gbdaa .BaseFont (),_faaga ._gbdaa .Subtype ());
return _agff ,_d .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_fbgdf +=_faaga ._bgef *_fbgb .Wx ;};var _agab []_dd .PdfObject ;_gga ,_fbab :=_faaga ._gbdaa .GetRuneMetrics (' ');
if !_fbab {return _agff ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ead :=_gga .Wx ;switch _faaga ._afcfe {case TextAlignmentJustify :if _aebb > 0&&_bdfe < len (_faaga ._fcda )-1{_ead =(_faaga ._bgdg *1000.0-_fbgdf )/float64 (_aebb )/_faaga ._bgef ;
};case TextAlignmentCenter :_ddbd :=_fbgdf +float64 (_aebb )*_ead *_faaga ._bgef ;_bfag :=(_faaga ._bgdg *1000.0-_ddbd )/2/_faaga ._bgef ;_agab =append (_agab ,_dd .MakeFloat (-_bfag ));case TextAlignmentRight :_cceg :=_fbgdf +float64 (_aebb )*_ead *_faaga ._bgef ;
_fege :=(_faaga ._bgdg *1000.0-_cceg )/_faaga ._bgef ;_agab =append (_agab ,_dd .MakeFloat (-_fege ));};_ccaf :=_faaga ._gbdaa .Encoder ();var _abffd []byte ;for _ ,_cbga :=range _dceb {if _cbga =='\u000A'{continue ;};if _cbga ==' '{if len (_abffd )> 0{_agab =append (_agab ,_dd .MakeStringFromBytes (_abffd ));
_abffd =nil ;};_agab =append (_agab ,_dd .MakeFloat (-_ead ));}else {if _ ,_facf :=_ccaf .RuneToCharcode (_cbga );!_facf {_eaff =UnsupportedRuneError {Message :_fb .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cbga ,_cbga ),Rune :_cbga };
_agff ._ggce =append (_agff ._ggce ,_eaff );_da .Log .Debug (_eaff .Error ());if _agff ._cbc <=0{continue ;};_cbga =_agff ._cbc ;};_abffd =append (_abffd ,_ccaf .Encode (string (_cbga ))...);};};if len (_abffd )> 0{_agab =append (_agab ,_dd .MakeStringFromBytes (_abffd ));
};_efdde .Add_TJ (_agab ...);};_efdde .Add_ET ();_efdde .Add_Q ();_feec :=_efdde .Operations ();_feec .WrapIfNeeded ();_gfggc .addContents (_feec );if _faaga ._fgecf .IsRelative (){_adga :=_faaga .Height ();_agff .Y +=_adga ;_agff .Height -=_adga ;if _agff .Inline {_agff .X +=_faaga .Width ()+_faaga ._efbg .Right ;
};};return _agff ,nil ;};func (_dbe *Block )translate (_ad ,_ac float64 ){_df :=_ebc .NewContentCreator ().Translate (_ad ,-_ac ).Operations ();*_dbe ._db =append (*_df ,*_dbe ._db ...);_dbe ._db .WrapIfNeeded ();};const (TextOverflowVisible TextOverflow =iota ;
TextOverflowHidden ;);

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_bgfe *shading )SetExtends (start bool ,end bool ){_bgfe ._gcefb =[]bool {start ,end }};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func (_gcgg *templateProcessor )parseColor (_ddbda string )Color {if _ddbda ==""{return nil ;};_dage ,_bgfdf :=_gcgg ._deag .ColorMap [_ddbda ];if _bgfdf {return _dage ;};if _ddbda [0]=='#'{return ColorRGBFromHex (_ddbda );};return nil ;
};

// NewImageFromData creates an Image from image data.
func (_edg *Creator )NewImageFromData (data []byte )(*Image ,error ){return _abgd (data )};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_efcc *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _efcc ._agebg [0],_efcc ._agebg [1]};

// Length calculates and returns the length of the line.
func (_ecfg *Line )Length ()float64 {return _fa .Sqrt (_fa .Pow (_ecfg ._ecec -_ecfg ._bcgf ,2.0)+_fa .Pow (_ecfg ._daac -_ecfg ._fgba ,2.0));};func (_cfffd *TableCell )width (_cagc []float64 ,_caafg float64 )float64 {_fgbdde :=float64 (0.0);for _dbeg :=0;
_dbeg < _cfffd ._cdefg ;_dbeg ++{_fgbdde +=_cagc [_cfffd ._faga +_dbeg -1];};return _fgbdde *_caafg ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cbgdf *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cbgdf ._cdfcd =halign ;};func (_cccd *Creator )initContext (){_cccd ._ddd .X =_cccd ._bbdf .Left ;_cccd ._ddd .Y =_cccd ._bbdf .Top ;_cccd ._ddd .Width =_cccd ._aef -_cccd ._bbdf .Right -_cccd ._bbdf .Left ;
_cccd ._ddd .Height =_cccd ._cec -_cccd ._bbdf .Bottom -_cccd ._bbdf .Top ;_cccd ._ddd .PageHeight =_cccd ._cec ;_cccd ._ddd .PageWidth =_cccd ._aef ;_cccd ._ddd .Margins =_cccd ._bbdf ;_cccd ._ddd ._cbc =_cccd .UnsupportedCharacterReplacement ;};

// SetFillOpacity sets the fill opacity.
func (_efgc *CurvePolygon )SetFillOpacity (opacity float64 ){_efgc ._febb =opacity };

// Logo returns the logo of the invoice.
func (_ggcd *Invoice )Logo ()*Image {return _ggcd ._gaffd };

// Width returns Image's document width.
func (_ffeb *Image )Width ()float64 {return _ffeb ._edda };

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_cbce *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cbce ._fbed .Left ,_cbce ._fbed .Right ,_cbce ._fbed .Top ,_cbce ._fbed .Bottom ;};func (_aeebb *StyledParagraph )getTextLineWidth (_gabf []*TextChunk )float64 {var _cdfd float64 ;
_gagbc :=len (_gabf );for _adffa ,_acef :=range _gabf {_feeaf :=&_acef .Style ;_fggge :=len (_acef .Text );for _befb ,_afcaf :=range _acef .Text {if _afcaf =='\u000A'{continue ;};_cgeg ,_fbag :=_feeaf .Font .GetRuneMetrics (_afcaf );if !_fbag {_da .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_afcaf );
return -1;};_cdfd +=_feeaf .FontSize *_cgeg .Wx *_feeaf .horizontalScale ();if _afcaf !=' '&&(_adffa !=_gagbc -1||_befb !=_fggge -1){_cdfd +=_feeaf .CharSpacing *1000.0;};};};return _cdfd ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_bce *Block )ScaleToHeight (h float64 ){_gae :=h /_bce ._egb ;_bce .Scale (_gae ,_gae )};

// SetBorderRadius sets the radius of the background corners.
func (_cb *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_cb .BorderRadiusTopLeft =topLeft ;_cb .BorderRadiusTopRight =topRight ;_cb .BorderRadiusBottomLeft =bottomLeft ;_cb .BorderRadiusBottomRight =bottomRight ;};

// RotatedSize returns the width and height of the rotated block.
func (_feed *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_dgc ,_gfc :=_abcbd (_feed ._bab ,_feed ._egb ,_feed ._gc );return _dgc ,_gfc ;};

// SetLogo sets the logo of the invoice.
func (_afcea *Invoice )SetLogo (logo *Image ){_afcea ._gaffd =logo };func (_ecgbbg *templateProcessor )parseLineStyleAttr (_ccbgf ,_fgae string )_bg .LineStyle {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ccbgf ,_fgae );
_bdbc :=map[string ]_bg .LineStyle {"\u0073\u006f\u006ci\u0064":_bg .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_bg .LineStyleDashed }[_fgae ];return _bdbc ;};func (_edcdb *templateProcessor )parseEllipse (_abddc *templateNode )(interface{},error ){_afagc :=_edcdb .creator .NewEllipse (0,0,0,0);
for _ ,_egdef :=range _abddc ._bdbga .Attr {_eebb :=_egdef .Value ;switch _agcf :=_egdef .Name .Local ;_agcf {case "\u0063\u0078":_afagc ._gbd =_edcdb .parseFloatAttr (_agcf ,_eebb );case "\u0063\u0079":_afagc ._efd =_edcdb .parseFloatAttr (_agcf ,_eebb );
case "\u0077\u0069\u0064t\u0068":_afagc .SetWidth (_edcdb .parseFloatAttr (_agcf ,_eebb ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_afagc .SetHeight (_edcdb .parseFloatAttr (_agcf ,_eebb ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_afagc .SetFillColor (_edcdb .parseColorAttr (_agcf ,_eebb ));
case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_afagc .SetFillOpacity (_edcdb .parseFloatAttr (_agcf ,_eebb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_afagc .SetBorderColor (_edcdb .parseColorAttr (_agcf ,_eebb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_afagc .SetBorderOpacity (_edcdb .parseFloatAttr (_agcf ,_eebb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_afagc .SetBorderWidth (_edcdb .parseFloatAttr (_agcf ,_eebb ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_afagc .SetPositioning (_edcdb .parsePositioningAttr (_agcf ,_eebb ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_afagc .SetFitMode (_edcdb .parseFitModeAttr (_agcf ,_eebb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gfge :=_edcdb .parseMarginAttr (_agcf ,_eebb );
_afagc .SetMargins (_gfge .Left ,_gfge .Right ,_gfge .Top ,_gfge .Bottom );default:_da .Log .Debug ("\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_agcf );
};};return _afagc ,nil ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_eddf *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_defc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ccbfb ,_ ,_cbbg :=_eddf .draw (_defc ,"");if _cbbg !=nil {return nil ,ctx ,_cbbg ;};_cbbg =_defc .addContentsByString (string (_ccbfb ));
if _cbbg !=nil {return nil ,ctx ,_cbbg ;};return []*Block {_defc },ctx ,nil ;};func (_gfaf *Invoice )setCellBorder (_gfef *TableCell ,_cdfbc *InvoiceCell ){for _ ,_bdfd :=range _cdfbc .BorderSides {_gfef .SetBorder (_bdfd ,CellBorderStyleSingle ,_cdfbc .BorderWidth );
};_gfef .SetBorderColor (_cdfbc .BorderColor );};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_beefd *TOC )SetLineStyle (style TextStyle ){_beefd .SetLineNumberStyle (style );_beefd .SetLineTitleStyle (style );_beefd .SetLineSeparatorStyle (style );_beefd .SetLinePageStyle (style );};func _gcdc (_gebb *Creator ,_deae _fg .Reader ,_fffg interface{},_edacc *TemplateOptions ,_dbgd componentRenderer )error {if _gebb ==nil {_da .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _eacgc ;};_aefeb :=_c .NewBuffer (nil );if _ ,_cdacc :=_fg .Copy (_aefeb ,_deae );_cdacc !=nil {return _cdacc ;};_cfad :=_ff .FuncMap {"\u0064\u0069\u0063\u0074":_bgfac };if _edacc !=nil &&_edacc .HelperFuncMap !=nil {for _ccfa ,_dffeb :=range _edacc .HelperFuncMap {if _ ,_ebaaf :=_cfad [_ccfa ];
_ebaaf {_da .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ccfa );
continue ;};_cfad [_ccfa ]=_dffeb ;};};_becca ,_bgde :=_ff .New ("").Funcs (_cfad ).Parse (_aefeb .String ());if _bgde !=nil {return _bgde ;};if _edacc !=nil &&_edacc .SubtemplateMap !=nil {for _acca ,_ebeab :=range _edacc .SubtemplateMap {if _acca ==""{_da .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _ebeab ==nil {_da .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_gecbg :=_c .NewBuffer (nil );if _ ,_deeec :=_fg .Copy (_gecbg ,_ebeab );_deeec !=nil {return _deeec ;};if _ ,_cdee :=_becca .New (_acca ).Parse (_gecbg .String ());_cdee !=nil {return _cdee ;};};};_aefeb .Reset ();if _aeega :=_becca .Execute (_aefeb ,_fffg );
_aeega !=nil {return _aeega ;};return _ggad (_gebb ,_aefeb .Bytes (),_edacc ,_dbgd ).run ();};func (_cbfec *templateProcessor )parseChapter (_efdg *templateNode )(interface{},error ){_geef :=_cbfec .creator .NewChapter ;if _efdg ._bdgb !=nil {if _cgfd ,_ddeg :=_efdg ._bdgb ._bdced .(*Chapter );
_ddeg {_geef =_cgfd .NewSubchapter ;};};_bddg :=_geef ("");for _ ,_feff :=range _efdg ._bdbga .Attr {_bebd :=_feff .Value ;switch _agagc :=_feff .Name .Local ;_agagc {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_bddg .SetShowNumbering (_cbfec .parseBoolAttr (_agagc ,_bebd ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_bddg .SetIncludeInTOC (_cbfec .parseBoolAttr (_agagc ,_bebd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ceagd :=_cbfec .parseMarginAttr (_agagc ,_bebd );_bddg .SetMargins (_ceagd .Left ,_ceagd .Right ,_ceagd .Top ,_ceagd .Bottom );
default:_da .Log .Debug ("\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_agagc );
};};return _bddg ,nil ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_beab *Invoice )SetAddressStyle (style TextStyle ){_beab ._bdbg =style };

// AddTotalLine adds a new line in the invoice totals table.
func (_afcc *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_bfcf :=&InvoiceCell {_afcc ._afdac ,desc };_gdae :=&InvoiceCell {_afcc ._afdac ,value };_afcc ._gcffc =append (_afcc ._gcffc ,[2]*InvoiceCell {_bfcf ,_gdae });return _bfcf ,_gdae ;
};func _gbac (_dffgb string )([]string ,error ){var (_gadb []string ;_acec []rune ;);for _ ,_ffbae :=range _dffgb {if _ffbae =='\u000A'{if len (_acec )> 0{_gadb =append (_gadb ,string (_acec ));};_gadb =append (_gadb ,string (_ffbae ));_acec =nil ;continue ;
};_acec =append (_acec ,_ffbae );};if len (_acec )> 0{_gadb =append (_gadb ,string (_acec ));};var _fbff []string ;for _ ,_cfaab :=range _gadb {_eddag :=[]rune (_cfaab );_cbebg :=_g .NewScanner (_eddag );var _fgfc []rune ;for _dgaf :=0;_dgaf < len (_eddag );
_dgaf ++{_ ,_fdcb ,_afagb :=_cbebg .Next ();if _afagb !=nil {return nil ,_afagb ;};if _fdcb ==_g .BreakProhibited ||_eb .IsSpace (_eddag [_dgaf ]){_fgfc =append (_fgfc ,_eddag [_dgaf ]);if _eb .IsSpace (_eddag [_dgaf ]){_fbff =append (_fbff ,string (_fgfc ));
_fgfc =[]rune {};};continue ;}else {if len (_fgfc )> 0{_fbff =append (_fbff ,string (_fgfc ));};_fgfc =[]rune {_eddag [_dgaf ]};};};if len (_fgfc )> 0{_fbff =append (_fbff ,string (_fgfc ));};};return _fbff ,nil ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_afe *Chart )SetPos (x ,y float64 ){_afe ._gge =PositionAbsolute ;_afe ._gfcd =x ;_afe ._abfg =y };func (_fbef *Image )rotatedSize ()(float64 ,float64 ){_ffca :=_fbef ._edda ;_eaeg :=_fbef ._eega ;_adac :=_fbef ._dbbd ;if _adac ==0{return _ffca ,_eaeg ;
};_cbbc :=_bg .Path {Points :[]_bg .Point {_bg .NewPoint (0,0).Rotate (_adac ),_bg .NewPoint (_ffca ,0).Rotate (_adac ),_bg .NewPoint (0,_eaeg ).Rotate (_adac ),_bg .NewPoint (_ffca ,_eaeg ).Rotate (_adac )}}.GetBoundingBox ();return _cbbc .Width ,_cbbc .Height ;
};

// SetLineHeight sets the line height (1.0 default).
func (_deead *StyledParagraph )SetLineHeight (lineheight float64 ){_deead ._gbbd =lineheight };var _accae =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_agdb :_ddbc },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_gagf :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_agdb :_cbgdfe },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_agdb :_dgefe },"\u0074\u0061\u0062l\u0065":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_agdb :_gffde },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_gagf :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_agdb :_dgga },"\u006c\u0069\u006e\u0065":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_agdb :_eeea },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_agdb :_fcfce },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_agdb :_aagf },"\u0069\u006d\u0061g\u0065":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_agdb :_fbgda },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_agdb :_ffcc },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_gagf :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_agdb :_fgbddeg },"\u0063\u0068\u0061r\u0074":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_agdb :_geegg },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_agdb :_bdcgb },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_gagf :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_agdb :_cefa },"\u006c\u0069\u0073\u0074":&templateTag {_gagf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_agdb :_gcabd },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_gagf :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_agdb :_eaead },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_gagf :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_agdb :_edafc }};


// SetBorderColor sets the border color of the ellipse.
func (_bfbg *Ellipse )SetBorderColor (col Color ){_bfbg ._fdfd =col };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_fbga *Creator )RotateDeg (angleDeg int64 )error {_edfc :=_fbga .getActivePage ();if _edfc ==nil {_da .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _d .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_da .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _cac int64 ;if _edfc .Rotate !=nil {_cac =*(_edfc .Rotate );};_cac +=angleDeg ;_edfc .Rotate =&_cac ;return nil ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_dacgf *StyledParagraph )SetText (text string )*TextChunk {_dacgf .Reset ();return _dacgf .Append (text );};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);func (_fgcg *Chapter )headingText ()string {_bae :=_fgcg ._cdb ;
if _gfg :=_fgcg .headingNumber ();_gfg !=""{_bae =_fb .Sprintf ("\u0025\u0073\u0020%\u0073",_gfg ,_bae );};return _bae ;};

// SetAngle sets the rotation angle in degrees.
func (_cde *Block )SetAngle (angleDeg float64 ){_cde ._gc =angleDeg };

// Angle returns the block rotation angle in degrees.
func (_gff *Block )Angle ()float64 {return _gff ._gc };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_dabcd *Creator )NewStyledParagraph ()*StyledParagraph {return _dccc (_dabcd .NewTextStyle ())};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_fad Drawable )(Drawable ,error );};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_bcbd *Image )SetMargins (left ,right ,top ,bottom float64 ){_bcbd ._dgb .Left =left ;_bcbd ._dgb .Right =right ;_bcbd ._dgb .Top =top ;_bcbd ._dgb .Bottom =bottom ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_gada *RadialShading )ToPdfShadingPattern ()*_fee .PdfShadingPatternType3 {_geeg ,_faec ,_ecece :=_gada ._ecef ._bbcfd .ToRGB ();_cedg :=_gada .shadingModel ();_cedg .PdfShading .Background =_dd .MakeArrayFromFloats ([]float64 {_geeg ,_faec ,_ecece });
_fadc :=_fee .NewPdfShadingPatternType3 ();_fadc .Shading =_cedg ;return _fadc ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_cceb *_bg .PolyBezierCurve ;_aabg float64 ;_ebef float64 ;_dcfb Color ;};func (_degd *StyledParagraph )wrapText ()error {return _degd .wrapChunks (true )};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_abca *List )Add (item VectorDrawable )(*TextChunk ,error ){_efccg :=&listItem {_eaca :item ,_aeaf :_abca ._dabcb };switch _facc :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _facc ._ggeg {_facc ._cfffc =15;};case *Division :case *Image :case *Table :default:return nil ,_d .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_abca ._fegg =append (_abca ._fegg ,_efccg );return &_efccg ._aeaf ,nil ;};func _fffdc (_bgfb *Table ,_deda DrawContext )([]*Block ,DrawContext ,error ){var _fage []*Block ;_bfgaa :=NewBlock (_deda .PageWidth ,_deda .PageHeight );_bgfb .updateRowHeights (_deda .Width -_bgfb ._dceg .Left -_bgfb ._dceg .Right );
_geba :=_bgfb ._dceg .Top ;if _bgfb ._caga .IsRelative ()&&!_bgfb ._edcc {_gfgc :=_bgfb .Height ();if _gfgc > _deda .Height -_bgfb ._dceg .Top &&_gfgc <=_deda .PageHeight -_deda .Margins .Top -_deda .Margins .Bottom {_fage =[]*Block {NewBlock (_deda .PageWidth ,_deda .PageHeight -_deda .Y )};
var _dgaeb error ;if _ ,_deda ,_dgaeb =_gaffdg ().GeneratePageBlocks (_deda );_dgaeb !=nil {return nil ,_deda ,_dgaeb ;};_geba =0;};};_bgba :=_deda ;if _bgfb ._caga .IsAbsolute (){_deda .X =_bgfb ._bccdf ;_deda .Y =_bgfb ._fedc ;}else {_deda .X +=_bgfb ._dceg .Left ;
_deda .Y +=_geba ;_deda .Width -=_bgfb ._dceg .Left +_bgfb ._dceg .Right ;_deda .Height -=_geba ;};_acge :=_deda .Width ;_dabfa :=_deda .X ;_egadf :=_deda .Y ;_dgddb :=_deda .Height ;_abdf :=0;_bbcdb ,_fdcafg :=-1,-1;if _bgfb ._dgaa {for _gddgg ,_gadda :=range _bgfb ._afbaa {if _gadda ._eeadc < _bgfb ._cfcgb {continue ;
};if _gadda ._eeadc > _bgfb ._bgda {break ;};if _bbcdb < 0{_bbcdb =_gddgg ;};_fdcafg =_gddgg ;};};if _adefc :=_bgfb .wrapContent (_deda );_adefc !=nil {return nil ,_deda ,_adefc ;};_bgfb .updateRowHeights (_deda .Width -_bgfb ._dceg .Left -_bgfb ._dceg .Right );
var (_agbf bool ;_dfgba int ;_edea int ;_eebg bool ;_fadd int ;_cbgd error ;);for _gbgdb :=0;_gbgdb < len (_bgfb ._afbaa );_gbgdb ++{_gbafg :=_bgfb ._afbaa [_gbgdb ];_fedg :=_gbafg .width (_bgfb ._fadgg ,_acge );_fbgdfa :=float64 (0.0);for _gbfg :=0;_gbfg < _gbafg ._faga -1;
_gbfg ++{_fbgdfa +=_bgfb ._fadgg [_gbfg ]*_acge ;};_feedc :=float64 (0.0);for _cgcfg :=_abdf ;_cgcfg < _gbafg ._eeadc -1;_cgcfg ++{_feedc +=_bgfb ._agda [_cgcfg ];};_deda .Height =_dgddb -_feedc ;_afbce :=float64 (0.0);for _cafdd :=0;_cafdd < _gbafg ._dbbfc ;
_cafdd ++{_afbce +=_bgfb ._agda [_gbafg ._eeadc +_cafdd -1];};_ffebc :=_eebg &&_gbafg ._eeadc !=_fadd ;_fadd =_gbafg ._eeadc ;if _ffebc ||_afbce > _deda .Height {if _bgfb ._cfbac &&!_eebg {_eebg ,_cbgd =_bgfb .wrapRow (_gbgdb ,_deda ,_acge );if _cbgd !=nil {return nil ,_deda ,_cbgd ;
};if _eebg {_gbgdb --;continue ;};_ffebc =true ;};_fage =append (_fage ,_bfgaa );_bfgaa =NewBlock (_deda .PageWidth ,_deda .PageHeight );_dabfa =_deda .Margins .Left +_bgfb ._dceg .Left ;_egadf =_deda .Margins .Top ;_deda .Height =_deda .PageHeight -_deda .Margins .Top -_deda .Margins .Bottom ;
_deda .Page ++;_dgddb =_deda .Height ;_abdf =_gbafg ._eeadc -1;_feedc =0;_eebg =false ;if _bgfb ._dgaa &&_bbcdb >=0{_dfgba =_gbgdb ;_gbgdb =_bbcdb -1;_edea =_abdf ;_abdf =_bgfb ._cfcgb -1;_agbf =true ;if _gbafg ._dbbfc > (_bgfb ._edde -_fadd )||(_gbafg ._dbbfc > 1&&_gbgdb < 0){_da .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_agbf =false ;_bbcdb ,_fdcafg =-1,-1;};continue ;};if _ffebc {_gbgdb --;continue ;};};_deda .Width =_fedg ;_deda .X =_dabfa +_fbgdfa ;_deda .Y =_egadf +_feedc ;_daacc :=_gfac (_deda .X ,_deda .Y ,_fedg ,_afbce );if _gbafg ._cafg !=nil {_daacc .SetFillColor (_gbafg ._cafg );
};_daacc .LineStyle =_gbafg ._gaeaa ;_daacc ._ece =_gbafg ._fgfda ;_daacc ._eccg =_gbafg ._egea ;_daacc ._cffc =_gbafg ._acdfc ;_daacc ._beb =_gbafg ._gefeba ;if _gbafg ._gefeb !=nil {_daacc .SetColorLeft (_gbafg ._gefeb );};if _gbafg ._fcgg !=nil {_daacc .SetColorBottom (_gbafg ._fcgg );
};if _gbafg ._fgdgg !=nil {_daacc .SetColorRight (_gbafg ._fgdgg );};if _gbafg ._gcac !=nil {_daacc .SetColorTop (_gbafg ._gcac );};_daacc .SetWidthBottom (_gbafg ._fabe );_daacc .SetWidthLeft (_gbafg ._bcdfe );_daacc .SetWidthRight (_gbafg ._bdga );_daacc .SetWidthTop (_gbafg ._cbcbcg );
_fabf :=_bfgaa .Draw (_daacc );if _fabf !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fabf );};if _gbafg ._cfdd !=nil {_bdfge :=_gbafg ._cfdd .Width ();_fcfe :=_gbafg ._cfdd .Height ();_fefd :=0.0;switch _caagd :=_gbafg ._cfdd .(type ){case *Paragraph :if _caagd ._ccee {_bdfge =_caagd .getMaxLineWidth ()/1000.0;
};_bdfge +=_caagd ._efbg .Left +_caagd ._efbg .Right ;_fcfe +=_caagd ._efbg .Top +_caagd ._efbg .Bottom ;case *StyledParagraph :if _caagd ._egge {_bdfge =_caagd .getMaxLineWidth ()/1000.0;};_abgb ,_bdcfd ,_bgeee :=_caagd .getLineMetrics (0);_deebc ,_aecb :=_abgb *_caagd ._gbbd ,_bdcfd *_caagd ._gbbd ;
if _caagd ._cfebc ==TextVerticalAlignmentCenter {_fefd =_aecb -(_bdcfd +(_abgb +_bgeee -_bdcfd )/2+(_aecb -_bdcfd )/2);};if len (_caagd ._cfcf )==1{_fcfe =_deebc ;}else {_fcfe =_fcfe -_aecb +_deebc ;};_fefd +=_deebc -_aecb ;switch _gbafg ._egfeb {case CellVerticalAlignmentTop :_fefd +=_deebc *0.5;
case CellVerticalAlignmentBottom :_fefd -=_deebc *0.5;};_bdfge +=_caagd ._eebag .Left +_caagd ._eebag .Right ;_fcfe +=_caagd ._eebag .Top +_caagd ._eebag .Bottom ;case *Table :_bdfge =_fedg ;case *List :_bdfge =_fedg ;case *Division :_bdfge =_fedg ;case *Chart :_bdfge =_fedg ;
case *Line :_fcfe +=_caagd ._cfdcg .Top +_caagd ._cfdcg .Bottom ;_fefd -=_caagd .Height ()/2;};switch _gbafg ._cdfcd {case CellHorizontalAlignmentLeft :_deda .X +=_gbafg ._bdff ;_deda .Width -=_gbafg ._bdff ;case CellHorizontalAlignmentCenter :if _eagf :=_fedg -_bdfge ;
_eagf > 0{_deda .X +=_eagf /2;_deda .Width -=_eagf /2;};case CellHorizontalAlignmentRight :if _fedg > _bdfge {_deda .X =_deda .X +_fedg -_bdfge -_gbafg ._bdff ;_deda .Width -=_gbafg ._bdff ;};};_bdaf :=_deda .Y ;_eebab :=_deda .Height ;_deda .Y +=_fefd ;
switch _gbafg ._egfeb {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _ffcb :=_afbce -_fcfe ;_ffcb > 0{_deda .Y +=_ffcb /2;_deda .Height -=_ffcb /2;};case CellVerticalAlignmentBottom :if _afbce > _fcfe {_deda .Y =_deda .Y +_afbce -_fcfe ;
_deda .Height =_afbce ;};};_egeeb :=_bfgaa .DrawWithContext (_gbafg ._cfdd ,_deda );if _egeeb !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_egeeb );};_deda .Y =_bdaf ;_deda .Height =_eebab ;};_deda .Y +=_afbce ;_deda .Height -=_afbce ;
if _agbf &&_gbgdb +1> _fdcafg {_egadf +=_feedc +_afbce ;_dgddb -=_afbce +_feedc ;_abdf =_edea ;_gbgdb =_dfgba -1;_agbf =false ;};};_fage =append (_fage ,_bfgaa );if _bgfb ._caga .IsAbsolute (){return _fage ,_bgba ,nil ;};_deda .X =_bgba .X ;_deda .Width =_bgba .Width ;
_deda .Y +=_bgfb ._dceg .Bottom ;_deda .Height -=_bgfb ._dceg .Bottom ;return _fage ,_deda ,nil ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_ade :_fa .Max (_fa .Min (r ,1.0),0.0),_fcc :_fa .Max (_fa .Min (g ,1.0),0.0),_fbe :_fa .Max (_fa .Min (b ,1.0),0.0)};};func _gfac (_def ,_fgc ,_dbd ,_bcb float64 )*border {_cce :=&border {};
_cce ._bgg =_def ;_cce ._ebg =_fgc ;_cce ._dgda =_dbd ;_cce ._aed =_bcb ;_cce ._bfgc =ColorBlack ;_cce ._beed =ColorBlack ;_cce ._ege =ColorBlack ;_cce ._ecba =ColorBlack ;_cce ._gab =0;_cce ._eec =0;_cce ._bbd =0;_cce ._cee =0;_cce .LineStyle =_bg .LineStyleSolid ;
return _cce ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_bbcg *Division )Width ()float64 {return 0};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_ecgebf *Rectangle )BorderOpacity ()float64 {return _ecgebf ._cgbf };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_beebgd *_fee .PdfAnnotation ;_bacff bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};func _fafb (_bebf Color ,_adgd float64 )*ColorPoint {return &ColorPoint {_abfba :_bebf ,_gfeg :_adgd }};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_aegg []VectorDrawable ;_dgcag Positioning ;_ceeba Margins ;_deca Margins ;_agag bool ;_fgg bool ;_dgce *Background ;};

// SkipCells skips over a specified number of cells in the table.
func (_ddgd *Table )SkipCells (num int ){if num < 0{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_ddgd ._gacbf +=num ;};func (_cae *Block )drawToPage (_efe *_fee .PdfPage )error {_eea :=&_ebc .ContentStreamOperations {};if _efe .Resources ==nil {_efe .Resources =_fee .NewPdfPageResources ();};_dc :=_gcg (_eea ,_efe .Resources ,_cae ._db ,_cae ._gf );
if _dc !=nil {return _dc ;};if _dc =_dee (_cae ._gf ,_efe .Resources );_dc !=nil {return _dc ;};if _dc =_efe .AppendContentBytes (_eea .Bytes (),true );_dc !=nil {return _dc ;};for _ ,_bcf :=range _cae ._aee {_efe .AddAnnotation (_bcf );};return nil ;};


// SetNotes sets the notes section of the invoice.
func (_eeba *Invoice )SetNotes (title ,content string ){_eeba ._egdda =[2]string {title ,content }};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_gfeea *Rectangle )Width ()float64 {return _gfeea ._bfddd };

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_aaga *Creator )PageFinalize (pageFinalizeFunc func (_eagbd PageFinalizeFunctionArgs )error ){_aaga ._ecd =pageFinalizeFunc ;};func _agegf (_adcd int )*Table {_eefce :=&Table {_fcfd :_adcd ,_gbbe :10.0,_fadgg :[]float64 {},_agda :[]float64 {},_afbaa :[]*TableCell {},_gbdga :make ([]int ,_adcd ),_edcc :true };
_eefce .resetColumnWidths ();return _eefce ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_eaegg *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _eaegg ._bcgf ,_eaegg ._fgba ,_eaegg ._ecec ,_eaegg ._daac ;};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_gaff *GraphicSVG )ScaleToWidth (w float64 ){_eafc :=_gaff ._cfff .Height /_gaff ._cfff .Width ;_gaff ._cfff .Width =w ;_gaff ._cfff .Height =w *_eafc ;_gaff ._cfff .SetScaling (_eafc ,_eafc );};

// SetPos sets absolute positioning with specified coordinates.
func (_dcfeg *StyledParagraph )SetPos (x ,y float64 ){_dcfeg ._eege =PositionAbsolute ;_dcfeg ._fggg =x ;_dcfeg ._gaba =y ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ecac *Creator )SetPageLabels (pageLabels _dd .PdfObject ){_ecac ._dce =pageLabels };

// SetHeight sets the Image's document height to specified h.
func (_gdfa *Image )SetHeight (h float64 ){_gdfa ._eega =h };

// SetHeight sets the height of the ellipse.
func (_gdab *Ellipse )SetHeight (height float64 ){_gdab ._afaf =height };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_beec *Image )SetWidth (w float64 ){_beec ._edda =w };

// SetHeight sets the height of the rectangle.
func (_afec *Rectangle )SetHeight (height float64 ){_afec ._abfd =height };

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_dacg *LinearShading )SetAngle (angle float64 ){_dacg ._fcfba =angle };

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_bb *Block )AddAnnotation (annotation *_fee .PdfAnnotation ){for _ ,_bfc :=range _bb ._aee {if _bfc ==annotation {return ;};};_bb ._aee =append (_bb ._aee ,annotation );};func (_eegb *templateProcessor )parseLine (_ccgfd *templateNode )(interface{},error ){_gabde :=_eegb .creator .NewLine (0,0,0,0);
for _ ,_cecbb :=range _ccgfd ._bdbga .Attr {_fgddf :=_cecbb .Value ;switch _deebb :=_cecbb .Name .Local ;_deebb {case "\u0078\u0031":_gabde ._bcgf =_eegb .parseFloatAttr (_deebb ,_fgddf );case "\u0079\u0031":_gabde ._fgba =_eegb .parseFloatAttr (_deebb ,_fgddf );
case "\u0078\u0032":_gabde ._ecec =_eegb .parseFloatAttr (_deebb ,_fgddf );case "\u0079\u0032":_gabde ._daac =_eegb .parseFloatAttr (_deebb ,_fgddf );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_gabde .SetLineWidth (_eegb .parseFloatAttr (_deebb ,_fgddf ));
case "\u0063\u006f\u006co\u0072":_gabde .SetColor (_eegb .parseColorAttr (_deebb ,_fgddf ));case "\u0073\u0074\u0079l\u0065":_gabde .SetStyle (_eegb .parseLineStyleAttr (_deebb ,_fgddf ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_gabde .SetDashPattern (_eegb .parseInt64Array (_deebb ,_fgddf ),_gabde ._ccgd );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_gabde .SetDashPattern (_gabde ._fafa ,_eegb .parseInt64Attr (_deebb ,_fgddf ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_gabde .SetOpacity (_eegb .parseFloatAttr (_deebb ,_fgddf ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_gabde .SetPositioning (_eegb .parsePositioningAttr (_deebb ,_fgddf ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_gabde .SetFitMode (_eegb .parseFitModeAttr (_deebb ,_fgddf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_caeg :=_eegb .parseMarginAttr (_deebb ,_fgddf );
_gabde .SetMargins (_caeg .Left ,_caeg .Right ,_caeg .Top ,_caeg .Bottom );default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_deebb );
};};return _gabde ,nil ;};func (_baac *templateProcessor )parseHorizontalAlignmentAttr (_eegec ,_fegaf string )HorizontalAlignment {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_eegec ,_fegaf );
_baggg :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_fegaf ];return _baggg ;};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_edde int ;_fcfd int ;_gacbf int ;_fadgg []float64 ;_agda []float64 ;_gbbe float64 ;_afbaa []*TableCell ;_gbdga []int ;_caga Positioning ;_bccdf ,_fedc float64 ;_dceg Margins ;_dgaa bool ;_cfcgb int ;_bgda int ;_cfbac bool ;_edcc bool ;
};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_gag *Division )Add (d VectorDrawable )error {switch _dffb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_fcfc ,_edgb :=_dffb .ContainerComponent (_gag );
if _edgb !=nil {return _edgb ;};_acgg ,_dgde :=_fcfc .(VectorDrawable );if !_dgde {return _fb .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_fcfc );
};d =_acgg ;default:return _d .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gag ._aegg =append (_gag ._aegg ,d );return nil ;};func (_gdfg *Paragraph )wrapText ()error {if !_gdfg ._ccee ||int (_gdfg ._bgdg )<=0{_gdfg ._fcda =[]string {_gdfg ._fagf };
return nil ;};_dabg :=NewTextChunk (_gdfg ._fagf ,TextStyle {Font :_gdfg ._gbdaa ,FontSize :_gdfg ._bgef });_dgaee ,_daff :=_dabg .Wrap (_gdfg ._bgdg );if _daff !=nil {return _daff ;};if _gdfg ._afaa > 0&&len (_dgaee )> _gdfg ._afaa {_dgaee =_dgaee [:_gdfg ._afaa ];
};_gdfg ._fcda =_dgaee ;return nil ;};

// DashPattern returns the dash pattern of the line.
func (_ccfe *Line )DashPattern ()(_cgga []int64 ,_fbca int64 ){return _ccfe ._fafa ,_ccfe ._ccgd };func _fcfce (_geea *templateProcessor ,_beeac *templateNode )(interface{},error ){return _geea .parseRectangle (_beeac );};

// DrawWithContext draws the Block using the specified drawing context.
func (_caa *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_bede ,_ ,_beda :=d .GeneratePageBlocks (ctx );if _beda !=nil {return _beda ;};if len (_bede )!=1{return _d .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_dad :=range _bede {if _af :=_caa .mergeBlocks (_dad );_af !=nil {return _af ;};};return nil ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_gaag *TOC )SetLineLevelOffset (levelOffset float64 ){_gaag ._gfdfe =levelOffset };

// Margins returns the margins of the component.
func (_faab *Division )Margins ()(_geda ,_bbf ,_gdfc ,_debe float64 ){return _faab ._ceeba .Left ,_faab ._ceeba .Right ,_faab ._ceeba .Top ,_faab ._ceeba .Bottom ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);
ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_edbg _ef .ChartRenderable ;_gge Positioning ;_gfcd float64 ;_abfg float64 ;_cgc Margins ;};

// Text sets the text content of the Paragraph.
func (_cbcd *Paragraph )Text ()string {return _cbcd ._fagf };func (_gaef *LinearShading )shadingModel ()*_fee .PdfShadingType2 {_eeaab :=_bg .NewPoint (_gaef ._ecbd .Llx +_gaef ._ecbd .Width ()/2,_gaef ._ecbd .Lly +_gaef ._ecbd .Height ()/2);_cgcf :=_bg .NewPoint (_gaef ._ecbd .Llx ,_gaef ._ecbd .Lly +_gaef ._ecbd .Height ()/2).Add (-_eeaab .X ,-_eeaab .Y ).Rotate (_gaef ._fcfba ).Add (_eeaab .X ,_eeaab .Y );
_cgcf =_bg .NewPoint (_fa .Max (_fa .Min (_cgcf .X ,_gaef ._ecbd .Urx ),_gaef ._ecbd .Llx ),_fa .Max (_fa .Min (_cgcf .Y ,_gaef ._ecbd .Ury ),_gaef ._ecbd .Lly ));_gagc :=_bg .NewPoint (_gaef ._ecbd .Urx ,_gaef ._ecbd .Lly +_gaef ._ecbd .Height ()/2).Add (-_eeaab .X ,-_eeaab .Y ).Rotate (_gaef ._fcfba ).Add (_eeaab .X ,_eeaab .Y );
_gagc =_bg .NewPoint (_fa .Min (_fa .Max (_gagc .X ,_gaef ._ecbd .Llx ),_gaef ._ecbd .Urx ),_fa .Min (_fa .Max (_gagc .Y ,_gaef ._ecbd .Lly ),_gaef ._ecbd .Ury ));_bdcf :=_fee .NewPdfShadingType2 ();_bdcf .PdfShading .ShadingType =_dd .MakeInteger (2);
_bdcf .PdfShading .ColorSpace =_fee .NewPdfColorspaceDeviceRGB ();_bdcf .PdfShading .AntiAlias =_dd .MakeBool (_gaef ._adece ._fbfeg );_bdcf .Coords =_dd .MakeArrayFromFloats ([]float64 {_cgcf .X ,_cgcf .Y ,_gagc .X ,_gagc .Y });_bdcf .Extend =_dd .MakeArray (_dd .MakeBool (_gaef ._adece ._gcefb [0]),_dd .MakeBool (_gaef ._adece ._gcefb [1]));
_bdcf .Function =_gaef ._adece .generatePdfFunctions ();return _bdcf ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_abgad *Table )MultiColCell (colspan int )*TableCell {return _abgad .MultiCell (1,colspan )};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_cfdf *Creator )SetPageSize (size PageSize ){_cfdf ._gee =size ;_cfdf ._aef =size [0];_cfdf ._cec =size [1];_agb :=0.1*_cfdf ._aef ;_cfdf ._bbdf .Left =_agb ;_cfdf ._bbdf .Right =_agb ;_cfdf ._bbdf .Top =_agb ;_cfdf ._bbdf .Bottom =_agb ;};

// SetOpacity sets the opacity of the line (0-1).
func (_eacg *Line )SetOpacity (opacity float64 ){_eacg ._dcfe =opacity };func (_efee *templateProcessor )parseRectangle (_abcbg *templateNode )(interface{},error ){_cbfe :=_efee .creator .NewRectangle (0,0,0,0);for _ ,_dgcc :=range _abcbg ._bdbga .Attr {_bccdg :=_dgcc .Value ;
switch _cfgdca :=_dgcc .Name .Local ;_cfgdca {case "\u0078":_cbfe ._cfbab =_efee .parseFloatAttr (_cfgdca ,_bccdg );case "\u0079":_cbfe ._cffbf =_efee .parseFloatAttr (_cfgdca ,_bccdg );case "\u0077\u0069\u0064t\u0068":_cbfe .SetWidth (_efee .parseFloatAttr (_cfgdca ,_bccdg ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_cbfe .SetHeight (_efee .parseFloatAttr (_cfgdca ,_bccdg ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_cbfe .SetFillColor (_efee .parseColorAttr (_cfgdca ,_bccdg ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_cbfe .SetFillOpacity (_efee .parseFloatAttr (_cfgdca ,_bccdg ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_cbfe .SetBorderColor (_efee .parseColorAttr (_cfgdca ,_bccdg ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_cbfe .SetBorderOpacity (_efee .parseFloatAttr (_cfgdca ,_bccdg ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_cbfe .SetBorderWidth (_efee .parseFloatAttr (_cfgdca ,_bccdg ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_bcef ,_bfgba ,_efbe ,_affg :=_efee .parseBorderRadiusAttr (_cfgdca ,_bccdg );
_cbfe .SetBorderRadius (_bcef ,_bfgba ,_affg ,_efbe );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_cbfe ._egdce =_efee .parseFloatAttr (_cfgdca ,_bccdg );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_cbfe ._edac =_efee .parseFloatAttr (_cfgdca ,_bccdg );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_cbfe ._cdfge =_efee .parseFloatAttr (_cfgdca ,_bccdg );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_cbfe ._cfef =_efee .parseFloatAttr (_cfgdca ,_bccdg );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_cbfe .SetPositioning (_efee .parsePositioningAttr (_cfgdca ,_bccdg ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_cbfe .SetFitMode (_efee .parseFitModeAttr (_cfgdca ,_bccdg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ggfe :=_efee .parseMarginAttr (_cfgdca ,_bccdg );
_cbfe .SetMargins (_ggfe .Left ,_ggfe .Right ,_ggfe .Top ,_ggfe .Bottom );default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_cfgdca );
};};return _cbfe ,nil ;};

// SetWidthRight sets border width for right.
func (_agaf *border )SetWidthRight (bw float64 ){_agaf ._cee =bw };

// Width returns the width of the ellipse.
func (_cbbd *Ellipse )Width ()float64 {return _cbbd ._baeg };

// Height returns the height of the list.
func (_cfba *List )Height ()float64 {var _cabg float64 ;for _ ,_abba :=range _cfba ._fegg {_cabg +=_abba .ctxHeight (_cfba .Width ());};return _cabg ;};

// SetWidth sets the width of the ellipse.
func (_dcce *Ellipse )SetWidth (width float64 ){_dcce ._baeg =width };

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_dabee *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gfgb float64 ;_bbec uint ;_eedde float64 ;_bgfaa Positioning ;_becg float64 ;_gfcef float64 ;_edbf int64 ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_aebe *Creator )Finalize ()error {if _aebe ._aeg {return nil ;};_aca :=len (_aebe ._adbg );_bggb :=0;if _aebe ._badc !=nil {_fgdb :=*_aebe ;_aebe ._adbg =nil ;_aebe ._ebec =nil ;_aebe .initContext ();_degeb :=FrontpageFunctionArgs {PageNum :1,TotalPages :_aca };
_aebe ._badc (_degeb );_bggb +=len (_aebe ._adbg );_aebe ._adbg =_fgdb ._adbg ;_aebe ._ebec =_fgdb ._ebec ;};if _aebe .AddTOC {_aebe .initContext ();_aebe ._ddd .Page =_bggb +1;if _aebe .CustomTOC &&_aebe ._cdfg !=nil {_dfcc :=*_aebe ;_aebe ._adbg =nil ;
_aebe ._ebec =nil ;if _gcda :=_aebe ._cdfg (_aebe ._fgde );_gcda !=nil {return _gcda ;};_bggb +=len (_aebe ._adbg );_aebe ._adbg =_dfcc ._adbg ;_aebe ._ebec =_dfcc ._ebec ;}else {if _aebe ._cdfg !=nil {if _ecbgc :=_aebe ._cdfg (_aebe ._fgde );_ecbgc !=nil {return _ecbgc ;
};};_ffe ,_ ,_ffef :=_aebe ._fgde .GeneratePageBlocks (_aebe ._ddd );if _ffef !=nil {_da .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_ffef );
return _ffef ;};_bggb +=len (_ffe );};_gadc :=_aebe ._fgde .Lines ();for _ ,_geec :=range _gadc {_fff ,_bfdd :=_fe .Atoi (_geec .Page .Text );if _bfdd !=nil {continue ;};_geec .Page .Text =_fe .Itoa (_fff +_bggb );_geec ._edbf +=int64 (_bggb );};};_adgbf :=false ;
var _cfgb []*_fee .PdfPage ;if _aebe ._badc !=nil {_gfga :=*_aebe ;_aebe ._adbg =nil ;_aebe ._ebec =nil ;_dac :=FrontpageFunctionArgs {PageNum :1,TotalPages :_aca };_aebe ._badc (_dac );_aca +=len (_aebe ._adbg );_cfgb =_aebe ._adbg ;_aebe ._adbg =append (_aebe ._adbg ,_gfga ._adbg ...);
_aebe ._ebec =_gfga ._ebec ;_adgbf =true ;};var _abc []*_fee .PdfPage ;if _aebe .AddTOC {_aebe .initContext ();if _aebe .CustomTOC &&_aebe ._cdfg !=nil {_bccd :=*_aebe ;_aebe ._adbg =nil ;_aebe ._ebec =nil ;if _ged :=_aebe ._cdfg (_aebe ._fgde );_ged !=nil {_da .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_ged );
return _ged ;};_abc =_aebe ._adbg ;_aca +=len (_abc );_aebe ._adbg =_bccd ._adbg ;_aebe ._ebec =_bccd ._ebec ;}else {if _aebe ._cdfg !=nil {if _cbg :=_aebe ._cdfg (_aebe ._fgde );_cbg !=nil {_da .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_cbg );
return _cbg ;};};_fgb ,_ ,_ :=_aebe ._fgde .GeneratePageBlocks (_aebe ._ddd );for _ ,_ebcd :=range _fgb {_ebcd .SetPos (0,0);_aca ++;_gacc :=_aebe .newPage ();_abc =append (_abc ,_gacc );_aebe .setActivePage (_gacc );_aebe .Draw (_ebcd );};};if _adgbf {_gfd :=_cfgb ;
_bced :=_aebe ._adbg [len (_cfgb ):];_aebe ._adbg =append ([]*_fee .PdfPage {},_gfd ...);_aebe ._adbg =append (_aebe ._adbg ,_abc ...);_aebe ._adbg =append (_aebe ._adbg ,_bced ...);}else {_aebe ._adbg =append (_abc ,_aebe ._adbg ...);};};if _aebe ._aeff !=nil &&_aebe .AddOutlines {var _gdbc func (_bbeg *_fee .OutlineItem );
_gdbc =func (_degef *_fee .OutlineItem ){_degef .Dest .Page +=int64 (_bggb );if _fgcgb :=int (_degef .Dest .Page );_fgcgb >=0&&_fgcgb < len (_aebe ._adbg ){_degef .Dest .PageObj =_aebe ._adbg [_fgcgb ].GetPageAsIndirectObject ();}else {_da .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_fgcgb );
};_degef .Dest .Y =_aebe ._cec -_degef .Dest .Y ;_dag :=_degef .Items ();for _ ,_abcc :=range _dag {_gdbc (_abcc );};};_acgc :=_aebe ._aeff .Items ();for _ ,_cdgc :=range _acgc {_gdbc (_cdgc );};if _aebe .AddTOC {var _aced int ;if _adgbf {_aced =len (_cfgb );
};_dfce :=_fee .NewOutlineDest (int64 (_aced ),0,_aebe ._cec );if _aced >=0&&_aced < len (_aebe ._adbg ){_dfce .PageObj =_aebe ._adbg [_aced ].GetPageAsIndirectObject ();}else {_da .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_aced );
};_aebe ._aeff .Insert (0,_fee .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_dfce ));};};for _cge ,_bef :=range _aebe ._adbg {_aebe .setActivePage (_bef );if _aebe ._ecd !=nil {_edfd ,_ccgc ,_ebcb :=_bef .Size ();
if _ebcb !=nil {return _ebcb ;};_egffa :=PageFinalizeFunctionArgs {PageNum :_cge +1,PageWidth :_edfd ,PageHeight :_ccgc ,TOCPages :len (_abc ),TotalPages :_aca };if _adfc :=_aebe ._ecd (_egffa );_adfc !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_adfc );
return _adfc ;};};if _aebe ._dbbg !=nil {_bfbd :=NewBlock (_aebe ._aef ,_aebe ._bbdf .Top );_gdec :=HeaderFunctionArgs {PageNum :_cge +1,TotalPages :_aca };_aebe ._dbbg (_bfbd ,_gdec );_bfbd .SetPos (0,0);if _cffg :=_aebe .Draw (_bfbd );_cffg !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_cffg );
return _cffg ;};};if _aebe ._fdf !=nil {_dea :=NewBlock (_aebe ._aef ,_aebe ._bbdf .Bottom );_ecgf :=FooterFunctionArgs {PageNum :_cge +1,TotalPages :_aca };_aebe ._fdf (_dea ,_ecgf );_dea .SetPos (0,_aebe ._cec -_dea ._egb );if _gcdg :=_aebe .Draw (_dea );
_gcdg !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_gcdg );return _gcdg ;};};_aefc ,_fccg :=_aebe ._ecbb [_bef ];if _gaca ,_gbaf :=_aebe ._adcea [_bef ];
_gbaf {if _fccg {_aefc .transformBlock (_gaca );};if _ecda :=_gaca .drawToPage (_bef );_ecda !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_cge +1,_ecda );
return _ecda ;};};if _fccg {if _bgbe :=_aefc .transformPage (_bef );_bgbe !=nil {_da .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_bgbe );
return _bgbe ;};};};_aebe ._aeg =true ;return nil ;};func _gfgag (_egae string )*_fee .PdfAnnotation {_bgfc :=_fee .NewPdfAnnotationLink ();_dfgfc :=_fee .NewBorderStyle ();_dfgfc .SetBorderWidth (0);_bgfc .BS =_dfgfc .ToPdfObject ();_ggcg :=_fee .NewPdfActionURI ();
_ggcg .URI =_dd .MakeString (_egae );_bgfc .SetAction (_ggcg .PdfAction );return _bgfc .PdfAnnotation ;};func (_bfec *Creator )setActivePage (_dccfc *_fee .PdfPage ){_bfec ._ebec =_dccfc };

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_edaf *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _edaf ._gcag .Left ,_edaf ._gcag .Right ,_edaf ._gcag .Top ,_edaf ._gcag .Bottom ;};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_ggcf *Ellipse )ScaleToWidth (w float64 ){_gcaa :=_ggcf ._afaf /_ggcf ._baeg ;_ggcf ._baeg =w ;_ggcf ._afaf =w *_gcaa ;};func _gaffdg ()*PageBreak {return &PageBreak {}};

// GeneratePageBlocks draw graphic svg into block.
func (_eedbb *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cadb :=ctx ;_gdd :=_eedbb ._ebgcc .IsRelative ();var _fggd []*Block ;if _gdd {_aeda :=1.0;_fgcd :=_eedbb ._dadde .Top ;if _eedbb ._cfff .Height > ctx .Height -_eedbb ._dadde .Top {_fggd =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _eeab error ;if _ ,ctx ,_eeab =_gaffdg ().GeneratePageBlocks (ctx );_eeab !=nil {return nil ,ctx ,_eeab ;};_fgcd =0;};ctx .X +=_eedbb ._dadde .Left +_aeda ;ctx .Y +=_fgcd ;ctx .Width -=_eedbb ._dadde .Left +_eedbb ._dadde .Right +2*_aeda ;ctx .Height -=_fgcd ;
}else {ctx .X =_eedbb ._cad ;ctx .Y =_eedbb ._debcc ;};_fgbd :=_ebc .NewContentCreator ();_fgbd .Translate (0,ctx .PageHeight );_fgbd .Scale (1,-1);_fgbd .Translate (ctx .X ,ctx .Y );_ffgb :=_eedbb ._cfff .Width /_eedbb ._cfff .ViewBox .W ;_fbea :=_eedbb ._cfff .Height /_eedbb ._cfff .ViewBox .H ;
_dbda :=_eedbb ._cad -(_eedbb ._cfff .ViewBox .X *_fa .Max (_ffgb ,_fbea ));_gccdd :=_eedbb ._debcc -(_eedbb ._cfff .ViewBox .Y *_fa .Max (_ffgb ,_fbea ));_eedbb ._cfff .ToContentCreator (_fgbd ,_ffgb ,_fbea ,_dbda ,_gccdd );_daa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _ebaag :=_daa .addContentsByString (_fgbd .String ());_ebaag !=nil {return nil ,ctx ,_ebaag ;};if _gdd {_fdddg :=_eedbb .Height ()+_eedbb ._dadde .Bottom ;ctx .Y +=_fdddg ;ctx .Height -=_fdddg ;}else {ctx =_cadb ;};_fggd =append (_fggd ,_daa );return _fggd ,ctx ,nil ;
};

// AddColorStop add color stop info for rendering gradient color.
func (_dggd *LinearShading )AddColorStop (color Color ,point float64 ){_dggd ._adece .AddColorStop (color ,point );};func (_acgce *templateProcessor )parseChapterHeading (_gecg *templateNode )(interface{},error ){if _gecg ._bdgb ==nil {_da .Log .Error ("\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_cedeg ;};_beebg ,_daaf :=_gecg ._bdgb ._bdced .(*Chapter );if !_daaf {_da .Log .Error ("\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_gecg ._bdgb ._bdced );
return nil ,_cedeg ;};_gdfbe :=_beebg .GetHeading ();if _ ,_gdaab :=_acgce .parseParagraph (_gecg ,_gdfbe );_gdaab !=nil {return nil ,_gdaab ;};return _gdfbe ,nil ;};func (_dccgc *pageTransformations )transformBlock (_bgea *Block ){if _dccgc ._gbgd !=nil {_bgea .transform (*_dccgc ._gbgd );
};};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_efga *Creator )AddPage (page *_fee .PdfPage )error {_adecg ,_bbab :=page .GetMediaBox ();if _bbab !=nil {_da .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_bbab );
return _bbab ;};_adecg .Normalize ();_bebg ,_ecf :=_adecg .Llx ,_adecg .Lly ;_cgf :=_adecg ;if _aedc :=page .CropBox ;_aedc !=nil &&*_aedc !=*_adecg {_aedc .Normalize ();_bebg ,_ecf =_aedc .Llx ,_aedc .Lly ;_cgf =_aedc ;};_dgae :=_bc .IdentityMatrix ();
_cfa ,_bbab :=page .GetRotate ();if _bbab !=nil {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_bbab .Error ());
};_ecde :=_cfa %360!=0&&_cfa %90==0;if _ecde {_fafg :=float64 ((360+_cfa %360)%360);if _fafg ==90{_dgae =_dgae .Translate (_cgf .Width (),0);}else if _fafg ==180{_dgae =_dgae .Translate (_cgf .Width (),_cgf .Height ());}else if _fafg ==270{_dgae =_dgae .Translate (0,_cgf .Height ());
};_dgae =_dgae .Mult (_bc .RotationMatrix (_fafg *_fa .Pi /180));_dgae =_dgae .Round (0.000001);_acg :=_fgbc (_cgf ,_dgae );_cgf =_acg ;_cgf .Normalize ();};if _bebg !=0||_ecf !=0{_dgae =_bc .TranslationMatrix (_bebg ,_ecf ).Mult (_dgae );};if !_dgae .Identity (){_dgae =_dgae .Round (0.000001);
_efga ._ecbb [page ]=&pageTransformations {_gbgd :&_dgae };};_efga ._aef =_cgf .Width ();_efga ._cec =_cgf .Height ();_efga .initContext ();_efga ._adbg =append (_efga ._adbg ,page );_efga ._ddd .Page ++;return nil ;};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _cfbfe (path )};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;func _fgbddeg (_cfbbe *templateProcessor ,_aba *templateNode )(interface{},error ){return _cfbbe .parseChapterHeading (_aba );};

// Width returns the width of the Paragraph.
func (_dabb *Paragraph )Width ()float64 {if _dabb ._ccee &&int (_dabb ._bgdg )> 0{return _dabb ._bgdg ;};return _dabb .getTextWidth ()/1000.0;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_eed *Block )DrawTemplate (c *Creator ,r _fg .Reader ,data interface{},options *TemplateOptions )error {return _gcdc (c ,r ,data ,options ,_eed );};func _aacgba (_aggg *Block ,_deee _fee .PdfColor ,_dcbb Color ,_aadb func ()Rectangle )error {switch _ffaab :=_deee .(type ){case *_fee .PdfColorPatternType2 :_ageg ,_fdbag :=_dcbb .(*LinearShading );
if !_fdbag {return _fb .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_dgec :=_aadb ();_ageg .SetBoundingBox (_dgec ._cfbab ,_dgec ._cffbf ,_dgec ._bfddd ,_dgec ._abfd );
_fbee ,_debee :=_ageg .AddPatternResource (_aggg );if _debee !=nil {return _fb .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_debee );
};_ffaab .PatternName =_fbee ;case *_fee .PdfColorPatternType3 :_afag ,_fdffa :=_dcbb .(*RadialShading );if !_fdffa {return _fb .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_dgbe :=_aadb ();_afag .SetBoundingBox (_dgbe ._cfbab ,_dgbe ._cffbf ,_dgbe ._bfddd ,_dgbe ._abfd );_gefb ,_dafbb :=_afag .AddPatternResource (_aggg );if _dafbb !=nil {return _fb .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_dafbb );
};_ffaab .PatternName =_gefb ;};return nil ;};func (_gbgf *templateProcessor )renderNode (_aafcb *templateNode )error {_fdafe :=_aafcb ._bdced ;if _fdafe ==nil {return nil ;};_fcdfd :=_aafcb ._bdbga .Name .Local ;_feac ,_dgac :=_accae [_fcdfd ];if !_dgac {_da .Log .Debug ("\u0049\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025s\u0060.\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_fcdfd );
return nil ;};var _deaf interface{};if _aafcb ._bdgb !=nil &&_aafcb ._bdgb ._bdced !=nil {_gedd :=_aafcb ._bdgb ._bdbga .Name .Local ;if _ ,_dgac =_feac ._gagf [_gedd ];!_dgac {_da .Log .Debug ("\u0060%\u0073\u0060 \u0069\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020`\u0025\u0073\u0060\u0020\u006e\u006f\u0064\u0065\u002e",_gedd ,_fcdfd );
return _cedeg ;};_deaf =_aafcb ._bdgb ._bdced ;}else {_fdcf :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _gbgf ._cgcaa .(type ){case *Block :_fdcf ="\u0062\u006c\u006fc\u006b";};if _ ,_dgac =_feac ._gagf [_fdcf ];!_dgac {_da .Log .Debug ("\u0060%\u0073\u0060 \u0069\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020`\u0025\u0073\u0060\u0020\u006e\u006f\u0064\u0065\u002e",_fdcf ,_fcdfd );
return _cedeg ;};_deaf =_gbgf ._cgcaa ;};switch _babgbc :=_deaf .(type ){case componentRenderer :_febbe ,_gecbd :=_fdafe .(Drawable );if !_gecbd {_da .Log .Error ("\u0043\u006f\u006d\u0070\u006f\u006ee\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_fdafe );
return _gffbc ;};return _babgbc .Draw (_febbe );case *Division :switch _bgfbc :=_fdafe .(type ){case *Background :_babgbc .SetBackground (_bgfbc );case VectorDrawable :return _babgbc .Add (_bgfbc );};case *TableCell :_cgaf ,_egfec :=_fdafe .(VectorDrawable );
if !_egfec {_da .Log .Error ("C\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006eo\u0074\u0020\u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072 d\u0072\u0061\u0077a\u0062l\u0065\u002e",_fdafe );return _gffbc ;
};return _babgbc .SetContent (_cgaf );case *StyledParagraph :_aecad ,_dcddd :=_fdafe .(*TextChunk );if !_dcddd {_da .Log .Error ("C\u006f\u006d\u0070\u006f\u006e\u0065n\u0074\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006ek\u002e",_fdafe );
return _gffbc ;};_babgbc .appendChunk (_aecad );case *Chapter :switch _edca :=_fdafe .(type ){case *Chapter :return nil ;case *Paragraph :if _aafcb ._bdbga .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};return _babgbc .Add (_edca );case Drawable :return _babgbc .Add (_edca );};case *List :switch _fdfg :=_fdafe .(type ){case *TextChunk :case *listItem :_babgbc ._fegg =append (_babgbc ._fegg ,_fdfg );default:_da .Log .Error ("\u0043o\u006d\u0070o\u006e\u0065\u006e\u0074 \u0028\u0025\u0054)\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061 l\u0069\u0073\u0074 \u0069\u0074e\u006d\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fdafe );
};case *listItem :switch _bdbgc :=_fdafe .(type ){case *TextChunk :case *StyledParagraph :_babgbc ._eaca =_bdbgc ;case *List :if _bdbgc ._ggeg {_bdbgc ._cfffc =15;};_babgbc ._eaca =_bdbgc ;case *Image :_babgbc ._eaca =_bdbgc ;case *Division :_babgbc ._eaca =_bdbgc ;
case *Table :_babgbc ._eaca =_bdbgc ;default:_da .Log .Error ("\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0028\u0025\u0054)\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e \u006c\u0069\u0073\u0074",_fdafe );
return _gffbc ;};};return nil ;};func (_adcc *Division )drawBackground (_eead []*Block ,_dbgc ,_gage DrawContext ,_caf bool )([]*Block ,error ){_bdaa :=len (_eead );if _bdaa ==0||_adcc ._dgce ==nil {return _eead ,nil ;};_ddfa :=make ([]*Block ,0,len (_eead ));
for _fbf ,_ggeb :=range _eead {var (_aabc =_adcc ._dgce .BorderRadiusTopLeft ;_gcde =_adcc ._dgce .BorderRadiusTopRight ;_gaga =_adcc ._dgce .BorderRadiusBottomLeft ;_abce =_adcc ._dgce .BorderRadiusBottomRight ;);_ced :=_dbgc ;_ced .Page +=_fbf ;if _fbf ==0{if _caf {_ddfa =append (_ddfa ,_ggeb );
continue ;};if _bdaa ==1{_ced .Height =_gage .Y -_dbgc .Y ;};}else {_ced .X =_ced .Margins .Left +_adcc ._ceeba .Left ;_ced .Y =_ced .Margins .Top ;_ced .Width =_ced .PageWidth -_ced .Margins .Left -_ced .Margins .Right -_adcc ._ceeba .Left -_adcc ._ceeba .Right ;
if _fbf ==_bdaa -1{_ced .Height =_gage .Y -_ced .Margins .Top -_adcc ._ceeba .Top ;}else {_ced .Height =_ced .PageHeight -_ced .Margins .Top -_ced .Margins .Bottom ;};if !_caf {_aabc =0;_gcde =0;};};if _bdaa > 1&&_fbf !=_bdaa -1{_gaga =0;_abce =0;};_egfa :=_eefb (_ced .X ,_ced .Y ,_ced .Width ,_ced .Height );
_egfa .SetFillColor (_adcc ._dgce .FillColor );_egfa .SetBorderColor (_adcc ._dgce .BorderColor );_egfa .SetBorderWidth (_adcc ._dgce .BorderSize );_egfa .SetBorderRadius (_aabc ,_gcde ,_gaga ,_abce );_cdefb ,_ ,_ggbaf :=_egfa .GeneratePageBlocks (_ced );
if _ggbaf !=nil {return nil ,_ggbaf ;};if len (_cdefb )==0{continue ;};_daca :=_cdefb [0];if _ggbaf =_daca .mergeBlocks (_ggeb );_ggbaf !=nil {return nil ,_ggbaf ;};_ddfa =append (_ddfa ,_daca );};return _ddfa ,nil ;};func _eaead (_ddgdg *templateProcessor ,_ceagg *templateNode )(interface{},error ){return _ddgdg .parseListItem (_ceagg );
};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_abgc *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _abgc ._gfbd [0],_abgc ._gfbd [1]};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);func (_gdagd *Table )updateRowHeights (_aeebf float64 ){for _ ,_ebgda :=range _gdagd ._afbaa {_cgcb :=_ebgda .width (_gdagd ._fadgg ,_aeebf );
_dgfa :=_gdagd ._agda [_ebgda ._eeadc +_ebgda ._dbbfc -2];if _aagbba :=_ebgda .height (_cgcb );_aagbba > _dgfa {_cdca :=_aagbba /float64 (_ebgda ._dbbfc );for _fdacf :=1;_fdacf <=_ebgda ._dbbfc ;_fdacf ++{if _cdca > _gdagd ._agda [_ebgda ._eeadc +_fdacf -2]{_gdagd ._agda [_ebgda ._eeadc +_fdacf -2]=_cdca ;
};};};};};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_gaac *Image )SetPos (x ,y float64 ){_gaac ._agagd =PositionAbsolute ;_gaac ._gbcdd =x ;_gaac ._egbgf =y ;};func (_adebd *templateProcessor )parseListMarker (_degfa *templateNode )(interface{},error ){if _degfa ._bdgb ==nil {_da .Log .Error ("\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_cedeg ;};var _eefd *TextChunk ;switch _egeec :=_degfa ._bdgb ._bdced .(type ){case *List :_eefd =&_egeec ._dabcb ;case *listItem :_eefd =&_egeec ._aeaf ;default:_da .Log .Error ("\u0025v\u0020\u0069s\u0020\u006e\u006ft\u0020\u0061\u0020\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006et\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006ci\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072",_egeec );
return nil ,_cedeg ;};if _ ,_cabff :=_adebd .parseTextChunk (_degfa ,_eefd );_cabff !=nil {_da .Log .Error ("\u0043\u006f\u0075\u006c\u0064\u0020n\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006c\u0069\u0073\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a \u0060\u0025\u0076\u0060",_cabff );
return nil ,nil ;};return _eefd ,nil ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_bfca *Table )SetPos (x ,y float64 ){_bfca ._caga =PositionAbsolute ;_bfca ._bccdf =x ;_bfca ._fedc =y ;};

// SetBorderColor sets the border color.
func (_gecb *CurvePolygon )SetBorderColor (color Color ){_gecb ._aaee .BorderColor =_cfd (color )};func (_gfec *templateProcessor )parseDivision (_bgcce *templateNode )(interface{},error ){_dfgf :=_gfec .creator .NewDivision ();for _ ,_ecbdb :=range _bgcce ._bdbga .Attr {_cddfg :=_ecbdb .Value ;
switch _deaef :=_ecbdb .Name .Local ;_deaef {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_dfgf .EnablePageWrap (_gfec .parseBoolAttr (_deaef ,_cddfg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gbgc :=_gfec .parseMarginAttr (_deaef ,_cddfg );
_dfgf .SetMargins (_gbgc .Left ,_gbgc .Right ,_gbgc .Top ,_gbgc .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_bdgce :=_gfec .parseMarginAttr (_deaef ,_cddfg );_dfgf .SetPadding (_bdgce .Left ,_bdgce .Right ,_bdgce .Top ,_bdgce .Bottom );default:_da .Log .Debug ("U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_deaef );
};};return _dfgf ,nil ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_adbg []*_fee .PdfPage ;_adcea map[*_fee .PdfPage ]*Block ;_ecbb map[*_fee .PdfPage ]*pageTransformations ;_ebec *_fee .PdfPage ;_gee PageSize ;_ddd DrawContext ;_bbdf Margins ;_aef ,_cec float64 ;_afba int ;_badc func (_dcf FrontpageFunctionArgs );
_cdfg func (_eccb *TOC )error ;_dbbg func (_gac *Block ,_adec HeaderFunctionArgs );_fdf func (_aeeab *Block ,_abff FooterFunctionArgs );_ecd func (_eabe PageFinalizeFunctionArgs )error ;_bcaa func (_egec *_fee .PdfWriter )error ;_aeg bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_fgde *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_aeff *_fee .Outline ;_eaa *_fee .PdfOutlineTreeNode ;_ebgd *_fee .PdfAcroForm ;_dce _dd .PdfObject ;_cecf _fee .Optimizer ;_gbc []*_fee .PdfFont ;_eedd *_fee .PdfFont ;_gbad *_fee .PdfFont ;};func (_bbgef *templateProcessor )processGradientColorPair (_gadff []string )(_bebeg []Color ,_ccfb []float64 ){for _ ,_gffdc :=range _gadff {var (_efgg =_cf .Fields (_gffdc );
_bbdb =len (_efgg ););if _bbdb ==0{continue ;};_afea :="";if _bbdb > 1{_afea =_cf .TrimSpace (_efgg [1]);};_daead :=-1.0;if _cf .HasSuffix (_afea ,"\u0025"){_cdaba ,_afbgb :=_fe .ParseFloat (_afea [:len (_afea )-1],64);if _afbgb !=nil {_da .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_afbgb );
};_daead =_cdaba /100.0;};_gaffc :=_bbgef .parseColor (_cf .TrimSpace (_efgg [0]));if _gaffc !=nil {_bebeg =append (_bebeg ,_gaffc );_ccfb =append (_ccfb ,_daead );};};if len (_bebeg )!=len (_ccfb ){_da .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_dfgcd :=-1;_bfgg :=0.0;for _fade ,_efba :=range _ccfb {if _efba ==-1.0{if _fade ==0{_efba =0.0;_ccfb [_fade ]=0.0;continue ;};_dfgcd ++;if _fade < len (_ccfb )-1{continue ;}else {_efba =1.0;_ccfb [_fade ]=1.0;};};_cdbcc :=_dfgcd +1;
for _babe :=_fade -_dfgcd ;_babe < _fade ;_babe ++{_ccfb [_babe ]=_bfgg +(float64 (_babe )*(_efba -_bfgg )/float64 (_cdbcc ));};_bfgg =_efba ;_dfgcd =-1;};return _bebeg ,_ccfb ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_edbac *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_edbac .Text },nil ;};var _fdceb []string ;var _beefc []rune ;var _adge float64 ;var _bdbcb []float64 ;_ccag :=_edbac .Style ;_fbcc :=_cfcbf (_edbac .Text );
for _ ,_bcfg :=range _edbac .Text {if _bcfg =='\u000A'{_fgdcf :=_bcgdb (string (_beefc ),_fbcc );_fdceb =append (_fdceb ,_cf .TrimRightFunc (_fgdcf ,_eb .IsSpace )+string (_bcfg ));_beefc =nil ;_adge =0;_bdbcb =nil ;continue ;};_afdc :=_bcfg ==' ';_fbefc ,_bcge :=_ccag .Font .GetRuneMetrics (_bcfg );
if !_bcge {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bcfg ,_bcfg ,_ccag .Font .BaseFont (),_ccag .Font .Subtype ());
_da .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ccag .Font );_da .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ccag .Font .Encoder ());return nil ,_d .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_fgcdf :=_ccag .FontSize *_fbefc .Wx ;_gbfge :=_fgcdf ;if !_afdc {_gbfge =_fgcdf +_ccag .CharSpacing *1000.0;};if _adge +_fgcdf > width *1000.0{_cdad :=-1;if !_afdc {for _ffdaef :=len (_beefc )-1;_ffdaef >=0;_ffdaef --{if _beefc [_ffdaef ]==' '{_cdad =_ffdaef ;
break ;};};};_ecfb :=string (_beefc );if _cdad > 0{_ecfb =string (_beefc [0:_cdad +1]);_beefc =append (_beefc [_cdad +1:],_bcfg );_bdbcb =append (_bdbcb [_cdad +1:],_gbfge );_adge =0;for _ ,_gcba :=range _bdbcb {_adge +=_gcba ;};}else {if _afdc {_beefc =[]rune {};
_bdbcb =[]float64 {};_adge =0;}else {_beefc =[]rune {_bcfg };_bdbcb =[]float64 {_gbfge };_adge =_gbfge ;};};_ecfb =_bcgdb (_ecfb ,_fbcc );_fdceb =append (_fdceb ,_cf .TrimRightFunc (_ecfb ,_eb .IsSpace ));}else {_beefc =append (_beefc ,_bcfg );_adge +=_gbfge ;
_bdbcb =append (_bdbcb ,_gbfge );};};if len (_beefc )> 0{_bbeeb :=string (_beefc );_bbeeb =_bcgdb (_bbeeb ,_fbcc );_fdceb =append (_fdceb ,_bbeeb );};return _fdceb ,nil ;};func _cdbf ()*FilledCurve {_gaccc :=FilledCurve {};_gaccc ._ddfce =[]_bg .CubicBezierCurve {};
return &_gaccc ;};func (_gdfb *Creator )getActivePage ()*_fee .PdfPage {if _gdfb ._ebec ==nil {if len (_gdfb ._adbg )==0{return nil ;};return _gdfb ._adbg [len (_gdfb ._adbg )-1];};return _gdfb ._ebec ;};func _geegg (_dgfad *templateProcessor ,_ggdg *templateNode )(interface{},error ){return _dgfad .parseChart (_ggdg );
};func _cged (_gdgaf string ,_bedf ,_eecf TextStyle )*TOC {_ggea :=_eecf ;_ggea .FontSize =14;_gccgb :=_dccc (_ggea );_gccgb .SetEnableWrap (true );_gccgb .SetTextAlignment (TextAlignmentLeft );_gccgb .SetMargins (0,0,0,5);_aeegf :=_gccgb .Append (_gdgaf );
_aeegf .Style =_ggea ;return &TOC {_bfaa :_gccgb ,_bbfe :[]*TOCLine {},_bbda :_bedf ,_gaebe :_bedf ,_ffedc :_bedf ,_ddege :_bedf ,_gabb :"\u002e",_gfdfe :10,_fdgc :Margins {0,0,2,2},_eebf :PositionRelative ,_dcdcg :_bedf ,_ffag :true };};func (_afgfe *Table )resetColumnWidths (){_afgfe ._fadgg =[]float64 {};
_feefc :=float64 (1.0)/float64 (_afgfe ._fcfd );for _ebbde :=0;_ebbde < _afgfe ._fcfd ;_ebbde ++{_afgfe ._fadgg =append (_afgfe ._fadgg ,_feefc );};};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_gagaa *Table )Width ()float64 {return 0};func (_aefac *templateProcessor )parseImage (_efabc *templateNode )(interface{},error ){var _aege string ;for _ ,_gdeg :=range _efabc ._bdbga .Attr {_cdagf :=_gdeg .Value ;switch _bbdfc :=_gdeg .Name .Local ;
_bbdfc {case "\u0073\u0072\u0063":_aege =_cdagf ;};};_fcbd ,_cbcbd :=_aefac .loadImageFromSrc (_aege );if _cbcbd !=nil {return nil ,_cbcbd ;};for _ ,_gdaea :=range _efabc ._bdbga .Attr {_afccae :=_gdaea .Value ;switch _bbcfe :=_gdaea .Name .Local ;_bbcfe {case "\u0061\u006c\u0069g\u006e":_fcbd .SetHorizontalAlignment (_aefac .parseHorizontalAlignmentAttr (_bbcfe ,_afccae ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fcbd .SetOpacity (_aefac .parseFloatAttr (_bbcfe ,_afccae ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bdgfa :=_aefac .parseMarginAttr (_bbcfe ,_afccae );_fcbd .SetMargins (_bdgfa .Left ,_bdgfa .Right ,_bdgfa .Top ,_bdgfa .Bottom );
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fcbd .SetFitMode (_aefac .parseFitModeAttr (_bbcfe ,_afccae ));case "\u0078":_fcbd .SetPos (_aefac .parseFloatAttr (_bbcfe ,_afccae ),_fcbd ._egbgf );case "\u0079":_fcbd .SetPos (_fcbd ._gbcdd ,_aefac .parseFloatAttr (_bbcfe ,_afccae ));
case "\u0077\u0069\u0064t\u0068":_fcbd .SetWidth (_aefac .parseFloatAttr (_bbcfe ,_afccae ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_fcbd .SetHeight (_aefac .parseFloatAttr (_bbcfe ,_afccae ));case "\u0061\u006e\u0067l\u0065":_fcbd .SetAngle (_aefac .parseFloatAttr (_bbcfe ,_afccae ));
case "\u0073\u0072\u0063":break ;default:_da .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_bbcfe );
};};return _fcbd ,nil ;};func _gfbde (_adfbcd *_fee .PdfAnnotation )*_fee .PdfAnnotation {if _adfbcd ==nil {return nil ;};var _cgda *_fee .PdfAnnotation ;switch _adfcc :=_adfbcd .GetContext ().(type ){case *_fee .PdfAnnotationLink :if _fabb :=_ceefe (_adfcc );
_fabb !=nil {_cgda =_fabb .PdfAnnotation ;};};return _cgda ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// SetHeading sets the text and the style of the heading of the TOC component.
func (_bebgf *TOC )SetHeading (text string ,style TextStyle ){_gfecg :=_bebgf .Heading ();_gfecg .Reset ();_agbfe :=_gfecg .Append (text );_agbfe .Style =style ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dgdg *Ellipse )SetFitMode (fitMode FitMode ){_dgdg ._ffgf =fitMode };func (_cbeff *Invoice )newCell (_bcadc string ,_gfbe InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_gfbe ,_bcadc };};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_ebfdf *TOC )SetLineSeparatorStyle (style TextStyle ){_ebfdf ._ffedc =style };

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_fdbg *GraphicSVG )Scale (xFactor ,yFactor float64 ){_fdbg ._cfff .Width =xFactor *_fdbg ._cfff .Width ;_fdbg ._cfff .Height =yFactor *_fdbg ._cfff .Height ;_fdbg ._cfff .SetScaling (xFactor ,yFactor );};

// NewImage create a new image from a unidoc image (model.Image).
func (_ggc *Creator )NewImage (img *_fee .Image )(*Image ,error ){return _gccg (img )};

// SetCoords sets the center coordinates of the ellipse.
func (_gfcg *Ellipse )SetCoords (xc ,yc float64 ){_gfcg ._gbd =xc ;_gfcg ._efd =yc };

// SetStyle sets the style of the line (solid or dashed).
func (_gdad *Line )SetStyle (style _bg .LineStyle ){_gdad ._gffb =style };

// SetBorderWidth sets the border width.
func (_fcacb *CurvePolygon )SetBorderWidth (borderWidth float64 ){_fcacb ._aaee .BorderWidth =borderWidth ;};func (_egcg *pageTransformations )applyFlip (_dddf *_fee .PdfPage )error {_dgee ,_fagbe :=_egcg ._ceeg ,_egcg ._agc ;if !_dgee &&!_fagbe {return nil ;
};if _dddf ==nil {return _d .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_daef ,_fce :=_dddf .GetMediaBox ();if _fce !=nil {return _fce ;};_bgfd ,_fcea :=_daef .Width (),_daef .Height ();_gcf ,_fce :=_dddf .GetRotate ();
if _fce !=nil {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_fce .Error ());
};if _egd :=_gcf %360!=0&&_gcf %90==0;_egd {if _dbbgd :=(360+_gcf %360)%360;_dbbgd ==90||_dbbgd ==270{_dgee ,_fagbe =_fagbe ,_dgee ;};};_bbgd ,_eefg :=1.0,0.0;if _dgee {_bbgd ,_eefg =-1.0,-_bgfd ;};_dcfd ,_eddd :=1.0,0.0;if _fagbe {_dcfd ,_eddd =-1.0,-_fcea ;
};_dgf :=_ebc .NewContentCreator ().Scale (_bbgd ,_dcfd ).Translate (_eefg ,_eddd );_ebea ,_fce :=_dd .MakeStream (_dgf .Bytes (),_dd .NewFlateEncoder ());if _fce !=nil {return _fce ;};_gbcd :=_dd .MakeArray (_ebea );_gbcd .Append (_dddf .GetContentStreamObjs ()...);
_dddf .Contents =_gbcd ;return nil ;};

// SetBackground sets the background properties of the component.
func (_gccde *Division )SetBackground (background *Background ){_gccde ._dgce =background };

// Append adds a new text chunk to the paragraph.
func (_gbgdf *StyledParagraph )Append (text string )*TextChunk {_babbc :=NewTextChunk (text ,_gbgdf ._cefc );return _gbgdf .appendChunk (_babbc );};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_abeb *shading )SetAntiAlias (enable bool ){_abeb ._fbfeg =enable };

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_becb *RadialShading )SetExtends (start bool ,end bool ){_becb ._ecef .SetExtends (start ,end )};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_ddcgd *RadialShading )AddPatternResource (block *Block )(_gagb _dd .PdfObjectName ,_aeeg error ){_ecca :=1;_caec :=_dd .PdfObjectName ("\u0050"+_fe .Itoa (_ecca ));for block ._gf .HasPatternByName (_caec ){_ecca ++;_caec =_dd .PdfObjectName ("\u0050"+_fe .Itoa (_ecca ));
};if _baed :=block ._gf .SetPatternByName (_caec ,_ddcgd .ToPdfShadingPattern ().ToPdfObject ());_baed !=nil {return "",_baed ;};return _caec ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fbbe *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbbe ._eebag .Left ,_fbbe ._eebag .Right ,_fbbe ._eebag .Top ,_fbbe ._eebag .Bottom ;};func (_cff *Block )addContents (_ab *_ebc .ContentStreamOperations ){_cff ._db .WrapIfNeeded ();
_ab .WrapIfNeeded ();*_cff ._db =append (*_cff ._db ,*_ab ...);};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_dbfa *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _d .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _d .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _d .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_dbfa ._dgaa =true ;_dbfa ._cfcgb =startRow ;_dbfa ._bgda =endRow ;return nil ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_befe *Creator )NewTextStyle ()TextStyle {return _fcff (_befe ._eedd )};func (_cfgfb *StyledParagraph )appendChunk (_eefgd *TextChunk )*TextChunk {_cfgfb ._adeb =append (_cfgfb ._adeb ,_eefgd );_cfgfb .wrapText ();return _eefgd ;};

// SetMargins sets the Paragraph's margins.
func (_cabf *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_cabf ._efbg .Left =left ;_cabf ._efbg .Right =right ;_cabf ._efbg .Top =top ;_cabf ._efbg .Bottom =bottom ;};func (_eggf *templateProcessor )parseColorAttr (_gfdef ,_aeaa string )Color {_da .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gfdef ,_aeaa );
_aeaa =_cf .TrimSpace (_aeaa );if _cf .HasPrefix (_aeaa ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_cf .HasSuffix (_aeaa ,"\u0029")&&len (_aeaa )> 17{return _eggf .parseLinearGradientAttr (_eggf .creator ,_aeaa );
};if _cf .HasPrefix (_aeaa ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_cf .HasSuffix (_aeaa ,"\u0029")&&len (_aeaa )> 17{return _eggf .parseRadialGradientAttr (_eggf .creator ,_aeaa );};if _dcbde :=_eggf .parseColor (_aeaa );
_dcbde !=nil {return _dcbde ;};return ColorBlack ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_acf *Creator )DrawHeader (drawHeaderFunc func (_afdb *Block ,_ebecd HeaderFunctionArgs )){_acf ._dbbg =drawHeaderFunc ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_fdddb *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bceef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bgaag ,_dcae :=_bceef .setOpacity (_fdddb ._aabg ,_fdddb ._ebef );if _dcae !=nil {return nil ,ctx ,_dcae ;
};_gfeab :=_fdddb ._cceb ;_gfeab .FillEnabled =_gfeab .FillColor !=nil ;var (_becfa =ctx .PageHeight ;_ebcg =_gfeab .Curves ;_gedae =make ([]_bg .CubicBezierCurve ,0,len (_gfeab .Curves )););_beaba :=_fee .PdfRectangle {};for _adbb :=range _gfeab .Curves {_eeabe :=_ebcg [_adbb ];
_eeabe .P0 .Y =_becfa -_eeabe .P0 .Y ;_eeabe .P1 .Y =_becfa -_eeabe .P1 .Y ;_eeabe .P2 .Y =_becfa -_eeabe .P2 .Y ;_eeabe .P3 .Y =_becfa -_eeabe .P3 .Y ;_gedae =append (_gedae ,_eeabe );_cbea :=_eeabe .GetBounds ();if _adbb ==0{_beaba =_cbea ;}else {_beaba .Llx =_fa .Min (_beaba .Llx ,_cbea .Llx );
_beaba .Lly =_fa .Min (_beaba .Lly ,_cbea .Lly );_beaba .Urx =_fa .Max (_beaba .Urx ,_cbea .Urx );_beaba .Ury =_fa .Max (_beaba .Ury ,_cbea .Ury );};};_gfeab .Curves =_gedae ;defer func (){_gfeab .Curves =_ebcg }();if _gfeab .FillEnabled {_gfdd :=_aacgba (_bceef ,_fdddb ._cceb .FillColor ,_fdddb ._dcfb ,func ()Rectangle {return Rectangle {_cfbab :_beaba .Llx ,_cffbf :_beaba .Lly ,_bfddd :_beaba .Width (),_abfd :_beaba .Height ()};
});if _gfdd !=nil {return nil ,ctx ,_gfdd ;};};_dfggb ,_ ,_dcae :=_gfeab .Draw (_bgaag );if _dcae !=nil {return nil ,ctx ,_dcae ;};if _dcae =_bceef .addContentsByString (string (_dfggb ));_dcae !=nil {return nil ,ctx ,_dcae ;};return []*Block {_bceef },ctx ,nil ;
};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_fabd *templateProcessor )parseTableCell (_bded *templateNode )(interface{},error ){if _bded ._bdgb ==nil {_da .Log .Error ("\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_cedeg ;};_ebfcf ,_fgeeg :=_bded ._bdgb ._bdced .(*Table );if !_fgeeg {_da .Log .Error ("\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_bded ._bdgb ._bdced );
return nil ,_cedeg ;};var _gabcd ,_cfffdg int64 ;for _ ,_ffgbg :=range _bded ._bdbga .Attr {_fegaa :=_ffgbg .Value ;switch _ddfaa :=_ffgbg .Name .Local ;_ddfaa {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_gabcd =_fabd .parseInt64Attr (_ddfaa ,_fegaa );
case "\u0072o\u0077\u0073\u0070\u0061\u006e":_cfffdg =_fabd .parseInt64Attr (_ddfaa ,_fegaa );};};if _gabcd <=0{_gabcd =1;};if _cfffdg <=0{_cfffdg =1;};_bdgdaf :=_ebfcf .MultiCell (int (_cfffdg ),int (_gabcd ));for _ ,_babce :=range _bded ._bdbga .Attr {_ccaeb :=_babce .Value ;
switch _fbbba :=_babce .Name .Local ;_fbbba {case "\u0069\u006e\u0064\u0065\u006e\u0074":_bdgdaf .SetIndent (_fabd .parseFloatAttr (_fbbba ,_ccaeb ));case "\u0061\u006c\u0069g\u006e":_bdgdaf .SetHorizontalAlignment (_fabd .parseCellAlignmentAttr (_fbbba ,_ccaeb ));
case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_bdgdaf .SetVerticalAlignment (_fabd .parseCellVerticalAlignmentAttr (_fbbba ,_ccaeb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_bdgdaf .SetSideBorderStyle (CellBorderSideAll ,_fabd .parseCellBorderStyleAttr (_fbbba ,_ccaeb ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_bdgdaf .SetSideBorderStyle (CellBorderSideTop ,_fabd .parseCellBorderStyleAttr (_fbbba ,_ccaeb ));case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_bdgdaf .SetSideBorderStyle (CellBorderSideBottom ,_fabd .parseCellBorderStyleAttr (_fbbba ,_ccaeb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_bdgdaf .SetSideBorderStyle (CellBorderSideLeft ,_fabd .parseCellBorderStyleAttr (_fbbba ,_ccaeb ));case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_bdgdaf .SetSideBorderStyle (CellBorderSideRight ,_fabd .parseCellBorderStyleAttr (_fbbba ,_ccaeb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_bdgdaf .SetSideBorderWidth (CellBorderSideAll ,_fabd .parseFloatAttr (_fbbba ,_ccaeb ));case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_bdgdaf .SetSideBorderWidth (CellBorderSideTop ,_fabd .parseFloatAttr (_fbbba ,_ccaeb ));
case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_bdgdaf .SetSideBorderWidth (CellBorderSideBottom ,_fabd .parseFloatAttr (_fbbba ,_ccaeb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_bdgdaf .SetSideBorderWidth (CellBorderSideLeft ,_fabd .parseFloatAttr (_fbbba ,_ccaeb ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_bdgdaf .SetSideBorderWidth (CellBorderSideRight ,_fabd .parseFloatAttr (_fbbba ,_ccaeb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_bdgdaf .SetSideBorderColor (CellBorderSideAll ,_fabd .parseColorAttr (_fbbba ,_ccaeb ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_bdgdaf .SetSideBorderColor (CellBorderSideTop ,_fabd .parseColorAttr (_fbbba ,_ccaeb ));case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_bdgdaf .SetSideBorderColor (CellBorderSideBottom ,_fabd .parseColorAttr (_fbbba ,_ccaeb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_bdgdaf .SetSideBorderColor (CellBorderSideLeft ,_fabd .parseColorAttr (_fbbba ,_ccaeb ));case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_bdgdaf .SetSideBorderColor (CellBorderSideRight ,_fabd .parseColorAttr (_fbbba ,_ccaeb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_bdgdaf .SetBorderLineStyle (_fabd .parseLineStyleAttr (_fbbba ,_ccaeb ));case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_bdgdaf .SetBackgroundColor (_fabd .parseColorAttr (_fbbba ,_ccaeb ));
case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_fbbba );
};};return _bdgdaf ,nil ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_aeec *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_ebdd *_fee .PdfWriter )error ){_aeec ._bcaa =pdfWriterAccessFunc ;};func _dgefe (_fccb *templateProcessor ,_ecacb *templateNode )(interface{},error ){return _fccb .parseDivision (_ecacb );
};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_cbc rune ;_ggce []error ;};

// NewColumn returns a new column for the line items invoice table.
func (_fed *Invoice )NewColumn (description string )*InvoiceCell {return _fed .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetIndent sets the cell's left indent.
func (_ffbe *TableCell )SetIndent (indent float64 ){_ffbe ._bdff =indent };

// NewPolygon creates a new polygon.
func (_ebed *Creator )NewPolygon (points [][]_bg .Point )*Polygon {return _aaefc (points )};

// GetMargins returns the left, right, top, bottom Margins.
func (_eeegg *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eeegg ._dceg .Left ,_eeegg ._dceg .Right ,_eeegg ._dceg .Top ,_eeegg ._dceg .Bottom ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_bacba *TextChunk )SetAnnotation (annotation *_fee .PdfAnnotation ){_bacba ._beebgd =annotation };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_adfd *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ecgeb :=ctx ;var _gdcd []*Block ;_cagb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _adfd ._fgecf .IsRelative (){ctx .X +=_adfd ._efbg .Left ;ctx .Y +=_adfd ._efbg .Top ;
ctx .Width -=_adfd ._efbg .Left +_adfd ._efbg .Right ;ctx .Height -=_adfd ._efbg .Top ;_adfd .SetWidth (ctx .Width );if _adfd .Height ()> ctx .Height {_gdcd =append (_gdcd ,_cagb );_cagb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gbga :=ctx ;
_gbga .Y =ctx .Margins .Top ;_gbga .X =ctx .Margins .Left +_adfd ._efbg .Left ;_gbga .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_gbga .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_adfd ._efbg .Left -_adfd ._efbg .Right ;
ctx =_gbga ;};}else {if int (_adfd ._bgdg )<=0{_adfd .SetWidth (_adfd .getTextWidth ());};ctx .X =_adfd ._gbfc ;ctx .Y =_adfd ._bfcd ;};ctx ,_adag :=_ccea (_cagb ,_adfd ,ctx );if _adag !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_adag );
return nil ,ctx ,_adag ;};_gdcd =append (_gdcd ,_cagb );if _adfd ._fgecf .IsRelative (){ctx .Y +=_adfd ._efbg .Bottom ;ctx .Height -=_adfd ._efbg .Bottom ;if !ctx .Inline {ctx .X =_ecgeb .X ;ctx .Width =_ecgeb .Width ;};return _gdcd ,ctx ,nil ;};return _gdcd ,_ecgeb ,nil ;
};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_gcab *LinearShading )SetExtends (start bool ,end bool ){_gcab ._adece .SetExtends (start ,end )};

// SetMargins sets the margins of the graphic svg component.
func (_ecdea *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_ecdea ._dadde .Left =left ;_ecdea ._dadde .Right =right ;_ecdea ._dadde .Top =top ;_ecdea ._dadde .Bottom =bottom ;};var (_ggdbc =_ae .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");
_eacgc =_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");_cedeg =_d .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");
_gffbc =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");_gaeg =_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e");
);

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_acfgd *TOCLine )SetLevelOffset (levelOffset float64 ){_acfgd ._eedde =levelOffset ;_acfgd ._dabee ._eebag .Left =_acfgd ._gfgb +float64 (_acfgd ._bbec -1)*_acfgd ._eedde ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetMargins sets the margins of the paragraph.
func (_bfgd *List )SetMargins (left ,right ,top ,bottom float64 ){_bfgd ._bffg .Left =left ;_bfgd ._bffg .Right =right ;_bfgd ._bffg .Top =top ;_bfgd ._bffg .Bottom =bottom ;};func _ffcc (_adgdd *templateProcessor ,_ggege *templateNode )(interface{},error ){return _adgdd .parseChapter (_ggege );
};func _ggb (_fcf string )string {_dgca :=_bee .FindAllString (_fcf ,-1);if len (_dgca )==0{_fcf =_fcf +"\u0030";}else {_acbe ,_eee :=_fe .Atoi (_dgca [len (_dgca )-1]);if _eee !=nil {_da .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_eee );
_fcf =_fcf +"\u0030";}else {_acbe ++;_cbee :=_cf .LastIndex (_fcf ,_dgca [len (_dgca )-1]);if _cbee ==-1{_fcf =_fb .Sprintf ("\u0025\u0073\u0025\u0064",_fcf [:len (_fcf )-1],_acbe );}else {_fcf =_fcf [:_cbee ]+_fe .Itoa (_acbe );};};};return _fcf ;};func (_faee *templateProcessor )parsePositioningAttr (_faca ,_face string )Positioning {_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_faca ,_face );
_dfag :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_face ];return _dfag ;};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_agbge *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebebc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egce ,_bacfa :=_ebebc .setOpacity (_agbge ._aacf ,_agbge ._ecbgf );if _bacfa !=nil {return nil ,ctx ,_bacfa ;
};_deeg :=_agbge ._ebdcd ;_deeg .FillEnabled =_deeg .FillColor !=nil ;_deeg .BorderEnabled =_deeg .BorderColor !=nil &&_deeg .BorderWidth > 0;_acgcf :=_deeg .Points ;_ded :=_fee .PdfRectangle {};_effcd :=false ;for _agcc :=range _acgcf {for _abbg :=range _acgcf [_agcc ]{_adef :=&_acgcf [_agcc ][_abbg ];
_adef .Y =ctx .PageHeight -_adef .Y ;if !_effcd {_ded .Llx =_adef .X ;_ded .Lly =_adef .Y ;_ded .Urx =_adef .X ;_ded .Ury =_adef .Y ;_effcd =true ;}else {_ded .Llx =_fa .Min (_ded .Llx ,_adef .X );_ded .Lly =_fa .Min (_ded .Lly ,_adef .Y );_ded .Urx =_fa .Max (_ded .Urx ,_adef .X );
_ded .Ury =_fa .Max (_ded .Ury ,_adef .Y );};};};if _deeg .FillEnabled {_gfefg :=_aacgba (_ebebc ,_agbge ._ebdcd .FillColor ,_agbge ._ecad ,func ()Rectangle {return Rectangle {_cfbab :_ded .Llx ,_cffbf :_ded .Lly ,_bfddd :_ded .Width (),_abfd :_ded .Height ()};
});if _gfefg !=nil {return nil ,ctx ,_gfefg ;};};_afcee ,_ ,_bacfa :=_deeg .Draw (_egce );if _bacfa !=nil {return nil ,ctx ,_bacfa ;};if _bacfa =_ebebc .addContentsByString (string (_afcee ));_bacfa !=nil {return nil ,ctx ,_bacfa ;};return []*Block {_ebebc },ctx ,nil ;
};

// GeneratePageBlocks implements drawable interface.
func (_cccg *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dccg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bbag :=_cccg ._bgg ;_babb :=ctx .PageHeight -_cccg ._ebg ;if _cccg ._aeea !=nil {_aea :=_bg .Rectangle {Opacity :1.0,X :_cccg ._bgg ,Y :ctx .PageHeight -_cccg ._ebg -_cccg ._aed ,Height :_cccg ._aed ,Width :_cccg ._dgda };
_aea .FillEnabled =true ;_gbb :=_cfd (_cccg ._aeea );_cdfb :=_aacgba (_dccg ,_gbb ,_cccg ._aeea ,func ()Rectangle {return Rectangle {_cfbab :_aea .X ,_cffbf :_aea .Y ,_bfddd :_aea .Width ,_abfd :_aea .Height };});if _cdfb !=nil {return nil ,ctx ,_cdfb ;
};_aea .FillColor =_gbb ;_aea .BorderEnabled =false ;_dbc ,_ ,_cdfb :=_aea .Draw ("");if _cdfb !=nil {return nil ,ctx ,_cdfb ;};_cdfb =_dccg .addContentsByString (string (_dbc ));if _cdfb !=nil {return nil ,ctx ,_cdfb ;};};_cdfa :=_cccg ._gab ;_egef :=_cccg ._eec ;
_ccg :=_cccg ._bbd ;_gfad :=_cccg ._cee ;_gdaa :=_cccg ._gab ;if _cccg ._cffc ==CellBorderStyleDouble {_gdaa +=2*_cdfa ;};_bgb :=_cccg ._eec ;if _cccg ._beb ==CellBorderStyleDouble {_bgb +=2*_egef ;};_bffa :=_cccg ._bbd ;if _cccg ._ece ==CellBorderStyleDouble {_bffa +=2*_ccg ;
};_fead :=_cccg ._cee ;if _cccg ._eccg ==CellBorderStyleDouble {_fead +=2*_gfad ;};_abfc :=(_gdaa -_bffa )/2;_adgb :=(_gdaa -_fead )/2;_gec :=(_bgb -_bffa )/2;_gfag :=(_bgb -_fead )/2;if _cccg ._gab !=0{_cdab :=_bbag ;_gde :=_babb ;if _cccg ._cffc ==CellBorderStyleDouble {_gde -=_cdfa ;
_acbg :=_bg .BasicLine {LineColor :_cfd (_cccg ._bfgc ),Opacity :1.0,LineWidth :_cccg ._gab ,LineStyle :_cccg .LineStyle ,X1 :_cdab -_gdaa /2+_abfc ,Y1 :_gde +2*_cdfa ,X2 :_cdab +_gdaa /2-_adgb +_cccg ._dgda ,Y2 :_gde +2*_cdfa };_ddg ,_ ,_adfa :=_acbg .Draw ("");
if _adfa !=nil {return nil ,ctx ,_adfa ;};_adfa =_dccg .addContentsByString (string (_ddg ));if _adfa !=nil {return nil ,ctx ,_adfa ;};};_bdd :=_bg .BasicLine {LineWidth :_cccg ._gab ,Opacity :1.0,LineColor :_cfd (_cccg ._bfgc ),LineStyle :_cccg .LineStyle ,X1 :_cdab -_gdaa /2+_abfc +(_bffa -_cccg ._bbd ),Y1 :_gde ,X2 :_cdab +_gdaa /2-_adgb +_cccg ._dgda -(_fead -_cccg ._cee ),Y2 :_gde };
_bcdd ,_ ,_afb :=_bdd .Draw ("");if _afb !=nil {return nil ,ctx ,_afb ;};_afb =_dccg .addContentsByString (string (_bcdd ));if _afb !=nil {return nil ,ctx ,_afb ;};};if _cccg ._eec !=0{_adfab :=_bbag ;_efg :=_babb -_cccg ._aed ;if _cccg ._beb ==CellBorderStyleDouble {_efg +=_egef ;
_cba :=_bg .BasicLine {LineWidth :_cccg ._eec ,Opacity :1.0,LineColor :_cfd (_cccg ._beed ),LineStyle :_cccg .LineStyle ,X1 :_adfab -_bgb /2+_gec ,Y1 :_efg -2*_egef ,X2 :_adfab +_bgb /2-_gfag +_cccg ._dgda ,Y2 :_efg -2*_egef };_ebe ,_ ,_adc :=_cba .Draw ("");
if _adc !=nil {return nil ,ctx ,_adc ;};_adc =_dccg .addContentsByString (string (_ebe ));if _adc !=nil {return nil ,ctx ,_adc ;};};_cfge :=_bg .BasicLine {LineWidth :_cccg ._eec ,Opacity :1.0,LineColor :_cfd (_cccg ._beed ),LineStyle :_cccg .LineStyle ,X1 :_adfab -_bgb /2+_gec +(_bffa -_cccg ._bbd ),Y1 :_efg ,X2 :_adfab +_bgb /2-_gfag +_cccg ._dgda -(_fead -_cccg ._cee ),Y2 :_efg };
_dfb ,_ ,_ggba :=_cfge .Draw ("");if _ggba !=nil {return nil ,ctx ,_ggba ;};_ggba =_dccg .addContentsByString (string (_dfb ));if _ggba !=nil {return nil ,ctx ,_ggba ;};};if _cccg ._bbd !=0{_fagb :=_bbag ;_abdd :=_babb ;if _cccg ._ece ==CellBorderStyleDouble {_fagb +=_ccg ;
_aeeb :=_bg .BasicLine {LineWidth :_cccg ._bbd ,Opacity :1.0,LineColor :_cfd (_cccg ._ege ),LineStyle :_cccg .LineStyle ,X1 :_fagb -2*_ccg ,Y1 :_abdd +_bffa /2+_abfc ,X2 :_fagb -2*_ccg ,Y2 :_abdd -_bffa /2-_gec -_cccg ._aed };_dbcb ,_ ,_ceb :=_aeeb .Draw ("");
if _ceb !=nil {return nil ,ctx ,_ceb ;};_ceb =_dccg .addContentsByString (string (_dbcb ));if _ceb !=nil {return nil ,ctx ,_ceb ;};};_dbde :=_bg .BasicLine {LineWidth :_cccg ._bbd ,Opacity :1.0,LineColor :_cfd (_cccg ._ege ),LineStyle :_cccg .LineStyle ,X1 :_fagb ,Y1 :_abdd +_bffa /2+_abfc -(_gdaa -_cccg ._gab ),X2 :_fagb ,Y2 :_abdd -_bffa /2-_gec -_cccg ._aed +(_bgb -_cccg ._eec )};
_fdb ,_ ,_egff :=_dbde .Draw ("");if _egff !=nil {return nil ,ctx ,_egff ;};_egff =_dccg .addContentsByString (string (_fdb ));if _egff !=nil {return nil ,ctx ,_egff ;};};if _cccg ._cee !=0{_dbg :=_bbag +_cccg ._dgda ;_ccbf :=_babb ;if _cccg ._eccg ==CellBorderStyleDouble {_dbg -=_gfad ;
_bbg :=_bg .BasicLine {LineWidth :_cccg ._cee ,Opacity :1.0,LineColor :_cfd (_cccg ._ecba ),LineStyle :_cccg .LineStyle ,X1 :_dbg +2*_gfad ,Y1 :_ccbf +_fead /2+_adgb ,X2 :_dbg +2*_gfad ,Y2 :_ccbf -_fead /2-_gfag -_cccg ._aed };_gcd ,_ ,_gecc :=_bbg .Draw ("");
if _gecc !=nil {return nil ,ctx ,_gecc ;};_gecc =_dccg .addContentsByString (string (_gcd ));if _gecc !=nil {return nil ,ctx ,_gecc ;};};_cbefe :=_bg .BasicLine {LineWidth :_cccg ._cee ,Opacity :1.0,LineColor :_cfd (_cccg ._ecba ),LineStyle :_cccg .LineStyle ,X1 :_dbg ,Y1 :_ccbf +_fead /2+_adgb -(_gdaa -_cccg ._gab ),X2 :_dbg ,Y2 :_ccbf -_fead /2-_gfag -_cccg ._aed +(_bgb -_cccg ._eec )};
_aace ,_ ,_aab :=_cbefe .Draw ("");if _aab !=nil {return nil ,ctx ,_aab ;};_aab =_dccg .addContentsByString (string (_aace ));if _aab !=nil {return nil ,ctx ,_aab ;};};return []*Block {_dccg },ctx ,nil ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_bcc :_fa .Min (float64 (c ),100)/100.0,_gdg :_fa .Min (float64 (m ),100)/100.0,_fbba :_fa .Min (float64 (y ),100)/100.0,_dgdaf :_fa .Min (float64 (k ),100)/100.0};};

// SetEnableWrap sets the line wrapping enabled flag.
func (_eagc *StyledParagraph )SetEnableWrap (enableWrap bool ){_eagc ._egge =enableWrap ;_eagc ._cbbga =false ;};func _abgd (_bcg []byte )(*Image ,error ){_eeeb :=_c .NewReader (_bcg );_cddc ,_cedf :=_fee .ImageHandling .Read (_eeeb );if _cedf !=nil {_da .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cedf );
return nil ,_cedf ;};return _gccg (_cddc );};func _gddgf (_ggag []*ColorPoint )*LinearShading {return &LinearShading {_adece :&shading {_bbcfd :ColorWhite ,_fbfeg :false ,_gcefb :[]bool {false ,false },_ccff :_ggag },_ecbd :&_fee .PdfRectangle {}};};func _gdfbf (_cege [][]_bg .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_aaee :&_bg .CurvePolygon {Rings :_cege },_febb :1.0,_efeb :1.0};
};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_acacc *LinearShading )SetAntiAlias (enable bool ){_acacc ._adece .SetAntiAlias (enable )};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};func (_ddfeb *templateProcessor )parseBackground (_ccbcf *templateNode )(interface{},error ){_fggaf :=&Background {};for _ ,_bafb :=range _ccbcf ._bdbga .Attr {_eaceg :=_bafb .Value ;
switch _ebebf :=_bafb .Name .Local ;_ebebf {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_fggaf .FillColor =_ddfeb .parseColorAttr (_ebebf ,_eaceg );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_fggaf .BorderColor =_ddfeb .parseColorAttr (_ebebf ,_eaceg );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_fggaf .BorderSize =_ddfeb .parseFloatAttr (_ebebf ,_eaceg );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_faed ,_bdefa ,_fdef ,_effea :=_ddfeb .parseBorderRadiusAttr (_ebebf ,_eaceg );
_fggaf .SetBorderRadius (_faed ,_bdefa ,_effea ,_fdef );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_fggaf .BorderRadiusTopLeft =_ddfeb .parseFloatAttr (_ebebf ,_eaceg );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_fggaf .BorderRadiusTopRight =_ddfeb .parseFloatAttr (_ebebf ,_eaceg );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_fggaf .BorderRadiusBottomLeft =_ddfeb .parseFloatAttr (_ebebf ,_eaceg );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_fggaf .BorderRadiusBottomRight =_ddfeb .parseFloatAttr (_ebebf ,_eaceg );
default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ebebf );
};};return _fggaf ,nil ;};func _aagf (_aageb *templateProcessor ,_dgaecc *templateNode )(interface{},error ){return _aageb .parseEllipse (_dgaecc );};func (_ccdbc *templateProcessor )parseMarginAttr (_fbefg ,_effeb string )Margins {_da .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_fbefg ,_effeb );
_cbdb :=Margins {};switch _daab :=_cf .Fields (_effeb );len (_daab ){case 1:_cbdb .Top ,_ =_fe .ParseFloat (_daab [0],64);_cbdb .Bottom =_cbdb .Top ;_cbdb .Left =_cbdb .Top ;_cbdb .Right =_cbdb .Top ;case 2:_cbdb .Top ,_ =_fe .ParseFloat (_daab [0],64);
_cbdb .Bottom =_cbdb .Top ;_cbdb .Left ,_ =_fe .ParseFloat (_daab [1],64);_cbdb .Right =_cbdb .Left ;case 3:_cbdb .Top ,_ =_fe .ParseFloat (_daab [0],64);_cbdb .Left ,_ =_fe .ParseFloat (_daab [1],64);_cbdb .Right =_cbdb .Left ;_cbdb .Bottom ,_ =_fe .ParseFloat (_daab [2],64);
case 4:_cbdb .Top ,_ =_fe .ParseFloat (_daab [0],64);_cbdb .Right ,_ =_fe .ParseFloat (_daab [1],64);_cbdb .Bottom ,_ =_fe .ParseFloat (_daab [2],64);_cbdb .Left ,_ =_fe .ParseFloat (_daab [3],64);};return _cbdb ;};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_bffae *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _bbcf (x1 ,y1 ,x2 ,y2 )};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_bcca *TOCLine )SetLink (page int64 ,x ,y float64 ){_bcca ._becg =x ;_bcca ._gfcef =y ;_bcca ._edbf =page ;_gbdge :=_bcca ._dabee ._fecf .Color ;_bcca .Number .Style .Color =_gbdge ;_bcca .Title .Style .Color =_gbdge ;_bcca .Separator .Style .Color =_gbdge ;
_bcca .Page .Style .Color =_gbdge ;};func _cefa (_babbb *templateProcessor ,_ecabe *templateNode )(interface{},error ){return _babbb .parseBackground (_ecabe );};func _afbgg (_febbg _a .Image )(*Image ,error ){_dbga ,_acd :=_fee .ImageHandling .NewImageFromGoImage (_febbg );
if _acd !=nil {return nil ,_acd ;};return _gccg (_dbga );};func (_gcbe *Invoice )generateTotalBlocks (_cga DrawContext )([]*Block ,DrawContext ,error ){_ffdf :=_agegf (4);_ffdf .SetMargins (0,0,10,10);_bfgb :=[][2]*InvoiceCell {_gcbe ._decgf };_bfgb =append (_bfgb ,_gcbe ._gcffc ...);
_bfgb =append (_bfgb ,_gcbe ._abb );for _ ,_acce :=range _bfgb {_cbba ,_dbba :=_acce [0],_acce [1];if _dbba .Value ==""{continue ;};_ffdf .SkipCells (2);_dca :=_ffdf .NewCell ();_dca .SetBackgroundColor (_cbba .BackgroundColor );_dca .SetHorizontalAlignment (_dbba .Alignment );
_gcbe .setCellBorder (_dca ,_cbba );_egfe :=_dccc (_cbba .TextStyle );_egfe .SetMargins (0,0,2,1);_egfe .Append (_cbba .Value );_dca .SetContent (_egfe );_dca =_ffdf .NewCell ();_dca .SetBackgroundColor (_dbba .BackgroundColor );_dca .SetHorizontalAlignment (_dbba .Alignment );
_gcbe .setCellBorder (_dca ,_cbba );_egfe =_dccc (_dbba .TextStyle );_egfe .SetMargins (0,0,2,1);_egfe .Append (_dbba .Value );_dca .SetContent (_egfe );};return _ffdf .GeneratePageBlocks (_cga );};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_bfe *Block )Draw (d Drawable )error {_fac :=DrawContext {};_fac .Width =_bfe ._bab ;_fac .Height =_bfe ._egb ;_fac .PageWidth =_bfe ._bab ;_fac .PageHeight =_bfe ._egb ;_fac .X =0;_fac .Y =0;_dfd ,_ ,_feb :=d .GeneratePageBlocks (_fac );if _feb !=nil {return _feb ;
};if len (_dfd )!=1{return _d .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_cdf :=range _dfd {if _ag :=_bfe .mergeBlocks (_cdf );_ag !=nil {return _ag ;};};return nil ;
};

// SetStyleTop sets border style for top side.
func (_gbg *border )SetStyleTop (style CellBorderStyle ){_gbg ._cffc =style };func _cbgdfe (_ccbd *templateProcessor ,_bffb *templateNode )(interface{},error ){return _ccbd .parseTextChunk (_bffb ,nil );};

// SetColorLeft sets border color for left.
func (_dbea *border )SetColorLeft (col Color ){_dbea ._ege =col };

// NewPageBreak create a new page break.
func (_cebb *Creator )NewPageBreak ()*PageBreak {return _gaffdg ()};func (_dgdae *templateProcessor )parseBorderRadiusAttr (_ecab ,_bfbec string )(_dbdgd ,_dedg ,_ebge ,_bfgdc float64 ){_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_ecab ,_bfbec );
switch _fcdc :=_cf .Fields (_bfbec );len (_fcdc ){case 1:_dbdgd ,_ =_fe .ParseFloat (_fcdc [0],64);_dedg =_dbdgd ;_ebge =_dbdgd ;_bfgdc =_dbdgd ;case 2:_dbdgd ,_ =_fe .ParseFloat (_fcdc [0],64);_ebge =_dbdgd ;_dedg ,_ =_fe .ParseFloat (_fcdc [1],64);_bfgdc =_dedg ;
case 3:_dbdgd ,_ =_fe .ParseFloat (_fcdc [0],64);_dedg ,_ =_fe .ParseFloat (_fcdc [1],64);_bfgdc =_dedg ;_ebge ,_ =_fe .ParseFloat (_fcdc [2],64);case 4:_dbdgd ,_ =_fe .ParseFloat (_fcdc [0],64);_dedg ,_ =_fe .ParseFloat (_fcdc [1],64);_ebge ,_ =_fe .ParseFloat (_fcdc [2],64);
_bfgdc ,_ =_fe .ParseFloat (_fcdc [3],64);};return _dbdgd ,_dedg ,_ebge ,_bfgdc ;};func _gfcee (_gcced float64 ,_fcdg float64 )float64 {return _fa .Round (_gcced /_fcdg )*_fcdg };func _aaefc (_adacc [][]_bg .Point )*Polygon {return &Polygon {_ebdcd :&_bg .Polygon {Points :_adacc },_aacf :1.0,_ecbgf :1.0};
};

// SetBorderWidth sets the border width of the rectangle.
func (_decc *Rectangle )SetBorderWidth (bw float64 ){_decc ._egde =bw };

// SetStyleBottom sets border style for bottom side.
func (_eccf *border )SetStyleBottom (style CellBorderStyle ){_eccf ._beb =style };func (_fgag *templateProcessor )parseAttrPropList (_cfgfd string )map[string ]string {_gfgcf :=_cf .Fields (_cfgfd );if len (_gfgcf )==0{return nil ;};_cggbe :=map[string ]string {};
for _ ,_efcaf :=range _gfgcf {_fbaf :=_ggdbc .FindStringSubmatch (_efcaf );if len (_fbaf )< 3{continue ;};_ebcf ,_dgdb :=_cf .TrimSpace (_fbaf [1]),_fbaf [2];if _ebcf ==""{continue ;};_cggbe [_ebcf ]=_dgdb ;};return _cggbe ;};

// Height returns the height of the chart.
func (_beea *Chart )Height ()float64 {return float64 (_beea ._edbg .Height ())};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_fccf *Rectangle )ScaleToHeight (h float64 ){_ggbf :=_fccf ._bfddd /_fccf ._abfd ;_fccf ._abfd =h ;_fccf ._bfddd =h *_ggbf ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_begc *Invoice )SetNoteStyle (style TextStyle ){_begc ._dabeb =style };func (_gdbg *templateProcessor )parseInt64Array (_degdg ,_cbcg string )[]int64 {_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_degdg ,_cbcg );
_fggb :=_cf .Fields (_cbcg );_eggc :=make ([]int64 ,0,len (_fggb ));for _ ,_abdea :=range _fggb {_feae ,_ :=_fe .ParseInt (_abdea ,10,64);_eggc =append (_eggc ,_feae );};return _eggc ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_egdc *FilledCurve )AppendCurve (curve _bg .CubicBezierCurve )*FilledCurve {_egdc ._ddfce =append (_egdc ._ddfce ,curve );return _egdc ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_eaed *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_eaed ._fgde =toc ;};func (_aecff *templateProcessor )parseCellVerticalAlignmentAttr (_edced ,_eccbc string )CellVerticalAlignment {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_edced ,_eccbc );
_baafb :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_eccbc ];return _baafb ;
};

// Height returns the total height of all rows.
func (_beecd *Table )Height ()float64 {_aaeaa :=float64 (0.0);for _ ,_fbdge :=range _beecd ._agda {_aaeaa +=_fbdge ;};return _aaeaa ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_efcg *Invoice )NoteStyle ()TextStyle {return _efcg ._dabeb };func (_gbba *TemplateOptions )init (){if _gbba .SubtemplateMap ==nil {_gbba .SubtemplateMap =map[string ]_fg .Reader {};};if _gbba .FontMap ==nil {_gbba .FontMap =map[string ]*_fee .PdfFont {};
};if _gbba .ImageMap ==nil {_gbba .ImageMap =map[string ]*_fee .Image {};};if _gbba .ColorMap ==nil {_gbba .ColorMap =map[string ]Color {};};if _gbba .ChartMap ==nil {_gbba .ChartMap =map[string ]_ef .ChartRenderable {};};};

// Margins returns the margins of the list: left, right, top, bottom.
func (_gbafa *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _gbafa ._bffg .Left ,_gbafa ._bffg .Right ,_gbafa ._bffg .Top ,_gbafa ._bffg .Bottom ;};func (_aegb *TOCLine )getLineLink ()*_fee .PdfAnnotation {if _aegb ._edbf <=0{return nil ;
};return _gabgca (_aegb ._edbf -1,_aegb ._becg ,_aegb ._gfcef ,0);};func _geed (_cecd *_fee .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_cecd ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func (_dgcdg *templateProcessor )parseInt64Attr (_befc ,_abgg string )int64 {_da .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_befc ,_abgg );
_gbgbd ,_ :=_fe .ParseInt (_abgg ,10,64);return _gbgbd ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_cfbab float64 ;_cffbf float64 ;_bfddd float64 ;_abfd float64 ;_fgaa Positioning ;_cdgf Color ;_ffdfg float64 ;_eggbc Color ;_egde float64 ;_cgbf float64 ;_egdce float64 ;_edac float64 ;_cdfge float64 ;_cfef float64 ;_gcag Margins ;
_fefc FitMode ;};func (_fbfg *Table )clone ()*Table {_dfacc :=*_fbfg ;_dfacc ._agda =make ([]float64 ,len (_fbfg ._agda ));copy (_dfacc ._agda ,_fbfg ._agda );_dfacc ._fadgg =make ([]float64 ,len (_fbfg ._fadgg ));copy (_dfacc ._fadgg ,_fbfg ._fadgg );
_dfacc ._afbaa =make ([]*TableCell ,0,len (_fbfg ._afbaa ));for _ ,_egfac :=range _fbfg ._afbaa {_bbcga :=*_egfac ;_bbcga ._fagfd =&_dfacc ;_dfacc ._afbaa =append (_dfacc ._afbaa ,&_bbcga );};return &_dfacc ;};

// GetIndent get the cell's left indent.
func (_dafbd *TableCell )GetIndent ()float64 {return _dafbd ._bdff };

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_abfba Color ;_gfeg float64 ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_aacgbc *TableCell )SetBorderLineStyle (style _bg .LineStyle ){_aacgbc ._gaeaa =style };

// Lines returns all the rows of the invoice line items table.
func (_cbag *Invoice )Lines ()[][]*InvoiceCell {return _cbag ._ccbed };

// NewCurvePolygon creates a new curve polygon.
func (_fgbb *Creator )NewCurvePolygon (rings [][]_bg .CubicBezierCurve )*CurvePolygon {return _gdfbf (rings );};

// Link returns link information for this line.
func (_gbgfc *TOCLine )Link ()(_cfgcf int64 ,_ccfec ,_fdadd float64 ){return _gbgfc ._edbf ,_gbgfc ._becg ,_gbgfc ._gfcef ;};

// NewPolyline creates a new polyline.
func (_affc *Creator )NewPolyline (points []_bg .Point )*Polyline {return _ceab (points )};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_adbga *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _adbga ._aaae ==nil {if _feeda :=_adbga .makeXObject ();_feeda !=nil {return nil ,ctx ,_feeda ;};};var _bfbaa []*Block ;_gegf :=ctx ;_bdec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _adbga ._agagd .IsRelative (){_adbga .applyFitMode (ctx .Width );ctx .X +=_adbga ._dgb .Left ;ctx .Y +=_adbga ._dgb .Top ;ctx .Width -=_adbga ._dgb .Left +_adbga ._dgb .Right ;ctx .Height -=_adbga ._dgb .Top +_adbga ._dgb .Bottom ;if _adbga ._eega > ctx .Height {_bfbaa =append (_bfbaa ,_bdec );
_bdec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_edcb :=ctx ;_edcb .Y =ctx .Margins .Top +_adbga ._dgb .Top ;_edcb .X =ctx .Margins .Left +_adbga ._dgb .Left ;_edcb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_adbga ._dgb .Top -_adbga ._dgb .Bottom ;
_edcb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_adbga ._dgb .Left -_adbga ._dgb .Right ;ctx =_edcb ;};}else {ctx .X =_adbga ._gbcdd ;ctx .Y =_adbga ._egbgf ;};ctx ,_eafa :=_ceaf (_bdec ,_adbga ,ctx );if _eafa !=nil {return nil ,ctx ,_eafa ;
};_bfbaa =append (_bfbaa ,_bdec );if _adbga ._agagd .IsAbsolute (){ctx =_gegf ;}else {ctx .X =_gegf .X ;ctx .Width =_gegf .Width ;ctx .Y +=_adbga ._dgb .Bottom ;};return _bfbaa ,ctx ,nil ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_afdab *StyledParagraph )SetTextAlignment (align TextAlignment ){_afdab ._fdge =align };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_fgdd *shading )SetBackgroundColor (backgroundColor Color ){_fgdd ._bbcfd =backgroundColor };

// SetOpacity sets opacity for Image.
func (_fefe *Image )SetOpacity (opacity float64 ){_fefe ._edcd =opacity };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_ceeb *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ceeb ._bcbb .Left ,_ceeb ._bcbb .Right ,_ceeb ._bcbb .Top ,_ceeb ._bcbb .Bottom ;};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_adfbb *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_beaf []*Block ;_cbeg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_becf =ctx ;_fgeca ,_bcfd =_adfbb ._bcgf ,ctx .PageHeight -_adfbb ._fgba ;_dafg ,_acad =_adfbb ._ecec ,ctx .PageHeight -_adfbb ._daac ;
);_bfafd :=_adfbb ._aede .IsRelative ();if _bfafd {ctx .X +=_adfbb ._cfdcg .Left ;ctx .Y +=_adfbb ._cfdcg .Top ;ctx .Width -=_adfbb ._cfdcg .Left +_adfbb ._cfdcg .Right ;ctx .Height -=_adfbb ._cfdcg .Top +_adfbb ._cfdcg .Bottom ;_fgeca ,_bcfd ,_dafg ,_acad =_adfbb .computeCoords (ctx );
if _adfbb .Height ()> ctx .Height {_beaf =append (_beaf ,_cbeg );_cbeg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_baec :=ctx ;_baec .Y =ctx .Margins .Top +_adfbb ._cfdcg .Top ;_baec .X =ctx .Margins .Left +_adfbb ._cfdcg .Left ;_baec .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_adfbb ._cfdcg .Top -_adfbb ._cfdcg .Bottom ;
_baec .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_adfbb ._cfdcg .Left -_adfbb ._cfdcg .Right ;ctx =_baec ;_fgeca ,_bcfd ,_dafg ,_acad =_adfbb .computeCoords (ctx );};};_aega :=_bg .BasicLine {X1 :_fgeca ,Y1 :_bcfd ,X2 :_dafg ,Y2 :_acad ,LineColor :_cfd (_adfbb ._bec ),Opacity :_adfbb ._dcfe ,LineWidth :_adfbb ._bdfc ,LineStyle :_adfbb ._gffb ,DashArray :_adfbb ._fafa ,DashPhase :_adfbb ._ccgd };
_dcfa ,_ggcb :=_cbeg .setOpacity (1.0,_adfbb ._dcfe );if _ggcb !=nil {return nil ,ctx ,_ggcb ;};_bcbe ,_ ,_ggcb :=_aega .Draw (_dcfa );if _ggcb !=nil {return nil ,ctx ,_ggcb ;};if _ggcb =_cbeg .addContentsByString (string (_bcbe ));_ggcb !=nil {return nil ,ctx ,_ggcb ;
};if _bfafd {ctx .X =_becf .X ;ctx .Width =_becf .Width ;_bbba :=_adfbb .Height ();ctx .Y +=_bbba +_adfbb ._cfdcg .Bottom ;ctx .Height -=_bbba ;}else {ctx =_becf ;};_beaf =append (_beaf ,_cbeg );return _beaf ,ctx ,nil ;};func (_gbecc *templateProcessor )parseCellAlignmentAttr (_beca ,_effcb string )CellHorizontalAlignment {_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_beca ,_effcb );
_cegadb :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_effcb ];return _cegadb ;
};func (_dcdc *templateProcessor )parseParagraph (_gbcbg *templateNode ,_cbfc *Paragraph )(interface{},error ){if _cbfc ==nil {_cbfc =_dcdc .creator .NewParagraph ("");};for _ ,_gegd :=range _gbcbg ._bdbga .Attr {_dedb :=_gegd .Value ;switch _efaa :=_gegd .Name .Local ;
_efaa {case "\u0066\u006f\u006e\u0074":_cbfc .SetFont (_dcdc .parseFontAttr (_efaa ,_dedb ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_cbfc .SetFontSize (_dcdc .parseFloatAttr (_efaa ,_dedb ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cbfc .SetTextAlignment (_dcdc .parseTextAlignmentAttr (_efaa ,_dedb ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_cbfc .SetLineHeight (_dcdc .parseFloatAttr (_efaa ,_dedb ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_cbfc .SetEnableWrap (_dcdc .parseBoolAttr (_efaa ,_dedb ));
case "\u0063\u006f\u006co\u0072":_cbfc .SetColor (_dcdc .parseColorAttr (_efaa ,_dedb ));case "\u0078":_cbfc .SetPos (_dcdc .parseFloatAttr (_efaa ,_dedb ),_cbfc ._bfcd );case "\u0079":_cbfc .SetPos (_cbfc ._gbfc ,_dcdc .parseFloatAttr (_efaa ,_dedb ));
case "\u0061\u006e\u0067l\u0065":_cbfc .SetAngle (_dcdc .parseFloatAttr (_efaa ,_dedb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gbab :=_dcdc .parseMarginAttr (_efaa ,_dedb );_cbfc .SetMargins (_gbab .Left ,_gbab .Right ,_gbab .Top ,_gbab .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_cbfc .SetMaxLines (int (_dcdc .parseInt64Attr (_efaa ,_dedb )));default:_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_efaa );
};};return _cbfc ,nil ;};

// SetNumber sets the number of the invoice.
func (_bcdbf *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_bcdbf ._agebg [1].Value =number ;return _bcdbf ._agebg [0],_bcdbf ._agebg [1];};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bfddf *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bfddf ._aedg =address };

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_adece *shading ;_ecbd *_fee .PdfRectangle ;_fcfba float64 ;};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_afcg *Division )SetMargins (left ,right ,top ,bottom float64 ){_afcg ._ceeba .Left =left ;_afcg ._ceeba .Right =right ;_afcg ._ceeba .Top =top ;_afcg ._ceeba .Bottom =bottom ;};

// SetAngle sets the rotation angle of the text.
func (_dgfe *Paragraph )SetAngle (angle float64 ){_dgfe ._abgcb =angle };func (_cafde *listItem )ctxHeight (_adda float64 )float64 {var _feeb float64 ;switch _ebeb :=_cafde ._eaca .(type ){case *Paragraph :if _ebeb ._ccee {_ebeb .SetWidth (_adda -_ebeb ._efbg .Horizontal ());
};_feeb =_ebeb .Height ()+_ebeb ._efbg .Vertical ();_feeb +=0.5*_ebeb ._bgef *_ebeb ._adgg ;case *StyledParagraph :if _ebeb ._egge {_ebeb .SetWidth (_adda -_ebeb ._eebag .Horizontal ());};_feeb =_ebeb .Height ()+_ebeb ._eebag .Vertical ();_feeb +=0.5*_ebeb .getTextHeight ();
case *List :_ddce :=_adda -_cafde ._aeaf .Width ()-_ebeb ._bffg .Horizontal ()-_ebeb ._cfffc ;_feeb =_ebeb .ctxHeight (_ddce )+_ebeb ._bffg .Vertical ();case *Image :_feeb =_ebeb .Height ()+_ebeb ._dgb .Vertical ();case *Division :_gcgcd :=_adda -_cafde ._aeaf .Width ()-_ebeb ._ceeba .Horizontal ();
_feeb =_ebeb .ctxHeight (_gcgcd )+_ebeb ._ceeba .Vertical ();case *Table :_ecdga :=_adda -_cafde ._aeaf .Width ()-_ebeb ._dceg .Horizontal ();_ebeb .updateRowHeights (_ecdga );_feeb =_ebeb .Height ()+_ebeb ._dceg .Vertical ();default:_feeb =_cafde ._eaca .Height ();
};return _feeb ;};

// SkipRows skips over a specified number of rows in the table.
func (_abccg *Table )SkipRows (num int ){_dbaaa :=num *_abccg ._fcfd -1;if _dbaaa < 0{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_abccg ._gacbf +=_dbaaa ;};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_dafd *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _bafd (x ,y ,innerRadius ,outerRadius ,colorPoints );};

// SetBorder sets the cell's border style.
func (_gabgc *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_gabgc ._fgfda =CellBorderStyleSingle ;_gabgc ._bcdfe =width ;_gabgc ._gefeba =CellBorderStyleSingle ;
_gabgc ._fabe =width ;_gabgc ._egea =CellBorderStyleSingle ;_gabgc ._bdga =width ;_gabgc ._acdfc =CellBorderStyleSingle ;_gabgc ._cbcbcg =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_gabgc ._fgfda =CellBorderStyleDouble ;_gabgc ._bcdfe =width ;
_gabgc ._gefeba =CellBorderStyleDouble ;_gabgc ._fabe =width ;_gabgc ._egea =CellBorderStyleDouble ;_gabgc ._bdga =width ;_gabgc ._acdfc =CellBorderStyleDouble ;_gabgc ._cbcbcg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_gabgc ._fgfda =style ;
_gabgc ._bcdfe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_gabgc ._gefeba =style ;_gabgc ._fabe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_gabgc ._egea =style ;
_gabgc ._bdga =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_gabgc ._acdfc =style ;_gabgc ._cbcbcg =width ;};};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_bebe *Creator )MoveDown (dy float64 ){_bebe ._ddd .Y +=dy };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_bcgf float64 ;_fgba float64 ;_ecec float64 ;_daac float64 ;_bec Color ;_gffb _bg .LineStyle ;_dcfe float64 ;_fafa []int64 ;_ccgd int64 ;_bdfc float64 ;_aede Positioning ;_fgcc FitMode ;_cfdcg Margins ;};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_aeebe *Creator )Flip (flipH ,flipV bool )error {_efff :=_aeebe .getActivePage ();if _efff ==nil {return _d .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_gbge ,_dbcc :=_aeebe ._ecbb [_efff ];if !_dbcc {_gbge =&pageTransformations {};
_aeebe ._ecbb [_efff ]=_gbge ;};_gbge ._ceeg =flipH ;_gbge ._agc =flipV ;return nil ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_dede *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_dede ._ecbd =&_fee .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_edada *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_acab ,_bacd :=_edada .Wrap (width );if _bacd !=nil {return nil ,_bacd ;};_bdad :=int (height /_edada .Style .FontSize );if _bdad >=len (_acab ){return nil ,nil ;};_beeda :="\u000a";
_edada .Text =_cf .Replace (_cf .Join (_acab [:_bdad ],"\u0020"),_beeda +"\u0020",_beeda ,-1);_ecfc :=_cf .Replace (_cf .Join (_acab [_bdad :],"\u0020"),_beeda +"\u0020",_beeda ,-1);return NewTextChunk (_ecfc ,_edada .Style ),nil ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_aaee *_bg .CurvePolygon ;_febb float64 ;_efeb float64 ;_agf Color ;};

// BorderWidth returns the border width of the rectangle.
func (_bddf *Rectangle )BorderWidth ()float64 {return _bddf ._egde };

// Write output of creator to io.Writer interface.
func (_cecg *Creator )Write (ws _fg .Writer )error {if _gdgg :=_cecg .Finalize ();_gdgg !=nil {return _gdgg ;};_efcf :=_fee .NewPdfWriter ();_efcf .SetOptimizer (_cecg ._cecf );if _cecg ._ebgd !=nil {_bacc :=_efcf .SetForms (_cecg ._ebgd );if _bacc !=nil {_da .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bacc );
return _bacc ;};};if _cecg ._eaa !=nil {_efcf .AddOutlineTree (_cecg ._eaa );}else if _cecg ._aeff !=nil &&_cecg .AddOutlines {_efcf .AddOutlineTree (&_cecg ._aeff .ToPdfOutline ().PdfOutlineTreeNode );};if _cecg ._dce !=nil {if _addf :=_efcf .SetPageLabels (_cecg ._dce );
_addf !=nil {_da .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_addf );return _addf ;};};if _cecg ._gbc !=nil {for _ ,_gdgb :=range _cecg ._gbc {_cca :=_gdgb .SubsetRegistered ();
if _cca !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_cca );return _cca ;};};};if _cecg ._bcaa !=nil {_afbc :=_cecg ._bcaa (&_efcf );
if _afbc !=nil {_da .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_afbc );return _afbc ;};};for _ ,_fcdf :=range _cecg ._adbg {_bdge :=_efcf .AddPage (_fcdf );if _bdge !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_bdge );
return _bdge ;};};_efb :=_efcf .Write (ws );if _efb !=nil {return _efb ;};return nil ;};type templateNode struct{_bdced interface{};_bdbga _e .StartElement ;_bdgb *templateNode ;};func (_fge *Block )transform (_gbe _bc .Matrix ){_bed :=_ebc .NewContentCreator ().Add_cm (_gbe [0],_gbe [1],_gbe [3],_gbe [4],_gbe [6],_gbe [7]).Operations ();
*_fge ._db =append (*_bed ,*_fge ._db ...);_fge ._db .WrapIfNeeded ();};

// TOC returns the table of contents component of the creator.
func (_ccf *Creator )TOC ()*TOC {return _ccf ._fgde };

// Scale scales Image by a constant factor, both width and height.
func (_ada *Image )Scale (xFactor ,yFactor float64 ){_ada ._edda =xFactor *_ada ._edda ;_ada ._eega =yFactor *_ada ._eega ;};

// Rows returns the total number of rows the table has.
func (_dgeeb *Table )Rows ()int {return _dgeeb ._edde };func (_debaa *templateProcessor )parseTextOverflowAttr (_gfbec ,_cdfec string )TextOverflow {_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_gfbec ,_cdfec );
_bfdfa :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_cdfec ];return _bfdfa ;};

// FillColor returns the fill color of the ellipse.
func (_ddea *Ellipse )FillColor ()Color {return _ddea ._dbeaf };

// SetBorderColor sets border color of the rectangle.
func (_fcca *Rectangle )SetBorderColor (col Color ){_fcca ._eggbc =col };

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_fef *Creator )NewParagraph (text string )*Paragraph {return _beeg (text ,_fef .NewTextStyle ())};

// GetOptimizer returns current PDF optimizer.
func (_abdg *Creator )GetOptimizer ()_fee .Optimizer {return _abdg ._cecf };

// Height returns the current page height.
func (_fbacg *Creator )Height ()float64 {return _fbacg ._cec };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_gcgf *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abge :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bccb ,_ebgg :=_abge .setOpacity (_gcgf ._febb ,_gcgf ._efeb );if _ebgg !=nil {return nil ,ctx ,_ebgg ;};
_caaf :=_gcgf ._aaee ;_caaf .FillEnabled =_caaf .FillColor !=nil ;_caaf .BorderEnabled =_caaf .BorderColor !=nil &&_caaf .BorderWidth > 0;var (_fecd =ctx .PageHeight ;_deba =_caaf .Rings ;_cdcgg =make ([][]_bg .CubicBezierCurve ,0,len (_caaf .Rings ));
);_bbbc :=_fee .PdfRectangle {};if len (_deba )> 0&&len (_deba [0])> 0{_adff :=_deba [0][0];_adff .P0 .Y =_fecd -_adff .P0 .Y ;_adff .P1 .Y =_fecd -_adff .P1 .Y ;_adff .P2 .Y =_fecd -_adff .P2 .Y ;_adff .P3 .Y =_fecd -_adff .P3 .Y ;_bbbc =_adff .GetBounds ();
};for _ ,_cdce :=range _deba {_decb :=make ([]_bg .CubicBezierCurve ,0,len (_cdce ));for _ ,_bbbcf :=range _cdce {_gdfe :=_bbbcf ;_gdfe .P0 .Y =_fecd -_gdfe .P0 .Y ;_gdfe .P1 .Y =_fecd -_gdfe .P1 .Y ;_gdfe .P2 .Y =_fecd -_gdfe .P2 .Y ;_gdfe .P3 .Y =_fecd -_gdfe .P3 .Y ;
_decb =append (_decb ,_gdfe );_ceag :=_gdfe .GetBounds ();_bbbc .Llx =_fa .Min (_bbbc .Llx ,_ceag .Llx );_bbbc .Lly =_fa .Min (_bbbc .Lly ,_ceag .Lly );_bbbc .Urx =_fa .Max (_bbbc .Urx ,_ceag .Urx );_bbbc .Ury =_fa .Max (_bbbc .Ury ,_ceag .Ury );};_cdcgg =append (_cdcgg ,_decb );
};_caaf .Rings =_cdcgg ;defer func (){_caaf .Rings =_deba }();if _caaf .FillEnabled {_fdga :=_aacgba (_abge ,_gcgf ._aaee .FillColor ,_gcgf ._agf ,func ()Rectangle {return Rectangle {_cfbab :_bbbc .Llx ,_cffbf :_bbbc .Lly ,_bfddd :_bbbc .Width (),_abfd :_bbbc .Height ()};
});if _fdga !=nil {return nil ,ctx ,_fdga ;};};_feg ,_ ,_ebgg :=_caaf .Draw (_bccb );if _ebgg !=nil {return nil ,ctx ,_ebgg ;};if _ebgg =_abge .addContentsByString (string (_feg ));_ebgg !=nil {return nil ,ctx ,_ebgg ;};return []*Block {_abge },ctx ,nil ;
};func _bdcgb (_efbfe *templateProcessor ,_bdfa *templateNode )(interface{},error ){return _efbfe .parsePageBreak (_bdfa );};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_cfgc *Creator )NewPage ()*_fee .PdfPage {_bafa :=_cfgc .newPage ();_cfgc ._adbg =append (_cfgc ._adbg ,_bafa );_cfgc ._ddd .Page ++;return _bafa ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_gacde *Invoice )SetColumns (cols []*InvoiceCell ){_gacde ._eaafb =cols };

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_fcegg *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcegg ._cfdcg .Left ,_fcegg ._cfdcg .Right ,_fcegg ._cfdcg .Top ,_fcegg ._cfdcg .Bottom ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_fagf string ;_gbdaa *_fee .PdfFont ;_bgef float64 ;_adgg float64 ;_cfae Color ;_afcfe TextAlignment ;_ccee bool ;_bgdg float64 ;_afaa int ;_ecfa bool ;_abgcb float64 ;_efbg Margins ;_fgecf Positioning ;_gbfc float64 ;_bfcd float64 ;
_fbaa ,_egag float64 ;_fcda []string ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_bcfb *Creator )NewChapter (title string )*Chapter {_bcfb ._afba ++;_bcag :=_bcfb .NewTextStyle ();_bcag .FontSize =16;return _eca (nil ,_bcfb ._fgde ,_bcfb ._aeff ,title ,_bcfb ._afba ,_bcag );};

// SetLineOpacity sets the line opacity.
func (_aacd *Polyline )SetLineOpacity (opacity float64 ){_aacd ._eadf =opacity };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_baa *Creator )MoveRight (dx float64 ){_baa ._ddd .X +=dx };

// SetBorderOpacity sets the border opacity of the rectangle.
func (_fecb *Rectangle )SetBorderOpacity (opacity float64 ){_fecb ._cgbf =opacity };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_dadfd *_bg .Polyline ;_eadf float64 ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_decgb *TOCLine )SetStyle (style TextStyle ){_decgb .Number .Style =style ;_decgb .Title .Style =style ;_decgb .Separator .Style =style ;_decgb .Page .Style =style ;};func _agae (_bfb _ef .ChartRenderable )*Chart {return &Chart {_edbg :_bfb ,_gge :PositionRelative ,_cgc :Margins {Top :10,Bottom :10}};
};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_aegfd *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_aegfd ._egfeb =valign };

// LevelOffset returns the amount of space an indentation level occupies.
func (_geade *TOCLine )LevelOffset ()float64 {return _geade ._eedde };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_dfde *Creator )SetForms (form *_fee .PdfAcroForm )error {_dfde ._ebgd =form ;return nil };

// SetBorderWidth sets the border width of the ellipse.
func (_eccc *Ellipse )SetBorderWidth (bw float64 ){_eccc ._bedef =bw };func (_cgbg *Image )applyFitMode (_afg float64 ){_afg -=_cgbg ._dgb .Left +_cgbg ._dgb .Right ;switch _cgbg ._eged {case FitModeFillWidth :_cgbg .ScaleToWidth (_afg );};};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_gafg *Table )SetMargins (left ,right ,top ,bottom float64 ){_gafg ._dceg .Left =left ;_gafg ._dceg .Right =right ;_gafg ._dceg .Top =top ;_gafg ._dceg .Bottom =bottom ;};func _gffde (_faaaa *templateProcessor ,_badgb *templateNode )(interface{},error ){return _faaaa .parseTable (_badgb );
};

// SetSideBorderStyle sets the cell's side border style.
func (_eccba *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_eccba ._acdfc =style ;_eccba ._gefeba =style ;_eccba ._fgfda =style ;_eccba ._egea =style ;case CellBorderSideTop :_eccba ._acdfc =style ;
case CellBorderSideBottom :_eccba ._gefeba =style ;case CellBorderSideLeft :_eccba ._fgfda =style ;case CellBorderSideRight :_eccba ._egea =style ;};};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_dfe *Creator )NewImageFromGoImage (goimg _a .Image )(*Image ,error ){return _afbgg (goimg )};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetBorderOpacity sets the border opacity.
func (_cddf *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_cddf ._ebef =opacity };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_dfea *Line )Width ()float64 {return _fa .Abs (_dfea ._ecec -_dfea ._bcgf )};func _fgee ()*Division {return &Division {_fgg :true }};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_ddfce []_bg .CubicBezierCurve ;FillEnabled bool ;_efgf Color ;BorderEnabled bool ;BorderWidth float64 ;_afdae Color ;};type templateProcessor struct{creator *Creator ;_ffcd []byte ;_deag *TemplateOptions ;_cgcaa componentRenderer ;
};func (_bggdf cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_afc :=_bggdf ._dgdaf ;return 1-(_bggdf ._bcc *(1-_afc )+_afc ),1-(_bggdf ._gdg *(1-_afc )+_afc ),1-(_bggdf ._fbba *(1-_afc )+_afc );};

// NewTOCLine creates a new table of contents line with the default style.
func (_cggb *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _eddac (number ,title ,page ,level ,_cggb .NewTextStyle ());};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_daee *Image )SetEncoder (encoder _dd .StreamEncoder ){_daee ._fcgd =encoder };

// SetBorderWidth sets the border width.
func (_dcfcg *Polygon )SetBorderWidth (borderWidth float64 ){_dcfcg ._ebdcd .BorderWidth =borderWidth };

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_cfbad *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_beeb :=NewTextChunk (text ,_cfbad ._fecf );_beeb ._beebgd =_gfgag (url );return _cfbad .appendChunk (_beeb );};func (_cdeagd *TextStyle )horizontalScale ()float64 {return _cdeagd .HorizontalScaling /100};


// SetFillOpacity sets the fill opacity.
func (_cecgf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_cecgf ._aabg =opacity };

// FitMode returns the fit mode of the ellipse.
func (_ebdc *Ellipse )FitMode ()FitMode {return _ebdc ._ffgf };func _eddac (_befg ,_bbeea ,_becfg string ,_cccf uint ,_ecafa TextStyle )*TOCLine {return _bege (TextChunk {Text :_befg ,Style :_ecafa },TextChunk {Text :_bbeea ,Style :_ecafa },TextChunk {Text :_becfg ,Style :_ecafa },_cccf ,_ecafa );
};func (_bcfbg *List )split (_aafb DrawContext )(_fdgg ,_fede *List ){var (_feggg float64 ;_afcb ,_gdeba []*listItem ;);_bdebc :=_aafb .Width -_bcfbg ._bffg .Horizontal ()-_bcfbg ._cfffc -_bcfbg .markerWidth ();_fbdc :=_bcfbg .markerWidth ();for _cbbe ,_fgcb :=range _bcfbg ._fegg {_cgcd :=_fgcb .ctxHeight (_bdebc );
_feggg +=_cgcd ;if _feggg <=_aafb .Height {_afcb =append (_afcb ,_fgcb );}else {switch _fcaag :=_fgcb ._eaca .(type ){case *List :_facd :=_aafb ;_facd .Height =_fa .Floor (_cgcd -(_feggg -_aafb .Height ));_baab ,_bcgd :=_fcaag .split (_facd );if _baab !=nil {_fefg :=_fagg ();
_fefg ._aeaf =_fgcb ._aeaf ;_fefg ._eaca =_baab ;_afcb =append (_afcb ,_fefg );};if _bcgd !=nil {_dffa :=_fcaag ._dabcb .Style .FontSize ;_abcad ,_fdcaf :=_fcaag ._dabcb .Style .Font .GetRuneMetrics (' ');if _fdcaf {_dffa =_fcaag ._dabcb .Style .FontSize *_abcad .Wx *_fcaag ._dabcb .Style .horizontalScale ()/1000.0;
};_deecf :=_cf .Repeat ("\u0020",int (_fbdc /_dffa ));_cgag :=_fagg ();_cgag ._aeaf =*NewTextChunk (_deecf ,_fcaag ._dabcb .Style );_cgag ._eaca =_bcgd ;_gdeba =append (_gdeba ,_cgag );_gdeba =append (_gdeba ,_bcfbg ._fegg [_cbbe +1:]...);};default:_gdeba =_bcfbg ._fegg [_cbbe :];
};if len (_gdeba )> 0{break ;};};};if len (_afcb )> 0{_fdgg =_egcf (_bcfbg ._bdbe );*_fdgg =*_bcfbg ;_fdgg ._fegg =_afcb ;};if len (_gdeba )> 0{_fede =_egcf (_bcfbg ._bdbe );*_fede =*_bcfbg ;_fede ._fegg =_gdeba ;};return _fdgg ,_fede ;};

// SetColorRight sets border color for right.
func (_dba *border )SetColorRight (col Color ){_dba ._ecba =col };

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_egad *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bcce []*Block ;_daefg bool ;_fegc error ;_fgab =_egad ._dgcag .IsRelative ();_fffa =_egad ._ceeba .Top ;);if _fgab &&!_egad ._fgg &&!_egad ._agag {_gfdg :=_egad .ctxHeight (ctx .Width );
if _gfdg > ctx .Height -_egad ._ceeba .Top &&_gfdg <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _bcce ,ctx ,_fegc =_gaffdg ().GeneratePageBlocks (ctx );_fegc !=nil {return nil ,ctx ,_fegc ;};_daefg =true ;_fffa =0;};};_dcca :=ctx ;_egdd :=ctx ;
if _fgab {ctx .X +=_egad ._ceeba .Left ;ctx .Y +=_fffa ;ctx .Width -=_egad ._ceeba .Left +_egad ._ceeba .Right ;ctx .Height -=_fffa ;_egdd =ctx ;ctx .X +=_egad ._deca .Left ;ctx .Y +=_egad ._deca .Top ;ctx .Width -=_egad ._deca .Left +_egad ._deca .Right ;
ctx .Height -=_egad ._deca .Top ;ctx .Margins .Top +=_egad ._deca .Top ;ctx .Margins .Bottom +=_egad ._deca .Bottom ;ctx .Margins .Left +=_egad ._ceeba .Left +_egad ._deca .Left ;ctx .Margins .Right +=_egad ._ceeba .Right +_egad ._deca .Right ;};ctx .Inline =_egad ._agag ;
_deeb :=ctx ;_badcb :=ctx ;var _gabgf float64 ;for _ ,_cegcb :=range _egad ._aegg {if ctx .Inline {if (ctx .X -_deeb .X )+_cegcb .Width ()<=ctx .Width {ctx .Y =_badcb .Y ;ctx .Height =_badcb .Height ;}else {ctx .X =_deeb .X ;ctx .Width =_deeb .Width ;_badcb .Y +=_gabgf ;
_badcb .Height -=_gabgf ;_gabgf =0;};};_dcg ,_cegef ,_fceag :=_cegcb .GeneratePageBlocks (ctx );if _fceag !=nil {_da .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_fceag );
return nil ,ctx ,_fceag ;};if len (_dcg )< 1{continue ;};if len (_bcce )> 0{_bcce [len (_bcce )-1].mergeBlocks (_dcg [0]);_bcce =append (_bcce ,_dcg [1:]...);}else {if _fbgabf :=_dcg [0]._db ;_fbgabf ==nil ||len (*_fbgabf )==0{_daefg =true ;};_bcce =append (_bcce ,_dcg [0:]...);
};if ctx .Inline {if ctx .Page !=_cegef .Page {_deeb .Y =ctx .Margins .Top ;_deeb .Height =ctx .PageHeight -ctx .Margins .Top ;_badcb .Y =_deeb .Y ;_badcb .Height =_deeb .Height ;_gabgf =_cegef .Height -_deeb .Height ;}else {if _efbb :=ctx .Height -_cegef .Height ;
_efbb > _gabgf {_gabgf =_efbb ;};};}else {_cegef .X =ctx .X ;};ctx =_cegef ;};ctx .Inline =_dcca .Inline ;ctx .Margins =_dcca .Margins ;if _fgab {ctx .X =_dcca .X ;ctx .Width =_dcca .Width ;ctx .Y +=_egad ._deca .Bottom ;ctx .Height -=_egad ._deca .Bottom ;
};if _egad ._dgce !=nil {_bcce ,_fegc =_egad .drawBackground (_bcce ,_egdd ,ctx ,_daefg );if _fegc !=nil {return nil ,ctx ,_fegc ;};};if _egad ._dgcag .IsAbsolute (){return _bcce ,_dcca ,nil ;};ctx .Y +=_egad ._ceeba .Bottom ;ctx .Height -=_egad ._ceeba .Bottom ;
return _bcce ,ctx ,nil ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _fafb (color ,point )};

// SetBorderWidth sets the border width.
func (_cbfb *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_cbfb ._cceb .BorderWidth =borderWidth ;};func _gabgca (_gbcf int64 ,_dbdbd ,_baggd ,_aaad float64 )*_fee .PdfAnnotation {_adfae :=_fee .NewPdfAnnotationLink ();_ccdd :=_fee .NewBorderStyle ();
_ccdd .SetBorderWidth (0);_adfae .BS =_ccdd .ToPdfObject ();if _gbcf < 0{_gbcf =0;};_adfae .Dest =_dd .MakeArray (_dd .MakeInteger (_gbcf ),_dd .MakeName ("\u0058\u0059\u005a"),_dd .MakeFloat (_dbdbd ),_dd .MakeFloat (_baggd ),_dd .MakeFloat (_aaad ));
return _adfae .PdfAnnotation ;};type cmykColor struct{_bcc ,_gdg ,_fbba ,_dgdaf float64 };

// BorderColor returns the border color of the ellipse.
func (_fbce *Ellipse )BorderColor ()Color {return _fbce ._fdfd };

// SetLevel sets the indentation level of the TOC line.
func (_degcg *TOCLine )SetLevel (level uint ){_degcg ._bbec =level ;_degcg ._dabee ._eebag .Left =_degcg ._gfgb +float64 (_degcg ._bbec -1)*_degcg ._eedde ;};

// SetFillColor sets the fill color of the ellipse.
func (_bdb *Ellipse )SetFillColor (col Color ){_bdb ._dbeaf =col };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func _acac (_eaea ,_ebf ,_fabc ,_ebeg ,_ddcf ,_cgec float64 )*Curve {_cdcb :=&Curve {};_cdcb ._dggg =_eaea ;_cdcb ._cea =_ebf ;_cdcb ._beg =_fabc ;_cdcb ._febag =_ebeg ;_cdcb ._bda =_ddcf ;_cdcb ._ccbc =_cgec ;_cdcb ._gabg =ColorBlack ;
_cdcb ._cgfc =1.0;return _cdcb ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_eace *List )Marker ()*TextChunk {return &_eace ._dabcb };

// MoveX moves the drawing context to absolute position x.
func (_caca *Creator )MoveX (x float64 ){_caca ._ddd .X =x };func (_dfdf *TextChunk )clone ()*TextChunk {_ggggf :=*_dfdf ;_ggggf ._beebgd =_gfbde (_dfdf ._beebgd );return &_ggggf ;};

// SetFont sets the Paragraph's font.
func (_bdebg *Paragraph )SetFont (font *_fee .PdfFont ){_bdebg ._gbdaa =font };func _eeea (_ddef *templateProcessor ,_efgd *templateNode )(interface{},error ){return _ddef .parseLine (_efgd );};

// SetWidthLeft sets border width for left.
func (_ceef *border )SetWidthLeft (bw float64 ){_ceef ._bbd =bw };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_bedg *Invoice )TotalLines ()[][2]*InvoiceCell {_cabc :=[][2]*InvoiceCell {_bedg ._decgf };_cabc =append (_cabc ,_bedg ._gcffc ...);return append (_cabc ,_bedg ._abb );};

// Width returns the current page width.
func (_ccce *Creator )Width ()float64 {return _ccce ._aef };func _gcg (_gd *_ebc .ContentStreamOperations ,_dde *_fee .PdfPageResources ,_abf *_ebc .ContentStreamOperations ,_ddec *_fee .PdfPageResources )error {_edb :=map[_dd .PdfObjectName ]_dd .PdfObjectName {};
_cbb :=map[_dd .PdfObjectName ]_dd .PdfObjectName {};_abg :=map[_dd .PdfObjectName ]_dd .PdfObjectName {};_efef :=map[_dd .PdfObjectName ]_dd .PdfObjectName {};_dgg :=map[_dd .PdfObjectName ]_dd .PdfObjectName {};_add :=map[_dd .PdfObjectName ]_dd .PdfObjectName {};
for _ ,_cc :=range *_abf {switch _cc .Operand {case "\u0044\u006f":if len (_cc .Params )==1{if _gdf ,_bbc :=_cc .Params [0].(*_dd .PdfObjectName );_bbc {if _ ,_fde :=_edb [*_gdf ];!_fde {var _dgd _dd .PdfObjectName ;_ce ,_ :=_ddec .GetXObjectByName (*_gdf );
if _ce !=nil {_dgd =*_gdf ;for {_fdeg ,_ :=_dde .GetXObjectByName (_dgd );if _fdeg ==nil ||_fdeg ==_ce {break ;};_dgd =*_dd .MakeName (_ggb (_dgd .String ()));};};_dde .SetXObjectByName (_dgd ,_ce );_edb [*_gdf ]=_dgd ;};_ggg :=_edb [*_gdf ];_cc .Params [0]=&_ggg ;
};};case "\u0054\u0066":if len (_cc .Params )==2{if _gda ,_ecb :=_cc .Params [0].(*_dd .PdfObjectName );_ecb {if _ ,_gfcc :=_cbb [*_gda ];!_gfcc {_adf ,_fbc :=_ddec .GetFontByName (*_gda );_adb :=*_gda ;if _fbc &&_adf !=nil {_adb =_eeg (_gda .String (),_adf ,_dde );
};_dde .SetFontByName (_adb ,_adf );_cbb [*_gda ]=_adb ;};_fda :=_cbb [*_gda ];_cc .Params [0]=&_fda ;};};case "\u0043\u0053","\u0063\u0073":if len (_cc .Params )==1{if _age ,_egc :=_cc .Params [0].(*_dd .PdfObjectName );_egc {if _ ,_eagb :=_abg [*_age ];
!_eagb {var _efa _dd .PdfObjectName ;_dabd ,_acb :=_ddec .GetColorspaceByName (*_age );if _acb {_efa =*_age ;for {_fca ,_cgd :=_dde .GetColorspaceByName (_efa );if !_cgd ||_dabd ==_fca {break ;};_efa =*_dd .MakeName (_ggb (_efa .String ()));};_dde .SetColorspaceByName (_efa ,_dabd );
_abg [*_age ]=_efa ;}else {_da .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _eda ,_abfb :=_abg [*_age ];_abfb {_cc .Params [0]=&_eda ;}else {_da .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_age );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_cc .Params )==1{if _abd ,_ffg :=_cc .Params [0].(*_dd .PdfObjectName );_ffg {if _ ,_fga :=_efef [*_abd ];!_fga {var _fcg _dd .PdfObjectName ;_ecbg ,_cda :=_ddec .GetPatternByName (*_abd );if _cda {_fcg =*_abd ;
for {_aga ,_bbcd :=_dde .GetPatternByName (_fcg );if !_bbcd ||_aga ==_ecbg {break ;};_fcg =*_dd .MakeName (_ggb (_fcg .String ()));};_fag :=_dde .SetPatternByName (_fcg ,_ecbg .ToPdfObject ());if _fag !=nil {return _fag ;};_efef [*_abd ]=_fcg ;};};if _cab ,_ccc :=_efef [*_abd ];
_ccc {_cc .Params [0]=&_cab ;};};};case "\u0073\u0068":if len (_cc .Params )==1{if _gea ,_gaa :=_cc .Params [0].(*_dd .PdfObjectName );_gaa {if _ ,_gfe :=_dgg [*_gea ];!_gfe {var _adg _dd .PdfObjectName ;_dfg ,_gce :=_ddec .GetShadingByName (*_gea );if _gce {_adg =*_gea ;
for {_deg ,_faf :=_dde .GetShadingByName (_adg );if !_faf ||_dfg ==_deg {break ;};_adg =*_dd .MakeName (_ggb (_adg .String ()));};_dcb :=_dde .SetShadingByName (_adg ,_dfg .ToPdfObject ());if _dcb !=nil {_da .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_dcb );
return _dcb ;};_dgg [*_gea ]=_adg ;}else {_da .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cdfc ,_bcd :=_dgg [*_gea ];_bcd {_cc .Params [0]=&_cdfc ;}else {_da .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_gea );
};};};case "\u0067\u0073":if len (_cc .Params )==1{if _dgeg ,_cdc :=_cc .Params [0].(*_dd .PdfObjectName );_cdc {if _ ,_ggf :=_add [*_dgeg ];!_ggf {var _ebcc _dd .PdfObjectName ;_gcce ,_bcfc :=_ddec .GetExtGState (*_dgeg );if _bcfc {_ebcc =*_dgeg ;for {_edab ,_acc :=_dde .GetExtGState (_ebcc );
if !_acc ||_gcce ==_edab {break ;};_ebcc =*_dd .MakeName (_ggb (_ebcc .String ()));};};_dde .AddExtGState (_ebcc ,_gcce );_add [*_dgeg ]=_ebcc ;};_fdad :=_add [*_dgeg ];_cc .Params [0]=&_fdad ;};};};*_gd =append (*_gd ,_cc );};return nil ;};

// SetFillColor sets background color for border.
func (_ebb *border )SetFillColor (col Color ){_ebb ._aeea =col };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_ggd *Creator )NewPolyBezierCurve (curves []_bg .CubicBezierCurve )*PolyBezierCurve {return _fabcd (curves );};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;
AnchorBottom ;);const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func _bgfac (_eccbb ...interface{})(map[string ]interface{},error ){_dbbgg :=len (_eccbb );if _dbbgg %2!=0{_da .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_dbbgg );
return nil ,_dd .ErrRangeError ;};_dadfa :=map[string ]interface{}{};for _efgb :=0;_efgb < _dbbgg ;_efgb +=2{_fdaa ,_fbeg :=_eccbb [_efgb ].(string );if !_fbeg {_da .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_eccbb [_efgb ]);
return nil ,_dd .ErrTypeError ;};_dadfa [_fdaa ]=_eccbb [_efgb +1];};return _dadfa ,nil ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_bde *Chapter )SetShowNumbering (show bool ){_bde ._dadd =show ;_bde ._ddc .SetText (_bde .headingText ());};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_ffa *Image )GetHorizontalAlignment ()HorizontalAlignment {return _ffa ._eeef };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_bcabb *Paragraph )SetMaxLines (maxLines int ){_bcabb ._afaa =maxLines ;_bcabb .wrapText ()};func (_bdcb *Invoice )drawSection (_eegd ,_gbgb string )[]*StyledParagraph {var _adba []*StyledParagraph ;if _eegd !=""{_gacb :=_dccc (_bdcb ._fadg );_gacb .SetMargins (0,0,0,5);
_gacb .Append (_eegd );_adba =append (_adba ,_gacb );};if _gbgb !=""{_ffeg :=_dccc (_bdcb ._dabeb );_ffeg .Append (_gbgb );_adba =append (_adba ,_ffeg );};return _adba ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_adea *Invoice )InfoLines ()[][2]*InvoiceCell {_afca :=[][2]*InvoiceCell {_adea ._agebg ,_adea ._gfbd ,_adea ._edgf };return append (_afca ,_adea ._dbbdg ...);};func (_egcc *templateProcessor )parseRadialGradientAttr (creator *Creator ,_gagdc string )Color {_ceeed :=ColorBlack ;
if _gagdc ==""{return _ceeed ;};var (_ebegc error ;_ceffg =0.0;_bcgfa =0.0;_acfa =-1.0;_edeg =_cf .Split (_gagdc [16:len (_gagdc )-1],"\u002c"););_gfgge :=_cf .Fields (_edeg [0]);if len (_gfgge )==2&&_cf .TrimSpace (_gfgge [0])[0]!='#'{_ceffg ,_ebegc =_fe .ParseFloat (_gfgge [0],64);
if _ebegc !=nil {_da .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_ebegc );
};_bcgfa ,_ebegc =_fe .ParseFloat (_gfgge [1],64);if _ebegc !=nil {_da .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_ebegc );
};_edeg =_edeg [1:];};_afcfd :=_cf .TrimSpace (_edeg [0]);if _afcfd [0]!='#'{_acfa ,_ebegc =_fe .ParseFloat (_afcfd ,64);if _ebegc !=nil {_da .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_ebegc );
};_edeg =_edeg [1:];};_aeebd ,_beafc :=_egcc .processGradientColorPair (_edeg );if _aeebd ==nil ||_beafc ==nil {return _ceeed ;};_fccae :=creator .NewRadialGradientColor (_ceffg ,_bcgfa ,0,_acfa ,[]*ColorPoint {});for _bdfgc :=0;_bdfgc < len (_aeebd );
_bdfgc ++{_fccae .AddColorStop (_aeebd [_bdfgc ],_beafc [_bdfgc ]);};return _fccae ;};func _cfcbf (_abdaf string )bool {_bdbgca :=func (_ddde rune )bool {return _ddde =='\u000A'};_baecg :=_cf .TrimFunc (_abdaf ,_bdbgca );_dafbbd :=_aa .Paragraph {};_ ,_fgbba :=_dafbbd .SetString (_baecg );
if _fgbba !=nil {return true ;};_bcecd ,_fgbba :=_dafbbd .Order ();if _fgbba !=nil {return true ;};if _bcecd .NumRuns ()< 1{return true ;};return _dafbbd .IsLeftToRight ();};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_bfba *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _gddgf (colorPoints );};type fontMetrics struct{_fdae float64 ;_ffedb float64 ;_aaefg float64 ;_ebggb float64 ;};

// SetLineWidth sets the line width.
func (_aedga *Line )SetLineWidth (width float64 ){_aedga ._bdfc =width };

// SetColorTop sets border color for top.
func (_caag *border )SetColorTop (col Color ){_caag ._bfgc =col };func (_ddgdf *TableCell )cloneProps (_bdgdae VectorDrawable )*TableCell {_afgd :=*_ddgdf ;_afgd ._cfdd =_bdgdae ;return &_afgd ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_bcc :_fa .Max (_fa .Min (c ,1.0),0.0),_gdg :_fa .Max (_fa .Min (m ,1.0),0.0),_fbba :_fa .Max (_fa .Min (y ,1.0),0.0),_dgdaf :_fa .Max (_fa .Min (k ,1.0),0.0)};};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_db *_ebc .ContentStreamOperations ;_gf *_fee .PdfPageResources ;_eg Positioning ;_ba ,_cd float64 ;_bab float64 ;_egb float64 ;_gc float64 ;_gb Margins ;_aee []*_fee .PdfAnnotation ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_gbee *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gbee ._cgc .Left ,_gbee ._cgc .Right ,_gbee ._cgc .Top ,_gbee ._cgc .Bottom ;};

// CreateFrontPage sets a function to generate a front Page.
func (_gfgg *Creator )CreateFrontPage (genFrontPageFunc func (_dddd FrontpageFunctionArgs )){_gfgg ._badc =genFrontPageFunc ;};func _caac (_gaab *_aeb .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_cfff :_gaab ,_ebgcc :PositionRelative ,_dadde :Margins {Top :10,Bottom :10}},nil ;
};