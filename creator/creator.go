//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_c "bytes";_ec "encoding/xml";_g "errors";_e "fmt";_a "github.com/gorilla/i18n/linebreak";_dfd "github.com/unidoc/typesetting/shaping";_ce "github.com/unidoc/unichart/render";_ef "github.com/unidoc/unipdf/v4/common";_ebf "github.com/unidoc/unipdf/v4/contentstream";
_dd "github.com/unidoc/unipdf/v4/contentstream/draw";_cd "github.com/unidoc/unipdf/v4/core";_ba "github.com/unidoc/unipdf/v4/internal/graphic2d";_ae "github.com/unidoc/unipdf/v4/internal/integrations/unichart";_ab "github.com/unidoc/unipdf/v4/internal/license";
_eca "github.com/unidoc/unipdf/v4/internal/precision";_ee "github.com/unidoc/unipdf/v4/internal/transform";_gf "github.com/unidoc/unipdf/v4/model";_edc "golang.org/x/net/html/charset";_da "image";_fd "io";_df "log";_fb "math";_f "os";_eb "path/filepath";
_gg "regexp";_ebc "sort";_ca "strconv";_b "strings";_dg "text/template";_ge "unicode";_ed "unicode/utf8";);

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_cdee *Division )SetMargins (left ,right ,top ,bottom float64 ){_cdee ._ffd .Left =left ;_cdee ._ffd .Right =right ;_cdee ._ffd .Top =top ;_cdee ._ffd .Bottom =bottom ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_facge *Creator )Finalize ()error {if _facge ._ffbe {return nil ;};_cafc :=len (_facge ._cbf );_cebd :=0;if _facge ._agdb !=nil {_bfa :=*_facge ;_facge ._cbf =nil ;_facge ._ddbg =nil ;_facge .initContext ();_defg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cafc };
_facge ._agdb (_defg );_cebd +=len (_facge ._cbf );_facge ._cbf =_bfa ._cbf ;_facge ._ddbg =_bfa ._ddbg ;};if _facge .AddTOC {_facge .initContext ();_facge ._fcba .Page =_cebd +1;if _facge .CustomTOC &&_facge ._eaeb !=nil {_bfde :=*_facge ;_facge ._cbf =nil ;
_facge ._ddbg =nil ;if _bbfb :=_facge ._eaeb (_facge ._fagf );_bbfb !=nil {return _bbfb ;};_cebd +=len (_facge ._cbf );_facge ._cbf =_bfde ._cbf ;_facge ._ddbg =_bfde ._ddbg ;}else {if _facge ._eaeb !=nil {if _bgfb :=_facge ._eaeb (_facge ._fagf );_bgfb !=nil {return _bgfb ;
};};_afd ,_ ,_gagc :=_facge ._fagf .GeneratePageBlocks (_facge ._fcba );if _gagc !=nil {_ef .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_gagc );
return _gagc ;};_cebd +=len (_afd );};_bcdc :=_facge ._fagf .Lines ();for _ ,_aada :=range _bcdc {_fbga ,_egf :=_ca .Atoi (_aada .Page .Text );if _egf !=nil {continue ;};_aada .Page .Text =_ca .Itoa (_fbga +_cebd );_aada ._fgeee +=int64 (_cebd );};};_ddggd :=false ;
var _geaf []*_gf .PdfPage ;if _facge ._agdb !=nil {_bbc :=*_facge ;_facge ._cbf =nil ;_facge ._ddbg =nil ;_bebe :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cafc };_facge ._agdb (_bebe );_cafc +=len (_facge ._cbf );_geaf =_facge ._cbf ;_facge ._cbf =append (_facge ._cbf ,_bbc ._cbf ...);
_facge ._ddbg =_bbc ._ddbg ;_ddggd =true ;};var _fda []*_gf .PdfPage ;if _facge .AddTOC {_facge .initContext ();if _facge .CustomTOC &&_facge ._eaeb !=nil {_bgg :=*_facge ;_facge ._cbf =nil ;_facge ._ddbg =nil ;if _eagd :=_facge ._eaeb (_facge ._fagf );
_eagd !=nil {_ef .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_eagd );return _eagd ;};_fda =_facge ._cbf ;_cafc +=len (_fda );_facge ._cbf =_bgg ._cbf ;
_facge ._ddbg =_bgg ._ddbg ;}else {if _facge ._eaeb !=nil {if _abcb :=_facge ._eaeb (_facge ._fagf );_abcb !=nil {_ef .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_abcb );
return _abcb ;};};_aga ,_ ,_ :=_facge ._fagf .GeneratePageBlocks (_facge ._fcba );for _ ,_egbf :=range _aga {_egbf .SetPos (0,0);_cafc ++;_facga :=_facge .newPage ();_fda =append (_fda ,_facga );_facge .setActivePage (_facga );_facge .Draw (_egbf );};};
if _ddggd {_acec :=_geaf ;_dgcb :=_facge ._cbf [len (_geaf ):];_facge ._cbf =append ([]*_gf .PdfPage {},_acec ...);_facge ._cbf =append (_facge ._cbf ,_fda ...);_facge ._cbf =append (_facge ._cbf ,_dgcb ...);}else {_facge ._cbf =append (_fda ,_facge ._cbf ...);
};};if _facge ._cced !=nil &&_facge .AddOutlines {var _abgfg func (_gfag *_gf .OutlineItem );_abgfg =func (_efce *_gf .OutlineItem ){_efce .Dest .Page +=int64 (_cebd );if _ddcf :=int (_efce .Dest .Page );_ddcf >=0&&_ddcf < len (_facge ._cbf ){_efce .Dest .PageObj =_facge ._cbf [_ddcf ].GetPageAsIndirectObject ();
}else {_ef .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ddcf );
};_efce .Dest .Y =_eca .RoundDefault (_facge ._dag -_efce .Dest .Y );_ddd :=_efce .Items ();for _ ,_gcaca :=range _ddd {_abgfg (_gcaca );};};_gafd :=_facge ._cced .Items ();for _ ,_aaeaf :=range _gafd {_abgfg (_aaeaf );};if _facge .AddTOC {var _gcfe int ;
if _ddggd {_gcfe =len (_geaf );};_edfa :=_gf .NewOutlineDest (int64 (_gcfe ),0,_facge ._dag );if _gcfe >=0&&_gcfe < len (_facge ._cbf ){_edfa .PageObj =_facge ._cbf [_gcfe ].GetPageAsIndirectObject ();}else {_ef .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gcfe );
};_facge ._cced .Insert (0,_gf .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_edfa ));};};for _aeef ,_eebe :=range _facge ._cbf {_facge .setActivePage (_eebe );if _facge ._acbf !=nil {_ead ,_faed ,_ffgff :=_eebe .Size ();
if _ffgff !=nil {return _ffgff ;};_dfae :=PageFinalizeFunctionArgs {PageNum :_aeef +1,PageWidth :_ead ,PageHeight :_faed ,TOCPages :len (_fda ),TotalPages :_cafc };if _efa :=_facge ._acbf (_dfae );_efa !=nil {_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_efa );
return _efa ;};};if _facge ._ceed !=nil {_geeg :=NewBlock (_facge ._gaa ,_facge ._feeg .Top );_baee :=HeaderFunctionArgs {PageNum :_aeef +1,TotalPages :_cafc };_facge ._ceed (_geeg ,_baee );_geeg .SetPos (0,0);if _badd :=_facge .Draw (_geeg );_badd !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_badd );
return _badd ;};};if _facge ._deaa !=nil {_gaaf :=NewBlock (_facge ._gaa ,_facge ._feeg .Bottom );_effba :=FooterFunctionArgs {PageNum :_aeef +1,TotalPages :_cafc };_facge ._deaa (_gaaf ,_effba );_gaaf .SetPos (0,_facge ._dag -_gaaf ._geb );if _eeed :=_facge .Draw (_gaaf );
_eeed !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_eeed );return _eeed ;};};_cfge ,_gdbg :=_facge ._abge [_eebe ];if _ece ,_bgee :=_facge ._aea [_eebe ];
_bgee {if _gdbg {_cfge .transformBlock (_ece );};if _fbfd :=_ece .drawToPage (_eebe );_fbfd !=nil {_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_aeef +1,_fbfd );
return _fbfd ;};};if _gdbg {if _gdbgc :=_cfge .transformPage (_eebe );_gdbgc !=nil {_ef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_gdbgc );
return _gdbgc ;};};};_facge ._ffbe =true ;return nil ;};func (_ddgg *Block )transform (_cdc _ee .Matrix ){_cagc :=_ebf .NewContentCreator ().Add_cm (_cdc [0],_cdc [1],_cdc [3],_cdc [4],_cdc [6],_cdc [7]).Operations ();*_ddgg ._bac =append (*_cagc ,*_ddgg ._bac ...);
_ddgg ._bac .WrapIfNeeded ();};

// GetArtifact returns the artifact associated with the image, if any.
func (_cddf *Image )GetArtifact ()*_gf .Artifact {return _cddf ._febda };

// Scale scales the ellipse dimensions by the specified factors.
func (_fdad *Ellipse )Scale (xFactor ,yFactor float64 ){_fdad ._feeac =xFactor *_fdad ._feeac ;_fdad ._feegb =yFactor *_fdad ._feegb ;};func (_gbbd *Invoice )generateNoteBlocks (_afecc DrawContext )([]*Block ,DrawContext ,error ){_dbgd :=_ffbf ();_bgadf :=append ([][2]string {_gbbd ._gebe ,_gbbd ._cbcac },_gbbd ._ffbag ...);
for _ ,_gddc :=range _bgadf {if _gddc [1]!=""{_bggcb :=_gbbd .drawSection (_gddc [0],_gddc [1]);for _ ,_befg :=range _bggcb {_dbgd .Add (_befg );};_gfega :=_bgdc (_gbbd ._agdg );_gfega .SetMargins (0,0,10,0);_dbgd .Add (_gfega );};};return _dbgd .GeneratePageBlocks (_afecc );
};

// SetAnnotation sets an annotation on a TextChunk,
// this will replace any existing annotation that has been set.
// Supplying a nil value as parameter would clear all the annotations.
func (_fcgfg *TextChunk )SetAnnotation (annotation *_gf .PdfAnnotation ){if annotation ==nil {_fcgfg .ClearAnnotations ();}else {_fcgfg ._cgbff =[]*_gf .PdfAnnotation {annotation };};};

// RemoveArtifact removes the artifact associated with the image, if any.
func (_facfc *Image )RemoveArtifact (){_facfc ._febda =nil };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// NewImageFromData creates an Image from image data.
func (_efef *Creator )NewImageFromData (data []byte )(*Image ,error ){return _dgge (data )};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func (_effea *Line )computeCoords (_cacc DrawContext )(_bbafa ,_cecc ,_fgfa ,_dead float64 ){_bbafa =_cacc .X ;_fgfa =_bbafa +_effea ._bada -_effea ._gbba ;_becg :=_effea ._gfbf ;if _effea ._gbba ==_effea ._bada {_becg /=2;
};if _effea ._dfag < _effea ._bbacd {_cecc =_cacc .PageHeight -_cacc .Y -_becg ;_dead =_cecc -_effea ._bbacd +_effea ._dfag ;}else {_dead =_cacc .PageHeight -_cacc .Y -_becg ;_cecc =_dead -_effea ._dfag +_effea ._bbacd ;};switch _effea ._gcfg {case FitModeFillWidth :_fgfa =_bbafa +_cacc .Width ;
};return _bbafa ,_cecc ,_fgfa ,_dead ;};

// SetSideBorderWidth sets the cell's side border width.
func (_faaf *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_faaf ._ecee =width ;_faaf ._gafaf =width ;_faaf ._bgeeg =width ;_faaf ._cdeb =width ;case CellBorderSideTop :_faaf ._ecee =width ;case CellBorderSideBottom :_faaf ._gafaf =width ;
case CellBorderSideLeft :_faaf ._bgeeg =width ;case CellBorderSideRight :_faaf ._cdeb =width ;};};func (_efcc *templateProcessor )parseImage (_bgfba *templateNode )(interface{},error ){var _ecaec string ;for _ ,_eaaf :=range _bgfba ._fdbe .Attr {_dcbd :=_eaaf .Value ;
switch _bgbddb :=_eaaf .Name .Local ;_bgbddb {case "\u0073\u0072\u0063":_ecaec =_dcbd ;};};_ffda ,_ceeec :=_efcc .loadImageFromSrc (_ecaec );if _ceeec !=nil {return nil ,_ceeec ;};var _ddbbag _cd .StreamEncoder ;_ecggf :=_b .ToLower (_eb .Ext (_ecaec ));
if _ecggf =="\u006a\u0070\u0067"||_ecggf =="\u006a\u0070\u0065\u0067"{_ddbbag =_cd .NewDCTEncoder ();}else {_ddbbag =_cd .NewFlateEncoder ();};_ffda .SetEncoder (_ddbbag );for _ ,_edea :=range _bgfba ._fdbe .Attr {_dcgc :=_edea .Value ;switch _gaeec :=_edea .Name .Local ;
_gaeec {case "\u0061\u006c\u0069g\u006e":_ffda .SetHorizontalAlignment (_efcc .parseHorizontalAlignmentAttr (_gaeec ,_dcgc ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_ffda .SetOpacity (_efcc .parseFloatAttr (_gaeec ,_dcgc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_abdb :=_efcc .parseMarginAttr (_gaeec ,_dcgc );
_ffda .SetMargins (_abdb .Left ,_abdb .Right ,_abdb .Top ,_abdb .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_ffda .SetFitMode (_efcc .parseFitModeAttr (_gaeec ,_dcgc ));case "\u0078":_ffda .SetPos (_efcc .parseFloatAttr (_gaeec ,_dcgc ),_ffda ._eaede );
case "\u0079":_ffda .SetPos (_ffda ._dgda ,_efcc .parseFloatAttr (_gaeec ,_dcgc ));case "\u0077\u0069\u0064t\u0068":_ffda .SetWidth (_efcc .parseFloatAttr (_gaeec ,_dcgc ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_ffda .SetHeight (_efcc .parseFloatAttr (_gaeec ,_dcgc ));
case "\u0061\u006e\u0067l\u0065":_ffda .SetAngle (_efcc .parseFloatAttr (_gaeec ,_dcgc ));case "\u0065n\u0063\u006f\u0064\u0065\u0072":_ddbbag =_efcc .parseImageEncoder (_gaeec ,_dcgc );if _ddbbag !=nil {_ffda .SetEncoder (_ddbbag );};case "\u0073\u0072\u0063":break ;
default:_efcc .nodeLogDebug (_bgfba ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_gaeec );
};};return _ffda ,nil ;};func (_baabb *Paragraph )getTextLineWidth (_ffbda string )float64 {var _ccfff float64 ;for _ ,_dcbf :=range _ffbda {if _dcbf =='\u000A'{continue ;};_fgab ,_aead :=_baabb ._abbaf .GetRuneMetrics (_dcbf );if !_aead {_ef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dcbf ,_dcbf );
return -1;};_ccfff +=_baabb ._fagc *_fgab .Wx ;};return _ccfff ;};

// LineWidth returns the width of the line.
func (_ddceg *Line )LineWidth ()float64 {return _ddceg ._gfbf };

// NewSubchapter creates a new child chapter with the specified title.
func (_cgeg *Chapter )NewSubchapter (title string )*Chapter {_caag :=_ebage (_cgeg ._egge ._gbbce [0].Style .Font );_caag .FontSize =14;_cgeg ._ada ++;_baa :=_agde (_cgeg ,_cgeg ._fged ,_cgeg ._ecd ,title ,_cgeg ._ada ,_caag );_cgeg .Add (_baa );return _baa ;
};

// SetStyleBottom sets border style for bottom side.
func (_ebb *border )SetStyleBottom (style CellBorderStyle ){_ebb ._cbc =style };func _acgb (_gdaa []*ColorPoint )*LinearShading {return &LinearShading {_beecg :&shading {_egdad :ColorWhite ,_fgad :false ,_defcc :[]bool {false ,false },_fcefg :_gdaa },_aadcb :&_gf .PdfRectangle {}};
};func _cfed (_ddcfb *Block ,_decc *Image ,_bbbf DrawContext )(DrawContext ,error ){_afceb :=_bbbf ;_fggc :=1;_edce :=_cd .PdfObjectName (_e .Sprintf ("\u0049\u006d\u0067%\u0064",_fggc ));for _ddcfb ._ebe .HasXObjectByName (_edce ){_fggc ++;_edce =_cd .PdfObjectName (_e .Sprintf ("\u0049\u006d\u0067%\u0064",_fggc ));
};_bdcb :=_ddcfb ._ebe .SetXObjectImageByNameLazy (_edce ,_decc ._bbcef ,_decc ._cbgdb );if _bdcb !=nil {return _bbbf ,_bdcb ;};_dcdg :=0;_dded :=_cd .PdfObjectName (_e .Sprintf ("\u0047\u0053\u0025\u0064",_dcdg ));for _ddcfb ._ebe .HasExtGState (_dded ){_dcdg ++;
_dded =_cd .PdfObjectName (_e .Sprintf ("\u0047\u0053\u0025\u0064",_dcdg ));};_fbad :=_cd .MakeDict ();_fbad .Set ("\u0042\u004d",_cd .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _decc ._bdbfb < 1.0{_fbad .Set ("\u0043\u0041",_cd .MakeFloat (_decc ._bdbfb ));
_fbad .Set ("\u0063\u0061",_cd .MakeFloat (_decc ._bdbfb ));};_bdcb =_ddcfb ._ebe .AddExtGState (_dded ,_cd .MakeIndirectObject (_fbad ));if _bdcb !=nil {return _bbbf ,_bdcb ;};_ecdg :=_decc .Width ();_cdbce :=_decc .Height ();_ ,_bcfg :=_decc .rotatedSize ();
_egfc :=_bbbf .X ;_ecfga :=_bbbf .PageHeight -_bbbf .Y -_cdbce ;if _decc ._cgaad .IsRelative (){_ecfga -=(_bcfg -_cdbce )/2;switch _decc ._dagce {case HorizontalAlignmentCenter :_egfc +=(_bbbf .Width -_ecdg )/2;case HorizontalAlignmentRight :_egfc =_bbbf .PageWidth -_bbbf .Margins .Right -_decc ._gdgbd .Right -_ecdg ;
};};_dacb :=_decc ._ggedf ;_eaegf :=_ebf .NewContentCreator ();if _decc ._febda ==nil {if _decc ._febd !=nil {_eaegf .Add_BDC (*_cd .MakeName (string (_decc ._febd .StructureType )),map[string ]_cd .PdfObject {"\u004d\u0043\u0049\u0044":_cd .MakeInteger (_decc ._febd .Mcid )});
};}else {_cgebb :=_decc ._febda .GenerateMap ();if len (_cgebb )> 0{_eaegf .Add_BDC (*_cd .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")),_cgebb );}else {_eaegf .Add_BMC (*_cd .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")));
};};_eaegf .Add_gs (_dded );_eaegf .Translate (_egfc ,_ecfga );if _dacb !=0{_eaegf .Translate (_ecdg /2,_cdbce /2);_eaegf .RotateDeg (_dacb );_eaegf .Translate (-_ecdg /2,-_cdbce /2);};_eaegf .Scale (_ecdg ,_cdbce ).Add_Do (_edce );if _decc ._febd !=nil ||_decc ._febda !=nil {_eaegf .Add_EMC ();
};_ccee :=_eaegf .Operations ();_ccee .WrapIfNeeded ();_ddcfb .addWrappedContents (_ccee );if _decc ._cgaad .IsRelative (){_bbbf .Y +=_bcfg ;_bbbf .Height -=_bcfg ;return _bbbf ,nil ;};return _afceb ,nil ;};

// SetBorderWidth sets the border width of the rectangle.
func (_gfea *Rectangle )SetBorderWidth (bw float64 ){_gfea ._daegc =bw };

// SetMargins sets the margins of the chart component.
func (_gfe *Chart )SetMargins (left ,right ,top ,bottom float64 ){_gfe ._bade .Left =left ;_gfe ._bade .Right =right ;_gfe ._bade .Top =top ;_gfe ._bade .Bottom =bottom ;};func (_affbe *Paragraph )getTextMetrics ()(_efcgf ,_eaabc ,_feaaf float64 ){_aabaf :=_bfcdf (_affbe ._abbaf ,_affbe ._fagc );
if _aabaf ._bfefbg > _efcgf {_efcgf =_aabaf ._bfefbg ;};if _aabaf ._bdbba < _feaaf {_feaaf =_aabaf ._bdbba ;};if _adfeb :=_affbe ._fagc ;_adfeb > _eaabc {_eaabc =_adfeb ;};return _efcgf ,_eaabc ,_feaaf ;};

// NewTOC creates a new table of contents.
func (_bcff *Creator )NewTOC (title string )*TOC {_bedd :=_bcff .NewTextStyle ();_bedd .Font =_bcff ._eggg ;return _gbfce (title ,_bcff .NewTextStyle (),_bedd );};

// IsHeader returns whether this row is a header row.
func (_cbgdd *GridRow )IsHeader ()bool {return _cbgdd ._ddce ==GridRowSectionHeader };

// SetColorBottom sets border color for bottom.
func (_gaf *border )SetColorBottom (col Color ){_gaf ._bfb =col };

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_egfd *Division )Height ()float64 {var _aeff float64 ;for _ ,_afec :=range _egfd ._cbg {switch _bbgf :=_afec .(type ){case marginDrawable :_ ,_ ,_bgea ,_fdgc :=_bbgf .GetMargins ();_aeff +=_bbgf .Height ()+_bgea +_fdgc ;default:_aeff +=_bbgf .Height ();
};};return _aeff ;};

// SetMaxLines sets the maximum number of lines to be drawn.
func (_fbgcb *StyledParagraph )SetMaxLines (maxLines int ){_fbgcb ._bfgda =maxLines };func (_abdab *templateProcessor )parsePageBreak (_bbcac *templateNode )(interface{},error ){return _fbbb (),nil ;};func _baaa (_dgafa ,_abag ,_gffe ,_adeg float64 )*Ellipse {return &Ellipse {_eaee :_dgafa ,_cbcg :_abag ,_feeac :_gffe ,_feegb :_adeg ,_gfgfb :PositionAbsolute ,_afgb :1.0,_cgffb :ColorBlack ,_dcag :1.0,_eadb :1.0};
};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_abeg *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_becad :=ctx ;var _cefd []*Block ;_caff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _abeg ._baea .IsRelative (){ctx .X +=_eca .RoundDefault (_abeg ._ecdf .Left );
ctx .Y +=_eca .RoundDefault (_abeg ._ecdf .Top );ctx .Width -=_eca .RoundDefault (_abeg ._ecdf .Left +_abeg ._ecdf .Right );ctx .Height -=_eca .RoundDefault (_abeg ._ecdf .Top );_abeg .SetWidth (ctx .Width );if _abeg .Height ()> ctx .Height {_cefd =append (_cefd ,_caff );
_caff =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_aeefg :=ctx ;_aeefg .Y =_eca .RoundDefault (ctx .Margins .Top );_aeefg .X =_eca .RoundDefault (ctx .Margins .Left +_abeg ._ecdf .Left );_aeefg .Height =_eca .RoundDefault (ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom );
_aeefg .Width =_eca .RoundDefault (ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_abeg ._ecdf .Left -_abeg ._ecdf .Right );ctx =_aeefg ;};}else {if int (_abeg ._afeca )<=0{_abeg .SetWidth (_abeg .getTextWidth ());};ctx .X =_abeg ._dcff ;ctx .Y =_abeg ._debb ;
};ctx ,_addg :=_gaadc (_caff ,_abeg ,ctx );if _addg !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_addg );return nil ,ctx ,_addg ;};_cefd =append (_cefd ,_caff );if _abeg ._baea .IsRelative (){ctx .Y +=_eca .RoundDefault (_abeg ._ecdf .Bottom );
ctx .Height -=_eca .RoundDefault (_abeg ._ecdf .Bottom );if !ctx .Inline {ctx .X =_becad .X ;ctx .Width =_becad .Width ;};return _cefd ,ctx ,nil ;};return _cefd ,_becad ,nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{taggedDrawable ;_eaee float64 ;_cbcg float64 ;_feeac float64 ;_feegb float64 ;_gfgfb Positioning ;_cefg Color ;_afgb float64 ;_cgffb Color ;_dcag float64 ;_eadb float64 ;_caace Margins ;_ccgb FitMode ;};func (_aba *Creator )setActivePage (_fgba *_gf .PdfPage ){_aba ._ddbg =_fgba };


// SetCoords sets the center coordinates of the ellipse.
func (_baaab *Ellipse )SetCoords (xc ,yc float64 ){_baaab ._eaee =xc ;_baaab ._cbcg =yc };

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _cfbcf (path )};

// SetWidth sets the width of the rectangle.
func (_bbca *Rectangle )SetWidth (width float64 ){_bbca ._egdeb =width };

// BorderColor returns the border color of the rectangle.
func (_cecaf *Rectangle )BorderColor ()Color {return _cecaf ._agbbe };func _dfbce (_cefgg *templateProcessor ,_dcceb *templateNode )(interface{},error ){return _cefgg .parseChapter (_dcceb );};

// SetBuyerAddress sets the buyer address of the invoice.
func (_fbgc *Invoice )SetBuyerAddress (address *InvoiceAddress ){_fbgc ._fegbd =address };

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_fecg *Chart )Width ()float64 {return float64 (_fecg ._ddba .Width ())};func (_caaab *Invoice )generateTotalBlocks (_bgbfc DrawContext )([]*Block ,DrawContext ,error ){_bcde :=_aggeg (4);_bcde .SetMargins (0,0,10,10);_dcge :=[][2]*InvoiceCell {_caaab ._efcb };
_dcge =append (_dcge ,_caaab ._eade ...);_dcge =append (_dcge ,_caaab ._dfad );for _ ,_aadgb :=range _dcge {_ccce ,_fdga :=_aadgb [0],_aadgb [1];if _fdga .Value ==""{continue ;};_bcde .SkipCells (2);_dcdf :=_bcde .NewCell ();_dcdf .SetBackgroundColor (_ccce .BackgroundColor );
_dcdf .SetHorizontalAlignment (_fdga .Alignment );_caaab .setCellBorder (_dcdf ,_ccce );_bfac :=_bgdc (_ccce .TextStyle );_bfac .SetMargins (0,0,2,1);_bfac .Append (_ccce .Value );_dcdf .SetContent (_bfac );_dcdf =_bcde .NewCell ();_dcdf .SetBackgroundColor (_fdga .BackgroundColor );
_dcdf .SetHorizontalAlignment (_fdga .Alignment );_caaab .setCellBorder (_dcdf ,_ccce );_bfac =_bgdc (_fdga .TextStyle );_bfac .SetMargins (0,0,2,1);_bfac .Append (_fdga .Value );_dcdf .SetContent (_bfac );};return _bcde .GeneratePageBlocks (_bgbfc );};


// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_agad *Line )Width ()float64 {return _fb .Abs (_agad ._bada -_agad ._gbba )};

// SetStructPageNumber sets the page object where the structure element for this drawable is located.
func (_deaf *taggedDrawable )SetStructPageNumber (pageNumber *int64 ){if _deaf ._febd ==nil {_deaf ._febd =_gf .NewStructureTagInfo ();_deaf ._febd .StructureType =_deaf ._gage ;};_deaf ._febd .StructPageNumber =pageNumber ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_cbefae *Image )ConvertToBinary ()error {return _cbefae ._addd .ConvertToBinary ()};func (_gcbdg *StyledParagraph )getLineMetrics (_fgebe int )(_dgab ,_gfeb ,_dbbd float64 ){if _gcbdg ._aeggc ==nil ||(_gcbdg ._aeggc !=nil &&len (_gcbdg ._aeggc )==0){_gcbdg .wrapText ();
};if _fgebe < 0||_fgebe > len (_gcbdg ._aeggc )-1{_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_fgebe );
return 0,0,0;};return _cefa (_gcbdg ._aeggc [_fgebe ]);};func (_aaeae *Invoice )SetStructPageNumber (pageNumber *int64 ){};

// SetLineHeight sets the line height (1.0 default).
func (_bdgf *StyledParagraph )SetLineHeight (lineheight float64 ){_bdgf ._edcb =lineheight };

// SetBorderOpacity sets the border opacity of the ellipse.
func (_gedd *Ellipse )SetBorderOpacity (opacity float64 ){_gedd ._eadb =opacity };

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_facdg *StyledParagraph )SetLanguageIdentifier (id string ){if _facdg ._febd ==nil {_facdg ._febd =_gf .NewStructureTagInfo ();_facdg ._febd .StructureType =_gf .StructureTypeParagraph ;};_facdg ._edbead =id ;};func (_eggb cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_dafd :=_eggb ._fgae ;
return 1-(_eggb ._dbg *(1-_dafd )+_dafd ),1-(_eggb ._dcg *(1-_dafd )+_dafd ),1-(_eggb ._acag *(1-_dafd )+_dafd );};func (_bgcbe *StyledParagraph )getTextLineWidth (_dbdd []*TextChunk )float64 {var _dbfc float64 ;_gaeef :=len (_dbdd );for _feed ,_agee :=range _dbdd {_cfgd :=&_agee .Style ;
_ggcag :=len (_agee .Text );for _deccd ,_dgdd :=range _agee .Text {if _dgdd =='\u000A'{continue ;};_fdgd ,_cadae :=_cfgd .Font .GetRuneMetrics (_dgdd );if !_cadae {_ef .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dgdd );
return -1;};_dbfc +=_cfgd .FontSize *_fdgd .Wx *_cfgd .horizontalScale ();if _dgdd !=' '&&(_feed !=_gaeef -1||_deccd !=_ggcag -1){_dbfc +=_cfgd .CharSpacing *1000.0;};};};return _dbfc ;};func _bgdc (_agfe TextStyle )*StyledParagraph {return &StyledParagraph {_gbbce :[]*TextChunk {},_dgaag :_agfe ,_eeeag :_gbagg (_agfe .Font ),_edcb :1.0,_abgad :TextAlignmentLeft ,_ffeac :true ,_dddf :true ,_fcgd :false ,_eagdd :0,_bege :1,_bgce :1,_ggdeb :PositionRelative ,_edbead :"",_ebff :nil ,taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeParagraph }};
};func (_cbce *templateProcessor )parseTextVerticalAlignmentAttr (_bagec ,_dgfee string )TextVerticalAlignment {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bagec ,_dgfee );
_fead :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_dgfee ];return _fead ;};func (_efdcb *templateProcessor )parseFitModeAttr (_dacab ,_fceadg string )FitMode {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_dacab ,_fceadg );
_gagcf :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_fceadg ];return _gagcf ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_debe *LinearShading )SetBackgroundColor (backgroundColor Color ){_debe ._beecg .SetBackgroundColor (backgroundColor );};

// BorderWidth returns the border width of the rectangle.
func (_dgfe *Rectangle )BorderWidth ()float64 {return _dgfe ._daegc };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };
);func _ceg (_cfg string ,_bda _cd .PdfObject ,_ceff *_gf .PdfPageResources )_cd .PdfObjectName {_ceffe :=_b .TrimRightFunc (_b .TrimSpace (_cfg ),func (_fgac rune )bool {return _ge .IsNumber (_fgac )});if _ceffe ==""{_ceffe ="\u0046\u006f\u006e\u0074";
};_caaa :=0;_dcb :=_cd .PdfObjectName (_cfg );for {_gceb ,_bcgf :=_ceff .GetFontByName (_dcb );if !_bcgf ||_gceb ==_bda {break ;};_caaa ++;_dcb =_cd .PdfObjectName (_e .Sprintf ("\u0025\u0073\u0025\u0064",_ceffe ,_caaa ));};return _dcb ;};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_cgcd *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_cgcd ._ccafa .Left =left ;_cgcd ._ccafa .Right =right ;_cgcd ._ccafa .Top =top ;_cgcd ._ccafa .Bottom =bottom ;};

// SetFillOpacity sets the fill opacity.
func (_deb *CurvePolygon )SetFillOpacity (opacity float64 ){_deb ._ccc =opacity };

// SetStructureType sets the structure type for the drawable.
func (_ggfgb *taggedDrawable )SetStructureType (structureType _gf .StructureType ){if _ggfgb ._febd ==nil {_ggfgb ._febd =_gf .NewStructureTagInfo ();};_ggfgb ._febd .StructureType =structureType ;};

// Scale scales Image by a constant factor, both width and height.
func (_dacf *Image )Scale (xFactor ,yFactor float64 ){_dacf ._dgega =xFactor *_dacf ._dgega ;_dacf ._dfbd =yFactor *_dacf ._dfbd ;};func (_gfg rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _gfg ._aaba ,_gfg ._caef ,_gfg ._dgc };

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ce .ChartRenderable )*Chart {return _eacf (chart )};

// SetDueDate sets the due date of the invoice.
func (_cgebf *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_cgebf ._ccaab [1].Value =dueDate ;return _cgebf ._ccaab [0],_cgebf ._ccaab [1];};

// EnableWordWrap sets the paragraph word wrap flag.
func (_cbfba *StyledParagraph )EnableWordWrap (val bool ){_cbfba ._fcgd =val };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fcdb *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_ggfbe :=_bgdc (_fcdb ._gcace );_ggfbe .Append (text );_bfbfb ,_abbeg :=_fcdb .Add (_ggfbe );return _ggfbe ,_bfbfb ,_abbeg ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_gcc *GridCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_gcc ._cffd =halign };func (_dege *GridRow )updateRowHeight (_eefc float64 ){_dege ._cedeg =_dege ._bef ;for _ ,_fgaff :=range _dege ._cffad {_eega :=_fgaff .width (_dege ._dcdde ._ccaa ,_eefc );
_ddag :=_fgaff .height (_eega );if _ddag > _dege ._cedeg {_dege ._cedeg =_ddag ;};};};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_agab *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcbe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gece ,_ ,_afabg :=_agab .draw (_bcbe ,"");if _afabg !=nil {return nil ,ctx ,_afabg ;};_afabg =_bcbe .addContentsByString (string (_gece ));
if _afabg !=nil {return nil ,ctx ,_afabg ;};return []*Block {_bcbe },ctx ,nil ;};

// NewRow makes a new row and inserts it into the table at the current position.
func (_dcaf *Grid )NewRow ()*GridRow {_eebd :=&GridRow {_bef :_dcaf ._gegag ,_fbagff :len (_dcaf ._fdagc ),_dcdde :_dcaf };_dcaf ._fdagc =append (_dcaf ._fdagc ,_eebd );return _eebd ;};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_feaf *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_dgde []*Block ;_dafe =NewBlock (ctx .PageWidth ,ctx .PageHeight );_aacaa =ctx ;_acbb ,_beeg =_feaf ._gbba ,ctx .PageHeight -_feaf ._dfag ;_cdbe ,_cfabb =_feaf ._bada ,ctx .PageHeight -_feaf ._bbacd ;
);_gdbf :=_feaf ._fbdb .IsRelative ();if _gdbf {ctx .X +=_feaf ._dfbfa .Left ;ctx .Y +=_feaf ._dfbfa .Top ;ctx .Width -=_feaf ._dfbfa .Left +_feaf ._dfbfa .Right ;ctx .Height -=_feaf ._dfbfa .Top +_feaf ._dfbfa .Bottom ;_acbb ,_beeg ,_cdbe ,_cfabb =_feaf .computeCoords (ctx );
if _feaf .Height ()> ctx .Height {_dgde =append (_dgde ,_dafe );_dafe =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fbfdb :=ctx ;_fbfdb .Y =ctx .Margins .Top +_feaf ._dfbfa .Top ;_fbfdb .X =ctx .Margins .Left +_feaf ._dfbfa .Left ;_fbfdb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_feaf ._dfbfa .Top -_feaf ._dfbfa .Bottom ;
_fbfdb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_feaf ._dfbfa .Left -_feaf ._dfbfa .Right ;ctx =_fbfdb ;_acbb ,_beeg ,_cdbe ,_cfabb =_feaf .computeCoords (ctx );};};_ffff :=_dd .BasicLine {X1 :_acbb ,Y1 :_beeg ,X2 :_cdbe ,Y2 :_cfabb ,LineColor :_fbd (_feaf ._fgbd ),Opacity :_feaf ._caabd ,LineWidth :_feaf ._gfbf ,LineStyle :_feaf ._gcgff ,DashArray :_feaf ._gddg ,DashPhase :_feaf ._edaa };
_ccab ,_aaeee :=_dafe .setOpacity (1.0,_feaf ._caabd );if _aaeee !=nil {return nil ,ctx ,_aaeee ;};_fafgfd ,_ ,_aaeee :=_ffff .MarkedDraw (_ccab ,_feaf ._febd );if _aaeee !=nil {return nil ,ctx ,_aaeee ;};if _aaeee =_dafe .addContentsByString (string (_fafgfd ));
_aaeee !=nil {return nil ,ctx ,_aaeee ;};if _gdbf {ctx .X =_aacaa .X ;ctx .Width =_aacaa .Width ;_eedg :=_feaf .Height ();ctx .Y +=_eedg +_feaf ._dfbfa .Bottom ;ctx .Height -=_eedg ;}else {ctx =_aacaa ;};_dgde =append (_dgde ,_dafe );return _dgde ,ctx ,nil ;
};

// SetDate sets the date of the invoice.
func (_aegf *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_aegf ._bdgb [1].Value =date ;return _aegf ._bdgb [0],_aegf ._bdgb [1];};func (_eeb *Block )addContentsByString (_ffg string )error {_cbe :=_ebf .NewContentStreamParser (_ffg );_agb ,_cfd :=_cbe .Parse ();
if _cfd !=nil {return _cfd ;};_eeb ._bac .WrapIfNeeded ();_agb .WrapIfNeeded ();*_eeb ._bac =append (*_eeb ._bac ,*_agb ...);return nil ;};func (_fdgcd *Division )split (_daea DrawContext )(_degge ,_dcdd *Division ){var (_gbcc float64 ;_ffbc ,_dbae []VectorDrawable ;
);_eecb :=_daea .Width -_fdgcd ._ffd .Left -_fdgcd ._ffd .Right -_fdgcd ._aeg .Left -_fdgcd ._aeg .Right ;for _gada ,_ede :=range _fdgcd ._cbg {_gbcc +=_efcg (_ede ,_eecb );if _gbcc < _daea .Height {_ffbc =append (_ffbc ,_ede );}else {_dbae =_fdgcd ._cbg [_gada :];
break ;};};if len (_ffbc )> 0{_degge =_ffbf ();*_degge =*_fdgcd ;_degge ._cbg =_ffbc ;if _fdgcd ._ecfg !=nil {_degge ._ecfg =&Background {};*_degge ._ecfg =*_fdgcd ._ecfg ;};};if len (_dbae )> 0{_dcdd =_ffbf ();*_dcdd =*_fdgcd ;_dcdd ._cbg =_dbae ;if _fdgcd ._ecfg !=nil {_dcdd ._ecfg =&Background {};
*_dcdd ._ecfg =*_fdgcd ._ecfg ;};};return _degge ,_dcdd ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_abgfa *TableCell )SetContent (vd VectorDrawable )error {switch _cgbec :=vd .(type ){case *Paragraph :if _cgbec ._fefe {_cgbec ._daabg =true ;};_abgfa ._ebagf =vd ;case *StyledParagraph :if _cgbec ._dddf {_cgbec ._ffeac =true ;};_abgfa ._ebagf =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_abgfa ._ebagf =vd ;default:_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _cd .ErrTypeError ;};return nil ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_aafc *Invoice )SetNoteHeadingStyle (style TextStyle ){_aafc ._efba =style };func (_dfabf *templateProcessor )parseAttrPropList (_ffcad string )map[string ]string {_gfdd :=_b .Fields (_ffcad );if len (_gfdd )==0{return nil ;};_daba :=map[string ]string {};
for _ ,_dccc :=range _gfdd {_baeag :=_eebdd .FindStringSubmatch (_dccc );if len (_baeag )< 3{continue ;};_caeb ,_dcece :=_b .TrimSpace (_baeag [1]),_baeag [2];if _caeb ==""{continue ;};_daba [_caeb ]=_dcece ;};return _daba ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
//
// Deprecated: Use NewStyledParagraph instead for better styling options.
func (_ffea *Creator )NewParagraph (text string )*Paragraph {return _acgd (text ,_ffea .NewTextStyle ())};

// AddColorStop add color stop info for rendering gradient color.
func (_cefce *LinearShading )AddColorStop (color Color ,point float64 ){_cefce ._beecg .AddColorStop (color ,point );};const (DefaultHorizontalScaling =100;);func (_fdbd *pageTransformations )transformBlock (_eda *Block ){if _fdbd ._gef !=nil {_eda .transform (*_fdbd ._gef );
};};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_abgdg *Invoice )SetAddressStyle (style TextStyle ){_abgdg ._afeef =style };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_ccd *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_ccd ._egdc .Left =left ;_ccd ._egdc .Right =right ;_ccd ._egdc .Top =top ;_ccd ._egdc .Bottom =bottom ;};

// AddAnnotation adds an annotation on a TextChunk.
func (_aaega *TextChunk )AddAnnotation (annotation *_gf .PdfAnnotation ){if annotation ==nil {return ;};_aaega ._cgbff =append (_aaega ._cgbff ,annotation );};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func (_fabaa *Invoice )generateInformationBlocks (_febc DrawContext )([]*Block ,DrawContext ,error ){_bcegca :=_bgdc (_fabaa ._agdg );_bcegca .SetMargins (0,0,0,20);_bfdcf :=_fabaa .drawAddress (_fabaa ._dfce );
_bfdcf =append (_bfdcf ,_bcegca );_bfdcf =append (_bfdcf ,_fabaa .drawAddress (_fabaa ._fegbd )...);_fcbg :=_ffbf ();for _ ,_faag :=range _bfdcf {_fcbg .Add (_faag );};_dgba :=_fabaa .drawInformation ();_dfaaa :=_aggeg (2);_dfaaa .SetMargins (0,0,25,0);
_gaee :=_dfaaa .NewCell ();_gaee .SetIndent (0);_gaee .SetContent (_fcbg );_gaee =_dfaaa .NewCell ();_gaee .SetContent (_dgba );return _dfaaa .GeneratePageBlocks (_febc );};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_eagf *Chapter )SetIncludeInTOC (includeInTOC bool ){_eagf ._gge =includeInTOC };const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);func _ebebc (_cbfefd ,_ccbcb ,_febgf float64 )(_gacgf ,_dagad ,_fddcf ,_ddbaag float64 ){if _febgf ==0{return 0,0,_cbfefd ,_ccbcb ;
};_gfbfe :=_dd .Path {Points :[]_dd .Point {_dd .NewPoint (0,0).Rotate (_febgf ),_dd .NewPoint (_cbfefd ,0).Rotate (_febgf ),_dd .NewPoint (0,_ccbcb ).Rotate (_febgf ),_dd .NewPoint (_cbfefd ,_ccbcb ).Rotate (_febgf )}}.GetBoundingBox ();return _gfbfe .X ,_gfbfe .Y ,_gfbfe .Width ,_gfbfe .Height ;
};

// Inline returns whether the inline mode of the division is active.
func (_cadf *Division )Inline ()bool {return _cadf ._dfcc };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_dgga *Invoice )SetNoteStyle (style TextStyle ){_dgga ._bddf =style };

// Highlight adds a highlight annotation to the text chunk with the specified color and alpha value.
func (_afge *TextChunk )Highlight (color Color ,alpha float64 )*_gf .PdfAnnotation {_cggde ,_feefd ,_afgee :=color .ToRGB ();_dcfca :=_gf .NewPdfAnnotationHighlight ();_dcfca .C =_cd .MakeArrayFromFloats ([]float64 {_cggde ,_feefd ,_afgee });_dcfca .CA =_cd .MakeFloat (alpha );
_afge .AddAnnotation (_dcfca .PdfAnnotation );return _dcfca .PdfAnnotation ;};func (_eaga *Invoice )newCell (_dfab string ,_gbd InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_gbd ,_dfab };};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_cgfb *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_cccb []*Block ;_gdfd =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gadge =ctx ;);_dcea :=_cgfb ._gfgfb .IsRelative ();if _dcea {_cgfb .applyFitMode (ctx .Width );
ctx .X +=_cgfb ._caace .Left ;ctx .Y +=_cgfb ._caace .Top ;ctx .Width -=_cgfb ._caace .Left +_cgfb ._caace .Right ;ctx .Height -=_cgfb ._caace .Top +_cgfb ._caace .Bottom ;if _cgfb ._feegb > ctx .Height {_cccb =append (_cccb ,_gdfd );_gdfd =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_egfdb :=ctx ;_egfdb .Y =ctx .Margins .Top +_cgfb ._caace .Top ;_egfdb .X =ctx .Margins .Left +_cgfb ._caace .Left ;_egfdb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cgfb ._caace .Top -_cgfb ._caace .Bottom ;_egfdb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cgfb ._caace .Left -_cgfb ._caace .Right ;
ctx =_egfdb ;};}else {ctx .X =_cgfb ._eaee -_cgfb ._feeac /2;ctx .Y =_cgfb ._cbcg -_cgfb ._feegb /2;};_ggfb :=_dd .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_cgfb ._feegb ,Width :_cgfb ._feeac ,Height :_cgfb ._feegb ,BorderWidth :_cgfb ._dcag ,Opacity :1.0};
if _cgfb ._cefg !=nil {_ggfb .FillEnabled =true ;_afcd :=_fbd (_cgfb ._cefg );_gaea :=_bdced (_gdfd ,_afcd ,_cgfb ._cefg ,func ()Rectangle {return Rectangle {_acaf :_ggfb .X ,_dgec :_ggfb .Y ,_egdeb :_ggfb .Width ,_ebef :_ggfb .Height };});if _gaea !=nil {return nil ,ctx ,_gaea ;
};_ggfb .FillColor =_afcd ;};if _cgfb ._cgffb !=nil {_ggfb .BorderEnabled =false ;if _cgfb ._dcag > 0{_ggfb .BorderEnabled =true ;};_ggfb .BorderColor =_fbd (_cgfb ._cgffb );_ggfb .BorderWidth =_cgfb ._dcag ;};_daca ,_bcgg :=_gdfd .setOpacity (_cgfb ._afgb ,_cgfb ._eadb );
if _bcgg !=nil {return nil ,ctx ,_bcgg ;};_eagfe ,_ ,_bcgg :=_ggfb .MarkedDraw (_daca ,_cgfb ._febd );if _bcgg !=nil {return nil ,ctx ,_bcgg ;};_bcgg =_gdfd .addContentsByString (string (_eagfe ));if _bcgg !=nil {return nil ,ctx ,_bcgg ;};if _dcea {ctx .X =_gadge .X ;
ctx .Width =_gadge .Width ;ctx .Y +=_cgfb ._feegb +_cgfb ._caace .Bottom ;ctx .Height -=_cgfb ._feegb ;}else {ctx =_gadge ;};_cccb =append (_cccb ,_gdfd );return _cccb ,ctx ,nil ;};func _aacae (_bgbcb *Block ,_dfcac *_gf .StructureTagInfo ){_dgfg :=_ebf .NewContentCreator ();
_eadcc :=map[string ]_cd .PdfObject {};if _dfcac !=nil {_eadcc ["\u004d\u0043\u0049\u0044"]=_cd .MakeInteger (_dfcac .Mcid );};_dgfg .Add_BDC (*_cd .MakeName (string (_dfcac .StructureType )),_eadcc );_bgbcb .addContents (_dgfg .Operations ());};

// SetStructTreeRoot sets the structure tree root to be appended in the document that will be created.
func (_dcfc *Creator )SetStructTreeRoot (structTreeRoot *_gf .StructTreeRoot ){_dcfc ._gec =structTreeRoot ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_fbae *Image )ScaleToHeight (h float64 ){_abda :=_fbae ._dgega /_fbae ._dfbd ;_fbae ._dfbd =h ;_fbae ._dgega =h *_abda ;};func _efcg (_dabe VectorDrawable ,_aeffg float64 )float64 {switch _dgbb :=_dabe .(type ){case *Paragraph :if _dgbb ._daabg {_dgbb .SetWidth (_aeffg -_dgbb ._ecdf .Left -_dgbb ._ecdf .Right );
};return _dgbb .Height ()+_dgbb ._ecdf .Top +_dgbb ._ecdf .Bottom +(0.5*_dgbb ._fagc *_dgbb ._eaag );case *StyledParagraph :if _dgbb ._ffeac {_dgbb .SetWidth (_aeffg -_dgbb ._dbge .Left -_dgbb ._dbge .Right );};return _dgbb .Height ()+_dgbb ._dbge .Top +_dgbb ._dbge .Bottom +(0.5*_dgbb .getTextHeight ());
case *Image :_dgbb .applyFitMode (_aeffg );return _dgbb .Height ()+_dgbb ._gdgbd .Top +_dgbb ._gdgbd .Bottom ;case *Rectangle :_dgbb .applyFitMode (_aeffg );return _dgbb .Height ()+_dgbb ._ccafa .Top +_dgbb ._ccafa .Bottom +_dgbb ._daegc ;case *Ellipse :_dgbb .applyFitMode (_aeffg );
return _dgbb .Height ()+_dgbb ._caace .Top +_dgbb ._caace .Bottom ;case *Division :return _dgbb .ctxHeight (_aeffg )+_dgbb ._ffd .Top +_dgbb ._ffd .Bottom +_dgbb ._aeg .Top +_dgbb ._aeg .Bottom ;case *Table :_dgbb .updateRowHeights (_aeffg -_dgbb ._efdf .Left -_dgbb ._efdf .Right );
return _dgbb .Height ()+_dgbb ._efdf .Top +_dgbb ._efdf .Bottom ;case *List :return _dgbb .ctxHeight (_aeffg )+_dgbb ._caba .Top +_dgbb ._caba .Bottom ;case marginDrawable :_ ,_ ,_dced ,_egcf :=_dgbb .GetMargins ();return _dgbb .Height ()+_dced +_egcf ;
default:return _dgbb .Height ();};};func _gbfce (_gcafc string ,_ddadaf ,_bbdfd TextStyle )*TOC {_efgfa :=_bbdfd ;_efgfa .FontSize =14;_ccfa :=_bgdc (_efgfa );_ccfa .SetEnableWrap (true );_ccfa .SetTextAlignment (TextAlignmentLeft );_ccfa .SetMargins (0,0,0,5);
_deafe :=_ccfa .Append (_gcafc );_deafe .Style =_efgfa ;return &TOC {_bbcbd :_ccfa ,_efbef :[]*TOCLine {},_bgbaa :_ddadaf ,_bbeae :_ddadaf ,_cbdff :_ddadaf ,_gagad :_ddadaf ,_cfadf :"\u002e",_dcae :10,_cdefd :Margins {0,0,2,2},_fdffe :PositionRelative ,_aafde :_ddadaf ,_befbd :true ,taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeTOC }};
};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_bgde *Chapter )GetHeading ()*StyledParagraph {return _bgde ._egge };

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_gbcb *Ellipse )ScaleToWidth (w float64 ){_cdca :=_gbcb ._feegb /_gbcb ._feeac ;_gbcb ._feeac =w ;_gbcb ._feegb =w *_cdca ;};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_fgdgc *Ellipse )SetFillOpacity (opacity float64 ){_fgdgc ._afgb =opacity };

// Height returns the total height of all rows.
func (_ddga *Grid )Height ()float64 {_eddg :=float64 (0.0);for _ ,_dgbbb :=range _ddga ._fdagc {_eddg +=_dgbbb ._bef ;};return _eddg ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_dacc *Creator )NewStyledParagraph ()*StyledParagraph {return _bgdc (_dacc .NewTextStyle ())};

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};func _abbee (_bbceb *templateProcessor ,_agbdaa *templateNode )(interface{},error ){return _bbceb .parseListMarker (_agbdaa );};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_aeeec *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_aeeec ._eggbc =&_gf .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func _bgbad (_cefda *templateProcessor ,_degbg *templateNode )(interface{},error ){return _cefda .parseList (_degbg );
};func (_ggcec *templateProcessor )parseLinkAttr (_fedf ,_cdbd string )*_gf .PdfAnnotation {_cdbd =_b .TrimSpace (_cdbd );if _b .HasPrefix (_cdbd ,"\u0075\u0072\u006c(\u0027")&&_b .HasSuffix (_cdbd ,"\u0027\u0029")&&len (_cdbd )> 7{return _dffad (_cdbd [5:len (_cdbd )-2],"");
};if _b .HasPrefix (_cdbd ,"\u0070\u0061\u0067e\u0028")&&_b .HasSuffix (_cdbd ,"\u0029")&&len (_cdbd )> 6{var (_eacfd error ;_affba int64 ;_gdfe float64 ;_fadee float64 ;_debfa =1.0;_bcdbcf =_b .Split (_cdbd [5:len (_cdbd )-1],"\u002c"););_affba ,_eacfd =_ca .ParseInt (_b .TrimSpace (_bcdbcf [0]),10,64);
if _eacfd !=nil {_ef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_eacfd );return nil ;};if len (_bcdbcf )>=2{_gdfe ,_eacfd =_ca .ParseFloat (_b .TrimSpace (_bcdbcf [1]),64);
if _eacfd !=nil {_ef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_eacfd );
return nil ;};};if len (_bcdbcf )>=3{_fadee ,_eacfd =_ca .ParseFloat (_b .TrimSpace (_bcdbcf [2]),64);if _eacfd !=nil {_ef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_eacfd );
return nil ;};};if len (_bcdbcf )>=4{_debfa ,_eacfd =_ca .ParseFloat (_b .TrimSpace (_bcdbcf [3]),64);if _eacfd !=nil {_ef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_eacfd );
return nil ;};};return _ffbcd (_affba -1,_gdfe ,_fadee ,_debfa ,"");};return nil ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_dagd *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dagd ._gdgbd .Left ,_dagd ._gdgbd .Right ,_dagd ._gdgbd .Top ,_dagd ._gdgbd .Bottom ;};func (_fedc *Grid )cloneRow (_acee int )*GridRow {_eaeg :=&GridRow {_bef :_fedc ._gegag ,_fbagff :_acee +1,_dcdde :_fedc };
for _ ,_egee :=range _fedc ._fdagc [_acee ]._cffad {_baag ,_ :=_eaeg .NewMultiCell (_egee ._cabd ,1);if _baag !=nil {_baag ._gcbd =_egee ._gcbd ;_baag ._ggbe =_egee ._ggbe ;_baag ._fceb =_egee ._fceb ;_baag ._bdgae =_egee ._bdgae ;_baag ._eeff =_egee ._eeff ;
_baag ._gcff =_egee ._gcff ;_baag ._abeb =_egee ._abeb ;_baag ._beddg =_egee ._beddg ;_baag ._cgcb =_egee ._cgcb ;_baag ._cddd =_egee ._cddd ;_baag ._gafdd =_egee ._gafdd ;_baag ._ffegf =_egee ._ffegf ;_baag ._caeea =_egee ._caeea ;_baag ._cbde =_egee ._cbde ;
_baag ._ecabf =_egee ._ecabf ;_baag ._cffd =_egee ._cffd ;_baag ._bcbg =_egee ._bcbg ;_baag ._ccfb =_egee ._ccfb ;_baag ._cbbe =_acee +1;_baag ._efbg =_egee ._efbg ;};};return _eaeg ;};func (_dcaad *Table )updateRowHeights (_cebb float64 ){for _ ,_ecdce :=range _dcaad ._agced {_ageca :=_ecdce .width (_dcaad ._beeaca ,_cebb );
_eegff :=_ecdce .height (_ageca );_gabe :=_dcaad ._acbg [_ecdce ._efdd +_ecdce ._addgb -2];if _ecdce ._addgb > 1{_bdef :=0.0;_ffbdg :=_dcaad ._acbg [_ecdce ._efdd -1:(_ecdce ._efdd +_ecdce ._addgb -1)];for _ ,_cbega :=range _ffbdg {_bdef +=_cbega ;};if _eegff <=_bdef {continue ;
};};if _eegff > _gabe {_geede :=_eegff /float64 (_ecdce ._addgb );if _geede > _gabe {for _fggfd :=1;_fggfd <=_ecdce ._addgb ;_fggfd ++{if _geede > _dcaad ._acbg [_ecdce ._efdd +_fggfd -2]{_dcaad ._acbg [_ecdce ._efdd +_fggfd -2]=_geede ;};};};};};};

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_ccf *border )SetMarkedContentID (id int64 ){};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_deaaa rune ;_afbfc []error ;};

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_bcb *border )SetStructureType (structureType _gf .StructureType ){};func (_feea *pageTransformations )transformPage (_bbea *_gf .PdfPage )error {if _gadd :=_feea .applyFlip (_bbea );_gadd !=nil {return _gadd ;};return nil ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cfgf *Creator )Draw (d Drawable )error {if _cfgf .getActivePage ()==nil {_cfgf .NewPage ();};if _cfgf ._bcgd {_cfgf ._fbg ++;_ecec :=int64 (len (_cfgf ._cbf ));d .SetStructPageNumber (&_ecec );switch _daeb :=d .(type ){case *Table :_daeb .AddTag (_cfgf ._fae );
_daeb .SetMarkedContentID (_cfgf ._fbg );case *Grid :_daeb .AddTag (_cfgf ._fae );_daeb .SetMarkedContentID (_cfgf ._fbg );case *List :_daeb .AddTag (_cfgf ._fae );_daeb .SetMarkedContentID (_cfgf ._fbg );case *Division :_daeb .AddTag (_cfgf ._fae );_daeb .SetMarkedContentID (_cfgf ._fbg );
default:_daeb .SetMarkedContentID (_cfgf ._fbg );_ggea ,_dfbf :=_daeb .GenerateKDict ();if _dfbf !=nil {return _dfbf ;};if _ggea !=nil {_cfgf ._fae .AddKChild (_ggea );};};};_badee ,_fgbc ,_cfc :=d .GeneratePageBlocks (_cfgf ._fcba );if _cfc !=nil {return _cfc ;
};if len (_fgbc ._afbfc )> 0{_cfgf .Errors =append (_cfgf .Errors ,_fgbc ._afbfc ...);};for _febb ,_degg :=range _badee {if _febb > 0{_cfgf .NewPage ();};_egege :=_cfgf .getActivePage ();if _fffe ,_cac :=_cfgf ._aea [_egege ];_cac {if _gffc :=_fffe .mergeBlocks (_degg );
_gffc !=nil {return _gffc ;};if _dbeb :=_cge (_degg ._ebe ,_fffe ._ebe );_dbeb !=nil {return _dbeb ;};}else {_cfgf ._aea [_egege ]=_degg ;};};_cfgf ._fcba .X =_fgbc .X ;_cfgf ._fcba .Y =_fgbc .Y ;_cfgf ._fcba .Height =_eca .RoundDefault (_fgbc .PageHeight -_fgbc .Y -_fgbc .Margins .Bottom );
return nil ;};func (_cdcge pathParserError )Error ()string {return _cdcge ._acgfb };

// SetLanguage sets the language identifier that will be stored inside document catalog.
func (_eggea *Creator )SetLanguage (language string ){_eggea ._fgeb =language };

// GetIndent get the cell's left indent.
func (_gbafa *TableCell )GetIndent ()float64 {return _gbafa ._aagdg };

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_beecg *shading ;_aadcb *_gf .PdfRectangle ;_aecga float64 ;};

// NewMultiCell makes a new cell with given colspan and rowspan and inserts it into the row at the current position.
func (_dggc *GridRow )NewMultiCell (colspan ,rowspan int )(*GridCell ,error ){_ebfac :=&GridCell {_ecabf :len (_dggc ._cffad ),_cbbe :_dggc ._fbagff ,_cabd :colspan ,_fagfe :rowspan };_ebfac ._cbbe =_dggc ._fbagff ;_ebfac ._ecabf =0;for _ ,_cbcd :=range _dggc ._cffad {_ebfac ._ecabf +=_cbcd ._cabd ;
};for _adde ,_ddbc :=range _dggc ._dcdde ._fdagc {if _adde ==_dggc ._fbagff +1{break ;};for _ ,_bfbfg :=range _ddbc ._cffad {if _bfbfg ._cbbe +_bfbfg ._fagfe > _ebfac ._cbbe {if _bfbfg ._ecabf +_bfbfg ._cabd > _ebfac ._ecabf {_ebfac ._ecabf =_bfbfg ._ecabf +_bfbfg ._cabd ;
};};};};if _ebfac ._ecabf >=_dggc ._dcdde ._daec {return nil ,_g .New ("\u0063\u0061n'\u0074\u0020\u0061d\u0064\u0020\u0061\u006ey m\u006fre\u0020\u0063\u0065\u006c\u006c\u0073\u0020to\u0020\u0074\u0068\u0069\u0073\u0020\u0072o\u0077");};_ebfac ._bcbg =5;
_ebfac ._beddg =CellBorderStyleNone ;_ebfac ._gcff =_dd .LineStyleSolid ;_ebfac ._cffd =CellHorizontalAlignmentLeft ;_ebfac ._efbg =CellVerticalAlignmentTop ;_ebfac ._ffegf =0;_ebfac ._gafdd =0;_ebfac ._caeea =0;_ebfac ._cbde =0;_aecg :=ColorBlack ;_ebfac ._fceb =_aecg ;
_ebfac ._ggbe =_aecg ;_ebfac ._bdgae =_aecg ;_ebfac ._eeff =_aecg ;_ebfac ._ccfb =1.0;_dggc ._cffad =append (_dggc ._cffad ,_ebfac );_ebfac ._gage =_gf .StructureTypeTableData ;return _ebfac ,nil ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_gfeg *Creator )CreateTableOfContents (genTOCFunc func (_fcdgg *TOC )error ){_gfeg ._eaeb =genTOCFunc ;};

// AddHighlightedText adds a new highlighted text to the paragraph.
func (_fcbd *StyledParagraph )AddHighlightedText (text string ,color Color ,alpha float64 )*TextChunk {_cgbe :=NewTextChunk (text ,_fcbd ._dgaag );_cgbe .Highlight (color ,alpha );return _fcbd .appendChunk (_cgbe );};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_dfeda *Image )ScaleToWidth (w float64 ){_cbge :=_dfeda ._dfbd /_dfeda ._dgega ;_dfeda ._dgega =w ;_dfeda ._dfbd =w *_cbge ;};

// SetMarkedContentID sets marked content ID.
func (_gbdd *Invoice )SetMarkedContentID (id int64 ){};type cmykColor struct{_dbg ,_dcg ,_acag ,_fgae float64 };

// Context returns the current drawing context.
func (_acbfg *Creator )Context ()DrawContext {return _acbfg ._fcba };

// SetFillOpacity sets the fill opacity.
func (_dbec *PolyBezierCurve )SetFillOpacity (opacity float64 ){_dbec ._gbcea =opacity };

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_caab *Ellipse )SetPositioning (position Positioning ){_caab ._gfgfb =position };

// AddTag adds a tag to the division.
func (_fbfad *Division )AddTag (rootKObj *_gf .KDict ){if _fbfad ._febd ==nil {_fbfad ._febd =_gf .NewStructureTagInfo ();_fbfad ._febd .StructureType =_gf .StructureTypeDivision ;};_fbfad ._febd .ApplyTag =true ;_fbfad ._febd .ParentKObj =rootKObj ;_fbfad ._febd .ComponentKObj =_gf .NewKDictionary ();
_fbfad ._febd .ComponentKObj .S =_cd .MakeName (string (_fbfad ._febd .StructureType ));_fbfad ._febd .ParentKObj .AddKChild (_fbfad ._febd .ComponentKObj );};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_eace *Creator )SetPageSize (size PageSize ){_eace ._bea =size ;_eace ._gaa =size [0];_eace ._dag =size [1];_cgfe :=0.1*_eace ._gaa ;_eace ._feeg .Left =_cgfe ;_eace ._feeg .Right =_cgfe ;_eace ._feeg .Top =_cgfe ;_eace ._feeg .Bottom =_cgfe ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);
ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// Command is a representation of an SVG path command and its parameters.
type Command struct{Symbol string ;Params []float64 ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_afe *Block )Draw (d Drawable )error {_acd :=DrawContext {};_acd .Width =_afe ._ddf ;_acd .Height =_afe ._geb ;_acd .PageWidth =_afe ._ddf ;_acd .PageHeight =_afe ._geb ;_acd .X =0;_acd .Y =0;_ade ,_ ,_fcc :=d .GeneratePageBlocks (_acd );if _fcc !=nil {return _fcc ;
};if len (_ade )!=1{return ErrContentNotFit ;};for _ ,_gb :=range _ade {if _bdc :=_afe .mergeBlocks (_gb );_bdc !=nil {return _bdc ;};};return nil ;};func (_ggbf *Invoice )drawSection (_dgafc ,_bbadg string )[]*StyledParagraph {var _cacgb []*StyledParagraph ;
if _dgafc !=""{_ccgfe :=_bgdc (_ggbf ._efba );_ccgfe .SetMargins (0,0,0,5);_ccgfe .Append (_dgafc );_cacgb =append (_cacgb ,_ccgfe );};if _bbadg !=""{_cdde :=_bgdc (_ggbf ._bddf );_cdde .Append (_bbadg );_cacgb =append (_cacgb ,_cdde );};return _cacgb ;
};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_dfdgf *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_efee []*Block ;_bagc =NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbbc =ctx ;_dabcc =_dfdgf ._daegc /2;);_ddfg :=_dfdgf ._gbbdg .IsRelative ();if _ddfg {_dfdgf .applyFitMode (ctx .Width );
ctx .X +=_dfdgf ._ccafa .Left +_dabcc ;ctx .Y +=_dfdgf ._ccafa .Top +_dabcc ;ctx .Width -=_dfdgf ._ccafa .Left +_dfdgf ._ccafa .Right ;ctx .Height -=_dfdgf ._ccafa .Top +_dfdgf ._ccafa .Bottom ;if _dfdgf ._ebef > ctx .Height {_efee =append (_efee ,_bagc );
_bagc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ddda :=ctx ;_ddda .Y =ctx .Margins .Top +_dfdgf ._ccafa .Top +_dabcc ;_ddda .X =ctx .Margins .Left +_dfdgf ._ccafa .Left +_dabcc ;_ddda .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dfdgf ._ccafa .Top -_dfdgf ._ccafa .Bottom ;
_ddda .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dfdgf ._ccafa .Left -_dfdgf ._ccafa .Right ;ctx =_ddda ;};}else {ctx .X =_dfdgf ._acaf ;ctx .Y =_dfdgf ._dgec ;};_egdeg :=_dd .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_dfdgf ._ebef ,Width :_dfdgf ._egdeb ,Height :_dfdgf ._ebef ,BorderRadiusTopLeft :_dfdgf ._ddfb ,BorderRadiusTopRight :_dfdgf ._ebdg ,BorderRadiusBottomLeft :_dfdgf ._afdd ,BorderRadiusBottomRight :_dfdgf ._dbaed ,Opacity :1.0};
if _dfdgf ._ececd !=nil {_egdeg .FillEnabled =true ;_efbedd :=_fbd (_dfdgf ._ececd );_adff :=_bdced (_bagc ,_efbedd ,_dfdgf ._ececd ,func ()Rectangle {return Rectangle {_acaf :_egdeg .X ,_dgec :_egdeg .Y ,_egdeb :_egdeg .Width ,_ebef :_egdeg .Height };
});if _adff !=nil {return nil ,ctx ,_adff ;};_egdeg .FillColor =_efbedd ;};if _dfdgf ._agbbe !=nil &&_dfdgf ._daegc > 0{_egdeg .BorderEnabled =true ;_egdeg .BorderColor =_fbd (_dfdgf ._agbbe );_egdeg .BorderWidth =_dfdgf ._daegc ;};_ggeed ,_ddeb :=_bagc .setOpacity (_dfdgf ._dgaab ,_dfdgf ._cgdba );
if _ddeb !=nil {return nil ,ctx ,_ddeb ;};_defbg ,_ ,_ddeb :=_egdeg .MarkedDraw (_ggeed ,_dfdgf ._febd );if _ddeb !=nil {return nil ,ctx ,_ddeb ;};if _ddeb =_bagc .addContentsByString (string (_defbg ));_ddeb !=nil {return nil ,ctx ,_ddeb ;};if _ddfg {ctx .X =_dbbc .X ;
ctx .Width =_dbbc .Width ;_dffda :=_dfdgf ._ebef +_dabcc ;ctx .Y +=_dffda +_dfdgf ._ccafa .Bottom ;ctx .Height -=_dffda ;}else {ctx =_dbbc ;};_efee =append (_efee ,_bagc );return _efee ,ctx ,nil ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_gefe *Creator )DrawFooter (drawFooterFunc func (_cafdg *Block ,_ceef FooterFunctionArgs )){_gefe ._deaa =drawFooterFunc ;};

// SetWidth sets line width.
func (_agfa *Curve )SetWidth (width float64 ){_agfa ._bfee =width };

// MoveY moves the drawing context to absolute position y.
func (_bbdg *Creator )MoveY (y float64 ){_bbdg ._fcba .Y =y };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_dafa *Creator )MoveRight (dx float64 ){_dafa ._fcba .X +=dx };func (_cbbc *Image )rotatedSize ()(float64 ,float64 ){_cgbd :=_cbbc ._dgega ;_acddc :=_cbbc ._dfbd ;_bfdea :=_cbbc ._ggedf ;if _bfdea ==0{return _cgbd ,_acddc ;};_bcegc :=_dd .Path {Points :[]_dd .Point {_dd .NewPoint (0,0).Rotate (_bfdea ),_dd .NewPoint (_cgbd ,0).Rotate (_bfdea ),_dd .NewPoint (0,_acddc ).Rotate (_bfdea ),_dd .NewPoint (_cgbd ,_acddc ).Rotate (_bfdea )}}.GetBoundingBox ();
return _bcegc .Width ,_bcegc .Height ;};func _afba (_fdceg *templateProcessor ,_ffab *templateNode )(interface{},error ){return _fdceg .parseListItem (_ffab );};func (_cfca *Table )resetColumnWidths (){_cfca ._beeaca =[]float64 {};_cbdg :=float64 (1.0)/float64 (_cfca ._daebe );
for _ecadd :=0;_ecadd < _cfca ._daebe ;_ecadd ++{_cfca ._beeaca =append (_cfca ._beeaca ,_cbdg );};};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_gadcf *Invoice )NoteHeadingStyle ()TextStyle {return _gadcf ._efba };

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_ccaf *Division )Add (d VectorDrawable )error {switch _fbef :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_fdde ,_eeggc :=_fbef .ContainerComponent (_ccaf );
if _eeggc !=nil {return _eeggc ;};_gaga ,_ccedc :=_fdde .(VectorDrawable );if !_ccedc {return _e .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_fdde );
};d =_gaga ;default:return _g .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_ccaf ._cbg =append (_ccaf ._cbg ,d );return nil ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_egfa *Grid )SetColumnWidths (widths ...float64 )error {if len (widths )!=_egfa ._daec {_ef .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_egfa ._ccaa =widths ;return nil ;};

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_adef *PageBreak )SetStructureType (structureType _gf .StructureType ){};func (_abed *Invoice )SetStructureType (structureType _gf .StructureType ){};func (_fcefgf *Table )wrapRow (_cggdc int ,_fefb DrawContext ,_beag float64 )(bool ,error ){if !_fcefgf ._afeec {return false ,nil ;
};var (_ccggb =_fcefgf ._agced [_cggdc ];_abegc =-1;_gedbc []*TableCell ;_dbaad float64 ;_begea bool ;_aeecd =make ([]float64 ,0,len (_fcefgf ._beeaca )););_fdfa :=func (_abcad *TableCell ,_dgafaa VectorDrawable ,_fggfdb bool )*TableCell {_cccde :=*_abcad ;
_cccde ._ebagf =_dgafaa ;if _fggfdb {_cccde ._efdd ++;};return &_cccde ;};_ddgb :=func (_bcbcd int ,_cgfeg VectorDrawable ){var _bcffc float64 =-1;if _cgfeg ==nil {if _fdfcg :=_aeecd [_bcbcd -_cggdc ];_fdfcg > _fefb .Height {_cgfeg =_fcefgf ._agced [_bcbcd ]._ebagf ;
_fcefgf ._agced [_bcbcd ]._ebagf =nil ;_aeecd [_bcbcd -_cggdc ]=0;_bcffc =_fdfcg ;};};_cgbc :=_fdfa (_fcefgf ._agced [_bcbcd ],_cgfeg ,true );_gedbc =append (_gedbc ,_cgbc );if _bcffc < 0{_bcffc =_cgbc .height (_fefb .Width );};if _bcffc > _dbaad {_dbaad =_bcffc ;
};};for _feac :=_cggdc ;_feac < len (_fcefgf ._agced );_feac ++{_gabde :=_fcefgf ._agced [_feac ];if _ccggb ._efdd !=_gabde ._efdd {_abegc =_feac ;break ;};_fefb .Width =_gabde .width (_fcefgf ._beeaca ,_beag );_gegc :=_gabde .height (_fefb .Width );var _bbeaf VectorDrawable ;
switch _gdgaf :=_gabde ._ebagf .(type ){case *StyledParagraph :if _gegc > _fefb .Height {_bbbgd :=_fefb ;_bbbgd .Height =_fb .Floor (_fefb .Height -_gdgaf ._dbge .Top -_gdgaf ._dbge .Bottom -0.5*_gdgaf .getTextHeight ());_ecdb ,_bgfbg ,_afdde :=_gdgaf .split (_bbbgd );
if _afdde !=nil {return false ,_afdde ;};if _ecdb !=nil &&_bgfbg !=nil {_gdgaf =_ecdb ;_gabde =_fdfa (_gabde ,_ecdb ,false );_fcefgf ._agced [_feac ]=_gabde ;_bbeaf =_bgfbg ;_begea =true ;};_gegc =_gabde .height (_fefb .Width );};case *Division :if _gegc > _fefb .Height {_accdd :=_fefb ;
_accdd .Height =_fb .Floor (_fefb .Height -_gdgaf ._ffd .Top -_gdgaf ._ffd .Bottom );_ddegd ,_baagg :=_gdgaf .split (_accdd );if _ddegd !=nil &&_baagg !=nil {_gdgaf =_ddegd ;_gabde =_fdfa (_gabde ,_ddegd ,false );_fcefgf ._agced [_feac ]=_gabde ;_bbeaf =_baagg ;
_begea =true ;if _ddegd ._ecfg !=nil {_ddegd ._ecfg .BorderRadiusBottomLeft =0;_ddegd ._ecfg .BorderRadiusBottomRight =0;};if _baagg ._ecfg !=nil {_baagg ._ecfg .BorderRadiusTopLeft =0;_baagg ._ecfg .BorderRadiusTopRight =0;};_gegc =_gabde .height (_fefb .Width );
};};case *List :if _gegc > _fefb .Height {_eecc :=_fefb ;_eecc .Height =_fb .Floor (_fefb .Height -_gdgaf ._caba .Vertical ());_egbffa ,_accba :=_gdgaf .split (_eecc );if _egbffa !=nil {_gdgaf =_egbffa ;_gabde =_fdfa (_gabde ,_egbffa ,false );_fcefgf ._agced [_feac ]=_gabde ;
};if _accba !=nil {_bbeaf =_accba ;_begea =true ;};_gegc =_gabde .height (_fefb .Width );};};_aeecd =append (_aeecd ,_gegc );if _begea {if _gedbc ==nil {_gedbc =make ([]*TableCell ,0,len (_fcefgf ._beeaca ));for _begacb :=_cggdc ;_begacb < _feac ;_begacb ++{_ddgb (_begacb ,nil );
};};_ddgb (_feac ,_bbeaf );};};var _ceefc float64 ;for _ ,_eaaeb :=range _aeecd {if _eaaeb > _ceefc {_ceefc =_eaaeb ;};};if _begea &&_ceefc < _fefb .Height {if _abegc < 0{_abegc =len (_fcefgf ._agced );};_bfgg :=_fcefgf ._agced [_abegc -1]._efdd +_fcefgf ._agced [_abegc -1]._addgb -1;
for _ddbaa :=_abegc ;_ddbaa < len (_fcefgf ._agced );_ddbaa ++{_fcefgf ._agced [_ddbaa ]._efdd ++;};_fcefgf ._agced =append (_fcefgf ._agced [:_abegc ],append (_gedbc ,_fcefgf ._agced [_abegc :]...)...);_fcefgf ._acbg =append (_fcefgf ._acbg [:_bfgg ],append ([]float64 {_dbaad },_fcefgf ._acbg [_bfgg :]...)...);
if len (_fcefgf ._acbg )> _fcefgf ._ebdeb {_fcefgf ._ebdeb =len (_fcefgf ._acbg );};_fcefgf ._acbg [_ccggb ._efdd +_ccggb ._addgb -2]=_ceefc ;};return _begea ,nil ;};var _ggbad commands ;func (_gffad *templateProcessor )parseChapterHeading (_dcbae *templateNode )(interface{},error ){if _dcbae ._ccbde ==nil {_gffad .nodeLogError (_dcbae ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_gdac ;};_baagb ,_bebfc :=_dcbae ._ccbde ._efefd .(*Chapter );if !_bebfc {_gffad .nodeLogError (_dcbae ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_dcbae ._ccbde ._efefd );
return nil ,_gdac ;};_ddfbf :=_baagb .GetHeading ();if _ ,_gdeac :=_gffad .parseParagraph (_dcbae ,_ddfbf );_gdeac !=nil {return nil ,_gdeac ;};return _ddfbf ,nil ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_deeea *Invoice )SetAddressHeadingStyle (style TextStyle ){_deeea ._faaca =style };func _ffbf ()*Division {return &Division {_gffa :true ,taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeDivision }};};func (_agdbd *Table )wrapContent (_ecdeg DrawContext )error {if _agdbd ._afeec {return nil ;
};_agdbd .sortCells ();_adbb :=func (_gcgb *TableCell ,_daega int ,_dgded int ,_bagcc int )(_fgfg int ){if _bagcc < 1{return -1;};_ggdea :=0;for _fcbaa :=_dgded +1;_fcbaa < len (_agdbd ._agced )-1;_fcbaa ++{_fdaae :=_agdbd ._agced [_fcbaa ];if _fdaae ._efdd ==_bagcc &&_ggdea !=_dgded {_ggdea =_fcbaa ;
if (_fdaae ._facac < _gcgb ._facac &&_agdbd ._daebe > _fdaae ._facac )||_gcgb ._facac < _agdbd ._daebe {continue ;};break ;};};_fbcdd :=float64 (0.0);for _fgead :=0;_fgead < _gcgb ._addgb ;_fgead ++{_fbcdd +=_agdbd ._acbg [_gcgb ._efdd +_fgead -1];};_ggcad :=_gcgb .width (_agdbd ._beeaca ,_ecdeg .Width );
var (_edda VectorDrawable ;_fefae =false ;);switch _ceced :=_gcgb ._ebagf .(type ){case *StyledParagraph :_dffab :=_ecdeg ;_dffab .Height =_fb .Floor (_fbcdd -_ceced ._dbge .Top -_ceced ._dbge .Bottom -0.5*_ceced .getTextHeight ());_dffab .Width =_ggcad ;
_fagfd ,_abfee ,_eecef :=_ceced .split (_dffab );if _eecef !=nil {_ef .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_eecef .Error ());
};if _fagfd !=nil &&_abfee !=nil {_agdbd ._agced [_dgded ]._ebagf =_fagfd ;_edda =_abfee ;_fefae =true ;};};_agdbd ._agced [_dgded ]._addgb =_gcgb ._addgb ;_ecdeg .Height =_ecdeg .PageHeight -_ecdeg .Margins .Top -_ecdeg .Margins .Bottom ;_abbea :=_gcgb .cloneProps (nil );
if _fefae {_abbea ._ebagf =_edda ;};_abbea ._addgb =_daega ;_abbea ._efdd =_bagcc +1;_abbea ._facac =_gcgb ._facac ;if _abbea ._efdd +_abbea ._addgb -1> _agdbd ._ebdeb {for _acdgc :=_agdbd ._ebdeb ;_acdgc < _abbea ._efdd +_abbea ._addgb -1;_acdgc ++{_agdbd ._ebdeb ++;
_agdbd ._acbg =append (_agdbd ._acbg ,_agdbd ._ccfbe );};};_agdbd ._agced =append (_agdbd ._agced [:_ggdea +1],append ([]*TableCell {_abbea },_agdbd ._agced [_ggdea +1:]...)...);return _ggdea +1;};_ebaba :=func (_eebed *TableCell ,_gdgcb int ,_cbgdbe int ,_fbcb float64 )(_bbbbd int ){_bfcc :=_eebed .width (_agdbd ._beeaca ,_ecdeg .Width );
_dacgd :=_fbcb ;_caeg :=1;_gegaa :=_ecdeg .Height ;if _gegaa > 0{for _dacgd > _gegaa {_dacgd -=_ecdeg .Height ;_gegaa =_ecdeg .PageHeight -_ecdeg .Margins .Top -_ecdeg .Margins .Bottom ;_caeg ++;};};var (_bbbaf VectorDrawable ;_geffc =false ;);switch _egdcff :=_eebed ._ebagf .(type ){case *StyledParagraph :_fcegaf :=_ecdeg ;
_fcegaf .Height =_fb .Floor (_ecdeg .Height -_egdcff ._dbge .Top -_egdcff ._dbge .Bottom -0.5*_egdcff .getTextHeight ());_fcegaf .Width =_bfcc ;_bgfc ,_acced ,_cbdgf :=_egdcff .split (_fcegaf );if _cbdgf !=nil {_ef .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_cbdgf .Error ());
};if _bgfc !=nil &&_acced !=nil {_agdbd ._agced [_gdgcb ]._ebagf =_bgfc ;_bbbaf =_acced ;_geffc =true ;};};if _caeg < 2{return -1;};if _agdbd ._agced [_gdgcb ]._efdd +_caeg -1> _agdbd ._ebdeb {for _acgdg :=0;_acgdg < _caeg ;_acgdg ++{_agdbd ._ebdeb ++;
_agdbd ._acbg =append (_agdbd ._acbg ,_agdbd ._ccfbe );};};_efbgeg :=_fbcb /float64 (_caeg );for _ecdbb :=0;_ecdbb < _caeg ;_ecdbb ++{_agdbd ._acbg [_cbgdbe +_ecdbb -1]=_efbgeg ;};_ecdeg .Height =_ecdeg .PageHeight -_ecdeg .Margins .Top -_ecdeg .Margins .Bottom ;
_deeef :=_eebed .cloneProps (nil );if _geffc {_deeef ._ebagf =_bbbaf ;};_deeef ._addgb =1;_deeef ._efdd =_cbgdbe +_caeg -1;_deeef ._facac =_eebed ._facac ;_agdbd ._agced =append (_agdbd ._agced ,_deeef );return len (_agdbd ._agced );};_gbcag :=1;_cgebd :=-1;
for _efffce :=0;_efffce < len (_agdbd ._agced );_efffce ++{_geagg :=_agdbd ._agced [_efffce ];if _cgebd ==_efffce {_gbcag =_geagg ._efdd ;};if _geagg ._addgb < 2{if _bfdgc :=_agdbd ._acbg [_geagg ._efdd -1];_bfdgc > _ecdeg .Height {_cgebd =_ebaba (_geagg ,_efffce ,_geagg ._efdd ,_bfdgc );
continue ;};continue ;};_acba :=float64 (0);for _ebbfe :=0;_ebbfe < _geagg ._addgb ;_ebbfe ++{_acba +=_agdbd ._acbg [_geagg ._efdd +_ebbfe -1];};_fccfbe :=float64 (0);for _degf :=_gbcag -1;_degf < _geagg ._efdd -1;_degf ++{_fccfbe +=_agdbd ._acbg [_degf ];
};if _acba <=(_ecdeg .Height -_fccfbe ){continue ;};_fddcg :=float64 (0.0);_cfdce :=_geagg ._addgb ;_ccfg :=-1;_eebegb :=1;for _gdbdg :=1;_gdbdg <=_geagg ._addgb ;_gdbdg ++{if (_fddcg +_agdbd ._acbg [_geagg ._efdd +_gdbdg -2])> (_ecdeg .Height -_fccfbe ){_eebegb --;
break ;};_ccfg =_geagg ._efdd +_gdbdg -1;_cfdce =_geagg ._addgb -_gdbdg ;_fddcg +=_agdbd ._acbg [_geagg ._efdd +_gdbdg -2];_eebegb ++;};if _geagg ._addgb ==_cfdce {_ecdeg .Height =_ecdeg .PageHeight -_ecdeg .Margins .Top -_ecdeg .Margins .Bottom ;_gbcag =_geagg ._efdd ;
_efffce --;continue ;};if _cfdce > 0&&_geagg ._addgb > _eebegb {_geagg ._addgb =_eebegb ;_cgebd =_adbb (_geagg ,_cfdce ,_efffce ,_ccfg );if _efffce +1==_cgebd {_efffce --;};};_gbcag =_geagg ._efdd ;};_agdbd .sortCells ();return nil ;};func _bfdff (_ebbe int )*Grid {_bacg :=&Grid {_daec :_ebbe ,_gegag :10.0,_ccaa :[]float64 {}};
_bacg ._gage =_gf .StructureTypeTable ;_bacg .resetColumnWidths ();return _bacg ;};

// AddTag adds the table tag for Grid to the root K object.
func (_ggca *Grid )AddTag (rootKObj *_gf .KDict ){if rootKObj ==nil {_ef .Log .Debug ("\u0054\u0061\u0062\u006ce\u003a\u0020\u0041\u0064\u0064\u0054\u0061\u0067\u0020c\u0061\u006c\u006c\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u0069\u006c\u0020\u0072\u006f\u006ft\u004b\u004f\u0062\u006a\u002c \u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0074\u0061\u0067\u0067\u0069\u006e\u0067\u002e");
return ;};if _ggca ._febd ==nil {_ggca ._febd =_gf .NewStructureTagInfo ();_ggca ._febd .StructureType =_gf .StructureTypeTable ;};_ggca ._febd .ApplyTag =true ;_ggca ._febd .ParentKObj =rootKObj ;_ggca ._febd .ComponentKObj =_gf .NewKDictionary ();_ggca ._febd .ComponentKObj .S =_cd .MakeName (string (_ggca ._febd .StructureType ));
_ggca ._febd .ParentKObj .AddKChild (_ggca ._febd .ComponentKObj );};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_gacgc *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_gacgc ._dagce =alignment };func (_bcc *Block )drawToPage (_be *_gf .PdfPage )error {_abd :=&_ebf .ContentStreamOperations {};if _be .Resources ==nil {_be .Resources =_gf .NewPdfPageResources ();
};_daa :=_feee (_abd ,_be .Resources ,_bcc ._bac ,_bcc ._ebe );if _daa !=nil {return _daa ;};if _daa =_cge (_bcc ._ebe ,_be .Resources );_daa !=nil {return _daa ;};if _daa =_be .AppendContentBytes (_abd .Bytes (),true );_daa !=nil {return _daa ;};for _ ,_bfdf :=range _bcc ._geg {_be .AddAnnotation (_bfdf );
};return nil ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_gedgb *TableCell )SetBorderLineStyle (style _dd .LineStyle ){_gedgb ._decca =style };

// Height returns the height of the graphic svg.
func (_dbcg *GraphicSVG )Height ()float64 {return _dbcg ._aagdf .Height };func _dbagb (_dcad string )(*Path ,error ){_ggbad =_gcgfc ();_ddgge ,_ebdce :=_adabe (_gfdbc (_dcad ));if _ebdce !=nil {return nil ,_ebdce ;};return _ebfe (_ddgge ),nil ;};func _adaef (_bgdgg *templateProcessor ,_dbcbb *templateNode )(interface{},error ){return _bgdgg .parseBackground (_dbcbb );
};

// SetMargins sets the Grid's left, right, top, bottom margins.
func (_bdfa *Grid )SetMargins (left ,right ,top ,bottom float64 ){_bdfa ._fabef .Left =left ;_bdfa ._fabef .Right =right ;_bdfa ._fabef .Top =top ;_bdfa ._fabef .Bottom =bottom ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_egdcc *Ellipse )BorderOpacity ()float64 {return _egdcc ._eadb };type taggedDrawable struct{_gage _gf .StructureType ;_febd *_gf .StructureTagInfo ;};

// Decode decodes the child elements of element.
func (_bfc *GraphicSVGElement )Decode (decoder *_ec .Decoder )error {for {_cfgg ,_eeac :=decoder .Token ();if _cfgg ==nil &&_eeac ==_fd .EOF {break ;};if _eeac !=nil {return _eeac ;};switch _dcca :=_cfgg .(type ){case _ec .StartElement :_gbbc :=_gfcf (_dcca );
_ecada :=_gbbc .Decode (decoder );if _ecada !=nil {return _ecada ;};_bfc .Children =append (_bfc .Children ,_gbbc );case _ec .CharData :_cgdb :=_b .TrimSpace (string (_dcca ));if _cgdb !=""{_bfc .Content =string (_dcca );};case _ec .EndElement :if _dcca .Name .Local ==_bfc .Name {return nil ;
};};};return nil ;};func (_ddcd *List )split (_bbgb DrawContext )(_gdge ,_egeda *List ){var (_cdec float64 ;_ddge ,_eeef []*listItem ;);_gfdb :=_bbgb .Width -_ddcd ._caba .Horizontal ()-_ddcd ._eafe -_ddcd .markerWidth ();_edbfc :=_ddcd .markerWidth ();
for _aaeb ,_gcbcce :=range _ddcd ._agec {_gaca :=_gcbcce .ctxHeight (_gfdb );_cdec +=_gaca ;if _cdec <=_bbgb .Height {_ddge =append (_ddge ,_gcbcce );}else {switch _egeca :=_gcbcce ._cceec .(type ){case *List :_fgbf :=_bbgb ;_fgbf .Height =_fb .Floor (_gaca -(_cdec -_bbgb .Height ));
_gdbgb ,_gdaf :=_egeca .split (_fgbf );if _gdbgb !=nil {_ebcb :=_fafa ();_ebcb ._fdab =_gcbcce ._fdab ;_ebcb ._cceec =_gdbgb ;_ddge =append (_ddge ,_ebcb );};if _gdaf !=nil {_efecg :=_egeca ._eaeba .Style .FontSize ;_fgec ,_bfbd :=_egeca ._eaeba .Style .Font .GetRuneMetrics (' ');
if _bfbd {_efecg =_egeca ._eaeba .Style .FontSize *_fgec .Wx *_egeca ._eaeba .Style .horizontalScale ()/1000.0;};_dcab :=_b .Repeat ("\u0020",int (_edbfc /_efecg ));_dbbf :=_fafa ();_dbbf ._fdab =*NewTextChunk (_dcab ,_egeca ._eaeba .Style );_dbbf ._cceec =_gdaf ;
_eeef =append (_eeef ,_dbbf );_eeef =append (_eeef ,_ddcd ._agec [_aaeb +1:]...);};default:_eeef =_ddcd ._agec [_aaeb :];};if len (_eeef )> 0{break ;};};};if len (_ddge )> 0{_gdge =_aedfg (_ddcd ._gcace );*_gdge =*_ddcd ;_gdge ._agec =_ddge ;};if len (_eeef )> 0{_egeda =_aedfg (_ddcd ._gcace );
*_egeda =*_ddcd ;_egeda ._agec =_eeef ;};return _gdge ,_egeda ;};const (_gfga =0.72;_ggba =28.3464;_fecf =_ggba /10;_bdfb =0.551784;_fafg =96;_cff =16.0;);func (_fdfg *Invoice )setCellBorder (_abaa *TableCell ,_bfdg *InvoiceCell ){for _ ,_agfae :=range _bfdg .BorderSides {_abaa .SetBorder (_agfae ,CellBorderStyleSingle ,_bfdg .BorderWidth );
};_abaa .SetBorderColor (_bfdg .BorderColor );};func (_cefff *commands )isCommand (_ffbce string )bool {for _ ,_daad :=range _cefff ._eedfg {if _b .ToLower (_ffbce )==_daad {return true ;};};return false ;};func _afae (_baefa float64 ,_ddbd float64 ,_ecaag float64 ,_cgade float64 ,_bdaf []*ColorPoint )*RadialShading {return &RadialShading {_acad :&shading {_egdad :ColorWhite ,_fgad :false ,_defcc :[]bool {false ,false },_fcefg :_bdaf },_bfcd :_baefa ,_bffce :_ddbd ,_abega :_ecaag ,_gccb :_cgade ,_debd :AnchorCenter };
};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_egdb *Invoice )Terms ()(string ,string ){return _egdb ._cbcac [0],_egdb ._cbcac [1]};

// AddTag adds the table row tag for Grid to the root K object.
func (_eaab *GridRow )AddTag (rootKObj *_gf .KDict ){if rootKObj ==nil {_ef .Log .Debug ("\u0054\u0061\u0062\u006ce\u003a\u0020\u0041\u0064\u0064\u0054\u0061\u0067\u0020c\u0061\u006c\u006c\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u0069\u006c\u0020\u0072\u006f\u006ft\u004b\u004f\u0062\u006a\u002c \u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0074\u0061\u0067\u0067\u0069\u006e\u0067\u002e");
return ;};if _eaab ._baab ==nil {_eaab ._baab =_gf .NewStructureTagInfo ();_eaab ._baab .StructureType =_gf .StructureTypeTableRow ;};_eaab ._baab .ParentKObj =rootKObj ;_eaab ._baab .ComponentKObj =_gf .NewKDictionary ();_eaab ._baab .ComponentKObj .S =_cd .MakeName (string (_eaab ._baab .StructureType ));
_eaab ._baab .ParentKObj .AddKChild (_eaab ._baab .ComponentKObj );};

// GeneratePageBlocks draws the curve onto page blocks.
func (_acca *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eecf :=_ebf .NewContentCreator ();if _acca ._febd !=nil {_eecf .Add_BDC (*_cd .MakeName (string (_acca ._febd .StructureType )),map[string ]_cd .PdfObject {"\u004d\u0043\u0049\u0044":_cd .MakeInteger (_acca ._febd .Mcid )});
};_eecf .Add_q ().Add_w (_acca ._bfee ).SetStrokingColor (_fbd (_acca ._bbbb )).Add_m (_acca ._bgb ,ctx .PageHeight -_acca ._fabd ).Add_v (_acca ._gbfe ,ctx .PageHeight -_acca ._gfda ,_acca ._eeec ,ctx .PageHeight -_acca ._ebeb ).Add_S ().Add_Q ();if _acca ._febd !=nil {_eecf .Add_EMC ();
};_dagc :=_efd .addContentsByString (_eecf .String ());if _dagc !=nil {return nil ,ctx ,_dagc ;};return []*Block {_efd },ctx ,nil ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_gf .PdfPage )(*Block ,error ){_gc :=&Block {};_ff ,_eg :=page .GetAllContentStreams ();if _eg !=nil {return nil ,_eg ;};_adb :=_ebf .NewContentStreamParser (_ff );_bf ,_eg :=_adb .Parse ();if _eg !=nil {return nil ,_eg ;};
_bf .WrapIfNeeded ();_gc ._bac =_bf ;if page .Resources !=nil {_gc ._ebe =page .Resources ;}else {_gc ._ebe =_gf .NewPdfPageResources ();};_af ,_eg :=page .GetMediaBox ();if _eg !=nil {return nil ,_eg ;};if _af .Llx !=0||_af .Lly !=0{_gc .translate (-_af .Llx ,_af .Lly );
};_gc ._ddf =_af .Urx -_af .Llx ;_gc ._geb =_af .Ury -_af .Lly ;if page .Rotate !=nil {_gc ._aag =-float64 (*page .Rotate );};return _gc ,nil ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_becf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _becf ._efcb [0],_becf ._efcb [1]};

// SetSubtotal sets the subtotal of the invoice.
func (_bcffa *Invoice )SetSubtotal (value string ){_bcffa ._efcb [1].Value =value };

// SetBorderWidth sets the border width of the ellipse.
func (_agdd *Ellipse )SetBorderWidth (bw float64 ){_agdd ._dcag =bw };

// Height returns the total height of all rows.
func (_dcdc *Table )Height ()float64 {_egfgb :=float64 (0.0);for _ ,_cdfcb :=range _dcdc ._acbg {_egfgb +=_cdfcb ;};return _egfgb ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_acad *shading ;_eggbc *_gf .PdfRectangle ;_debd AnchorPoint ;_bfcd float64 ;_bffce float64 ;_abega float64 ;_gccb float64 ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ebgba *TOC )SetLineStyle (style TextStyle ){_ebgba .SetLineNumberStyle (style );_ebgba .SetLineTitleStyle (style );_ebgba .SetLineSeparatorStyle (style );_ebgba .SetLinePageStyle (style );};

// CurRow returns the currently active cell's row number.
func (_aggd *Table )CurRow ()int {_aebe :=(_aggd ._facb -1)/_aggd ._daebe +1;return _aebe };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{taggedDrawable ;_bbcbd *StyledParagraph ;_efbef []*TOCLine ;_bgbaa TextStyle ;_bbeae TextStyle ;_cbdff TextStyle ;_gagad TextStyle ;_cfadf string ;_dcae float64 ;_cdefd Margins ;_fdffe Positioning ;_aafde TextStyle ;_befbd bool ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_adfe *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _adfe ._ccaab [0],_adfe ._ccaab [1]};type listItem struct{_cceec VectorDrawable ;_fdab TextChunk ;};

// SetFillColor sets the fill color of the rectangle.
func (_fbcac *Rectangle )SetFillColor (col Color ){_fbcac ._ececd =col };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_adba *Block )SetMargins (left ,right ,top ,bottom float64 ){_adba ._gfc .Left =left ;_adba ._gfc .Right =right ;_adba ._gfc .Top =top ;_adba ._gfc .Bottom =bottom ;};

// SetSideBorderColor sets the cell's side border color.
func (_afeg *GridCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_afeg ._eeff =col ;_afeg ._ggbe =col ;_afeg ._fceb =col ;_afeg ._bdgae =col ;case CellBorderSideTop :_afeg ._eeff =col ;case CellBorderSideBottom :_afeg ._ggbe =col ;
case CellBorderSideLeft :_afeg ._fceb =col ;case CellBorderSideRight :_afeg ._bdgae =col ;};};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_edac *LinearShading )SetAngle (angle float64 ){_edac ._aecga =angle };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_bgba *PageBreak )SetMarkedContentID (id int64 ){};

// SetHeight sets the Image's document height to specified h.
func (_acde *Image )SetHeight (h float64 ){_acde ._dfbd =h };const (PositionRelative Positioning =iota ;PositionAbsolute ;);func (_cdda *Invoice )drawInformation ()*Table {_bgdag :=_aggeg (2);_gccfe :=append ([][2]*InvoiceCell {_cdda ._gfcd ,_cdda ._bdgb ,_cdda ._ccaab },_cdda ._ceacc ...);
for _ ,_cegd :=range _gccfe {_dcbed ,_degbf :=_cegd [0],_cegd [1];if _degbf .Value ==""{continue ;};_cegfe :=_bgdag .NewCell ();_cegfe .SetBackgroundColor (_dcbed .BackgroundColor );_cdda .setCellBorder (_cegfe ,_dcbed );_gffgb :=_bgdc (_dcbed .TextStyle );
_gffgb .Append (_dcbed .Value );_gffgb .SetMargins (0,0,2,1);_cegfe .SetContent (_gffgb );_cegfe =_bgdag .NewCell ();_cegfe .SetBackgroundColor (_degbf .BackgroundColor );_cdda .setCellBorder (_cegfe ,_degbf );_gffgb =_bgdc (_degbf .TextStyle );_gffgb .Append (_degbf .Value );
_gffgb .SetMargins (0,0,2,1);_cegfe .SetContent (_gffgb );};return _bgdag ;};func (_agfaa *templateProcessor )parseTextRenderingModeAttr (_cbabac ,_cgbae string )TextRenderingMode {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cbabac ,_cgbae );
_eebdb :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_cgbae ];
return _eebdb ;};func (_aacac *GraphicSVGElement )drawPolygon (_cecd *_ebf .ContentCreator ,_egcad *_gf .PdfPageResources ){_cecd .Add_q ();_aacac .Style .toContentStream (_cecd ,_egcad ,_aacac );_ecadb ,_cafb :=_adgac (_aacac .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);
if _cafb !=nil {_ef .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_cafb );
return ;};if len (_ecadb )%2> 0{_ef .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _fddg :=0;_fddg < len (_ecadb );{if _fddg ==0{_cecd .Add_m (_ecadb [_fddg ]*_aacac ._bcae ,_ecadb [_fddg +1]*_aacac ._bcae );}else {_cecd .Add_l (_ecadb [_fddg ]*_aacac ._bcae ,_ecadb [_fddg +1]*_aacac ._bcae );};_fddg +=2;};_cecd .Add_l (_ecadb [0]*_aacac ._bcae ,_ecadb [1]*_aacac ._bcae );
_aacac .Style .fillStroke (_cecd );_cecd .Add_h ();_cecd .Add_Q ();};

// NewImageFromFile creates an Image from a file.
func (_dgae *Creator )NewImageFromFile (path string )(*Image ,error ){return _ecabc (path )};const (DropCapsFirstCharacter DropCapsScope =iota ;DropCapsFirstWord ;);

// SetEnableWrap sets the line wrapping enabled flag.
func (_afde *Paragraph )SetEnableWrap (enableWrap bool ){_afde ._daabg =enableWrap ;_afde ._fefe =false ;};func (_ggacf *Table )sortCells (){_ebc .Slice (_ggacf ._agced ,func (_bcdbcc ,_efded int )bool {_aedef :=_ggacf ._agced [_bcdbcc ]._efdd ;_efbgc :=_ggacf ._agced [_efded ]._efdd ;
if _aedef < _efbgc {return true ;};if _aedef > _efbgc {return false ;};return _ggacf ._agced [_bcdbcc ]._facac < _ggacf ._agced [_efded ]._facac ;});};

// GridCell defines a cell which can contain a Drawable as content.
type GridCell struct{taggedDrawable ;_gcbd Color ;_ccfb float64 ;_gcff _dd .LineStyle ;_beddg CellBorderStyle ;_fceb Color ;_ffegf float64 ;_abeb CellBorderStyle ;_ggbe Color ;_gafdd float64 ;_cgcb CellBorderStyle ;_bdgae Color ;_caeea float64 ;_cddd CellBorderStyle ;
_eeff Color ;_cbde float64 ;_bcfd VectorDrawable ;_cbbe ,_ecabf int ;_fagfe int ;_cabd int ;_cffd CellHorizontalAlignment ;_efbg CellVerticalAlignment ;_bcbg float64 ;};

// Lazy gets the lazy mode for the image.
func (_fddf *Image )Lazy ()bool {return _fddf ._cbgdb };func _cfbcf (_dfbfc string )(*GraphicSVG ,error ){_fgdgf ,_bgeaa :=ParseFromSVGFile (_dfbfc );if _bgeaa !=nil {return nil ,_bgeaa ;};return _ggab (_fgdgf );};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_eegf *Line )SetFitMode (fitMode FitMode ){_eegf ._gcfg =fitMode };

// SetMargins sets the Paragraph's margins.
func (_gebaf *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_gebaf ._ecdf .Left =left ;_gebaf ._ecdf .Right =right ;_gebaf ._ecdf .Top =top ;_gebaf ._ecdf .Bottom =bottom ;};

// SetLineHeight sets the line height (1.0 default).
func (_fgebb *Paragraph )SetLineHeight (lineheight float64 ){_fgebb ._eaag =lineheight };

// CreateFrontPage sets a function to generate a front Page.
func (_dbc *Creator )CreateFrontPage (genFrontPageFunc func (_gbcd FrontpageFunctionArgs )){_dbc ._agdb =genFrontPageFunc ;};

// SetBorderColor sets the border color for the path.
func (_ffgbe *FilledCurve )SetBorderColor (color Color ){_ffgbe ._fgcb =color };

// Rows returns the total number of rows the table has.
func (_fgeac *Table )Rows ()int {return _fgeac ._ebdeb };func _baec (_efgge []_dd .Point )*Polyline {return &Polyline {_fbcfa :&_dd .Polyline {Points :_efgge ,LineColor :_gf .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_fdffb :1.0};};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_aaegb *Image )SetFitMode (fitMode FitMode ){_aaegb ._aeeb =fitMode };

// SetWidthRight sets border width for right.
func (_fgb *border )SetWidthRight (bw float64 ){_fgb ._gebg =bw };

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_ffba *Division )SetPadding (left ,right ,top ,bottom float64 ){_ffba ._aeg .Left =left ;_ffba ._aeg .Right =right ;_ffba ._aeg .Top =top ;_ffba ._aeg .Bottom =bottom ;};

// SetNotes sets the notes section of the invoice.
func (_ggbd *Invoice )SetNotes (title ,content string ){_ggbd ._gebe =[2]string {title ,content }};type rgbColor struct{_aaba ,_caef ,_dgc float64 };

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// SetFillColor sets background color for border.
func (_cadb *border )SetFillColor (col Color ){_cadb ._gcd =col };

// SkipCells skips over a specified number of cells in the table.
func (_ffbea *Table )SkipCells (num int ){if num < 0{_ef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _cdcae :=0;_cdcae < num ;_cdcae ++{_ffbea .NewCell ();};};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;func _gccfd (_gbdc string )(*_gf .PdfFont ,error ){_gccg ,_ddec :=map[string ]_gf .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_gf .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_gf .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_gf .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_gf .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_gf .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_gf .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_gf .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_gf .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_gf .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_gf .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_gf .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_gf .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_gf .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_gf .TimesBoldItalicName }[_gbdc ];
if !_ddec {return nil ,_e .Errorf ("\u0066\u006f\u006e\u0074\u002df\u0061\u006d\u0069\u006c\u0079\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u006c\u0069\u0073t",_gbdc );
};_baff ,_efcggc :=_gf .NewStandard14Font (_gccg );if _efcggc !=nil {return nil ,_efcggc ;};return _baff ,nil ;};var (ErrContentNotFit =_g .New ("\u0063\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);func (_deeee *templateProcessor )parseListItem (_abdbb *templateNode )(interface{},error ){if _abdbb ._ccbde ==nil {_deeee .nodeLogError (_abdbb ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_gdac ;};_cacb ,_bffd :=_abdbb ._ccbde ._efefd .(*List );if !_bffd {_deeee .nodeLogError (_abdbb ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_gdac ;};_ffada :=_fafa ();_ffada ._fdab =_cacb ._eaeba ;return _ffada ,nil ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func _afcdc (_bacea ,_edeb TextStyle )*Invoice {_beca :=&Invoice {_eebfb :"\u0049N\u0056\u004f\u0049\u0043\u0045",_cgecf :"\u002c\u0020",_agdg :_bacea ,_aaad :_edeb };
_beca ._dfce =&InvoiceAddress {Separator :_beca ._cgecf };_beca ._fegbd =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_beca ._cgecf };_ebdf :=ColorRGBFrom8bit (245,245,245);_gffbg :=ColorRGBFrom8bit (155,155,155);_beca ._cead =_edeb ;
_beca ._cead .Color =_gffbg ;_beca ._cead .FontSize =20;_beca ._afeef =_bacea ;_beca ._faaca =_edeb ;_beca ._bddf =_bacea ;_beca ._efba =_edeb ;_beca ._bggg =_beca .NewCellProps ();_beca ._bggg .BackgroundColor =_ebdf ;_beca ._bggg .TextStyle =_edeb ;_beca ._abfde =_beca .NewCellProps ();
_beca ._abfde .TextStyle =_edeb ;_beca ._abfde .BackgroundColor =_ebdf ;_beca ._abfde .BorderColor =_ebdf ;_beca ._ccbg =_beca .NewCellProps ();_beca ._ccbg .BorderColor =_ebdf ;_beca ._ccbg .BorderSides =[]CellBorderSide {CellBorderSideBottom };_beca ._ccbg .Alignment =CellHorizontalAlignmentRight ;
_beca ._dbed =_beca .NewCellProps ();_beca ._dbed .Alignment =CellHorizontalAlignmentRight ;_beca ._gfcd =[2]*InvoiceCell {_beca .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_beca ._bggg ),_beca .newCell ("",_beca ._bggg )};
_beca ._bdgb =[2]*InvoiceCell {_beca .newCell ("\u0044\u0061\u0074\u0065",_beca ._bggg ),_beca .newCell ("",_beca ._bggg )};_beca ._ccaab =[2]*InvoiceCell {_beca .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_beca ._bggg ),_beca .newCell ("",_beca ._bggg )};
_beca ._efcb =[2]*InvoiceCell {_beca .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_beca ._dbed ),_beca .newCell ("",_beca ._dbed )};_gaba :=_beca ._dbed ;_gaba .TextStyle =_edeb ;_gaba .BackgroundColor =_ebdf ;_gaba .BorderColor =_ebdf ;
_beca ._dfad =[2]*InvoiceCell {_beca .newCell ("\u0054\u006f\u0074a\u006c",_gaba ),_beca .newCell ("",_gaba )};_beca ._gebe =[2]string {"\u004e\u006f\u0074e\u0073",""};_beca ._cbcac =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_beca ._ccgf =[]*InvoiceCell {_beca .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_beca .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_beca .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_beca .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _beca ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_fffef *Invoice )SetColumns (cols []*InvoiceCell ){_fffef ._ccgf =cols };func (_bfag *GraphicSVGElement )drawRect (_faage *_ebf .ContentCreator ,_gdgfa *_gf .PdfPageResources ){_faage .Add_q ();_bfag .Style .toContentStream (_faage ,_gdgfa ,_bfag );
_fadb ,_ccagd :=_fgde (_bfag .Attributes ["\u0078"],64);if _ccagd !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_ccagd .Error ());
};_eebgc ,_ccagd :=_fgde (_bfag .Attributes ["\u0079"],64);if _ccagd !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_ccagd .Error ());
};_fcgg ,_ccagd :=_fgde (_bfag .Attributes ["\u0077\u0069\u0064t\u0068"],64);if _ccagd !=nil {_ef .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_ccagd .Error ());
};_gade ,_ccagd :=_fgde (_bfag .Attributes ["\u0068\u0065\u0069\u0067\u0068\u0074"],64);if _ccagd !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0077h\u0069\u006c\u0065 \u0070\u0061\u0072\u0073i\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_ccagd .Error ());
};_faage .Add_re (_fadb *_bfag ._bcae ,_eebgc *_bfag ._bcae ,_fcgg *_bfag ._bcae ,_gade *_bfag ._bcae );_bfag .Style .fillStroke (_faage );_faage .Add_Q ();};

// Height returns the current page height.
func (_afeb *Creator )Height ()float64 {return _afeb ._dag };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_baaabf *Image )SetWidth (w float64 ){_baaabf ._dgega =w };

// SetMarkedContentID sets marked content ID.
func (_ffa *taggedDrawable )SetMarkedContentID (mcid int64 ){if _ffa ._febd ==nil {_ffa ._febd =_gf .NewStructureTagInfo ();_ffa ._febd .StructureType =_ffa ._gage ;};_ffa ._febd .Mcid =mcid ;};

// SetColorRight sets border color for right.
func (_ddfe *border )SetColorRight (col Color ){_ddfe ._acg =col };

// Columns returns all the columns in the invoice line items table.
func (_aebfb *Invoice )Columns ()[]*InvoiceCell {return _aebfb ._ccgf };

// Style returns the style of the line.
func (_gffd *Line )Style ()_dd .LineStyle {return _gffd ._gcgff };

// BuyerAddress returns the buyer address used in the invoice template.
func (_ebge *Invoice )BuyerAddress ()*InvoiceAddress {return _ebge ._fegbd };

// Width returns the Block's width.
func (_fga *Block )Width ()float64 {return _fga ._ddf };func _bfca (_egfead *_ec .Decoder )(int ,int ){return _egfead .InputPos ()};

// String implements error interface.
func (_febde UnsupportedRuneError )Error ()string {return _febde .Message };

// SetBorderColor sets the border color.
func (_bfbea *Polygon )SetBorderColor (color Color ){_bfbea ._fcfa .BorderColor =_fbd (color )};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_afbe *RadialShading )ToPdfShadingPattern ()*_gf .PdfShadingPatternType3 {_acgg ,_bffge ,_daecg :=_afbe ._acad ._egdad .ToRGB ();_afcec :=_afbe .shadingModel ();_afcec .Background =_cd .MakeArrayFromFloats ([]float64 {_acgg ,_bffge ,_daecg });_bfea :=_gf .NewPdfShadingPatternType3 ();
_bfea .Shading =_afcec ;return _bfea ;};func _adgac (_gcffa string )([]float64 ,error ){_efdedf :=-1;var _bcdec []float64 ;_efeff :=' ';for _aaaad ,_eaaed :=range _gcffa {if !_ge .IsNumber (_eaaed )&&_eaaed !='.'&&!(_eaaed =='-'&&_efeff =='e')&&_eaaed !='e'{if _efdedf !=-1{_ccfee ,_fabeaf :=_eage (_gcffa [_efdedf :_aaaad ]);
if _fabeaf !=nil {return _bcdec ,_fabeaf ;};_bcdec =append (_bcdec ,_ccfee ...);};if _eaaed =='-'{_efdedf =_aaaad ;}else {_efdedf =-1;};}else if _efdedf ==-1{_efdedf =_aaaad ;};_efeff =_eaaed ;};if _efdedf !=-1&&_efdedf !=len (_gcffa ){_aaac ,_ccbdc :=_eage (_gcffa [_efdedf :]);
if _ccbdc !=nil {return _bcdec ,_ccbdc ;};_bcdec =append (_bcdec ,_aaac ...);};return _bcdec ,nil ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_acddg *RadialShading )SetAntiAlias (enable bool ){_acddg ._acad .SetAntiAlias (enable )};func _feee (_ea *_ebf .ContentStreamOperations ,_abf *_gf .PdfPageResources ,_gdg *_ebf .ContentStreamOperations ,_bga *_gf .PdfPageResources )error {_dda :=map[_cd .PdfObjectName ]_cd .PdfObjectName {};
_gfb :=map[_cd .PdfObjectName ]_cd .PdfObjectName {};_ecae :=map[_cd .PdfObjectName ]_cd .PdfObjectName {};_cagg :=map[_cd .PdfObjectName ]_cd .PdfObjectName {};_cec :=map[_cd .PdfObjectName ]_cd .PdfObjectName {};_ecf :=map[_cd .PdfObjectName ]_cd .PdfObjectName {};
for _ ,_fdb :=range *_gdg {switch _fdb .Operand {case "\u0044\u006f":if len (_fdb .Params )==1{if _ecaea ,_eba :=_fdb .Params [0].(*_cd .PdfObjectName );_eba {if _ ,_ega :=_dda [*_ecaea ];!_ega {var _eab _cd .PdfObjectName ;_ffbg ,_ :=_bga .GetXObjectByName (*_ecaea );
if _ffbg !=nil {_eab =*_ecaea ;for {_aedf ,_ :=_abf .GetXObjectByName (_eab );if _aedf ==nil ||_aedf ==_ffbg {break ;};_eab =*_cd .MakeName (_ggd (_eab .String ()));};};_abf .SetXObjectByName (_eab ,_ffbg );_dda [*_ecaea ]=_eab ;};_fcb :=_dda [*_ecaea ];
_fdb .Params [0]=&_fcb ;};};case "\u0054\u0066":if len (_fdb .Params )==2{if _ecag ,_fgc :=_fdb .Params [0].(*_cd .PdfObjectName );_fgc {if _ ,_fef :=_gfb [*_ecag ];!_fef {_dfa ,_bfe :=_bga .GetFontByName (*_ecag );_bfg :=*_ecag ;if _bfe &&_dfa !=nil {_bfg =_ceg (_ecag .String (),_dfa ,_abf );
};_abf .SetFontByName (_bfg ,_dfa );_gfb [*_ecag ]=_bfg ;};_dfe :=_gfb [*_ecag ];_fdb .Params [0]=&_dfe ;};};case "\u0043\u0053","\u0063\u0073":if len (_fdb .Params )==1{if _dga ,_ddgd :=_fdb .Params [0].(*_cd .PdfObjectName );_ddgd {if _ ,_cece :=_ecae [*_dga ];
!_cece {var _bdg _cd .PdfObjectName ;_gce ,_beb :=_bga .GetColorspaceByName (*_dga );if _beb {_bdg =*_dga ;for {_abfg ,_cbeg :=_abf .GetColorspaceByName (_bdg );if !_cbeg ||_gce ==_abfg {break ;};_bdg =*_cd .MakeName (_ggd (_bdg .String ()));};_abf .SetColorspaceByName (_bdg ,_gce );
_ecae [*_dga ]=_bdg ;}else {_ef .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _bgf ,_edd :=_ecae [*_dga ];_edd {_fdb .Params [0]=&_bgf ;}else {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_dga );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_fdb .Params )==1{if _cae ,_ege :=_fdb .Params [0].(*_cd .PdfObjectName );_ege {if _ ,_gdga :=_cagg [*_cae ];!_gdga {var _cgg _cd .PdfObjectName ;_adbd ,_bbg :=_bga .GetPatternByName (*_cae );
if _bbg {_cgg =*_cae ;for {_aca ,_gde :=_abf .GetPatternByName (_cgg );if !_gde ||_aca ==_adbd {break ;};_cgg =*_cd .MakeName (_ggd (_cgg .String ()));};_eee :=_abf .SetPatternByName (_cgg ,_adbd .ToPdfObject ());if _eee !=nil {return _eee ;};_cagg [*_cae ]=_cgg ;
};};if _dae ,_fca :=_cagg [*_cae ];_fca {_fdb .Params [0]=&_dae ;};};};case "\u0073\u0068":if len (_fdb .Params )==1{if _ebgd ,_dcc :=_fdb .Params [0].(*_cd .PdfObjectName );_dcc {if _ ,_edb :=_cec [*_ebgd ];!_edb {var _aad _cd .PdfObjectName ;_dcf ,_ccb :=_bga .GetShadingByName (*_ebgd );
if _ccb {_aad =*_ebgd ;for {_fcf ,_agbb :=_abf .GetShadingByName (_aad );if !_agbb ||_dcf ==_fcf {break ;};_aad =*_cd .MakeName (_ggd (_aad .String ()));};_ebd :=_abf .SetShadingByName (_aad ,_dcf .ToPdfObject ());if _ebd !=nil {_ef .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_ebd );
return _ebd ;};_cec [*_ebgd ]=_aad ;}else {_ef .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _ded ,_fad :=_cec [*_ebgd ];_fad {_fdb .Params [0]=&_ded ;}else {_ef .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ebgd );
};};};case "\u0067\u0073":if len (_fdb .Params )==1{if _cgf ,_bfed :=_fdb .Params [0].(*_cd .PdfObjectName );_bfed {if _ ,_fdbf :=_ecf [*_cgf ];!_fdbf {var _fgd _cd .PdfObjectName ;_eac ,_dbe :=_bga .GetExtGState (*_cgf );if _dbe {_fgd =*_cgf ;for {_fcag ,_bba :=_abf .GetExtGState (_fgd );
if !_bba ||_eac ==_fcag {break ;};_fgd =*_cd .MakeName (_ggd (_fgd .String ()));};};_abf .AddExtGState (_fgd ,_eac );_ecf [*_cgf ]=_fgd ;};_bde :=_ecf [*_cgf ];_fdb .Params [0]=&_bde ;};};};*_ea =append (*_ea ,_fdb );};return nil ;};

// Positioning returns the type of positioning the line is set to use.
func (_abbagb *Line )Positioning ()Positioning {return _abbagb ._fbdb };

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_gfa *Block )SetStructPageNumber (pageNumber *int64 ){};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_bgdf *shading )SetExtends (start bool ,end bool ){_bgdf ._defcc =[]bool {start ,end }};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_aeed *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_gddf :=[2]*InvoiceCell {_aeed .newCell (description ,_aeed ._bggg ),_aeed .newCell (value ,_aeed ._bggg )};_aeed ._ceacc =append (_aeed ._ceacc ,_gddf );return _gddf [0],_gddf [1];
};

// SetOpacity sets the cell's opacity in the range 0-1.
func (_dgee *TableCell )SetOpacity (opacity float64 ){_dgee ._ggcef =opacity };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_aabag *Creator )RotateDeg (angleDeg int64 )error {_ebde :=_aabag .getActivePage ();if _ebde ==nil {_ef .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _g .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_ef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _bgab int64 ;if _ebde .Rotate !=nil {_bgab =*(_ebde .Rotate );};_bgab +=angleDeg ;_ebde .Rotate =&_bgab ;return nil ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// AddSection adds a new content section at the end of the invoice.
func (_gecfb *Invoice )AddSection (title ,content string ){_gecfb ._ffbag =append (_gecfb ._ffbag ,[2]string {title ,content });};func (_gcec *Creator )wrapPageIfNeeded (_fba *_gf .PdfPage )(*_gf .PdfPage ,error ){_fbed ,_dec :=_fba .GetAllContentStreams ();
if _dec !=nil {return nil ,_dec ;};_gcac :=_ebf .NewContentStreamParser (_fbed );_aaed ,_dec :=_gcac .Parse ();if _dec !=nil {return nil ,_dec ;};if !_aaed .HasUnclosedQ (){return nil ,nil ;};_aaed .WrapIfNeeded ();_bcgda ,_dec :=_cd .MakeStream (_aaed .Bytes (),_cd .NewFlateEncoder ());
if _dec !=nil {return nil ,_dec ;};_fba .Contents =_cd .MakeArray (_bcgda );return _fba ,nil ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// BorderColor returns the border color of the ellipse.
func (_dafc *Ellipse )BorderColor ()Color {return _dafc ._cgffb };func _cafcd (_gggd *templateProcessor ,_aaebfc *templateNode )(interface{},error ){return _gggd .parseTable (_aaebfc );};

// NewColumn returns a new column for the line items invoice table.
func (_acda *Invoice )NewColumn (description string )*InvoiceCell {return _acda .newColumn (description ,CellHorizontalAlignmentLeft );};func _bbe (_daab ,_gbf ,_fgg ,_aedfb float64 )*border {_gacd :=&border {};_gacd ._ecfc =_daab ;_gacd ._agg =_gbf ;_gacd ._aef =_fgg ;
_gacd ._efe =_aedfb ;_gacd ._ced =ColorBlack ;_gacd ._bfb =ColorBlack ;_gacd ._ebcg =ColorBlack ;_gacd ._acg =ColorBlack ;_gacd ._ggc =0;_gacd ._bcd =0;_gacd ._bag =0;_gacd ._gebg =0;_gacd ._dbeg =1.0;_gacd .LineStyle =_dd .LineStyleSolid ;return _gacd ;
};

// NewList creates a new list.
func (_baf *Creator )NewList ()*List {return _aedfg (_baf .NewTextStyle ())};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_addff *Table )SetMargins (left ,right ,top ,bottom float64 ){_addff ._efdf .Left =left ;_addff ._efdf .Right =right ;_addff ._efdf .Top =top ;_addff ._efdf .Bottom =bottom ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_beae *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _dadbb float64 ;var _ccff []*StyledParagraph ;_bfab :=_beae ._febd !=nil &&_beae ._febd .ApplyTag ;for _ ,_gbabb :=range _beae ._agec {_dedbd :=_bgdc (_beae ._gcace );
_dedbd .SetEnableWrap (false );_dedbd .SetTextAlignment (TextAlignmentRight );_dedbd .Append (_gbabb ._fdab .Text ).Style =_gbabb ._fdab .Style ;_geba :=_dedbd .getTextWidth ()/1000.0/ctx .Width ;if _dadbb < _geba {_dadbb =_geba ;};_ccff =append (_ccff ,_dedbd );
};_aabf :=_aggeg (2);_aabf .SetColumnWidths (_dadbb ,1-_dadbb );_aabf .SetMargins (_beae ._caba .Left +_beae ._eafe ,_beae ._caba .Right ,_beae ._caba .Top ,_beae ._caba .Bottom );_aabf .EnableRowWrap (true );if _bfab {_aabf .SetStructPageNumber (_beae ._febd .StructPageNumber );
_aabf .AddTag (_beae ._febd .ParentKObj );_aabf .SetStructureType (_gf .StructureTypeList );};for _cfefb ,_bdbg :=range _beae ._agec {_bdff :=_aabf .NewCell ();_bdff .SetIndent (0);_bdff .SetContent (_ccff [_cfefb ]);if _bfab {_bdff .SetStructPageNumber (_beae ._febd .StructPageNumber );
_bdff .SetStructureType (_gf .StructureTypeLabel );};_bdff =_aabf .NewCell ();_bdff .SetIndent (0);_bdff .SetContent (_bdbg ._cceec );if _bfab {_bdff .SetStructPageNumber (_beae ._febd .StructPageNumber );_bdff .SetStructureType (_gf .StructureTypeListBody );
};};return _aabf .GeneratePageBlocks (ctx );};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_defdd *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_aegfg :=range subtable ._agced {_ddgff :=&TableCell {};*_ddgff =*_aegfg ;_ddgff ._gceg =_defdd ;_ddgff ._facac +=col -1;if _cffb :=_defdd ._daebe -(_ddgff ._facac -1);_cffb < _ddgff ._ggfdg {_defdd ._daebe +=_ddgff ._ggfdg -_cffb ;
_defdd .resetColumnWidths ();_ef .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_defdd ._daebe );
};_ddgff ._efdd +=row -1;_dcegf :=subtable ._acbg [_aegfg ._efdd -1];if _ddgff ._efdd > _defdd ._ebdeb {for _ddgff ._efdd > _defdd ._ebdeb {_defdd ._ebdeb ++;_defdd ._acbg =append (_defdd ._acbg ,_defdd ._ccfbe );};_defdd ._acbg [_ddgff ._efdd -1]=_dcegf ;
}else {_defdd ._acbg [_ddgff ._efdd -1]=_fb .Max (_defdd ._acbg [_ddgff ._efdd -1],_dcegf );};_defdd ._agced =append (_defdd ._agced ,_ddgff );};_defdd .sortCells ();};func (_fccfb *shading )generatePdfFunctions ()[]_gf .PdfFunction {if len (_fccfb ._fcefg )==0{return nil ;
}else if len (_fccfb ._fcefg )<=2{_cfac ,_ffee ,_efcea :=_fccfb ._fcefg [0]._efdg .ToRGB ();_debba ,_aacfb ,_adfa :=_fccfb ._fcefg [len (_fccfb ._fcefg )-1]._efdg .ToRGB ();return []_gf .PdfFunction {&_gf .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_cfac ,_ffee ,_efcea },C1 :[]float64 {_debba ,_aacfb ,_adfa }}};
}else {_gbbf :=[]_gf .PdfFunction {};_fbgab :=[]float64 {};for _efac :=0;_efac < len (_fccfb ._fcefg )-1;_efac ++{_gcadg ,_babc ,_agfg :=_fccfb ._fcefg [_efac ]._efdg .ToRGB ();_gfbfc ,_aafd ,_ccfbc :=_fccfb ._fcefg [_efac +1]._efdg .ToRGB ();_dbde :=&_gf .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_gcadg ,_babc ,_agfg },C1 :[]float64 {_gfbfc ,_aafd ,_ccfbc }};
_gbbf =append (_gbbf ,_dbde );if _efac > 0{_fbgab =append (_fbgab ,_fccfb ._fcefg [_efac ]._bccb );};};_ccceaf :=[]float64 {};for range _gbbf {_ccceaf =append (_ccceaf ,[]float64 {0.0,1.0}...);};return []_gf .PdfFunction {&_gf .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_gbbf ,Bounds :_fbgab ,Encode :_ccceaf }};
};};func (_ccbbb *GraphicSVGStyle )toContentStream (_cgaa *_ebf .ContentCreator ,_geed *_gf .PdfPageResources ,_geea *GraphicSVGElement ){if _ccbbb ==nil {return ;};if _ccbbb .FillColor !=""{var _cdbb ,_eegb ,_bec float64 ;if _gdcg ,_adbc :=_ba .ColorMap [_ccbbb .FillColor ];
_adbc {_ffad ,_bdde ,_cade ,_ :=_gdcg .RGBA ();_cdbb ,_eegb ,_bec =float64 (_ffad ),float64 (_bdde ),float64 (_cade );_cgaa .Add_rg (_cdbb ,_eegb ,_bec );}else if _b .HasPrefix (_ccbbb .FillColor ,"\u0072\u0067\u0062\u0028"){_cdbb ,_eegb ,_bec =_fedea (_ccbbb .FillColor );
_cgaa .Add_rg (_cdbb ,_eegb ,_bec );}else if _b .HasPrefix (_ccbbb .FillColor ,"\u0075\u0072\u006c\u0028"){_dffa :=_b .TrimPrefix (_ccbbb .FillColor ,"\u0075\u0072\u006c\u0028\u0027\u0023");_dffa =_b .TrimPrefix (_dffa ,"\u0075\u0072\u006c(\u0023");_dffa =_b .TrimSuffix (_dffa ,"\u0027\u0029");
_dffa =_b .TrimSuffix (_dffa ,"\u0029");if _geea ._abca [_dffa ]!=nil {_geed .SetPatternByName (*_cd .MakeName (_dffa ),_geea ._abca [_dffa ].ToPdfShadingPattern ().ToPdfObject ());_cgaa .Add_cs (*_cd .MakeName ("\u0050a\u0074\u0074\u0065\u0072\u006e"));
_cgaa .Add_scn_pattern (*_cd .MakeName (_dffa ));}else if _geea ._ceefd [_dffa ]!=nil {_geed .SetPatternByName (*_cd .MakeName (_dffa ),_geea ._ceefd [_dffa ].ToPdfShadingPattern ().ToPdfObject ());_cgaa .Add_cs (*_cd .MakeName ("\u0050a\u0074\u0074\u0065\u0072\u006e"));
_cgaa .Add_scn_pattern (*_cd .MakeName (_dffa ));};}else {_cdbb ,_eegb ,_bec =ColorRGBFromHex (_ccbbb .FillColor ).ToRGB ();_cgaa .Add_rg (_cdbb ,_eegb ,_bec );};};if _ccbbb .FillOpacity < 1.0{_ebfb :=0;_fdcd :=_cd .PdfObjectName (_e .Sprintf ("\u0047\u0053\u0025\u0064",_ebfb ));
for {_ ,_eeba :=_geed .GetExtGState (_fdcd );if !_eeba {break ;};_ebfb ++;_fdcd =_cd .PdfObjectName (_e .Sprintf ("\u0047\u0053\u0025\u0064",_ebfb ));};_gcdfc :=_cd .MakeDict ();_gcdfc .Set ("\u0063\u0061",_cd .MakeFloat (_ccbbb .FillOpacity ));_dbb :=_geed .AddExtGState (_fdcd ,_cd .MakeIndirectObject (_gcdfc ));
if _dbb !=nil {_ef .Log .Debug (_dbb .Error ());return ;};_cgaa .Add_gs (_fdcd );};if _ccbbb .StrokeColor !=""{var _ccfd ,_bdbcg ,_agdba float64 ;if _caea ,_bbcg :=_ba .ColorMap [_ccbbb .StrokeColor ];_bbcg {_cbcgf ,_agdee ,_bfgf ,_ :=_caea .RGBA ();_ccfd ,_bdbcg ,_agdba =float64 (_cbcgf )/255.0,float64 (_agdee )/255.0,float64 (_bfgf )/255.0;
}else if _b .HasPrefix (_ccbbb .FillColor ,"\u0072\u0067\u0062\u0028"){_ccfd ,_bdbcg ,_agdba =_fedea (_ccbbb .FillColor );}else {_ccfd ,_bdbcg ,_agdba =ColorRGBFromHex (_ccbbb .StrokeColor ).ToRGB ();};_cgaa .Add_RG (_ccfd ,_bdbcg ,_agdba );};if _ccbbb .StrokeWidth > 0{_cgaa .Add_w (_ccbbb .StrokeWidth );
};};

// SetTerms sets the terms and conditions section of the invoice.
func (_fafgf *Invoice )SetTerms (title ,content string ){_fafgf ._cbcac =[2]string {title ,content }};

// GeneratePageBlocks generates a page break block.
func (_gadgd *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fegf :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_gdcaf :=ctx ;_gdcaf .Y =ctx .Margins .Top ;
_gdcaf .X =ctx .Margins .Left ;_gdcaf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_gdcaf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_gdcaf ;return _fegf ,ctx ,nil ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_eaaab *LinearShading )ToPdfShadingPattern ()*_gf .PdfShadingPatternType2 {_bafg ,_afda ,_cefb :=_eaaab ._beecg ._egdad .ToRGB ();_deae :=_eaaab .shadingModel ();_deae .Background =_cd .MakeArrayFromFloats ([]float64 {_bafg ,_afda ,_cefb });_abce :=_gf .NewPdfShadingPatternType2 ();
_abce .Shading =_deae ;return _abce ;};

// SetFontSize sets the font size in document units (points).
func (_ecdd *Paragraph )SetFontSize (fontSize float64 ){_ecdd ._fagc =fontSize };

// NewPolyline creates a new polyline.
func (_fegb *Creator )NewPolyline (points []_dd .Point )*Polyline {return _baec (points )};func _cggf (_cafce string )(*GraphicSVG ,error ){_aaeg ,_faac :=ParseFromSVGString (_cafce );if _faac !=nil {return nil ,_faac ;};return _ggab (_aaeg );};func (_defa *GraphicSVGElement )drawPolyline (_gaae *_ebf .ContentCreator ,_acece *_gf .PdfPageResources ){_gaae .Add_q ();
_defa .Style .toContentStream (_gaae ,_acece ,_defa );_abggb ,_egdbd :=_adgac (_defa .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);if _egdbd !=nil {_ef .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_egdbd );
return ;};if len (_abggb )%2> 0{_ef .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _gafff :=0;_gafff < len (_abggb );{if _gafff ==0{_gaae .Add_m (_abggb [_gafff ]*_defa ._bcae ,_abggb [_gafff +1]*_defa ._bcae );}else {_gaae .Add_l (_abggb [_gafff ]*_defa ._bcae ,_abggb [_gafff +1]*_defa ._bcae );};_gafff +=2;};_defa .Style .fillStroke (_gaae );
_gaae .Add_h ();_gaae .Add_Q ();};

// SetDropCapsFirstCharacter is a convenience method to set traditional drop caps
// on the first character of the paragraph.
//
// Example:
//
//	p := c.NewStyledParagraph()
//	p.SetText("This paragraph starts with a large T...")
//	p.SetDropCapsFirstCharacter(3, 5.0) // T spans 3 lines with 5pt gap
func (_gedc *StyledParagraph )SetDropCapsFirstCharacter (numLines int ,gap float64 ){_gedc .SetDropCaps (DropCapsOptions {Type :DropCapsDrop ,Scope :DropCapsFirstCharacter ,NumLines :numLines ,Gap :gap });};

// NewInvoice returns an instance of an empty invoice.
func (_dfg *Creator )NewInvoice ()*Invoice {_gdgd :=_dfg .NewTextStyle ();_gdgd .Font =_dfg ._eggg ;return _afcdc (_dfg .NewTextStyle (),_gdgd );};

// Height returns Image's document height.
func (_ddcc *Image )Height ()float64 {return _ddcc ._dfbd };

// SetPos sets absolute positioning with specified coordinates.
func (_badec *StyledParagraph )SetPos (x ,y float64 ){_badec ._ggdeb =PositionAbsolute ;_badec ._bafb =x ;_badec ._fcda =y ;};

// Width returns the cell's width based on the input draw context.
func (_cafbe *TableCell )Width (ctx DrawContext )float64 {_fgafgd :=float64 (0.0);for _fabbbb :=0;_fabbbb < _cafbe ._ggfdg ;_fabbbb ++{_fgafgd +=_cafbe ._gceg ._beeaca [_cafbe ._facac +_fabbbb -1];};_cffe :=ctx .Width *_fgafgd ;return _cffe ;};

// Width returns the width of the Paragraph.
func (_abgaa *Paragraph )Width ()float64 {if _abgaa ._daabg &&int (_abgaa ._afeca )> 0{return _abgaa ._afeca ;};return _abgaa .getTextWidth ()/1000.0;};func (_eaed *Chapter )headingText ()string {_bdca :=_eaed ._cede ;if _gafc :=_eaed .headingNumber ();
_gafc !=""{_bdca =_e .Sprintf ("\u0025\u0073\u0020%\u0073",_gafc ,_bdca );};return _bdca ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{taggedDrawable ;_ebdeb int ;_daebe int ;_facb int ;_beeaca []float64 ;_acbg []float64 ;_ccfbe float64 ;_agced []*TableCell ;_afbfce []int ;_fddd Positioning ;_ddfeb ,_befbg float64 ;_efdf Margins ;_ccdcb bool ;_faaga int ;_dagb int ;_afeec bool ;
_ccea bool ;_gdbd bool ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;
);

// Scale scales the rectangle dimensions by the specified factors.
func (_cdgd *Rectangle )Scale (xFactor ,yFactor float64 ){_cdgd ._egdeb =xFactor *_cdgd ._egdeb ;_cdgd ._ebef =yFactor *_cdgd ._ebef ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_afeba *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gcef :=&InvoiceCell {_afeba ._dbed ,desc };_bgded :=&InvoiceCell {_afeba ._dbed ,value };_afeba ._eade =append (_afeba ._eade ,[2]*InvoiceCell {_gcef ,_bgded });return _gcef ,_bgded ;
};

// SetBorderColor sets the border color.
func (_ceegg *PolyBezierCurve )SetBorderColor (color Color ){_ceegg ._cega .BorderColor =_fbd (color )};func (_dgcg *Image )applyFitMode (_gcad float64 ){_gcad -=_dgcg ._gdgbd .Left +_dgcg ._gdgbd .Right ;switch _dgcg ._aeeb {case FitModeFillWidth :_dgcg .ScaleToWidth (_gcad );
};};func (_aaegf *Invoice )drawAddress (_gdgf *InvoiceAddress )[]*StyledParagraph {var _acfd []*StyledParagraph ;if _gdgf .Heading !=""{_eeaa :=_bgdc (_aaegf ._faaca );_eeaa .SetMargins (0,0,0,7);_eeaa .Append (_gdgf .Heading );_acfd =append (_acfd ,_eeaa );
};_fdfc :=_bgdc (_aaegf ._afeef );_fdfc .SetLineHeight (1.2);_gggc :=_gdgf .Separator ;if _gggc ==""{_gggc =_aaegf ._cgecf ;};_beg :=_gdgf .City ;if _gdgf .State !=""{if _beg !=""{_beg +=_gggc ;};_beg +=_gdgf .State ;};if _gdgf .Zip !=""{if _beg !=""{_beg +=_gggc ;
};_beg +=_gdgf .Zip ;};if _gdgf .Name !=""{_fdfc .Append (_gdgf .Name +"\u000a");};if _gdgf .Street !=""{_fdfc .Append (_gdgf .Street +"\u000a");};if _gdgf .Street2 !=""{_fdfc .Append (_gdgf .Street2 +"\u000a");};if _beg !=""{_fdfc .Append (_beg +"\u000a");
};if _gdgf .Country !=""{_fdfc .Append (_gdgf .Country +"\u000a");};_gcae :=_bgdc (_aaegf ._afeef );_gcae .SetLineHeight (1.2);_gcae .SetMargins (0,0,7,0);if _gdgf .Phone !=""{_gcae .Append (_gdgf .fmtLine (_gdgf .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_gdgf .HidePhoneLabel ));
};if _gdgf .Email !=""{_gcae .Append (_gdgf .fmtLine (_gdgf .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_gdgf .HideEmailLabel ));};_acfd =append (_acfd ,_fdfc ,_gcae );return _acfd ;};func _bdced (_edbfcb *Block ,_aacb _gf .PdfColor ,_fgaec Color ,_gbbg func ()Rectangle )error {switch _bcfgg :=_aacb .(type ){case *_gf .PdfColorPatternType2 :_dgfd ,_dedc :=_fgaec .(*LinearShading );
if !_dedc {return _e .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_fcdcd :=_gbbg ();_dgfd .SetBoundingBox (_fcdcd ._acaf ,_fcdcd ._dgec ,_fcdcd ._egdeb ,_fcdcd ._ebef );
_abeba ,_afea :=_dgfd .AddPatternResource (_edbfcb );if _afea !=nil {return _e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_afea );
};_bcfgg .PatternName =_abeba ;case *_gf .PdfColorPatternType3 :_agdf ,_aecd :=_fgaec .(*RadialShading );if !_aecd {return _e .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_fddcb :=_gbbg ();_agdf .SetBoundingBox (_fddcb ._acaf ,_fddcb ._dgec ,_fddcb ._egdeb ,_fddcb ._ebef );_feebe ,_accfa :=_agdf .AddPatternResource (_edbfcb );if _accfa !=nil {return _e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_accfa );
};_bcfgg .PatternName =_feebe ;};return nil ;};

// Heading returns the heading component of the table of contents.
func (_ddcef *TOC )Heading ()*StyledParagraph {return _ddcef ._bbcbd };

// MarkAsArtifact marks the image as an artifact of the specified type.
//
// This would override regular structure tagging and accessibility
// properties, and the image will be treated as an artifact in the PDF.
func (_cadd *Image )MarkAsArtifact (artifactType _gf .ArtifactType )*_gf .Artifact {_cadd ._febda =&_gf .Artifact {Type :artifactType };return _cadd ._febda ;};

// CurCol returns the currently active cell's column number.
func (_dgafb *Table )CurCol ()int {_efgf :=(_dgafb ._facb -1)%(_dgafb ._daebe )+1;return _efgf };

// SetInline sets the inline mode of the division.
func (_adgd *Division )SetInline (inline bool ){_adgd ._dfcc =inline };

// Height returns the height of the list.
func (_afbd *List )Height ()float64 {var _edfff float64 ;for _ ,_abaag :=range _afbd ._agec {_edfff +=_abaag .ctxHeight (_afbd .Width ());};return _edfff ;};func _gcgfc ()commands {var _bbbded =map[string ]int {"\u006d":2,"\u007a":0,"\u006c":2,"\u0068":1,"\u0076":1,"\u0063":6,"\u0073":4,"\u0071":4,"\u0074":2,"\u0061":7};
var _adeff []string ;for _ddfde :=range _bbbded {_adeff =append (_adeff ,_ddfde );};return commands {_adeff ,_bbbded ,"\u006d","\u007a"};};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_dbedb *LinearShading )AddShadingResource (block *Block )(_aegb _cd .PdfObjectName ,_gfef error ){_fdaa :=1;_aegb =_cd .PdfObjectName ("\u0053\u0068"+_ca .Itoa (_fdaa ));for block ._ebe .HasShadingByName (_aegb ){_fdaa ++;_aegb =_cd .PdfObjectName ("\u0053\u0068"+_ca .Itoa (_fdaa ));
};if _adac :=block ._ebe .SetShadingByName (_aegb ,_dbedb .shadingModel ().ToPdfObject ());_adac !=nil {return "",_adac ;};return _aegb ,nil ;};func (_gabf *templateProcessor )parseInt64Array (_ceeea ,_fcead string )[]int64 {_ef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ceeea ,_fcead );
_cacf :=_b .Fields (_fcead );_bbfe :=make ([]int64 ,0,len (_cacf ));for _ ,_bgdg :=range _cacf {_bggbb ,_ :=_ca .ParseInt (_bgdg ,10,64);_bbfe =append (_bbfe ,_bggbb );};return _bbfe ;};

// SetDropCapsWithStyle is a convenience method to set drop caps with a custom style.
// This allows you to customize the appearance of the drop cap (color, font, etc.)
// while specifying the basic drop caps parameters.
//
// Example:
//
//	p := c.NewStyledParagraph()
//	p.SetText("This is a paragraph with a styled drop cap...")
//	style := creator.TextStyle{
//	    Font:  boldFont,
//	    Color: creator.ColorRGBFrom8bit(200, 0, 0), // Red
//	}
//	p.SetDropCapsWithStyle(creator.DropCapsDrop, creator.DropCapsFirstCharacter, 3, 5.0, &style)
func (_dcfdg *StyledParagraph )SetDropCapsWithStyle (dropType DropCapsType ,scope DropCapsScope ,numLines int ,gap float64 ,style *TextStyle ){_dcfdg .SetDropCaps (DropCapsOptions {Type :dropType ,Scope :scope ,NumLines :numLines ,Gap :gap ,Style :style });
};

// Color returns the color of the line.
func (_cbag *Line )Color ()Color {return _cbag ._fgbd };func _acffa (_bbcf *Creator ,_fgeaa _fd .Reader ,_dggfb interface{},_gdfc *TemplateOptions ,_cbecc componentRenderer )error {if _bbcf ==nil {_ef .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _ebdcg ;};_ceecd :="";if _acgfg ,_eede :=_fgeaa .(*_f .File );_eede {_ceecd =_acgfg .Name ();};_bead :=_c .NewBuffer (nil );if _ ,_eaabd :=_fd .Copy (_bead ,_fgeaa );_eaabd !=nil {return _eaabd ;};_abebc :=_dg .FuncMap {"\u0064\u0069\u0063\u0074":_dabba ,"\u0061\u0064\u0064":_befec ,"\u0061\u0072\u0072a\u0079":_dagfd ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_ggccf ,"\u006da\u006b\u0065\u0053\u0065\u0071":_ecabg };
if _gdfc !=nil &&_gdfc .HelperFuncMap !=nil {for _eabffa ,_eaecc :=range _gdfc .HelperFuncMap {if _ ,_bdeagc :=_abebc [_eabffa ];_bdeagc {_ef .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_eabffa );
continue ;};_abebc [_eabffa ]=_eaecc ;};};_cceg ,_eagdb :=_dg .New ("").Funcs (_abebc ).Parse (_bead .String ());if _eagdb !=nil {return _eagdb ;};if _gdfc !=nil &&_gdfc .SubtemplateMap !=nil {for _agcfe ,_efbf :=range _gdfc .SubtemplateMap {if _agcfe ==""{_ef .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _efbf ==nil {_ef .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_fage :=_c .NewBuffer (nil );if _ ,_bgeb :=_fd .Copy (_fage ,_efbf );_bgeb !=nil {return _bgeb ;};if _ ,_fagfb :=_cceg .New (_agcfe ).Parse (_fage .String ());_fagfb !=nil {return _fagfb ;};};};_bead .Reset ();if _efcec :=_cceg .Execute (_bead ,_dggfb );
_efcec !=nil {return _efcec ;};return _bbfcc (_bbcf ,_ceecd ,_bead .Bytes (),_gdfc ,_cbecc ).run ();};

// Padding returns the padding of the component.
func (_ebdc *Division )Padding ()(_fdag ,_eebb ,_dfde ,_dba float64 ){return _ebdc ._aeg .Left ,_ebdc ._aeg .Right ,_ebdc ._aeg .Top ,_ebdc ._aeg .Bottom ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{taggedDrawable ;_fcfa *_dd .Polygon ;_cccgd float64 ;_fafbf float64 ;_dafec Color ;};func (_agddd *templateProcessor )renderNode (_afccc *templateNode )error {_eacbd :=_afccc ._efefd ;if _eacbd ==nil {return nil ;};_eceb :=_afccc ._fdbe .Name .Local ;
_fdcb ,_cacd :=_gbabd [_eceb ];if !_cacd {_agddd .nodeLogDebug (_afccc ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_eceb );return nil ;};var _cfbdd interface{};
if _afccc ._ccbde !=nil &&_afccc ._ccbde ._efefd !=nil {_bdgfe :=_afccc ._ccbde ._fdbe .Name .Local ;if _ ,_cacd =_fdcb ._cgdd [_bdgfe ];!_cacd {_agddd .nodeLogDebug (_afccc ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_bdgfe ,_eceb );
return _gdac ;};_cfbdd =_afccc ._ccbde ._efefd ;}else {_bgbg :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _agddd ._ffeca .(type ){case *Block :_bgbg ="\u0062\u006c\u006fc\u006b";};if _ ,_cacd =_fdcb ._cgdd [_bgbg ];!_cacd {_agddd .nodeLogDebug (_afccc ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_bgbg ,_eceb );
return _gdac ;};_cfbdd =_agddd ._ffeca ;};switch _cebec :=_cfbdd .(type ){case componentRenderer :_deag ,_ffca :=_eacbd .(Drawable );if !_ffca {_agddd .nodeLogError (_afccc ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_eceb ,_eacbd );
return _efdfd ;};_ccafce :=_cebec .Draw (_deag );if _ccafce !=nil {return _agddd .nodeError (_afccc ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_eceb ,_eacbd ,_ccafce );
};case *Division :switch _ceage :=_eacbd .(type ){case *Background :_cebec .SetBackground (_ceage );case VectorDrawable :_egag :=_cebec .Add (_ceage );if _egag !=nil {return _agddd .nodeError (_afccc ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_eceb ,_eacbd ,_egag );
};};case *TableCell :_eddc ,_bece :=_eacbd .(VectorDrawable );if !_bece {_agddd .nodeLogError (_afccc ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_eceb ,_eacbd );
return _efdfd ;};_efeca :=_cebec .SetContent (_eddc );if _efeca !=nil {return _agddd .nodeError (_afccc ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_eceb ,_eacbd ,_efeca );
};case *StyledParagraph :_aaeec ,_efggg :=_eacbd .(*TextChunk );if !_efggg {_agddd .nodeLogError (_afccc ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_eceb ,_eacbd );
return _efdfd ;};_cebec .appendChunk (_aaeec );case *Chapter :switch _eddaa :=_eacbd .(type ){case *Chapter :return nil ;case *StyledParagraph :if _afccc ._fdbe .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_adae :=_cebec .Add (_eddaa );if _adae !=nil {return _agddd .nodeError (_afccc ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_eceb ,_eacbd ,_adae );
};case Drawable :_eccf :=_cebec .Add (_eddaa );if _eccf !=nil {return _agddd .nodeError (_afccc ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_eceb ,_eacbd ,_eccf );
};};case *List :switch _dccbe :=_eacbd .(type ){case *TextChunk :case *listItem :_cebec ._agec =append (_cebec ._agec ,_dccbe );default:_agddd .nodeLogError (_afccc ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_eceb ,_eacbd );
};case *listItem :switch _aebg :=_eacbd .(type ){case *TextChunk :case *StyledParagraph :_cebec ._cceec =_aebg ;case *List :if _aebg ._dbdb {_aebg ._eafe =15;};_cebec ._cceec =_aebg ;case *Image :_cebec ._cceec =_aebg ;case *Division :_cebec ._cceec =_aebg ;
case *Table :_cebec ._cceec =_aebg ;default:_agddd .nodeLogError (_afccc ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_eceb ,_eacbd );
return _efdfd ;};};return nil ;};func (_dfgbf *GraphicSVGElement )parseColorPoints ()[]*ColorPoint {var _bcadb []*ColorPoint ;var _ddbf error ;for _ ,_agfb :=range _dfgbf .Children {if _agfb .Name =="\u0073\u0074\u006f\u0070"{_fbag :=ColorBlack ;_abff :=0.0;
for _dddc ,_cbb :=range _agfb .Attributes {if _dddc =="\u006f\u0066\u0066\u0073\u0065\u0074"{if _b .HasSuffix (_cbb ,"\u0025"){_dfge ,_bdbcf :=_ca .ParseFloat (_b .TrimSuffix (_cbb ,"\u0025"),64);if _bdbcf !=nil {continue ;};_abff =_dfge /100;}else {_abff ,_ddbf =_ca .ParseFloat (_cbb ,64);
if _ddbf !=nil {continue ;};};}else if _dddc =="\u0073\u0074\u006f\u0070\u002d\u0063\u006f\u006c\u006f\u0072"{if _cbb [0]=='#'{_fbag =ColorRGBFromHex (_cbb );}else {_eagfed ,_feagf :=_ba .ColorMap [_cbb ];if _feagf {_fbag =ColorRGBFrom8bit (_eagfed .R ,_eagfed .G ,_eagfed .B );
};};};};_bcadb =append (_bcadb ,NewColorPoint (_fbag ,_abff ));};};return _bcadb ;};

// SetAnchor set gradient position anchor.
// Default to center.
func (_aeec *RadialShading )SetAnchor (anchor AnchorPoint ){_aeec ._debd =anchor };func (_ecdc *GraphicSVGElement )toContentStream (_bdee *_ebf .ContentCreator ,_ggagd *_gf .PdfPageResources ){_bgda ,_eded :=_ggcg (_ecdc .Attributes ,_ecdc ._bcae );if _eded !=nil {_ef .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_eded );
};_ecdc .Style =_bgda ;switch _ecdc .Name {case "\u0070\u0061\u0074\u0068":_ecdc .drawPath (_bdee ,_ggagd );for _ ,_ebfg :=range _ecdc .Children {_ebfg .toContentStream (_bdee ,_ggagd );};case "\u0072\u0065\u0063\u0074":_ecdc .drawRect (_bdee ,_ggagd );
for _ ,_ddbe :=range _ecdc .Children {_ddbe .toContentStream (_bdee ,_ggagd );};case "\u0063\u0069\u0072\u0063\u006c\u0065":_ecdc .drawCircle (_bdee ,_ggagd );for _ ,_accfd :=range _ecdc .Children {_accfd .toContentStream (_bdee ,_ggagd );};case "\u0065l\u006c\u0069\u0070\u0073\u0065":_ecdc .drawEllipse (_bdee ,_ggagd );
for _ ,_fgcd :=range _ecdc .Children {_fgcd .toContentStream (_bdee ,_ggagd );};case "\u0070\u006f\u006c\u0079\u006c\u0069\u006e\u0065":_ecdc .drawPolyline (_bdee ,_ggagd );for _ ,_ggeeg :=range _ecdc .Children {_ggeeg .toContentStream (_bdee ,_ggagd );
};case "\u0070o\u006c\u0079\u0067\u006f\u006e":_ecdc .drawPolygon (_bdee ,_ggagd );for _ ,_gacdc :=range _ecdc .Children {_gacdc .toContentStream (_bdee ,_ggagd );};case "\u006c\u0069\u006e\u0065":_ecdc .drawLine (_bdee ,_ggagd );for _ ,_ffgfd :=range _ecdc .Children {_ffgfd .toContentStream (_bdee ,_ggagd );
};case "\u0074\u0065\u0078\u0074":_ecdc .drawText (_bdee ,_ggagd );for _ ,_dcageb :=range _ecdc .Children {_dcageb .toContentStream (_bdee ,_ggagd );};case "\u0067":_cffg ,_ebga :=_ecdc .Attributes ["\u0066\u0069\u006c\u006c"];_efff ,_cafdd :=_ecdc .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];
_bcfff ,_edgf :=_ecdc .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];_cgec ,_cbbg :=_ecdc .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];for _ ,_bcac :=range _ecdc .Children {if _ ,_abga :=_bcac .Attributes ["\u0066\u0069\u006c\u006c"];
!_abga &&_ebga {_bcac .Attributes ["\u0066\u0069\u006c\u006c"]=_cffg ;};if _ ,_bddb :=_bcac .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];!_bddb &&_cafdd {_bcac .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"]=_efff ;};if _ ,_ecagg :=_bcac .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
!_ecagg &&_edgf {_bcac .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"]=_bcfff ;};if _ ,_abbgb :=_bcac .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];!_abbgb &&_cbbg {_bcac .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"]=_cgec ;
};_bcac .toContentStream (_bdee ,_ggagd );};};};func (_degca *templateProcessor )parseStyledParagraph (_ecfdaf *templateNode )(interface{},error ){_bgegd :=_degca .creator .NewStyledParagraph ();for _ ,_cdegb :=range _ecfdaf ._fdbe .Attr {_daaf :=_cdegb .Value ;
switch _ffbfe :=_cdegb .Name .Local ;_ffbfe {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_bgegd .SetTextAlignment (_degca .parseTextAlignmentAttr (_ffbfe ,_daaf ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_bgegd .SetTextVerticalAlignment (_degca .parseTextVerticalAlignmentAttr (_ffbfe ,_daaf ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_bgegd .SetLineHeight (_degca .parseFloatAttr (_ffbfe ,_daaf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bede :=_degca .parseMarginAttr (_ffbfe ,_daaf );_bgegd .SetMargins (_bede .Left ,_bede .Right ,_bede .Top ,_bede .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_bgegd .SetEnableWrap (_degca .parseBoolAttr (_ffbfe ,_daaf ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_bgegd .EnableWordWrap (_degca .parseBoolAttr (_ffbfe ,_daaf ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_bgegd .SetTextOverflow (_degca .parseTextOverflowAttr (_ffbfe ,_daaf ));case "\u0078":_bgegd .SetPos (_degca .parseFloatAttr (_ffbfe ,_daaf ),_bgegd ._fcda );case "\u0079":_bgegd .SetPos (_bgegd ._bafb ,_degca .parseFloatAttr (_ffbfe ,_daaf ));
case "\u0061\u006e\u0067l\u0065":_bgegd .SetAngle (_degca .parseFloatAttr (_ffbfe ,_daaf ));default:_degca .nodeLogDebug (_ecfdaf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ffbfe );
};};return _bgegd ,nil ;};func _gcdf ()*GraphicSVGStyle {return &GraphicSVGStyle {FillColor :"\u00230\u0030\u0030\u0030\u0030\u0030",StrokeColor :"",StrokeWidth :0,FillOpacity :1.0};};

// SetFontColor sets the font color for the paragraph.
func (_cbab *StyledParagraph )SetFontColor (color Color ){_cbab ._dgaag .Color =color ;for _ ,_cceeb :=range _cbab ._gbbce {_cceeb .Style .Color =color ;};};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_bac *_ebf .ContentStreamOperations ;_ebe *_gf .PdfPageResources ;_aa Positioning ;_fc ,_eec float64 ;_ddf float64 ;_geb float64 ;_aag float64 ;_gfc Margins ;_geg []*_gf .PdfAnnotation ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;func (_gdcf *StyledParagraph )getMaxLineWidth ()float64 {if _gdcf ._aeggc ==nil ||(_gdcf ._aeggc !=nil &&len (_gdcf ._aeggc )==0){_gdcf .wrapText ();};var _afgd float64 ;for _ ,_eeeff :=range _gdcf ._aeggc {_cbedf :=_gdcf .getTextLineWidth (_eeeff );
if _cbedf > _afgd {_afgd =_cbedf ;};};return _afgd ;};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_aadg *Ellipse )ScaleToHeight (h float64 ){_dcba :=_aadg ._feeac /_aadg ._feegb ;_aadg ._feegb =h ;_aadg ._feeac =h *_dcba ;};func (_bded *listItem )ctxHeight (_faedf float64 )float64 {var _bfaca float64 ;switch _gaad :=_bded ._cceec .(type ){case *Paragraph :if _gaad ._daabg {_gaad .SetWidth (_faedf -_gaad ._ecdf .Horizontal ());
};_bfaca =_gaad .Height ()+_gaad ._ecdf .Vertical ();_bfaca +=0.5*_gaad ._fagc *_gaad ._eaag ;case *StyledParagraph :if _gaad ._ffeac {_gaad .SetWidth (_faedf -_gaad ._dbge .Horizontal ());};_bfaca =_gaad .Height ()+_gaad ._dbge .Vertical ();_bfaca +=0.5*_gaad .getTextHeight ();
case *List :_eaadc :=_faedf -_bded ._fdab .Width ()-_gaad ._caba .Horizontal ()-_gaad ._eafe ;_bfaca =_gaad .ctxHeight (_eaadc )+_gaad ._caba .Vertical ();case *Image :_bfaca =_gaad .Height ()+_gaad ._gdgbd .Vertical ();case *Division :_caca :=_faedf -_bded ._fdab .Width ()-_gaad ._ffd .Horizontal ();
_bfaca =_gaad .ctxHeight (_caca )+_gaad ._ffd .Vertical ();case *Table :_ddee :=_faedf -_bded ._fdab .Width ()-_gaad ._efdf .Horizontal ();_gaad .updateRowHeights (_ddee );_bfaca =_gaad .Height ()+_gaad ._efdf .Vertical ();default:_bfaca =_bded ._cceec .Height ();
};return _bfaca ;};

// Length calculates and returns the length of the line.
func (_geab *Line )Length ()float64 {return _fb .Sqrt (_fb .Pow (_geab ._bada -_geab ._gbba ,2.0)+_fb .Pow (_geab ._bbacd -_geab ._dfag ,2.0));};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_acfda *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _acfda ._dfbfa .Left ,_acfda ._dfbfa .Right ,_acfda ._dfbfa .Top ,_acfda ._dfbfa .Bottom ;};func (_gacgaa *TextChunk )clone ()*TextChunk {_gcgg :=*_gacgaa ;_gcgg ._cgbff =_faecf (_gacgaa ._cgbff );
return &_gcgg ;};func (_gega *GraphicSVGStyle )fillStroke (_ecbcd *_ebf .ContentCreator ){if _gega .FillColor !=""&&_gega .StrokeColor !=""{_ecbcd .Add_B ();}else if _gega .FillColor !=""{_ecbcd .Add_f ();}else if _gega .StrokeColor !=""{_ecbcd .Add_S ();
};};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_eabg *Table )NewCell ()*TableCell {return _eabg .MultiCell (1,1)};

// SetBorderWidth sets the border width.
func (_dcagd *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_dcagd ._cega .BorderWidth =borderWidth ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_gcgc *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func (_bcdga *Subpath )compare (_cfcbd *Subpath )bool {if len (_bcdga .Commands )!=len (_cfcbd .Commands ){return false ;};for _gcdcg ,_gdde :=range _bcdga .Commands {if !_gdde .compare (_cfcbd .Commands [_gcdcg ]){return false ;
};};return true ;};func _gfdbc (_cgda string )[]token {var (_efbbe []token ;_ddgdb string ;);for _ ,_ecfb :=range _cgda {_adcc :=string (_ecfb );switch {case _ggbad .isCommand (_adcc ):_efbbe ,_ddgdb =_dcaa (_efbbe ,_ddgdb );_efbbe =append (_efbbe ,token {_adcc ,true });
case _adcc =="\u002e":if _ddgdb ==""{_ddgdb ="\u0030";};if _b .Contains (_ddgdb ,_adcc ){_efbbe =append (_efbbe ,token {_ddgdb ,false });_ddgdb ="\u0030";};fallthrough;case _adcc >="\u0030"&&_adcc <="\u0039"||_adcc =="\u0065":_ddgdb +=_adcc ;case _adcc =="\u002d":if _b .HasSuffix (_ddgdb ,"\u0065"){_ddgdb +=_adcc ;
}else {_efbbe ,_ =_dcaa (_efbbe ,_ddgdb );_ddgdb =_adcc ;};default:_efbbe ,_ddgdb =_dcaa (_efbbe ,_ddgdb );};};_efbbe ,_ =_dcaa (_efbbe ,_ddgdb );return _efbbe ;};

// AddTag adds a tag to the chapter.
func (_fce *Chapter )AddTag (rootKObj *_gf .KDict ){if _fce ._febd ==nil {_fce ._febd =_gf .NewStructureTagInfo ();_fce ._febd .StructureType =_gf .StructureTypeSection ;};_fce ._febd .ApplyTag =true ;_fce ._febd .ParentKObj =rootKObj ;_fce ._febd .ComponentKObj =_gf .NewKDictionary ();
_fce ._febd .ComponentKObj .S =_cd .MakeName (string (_fce ._febd .StructureType ));_fce ._febd .ParentKObj .AddKChild (_fce ._febd .ComponentKObj );};func (_cfcfg *templateProcessor )parseMarginAttr (_ffece ,_bgaad string )Margins {_ef .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_ffece ,_bgaad );
_beagf :=Margins {};switch _cffeg :=_b .Fields (_bgaad );len (_cffeg ){case 1:_beagf .Top ,_ =_ca .ParseFloat (_cffeg [0],64);_beagf .Bottom =_beagf .Top ;_beagf .Left =_beagf .Top ;_beagf .Right =_beagf .Top ;case 2:_beagf .Top ,_ =_ca .ParseFloat (_cffeg [0],64);
_beagf .Bottom =_beagf .Top ;_beagf .Left ,_ =_ca .ParseFloat (_cffeg [1],64);_beagf .Right =_beagf .Left ;case 3:_beagf .Top ,_ =_ca .ParseFloat (_cffeg [0],64);_beagf .Left ,_ =_ca .ParseFloat (_cffeg [1],64);_beagf .Right =_beagf .Left ;_beagf .Bottom ,_ =_ca .ParseFloat (_cffeg [2],64);
case 4:_beagf .Top ,_ =_ca .ParseFloat (_cffeg [0],64);_beagf .Right ,_ =_ca .ParseFloat (_cffeg [1],64);_beagf .Bottom ,_ =_ca .ParseFloat (_cffeg [2],64);_beagf .Left ,_ =_ca .ParseFloat (_cffeg [3],64);};return _beagf ;};func _eacf (_ebgda _ce .ChartRenderable )*Chart {return &Chart {_ddba :_ebgda ,_ggcc :PositionRelative ,_bade :Margins {Top :10,Bottom :10},taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeFigure }};
};func (_ddaa *templateProcessor )nodeLogError (_gagbf *templateNode ,_fffd string ,_cbbb ...interface{}){_ef .Log .Error (_ddaa .getNodeErrorLocation (_gagbf ,_fffd ,_cbbb ...));};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_dfb *Creator )SetPageLabels (pageLabels _cd .PdfObject ){_dfb ._bcf =pageLabels };

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_dbbbg *Table )MultiCell (rowspan ,colspan int )*TableCell {_dbbbg ._facb ++;_agbfb :=(_dbbbg .moveToNextAvailableCell ()-1)%(_dbbbg ._daebe )+1;_gdeb :=(_dbbbg ._facb -1)/_dbbbg ._daebe +1;for _gdeb > _dbbbg ._ebdeb {_dbbbg ._ebdeb ++;_dbbbg ._acbg =append (_dbbbg ._acbg ,_dbbbg ._ccfbe );
};_fcefb :=&TableCell {};_fcefb ._efdd =_gdeb ;_fcefb ._facac =_agbfb ;_fcefb ._gage =_gf .StructureTypeTableData ;_fcefb ._febd =_gf .NewStructureTagInfo ();_fcefb ._febd .StructureType =_gf .StructureTypeTableData ;_fcefb ._aagdg =5;_fcefb ._ddcce =CellBorderStyleNone ;
_fcefb ._decca =_dd .LineStyleSolid ;_fcefb ._edgce =CellHorizontalAlignmentLeft ;_fcefb ._bdfedc =CellVerticalAlignmentTop ;_fcefb ._bgeeg =0;_fcefb ._gafaf =0;_fcefb ._cdeb =0;_fcefb ._ecee =0;_gdbgf :=ColorBlack ;_fcefb ._agfge =_gdbgf ;_fcefb ._gdae =_gdbgf ;
_fcefb ._fcdd =_gdbgf ;_fcefb ._dadeb =_gdbgf ;_fcefb ._ggcef =1.0;if rowspan < 1{_ef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_fcada :=_dbbbg ._ebdeb -(_fcefb ._efdd -1);if rowspan > _fcada {_ef .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_fcada );
_dbbbg ._ebdeb +=rowspan -1;for _ceedd :=0;_ceedd <=rowspan -_fcada ;_ceedd ++{_dbbbg ._acbg =append (_dbbbg ._acbg ,_dbbbg ._ccfbe );};};for _decg :=0;_decg < colspan &&_agbfb +_decg -1< len (_dbbbg ._afbfce );_decg ++{_dbbbg ._afbfce [_agbfb +_decg -1]=rowspan -1;
};_fcefb ._addgb =rowspan ;if colspan < 1{_ef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_abgccf :=_dbbbg ._daebe -(_fcefb ._facac -1);if colspan > _abgccf {_ef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_abgccf );
colspan =_abgccf ;};_fcefb ._ggfdg =colspan ;_dbbbg ._facb +=colspan -1;_dbbbg ._agced =append (_dbbbg ._agced ,_fcefb );_fcefb ._gceg =_dbbbg ;return _fcefb ;};func (_bcecd *StyledParagraph )createAccessibleLinkChunk (_bbcb string ,_agfbb *_gf .PdfAnnotation ,_cdfbe LinkTagOptions )(*TextChunk ,*_gf .KDict ,error ){var _agddb *_gf .KDict ;
_gfab :=NewTextChunk (_bbcb ,_bcecd ._eeeag );_gfab .AddAnnotation (_agfbb );if _cdfbe .MCID > 0{_gfab .SetMarkedContentID (_cdfbe .MCID );_gfab .SetStructureType (_gf .StructureTypeLink );if _cdfbe .AltText !=""&&_cdfbe .AltText !=_bbcb {_gfab .SetAltText (_cdfbe .AltText );
};_gfab .AssociateAnnotationWithStructure (_agfbb );_ffaf ,_efffc :=_gfab .GenerateKDict ();if _efffc !=nil {return nil ,nil ,_e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020t\u006f\u0020\u0067e\u006e\u0065\u0072\u0061t\u0065\u0020\u004b\u0044\u0069\u0063\u0074\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u006e\u006b\u0020\u0063\u0068\u0075\u006e\u006b\u003a\u0020\u0025\u0076",_efffc );
};if _cdfbe .AltText !=""&&_cdfbe .AltText !=_bbcb {_ffaf .Alt =_cd .MakeString (_cdfbe .AltText );};_agddb =_ffaf ;};_bcecd .appendChunk (_gfab );return _gfab ,_agddb ,nil ;};func _edfb (_dafae *_gf .PdfAnnotationHighlight )*_gf .PdfAnnotationHighlight {if _dafae ==nil {return nil ;
};_gbfgg :=_gf .NewPdfAnnotationHighlight ();_gbfgg .CopyFrom (_dafae .PdfAnnotation );_gbfgg .CA =_dafae .CA ;_gbfgg .QuadPoints =_dafae .QuadPoints ;return _gbfgg ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_face *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_ffcb :=uint (len (_face ._ccgf ));if index > _ffcb {index =_ffcb ;};_ffbb :=_face .NewColumn (description );_face ._ccgf =append (_face ._ccgf [:index ],append ([]*InvoiceCell {_ffbb },_face ._ccgf [index :]...)...);
return _ffbb ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_gcada *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aaae :=ctx ;var _bfabd []*Block ;_ffddd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gcada ._ggdeb .IsRelative (){ctx .X +=_gcada ._dbge .Left ;ctx .Y +=_gcada ._dbge .Top ;
ctx .Width -=_gcada ._dbge .Left +_gcada ._dbge .Right ;ctx .Height -=_gcada ._dbge .Top ;_gcada .SetWidth (ctx .Width );}else {if int (_gcada ._ffdb )<=0{_gcada .SetWidth (_gcada .getTextWidth ()/1000.0);};ctx .X =_gcada ._bafb ;ctx .Y =_gcada ._fcda ;
};if _gcada ._egdcf !=nil {_gcada ._egdcf (_gcada ,ctx );};if _dfdc :=_gcada .wrapText ();_dfdc !=nil {return nil ,ctx ,_dfdc ;};_cbaeg :=_gcada ._aeggc ;_bfef :=0;for {_dfaabe ,_bdbfc ,_feagd :=_cbbef (_ffddd ,_gcada ,_cbaeg ,ctx );if _feagd !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_feagd );
return nil ,ctx ,_feagd ;};ctx =_dfaabe ;_bfabd =append (_bfabd ,_ffddd );if _cbaeg =_bdbfc ;len (_bdbfc )==0{break ;};if len (_bdbfc )==_bfef {return nil ,ctx ,_g .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_gcada ._ceaf =nil ;_ffddd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dfaabe =ctx ;_dfaabe .Y =ctx .Margins .Top ;_dfaabe .X =ctx .Margins .Left +_gcada ._dbge .Left ;_dfaabe .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
_dfaabe .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gcada ._dbge .Left -_gcada ._dbge .Right ;ctx =_dfaabe ;_bfef =len (_bdbfc );};if _gcada ._ggdeb .IsRelative (){ctx .Y +=_gcada ._dbge .Bottom ;ctx .Height -=_gcada ._dbge .Bottom ;
if !ctx .Inline {ctx .X =_aaae .X ;ctx .Width =_aaae .Width ;};return _bfabd ,ctx ,nil ;};return _bfabd ,_aaae ,nil ;};func (_gaaa *StyledParagraph )appendChunk (_baefd *TextChunk )*TextChunk {_gaaa ._gbbce =append (_gaaa ._gbbce ,_baefd );_gaaa .wrapText ();
return _baefd ;};func _cefa (_degee []*TextChunk )(_ddbba ,_feeag ,_fcadc float64 ){if len (_degee )==0{return 0,0,0;};for _ ,_acbd :=range _degee {_efaac :=_bfcdf (_acbd .Style .Font ,_acbd .Style .FontSize );if _efaac ._bfefbg > _ddbba {_ddbba =_efaac ._bfefbg ;
};if _efaac ._bdbba < _fcadc {_fcadc =_efaac ._bdbba ;};if _gdced :=_acbd .Style .FontSize ;_gdced > _feeag {_feeag =_gdced ;};};return _ddbba ,_feeag ,_fcadc ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_gcbcc *Invoice )TotalLines ()[][2]*InvoiceCell {_dcfd :=[][2]*InvoiceCell {_gcbcc ._efcb };_dcfd =append (_dcfd ,_gcbcc ._eade ...);return append (_dcfd ,_gcbcc ._dfad );};func _ebfe (_befbe []*Command )*Path {_cfea :=&Path {};var _dgbe []*Command ;
for _bggd ,_dfeg :=range _befbe {switch _b .ToLower (_dfeg .Symbol ){case _ggbad ._fgbae :if len (_dgbe )> 0{_cfea .Subpaths =append (_cfea .Subpaths ,&Subpath {_dgbe });};_dgbe =[]*Command {_dfeg };case _ggbad ._gagaf :_dgbe =append (_dgbe ,_dfeg );_cfea .Subpaths =append (_cfea .Subpaths ,&Subpath {_dgbe });
_dgbe =[]*Command {};default:_dgbe =append (_dgbe ,_dfeg );if len (_befbe )==_bggd +1{_cfea .Subpaths =append (_cfea .Subpaths ,&Subpath {_dgbe });};};};return _cfea ;};

// SetAngle sets the rotation angle of the text.
func (_fdedg *Paragraph )SetAngle (angle float64 ){_fdedg ._bafe =angle };var (_eebdd =_gg .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_ebdcg =_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_gdac =_g .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_efdfd =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_ecdff =_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_afag *List )Width ()float64 {return 0};

// SetFont sets the Paragraph's font.
func (_gecfd *Paragraph )SetFont (font *_gf .PdfFont ){_gecfd ._abbaf =font };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline ,_cgbff :[]*_gf .PdfAnnotation {},_bfcda :[]bool {},taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeSpan }};
};

// ParseFromSVGFile creates a GraphicSVG instance from file.
func ParseFromSVGFile (path string )(*GraphicSVGElement ,error ){_bfba ,_cfcd :=_f .Open (path );if _cfcd !=nil {return nil ,_cfcd ;};defer _bfba .Close ();return ParseFromSVGStream (_bfba );};

// SetMargins sets the margins TOC line.
func (_bcbda *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_bcbda ._gggea =left ;_ddbcd :=&_bcbda ._eccb ._dbge ;_ddbcd .Left =_bcbda ._gggea +float64 (_bcbda ._bacb -1)*_bcbda ._gdcafd ;_ddbcd .Right =right ;_ddbcd .Top =top ;_ddbcd .Bottom =bottom ;
};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_dddd *Ellipse )GetCoords ()(float64 ,float64 ){return _dddd ._eaee ,_dddd ._cbcg };func (_gbaf *Table )getLastCellFromCol (_feaca int )(int ,*TableCell ){for _aeggg :=len (_gbaf ._agced )-1;_aeggg >=0;_aeggg --{if _gbaf ._agced [_aeggg ]._facac <=_feaca &&_feaca <=_gbaf ._agced [_aeggg ]._facac +_gbaf ._agced [_aeggg ]._ggfdg {return _aeggg ,_gbaf ._agced [_aeggg ];
};};return 0,nil ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_babe *Image )SetPos (x ,y float64 ){_babe ._cgaad =PositionAbsolute ;_babe ._dgda =x ;_babe ._eaede =y ;};

// Cols returns the total number of columns the table has.
func (_abcae *Table )Cols ()int {return _abcae ._daebe };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_dcef *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_adge ,_ebdb :=_dcef .Wrap (width );if _ebdb !=nil {return nil ,_ebdb ;};_ffbege :=int (height /_dcef .Style .FontSize );if _ffbege >=len (_adge ){return nil ,nil ;};_ccafad :="\u000a";
_dcef .Text =_b .ReplaceAll (_b .Join (_adge [:_ffbege ],"\u0020"),_ccafad +"\u0020",_ccafad );_beaeb :=_b .ReplaceAll (_b .Join (_adge [_ffbege :],"\u0020"),_ccafad +"\u0020",_ccafad );return NewTextChunk (_beaeb ,_dcef .Style ),nil ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gebd *Paragraph )SetTextAlignment (align TextAlignment ){_gebd ._abea =align };func (_gfebc *templateProcessor )parsePositioningAttr (_bceb ,_gfgc string )Positioning {_ef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bceb ,_gfgc );
_dbgae :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_gfgc ];return _dbgae ;};func (_bdab *GraphicSVGElement )drawPath (_fefaa *_ebf .ContentCreator ,_ceddg *_gf .PdfPageResources ){_fefaa .Add_q ();
_bdab .Style .toContentStream (_fefaa ,_ceddg ,_bdab );_ebcc (_bdab ,_fefaa );_decaf ,_dbeeg :=_dbagb (_bdab .Attributes ["\u0064"]);if _dbeeg !=nil {_ef .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025s",_dbeeg .Error ());};var (_gfcbf ,_afdg =0.0,0.0;
_eafag ,_fafc =0.0,0.0;_gdea *Command ;);for _ ,_caaac :=range _decaf .Subpaths {for _ ,_bbge :=range _caaac .Commands {switch _b .ToLower (_bbge .Symbol ){case "\u006d":_eafag ,_fafc =_bbge .Params [0]*_bdab ._bcae ,_bbge .Params [1]*_bdab ._bcae ;if !_bbge .isAbsolute (){_eafag ,_fafc =_gfcbf +_eafag -_bdab .ViewBox .X ,_afdg +_fafc -_bdab .ViewBox .Y ;
};_fefaa .Add_m (_eca .RoundFloat (_eafag ,3),_eca .RoundFloat (_fafc ,3));_gfcbf ,_afdg =_eafag ,_fafc ;case "\u0063":_gafg ,_dbecc ,_gddfa ,_agbd ,_cafe ,_bfcee :=_bbge .Params [0]*_bdab ._bcae ,_bbge .Params [1]*_bdab ._bcae ,_bbge .Params [2]*_bdab ._bcae ,_bbge .Params [3]*_bdab ._bcae ,_bbge .Params [4]*_bdab ._bcae ,_bbge .Params [5]*_bdab ._bcae ;
if !_bbge .isAbsolute (){_gafg ,_dbecc ,_gddfa ,_agbd ,_cafe ,_bfcee =_gfcbf +_gafg ,_afdg +_dbecc ,_gfcbf +_gddfa ,_afdg +_agbd ,_gfcbf +_cafe ,_afdg +_bfcee ;};_fefaa .Add_c (_eca .RoundFloat (_gafg ,3),_eca .RoundFloat (_dbecc ,3),_eca .RoundFloat (_gddfa ,3),_eca .RoundFloat (_agbd ,3),_eca .RoundFloat (_cafe ,3),_eca .RoundFloat (_bfcee ,3));
_gfcbf ,_afdg =_cafe ,_bfcee ;case "\u0073":_bbbff ,_gaef ,_beabf ,_cdcc :=_bbge .Params [0]*_bdab ._bcae ,_bbge .Params [1]*_bdab ._bcae ,_bbge .Params [2]*_bdab ._bcae ,_bbge .Params [3]*_bdab ._bcae ;if !_bbge .isAbsolute (){_bbbff ,_gaef ,_beabf ,_cdcc =_gfcbf +_bbbff ,_afdg +_gaef ,_gfcbf +_beabf ,_afdg +_cdcc ;
};_fefaa .Add_c (_eca .RoundFloat (_gfcbf ,3),_eca .RoundFloat (_afdg ,3),_eca .RoundFloat (_bbbff ,3),_eca .RoundFloat (_gaef ,3),_eca .RoundFloat (_beabf ,3),_eca .RoundFloat (_cdcc ,3));_gfcbf ,_afdg =_beabf ,_cdcc ;case "\u006c":_ccgaa ,_gced :=_bbge .Params [0]*_bdab ._bcae ,_bbge .Params [1]*_bdab ._bcae ;
if !_bbge .isAbsolute (){_ccgaa ,_gced =_gfcbf +_ccgaa ,_afdg +_gced ;};_fefaa .Add_l (_eca .RoundFloat (_ccgaa ,3),_eca .RoundFloat (_gced ,3));_gfcbf ,_afdg =_ccgaa ,_gced ;case "\u0068":_bebaaa :=_bbge .Params [0]*_bdab ._bcae ;if !_bbge .isAbsolute (){_bebaaa =_gfcbf +_bebaaa ;
};_fefaa .Add_l (_eca .RoundFloat (_bebaaa ,3),_eca .RoundFloat (_afdg ,3));_gfcbf =_bebaaa ;case "\u0076":_gdcda :=_bbge .Params [0]*_bdab ._bcae ;if !_bbge .isAbsolute (){_gdcda =_afdg +_gdcda ;};_fefaa .Add_l (_eca .RoundFloat (_gfcbf ,3),_eca .RoundFloat (_gdcda ,3));
_afdg =_gdcda ;case "\u0071":_ebag ,_dfdce ,_aefgg ,_beaee :=_bbge .Params [0]*_bdab ._bcae ,_bbge .Params [1]*_bdab ._bcae ,_bbge .Params [2]*_bdab ._bcae ,_bbge .Params [3]*_bdab ._bcae ;if !_bbge .isAbsolute (){_ebag ,_dfdce ,_aefgg ,_beaee =_gfcbf +_ebag ,_afdg +_dfdce ,_gfcbf +_aefgg ,_afdg +_beaee ;
};_gaeaa ,_acdag :=_ba .QuadraticToCubicBezier (_gfcbf ,_afdg ,_ebag ,_dfdce ,_aefgg ,_beaee );_fefaa .Add_c (_eca .RoundFloat (_gaeaa .X ,3),_eca .RoundFloat (_gaeaa .Y ,3),_eca .RoundFloat (_acdag .X ,3),_eca .RoundFloat (_acdag .Y ,3),_eca .RoundFloat (_aefgg ,3),_eca .RoundFloat (_beaee ,3));
_gfcbf ,_afdg =_aefgg ,_beaee ;case "\u0074":var _gbcfc ,_afced _ba .Point ;_eeeed ,_bfceeg :=_bbge .Params [0]*_bdab ._bcae ,_bbge .Params [1]*_bdab ._bcae ;if !_bbge .isAbsolute (){_eeeed ,_bfceeg =_gfcbf +_eeeed ,_afdg +_bfceeg ;};if _gdea !=nil &&_b .ToLower (_gdea .Symbol )=="\u0071"{_afecf :=_ba .Point {X :_gdea .Params [0]*_bdab ._bcae ,Y :_gdea .Params [1]*_bdab ._bcae };
_bfgc :=_ba .Point {X :_gdea .Params [2]*_bdab ._bcae ,Y :_gdea .Params [3]*_bdab ._bcae };_afdaf :=_bfgc .Mul (2.0).Sub (_afecf );_gbcfc ,_afced =_ba .QuadraticToCubicBezier (_gfcbf ,_afdg ,_afdaf .X ,_afdaf .Y ,_eeeed ,_bfceeg );};_fefaa .Add_c (_eca .RoundFloat (_gbcfc .X ,3),_eca .RoundFloat (_gbcfc .Y ,3),_eca .RoundFloat (_afced .X ,3),_eca .RoundFloat (_afced .Y ,3),_eca .RoundFloat (_eeeed ,3),_eca .RoundFloat (_bfceeg ,3));
_gfcbf ,_afdg =_eeeed ,_bfceeg ;case "\u0061":_dccde ,_bgdee :=_bbge .Params [0]*_bdab ._bcae ,_bbge .Params [1]*_bdab ._bcae ;_cdbed :=_bbge .Params [2];_dacfb :=_bbge .Params [3]> 0;_ddab :=_bbge .Params [4]> 0;_fcgba ,_bbdag :=_bbge .Params [5]*_bdab ._bcae ,_bbge .Params [6]*_bdab ._bcae ;
if !_bbge .isAbsolute (){_fcgba ,_bbdag =_gfcbf +_fcgba ,_afdg +_bbdag ;};_ggeee :=_ba .EllipseToCubicBeziers (_gfcbf ,_afdg ,_dccde ,_bgdee ,_cdbed ,_dacfb ,_ddab ,_fcgba ,_bbdag );for _ ,_gbde :=range _ggeee {_fefaa .Add_c (_eca .RoundFloat (_gbde [1].X ,3),_eca .RoundFloat ((_gbde [1].Y ),3),_eca .RoundFloat ((_gbde [2].X ),3),_eca .RoundFloat ((_gbde [2].Y ),3),_eca .RoundFloat ((_gbde [3].X ),3),_eca .RoundFloat ((_gbde [3].Y ),3));
};_gfcbf ,_afdg =_fcgba ,_bbdag ;case "\u007a":_fefaa .Add_h ();};_gdea =_bbge ;};};_bdab .Style .fillStroke (_fefaa );_fefaa .Add_h ();_fefaa .Add_Q ();};

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_gdgfb *Table )SetCompactMode (enable bool ){_gdgfb ._gdbd =enable };func (_eddgg *GridCell )height (_aade float64 )float64 {var _dbaa float64 ;switch _eecg :=_eddgg ._bcfd .(type ){case *Paragraph :if _eecg ._daabg {_eecg .SetWidth (_aade -_eddgg ._bcbg -_eecg ._ecdf .Left -_eecg ._ecdf .Right );
};_dbaa =_eecg .Height ()+_eecg ._ecdf .Top +_eecg ._ecdf .Bottom ;case *StyledParagraph :if _eecg ._ffeac {_eecg .SetWidth (_aade -_eddgg ._bcbg -_eecg ._dbge .Left -_eecg ._dbge .Right );};_dbaa =_eecg .Height ()+_eecg ._dbge .Top +_eecg ._dbge .Bottom ;
case *Image :_eecg .applyFitMode (_aade -_eddgg ._bcbg );_dbaa =_eecg .Height ()+_eecg ._gdgbd .Top +_eecg ._gdgbd .Bottom ;case *Table :_eecg .updateRowHeights (_aade -_eddgg ._bcbg -_eecg ._efdf .Left -_eecg ._efdf .Right );_dbaa =_eecg .Height ()+_eecg ._efdf .Top +_eecg ._efdf .Bottom ;
case *List :_dbaa =_eecg .ctxHeight (_aade -_eddgg ._bcbg )+_eecg ._caba .Top +_eecg ._caba .Bottom ;case *Division :_dbaa =_eecg .ctxHeight (_aade -_eddgg ._bcbg )+_eecg ._ffd .Top +_eecg ._ffd .Bottom +_eecg ._aeg .Top +_eecg ._aeg .Bottom ;case *Chart :_dbaa =_eecg .Height ()+_eecg ._bade .Top +_eecg ._bade .Bottom ;
case *Rectangle :_eecg .applyFitMode (_aade -_eddgg ._bcbg );_dbaa =_eecg .Height ()+_eecg ._ccafa .Top +_eecg ._ccafa .Bottom +_eecg ._daegc ;case *Ellipse :_eecg .applyFitMode (_aade -_eddgg ._bcbg );_dbaa =_eecg .Height ()+_eecg ._caace .Top +_eecg ._caace .Bottom ;
case *Line :_dbaa =_eecg .Height ()+_eecg ._dfbfa .Top +_eecg ._dfbfa .Bottom ;};return _dbaa ;};

// NewCurvePolygon creates a new curve polygon.
func (_cbdc *Creator )NewCurvePolygon (rings [][]_dd .CubicBezierCurve )*CurvePolygon {return _gab (rings );};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_gae *Creator )Flip (flipH ,flipV bool )error {_bbad :=_gae .getActivePage ();if _bbad ==nil {return _g .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_bbab ,_cbef :=_gae ._abge [_bbad ];if !_cbef {_bbab =&pageTransformations {};
_gae ._abge [_bbad ]=_bbab ;};_bbab ._dffe =flipH ;_bbab ._cfef =flipV ;return nil ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_cefga *shading )SetBackgroundColor (backgroundColor Color ){_cefga ._egdad =backgroundColor };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};type templateProcessor struct{creator *Creator ;_dgac []byte ;_caaec *TemplateOptions ;_ffeca componentRenderer ;_ceeff string ;};func _bbgbd (_eefb *templateProcessor ,_eabe *templateNode )(interface{},error ){return _eefb .parsePageBreak (_eabe );
};

// Reset removes all the text chunks the paragraph contains.
func (_afbdf *StyledParagraph )Reset (){_afbdf ._gbbce =[]*TextChunk {}};func _geeef (_dfceb ,_gffbgc ,_eeffd ,_caed float64 )*Rectangle {return &Rectangle {_acaf :_dfceb ,_dgec :_gffbgc ,_egdeb :_eeffd ,_ebef :_caed ,_gbbdg :PositionAbsolute ,_dgaab :1.0,_agbbe :ColorBlack ,_daegc :1.0,_cgdba :1.0};
};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_geec *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_geec ._aadcb =&_gf .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func (_ccafaf *templateProcessor )parseTextAlignmentAttr (_gbeb ,_daffad string )TextAlignment {_ef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gbeb ,_daffad );
_fbbac :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_daffad ];
return _fbbac ;};

// ClearAnnotations clears any existing annotations.
func (_ddedd *TextChunk )ClearAnnotations (){_ddedd ._cgbff =[]*_gf .PdfAnnotation {}};

// SetWidthTop sets border width for top.
func (_cedd *border )SetWidthTop (bw float64 ){_cedd ._ggc =bw };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_fceff *Creator )AddPage (page *_gf .PdfPage )error {if _fceff .AutofixPageContentStream {_ecde ,_bcgc :=_fceff .wrapPageIfNeeded (page );if _bcgc !=nil {return _bcgc ;};if _ecde !=nil {page =_ecde ;};};_dffed ,_gdbe :=page .GetMediaBox ();if _gdbe !=nil {_ef .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_gdbe );
return _gdbe ;};_dffed .Normalize ();_ffgf ,_efb :=_dffed .Llx ,_dffed .Lly ;_febga :=_dffed ;if _acdg :=page .CropBox ;_acdg !=nil &&*_acdg !=*_dffed {_acdg .Normalize ();_ffgf ,_efb =_acdg .Llx ,_acdg .Lly ;_febga =_acdg ;};_cggga :=_ee .IdentityMatrix ();
_fafb ,_gdbe :=page .GetRotate ();if _gdbe !=nil {_ef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_gdbe .Error ());
};_gadc :=_fafb %360!=0&&_fafb %90==0;if _gadc {_gcdb :=float64 ((360+_fafb %360)%360);switch _gcdb {case 90:_cggga =_cggga .Translate (_febga .Width (),0);case 180:_cggga =_cggga .Translate (_febga .Width (),_febga .Height ());case 270:_cggga =_cggga .Translate (0,_febga .Height ());
};_cggga =_cggga .Mult (_ee .RotationMatrix (_gcdb *_fb .Pi /180));_cggga =_cggga .Round (0.000001);_eebg :=_bdgd (_febga ,_cggga );_febga =_eebg ;_febga .Normalize ();};if _ffgf !=0||_efb !=0{_cggga =_ee .TranslationMatrix (_ffgf ,_efb ).Mult (_cggga );
};if !_cggga .Identity (){_cggga =_cggga .Round (0.000001);_fceff ._abge [page ]=&pageTransformations {_gef :&_cggga };};_fceff ._gaa =_febga .Width ();_fceff ._dag =_febga .Height ();_fceff .initContext ();_fceff ._cbf =append (_fceff ._cbf ,page );_fceff ._fcba .Page ++;
return nil ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_dbg :_fb .Min (float64 (c ),100)/100.0,_dcg :_fb .Min (float64 (m ),100)/100.0,_acag :_fb .Min (float64 (y ),100)/100.0,_fgae :_fb .Min (float64 (k ),100)/100.0};};

// GeneratePageBlocks generates the grid page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_dgcc *Grid )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bgece []*Block ;_cfcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dgcc .updateRowHeights (ctx .Width -_dgcc ._fabef .Left -_dgcc ._fabef .Right );_ccae :=_dgcc ._fabef .Top ;
_faec :=ctx ;if _dgcc ._gbfc .IsAbsolute (){ctx .X =_dgcc ._afcf ;ctx .Y =_dgcc ._aege ;}else {ctx .X +=_dgcc ._fabef .Left ;ctx .Y +=_ccae ;ctx .Width -=_dgcc ._fabef .Left +_dgcc ._fabef .Right ;ctx .Height -=_ccae ;};_aabec :=ctx .Width ;_adaff :=ctx .X ;
_ffc :=ctx .Y ;_agac :=ctx .Height ;var (_cgfd =0;_eeedc =false ;_fadc int64 ;_bfbbb *_gf .KDict ;_fggb =GridRowSectionUnknown ;_gagf =_dgcc ._febd !=nil &&_dgcc ._febd .ApplyTag ;);if _gagf {_aacae (_cfcg ,_dgcc ._febd );_fadc =_dgcc ._febd .Mcid +1;_bfbbb =_dgcc ._febd .ComponentKObj ;
};for _egfg :=0;_egfg < len (_dgcc ._fdagc );_egfg ++{_ccga :=_dgcc ._fdagc [_egfg ];if _gagf {if _fggb !=_ccga ._ddce {if _fggb !=GridRowSectionUnknown {_bfbfd (_cfcg );};_fggb =_ccga ._ddce ;_bfbbb =_dgcc .addSectionTag (_fggb );_aacae (_cfcg ,&_gf .StructureTagInfo {Mcid :_fadc ,StructureType :_bbef [_fggb ]});
_fadc ++;};_fcdce :=_gf .StructureTypeTableRow ;_aacae (_cfcg ,&_gf .StructureTagInfo {Mcid :_fadc ,StructureType :_fcdce });_ccga .AddTag (_bfbbb );_fadc ++;};_gbae :=float64 (0.0);for _badgf :=_cgfd ;_badgf < _ccga ._fbagff ;_badgf ++{_gbae +=_dgcc ._fdagc [_badgf ]._cedeg ;
};ctx .Height =_agac -_gbae ;if _eeedc {_bgece =append (_bgece ,_cfcg );_cfcg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_adaff =ctx .Margins .Left +_dgcc ._fabef .Left ;_ffc =ctx .Margins .Top ;ctx .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
ctx .Page ++;_agac =ctx .Height ;_cgfd =_egfg ;_gbae =0;_eeedc =false ;};if _ccga ._cedeg > ctx .Height {_faba :=_dgcc .cloneRow (_ccga ._fbagff );_aefg :=false ;for _fece ,_gfgae :=range _ccga ._cffad {switch _ecc :=_gfgae ._bcfd .(type ){case *StyledParagraph :_cfbd :=ctx ;
_cfbd .Height =_fb .Floor (ctx .Height -_ecc ._dbge .Top -_ecc ._dbge .Bottom -0.5*_ecc .getTextHeight ());_cefc ,_decac ,_eafa :=_ecc .split (_cfbd );if _eafa !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eafa );};if _cefc !=nil &&_decac !=nil &&_faba !=nil {_gfgae .SetContent (_cefc );
_faba ._cffad [_fece ].SetContent (_decac );_aefg =true ;};case *Division :_bgef :=ctx ;_bgef .Height =_fb .Floor (ctx .Height -_ecc ._ffd .Top -_ecc ._ffd .Bottom );_afgbd ,_cbefa :=_ecc .split (_bgef );if _afgbd !=nil &&_cbefa !=nil &&_faba !=nil {_gfgae .SetContent (_afgbd );
_faba ._cffad [_fece ].SetContent (_cbefa );_aefg =true ;};case *List :_gfdf :=ctx ;_gfdf .Height =_fb .Floor (ctx .Height -_ecc ._caba .Vertical ());_bbdf ,_ddbfg :=_ecc .split (_gfdf );if _bbdf !=nil &&_ddbfg !=nil &&_faba !=nil {_gfgae .SetContent (_bbdf );
_faba ._cffad [_fece ].SetContent (_ddbfg );_aefg =true ;};};};_eeedc =true ;if _aefg {_dgcc .insertRowAfter (_ccga ._fbagff ,_faba );_ccga .updateRowHeight (_aabec );_faba .updateRowHeight (_aabec );}else {_egfg -=1;continue ;};};for _ ,_cecb :=range _ccga ._cffad {var _ggde *_gf .KDict ;
if _gagf {_cecb .SetMarkedContentID (_fadc );_fgggd :=_gf .StructureTypeTableData ;if _ccga .IsHeader (){_fgggd =_gf .StructureTypeTableHeaderCell ;};_cecb .SetStructureType (_fgggd );_aacae (_cfcg ,&_gf .StructureTagInfo {Mcid :_fadc ,StructureType :_fgggd });
_ggde =_gf .NewKDictionary ();_ggde .S =_cd .MakeName (string (_fgggd ));_bccd :=_gf .NewKValue ();_bccd .SetMCID (int (_fadc ));_ggde .AddChild (_bccd );_ccga ._baab .ComponentKObj .AddKChild (_ggde );_fadc ++;};_fbec :=_cecb .width (_dgcc ._ccaa ,_aabec );
_eaad :=float64 (0.0);for _gcaf :=0;_gcaf < _cecb ._ecabf ;_gcaf ++{_eaad +=_dgcc ._ccaa [_gcaf ]*_aabec ;};_fegc :=float64 (0.0);for _fgeg :=0;_fgeg < _cecb ._fagfe ;_fgeg ++{_fegc +=_dgcc ._fdagc [_cecb ._cbbe +_fgeg ]._cedeg ;};ctx .Width =_fbec ;ctx .X =_adaff +_eaad ;
ctx .Y =_ffc +_gbae ;_ccdf :=_bbe (ctx .X ,ctx .Y ,_fbec ,_fegc );if _cecb ._gcbd !=nil {_ccdf .SetFillColor (_cecb ._gcbd );};_ccdf .SetOpacity (_cecb ._ccfb );_ccdf .LineStyle =_cecb ._gcff ;_ccdf ._dab =_cecb ._beddg ;_ccdf ._gdb =_cecb ._cgcb ;_ccdf ._aff =_cecb ._cddd ;
_ccdf ._cbc =_cecb ._abeb ;if _cecb ._fceb !=nil {_ccdf .SetColorLeft (_cecb ._fceb );};if _cecb ._ggbe !=nil {_ccdf .SetColorBottom (_cecb ._ggbe );};if _cecb ._bdgae !=nil {_ccdf .SetColorRight (_cecb ._bdgae );};if _cecb ._eeff !=nil {_ccdf .SetColorTop (_cecb ._eeff );
};_ccdf .SetWidthBottom (_cecb ._gafdd );_ccdf .SetWidthLeft (_cecb ._ffegf );_ccdf .SetWidthRight (_cecb ._caeea );_ccdf .SetWidthTop (_cecb ._cbde );_cbgd :=_cfcg .Draw (_ccdf );if _cbgd !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cbgd );
};if _cecb ._bcfd !=nil {_aegee :=_cecb ._bcfd .Width ();_geee :=_cecb ._bcfd .Height ();_aegee ,_geee ,_edbea ,_dgeg ,_cgcg ,_dabc :=_fbgec (_cecb ._bcfd ,_aegee ,_geee ,_cecb ._efbg ,false ,_ggde ,_fadc ,_fbec );if _dabc !=nil {return nil ,ctx ,_dabc ;
};if _dgeg !=nil {if !_cgcg {_ggde .AddKChild (_dgeg );};_fadc ++;};switch _cecb ._cffd {case CellHorizontalAlignmentLeft :ctx .X +=_cecb ._bcbg ;ctx .Width -=_cecb ._bcbg ;case CellHorizontalAlignmentCenter :if _aabeca :=_fbec -_aegee ;_aabeca > 0{ctx .X +=_aabeca /2;
ctx .Width -=_aabeca /2;};case CellHorizontalAlignmentRight :if _fbec > _aegee {ctx .X =ctx .X +_fbec -_aegee -_cecb ._bcbg ;ctx .Width -=_cecb ._bcbg ;};};_babg :=ctx .Y ;_bbeg :=ctx .Height ;ctx .Y +=_edbea ;switch _cecb ._efbg {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _aabd :=_fegc -_geee ;
_aabd > 0{ctx .Y +=_aabd /2;ctx .Height -=_aabd /2;};case CellVerticalAlignmentBottom :if _fegc > _geee {ctx .Y =ctx .Y +_fegc -_geee ;ctx .Height =_fegc ;};};_dabc =_cfcg .DrawWithContext (_cecb ._bcfd ,ctx );if _dabc !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dabc );
};ctx .Y =_babg ;ctx .Height =_bbeg ;};if _gagf {_bfbfd (_cfcg );};};ctx .Y +=_ccga ._cedeg ;if _gagf {_bfbfd (_cfcg );};};if _gagf {if _fggb !=GridRowSectionUnknown {_bfbfd (_cfcg );};_bfbfd (_cfcg );};_bgece =append (_bgece ,_cfcg );if _dgcc ._gbfc .IsAbsolute (){return _bgece ,_faec ,nil ;
};ctx .X =_faec .X ;ctx .Width =_faec .Width ;ctx .Y +=_dgcc ._fabef .Bottom ;ctx .Height -=_dgcc ._fabef .Bottom ;return _bgece ,ctx ,nil ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_gadf *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _acgb (colorPoints );};

// EnableTextShaping enables or disables advanced text shaping for the paragraph.
//
// This only has effect if the fonts used in the paragraph support text shaping (OTF fonts).
// Advanced text shaping is useful for rendering complex scripts, ligatures,
// and proper character positioning.
//
// By default, text shaping is disabled.
func (_ccdc *StyledParagraph )EnableTextShaping (enable bool ){_ccdc ._acgf =enable };func (_fcefgb *templateProcessor )parseBoolAttr (_fdgac ,_debgc string )bool {_ef .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_fdgac ,_debgc );
_agbda ,_ :=_ca .ParseBool (_debgc );return _debgc ==""||_agbda ;};func _faecf (_befa []*_gf .PdfAnnotation )[]*_gf .PdfAnnotation {var _bafbc []*_gf .PdfAnnotation ;for _ ,_cdff :=range _befa {_bafbc =append (_bafbc ,_gdbbd (_cdff ));};return _bafbc ;
};

// NewImage create a new image from a unidoc image (model.Image).
func (_bdbc *Creator )NewImage (img *_gf .Image )(*Image ,error ){return _dgf (img )};

// Title returns the title of the invoice.
func (_abdc *Invoice )Title ()string {return _abdc ._eebfb };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{taggedDrawable ;_gbba float64 ;_dfag float64 ;_bada float64 ;_bbacd float64 ;_fgbd Color ;_gcgff _dd .LineStyle ;_caabd float64 ;_gddg []int64 ;_edaa int64 ;_gfbf float64 ;_fbdb Positioning ;_gcfg FitMode ;_dfbfa Margins ;};func (_dbfe *GraphicSVGElement )drawCircle (_fgce *_ebf .ContentCreator ,_baefg *_gf .PdfPageResources ){_fgce .Add_q ();
_dbfe .Style .toContentStream (_fgce ,_baefg ,_dbfe );_ecacf ,_egdgb :=_fgde (_dbfe .Attributes ["\u0063\u0078"],64);if _egdgb !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_egdgb .Error ());
};_acdaa ,_egdgb :=_fgde (_dbfe .Attributes ["\u0063\u0079"],64);if _egdgb !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_egdgb .Error ());
};_gbff ,_egdgb :=_fgde (_dbfe .Attributes ["\u0072"],64);if _egdgb !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0072\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_egdgb .Error ());
};_cgfbe :=_gbff *_dbfe ._bcae ;_gbag :=_gbff *_dbfe ._bcae ;_aabfb :=_cgfbe *_bdfb ;_bffgc :=_gbag *_bdfb ;_bcdg :=_dd .NewCubicBezierPath ();_bcdg =_bcdg .AppendCurve (_dd .NewCubicBezierCurve (-_cgfbe ,0,-_cgfbe ,_bffgc ,-_aabfb ,_gbag ,0,_gbag ));_bcdg =_bcdg .AppendCurve (_dd .NewCubicBezierCurve (0,_gbag ,_aabfb ,_gbag ,_cgfbe ,_bffgc ,_cgfbe ,0));
_bcdg =_bcdg .AppendCurve (_dd .NewCubicBezierCurve (_cgfbe ,0,_cgfbe ,-_bffgc ,_aabfb ,-_gbag ,0,-_gbag ));_bcdg =_bcdg .AppendCurve (_dd .NewCubicBezierCurve (0,-_gbag ,-_aabfb ,-_gbag ,-_cgfbe ,-_bffgc ,-_cgfbe ,0));_bcdg =_bcdg .Offset (_ecacf *_dbfe ._bcae ,_acdaa *_dbfe ._bcae );
if _dbfe .Style .StrokeWidth > 0{_bcdg =_bcdg .Offset (_dbfe .Style .StrokeWidth /2,_dbfe .Style .StrokeWidth /2);};_dd .DrawBezierPathWithCreator (_bcdg ,_fgce );_dbfe .Style .fillStroke (_fgce );_fgce .Add_h ();_fgce .Add_Q ();};

// LinkTagOptions represents optional parameters for tagged link annotations,
// providing flexibility for adding accessibility features.
type LinkTagOptions struct{

// MCID is the marked content identifier for structure tree association
MCID int64 ;

// AltText is alternative text for screen readers (only used if different from visible text)
AltText string ;

// Tooltip sets the annotation's Contents field (tooltip on hover)
Tooltip string ;};

// NewTable create a new Table with a specified number of columns.
func (_ccbf *Creator )NewTable (cols int )*Table {return _aggeg (cols )};func (_aabdd *templateProcessor )parseList (_gfcdf *templateNode )(interface{},error ){_fegba :=_aabdd .creator .NewList ();for _ ,_ccfe :=range _gfcdf ._fdbe .Attr {_cafag :=_ccfe .Value ;
switch _ebggg :=_ccfe .Name .Local ;_ebggg {case "\u0069\u006e\u0064\u0065\u006e\u0074":_fegba .SetIndent (_aabdd .parseFloatAttr (_ebggg ,_cafag ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dbad :=_aabdd .parseMarginAttr (_ebggg ,_cafag );_fegba .SetMargins (_dbad .Left ,_dbad .Right ,_dbad .Top ,_dbad .Bottom );
default:_aabdd .nodeLogDebug (_gfcdf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ebggg );
};};return _fegba ,nil ;};func (_aabe *GraphicSVGElement )processDefs (){_aabe ._abca =make (map[string ]*LinearShading );_aabe ._ceefd =make (map[string ]*RadialShading );for _ ,_dedb :=range _aabe .Children {if _dedb .Name =="\u0064\u0065\u0066\u0073"{for _ ,_cdg :=range _dedb .Children {switch _cdg .Name {case "\u006c\u0069\u006e\u0065\u0061\u0072\u0047\u0072\u0061d\u0069\u0065\u006e\u0074":_afef :=_cdg .Attributes ["\u0069\u0064"];
_bfdb :=_cdg .parseColorPoints ();_geae :=_acgb (_bfdb );_ceac :=_cdg .getGradientAngle ();_geae .SetAngle (-_ceac );_geae .SetExtends (true ,true );_geae .SetBoundingBox (0,0,_aabe .Width ,_aabe .Height );_aabe ._abca [_afef ]=_geae ;case "\u0072\u0061\u0064\u0069\u0061\u006c\u0047\u0072\u0061d\u0069\u0065\u006e\u0074":_eged :=_cdg .Attributes ["\u0069\u0064"];
_aegg :=_cdg .parseColorPoints ();_agcb :=_afae (_aabe ._fddeg ,_aabe .ViewBox .H ,0,_fb .Min (_aabe .Width ,_aabe .Height )/2,_aegg );_agcb .SetExtends (true ,true );_agcb .SetBoundingBox (0,0,_aabe .Width ,_aabe .Height );_aabe ._ceefd [_eged ]=_agcb ;
};};};};};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_aegd *Line )SetPositioning (positioning Positioning ){_aegd ._fbdb =positioning };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_dfeb *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_ffcd :=NewTextChunk (text ,_dfeb ._eeeag );_ffcd .AddAnnotation (_ffbcd (page -1,x ,y ,zoom ,""));return _dfeb .appendChunk (_ffcd );};func _dgge (_aaab []byte )(*Image ,error ){_gbee :=_c .NewReader (_aaab );
_efbc ,_defc :=_gf .ImageHandling .Read (_gbee );if _defc !=nil {_ef .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_defc );return nil ,_defc ;};return _dgf (_efbc );
};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_dacce *Table )MultiRowCell (rowspan int )*TableCell {return _dacce .MultiCell (rowspan ,1)};func (_agbe *Invoice )generateLineBlocks (_cfcba DrawContext )([]*Block ,DrawContext ,error ){_dcfcd :=_aggeg (len (_agbe ._ccgf ));_dcfcd .SetMargins (0,0,25,0);
for _ ,_ebgdb :=range _agbe ._ccgf {_defb :=_bgdc (_ebgdb .TextStyle );_defb .SetMargins (0,0,1,0);_defb .Append (_ebgdb .Value );_facd :=_dcfcd .NewCell ();_facd .SetHorizontalAlignment (_ebgdb .Alignment );_facd .SetBackgroundColor (_ebgdb .BackgroundColor );
_agbe .setCellBorder (_facd ,_ebgdb );_facd .SetContent (_defb );};for _ ,_eabf :=range _agbe ._dafad {for _ ,_abgg :=range _eabf {_ceeg :=_bgdc (_abgg .TextStyle );_ceeg .SetMargins (0,0,3,2);_ceeg .Append (_abgg .Value );_gcaa :=_dcfcd .NewCell ();_gcaa .SetHorizontalAlignment (_abgg .Alignment );
_gcaa .SetBackgroundColor (_abgg .BackgroundColor );_agbe .setCellBorder (_gcaa ,_abgg );_gcaa .SetContent (_ceeg );};};return _dcfcd .GeneratePageBlocks (_cfcba );};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_eddgf *StyledParagraph )Height ()float64 {_eddgf .wrapText ();var _aeca float64 ;for _ ,_babf :=range _eddgf ._aeggc {var _dagdg float64 ;for _ ,_egdf :=range _babf {_fcdca :=_eddgf ._edcb *_egdf .Style .FontSize ;if _fcdca > _dagdg {_dagdg =_fcdca ;
};};_aeca +=_dagdg ;};return _aeca ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_ecgd *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_bagbd :=&_ecgd ._eccb ._dbge ;return _ecgd ._gggea ,_bagbd .Right ,_bagbd .Top ,_bagbd .Bottom ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cabgb *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _cabgb ._dfad [0],_cabgb ._dfad [1]};func (_bged *templateProcessor )parseRadialGradientAttr (creator *Creator ,_fegbdb string )Color {_abfea :=ColorBlack ;if _fegbdb ==""{return _abfea ;
};var (_eeab error ;_cabfd =0.0;_eeabe =0.0;_fbbba =-1.0;_dcagf =_b .Split (_fegbdb [16:len (_fegbdb )-1],"\u002c"););_aafg :=_b .Fields (_dcagf [0]);if len (_aafg )==2&&_b .TrimSpace (_aafg [0])[0]!='#'{_cabfd ,_eeab =_ca .ParseFloat (_aafg [0],64);if _eeab !=nil {_ef .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_eeab );
};_eeabe ,_eeab =_ca .ParseFloat (_aafg [1],64);if _eeab !=nil {_ef .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_eeab );
};_dcagf =_dcagf [1:];};_cdfd :=_b .TrimSpace (_dcagf [0]);if _cdfd [0]!='#'{_fbbba ,_eeab =_ca .ParseFloat (_cdfd ,64);if _eeab !=nil {_ef .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_eeab );
};_dcagf =_dcagf [1:];};_bgaded ,_egeea :=_bged .processGradientColorPair (_dcagf );if _bgaded ==nil ||_egeea ==nil {return _abfea ;};_gabff :=creator .NewRadialGradientColor (_cabfd ,_eeabe ,0,_fbbba ,[]*ColorPoint {});for _debc :=0;_debc < len (_bgaded );
_debc ++{_gabff .AddColorStop (_bgaded [_debc ],_egeea [_debc ]);};return _gabff ;};func _badae (_ffaa *_ec .Decoder )(*GraphicSVGElement ,error ){for {_gbege ,_cgbgd :=_ffaa .Token ();if _gbege ==nil &&_cgbgd ==_fd .EOF {break ;};if _cgbgd !=nil {return nil ,_cgbgd ;
};switch _cdfe :=_gbege .(type ){case _ec .StartElement :return _gfcf (_cdfe ),nil ;};};return &GraphicSVGElement {},nil ;};func (_dffdd *Image )makeXObject ()error {_dbff ,_cbec :=_gf .NewXObjectImageFromImageLazy (_dffdd ._addd ,nil ,_dffdd ._dbfa ,_dffdd ._cbgdb );
if _cbec !=nil {_ef .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cbec );return _cbec ;};_dffdd ._bbcef =_dbff ;
return nil ;};

// SetFillColor sets the fill color.
func (_gbfed *Polygon )SetFillColor (color Color ){_gbfed ._dafec =color ;_gbfed ._fcfa .FillColor =_fbd (color );};

// AddTag adds the table tag to the root K object.
func (_cgfgb *Table )AddTag (rootKObj *_gf .KDict ){if rootKObj ==nil {_ef .Log .Debug ("\u0054\u0061\u0062\u006ce\u003a\u0020\u0041\u0064\u0064\u0054\u0061\u0067\u0020c\u0061\u006c\u006c\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u0069\u006c\u0020\u0072\u006f\u006ft\u004b\u004f\u0062\u006a\u002c \u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0074\u0061\u0067\u0067\u0069\u006e\u0067\u002e");
return ;};if _cgfgb ._febd ==nil {_cgfgb ._febd =_gf .NewStructureTagInfo ();_cgfgb ._febd .StructureType =_cgfgb ._gage ;};_cgfgb ._febd .ApplyTag =true ;_cgfgb ._febd .ParentKObj =rootKObj ;_cgfgb ._febd .ComponentKObj =_gf .NewKDictionary ();_cgfgb ._febd .ComponentKObj .S =_cd .MakeName (string (_cgfgb ._febd .StructureType ));
_cgfgb ._febd .ParentKObj .AddKChild (_cgfgb ._febd .ComponentKObj );};func _afdc (_gaff [][]_dd .Point )*Polygon {return &Polygon {_fcfa :&_dd .Polygon {Points :_gaff },_cccgd :1.0,_fafbf :1.0};};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_bfgdg *Invoice )Sections ()[][2]string {return _bfgdg ._ffbag };

// SetBorderColor sets the cell's border color.
func (_bceeb *TableCell )SetBorderColor (col Color ){_bceeb ._agfge =col ;_bceeb ._gdae =col ;_bceeb ._fcdd =col ;_bceeb ._dadeb =col ;};func _bfbfd (_bafgg *Block ){_ccced :=_ebf .NewContentCreator ();_ccced .Add_EMC ();_bafgg .addContents (_ccced .Operations ());
};func (_abbef *Invoice )generateHeaderBlocks (_ffdg DrawContext )([]*Block ,DrawContext ,error ){_fbcd :=_bgdc (_abbef ._cead );_fbcd .SetEnableWrap (true );_fbcd .Append (_abbef ._eebfb );_ffega :=_aggeg (2);if _abbef ._gffb !=nil {_ecaa :=_ffega .NewCell ();
_ecaa .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_ecaa .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ecaa .SetIndent (0);_ecaa .SetContent (_abbef ._gffb );_abbef ._gffb .ScaleToHeight (_fbcd .Height ()+20);}else {_ffega .SkipCells (1);
};_cgeae :=_ffega .NewCell ();_cgeae .SetHorizontalAlignment (CellHorizontalAlignmentRight );_cgeae .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cgeae .SetContent (_fbcd );return _ffega .GeneratePageBlocks (_ffdg );};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ad :=&Block {};_ad ._bac =&_ebf .ContentStreamOperations {};_ad ._ebe =_gf .NewPdfPageResources ();_ad ._ddf =width ;_ad ._geb =height ;return _ad ;};

// SetDropCapsFirstWord is a convenience method to set traditional drop caps
// on the first word of the paragraph.
//
// Example:
//
//	p := c.NewStyledParagraph()
//	p.SetText("CHAPTER ONE: It was the best of times...")
//	p.SetDropCapsFirstWord(3, 8.0) // "CHAPTER" spans 3 lines with 8pt gap
func (_bcbb *StyledParagraph )SetDropCapsFirstWord (numLines int ,gap float64 ){_bcbb .SetDropCaps (DropCapsOptions {Type :DropCapsDrop ,Scope :DropCapsFirstWord ,NumLines :numLines ,Gap :gap });};

// Notes returns the notes section of the invoice as a title-content pair.
func (_cbfa *Invoice )Notes ()(string ,string ){return _cbfa ._gebe [0],_cbfa ._gebe [1]};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_abgde *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _abgde ._gbba ,_abgde ._dfag ,_abgde ._bada ,_abgde ._bbacd ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_aaba :_fb .Max (_fb .Min (r ,1.0),0.0),_caef :_fb .Max (_fb .Min (g ,1.0),0.0),_dgc :_fb .Max (_fb .Min (b ,1.0),0.0)};};type shading struct{_egdad Color ;_fgad bool ;_defcc []bool ;
_fcefg []*ColorPoint ;};

// GetArtifact returns the artifact associated with the paragraph, if any.
func (_facae *StyledParagraph )GetArtifact ()*_gf .Artifact {return _facae ._ebff };

// MoveX moves the drawing context to absolute position x.
func (_bfeb *Creator )MoveX (x float64 ){_bfeb ._fcba .X =x };

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_febe *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _afae (x ,y ,innerRadius ,outerRadius ,colorPoints );};

// GetMargins returns the left, right, top, bottom Margins.
func (_gggb *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gggb ._efdf .Left ,_gggb ._efdf .Right ,_gggb ._efdf .Top ,_gggb ._efdf .Bottom ;};func _dcaa (_bdddd []token ,_dcedf string )([]token ,string ){if _dcedf !=""{_bdddd =append (_bdddd ,token {_dcedf ,false });
_dcedf ="";};return _bdddd ,_dcedf ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_ccag *Paragraph )SetMaxLines (maxLines int ){_ccag ._egfcd =maxLines ;_ccag .wrapText ()};func _ggab (_fded *GraphicSVGElement )(*GraphicSVG ,error ){return &GraphicSVG {_aagdf :_fded ,_daeg :PositionRelative ,_bbcd :Margins {Top :10,Bottom :10},taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeFigure }},nil ;
};

// NewPageBreak create a new page break.
func (_cabf *Creator )NewPageBreak ()*PageBreak {return _fbbb ()};

// Lines returns all the rows of the invoice line items table.
func (_ffec *Invoice )Lines ()[][]*InvoiceCell {return _ffec ._dafad };

// FitMode returns the fit mode of the rectangle.
func (_eaeef *Rectangle )FitMode ()FitMode {return _eaeef ._ffbcg };

// SetColorLeft sets border color for left.
func (_eaf *border )SetColorLeft (col Color ){_eaf ._ebcg =col };func _ggcg (_cfdcf map[string ]string ,_adfea float64 )(*GraphicSVGStyle ,error ){_ggfgf :=_gcdf ();_begb ,_dbag :=_cfdcf ["\u0066\u0069\u006c\u006c"];if _dbag {_ggfgf .FillColor =_begb ;
if _begb =="\u006e\u006f\u006e\u0065"{_ggfgf .FillColor ="";};};_fafbfa ,_fabde :=_cfdcf ["\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079"];if _fabde {_abeff ,_cfcdc :=_egcgf (_fafbfa );if _cfcdc !=nil {return nil ,_cfcdc ;};_ggfgf .FillOpacity =_abeff ;
};_fgcce ,_cdcf :=_cfdcf ["\u0073\u0074\u0072\u006f\u006b\u0065"];if _cdcf {_ggfgf .StrokeColor =_fgcce ;if _fgcce =="\u006e\u006f\u006e\u0065"{_ggfgf .StrokeColor ="";};};_fbbd ,_ecagde :=_cfdcf ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
if _ecagde {_edecd ,_edfed :=_fgde (_fbbd ,64);if _edfed !=nil {return nil ,_edfed ;};_ggfgf .StrokeWidth =_edecd *_adfea ;};return _ggfgf ,nil ;};func (_gbfdbb *templateProcessor )parseLine (_ddgdd *templateNode )(interface{},error ){_cgcbg :=_gbfdbb .creator .NewLine (0,0,0,0);
for _ ,_aeeca :=range _ddgdd ._fdbe .Attr {_gcaef :=_aeeca .Value ;switch _dadcfg :=_aeeca .Name .Local ;_dadcfg {case "\u0078\u0031":_cgcbg ._gbba =_gbfdbb .parseFloatAttr (_dadcfg ,_gcaef );case "\u0079\u0031":_cgcbg ._dfag =_gbfdbb .parseFloatAttr (_dadcfg ,_gcaef );
case "\u0078\u0032":_cgcbg ._bada =_gbfdbb .parseFloatAttr (_dadcfg ,_gcaef );case "\u0079\u0032":_cgcbg ._bbacd =_gbfdbb .parseFloatAttr (_dadcfg ,_gcaef );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_cgcbg .SetLineWidth (_gbfdbb .parseFloatAttr (_dadcfg ,_gcaef ));
case "\u0063\u006f\u006co\u0072":_cgcbg .SetColor (_gbfdbb .parseColorAttr (_dadcfg ,_gcaef ));case "\u0073\u0074\u0079l\u0065":_cgcbg .SetStyle (_gbfdbb .parseLineStyleAttr (_dadcfg ,_gcaef ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_cgcbg .SetDashPattern (_gbfdbb .parseInt64Array (_dadcfg ,_gcaef ),_cgcbg ._edaa );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_cgcbg .SetDashPattern (_cgcbg ._gddg ,_gbfdbb .parseInt64Attr (_dadcfg ,_gcaef ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_cgcbg .SetOpacity (_gbfdbb .parseFloatAttr (_dadcfg ,_gcaef ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_cgcbg .SetPositioning (_gbfdbb .parsePositioningAttr (_dadcfg ,_gcaef ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_cgcbg .SetFitMode (_gbfdbb .parseFitModeAttr (_dadcfg ,_gcaef ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_cgbea :=_gbfdbb .parseMarginAttr (_dadcfg ,_gcaef );_cgcbg .SetMargins (_cgbea .Left ,_cgbea .Right ,_cgbea .Top ,_cgbea .Bottom );default:_gbfdbb .nodeLogDebug (_ddgdd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dadcfg );
};};return _cgcbg ,nil ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_adf :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_ef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adf ;
};var _cgeb ,_fada ,_agca int ;if len (hexStr )==4{var _eeg ,_geeb ,_effb int ;_cggc ,_fcgf :=_e .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_eeg ,&_geeb ,&_effb );if _fcgf !=nil {_ef .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_fcgf );
return _adf ;};if _cggc !=3{_ef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adf ;};_cgeb =_eeg *16+_eeg ;_fada =_geeb *16+_geeb ;_agca =_effb *16+_effb ;}else {_aeeg ,_aac :=_e .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_cgeb ,&_fada ,&_agca );
if _aac !=nil {_ef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adf ;};if _aeeg !=3{_ef .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_aeeg );
return _adf ;};};_bgc :=float64 (_cgeb )/255.0;_dce :=float64 (_fada )/255.0;_ggg :=float64 (_agca )/255.0;_adf ._aaba =_bgc ;_adf ._caef =_dce ;_adf ._dgc =_ggg ;return _adf ;};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_daace *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fabea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gdff ,_efggf :=_fabea .setOpacity (_daace ._cccgd ,_daace ._fafbf );if _efggf !=nil {return nil ,ctx ,_efggf ;
};_egfe :=_daace ._fcfa ;_egfe .FillEnabled =_egfe .FillColor !=nil ;_egfe .BorderEnabled =_egfe .BorderColor !=nil &&_egfe .BorderWidth > 0;_bdcba :=_egfe .Points ;_dagfg :=_gf .PdfRectangle {};_ageb :=false ;for _ccfc :=range _bdcba {for _cecg :=range _bdcba [_ccfc ]{_dagg :=&_bdcba [_ccfc ][_cecg ];
_dagg .Y =ctx .PageHeight -_dagg .Y ;if !_ageb {_dagfg .Llx =_dagg .X ;_dagfg .Lly =_dagg .Y ;_dagfg .Urx =_dagg .X ;_dagfg .Ury =_dagg .Y ;_ageb =true ;}else {_dagfg .Llx =_fb .Min (_dagfg .Llx ,_dagg .X );_dagfg .Lly =_fb .Min (_dagfg .Lly ,_dagg .Y );
_dagfg .Urx =_fb .Max (_dagfg .Urx ,_dagg .X );_dagfg .Ury =_fb .Max (_dagfg .Ury ,_dagg .Y );};};};if _egfe .FillEnabled {_aacg :=_bdced (_fabea ,_daace ._fcfa .FillColor ,_daace ._dafec ,func ()Rectangle {return Rectangle {_acaf :_dagfg .Llx ,_dgec :_dagfg .Lly ,_egdeb :_dagfg .Width (),_ebef :_dagfg .Height ()};
});if _aacg !=nil {return nil ,ctx ,_aacg ;};};_geffd ,_ ,_efggf :=_egfe .MarkedDraw (_gdff ,_daace ._febd );if _efggf !=nil {return nil ,ctx ,_efggf ;};if _efggf =_fabea .addContentsByString (string (_geffd ));_efggf !=nil {return nil ,ctx ,_efggf ;};
return []*Block {_fabea },ctx ,nil ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_dggce *LinearShading )SetAntiAlias (enable bool ){_dggce ._beecg .SetAntiAlias (enable )};

// FitMode returns the fit mode of the image.
func (_fadd *Image )FitMode ()FitMode {return _fadd ._aeeb };func _dfgc (_gfede string )(float64 ,error ){_gfede =_b .TrimSpace (_gfede );var _fccdc float64 ;if _b .HasSuffix (_gfede ,"\u0025"){_ddca ,_babbe :=_ca .ParseFloat (_b .TrimSuffix (_gfede ,"\u0025"),64);
if _babbe !=nil {return 0,_babbe ;};_fccdc =(_ddca *255.0)/100.0;}else {_ccdgd ,_facbe :=_ca .Atoi (_gfede );if _facbe !=nil {return 0,_facbe ;};_fccdc =float64 (_ccdgd );};return _fccdc ,nil ;};

// SetAltText sets the alternative text for the text chunk.
func (_dbbbe *TextChunk )SetAltText (text string ){_dbbbe ._bdgga =&text };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_fccg *Creator )NewImageFromGoImage (goimg _da .Image )(*Image ,error ){return _ebba (goimg )};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_dbgg *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_ggge *Ellipse )FillOpacity ()float64 {return _ggge ._afgb };

// SetLevel sets the indentation level of the TOC line.
func (_dagfa *TOCLine )SetLevel (level uint ){_dagfa ._bacb =level ;_dagfa ._eccb ._dbge .Left =_dagfa ._gggea +float64 (_dagfa ._bacb -1)*_dagfa ._gdcafd ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fdfb *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fdfb ._ecdf .Left ,_fdfb ._ecdf .Right ,_fdfb ._ecdf .Top ,_fdfb ._ecdf .Bottom ;};func (_deef *Path )compare (_eeae *Path )bool {if len (_deef .Subpaths )!=len (_eeae .Subpaths ){return false ;
};for _abac ,_ffdde :=range _deef .Subpaths {if !_ffdde .compare (_eeae .Subpaths [_abac ]){return false ;};};return true ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_gdcc *Ellipse )Positioning ()Positioning {return _gdcc ._gfgfb };

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_dfdg *GraphicSVG )ScaleToHeight (h float64 ){_gacbe :=_dfdg ._aagdf .Width /_dfdg ._aagdf .Height ;_dfdg ._aagdf .Height =h ;_dfdg ._aagdf .Width =h *_gacbe ;_dfdg ._aagdf .SetScaling (_gacbe ,_gacbe );};

// GetHeight get the current height for the row.
func (_dcfb *GridRow )GetHeight ()float64 {return _dcfb ._bef };func (_eacd *Creator )initContext (){_eacd ._fcba .X =_eca .RoundDefault (_eacd ._feeg .Left );_eacd ._fcba .Y =_eca .RoundDefault (_eacd ._feeg .Top );_eacd ._fcba .Width =_eca .RoundDefault (_eacd ._gaa -_eacd ._feeg .Right -_eacd ._feeg .Left );
_eacd ._fcba .Height =_eca .RoundDefault (_eacd ._dag -_eacd ._feeg .Bottom -_eacd ._feeg .Top );_eacd ._fcba .PageHeight =_eca .RoundDefault (_eacd ._dag );_eacd ._fcba .PageWidth =_eca .RoundDefault (_eacd ._gaa );_eacd ._fcba .Margins =_eacd ._feeg ;
_eacd ._fcba ._deaaa =_eacd .UnsupportedCharacterReplacement ;};

// AssociateAnnotationWithStructure associates the given annotation with the text chunk's structure element.
// This is necessary for proper tag structure when using annotations in tagged PDFs.
func (_gcaeg *TextChunk )AssociateAnnotationWithStructure (annotation *_gf .PdfAnnotation ){if _gcaeg ._febd ==nil {_gcaeg ._febd =_gf .NewStructureTagInfo ();_gcaeg ._febd .StructureType =_gf .StructureTypeSpan ;};_acggg :=annotation .GetContainingPdfObject ();
_gcaeg ._febd .SetObjAttrib (_acggg );if _aaga ,_gcefg :=_cd .GetDict (_acggg );_gcefg {_aaga .Set ("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074",_cd .MakeInteger (_gcaeg ._febd .Mcid ));};};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_aaabc *Invoice )NoteStyle ()TextStyle {return _aaabc ._bddf };

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_geaa *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _baaa (xc ,yc ,width ,height );};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_bfgd *Creator )PageFinalize (pageFinalizeFunc func (_acdd PageFinalizeFunctionArgs )error ){_bfgd ._acbf =pageFinalizeFunc ;};

// Indent returns the left offset of the list when nested into another list.
func (_bdcd *List )Indent ()float64 {return _bdcd ._eafe };

// SetBorderColor sets border color of the rectangle.
func (_cgfgc *Rectangle )SetBorderColor (col Color ){_cgfgc ._agbbe =col };func (_dbbfc *StyledParagraph )addLine (_abgc []*TextChunk )bool {if _dbbfc ._bfgda > 0&&len (_dbbfc ._aeggc )+1>=_dbbfc ._bfgda {if len (_abgc )> 0{_dbbfc ._aeggc =append (_dbbfc ._aeggc ,_abgc );
};return false ;};_dbbfc ._aeggc =append (_dbbfc ._aeggc ,_abgc );return true ;};func _egcgf (_fbbg string )(float64 ,error ){_fbbg =_b .TrimSpace (_fbbg );var _gafeed float64 ;if _b .HasSuffix (_fbbg ,"\u0025"){_egcc ,_cfcde :=_ca .ParseFloat (_b .TrimSuffix (_fbbg ,"\u0025"),64);
if _cfcde !=nil {return 0,_cfcde ;};_gafeed =_egcc /100.0;}else {_fcdcdg ,_ddgac :=_ca .ParseFloat (_fbbg ,64);if _ddgac !=nil {return 0,_ddgac ;};_gafeed =_fcdcdg ;};return _gafeed ,nil ;};func (_ggbea *LinearShading )shadingModel ()*_gf .PdfShadingType2 {_bfgfa :=_dd .NewPoint (_ggbea ._aadcb .Llx +_ggbea ._aadcb .Width ()/2,_ggbea ._aadcb .Lly +_ggbea ._aadcb .Height ()/2);
_dbgc :=_dd .NewPoint (_ggbea ._aadcb .Llx ,_ggbea ._aadcb .Lly +_ggbea ._aadcb .Height ()/2).Add (-_bfgfa .X ,-_bfgfa .Y ).Rotate (_ggbea ._aecga ).Add (_bfgfa .X ,_bfgfa .Y );_dbgc =_dd .NewPoint (_fb .Max (_fb .Min (_dbgc .X ,_ggbea ._aadcb .Urx ),_ggbea ._aadcb .Llx ),_fb .Max (_fb .Min (_dbgc .Y ,_ggbea ._aadcb .Ury ),_ggbea ._aadcb .Lly ));
_adgdc :=_dd .NewPoint (_ggbea ._aadcb .Urx ,_ggbea ._aadcb .Lly +_ggbea ._aadcb .Height ()/2).Add (-_bfgfa .X ,-_bfgfa .Y ).Rotate (_ggbea ._aecga ).Add (_bfgfa .X ,_bfgfa .Y );_adgdc =_dd .NewPoint (_fb .Min (_fb .Max (_adgdc .X ,_ggbea ._aadcb .Llx ),_ggbea ._aadcb .Urx ),_fb .Min (_fb .Max (_adgdc .Y ,_ggbea ._aadcb .Lly ),_ggbea ._aadcb .Ury ));
_eaabe :=_gf .NewPdfShadingType2 ();_eaabe .ShadingType =_cd .MakeInteger (2);_eaabe .ColorSpace =_gf .NewPdfColorspaceDeviceRGB ();_eaabe .AntiAlias =_cd .MakeBool (_ggbea ._beecg ._fgad );_eaabe .Coords =_cd .MakeArrayFromFloats ([]float64 {_dbgc .X ,_dbgc .Y ,_adgdc .X ,_adgdc .Y });
_eaabe .Extend =_cd .MakeArray (_cd .MakeBool (_ggbea ._beecg ._defcc [0]),_cd .MakeBool (_ggbea ._beecg ._defcc [1]));_eaabe .Function =_ggbea ._beecg .generatePdfFunctions ();return _eaabe ;};var (_ecfa =[]string {"\u0063\u006d","\u006d\u006d","\u0070\u0078","\u0070\u0074"};
_ggaf =map[string ]float64 {"\u0063\u006d":_ggba ,"\u006d\u006d":_fecf ,"\u0070\u0078":_gfga ,"\u0070\u0074":1};);

// AddInternalLinkWithTag adds a new internal link to the paragraph with proper tagging for accessibility.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y coordinates.
// Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom parameter (0 keeps current zoom).
// The options parameter contains accessibility properties like tooltip, altText, and mcid.
func (_aafda *StyledParagraph )AddInternalLinkWithTag (text string ,page int64 ,x ,y ,zoom float64 ,options LinkTagOptions )(*TextChunk ,*_gf .KDict ){_dffc :=_ffbcd (page -1,x ,y ,zoom ,options .Tooltip );_abfeb ,_gcebd ,_gdbb :=_aafda .createAccessibleLinkChunk (text ,_dffc ,options );
if _gdbb !=nil {_ef .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0069\u006e\u0074\u0065\u0072n\u0061\u006c\u0020\u006c\u0069\u006e\u006b\u0020\u0077\u0069th\u0020\u0074\u0061g\u003a \u0025\u0076",_gdbb );
return nil ,nil ;};return _abfeb ,_gcebd ;};

// SellerAddress returns the seller address used in the invoice template.
func (_gebea *Invoice )SellerAddress ()*InvoiceAddress {return _gebea ._dfce };

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{taggedDrawable ;_gbbce []*TextChunk ;_dgaag TextStyle ;_eeeag TextStyle ;_abgad TextAlignment ;_bffb TextVerticalAlignment ;_edcb float64 ;_ffeac bool ;_ffdb float64 ;_fcgd bool ;_bfgda int ;_dddf bool ;_cgadg TextOverflow ;
_eagdd float64 ;_dbge Margins ;_ggdeb Positioning ;_bafb float64 ;_fcda float64 ;_bege float64 ;_bgce float64 ;_aeggc [][]*TextChunk ;_egdcf func (_bfacad *StyledParagraph ,_bfad DrawContext );_edbead string ;_ebff *_gf .Artifact ;_acgf bool ;_ceaf *DropCapsOptions ;
_bcfc bool ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_bfbb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _ddecc (number ,title ,page ,level ,style );};func (_acada *templateProcessor )parseBorderRadiusAttr (_baadc ,_badfg string )(_agbeb ,_dgaba ,_acdeg ,_ddeea float64 ){_ef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_baadc ,_badfg );
switch _deda :=_b .Fields (_badfg );len (_deda ){case 1:_agbeb ,_ =_ca .ParseFloat (_deda [0],64);_dgaba =_agbeb ;_acdeg =_agbeb ;_ddeea =_agbeb ;case 2:_agbeb ,_ =_ca .ParseFloat (_deda [0],64);_acdeg =_agbeb ;_dgaba ,_ =_ca .ParseFloat (_deda [1],64);
_ddeea =_dgaba ;case 3:_agbeb ,_ =_ca .ParseFloat (_deda [0],64);_dgaba ,_ =_ca .ParseFloat (_deda [1],64);_ddeea =_dgaba ;_acdeg ,_ =_ca .ParseFloat (_deda [2],64);case 4:_agbeb ,_ =_ca .ParseFloat (_deda [0],64);_dgaba ,_ =_ca .ParseFloat (_deda [1],64);
_acdeg ,_ =_ca .ParseFloat (_deda [2],64);_ddeea ,_ =_ca .ParseFloat (_deda [3],64);};return _agbeb ,_dgaba ,_acdeg ,_ddeea ;};func (_agc *Block )translate (_feb ,_gcf float64 ){_ddc :=_ebf .NewContentCreator ().Translate (_feb ,-_gcf ).Operations ();*_agc ._bac =append (*_ddc ,*_agc ._bac ...);
_agc ._bac .WrapIfNeeded ();};func _fbbb ()*PageBreak {return &PageBreak {}};

// TextAlignment options for paragraph.
type TextAlignment int ;func _acgd (_agbg string ,_gbed TextStyle )*Paragraph {_affe :=&Paragraph {_edceg :_agbg ,_abbaf :_gbed .Font ,_fagc :_gbed .FontSize ,_eaag :1.0,_daabg :true ,_fefe :true ,_abea :TextAlignmentLeft ,_bafe :0,_gageb :1,_dbga :1,_baea :PositionRelative ,_cfde :""};
_affe .SetColor (_gbed .Color );_affe ._gage =_gf .StructureTypeParagraph ;return _affe ;};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _cggf (svgStr )};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func _fgfbd (_bdcfc *Table ,_eaacb DrawContext )([]*Block ,DrawContext ,error ){var _cgaff []*Block ;_egbae :=NewBlock (_eaacb .PageWidth ,_eaacb .PageHeight );_bdcfc .updateRowHeights (_eaacb .Width -_bdcfc ._efdf .Left -_bdcfc ._efdf .Right );
_ggdbc :=_bdcfc ._efdf .Top ;if _bdcfc ._fddd .IsRelative ()&&!_bdcfc ._ccea {_ebgfa :=_bdcfc .Height ();if _ebgfa > _eaacb .Height -_bdcfc ._efdf .Top &&_ebgfa <=_eaacb .PageHeight -_eaacb .Margins .Top -_eaacb .Margins .Bottom {_cgaff =[]*Block {NewBlock (_eaacb .PageWidth ,_eaacb .PageHeight -_eaacb .Y )};
var _fbbec error ;if _ ,_eaacb ,_fbbec =_fbbb ().GeneratePageBlocks (_eaacb );_fbbec !=nil {return nil ,_eaacb ,_fbbec ;};_ggdbc =0;};};_daee :=_eaacb ;if _bdcfc ._fddd .IsAbsolute (){_eaacb .X =_bdcfc ._ddfeb ;_eaacb .Y =_bdcfc ._befbg ;}else {_eaacb .X +=_bdcfc ._efdf .Left ;
_eaacb .Y +=_ggdbc ;_eaacb .Width -=_bdcfc ._efdf .Left +_bdcfc ._efdf .Right ;_eaacb .Height -=_ggdbc ;};_aabc :=_eaacb .Width ;_accd :=_eaacb .X ;_befgg :=_eaacb .Y ;_agggf :=_eaacb .Height ;_bdec :=0;_edad ,_bdfgd :=-1,-1;if _bdcfc ._ccdcb {for _cgafc ,_dagbc :=range _bdcfc ._agced {if _dagbc ._efdd < _bdcfc ._faaga {continue ;
};if _dagbc ._efdd > _bdcfc ._dagb {break ;};if _edad < 0{_edad =_cgafc ;};_bdfgd =_cgafc ;};};if _gbcae :=_bdcfc .wrapContent (_eaacb );_gbcae !=nil {return nil ,_eaacb ,_gbcae ;};_bdcfc .updateRowHeights (_eaacb .Width -_bdcfc ._efdf .Left -_bdcfc ._efdf .Right );
var (_adfg bool ;_aggcf int ;_eagc int ;_fdded bool ;_gbea int ;_gceda error ;_fbgba int64 ;_gdec *_gf .KDict ;_ddfc =_bdcfc ._febd !=nil &&_bdcfc ._febd .ApplyTag ;);if _ddfc {_aacae (_egbae ,_bdcfc ._febd );_fbgba =_bdcfc ._febd .Mcid +1;};for _ffbbb :=0;
_ffbbb < len (_bdcfc ._agced );_ffbbb ++{_gdcdg :=_bdcfc ._agced [_ffbbb ];if _ddfc &&_gdcdg ._efdd > _gbea {switch _bdcfc ._febd .StructureType {case _gf .StructureTypeTable :_aacae (_egbae ,&_gf .StructureTagInfo {Mcid :_fbgba ,StructureType :_gf .StructureTypeTableRow });
_gdec =_bdcfc .addRowTag ();case _gf .StructureTypeList :_aacae (_egbae ,&_gf .StructureTagInfo {Mcid :_fbgba ,StructureType :_gf .StructureTypeListItem });_gdec =_bdcfc .addListItemTag ();};_gbea =_gdcdg ._efdd ;_fbgba ++;};if _gfedd ,_dceae :=_bdcfc .getLastCellFromCol (_gdcdg ._facac );
_gfedd ==_ffbbb {if (_dceae ._efdd +_dceae ._addgb -1)< _bdcfc ._ebdeb {for _deed :=_gdcdg ._efdd ;_deed < _bdcfc ._ebdeb ;_deed ++{_ecbce :=&TableCell {};_ecbce ._efdd =_deed +1;_ecbce ._addgb =1;_ecbce ._facac =_gdcdg ._facac ;_bdcfc ._agced =append (_bdcfc ._agced ,_ecbce );
};};};_bagee :=_gdcdg .width (_bdcfc ._beeaca ,_aabc );_cadba :=float64 (0.0);for _gbagd :=0;_gbagd < _gdcdg ._facac -1;_gbagd ++{_cadba +=_bdcfc ._beeaca [_gbagd ]*_aabc ;};_cdbcb :=float64 (0.0);for _gfgd :=_bdec ;_gfgd < _gdcdg ._efdd -1;_gfgd ++{_cdbcb +=_bdcfc ._acbg [_gfgd ];
};_eaacb .Height =_agggf -_cdbcb ;_fbfe :=float64 (0.0);for _bfefb :=0;_bfefb < _gdcdg ._addgb ;_bfefb ++{_fbfe +=_bdcfc ._acbg [_gdcdg ._efdd +_bfefb -1];};_cbfd :=_fdded &&_gdcdg ._efdd !=_gbea ;_gbea =_gdcdg ._efdd ;if _cbfd ||_fbfe > _eaacb .Height {if _bdcfc ._afeec &&!_fdded {_fdded ,_gceda =_bdcfc .wrapRow (_ffbbb ,_eaacb ,_aabc );
if _gceda !=nil {return nil ,_eaacb ,_gceda ;};if _fdded {_ffbbb --;continue ;};};_cgaff =append (_cgaff ,_egbae );_egbae =NewBlock (_eaacb .PageWidth ,_eaacb .PageHeight );_accd =_eaacb .Margins .Left +_bdcfc ._efdf .Left ;_befgg =_eaacb .Margins .Top ;
_eaacb .Height =_eaacb .PageHeight -_eaacb .Margins .Top -_eaacb .Margins .Bottom ;_eaacb .Page ++;_agggf =_eaacb .Height ;_bdec =_gdcdg ._efdd -1;_cdbcb =0;_fdded =false ;if _bdcfc ._ccdcb &&_edad >=0{_aggcf =_ffbbb ;_ffbbb =_edad -1;_eagc =_bdec ;_bdec =_bdcfc ._faaga -1;
_adfg =true ;if _gdcdg ._addgb > (_bdcfc ._ebdeb -_gbea +1)||(_gdcdg ._addgb > 1&&_ffbbb < 0){_ef .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_adfg =false ;_edad ,_bdfgd =-1,-1;};continue ;};if _cbfd {_ffbbb --;continue ;};};_eaacb .Width =_bagee ;_eaacb .X =_accd +_cadba ;_eaacb .Y =_befgg +_cdbcb ;if _fbfe > _eaacb .PageHeight -_eaacb .Margins .Top -_eaacb .Margins .Bottom {_fbfe =_eaacb .PageHeight -_eaacb .Margins .Top -_eaacb .Margins .Bottom ;
};_bcbgc :=_bbe (_eaacb .X ,_eaacb .Y ,_bagee ,_fbfe );if _gdcdg ._cbbgf !=nil {_bcbgc .SetFillColor (_gdcdg ._cbbgf );};_bcbgc .SetOpacity (_gdcdg ._ggcef );_bcbgc .LineStyle =_gdcdg ._decca ;_bcbgc ._dab =_gdcdg ._ddcce ;_bcbgc ._gdb =_gdcdg ._efabe ;
_bcbgc ._aff =_gdcdg ._cdefc ;_bcbgc ._cbc =_gdcdg ._gebca ;if _gdcdg ._agfge !=nil {_bcbgc .SetColorLeft (_gdcdg ._agfge );};if _gdcdg ._gdae !=nil {_bcbgc .SetColorBottom (_gdcdg ._gdae );};if _gdcdg ._fcdd !=nil {_bcbgc .SetColorRight (_gdcdg ._fcdd );
};if _gdcdg ._dadeb !=nil {_bcbgc .SetColorTop (_gdcdg ._dadeb );};_bcbgc .SetWidthBottom (_gdcdg ._gafaf );_bcbgc .SetWidthLeft (_gdcdg ._bgeeg );_bcbgc .SetWidthRight (_gdcdg ._cdeb );_bcbgc .SetWidthTop (_gdcdg ._ecee );_cccag :=NewBlock (_egbae ._ddf ,_egbae ._geb );
_cabgd :=_egbae .Draw (_bcbgc );if _cabgd !=nil {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cabgd );};if _gdcdg ._ebagf !=nil {var _accdf *_gf .KDict ;if _ddfc {_gdcdg .SetMarkedContentID (_fbgba );_gdcdg .SetStructPageNumber (_bdcfc ._febd .StructPageNumber );
_feab :=_gf .StructureTypeTableData ;if _gdcdg ._febd .StructureType !=_gf .StructureTypeTableData {_feab =_gdcdg ._febd .StructureType ;}else {_gdcdg .SetStructureType (_gf .StructureTypeTableData );};_aacae (_egbae ,&_gf .StructureTagInfo {Mcid :_fbgba ,StructureType :_feab });
_accdf =_gf .NewKDictionary ();_accdf .S =_cd .MakeName (string (_feab ));_gdgbg :=_gf .NewKValue ();_gdgbg .SetMCID (int (_fbgba ));_accdf .AddChild (_gdgbg );_gdec .AddKChild (_accdf );_fbgba ++;};_agea :=_gdcdg ._ebagf .Width ();_egebaf :=_gdcdg ._ebagf .Height ();
_agea ,_egebaf ,_effeag ,_dbfcg ,_bbccd ,_gbbca :=_fbgec (_gdcdg ._ebagf ,_agea ,_egebaf ,_gdcdg ._bdfedc ,_bdcfc ._gdbd ,_accdf ,_fbgba ,_bagee );if _gbbca !=nil {return nil ,_eaacb ,_gbbca ;};if _dbfcg !=nil {if !_bbccd {_accdf .AddKChild (_dbfcg );};
_fbgba ++;};switch _gdcdg ._edgce {case CellHorizontalAlignmentLeft :_eaacb .X +=_gdcdg ._aagdg ;_eaacb .Width -=_gdcdg ._aagdg ;case CellHorizontalAlignmentCenter :if _fegcb :=_bagee -_agea ;_fegcb > 0{_eaacb .X +=_fegcb /2;_eaacb .Width -=_fegcb /2;};
case CellHorizontalAlignmentRight :if _bagee > _agea {_eaacb .X =_eaacb .X +_bagee -_agea -_gdcdg ._aagdg ;_eaacb .Width -=_gdcdg ._aagdg ;};};_bdabc :=_eaacb .Y ;_ggagg :=_eaacb .Height ;_eaacb .Y +=_effeag ;switch _gdcdg ._bdfedc {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _abbfbg :=_fbfe -_egebaf ;
_abbfbg > 0{_eaacb .Y +=_abbfbg /2;_eaacb .Height -=_abbfbg /2;};case CellVerticalAlignmentBottom :if _fbfe > _egebaf {_eaacb .Y =_eaacb .Y +_fbfe -_egebaf ;_eaacb .Height =_fbfe ;};};_gbbca =_egbae .DrawWithContext (_gdcdg ._ebagf ,_eaacb );if _gbbca !=nil {if _g .Is (_gbbca ,ErrContentNotFit )&&!_cbfd {_egbae =_cccag ;
_cbfd =true ;_ffbbb --;continue ;};_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbbca );};_eaacb .Y =_bdabc ;_eaacb .Height =_ggagg ;};_eaacb .Y +=_fbfe ;_eaacb .Height -=_fbfe ;if _adfg &&_ffbbb +1> _bdfgd {_befgg +=_cdbcb +_fbfe ;
_agggf -=_fbfe +_cdbcb ;_bdec =_eagc ;_ffbbb =_aggcf -1;_adfg =false ;};if _ddfc {_bfbfd (_egbae );if _ffbbb +1==len (_bdcfc ._agced )||_bdcfc ._agced [_ffbbb +1]._efdd > _gbea {_bfbfd (_egbae );};};};if _ddfc {_bfbfd (_egbae );};_cgaff =append (_cgaff ,_egbae );
if _bdcfc ._fddd .IsAbsolute (){return _cgaff ,_daee ,nil ;};_eaacb .X =_daee .X ;_eaacb .Width =_daee .Width ;_eaacb .Y +=_bdcfc ._efdf .Bottom ;_eaacb .Height -=_bdcfc ._efdf .Bottom ;return _cgaff ,_eaacb ,nil ;};func _fbd (_gadg Color )_gf .PdfColor {if _gadg ==nil {_gadg =ColorBlack ;
};switch _dea :=_gadg .(type ){case grayColor :return _gf .NewPdfColorDeviceGray (_dea ._bacdf );case cmykColor :return _gf .NewPdfColorDeviceCMYK (_dea ._dbg ,_dea ._dcg ,_dea ._acag ,_dea ._fgae );case *LinearShading :return _gf .NewPdfColorPatternType2 ();
case *RadialShading :return _gf .NewPdfColorPatternType3 ();};return _gf .NewPdfColorDeviceRGB (_gadg .ToRGB ());};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_gbgg *List )Marker ()*TextChunk {return &_gbgg ._eaeba };

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_cfbf *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dccf :=ctx ;_dcd :=_cfbf ._febd !=nil &&_cfbf ._febd .ApplyTag ;var _cegf int64 ;if _cfbf ._acef .IsRelative (){ctx .X +=_cfbf ._egdc .Left ;ctx .Y +=_cfbf ._egdc .Top ;
ctx .Width -=_cfbf ._egdc .Left +_cfbf ._egdc .Right ;ctx .Height -=_cfbf ._egdc .Top ;};if _dcd {_cfbf ._egge .SetMarkedContentID (_cegf );_cfbf ._egge .SetStructureType (_gf .StructureTypeHeader );};_cged ,_feg ,_cabg :=_cfbf ._egge .GeneratePageBlocks (ctx );
if _cabg !=nil {return _cged ,ctx ,_cabg ;};if _dcd {_dac :=int64 (_feg .Page );_cfbf ._egge .SetStructPageNumber (&_dac );_gbc ,_cfbc :=_cfbf ._egge .GenerateKDict ();if _cfbc !=nil {return nil ,ctx ,_cfbc ;};_cfbf ._febd .ComponentKObj .AddKChild (_gbc );
if len (_cged )> 0{for _fgea ,_ggbc :=range _cged {if _fgea ==0{_aacae (_ggbc ,&_gf .StructureTagInfo {Mcid :_cegf ,StructureType :_gf .StructureTypeHeader });};if _fgea ==len (_cged )-1{_bfbfd (_ggbc );};};};_cegf ++;};ctx =_feg ;_fcg :=ctx .X ;_efgg :=ctx .Y -_cfbf ._egge .Height ();
_cca :=int64 (ctx .Page );_gfd :=_cfbf .headingNumber ();_cde :=_cfbf .headingText ();if _cfbf ._gge {_efc :=_cfbf ._fged .Add (_gfd ,_cfbf ._cede ,_ca .FormatInt (_cca ,10),_cfbf ._abfc );if _cfbf ._fged ._befbd {_efc .SetLink (_cca ,_fcg ,_efgg );};};
if _cfbf ._ffgb ==nil {_cfbf ._ffgb =_gf .NewOutlineItem (_cde ,_gf .NewOutlineDest (_cca -1,_fcg ,_efgg ));if _cfbf ._bad !=nil {_cfbf ._bad ._ffgb .Add (_cfbf ._ffgb );}else {_cfbf ._ecd .Add (_cfbf ._ffgb );};}else {_cfgc :=&_cfbf ._ffgb .Dest ;_cfgc .Page =_cca -1;
_cfgc .X =_fcg ;_cfgc .Y =_efgg ;};for _ ,_gbge :=range _cfbf ._ebea {_acb :=false ;var _ggdg _gf .StructureType ;if _dcd {switch _fbf :=_gbge .(type ){case *Paragraph ,*StyledParagraph :_acb =true ;_ggdg =_gf .StructureTypeParagraph ;_gbge .SetMarkedContentID (_cegf );
_gbge .SetStructureType (_ggdg );case *Division :_acb =true ;_ggdg =_gf .StructureTypeDivision ;_fbf .AddTag (_cfbf ._febd .ComponentKObj );case *Table :_acb =true ;_ggdg =_gf .StructureTypeTable ;_fbf .AddTag (_cfbf ._febd .ComponentKObj );case *List :_acb =true ;
_ggdg =_gf .StructureTypeList ;_fbf .AddTag (_cfbf ._febd .ComponentKObj );case *Chapter :_acb =true ;_ggdg =_gf .StructureTypeSection ;_fbf .AddTag (_cfbf ._febd .ComponentKObj );};};_bbda ,_eaa ,_fbb :=_gbge .GeneratePageBlocks (ctx );if _fbb !=nil {return _cged ,ctx ,_fbb ;
};if _dcd &&_acb {_cagga :=int64 (_eaa .Page );_gbge .SetStructPageNumber (&_cagga );if _ggdg ==_gf .StructureTypeParagraph {_cfab ,_ggac :=_gbge .GenerateKDict ();if _ggac !=nil {return nil ,ctx ,_ggac ;};_cfbf ._febd .ComponentKObj .AddKChild (_cfab );
};if len (_bbda )> 0{for _gcfa ,_cfgce :=range _bbda {if _gcfa ==0{_aacae (_cfgce ,&_gf .StructureTagInfo {Mcid :_cegf ,StructureType :_ggdg });};if _gcfa ==len (_bbda )-1{_bfbfd (_cfgce );};};};_cegf ++;};if len (_bbda )< 1{continue ;};_cged [len (_cged )-1].mergeBlocks (_bbda [0]);
_cged =append (_cged ,_bbda [1:]...);ctx =_eaa ;};if _cfbf ._acef .IsRelative (){ctx .X =_dccf .X ;};if _cfbf ._acef .IsAbsolute (){return _cged ,_dccf ,nil ;};return _cged ,ctx ,nil ;};func (_daag *Creator )newPage ()*_gf .PdfPage {_fbdd :=_gf .NewPdfPage ();
_feeb :=_daag ._bea [0];_fdc :=_daag ._bea [1];_fcec :=_gf .PdfRectangle {Llx :0,Lly :0,Urx :_feeb ,Ury :_fdc };_fbdd .MediaBox =&_fcec ;_daag ._gaa =_feeb ;_daag ._dag =_fdc ;_daag .initContext ();return _fbdd ;};

// SetOpacity sets the opacity of the line (0-1).
func (_cadg *Line )SetOpacity (opacity float64 ){_cadg ._caabd =opacity };func _cbbef (_dbdae *Block ,_caffa *StyledParagraph ,_gbcf [][]*TextChunk ,_dedbf DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bdeba :=1;_gcaeb :=_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));
for _dbdae ._ebe .HasFontByName (_gcaeb ){_bdeba ++;_gcaeb =_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));};_caeef :=_dbdae ._ebe .SetFontByName (_gcaeb ,_caffa ._dgaag .Font .ToPdfObject ());if _caeef !=nil {return _dedbf ,nil ,_caeef ;
};_bdeba ++;_cebg :=_gcaeb ;_edgcg :=_caffa ._dgaag .FontSize ;_dfbc :=_caffa ._ggdeb .IsRelative ();var _gcefa [][]_cd .PdfObjectName ;var _abde [][]*TextChunk ;var _dfaeg float64 ;_degbe :=[][]_dfd .Line {};for _ggafa ,_dfdee :=range _gbcf {var _cdagc []_cd .PdfObjectName ;
var _cacab float64 ;if len (_dfdee )> 0{_cacab =_dfdee [0].Style .FontSize ;if _ggafa ==0&&len (_caffa ._gbbce )> 0&&_caffa ._ceaf !=nil {_caabg :=_caffa ._ceaf ;if _caabg .Type !=DropCapsNone &&_caffa ._bcfc {if len (_dfdee )> 1{_cacab =_dfdee [1].Style .FontSize ;
};};};};_cegad :=[]_dfd .Line {};for _ffed ,_ffeff :=range _dfdee {if _ggafa ==0&&_ffed ==0&&len (_caffa ._gbbce )> 0&&_caffa ._ceaf !=nil {_ecgc :=_caffa ._ceaf ;if _ecgc .Type !=DropCapsNone &&_caffa ._bcfc {continue ;};};_fcgdg :=_ffeff .Style ;if _ffeff .Text !=""&&_fcgdg .FontSize > _cacab {_cacab =_fcgdg .FontSize ;
};if _cacab > _dedbf .PageHeight {return _dedbf ,nil ,_g .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_gcaeb =_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));_cdagc =append (_cdagc ,_gcaeb );if _caffa ._acgf {if _dcfdd :=_fcgdg .Font .GetOTFType ();_dcfdd !=nil {_becc :=_dcfdd .ShapeText (_ffeff .Text ,_fcgdg .FontSize );
_cegad =append (_cegad ,_becc );for _ ,_bdebg :=range _becc {_ffeff .Style .Font .RegisterLigatureMapping (_bdebg ,_ffeff .Text );};}else {_cegad =append (_cegad ,nil );};};_gbcca :=_dbdae ._ebe .SetFontByName (_gcaeb ,_fcgdg .Font .ToPdfObject ());if _gbcca !=nil {return _dedbf ,nil ,_gbcca ;
};_bdeba ++;};_degbe =append (_degbe ,_cegad );_cacab *=_caffa ._edcb ;if _dfbc &&_dfaeg +_cacab > _dedbf .Height {_abde =_gbcf [_ggafa :];_gbcf =_gbcf [:_ggafa ];break ;};_dfaeg +=_cacab ;_gcefa =append (_gcefa ,_cdagc );};_gacge ,_gfcbc ,_gdgc :=0.0,0.0,0.0;
if len (_gbcf )> 0{_gacge ,_gfcbc ,_gdgc =_cefa (_gbcf [0]);};_dddba ,_gfcee :=_gacge *_caffa ._edcb ,_gfcbc *_caffa ._edcb ;var _beegg *TextChunk ;if len (_caffa ._gbbce )> 0&&_caffa ._ceaf !=nil {_bfbc :=_caffa ._ceaf ;if _bfbc .Type !=DropCapsNone &&_caffa ._bcfc {_beegg =_caffa ._gbbce [0];
_acfeb :=_caffa ._aeggc [0][0];if len (_caffa ._aeggc [0])> 1&&_acfeb ==_beegg {_acfeb =_caffa ._aeggc [0][1];};_gfcee =_acfeb .Style .FontSize *_caffa ._edcb ;};};if len (_gbcf )==0{return _dedbf ,_abde ,nil ;};_bfgdec :=_ebf .NewContentCreator ();_bfgdec .Add_q ();
_gefeb :=_gfcee ;if _caffa ._bffb ==TextVerticalAlignmentCenter {_gefeb =_gfcbc +(_gacge +_gdgc -_gfcbc )/2+(_gfcee -_gfcbc )/2;};_fgabd :=_dedbf .PageHeight -_dedbf .Y -_gefeb ;_bfgdec .Translate (_dedbf .X ,_fgabd );_fcfc :=_fgabd ;if _caffa ._eagdd !=0{_bfgdec .RotateDeg (_caffa ._eagdd );
};if _caffa ._cgadg ==TextOverflowHidden {_bfgdec .Add_re (0,-_dfaeg +_dddba +1,_caffa ._ffdb ,_dfaeg ).Add_W ().Add_n ();};_bfgdec .Add_BT ();_gedad :=map[string ]_cd .PdfObject {};if _caffa ._ebff ==nil {if _caffa ._febd !=nil {_gedad ["\u004d\u0043\u0049\u0044"]=_cd .MakeInteger (_caffa ._febd .Mcid );
};if _caffa ._edbead !=""{_gedad ["\u004c\u0061\u006e\u0067"]=_cd .MakeString (_caffa ._edbead );};if len (_gedad )> 0{_bfgdec .Add_BDC (*_cd .MakeName (string (_caffa ._febd .StructureType )),_gedad );};}else {_gedad =_caffa ._ebff .GenerateMap ();if len (_gedad )> 0{_bfgdec .Add_BDC (*_cd .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")),_gedad );
}else {_bfgdec .Add_BMC (*_cd .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")));};};var _eadgd float64 ;if _beegg !=nil {_cbdb :=&_beegg .Style ;_affg :=_caffa ._ceaf ;_fbgbe :=_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));
_gcfge :=_dbdae ._ebe .SetFontByName (_fbgbe ,_cbdb .Font .ToPdfObject ());if _gcfge !=nil {return _dedbf ,nil ,_gcfge ;};_bdeba ++;_afaa :=_cbdb .Font .Encoder ().Encode (_beegg .Text );var _egedf float64 ;_fcge :=[]rune (_beegg .Text );for _egecad ,_acgfd :=range _fcge {_aabeg ,_gfee :=_cbdb .Font .GetRuneMetrics (_acgfd );
if _gfee {_egedf +=_cbdb .FontSize *_aabeg .Wx *_cbdb .horizontalScale ()/1000.0;if _egecad < len (_fcge )-1{_egedf +=_cbdb .CharSpacing ;};};};switch _affg .Type {case DropCapsDrop :_cddg :=_caffa ._aeggc [0][0];if len (_caffa ._aeggc [0])> 1&&_cddg ==_beegg {_cddg =_caffa ._aeggc [0][1];
};_ccca :=_bfcdf (_cddg .Style .Font ,_cddg .Style .FontSize );_baae :=_bfcdf (_cbdb .Font ,_cbdb .FontSize );_gaaab :=_ccca ._daffb -_baae ._daffb ;_bfgdec .SetNonStrokingColor (_fbd (_cbdb .Color )).Add_Tf (_fbgbe ,_cbdb .FontSize ).Add_Td (0,_gaaab ).Add_TJ ([]_cd .PdfObject {_cd .MakeStringFromBytes (_afaa )}...);
_bfgdec .Add_Td (_egedf +_affg .Gap ,-_gaaab );_eadgd =_egedf +_affg .Gap ;case DropCapsInline :_cfaad :=_caffa ._aeggc [0][0];if len (_caffa ._aeggc [0])> 1&&_cfaad ==_beegg {_cfaad =_caffa ._aeggc [0][1];};_dfeag :=_bfcdf (_cfaad .Style .Font ,_cfaad .Style .FontSize );
_egggg :=_bfcdf (_cbdb .Font ,_cbdb .FontSize );_bebaa :=_dfeag ._bfefbg -_egggg ._bfefbg ;_bfgdec .SetNonStrokingColor (_fbd (_cbdb .Color )).Add_Tf (_fbgbe ,_cbdb .FontSize ).Add_Td (0,_bebaa ).Add_TJ ([]_cd .PdfObject {_cd .MakeStringFromBytes (_afaa )}...);
_bfgdec .Add_Td (_egedf +_affg .Gap ,-_bebaa );_eadgd =_egedf +_affg .Gap ;};};var _fbeg []*_dd .BasicLine ;for _cbba ,_eggc :=range _gbcf {_abgag :=_dedbf .X ;var _ggbaf float64 ;if len (_eggc )> 0{_ggbaf =_eggc [0].Style .FontSize ;};_gacge ,_ ,_gdgc =_caffa .getLineMetrics (_cbba );
_gfcee =(_gacge +_gdgc );for _ ,_gdda :=range _eggc {_aaaab :=&_gdda .Style ;if _gdda .Text !=""&&_aaaab .FontSize > _ggbaf {_ggbaf =_aaaab .FontSize ;};if _gfcee > _ggbaf {_ggbaf =_gfcee ;};};if _cbba !=0{_bfgdec .Add_TD (0,-_ggbaf *_caffa ._edcb );_fcfc -=_ggbaf *_caffa ._edcb ;
};var _cdcg float64 ;_fbfdg :=0.0;if _beegg !=nil {_abaf :=_caffa ._ceaf ;if _cbba > 0{if _abaf .Type ==DropCapsDrop &&_cbba -1< _abaf .NumLines {_cdcg =_eadgd ;}else if _abaf .Type ==DropCapsInline {_cdcg =_eadgd ;};};switch _abaf .Type {case DropCapsDrop :if _cbba < _abaf .NumLines {_fbfdg =_eadgd ;
};case DropCapsInline :_fbfdg =_eadgd ;};};if _cbba > 0{_cacgeb :=_fbfdg -_cdcg ;if _cacgeb !=0{_bfgdec .Add_Td (_cacgeb ,0);};};_abgag +=_fbfdg ;_aaaf :=_cbba ==len (_gbcf )-1;var (_cebc float64 ;_fdccc float64 ;_fgfc *fontMetrics ;_caae float64 ;_edegc uint ;
);var _eccgf []float64 ;for _dcffd ,_cgbf :=range _eggc {if _cbba ==0&&_dcffd ==0&&_beegg !=nil {continue ;};_babcc :=&_cgbf .Style ;if _babcc .FontSize > _fdccc {_fdccc =_babcc .FontSize ;_fgfc =_bfcdf (_cgbf .Style .Font ,_babcc .FontSize );};if _gfcee > _fdccc {_fdccc =_gfcee ;
};_ecagb ,_ebead :=_babcc .Font .GetRuneMetrics (' ');if _ecagb .Wx ==0&&_babcc .MultiFont !=nil {_ecagb ,_ebead =_babcc .MultiFont .GetRuneMetrics (' ');_babcc .MultiFont .Reset ();};if !_ebead {return _dedbf ,nil ,_g .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _accgc uint ;var _fbdbg float64 ;_ceag :=len (_cgbf .Text );for _befb ,_cdgge :=range _cgbf .Text {if _cdgge ==' '{_accgc ++;continue ;};if _cdgge =='\u000A'{continue ;};_ffdge ,_ebbec :=_babcc .Font .GetRuneMetrics (_cdgge );if _ffdge .Wx ==0&&_babcc .MultiFont !=nil {_ffdge ,_ebbec =_babcc .MultiFont .GetRuneMetrics (' ');
_babcc .MultiFont .Reset ();};if !_ebbec {_ef .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_cdgge );return _dedbf ,nil ,_g .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_fbdbg +=_babcc .FontSize *_ffdge .Wx *_babcc .horizontalScale ();if _befb !=_ceag -1{_fbdbg +=_babcc .CharSpacing *1000.0;};};_eccgf =append (_eccgf ,_fbdbg );_cebc +=_fbdbg ;_caae +=float64 (_accgc )*_ecagb .Wx *_babcc .FontSize *_babcc .horizontalScale ();
_edegc +=_accgc ;};_fdccc *=_caffa ._edcb ;var _fbge []_cd .PdfObject ;_acegc :=_caffa ._ffdb *1000.0;switch _caffa ._abgad {case TextAlignmentJustify :if _edegc > 0&&!_aaaf {_caae =(_acegc -_cebc )/float64 (_edegc )/_edgcg ;};case TextAlignmentCenter :_fccc :=(_acegc -_cebc -_caae )/2;
_begac :=_fccc /_edgcg ;_fbge =append (_fbge ,_cd .MakeFloat (-_begac ));_abgag +=_fccc /1000.0;case TextAlignmentRight :_bgade :=(_acegc -_cebc -_caae );_ageba :=_bgade /_edgcg ;_fbge =append (_fbge ,_cd .MakeFloat (-_ageba ));_abgag +=_bgade /1000.0;
};if len (_fbge )> 0{_bfgdec .Add_Tf (_cebg ,_edgcg ).Add_TL (_edgcg *_caffa ._edcb ).Add_TJ (_fbge ...);};_dgfb :=0.0;_eaac :=0;for _fbbe ,_acggb :=range _eggc {if _cbba ==0&&_fbbe ==0&&_beegg !=nil {continue ;};_bgcde :=&_acggb .Style ;_cbdf :=_cebg ;
_bfcf :=_edgcg ;_aefe :=_bgcde .OutlineColor !=nil ;_bfgfe :=_bgcde .HorizontalScaling !=DefaultHorizontalScaling ;_bbgdf :=_bgcde .OutlineSize !=1;if _bbgdf {_bfgdec .Add_w (_bgcde .OutlineSize );};_gfbfd :=_bgcde .RenderingMode !=TextRenderingModeFill ;
if _gfbfd {_bfgdec .Add_Tr (int64 (_bgcde .RenderingMode ));};_ebfab :=_bgcde .CharSpacing !=0;if _ebfab {_bfgdec .Add_Tc (_bgcde .CharSpacing );};_bcce :=_bgcde .TextRise !=0;if _bcce {_bfgdec .Add_Ts (_bgcde .TextRise );};if _acggb .VerticalAlignment !=TextVerticalAlignmentBaseline {_abfb :=_bfcdf (_acggb .Style .Font ,_bgcde .FontSize );
switch _acggb .VerticalAlignment {case TextVerticalAlignmentCenter :_dgfb =_fgfc ._abagf /2-_abfb ._abagf /2;case TextVerticalAlignmentBottom :_dgfb =_fgfc ._bdbba -_abfb ._bdbba ;case TextVerticalAlignmentTop :_dgfb =_gfcbc -_bgcde .FontSize ;};if _dgfb !=0.0{_bfgdec .Translate (0,_dgfb );
};};if _caffa ._abgad !=TextAlignmentJustify ||_aaaf {_deafa ,_aaadf :=_bgcde .Font .GetRuneMetrics (' ');if !_aaadf {return _dedbf ,nil ,_g .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_cbdf =_gcefa [_cbba ][_eaac ];_bfcf =_bgcde .FontSize ;_caae =_deafa .Wx *_bgcde .horizontalScale ();};_eccc :=_bgcde .Font .Encoder ();var _bdcgd []byte ;var _bfadg bool ;_bbcbb :=_bgcde .Font ;_ffdf :=map[string ]_cd .PdfObject {};if _acggb ._afcbd !=nil {_ffdf ["\u0045"]=_cd .MakeString (*_acggb ._afcbd );
};if _acggb ._dcbb !=nil {_ffdf ["\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074"]=_cd .MakeString (*_acggb ._dcbb );};if _acggb ._bdgga !=nil {_ffdf ["\u0041\u006c\u0074"]=_cd .MakeString (*_acggb ._bdgga );};if _acggb ._febd !=nil {_ffdf ["\u004d\u0043\u0049\u0044"]=_cd .MakeInteger (_acggb ._febd .Mcid );
};if len (_ffdf )> 0{if _acggb ._febd !=nil &&_acggb ._febd .StructureType !=_gf .StructureTypeUnknown {_bfgdec .Add_BDC (*_cd .MakeName (string (_acggb ._febd .StructureType )),_ffdf );}else {_bfgdec .Add_BDC (*_cd .MakeName (string (_gf .StructureTypeSpan )),_ffdf );
};};if _caffa ._acgf &&_degbe [_cbba ][_fbbe ]!=nil {_agddbg :=_gcefa [_cbba ][_eaac ];if _bfadg {_agddbg =_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));_aefge :=_dbdae ._ebe .SetFontByName (_agddbg ,_bbcbb .ToPdfObject ());
if _aefge !=nil {return _dedbf ,nil ,_aefge ;};_bdeba ++;_bfadg =false ;};_bfgdec =_bfgdec .SetNonStrokingColor (_fbd (_bgcde .Color )).Add_Tf (_agddbg ,_bgcde .FontSize );var _fgbaf []_cd .PdfObject ;for _ ,_ddgeb :=range _degbe [_cbba ][_fbbe ]{for _ ,_aeeecf :=range _ddgeb .Glyphs {_fgbaf =append (_fgbaf ,_cd .MakeHexStringFromHexNumber (uint32 (_aeeecf .GlyphID ),2));
};};if _fgbaf !=nil {_bfgdec .Add_TJ (_fgbaf ...);};}else {for _ ,_cadfd :=range _acggb .Text {if _cadfd =='\u000A'{continue ;};_abbfbf ,_aggf :=_bdedd (_dedbf ,_bfgdec ,_dbdae ,_cadfd ,_abgag ,_bgcde ,_ffdf );if _aggf !=nil {return _dedbf ,nil ,_aggf ;
};if _abbfbf {continue ;};if _cadfd ==' '{if len (_bdcgd )> 0{if _aefe {_bfgdec .SetStrokingColor (_fbd (_bgcde .OutlineColor ));};if _bfgfe {_bfgdec .Add_Tz (_bgcde .HorizontalScaling );};_fbac :=_gcefa [_cbba ][_eaac ];if _bfadg {_fbac =_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));
_eeace :=_dbdae ._ebe .SetFontByName (_fbac ,_bbcbb .ToPdfObject ());if _eeace !=nil {return _dedbf ,nil ,_eeace ;};_bdeba ++;_bfadg =false ;_eccc =_bgcde .Font .Encoder ();};_bfgdec .SetNonStrokingColor (_fbd (_bgcde .Color )).Add_Tf (_fbac ,_bgcde .FontSize ).Add_TJ ([]_cd .PdfObject {_cd .MakeStringFromBytes (_bdcgd )}...);
_bdcgd =nil ;};if _bfgfe {_bfgdec .Add_Tz (DefaultHorizontalScaling );};_bfgdec .Add_Tf (_cbdf ,_bfcf ).Add_TJ ([]_cd .PdfObject {_cd .MakeFloat (-_caae )}...);_eccgf [_eaac ]+=_caae *_bfcf ;}else {if _ ,_bbffb :=_eccc .RuneToCharcode (_cadfd );!_bbffb {if _bgcde .MultiFont !=nil {_adcg ,_adfd :=_bgcde .MultiFont .Encoder (_cadfd );
if _adfd {if len (_bdcgd )!=0{_adeba :=_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));_fgfac :=_dbdae ._ebe .SetFontByName (_cbdf ,_bbcbb .ToPdfObject ());if _fgfac !=nil {return _dedbf ,nil ,_fgfac ;};_bfgdec .SetNonStrokingColor (_fbd (_bgcde .Color )).Add_Tf (_adeba ,_bgcde .FontSize ).Add_TJ ([]_cd .PdfObject {_cd .MakeStringFromBytes (_bdcgd )}...);
_bdeba ++;_bdcgd =nil ;};_eccc =_adcg ;_bfadg =true ;_bbcbb =_bgcde .MultiFont .CurrentFont ;};}else {_aggf =UnsupportedRuneError {Message :_e .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cadfd ,_cadfd ),Rune :_cadfd };
_dedbf ._afbfc =append (_dedbf ._afbfc ,_aggf );_ef .Log .Debug (_aggf .Error ());if _dedbf ._deaaa <=0{continue ;};_cadfd =_dedbf ._deaaa ;};};_aabg :=_eccc .Encode (string (_cadfd ));_bdcgd =append (_bdcgd ,_aabg ...);};if _bgcde .MultiFont !=nil {_bgcde .MultiFont .Reset ();
};};};if len (_bdcgd )> 0{if _aefe {_bfgdec .SetStrokingColor (_fbd (_bgcde .OutlineColor ));};if _bfgfe {_bfgdec .Add_Tz (_bgcde .HorizontalScaling );};_eaabg :=_gcefa [_cbba ][_eaac ];if _bfadg {_eaabg =_cd .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdeba ));
_egfea :=_dbdae ._ebe .SetFontByName (_eaabg ,_bbcbb .ToPdfObject ());if _egfea !=nil {return _dedbf ,nil ,_egfea ;};_bdeba ++;_bfadg =false ;};_bfgdec .SetNonStrokingColor (_fbd (_bgcde .Color )).Add_Tf (_eaabg ,_bgcde .FontSize ).Add_TJ ([]_cd .PdfObject {_cd .MakeStringFromBytes (_bdcgd )}...);
};if len (_ffdf )> 0{_bfgdec .Add_EMC ();};_begg :=_eccgf [_eaac ]/1000.0;if _bgcde .Underline {_facaf :=_bgcde .UnderlineStyle .Color ;if _facaf ==nil {_facaf =_acggb .Style .Color ;};_feced ,_aacc ,_eggce :=_facaf .ToRGB ();_dgadd :=_abgag -_dedbf .X ;
_eebea :=_fcfc -_fgabd +_bgcde .TextRise -_bgcde .UnderlineStyle .Offset ;_fbeg =append (_fbeg ,&_dd .BasicLine {X1 :_dgadd ,Y1 :_eebea ,X2 :_dgadd +_begg ,Y2 :_eebea ,LineWidth :_acggb .Style .UnderlineStyle .Thickness ,LineColor :_gf .NewPdfColorDeviceRGB (_feced ,_aacc ,_eggce )});
};for _acbfd ,_cbefac :=range _acggb ._cgbff {var _fbcfad *_cd .PdfObjectArray ;if len (_acggb ._bfcda )==_acbfd {switch _bdfegf :=_cbefac .GetContext ().(type ){case *_gf .PdfAnnotationLink :_fbcfad =_cd .MakeArray ();_bdfegf .Rect =_fbcfad ;_dfaca ,_dgabd :=_bdfegf .Dest .(*_cd .PdfObjectArray );
if _dgabd &&_dfaca .Len ()==5{_bdbd ,_fgdcg :=_dfaca .Get (1).(*_cd .PdfObjectName );if _fgdcg &&_bdbd .String ()=="\u0058\u0059\u005a"{_gedf ,_adab :=_cd .GetNumberAsFloat (_dfaca .Get (3));if _adab ==nil {_dfaca .Set (3,_cd .MakeFloat (_dedbf .PageHeight -_gedf ));
};};};case *_gf .PdfAnnotationHighlight :_fbcfad =_cd .MakeArray ();_bdfegf .Rect =_fbcfad ;_gcbde :=_abgag ;_dedge :=_fcfc +_bgcde .TextRise ;_cgadc :=_bgfe (&_gf .PdfRectangle {Llx :_gcbde ,Lly :_dedge ,Urx :_gcbde +_begg ,Ury :_dedge +_fdccc },_caffa ._eagdd );
_bdfegf .QuadPoints =_cd .MakeArrayFromFloats ([]float64 {_cgadc [0].X ,_cgadc [0].Y ,_cgadc [1].X ,_cgadc [1].Y ,_cgadc [3].X ,_cgadc [3].Y ,_cgadc [2].X ,_cgadc [2].Y });};_acggb ._bfcda =append (_acggb ._bfcda ,true );};if _fbcfad !=nil {_dffcge :=_dd .NewPoint (_abgag -_dedbf .X ,_fcfc +_bgcde .TextRise -_fgabd ).Rotate (_caffa ._eagdd );
_dffcge .X +=_dedbf .X ;_dffcge .Y +=_fgabd ;_eabff ,_adfbf ,_bdbcc ,_efdgg :=_ebebc (_begg ,_fdccc ,_caffa ._eagdd );_dffcge .X +=_eabff ;_dffcge .Y +=_adfbf ;_fbcfad .Clear ();_fbcfad .Append (_cd .MakeFloat (_dffcge .X ));_fbcfad .Append (_cd .MakeFloat (_dffcge .Y ));
_fbcfad .Append (_cd .MakeFloat (_dffcge .X +_bdbcc ));_fbcfad .Append (_cd .MakeFloat (_dffcge .Y +_efdgg ));};_dbdae .AddAnnotation (_cbefac );};_abgag +=_begg ;if _bbgdf {_bfgdec .Add_w (1.0);};if _aefe {_bfgdec .Add_RG (0.0,0.0,0.0);};if _gfbfd {_bfgdec .Add_Tr (int64 (TextRenderingModeFill ));
};if _ebfab {_bfgdec .Add_Tc (0);};if _bcce {_bfgdec .Add_Ts (0);};if _bfgfe {_bfgdec .Add_Tz (DefaultHorizontalScaling );};if _dgfb !=0.0{_bfgdec .Translate (0,-_dgfb );_dgfb =0.0;};_eaac ++;};};if len (_gedad )> 0{_bfgdec .Add_EMC ();};_bfgdec .Add_ET ();
for _ ,_aafaf :=range _fbeg {_bfgdec .SetStrokingColor (_aafaf .LineColor ).Add_w (_aafaf .LineWidth ).Add_m (_aafaf .X1 ,_aafaf .Y1 ).Add_l (_aafaf .X2 ,_aafaf .Y2 ).Add_s ();};_bfgdec .Add_Q ();_bfaad :=_bfgdec .Operations ();_bfaad .WrapIfNeeded ();
_dbdae .addWrappedContents (_bfaad );if _dfbc {_beaa :=_dfaeg ;_dedbf .Y +=_beaa ;_dedbf .Height -=_beaa ;if _dedbf .Inline {_dedbf .X +=_caffa .Width ()+_caffa ._dbge .Right ;};};return _dedbf ,_abde ,nil ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_baef *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_baef ._fagf =toc ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_cebdaf *TOC )SetShowLinks (showLinks bool ){_cebdaf ._befbd =showLinks };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_egg *Block )DrawTemplate (c *Creator ,r _fd .Reader ,data interface{},options *TemplateOptions )error {return _acffa (c ,r ,data ,options ,_egg );};

// SetMargins sets the Paragraph's margins.
func (_aeadb *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_aeadb ._dbge .Left =left ;_aeadb ._dbge .Right =right ;_aeadb ._dbge .Top =top ;_aeadb ._dbge .Bottom =bottom ;};const (DropCapsNone DropCapsType =iota ;DropCapsDrop ;DropCapsInline ;
);

// Height returns the height of the line.
func (_bacdc *Line )Height ()float64 {_aaedc :=_bacdc ._gfbf ;if _bacdc ._gbba ==_bacdc ._bada {_aaedc /=2;};return _fb .Abs (_bacdc ._bbacd -_bacdc ._dfag )+_aaedc ;};func _fegeg (_cebdc *templateProcessor ,_aefc *templateNode )(interface{},error ){return _cebdc .parseEllipse (_aefc );
};

// SetBorderWidth sets the border width.
func (_bgaba *Polygon )SetBorderWidth (borderWidth float64 ){_bgaba ._fcfa .BorderWidth =borderWidth };

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_cbece *Rectangle )ScaleToHeight (h float64 ){_dfcf :=_cbece ._egdeb /_cbece ._ebef ;_cbece ._ebef =h ;_cbece ._egdeb =h *_dfcf ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destination of the link.
func (_cebda *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_dgag :=url ;if _b .HasPrefix (url ,"\u0068\u0074\u0074\u0070"){_dgag =text ;};_dgebf :=NewTextChunk (text ,_cebda ._eeeag );_dgebf .AddAnnotation (_dffad (url ,_dgag ));return _cebda .appendChunk (_dgebf );
};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_ebcgb *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gbgd []*Block ;_fcad bool ;_aaee error ;_bee =_ebcgb ._abba .IsRelative ();_afaf =_ebcgb ._ffd .Top ;_gfgf =_ebcgb ._febd !=nil &&_ebcgb ._febd .ApplyTag ;
_efge int64 ;);if _bee &&!_ebcgb ._gffa &&!_ebcgb ._dfcc {_eef :=_ebcgb .ctxHeight (ctx .Width );if _eef > ctx .Height -_ebcgb ._ffd .Top &&_eef <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _gbgd ,ctx ,_aaee =_fbbb ().GeneratePageBlocks (ctx );
_aaee !=nil {return nil ,ctx ,_aaee ;};_fcad =true ;_afaf =0;};};_ggfg :=ctx ;_badb :=ctx ;if _bee {ctx .X +=_ebcgb ._ffd .Left ;ctx .Y +=_afaf ;ctx .Width -=_ebcgb ._ffd .Left +_ebcgb ._ffd .Right ;ctx .Height -=_afaf ;_badb =ctx ;ctx .X +=_ebcgb ._aeg .Left ;
ctx .Y +=_ebcgb ._aeg .Top ;ctx .Width -=_ebcgb ._aeg .Left +_ebcgb ._aeg .Right ;ctx .Height -=_ebcgb ._aeg .Top ;ctx .Margins .Top +=_ebcgb ._aeg .Top ;ctx .Margins .Bottom +=_ebcgb ._aeg .Bottom ;ctx .Margins .Left +=_ebcgb ._ffd .Left +_ebcgb ._aeg .Left ;
ctx .Margins .Right +=_ebcgb ._ffd .Right +_ebcgb ._aeg .Right ;};ctx .Inline =_ebcgb ._dfcc ;_bbce :=ctx ;_bcee :=ctx ;var _aadf float64 ;for _ ,_fegg :=range _ebcgb ._cbg {if ctx .Inline {if (ctx .X -_bbce .X )+_fegg .Width ()<=ctx .Width {ctx .Y =_bcee .Y ;
ctx .Height =_bcee .Height ;}else {ctx .X =_bbce .X ;ctx .Width =_bbce .Width ;_bcee .Y +=_aadf ;_bcee .Height -=_aadf ;_aadf =0;};};_efbb :=false ;switch _fegg .(type ){case *Paragraph ,*StyledParagraph :_efbb =true ;};_dadc :=_gf .StructureTypeParagraph ;
if _gfgf &&_efbb {_fegg .SetMarkedContentID (_efge );_fegg .SetStructureType (_dadc );};_ddgf ,_edff ,_cfaa :=_fegg .GeneratePageBlocks (ctx );if _cfaa !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_cfaa );
return nil ,ctx ,_cfaa ;};if _gfgf &&_efbb {_bedbg :=int64 (_edff .Page );_fegg .SetStructPageNumber (&_bedbg );_gbb ,_gabc :=_fegg .GenerateKDict ();if _gabc !=nil {return nil ,ctx ,_gabc ;};_ebcgb ._febd .ComponentKObj .AddKChild (_gbb );if len (_ddgf )> 0{for _bgfa ,_bdaa :=range _ddgf {if _bgfa ==0{_aacae (_bdaa ,&_gf .StructureTagInfo {Mcid :_efge ,StructureType :_dadc });
};if _bgfa ==len (_ddgf )-1{_bfbfd (_bdaa );};};};_efge ++;};if len (_ddgf )< 1{continue ;};if len (_gbgd )> 0{_gbgd [len (_gbgd )-1].mergeBlocks (_ddgf [0]);_gbgd =append (_gbgd ,_ddgf [1:]...);}else {if _gdab :=_ddgf [0]._bac ;_gdab ==nil ||len (*_gdab )==0{_fcad =true ;
};_gbgd =append (_gbgd ,_ddgf [0:]...);};_dfca :=0.0;switch _afab :=_fegg .(type ){case *Paragraph :_dfca =(0.5*_afab ._fagc *_afab ._eaag );case *StyledParagraph :_dfca =(0.5*_afab .getTextHeight ());};_edff .Y +=_dfca ;_edff .Height -=_dfca ;if ctx .Inline {if ctx .Page !=_edff .Page {_bbce .Y =ctx .Margins .Top ;
_bbce .Height =ctx .PageHeight -ctx .Margins .Top ;_bcee .Y =_bbce .Y ;_bcee .Height =_bbce .Height ;_aadf =_edff .Height -_bbce .Height ;}else {if _eebf :=ctx .Height -_edff .Height ;_eebf > _aadf {_aadf =_eebf ;};};}else {_edff .X =ctx .X ;};ctx =_edff ;
};if len (_ebcgb ._cbg )==0{_bggb :=NewBlock (ctx .Width ,0);_gbgd =append (_gbgd ,_bggb );};ctx .Inline =_ggfg .Inline ;ctx .Margins =_ggfg .Margins ;if _bee {ctx .X =_ggfg .X ;ctx .Width =_ggfg .Width ;ctx .Y +=_ebcgb ._aeg .Bottom ;ctx .Height -=_ebcgb ._aeg .Bottom ;
};if _ebcgb ._ecfg !=nil {_gbgd ,_aaee =_ebcgb .drawBackground (_gbgd ,_badb ,ctx ,_fcad );if _aaee !=nil {return nil ,ctx ,_aaee ;};};if _ebcgb ._abba .IsAbsolute (){return _gbgd ,_ggfg ,nil ;};ctx .Y +=_ebcgb ._ffd .Bottom ;ctx .Height -=_ebcgb ._ffd .Bottom ;
return _gbgd ,ctx ,nil ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_bdffb *RadialShading )AddPatternResource (block *Block )(_cbfeee _cd .PdfObjectName ,_ffag error ){_ccde :=1;_ecfda :=_cd .PdfObjectName ("\u0050"+_ca .Itoa (_ccde ));for block ._ebe .HasPatternByName (_ecfda ){_ccde ++;_ecfda =_cd .PdfObjectName ("\u0050"+_ca .Itoa (_ccde ));
};if _aabb :=block ._ebe .SetPatternByName (_ecfda ,_bdffb .ToPdfShadingPattern ().ToPdfObject ());_aabb !=nil {return "",_aabb ;};return _ecfda ,nil ;};func _fgcc (_bdfeg []_dd .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_cega :&_dd .PolyBezierCurve {Curves :_bdfeg ,BorderColor :_gf .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_gbcea :1.0,_cbac :1.0};
};

// Width returns Image's document width.
func (_fdcc *Image )Width ()float64 {return _fdcc ._dgega };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_ebcd *Invoice )AddressHeadingStyle ()TextStyle {return _ebcd ._aaad };func _bbdee (_accad *templateProcessor ,_afcgb *templateNode )(interface{},error ){return _accad .parseRectangle (_afcgb );};type GridRowSection int ;

// SetWidth sets the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_fbcf *Paragraph )SetWidth (width float64 ){_fbcf ._afeca =width ;_fbcf .wrapText ()};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_gga *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gga ._egdc .Left ,_gga ._egdc .Right ,_gga ._egdc .Top ,_gga ._egdc .Bottom ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_bfcef *RadialShading )SetExtends (start bool ,end bool ){_bfcef ._acad .SetExtends (start ,end )};

// SetPos sets absolute positioning with specified coordinates.
func (_abcd *Paragraph )SetPos (x ,y float64 ){_abcd ._baea =PositionAbsolute ;_abcd ._dcff =x ;_abcd ._debb =y ;};

// SetPos set position of the element on PDF page
func (_faef *GraphicSVGElement )SetPos (x ,y float64 ){_faef ._fddeg =x ;_faef ._fggg =y };

// DropCapsScope defines what portion of the paragraph text receives drop caps treatment.
type DropCapsScope int ;func (_gfdc *templateProcessor )parseRectangle (_dgbfa *templateNode )(interface{},error ){_dcgd :=_gfdc .creator .NewRectangle (0,0,0,0);for _ ,_ffffc :=range _dgbfa ._fdbe .Attr {_gfbc :=_ffffc .Value ;switch _aaebf :=_ffffc .Name .Local ;
_aaebf {case "\u0078":_dcgd ._acaf =_gfdc .parseFloatAttr (_aaebf ,_gfbc );case "\u0079":_dcgd ._dgec =_gfdc .parseFloatAttr (_aaebf ,_gfbc );case "\u0077\u0069\u0064t\u0068":_dcgd .SetWidth (_gfdc .parseFloatAttr (_aaebf ,_gfbc ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_dcgd .SetHeight (_gfdc .parseFloatAttr (_aaebf ,_gfbc ));
case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dcgd .SetFillColor (_gfdc .parseColorAttr (_aaebf ,_gfbc ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_dcgd .SetFillOpacity (_gfdc .parseFloatAttr (_aaebf ,_gfbc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dcgd .SetBorderColor (_gfdc .parseColorAttr (_aaebf ,_gfbc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_dcgd .SetBorderOpacity (_gfdc .parseFloatAttr (_aaebf ,_gfbc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_dcgd .SetBorderWidth (_gfdc .parseFloatAttr (_aaebf ,_gfbc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gcbdf ,_bgbfce ,_adefe ,_ecggb :=_gfdc .parseBorderRadiusAttr (_aaebf ,_gfbc );
_dcgd .SetBorderRadius (_gcbdf ,_bgbfce ,_ecggb ,_adefe );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_dcgd ._ddfb =_gfdc .parseFloatAttr (_aaebf ,_gfbc );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dcgd ._ebdg =_gfdc .parseFloatAttr (_aaebf ,_gfbc );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_dcgd ._afdd =_gfdc .parseFloatAttr (_aaebf ,_gfbc );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_dcgd ._dbaed =_gfdc .parseFloatAttr (_aaebf ,_gfbc );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dcgd .SetPositioning (_gfdc .parsePositioningAttr (_aaebf ,_gfbc ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dcgd .SetFitMode (_gfdc .parseFitModeAttr (_aaebf ,_gfbc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dgea :=_gfdc .parseMarginAttr (_aaebf ,_gfbc );
_dcgd .SetMargins (_dgea .Left ,_dgea .Right ,_dgea .Top ,_dgea .Bottom );default:_gfdc .nodeLogDebug (_dgbfa ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_aaebf );
};};return _dcgd ,nil ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bgfd *Creator )SetOptimizer (optimizer _gf .Optimizer ){_bgfd ._egeb =optimizer };

// SetFillColor sets the fill color.
func (_aaaa *CurvePolygon )SetFillColor (color Color ){_aaaa ._cdbc =color ;_aaaa ._feaa .FillColor =_fbd (color );};

// SetOpacity sets opacity for border in range 0-1.
func (_efg *border )SetOpacity (opacity float64 ){_efg ._dbeg =opacity };

// AddLine adds a new line with the provided style to the table of contents.
func (_cgded *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_cgded ._efbef =append (_cgded ._efbef ,line );return line ;};func _ebgg ()*FilledCurve {_egba :=FilledCurve {};_egba ._ccggc =[]_dd .CubicBezierCurve {};return &_egba ;};


// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _dg .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_fd .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_gf .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_gf .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ce .ChartRenderable ;};

// SetDropCaps sets drop caps options for the paragraph.
// The drop caps will be applied during text wrapping and rendering.
//
// Note: Drop caps are currently not supported for RTL (right-to-left) text.
// If applied to RTL text, the feature will be automatically disabled during rendering
// with a debug log notification.
//
// Example:
//
//	p := c.NewStyledParagraph()
//	p.SetText("This is a paragraph with a beautiful drop cap...")
//	p.SetDropCaps(creator.DropCapsOptions{
//	    Type:     creator.DropCapsDrop,
//	    Scope:    creator.DropCapsFirstCharacter,
//	    NumLines: 3,
//	    Gap:      5.0,
//	})
//
// Example with custom style:
//
//	p := c.NewStyledParagraph()
//	p.SetText("This is a paragraph with a styled drop cap...")
//	dropCapStyle := creator.TextStyle{
//	    Font:  boldFont,
//	    Color: creator.ColorRGBFrom8bit(200, 0, 0), // Red
//	}
//	p.SetDropCaps(creator.DropCapsOptions{
//	    Type:     creator.DropCapsDrop,
//	    Scope:    creator.DropCapsFirstCharacter,
//	    NumLines: 3,
//	    Gap:      5.0,
//	    Style:    &dropCapStyle,
//	})
func (_adbcg *StyledParagraph )SetDropCaps (options DropCapsOptions ){if options .Type ==DropCapsNone {_adbcg ._ceaf =nil ;return ;};if options .NumLines <=0{options .NumLines =3;};if options .Gap <=0{options .Gap =5.0;};_adbcg ._ceaf =&options ;};

// DropCapsOptions contains configuration options for drop caps rendering.
type DropCapsOptions struct{

// Type specifies the drop caps type (Drop or Inline).
Type DropCapsType ;

// Scope defines what portion of the paragraph text gets drop caps treatment.
// Default: DropCapsFirstCharacter
Scope DropCapsScope ;

// NumLines specifies how many lines the drop cap should span.
// For DropCapsDrop: how many lines flow beside before continuing below.
// For DropCapsInline: affects the size of the drop cap character.
// Default: 3 lines.
NumLines int ;

// Gap specifies the horizontal distance between the drop cap and the text.
// Measured in points. Default: 5.0 points.
Gap float64 ;

// Style specifies the text style to apply to the drop cap character(s).
// This allows customization of font, color, outline, and other text properties.
// If nil, the drop cap will inherit the style from the first chunk of text.
// Note: The FontSize in this style will be overridden by the calculated size
// based on NumLines, but other properties like Color, Font, OutlineColor,
// CharSpacing, etc. will be applied.
Style *TextStyle ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Lines returns all the lines the table of contents has.
func (_dgeac *TOC )Lines ()[]*TOCLine {return _dgeac ._efbef };

// SetFillColor sets the fill color for the path.
func (_aaca *FilledCurve )SetFillColor (color Color ){_aaca ._fbca =color };func (_cccg *List )markerWidth ()float64 {var _acfg float64 ;for _ ,_egcg :=range _cccg ._agec {_cfbfg :=_bgdc (_cccg ._gcace );_cfbfg .SetEnableWrap (false );_cfbfg .SetTextAlignment (TextAlignmentRight );
_cfbfg .Append (_egcg ._fdab .Text ).Style =_egcg ._fdab .Style ;_agfbf :=_cfbfg .getTextWidth ()/1000.0;if _acfg < _agfbf {_acfg =_agfbf ;};};return _acfg ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_cdf *Block )SetStructureType (structureType _gf .StructureType ){};

// SetStyleRight sets border style for right side.
func (_gcg *border )SetStyleRight (style CellBorderStyle ){_gcg ._gdb =style };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{taggedDrawable ;_acaf float64 ;_dgec float64 ;_egdeb float64 ;_ebef float64 ;_gbbdg Positioning ;_ececd Color ;_dgaab float64 ;_agbbe Color ;_daegc float64 ;_cgdba float64 ;_ddfb float64 ;_ebdg float64 ;_afdd float64 ;_dbaed float64 ;
_ccafa Margins ;_ffbcg FitMode ;};func (_ceca *Chapter )headingNumber ()string {var _aab string ;if _ceca ._dbf {if _ceca ._abbd !=0{_aab =_ca .Itoa (_ceca ._abbd )+"\u002e";};if _ceca ._bad !=nil {_dfee :=_ceca ._bad .headingNumber ();if _dfee !=""{_aab =_dfee +_aab ;
};};};return _aab ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_baddd *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgagb :=ctx ;_ecfgg ,ctx ,_dcdgc :=_baddd ._bbcbd .GeneratePageBlocks (ctx );if _dcdgc !=nil {return _ecfgg ,ctx ,_dcdgc ;};for _ ,_baed :=range _baddd ._efbef {_fcdaf :=_baed ._fgeee ;
if !_baddd ._befbd {_baed ._fgeee =0;};_ggbgb ,_cfdg ,_bgaadd :=_baed .GeneratePageBlocks (ctx );_baed ._fgeee =_fcdaf ;if _bgaadd !=nil {return _ecfgg ,ctx ,_bgaadd ;};if len (_ggbgb )< 1{continue ;};_ecfgg [len (_ecfgg )-1].mergeBlocks (_ggbgb [0]);_ecfgg =append (_ecfgg ,_ggbgb [1:]...);
ctx =_cfdg ;};if _baddd ._fdffe .IsRelative (){ctx .X =_bgagb .X ;};if _baddd ._fdffe .IsAbsolute (){return _ecfgg ,_bgagb ,nil ;};return _ecfgg ,ctx ,nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_eebfb string ;_gffb *Image ;_fegbd *InvoiceAddress ;_dfce *InvoiceAddress ;_cgecf string ;_gfcd [2]*InvoiceCell ;_bdgb [2]*InvoiceCell ;_ccaab [2]*InvoiceCell ;_ceacc [][2]*InvoiceCell ;_ccgf []*InvoiceCell ;_dafad [][]*InvoiceCell ;
_efcb [2]*InvoiceCell ;_dfad [2]*InvoiceCell ;_eade [][2]*InvoiceCell ;_gebe [2]string ;_cbcac [2]string ;_ffbag [][2]string ;_agdg TextStyle ;_aaad TextStyle ;_cead TextStyle ;_afeef TextStyle ;_faaca TextStyle ;_bddf TextStyle ;_efba TextStyle ;_bggg InvoiceCellProps ;
_abfde InvoiceCellProps ;_ccbg InvoiceCellProps ;_dbed InvoiceCellProps ;_fbgb Positioning ;};func (_beefg *StyledParagraph )getTextWidth ()float64 {var _gafce float64 ;_fgcg :=len (_beefg ._gbbce );for _ecbea ,_dgcce :=range _beefg ._gbbce {_adgc :=&_dgcce .Style ;
_adga :=len (_dgcce .Text );for _baca ,_fcaf :=range _dgcce .Text {if _fcaf =='\u000A'{continue ;};_bcdbc ,_cbgde :=_adgc .Font .GetRuneMetrics (_fcaf );if !_cbgde {_ef .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fcaf );
return -1;};_gafce +=_adgc .FontSize *_bcdbc .Wx *_adgc .horizontalScale ();if _fcaf !=' '&&(_ecbea !=_fgcg -1||_baca !=_adga -1){_gafce +=_adgc .CharSpacing *1000.0;};};};return _gafce ;};

// SetStyleTop sets border style for top side.
func (_edf *border )SetStyleTop (style CellBorderStyle ){_edf ._aff =style };func (_dedfa *TextStyle )horizontalScale ()float64 {return _dedfa .HorizontalScaling /100};

// FitMode returns the fit mode of the ellipse.
func (_acfe *Ellipse )FitMode ()FitMode {return _acfe ._ccgb };

// WriteToFile writes the Creator output to file specified by path.
func (_afbfa *Creator )WriteToFile (outputPath string )error {_bbag ,_ccbb :=_f .Create (outputPath );if _ccbb !=nil {return _ccbb ;};defer _bbag .Close ();return _afbfa .Write (_bbag );};func (_abgfab *templateProcessor )parseBackground (_fbcbb *templateNode )(interface{},error ){_accfe :=&Background {};
for _ ,_afcgc :=range _fbcbb ._fdbe .Attr {_ggeedb :=_afcgc .Value ;switch _fdabc :=_afcgc .Name .Local ;_fdabc {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_accfe .FillColor =_abgfab .parseColorAttr (_fdabc ,_ggeedb );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_accfe .BorderColor =_abgfab .parseColorAttr (_fdabc ,_ggeedb );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_accfe .BorderSize =_abgfab .parseFloatAttr (_fdabc ,_ggeedb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_cafec ,_cbdde ,_daga ,_geac :=_abgfab .parseBorderRadiusAttr (_fdabc ,_ggeedb );
_accfe .SetBorderRadius (_cafec ,_cbdde ,_geac ,_daga );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_accfe .BorderRadiusTopLeft =_abgfab .parseFloatAttr (_fdabc ,_ggeedb );
case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_accfe .BorderRadiusTopRight =_abgfab .parseFloatAttr (_fdabc ,_ggeedb );case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_accfe .BorderRadiusBottomLeft =_abgfab .parseFloatAttr (_fdabc ,_ggeedb );
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_accfe .BorderRadiusBottomRight =_abgfab .parseFloatAttr (_fdabc ,_ggeedb );default:_abgfab .nodeLogDebug (_fbcbb ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_fdabc );
};};return _accfe ,nil ;};

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{taggedDrawable ;_ccggc []_dd .CubicBezierCurve ;FillEnabled bool ;_fbca Color ;BorderEnabled bool ;BorderWidth float64 ;_fgcb Color ;};

// SetTitle sets the title of the invoice.
func (_aceg *Invoice )SetTitle (title string ){_aceg ._eebfb =title };func _gbagg (_efbfc *_gf .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_efbfc ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_afbde *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bacac :=_afbde ;if _afbde ._afeec {_bacac =_afbde .clone ();};return _fgfbd (_bacac ,ctx );};

// FillColor returns the fill color of the rectangle.
func (_bbfac *Rectangle )FillColor ()Color {return _bbfac ._ececd };func (_cbdd *GraphicSVGElement )getGradientAngle ()float64 {_ccad ,_gaafa :=_cbdd .Attributes ["\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0054\u0072\u0061\u006es\u0066\u006f\u0072\u006d"];
if _gaafa {_gbgc :=_b .Fields (_ccad );for _ ,_efbed :=range _gbgc {_cbca :=_b .FieldsFunc (_efbed ,_bcbd );if len (_cbca )< 2{continue ;};if _cbca [0]=="\u0072\u006f\u0074\u0061\u0074\u0065"{_dccd ,_dcec :=_dfgc (_cbca [1]);if _dcec !=nil {_ef .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_ccad );
return 0.0;};return _dccd ;};};};return 0.0;};type Grid struct{taggedDrawable ;_daec int ;_ccaa []float64 ;_gegag float64 ;_gbfc Positioning ;_afcf ,_aege float64 ;_fabef Margins ;_fdagc []*GridRow ;};

// Write output of creator to io.Writer interface.
func (_adag *Creator )Write (ws _fd .Writer )error {if _dcbe :=_adag .Finalize ();_dcbe !=nil {return _dcbe ;};_abbf :="";if _cffa ,_badg :=ws .(*_f .File );_badg {_abbf =_cffa .Name ();};_acceb :=_gf .NewPdfWriter ();_acceb .SetOptimizer (_adag ._egeb );
_acceb .SetFileName (_abbf );if _adag ._edg !=nil {_fab :=_acceb .SetForms (_adag ._edg );if _fab !=nil {_ef .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fab );return _fab ;};};if _adag ._adaf !=nil {_acceb .AddOutlineTree (_adag ._adaf );
}else if _adag ._cced !=nil &&_adag .AddOutlines {_acceb .AddOutlineTree (&_adag ._cced .ToPdfOutline ().PdfOutlineTreeNode );};if _adag ._bcf !=nil {if _egaaf :=_acceb .SetPageLabels (_adag ._bcf );_egaaf !=nil {_ef .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_egaaf );
return _egaaf ;};};if _adag ._bbac !=nil {for _ ,_bggc :=range _adag ._bbac {_cfdd :=_bggc .SubsetRegistered ();if _cfdd !=nil {_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_cfdd );
return _cfdd ;};};};if _adag ._bcgd &&_adag ._gec !=nil {_acceb .SetCatalogMarkInfo (_cd .MakeDictMap (map[string ]_cd .PdfObject {"\u004d\u0061\u0072\u006b\u0065\u0064":_cd .MakeBool (true )}));};if _adag ._bbed !=nil {_afc :=_adag ._bbed (&_acceb );if _afc !=nil {_ef .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_afc );
return _afc ;};};for _gdc ,_gdca :=range _adag ._cbf {_cgggb :=_acceb .AddPage (_gdca );if _cgggb !=nil {_ef .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_cgggb );return _cgggb ;
};if _adag ._gec !=nil {if _adag ._bcgd {_gdca .SetStructParentsKey (_gdc );};_edde :=_adag ._gec .K ;_dafb ,_edbd :=_acceb .GetPageIndirectObject (_gdc );if _edbd !=nil {_ef .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0043\u006fu\u006c\u0064\u0020n\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061ge\u0020\u0069\u006ed\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074 \u0025\u0076",_edbd );
};var _egegg func (_eegg *_gf .KDict );_egegg =func (_fcdc *_gf .KDict ){if _fcdc ==nil {return ;};if _fcdc .GetPageNumber ()-1==int64 (_gdc ){_fcdc .SetPage (_dafb );};for _ ,_bff :=range _fcdc .GetChildren (){if _ceefb :=_bff .GetKDict ();_ceefb !=nil {_egegg (_ceefb );
};};};for _ ,_abbg :=range _edde {_egegg (_abbg );};};};if _adag ._gec !=nil {if _gged :=_acceb .SetCatalogStructTreeRoot (_adag ._gec .ToPdfObject ());_gged !=nil {_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020n\u006f\u0074\u0020\u0073\u0065\u0074 \u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006ft\u003a\u0020\u0025\u0076",_gged );
return _gged ;};};if _adag ._bcdb !=nil {if _ceab :=_acceb .SetCatalogViewerPreferences (_adag ._bcdb .ToPdfObject ());_ceab !=nil {_ef .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074\u0020\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073\u003a\u0020\u0025\u0076",_ceab );
return _ceab ;};};if _adag ._fgeb !=""{if _bdd :=_acceb .SetCatalogLanguage (_cd .MakeString (_adag ._fgeb ));_bdd !=nil {_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065t\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006c\u0061\u006e\u0067\u0075\u0061\u0067\u0065\u003a\u0020\u0025\u0076",_bdd );
return _bdd ;};};_ceeb :=_acceb .Write (ws );if _ceeb !=nil {return _ceeb ;};return nil ;};

// SetBorderOpacity sets the border opacity.
func (_aceec *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_aceec ._cbac =opacity };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetColPosition sets cell column position.
func (_gbbga *TableCell )SetColPosition (col int ){_gbbga ._facac =col };

// SetDropCapsInline sets inline drop caps for the paragraph, where all lines
// flow beside the enlarged character(s).
//
// Example:
//
//	p := c.NewStyledParagraph()
//	p.SetText("This paragraph has inline drop caps...")
//	p.SetDropCapsInline(creator.DropCapsFirstCharacter, 2, 5.0)
func (_gbddb *StyledParagraph )SetDropCapsInline (scope DropCapsScope ,numLines int ,gap float64 ){_gbddb .SetDropCaps (DropCapsOptions {Type :DropCapsInline ,Scope :scope ,NumLines :numLines ,Gap :gap });};

// SetLineWidth sets the line width.
func (_ffef *Line )SetLineWidth (width float64 ){_ffef ._gfbf =width };func (_affcc *templateProcessor )parseTextOverflowAttr (_afbec ,_gdbbc string )TextOverflow {_ef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_afbec ,_gdbbc );
_gaeb :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_gdbbc ];return _gaeb ;};func (_de *Block )setOpacity (_ac float64 ,_bfd float64 )(string ,error ){if (_ac < 0||_ac >=1.0)&&(_bfd < 0||_bfd >=1.0){return "",nil ;
};_gebb :=0;_aed :=_e .Sprintf ("\u0047\u0053\u0025\u0064",_gebb );for _de ._ebe .HasExtGState (_cd .PdfObjectName (_aed )){_gebb ++;_aed =_e .Sprintf ("\u0047\u0053\u0025\u0064",_gebb );};_ddg :=_cd .MakeDict ();if _ac >=0&&_ac < 1.0{_ddg .Set ("\u0063\u0061",_cd .MakeFloat (_ac ));
};if _bfd >=0&&_bfd < 1.0{_ddg .Set ("\u0043\u0041",_cd .MakeFloat (_bfd ));};_ceb :=_de ._ebe .AddExtGState (_cd .PdfObjectName (_aed ),_ddg );if _ceb !=nil {return "",_ceb ;};return _aed ,nil ;};func (_fgfb *FilledCurve )draw (_fddec *Block ,_gead string )([]byte ,*_gf .PdfRectangle ,error ){_afcg :=_dd .NewCubicBezierPath ();
for _ ,_cded :=range _fgfb ._ccggc {_afcg =_afcg .AppendCurve (_cded );};creator :=_ebf .NewContentCreator ();if _fgfb ._febd !=nil {creator .Add_BDC (*_cd .MakeName (string (_fgfb ._febd .StructureType )),map[string ]_cd .PdfObject {"\u004d\u0043\u0049\u0044":_cd .MakeInteger (_fgfb ._febd .Mcid )});
};creator .Add_q ();if _fgfb .FillEnabled &&_fgfb ._fbca !=nil {_defd :=_fbd (_fgfb ._fbca );_eadbg :=_bdced (_fddec ,_defd ,_fgfb ._fbca ,func ()Rectangle {_gdce :=_dd .NewCubicBezierPath ();for _ ,_gacg :=range _fgfb ._ccggc {_gdce =_gdce .AppendCurve (_gacg );
};_daacf :=_gdce .GetBoundingBox ();if _fgfb .BorderEnabled {_daacf .Height +=_fgfb .BorderWidth ;_daacf .Width +=_fgfb .BorderWidth ;_daacf .X -=_fgfb .BorderWidth /2;_daacf .Y -=_fgfb .BorderWidth /2;};return Rectangle {_acaf :_daacf .X ,_dgec :_daacf .Y ,_egdeb :_daacf .Width ,_ebef :_daacf .Height };
});if _eadbg !=nil {return nil ,nil ,_eadbg ;};creator .SetNonStrokingColor (_defd );};if _fgfb .BorderEnabled {if _fgfb ._fgcb !=nil {creator .SetStrokingColor (_fbd (_fgfb ._fgcb ));};creator .Add_w (_fgfb .BorderWidth );};if len (_gead )> 1{creator .Add_gs (_cd .PdfObjectName (_gead ));
};_dd .DrawBezierPathWithCreator (_afcg ,creator );creator .Add_h ();if _fgfb .FillEnabled &&_fgfb .BorderEnabled {creator .Add_B ();}else if _fgfb .FillEnabled {creator .Add_f ();}else if _fgfb .BorderEnabled {creator .Add_S ();};creator .Add_Q ();if _fgfb ._febd !=nil {creator .Add_EMC ();
};_bage :=_afcg .GetBoundingBox ();if _fgfb .BorderEnabled {_bage .Height +=_fgfb .BorderWidth ;_bage .Width +=_fgfb .BorderWidth ;_bage .X -=_fgfb .BorderWidth /2;_bage .Y -=_fgfb .BorderWidth /2;};_fagda :=&_gf .PdfRectangle {};_fagda .Llx =_bage .X ;
_fagda .Lly =_bage .Y ;_fagda .Urx =_bage .X +_bage .Width ;_fagda .Ury =_bage .Y +_bage .Height ;return creator .Bytes (),_fagda ,nil ;};func _bdffa (_aggec *templateProcessor ,_edbdb *templateNode )(interface{},error ){return _aggec .parseTextChunk (_edbdb ,nil );
};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_egeg *Chapter )SetShowNumbering (show bool ){_egeg ._dbf =show ;_egeg ._egge .SetText (_egeg .headingText ());};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{taggedDrawable ;

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_cgbff []*_gf .PdfAnnotation ;_bfcda []bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;_afcbd *string ;_dcbb *string ;_bdgga *string ;};

// DropCapsType represents the type of drop caps to apply to a paragraph.
// Note: Drop caps are currently not supported for RTL (right-to-left) text and will be
// automatically disabled with a debug log if applied to RTL content.
type DropCapsType int ;

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_ebegc *TOCLine )SetLevelOffset (levelOffset float64 ){_ebegc ._gdcafd =levelOffset ;_ebegc ._eccb ._dbge .Left =_ebegc ._gggea +float64 (_ebegc ._bacb -1)*_ebegc ._gdcafd ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_eeeg *Ellipse )SetFitMode (fitMode FitMode ){_eeeg ._ccgb =fitMode };

// Height returns the height of the chart.
func (_eedff *Chart )Height ()float64 {return float64 (_eedff ._ddba .Height ())};func (_cgdbe *templateProcessor )processGradientColorPair (_eadc []string )(_beaff []Color ,_ageef []float64 ){for _ ,_egdfg :=range _eadc {var (_aacaf =_b .Fields (_egdfg );
_begbf =len (_aacaf ););if _begbf ==0{continue ;};_gcegd :="";if _begbf > 1{_gcegd =_b .TrimSpace (_aacaf [1]);};_ffgbb :=-1.0;if _b .HasSuffix (_gcegd ,"\u0025"){_deeeee ,_egcef :=_ca .ParseFloat (_gcegd [:len (_gcegd )-1],64);if _egcef !=nil {_ef .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_egcef );
};_ffgbb =_deeeee /100.0;};_ddddg :=_cgdbe .parseColor (_b .TrimSpace (_aacaf [0]));if _ddddg !=nil {_beaff =append (_beaff ,_ddddg );_ageef =append (_ageef ,_ffgbb );};};if len (_beaff )!=len (_ageef ){_ef .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_eabb :=-1;_gfcdfc :=0.0;for _cccab ,_daggg :=range _ageef {if _daggg ==-1.0{if _cccab ==0{_daggg =0.0;_ageef [_cccab ]=0.0;continue ;};_eabb ++;if _cccab < len (_ageef )-1{continue ;}else {_daggg =1.0;_ageef [_cccab ]=1.0;};};_egcea :=_eabb +1;
for _bbdagd :=_cccab -_eabb ;_bbdagd < _cccab ;_bbdagd ++{_ageef [_bbdagd ]=_gfcdfc +(float64 (_bbdagd )*(_daggg -_gfcdfc )/float64 (_egcea ));};_gfcdfc =_daggg ;_eabb =-1;};return _beaff ,_ageef ;};func (_dc *Block )addContents (_abgf *_ebf .ContentStreamOperations ){*_dc ._bac =append (*_dc ._bac ,*_abgf ...);
};

// SetStructureType sets the structure type for the grid.
func (_egdd *Grid )SetStructureType (structureType _gf .StructureType ){if _egdd ._febd ==nil {_egdd ._febd =&_gf .StructureTagInfo {};};_egdd ._febd .StructureType =structureType ;if _egdd ._febd .ComponentKObj ==nil {if _egdd ._febd .ParentKObj !=nil {_egdd ._febd .ParentKObj .RemoveKChild (_egdd ._febd .ComponentKObj );
};_egdd ._febd .ComponentKObj =_gf .NewKDictionary ();_egdd ._febd .ComponentKObj .S =_cd .MakeName (string (structureType ));_egdd ._febd .ParentKObj .AddKChild (_egdd ._febd .ComponentKObj );};};var PPMM =float64 (72*1.0/25.4);func (_bfgfc *Rectangle )applyFitMode (_ggfc float64 ){_ggfc -=_bfgfc ._ccafa .Left +_bfgfc ._ccafa .Right +_bfgfc ._daegc ;
switch _bfgfc ._ffbcg {case FitModeFillWidth :_bfgfc .ScaleToWidth (_ggfc );};};

// Margins returns the margins of the component.
func (_dcce *Division )Margins ()(_bbgc ,_faaa ,_efbe ,_bagbc float64 ){return _dcce ._ffd .Left ,_dcce ._ffd .Right ,_dcce ._ffd .Top ,_dcce ._ffd .Bottom ;};

// Vertical returns total vertical (top + bottom) margin.
func (_accf *Margins )Vertical ()float64 {return _accf .Bottom +_accf .Top };func _aedfg (_bcgdd TextStyle )*List {return &List {_eaeba :TextChunk {Text :"\u2022\u0020",Style :_bcgdd },_eafe :0,_dbdb :true ,_fabbb :PositionRelative ,_gcace :_bcgdd ,taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeList }};
};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_cadee *Image )GetHorizontalAlignment ()HorizontalAlignment {return _cadee ._dagce };

// SetBorderOpacity sets the border opacity of the rectangle.
func (_dcagb *Rectangle )SetBorderOpacity (opacity float64 ){_dcagb ._cgdba =opacity };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_efec *Creator )SetOutlineTree (outlineTree *_gf .PdfOutlineTreeNode ){_efec ._adaf =outlineTree };func _gdbbd (_ggfe *_gf .PdfAnnotation )*_gf .PdfAnnotation {if _ggfe ==nil {return nil ;};var _cabfc *_gf .PdfAnnotation ;switch _cbbae :=_ggfe .GetContext ().(type ){case *_gf .PdfAnnotationLink :if _dgdb :=_fffc (_cbbae );
_dgdb !=nil {_cabfc =_dgdb .PdfAnnotation ;};case *_gf .PdfAnnotationHighlight :if _cdced :=_edfb (_cbbae );_cdced !=nil {_cabfc =_cdced .PdfAnnotation ;};};return _cabfc ;};

// SetRowPosition sets cell row position.
func (_gefg *TableCell )SetRowPosition (row int ){_gefg ._efdd =row };func (_aedg *Paragraph )wrapText ()error {if !_aedg ._daabg ||int (_aedg ._afeca )<=0{_aedg ._bbbd =[]string {_aedg ._edceg };return nil ;};_fecfg :=NewTextChunk (_aedg ._edceg ,TextStyle {Font :_aedg ._abbaf ,FontSize :_aedg ._fagc });
_gcbf ,_ddcea :=_fecfg .Wrap (_aedg ._afeca );if _ddcea !=nil {return _ddcea ;};if _aedg ._egfcd > 0&&len (_gcbf )> _aedg ._egfcd {_gcbf =_gcbf [:_aedg ._egfcd ];};_aedg ._bbbd =_gcbf ;return nil ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_eccb *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gggea float64 ;_bacb uint ;_gdcafd float64 ;_dbbff Positioning ;_fdfd float64 ;_abfdc float64 ;_fgeee int64 ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_cgeaeg *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_cgeaeg ._gddg =dashArray ;_cgeaeg ._edaa =dashPhase ;};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_bgbc *Rectangle )ScaleToWidth (w float64 ){_ceebc :=_bgbc ._ebef /_bgbc ._egdeb ;_bgbc ._egdeb =w ;_bgbc ._ebef =w *_ceebc ;};func (_bfge *templateProcessor )nodeError (_agcg *templateNode ,_cfeff string ,_gdef ...interface{})error {return _e .Errorf ("\u0025\u0073",_bfge .getNodeErrorLocation (_agcg ,_cfeff ,_gdef ...));
};

// SetFontSize sets the font size for the paragraph.
func (_gbgce *StyledParagraph )SetFontSize (fontSize float64 ){_gbgce ._dgaag .FontSize =fontSize ;for _ ,_edaad :=range _gbgce ._gbbce {_edaad .Style .FontSize =fontSize ;};};

// Append adds a new text chunk to the paragraph.
func (_ggedb *StyledParagraph )Append (text string )*TextChunk {_ccgbd :=NewTextChunk (text ,_ggedb ._dgaag );return _ggedb .appendChunk (_ccgbd );};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_cebeg *Table )EnablePageWrap (enable bool ){_cebeg ._ccea =enable };

// GeneratePageBlocks draws the chart onto a block.
func (_fbcg *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcef :=ctx ;_gea :=_fbcg ._ggcc .IsRelative ();var _ffbd []*Block ;if _gea {_dgd :=1.0;_bbec :=_fbcg ._bade .Top ;if float64 (_fbcg ._ddba .Height ())> ctx .Height -_fbcg ._bade .Top {_ffbd =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _age error ;if _ ,ctx ,_age =_fbbb ().GeneratePageBlocks (ctx );_age !=nil {return nil ,ctx ,_age ;};_bbec =0;};ctx .X +=_fbcg ._bade .Left +_dgd ;ctx .Y +=_bbec ;ctx .Width -=_fbcg ._bade .Left +_fbcg ._bade .Right +2*_dgd ;ctx .Height -=_bbec ;_fbcg ._ddba .SetWidth (int (ctx .Width ));
}else {ctx .X =_fbcg ._gdgb ;ctx .Y =_fbcg ._ggef ;};_cada :=_ebf .NewContentCreator ();if _fbcg ._febd !=nil {_cada .Add_BDC (*_cd .MakeName (string (_fbcg ._febd .StructureType )),map[string ]_cd .PdfObject {"\u004d\u0043\u0049\u0044":_cd .MakeInteger (_fbcg ._febd .Mcid )});
};_cada .Translate (0,ctx .PageHeight );_cada .Scale (1,-1);_cada .Translate (ctx .X ,ctx .Y );_eebc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fbcg ._ddba .Render (_ae .NewRenderer (_cada ,_eebc ._ebe ),nil );if _fbcg ._febd !=nil {_cada .Add_EMC ();
};if _ecad :=_eebc .addContentsByString (_cada .String ());_ecad !=nil {return nil ,ctx ,_ecad ;};if _gea {_fcgb :=_fbcg .Height ()+_fbcg ._bade .Bottom ;ctx .Y +=_fcgb ;ctx .Height -=_fcgb ;}else {ctx =_fcef ;};_ffbd =append (_ffbd ,_eebc );return _ffbd ,ctx ,nil ;
};

// AddColorStop add color stop information for rendering gradient.
func (_fdeee *shading )AddColorStop (color Color ,point float64 ){_fdeee ._fcefg =append (_fdeee ._fcefg ,_dggf (color ,point ));};

// Width returns the width of the Paragraph.
func (_dgdc *StyledParagraph )Width ()float64 {if _dgdc ._ffeac &&int (_dgdc ._ffdb )> 0{return _dgdc ._ffdb ;};return _dgdc .getTextWidth ()/1000.0;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_ggbb *shading )SetAntiAlias (enable bool ){_ggbb ._fgad =enable };

// SetFillColor sets the fill color of the ellipse.
func (_fgdc *Ellipse )SetFillColor (col Color ){_fgdc ._cefg =col };

// Width returns the width of the graphic svg.
func (_caee *GraphicSVG )Width ()float64 {return _caee ._aagdf .Width };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_aebf *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_afa ,_cfad :=_dad .setOpacity (_aebf ._ccc ,_aebf ._bdeb );if _cfad !=nil {return nil ,ctx ,_cfad ;};_gfed :=_aebf ._feaa ;
_gfed .FillEnabled =_gfed .FillColor !=nil ;_gfed .BorderEnabled =_gfed .BorderColor !=nil &&_gfed .BorderWidth > 0;var (_abfcf =ctx .PageHeight ;_gggf =_gfed .Rings ;_ffga =make ([][]_dd .CubicBezierCurve ,0,len (_gfed .Rings )););_caaf :=_gf .PdfRectangle {};
if len (_gggf )> 0&&len (_gggf [0])> 0{_badcb :=_gggf [0][0];_badcb .P0 .Y =_abfcf -_badcb .P0 .Y ;_badcb .P1 .Y =_abfcf -_badcb .P1 .Y ;_badcb .P2 .Y =_abfcf -_badcb .P2 .Y ;_badcb .P3 .Y =_abfcf -_badcb .P3 .Y ;_caaf =_badcb .GetBounds ();};for _ ,_gfcc :=range _gggf {_bdfe :=make ([]_dd .CubicBezierCurve ,0,len (_gfcc ));
for _ ,_dfga :=range _gfcc {_ggbcg :=_dfga ;_ggbcg .P0 .Y =_abfcf -_ggbcg .P0 .Y ;_ggbcg .P1 .Y =_abfcf -_ggbcg .P1 .Y ;_ggbcg .P2 .Y =_abfcf -_ggbcg .P2 .Y ;_ggbcg .P3 .Y =_abfcf -_ggbcg .P3 .Y ;_bdfe =append (_bdfe ,_ggbcg );_dbcf :=_ggbcg .GetBounds ();
_caaf .Llx =_fb .Min (_caaf .Llx ,_dbcf .Llx );_caaf .Lly =_fb .Min (_caaf .Lly ,_dbcf .Lly );_caaf .Urx =_fb .Max (_caaf .Urx ,_dbcf .Urx );_caaf .Ury =_fb .Max (_caaf .Ury ,_dbcf .Ury );};_ffga =append (_ffga ,_bdfe );};_gfed .Rings =_ffga ;defer func (){_gfed .Rings =_gggf }();
if _gfed .FillEnabled {_facf :=_bdced (_dad ,_aebf ._feaa .FillColor ,_aebf ._cdbc ,func ()Rectangle {return Rectangle {_acaf :_caaf .Llx ,_dgec :_caaf .Lly ,_egdeb :_caaf .Width (),_ebef :_caaf .Height ()};});if _facf !=nil {return nil ,ctx ,_facf ;};
};_dcgg ,_ ,_cfad :=_gfed .MarkedDraw (_afa ,_aebf ._febd );if _cfad !=nil {return nil ,ctx ,_cfad ;};if _cfad =_dad .addContentsByString (string (_dcgg ));_cfad !=nil {return nil ,ctx ,_cfad ;};return []*Block {_dad },ctx ,nil ;};func (_eaaa *GridCell )width (_cddde []float64 ,_dgef float64 )float64 {_daecf :=float64 (0.0);
for _ebbf :=0;_ebbf < _eaaa ._cabd ;_ebbf ++{_daecf +=_cddde [_eaaa ._ecabf +_ebbf ];};return _daecf *_dgef ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_fabcc *TOC )SetLineLevelOffset (levelOffset float64 ){_fabcc ._dcae =levelOffset };

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{taggedDrawable ;_ddba _ce .ChartRenderable ;_ggcc Positioning ;_gdgb float64 ;_ggef float64 ;_bade Margins ;};

// SetSection sets whether this row is a header row.
func (_aacf *GridRow )SetSection (role GridRowSection ){_aacf ._ddce =role };type pageTransformations struct{_gef *_ee .Matrix ;_dffe bool ;_cfef bool ;};func (_efeaf *Grid )resetColumnWidths (){_efeaf ._ccaa =[]float64 {};_caabb :=float64 (1.0)/float64 (_efeaf ._daec );
for _bgca :=0;_bgca < _efeaf ._daec ;_bgca ++{_efeaf ._ccaa =append (_efeaf ._ccaa ,_caabb );};};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_gdad *Table )Width ()float64 {return 0};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func (_egegf *templateProcessor )parseEllipse (_decaff *templateNode )(interface{},error ){_dabdg :=_egegf .creator .NewEllipse (0,0,0,0);for _ ,_gbeaf :=range _decaff ._fdbe .Attr {_cdbcd :=_gbeaf .Value ;
switch _ffbbf :=_gbeaf .Name .Local ;_ffbbf {case "\u0063\u0078":_dabdg ._eaee =_egegf .parseFloatAttr (_ffbbf ,_cdbcd );case "\u0063\u0079":_dabdg ._cbcg =_egegf .parseFloatAttr (_ffbbf ,_cdbcd );case "\u0077\u0069\u0064t\u0068":_dabdg .SetWidth (_egegf .parseFloatAttr (_ffbbf ,_cdbcd ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_dabdg .SetHeight (_egegf .parseFloatAttr (_ffbbf ,_cdbcd ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dabdg .SetFillColor (_egegf .parseColorAttr (_ffbbf ,_cdbcd ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_dabdg .SetFillOpacity (_egegf .parseFloatAttr (_ffbbf ,_cdbcd ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dabdg .SetBorderColor (_egegf .parseColorAttr (_ffbbf ,_cdbcd ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_dabdg .SetBorderOpacity (_egegf .parseFloatAttr (_ffbbf ,_cdbcd ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_dabdg .SetBorderWidth (_egegf .parseFloatAttr (_ffbbf ,_cdbcd ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dabdg .SetPositioning (_egegf .parsePositioningAttr (_ffbbf ,_cdbcd ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dabdg .SetFitMode (_egegf .parseFitModeAttr (_ffbbf ,_cdbcd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fbagg :=_egegf .parseMarginAttr (_ffbbf ,_cdbcd );_dabdg .SetMargins (_fbagg .Left ,_fbagg .Right ,_fbagg .Top ,_fbagg .Bottom );
default:_egegf .nodeLogDebug (_decaff ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ffbbf );
};};return _dabdg ,nil ;};func (_bbacg *RadialShading )shadingModel ()*_gf .PdfShadingType3 {_eadbge ,_cgga ,_fcbgd :=_bbacg ._acad ._egdad .ToRGB ();var _bbgg _dd .Point ;switch _bbacg ._debd {case AnchorBottomLeft :_bbgg =_dd .Point {X :_bbacg ._eggbc .Llx ,Y :_bbacg ._eggbc .Lly };
case AnchorBottomRight :_bbgg =_dd .Point {X :_bbacg ._eggbc .Urx ,Y :_bbacg ._eggbc .Ury -_bbacg ._eggbc .Height ()};case AnchorTopLeft :_bbgg =_dd .Point {X :_bbacg ._eggbc .Llx ,Y :_bbacg ._eggbc .Lly +_bbacg ._eggbc .Height ()};case AnchorTopRight :_bbgg =_dd .Point {X :_bbacg ._eggbc .Urx ,Y :_bbacg ._eggbc .Ury };
case AnchorLeft :_bbgg =_dd .Point {X :_bbacg ._eggbc .Llx ,Y :_bbacg ._eggbc .Lly +_bbacg ._eggbc .Height ()/2};case AnchorTop :_bbgg =_dd .Point {X :_bbacg ._eggbc .Llx +_bbacg ._eggbc .Width ()/2,Y :_bbacg ._eggbc .Ury };case AnchorRight :_bbgg =_dd .Point {X :_bbacg ._eggbc .Urx ,Y :_bbacg ._eggbc .Lly +_bbacg ._eggbc .Height ()/2};
case AnchorBottom :_bbgg =_dd .Point {X :_bbacg ._eggbc .Urx +_bbacg ._eggbc .Width ()/2,Y :_bbacg ._eggbc .Lly };default:_bbgg =_dd .NewPoint (_bbacg ._eggbc .Llx +_bbacg ._eggbc .Width ()/2,_bbacg ._eggbc .Lly +_bbacg ._eggbc .Height ()/2);};_bbacb :=_bbacg ._abega ;
_abbgeb :=_bbacg ._gccb ;_fggbc :=_bbgg .X +_bbacg ._bfcd ;_dedg :=_bbgg .Y +_bbacg ._bffce ;if _bbacb ==-1.0{_bbacb =0.0;};if _abbgeb ==-1.0{var _cbgdc []float64 ;_efaff :=_fb .Pow (_fggbc -_bbacg ._eggbc .Llx ,2)+_fb .Pow (_dedg -_bbacg ._eggbc .Lly ,2);
_cbgdc =append (_cbgdc ,_fb .Abs (_efaff ));_bgaa :=_fb .Pow (_fggbc -_bbacg ._eggbc .Llx ,2)+_fb .Pow (_bbacg ._eggbc .Lly +_bbacg ._eggbc .Height ()-_dedg ,2);_cbgdc =append (_cbgdc ,_fb .Abs (_bgaa ));_efdc :=_fb .Pow (_bbacg ._eggbc .Urx -_fggbc ,2)+_fb .Pow (_dedg -_bbacg ._eggbc .Ury -_bbacg ._eggbc .Height (),2);
_cbgdc =append (_cbgdc ,_fb .Abs (_efdc ));_fcdbg :=_fb .Pow (_bbacg ._eggbc .Urx -_fggbc ,2)+_fb .Pow (_bbacg ._eggbc .Ury -_dedg ,2);_cbgdc =append (_cbgdc ,_fb .Abs (_fcdbg ));_ebc .Slice (_cbgdc ,func (_bebd ,_efcgg int )bool {return _bebd > _efcgg });
_abbgeb =_fb .Sqrt (_cbgdc [0]);};_bfaa :=&_gf .PdfRectangle {Llx :_fggbc -_abbgeb ,Lly :_dedg -_abbgeb ,Urx :_fggbc +_abbgeb ,Ury :_dedg +_abbgeb };_abdcd :=_gf .NewPdfShadingType3 ();_abdcd .ShadingType =_cd .MakeInteger (3);_abdcd .ColorSpace =_gf .NewPdfColorspaceDeviceRGB ();
_abdcd .Background =_cd .MakeArrayFromFloats ([]float64 {_eadbge ,_cgga ,_fcbgd });_abdcd .BBox =_bfaa ;_abdcd .AntiAlias =_cd .MakeBool (_bbacg ._acad ._fgad );_abdcd .Coords =_cd .MakeArrayFromFloats ([]float64 {_fggbc ,_dedg ,_bbacb ,_fggbc ,_dedg ,_abbgeb });
_abdcd .Domain =_cd .MakeArrayFromFloats ([]float64 {0.0,1.0});_abdcd .Extend =_cd .MakeArray (_cd .MakeBool (_bbacg ._acad ._defcc [0]),_cd .MakeBool (_bbacg ._acad ._defcc [1]));_abdcd .Function =_bbacg ._acad .generatePdfFunctions ();return _abdcd ;
};

// SetColor sets the line color.
func (_egec *Curve )SetColor (col Color ){_egec ._bbbb =col };

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_efcf DrawContext )([]*Block ,DrawContext ,error );

// SetMarkedContentID sets the marked content id for the drawable.
SetMarkedContentID (_bedc int64 );

// SetStructureType sets the structure type for the drawable.
SetStructureType (_bdce _gf .StructureType );

// GenerateKDict generates a K dictionary for the drawable.
GenerateKDict ()(*_gf .KDict ,error );

// SetStructPageNumber sets the page number where the structure element for this drawable is located.
SetStructPageNumber (_aec *int64 );};

// RotatedSize returns the width and height of the rotated block.
func (_cf *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_bacd ,_fee :=_ebebc (_cf ._ddf ,_cf ._geb ,_cf ._aag );return _bacd ,_fee ;};

// NewDivision returns a new Division container component.
func (_fccf *Creator )NewDivision ()*Division {return _ffbf ()};func _bcbd (_bdfgg rune )bool {return _bdfgg =='('||_bdfgg ==','||_bdfgg ==')'};func (_bdda *Grid )insertRowAfter (_bacee int ,_affa *GridRow ){_bdda ._fdagc =append (_bdda ._fdagc ,&GridRow {});
copy (_bdda ._fdagc [_bacee +2:],_bdda ._fdagc [_bacee +1:]);_bdda ._fdagc [_bacee +1]=_affa ;for _dgeb ,_gfccb :=range _bdda ._fdagc {if _dgeb > _bacee +1{_gfccb ._fbagff +=1;for _ ,_ffgba :=range _gfccb ._cffad {_ffgba ._cbbe +=1;};};};};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_efdg Color ;_bccb float64 ;};

// IsRelative checks if the positioning is relative.
func (_fafe Positioning )IsRelative ()bool {return _fafe ==PositionRelative };func _begc (_gbcbc *templateProcessor ,_cfegg *templateNode )(interface{},error ){return _gbcbc .parseLine (_cfegg );};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_bdcf *GraphicSVG )ScaleToWidth (w float64 ){_gdcb :=_bdcf ._aagdf .Height /_bdcf ._aagdf .Width ;_bdcf ._aagdf .Width =w ;_bdcf ._aagdf .Height =w *_gdcb ;_bdcf ._aagdf .SetScaling (_gdcb ,_gdcb );};func _efeed (_cfbb *templateProcessor ,_dcbc *templateNode )(interface{},error ){return _cfbb .parseImage (_dcbc );
};

// Height returns the height of the ellipse.
func (_agbfc *Ellipse )Height ()float64 {return _agbfc ._feegb };func (_eegd *templateProcessor )parseLineStyleAttr (_bggdf ,_bdgg string )_dd .LineStyle {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bggdf ,_bdgg );
_cefgf :=map[string ]_dd .LineStyle {"\u0073\u006f\u006ci\u0064":_dd .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_dd .LineStyleDashed }[_bdgg ];return _cefgf ;};func (_dabgd *GraphicSVGElement )setDefaultScaling (_gebc float64 ){_dabgd ._bcae =_gebc ;
if _dabgd .Style !=nil &&_dabgd .Style .StrokeWidth > 0{_dabgd .Style .StrokeWidth =_dabgd .Style .StrokeWidth *_dabgd ._bcae ;};for _ ,_feff :=range _dabgd .Children {_feff .setDefaultScaling (_gebc );};};

// SetBorder sets the cell's border style.
func (_adafc *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_adafc ._ddcce =CellBorderStyleSingle ;_adafc ._bgeeg =width ;_adafc ._gebca =CellBorderStyleSingle ;
_adafc ._gafaf =width ;_adafc ._efabe =CellBorderStyleSingle ;_adafc ._cdeb =width ;_adafc ._cdefc =CellBorderStyleSingle ;_adafc ._ecee =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_adafc ._ddcce =CellBorderStyleDouble ;_adafc ._bgeeg =width ;
_adafc ._gebca =CellBorderStyleDouble ;_adafc ._gafaf =width ;_adafc ._efabe =CellBorderStyleDouble ;_adafc ._cdeb =width ;_adafc ._cdefc =CellBorderStyleDouble ;_adafc ._ecee =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_adafc ._ddcce =style ;
_adafc ._bgeeg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_adafc ._gebca =style ;_adafc ._gafaf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_adafc ._efabe =style ;
_adafc ._cdeb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_adafc ._cdefc =style ;_adafc ._ecee =width ;};};

// SetBackgroundColor sets the cell's background color.
func (_aeefb *GridCell )SetBackgroundColor (col Color ){_aeefb ._gcbd =col };

// Width returns the width of the ellipse.
func (_fagd *Ellipse )Width ()float64 {return _fagd ._feeac };

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_edag *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_edag ._edgce =halign };func _afeae (_abefb []float64 )[]float64 {for _fbeb ,_faefg :=0,len (_abefb )-1;_fbeb < _faefg ;_fbeb ,_faefg =_fbeb +1,_faefg -1{_abefb [_fbeb ],_abefb [_faefg ]=_abefb [_faefg ],_abefb [_fbeb ];
};return _abefb ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_dbg :_fb .Max (_fb .Min (c ,1.0),0.0),_dcg :_fb .Max (_fb .Min (m ,1.0),0.0),_acag :_fb .Max (_fb .Min (y ,1.0),0.0),_fgae :_fb .Max (_fb .Min (k ,1.0),0.0)};};func (_aafb *InvoiceAddress )fmtLine (_bcda ,_ggfgc string ,_egfcb bool )string {if _egfcb {_ggfgc ="";
};return _e .Sprintf ("\u0025\u0073\u0025s\u000a",_ggfgc ,_bcda );};func (_fdba *Table )addListItemTag ()*_gf .KDict {_dgbc :=_gf .NewKDictionary ();_dgbc .S =_cd .MakeName (string (_gf .StructureTypeListItem ));_fdba ._febd .ComponentKObj .AddKChild (_dgbc );
return _dgbc ;};

// SetWidthLeft sets border width for left.
func (_ggce *border )SetWidthLeft (bw float64 ){_ggce ._bag =bw };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_ccaga *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_ccaga ._daebe {_ef .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ccaga ._beeaca =widths ;return nil ;};

// Opacity returns the opacity of the line.
func (_fbff *Line )Opacity ()float64 {return _fbff ._caabd };func _fafa ()*listItem {return &listItem {}};func (_acfdd *StyledParagraph )wrapChunks (_caaceb bool )error {if !_acfdd ._ffeac ||int (_acfdd ._ffdb )<=0{_acfdd ._aeggc =[][]*TextChunk {_acfdd ._gbbce };
return nil ;};for _ ,_geeca :=range _acfdd ._gbbce {if _geeca .Style .HorizontalScaling ==0{_geeca .Style .HorizontalScaling =DefaultHorizontalScaling ;};};if _acfdd ._fcgd {_acfdd .wrapWordChunks ();};if _acfdd ._ceaf !=nil &&len (_acfdd ._gbbce )> 0&&len (_acfdd ._gbbce [0].Text )> 0{_cfeg :=_acfdd ._gbbce [0];
_gcfc :=_acfdd ._ceaf ;if !_cd .IsTextWriteDirectionLTR (_cfeg .Text ){_ef .Log .Debug ("\u0044\u0072op\u0020\u0063\u0061p\u0073\u0020\u006e\u006ft s\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0066or\u0020\u0052\u0054\u004c\u0020\u0074\u0065x\u0074");
_acfdd ._ceaf =nil ;}else if _gcfc .Type !=DropCapsNone &&!_acfdd ._bcfc {var _ddaf *TextChunk ;switch _gcfc .Scope {case DropCapsFirstCharacter :_feege :=[]rune (_cfeg .Text );if len (_feege )> 0{_ddaf =_cfeg .clone ();_ddaf .Text =string (_feege [0]);
if _gcfc .Style !=nil {_ddaf .Style =*_gcfc .Style ;};if _ddaf .Style .HorizontalScaling ==0{_ddaf .Style .HorizontalScaling =DefaultHorizontalScaling ;};if len (_feege )> 1{_cdeec :=_cfeg .clone ();_cdeec .Text =string (_feege [1:]);if _cdeec .Style .HorizontalScaling ==0{_cdeec .Style .HorizontalScaling =DefaultHorizontalScaling ;
};_acfdd ._gbbce [0]=_cdeec ;};};case DropCapsFirstWord :_cbeca :=_cfeg .Text ;_bebb :=_b .IndexAny (_cbeca ,"\u0020\u0009\u000a");_ddaf =_cfeg .clone ();_dggag :=_cfeg .clone ();if _bebb > 0{_ddaf .Text =_cbeca [:_bebb ];_dggag .Text =_b .TrimSpace (_cbeca [_bebb :]);
}else {_ddaf .Text =_cbeca ;_dggag .Text ="";};if _gcfc .Style !=nil {_ddaf .Style =*_gcfc .Style ;};if _ddaf .Style .HorizontalScaling ==0{_ddaf .Style .HorizontalScaling =DefaultHorizontalScaling ;};if _dggag .Style .HorizontalScaling ==0{_dggag .Style .HorizontalScaling =DefaultHorizontalScaling ;
};_acfdd ._gbbce [0]=_dggag ;default:_edfe :=[]rune (_cfeg .Text );if len (_edfe )> 0{_ddaf =_cfeg .clone ();_ddaf .Text =string (_edfe [0]);if _gcfc .Style !=nil {_ddaf .Style =*_gcfc .Style ;};if _ddaf .Style .HorizontalScaling ==0{_ddaf .Style .HorizontalScaling =DefaultHorizontalScaling ;
};if len (_edfe )> 1{_gbeg :=_cfeg .clone ();_gbeg .Text =string (_edfe [1:]);if _gbeg .Style .HorizontalScaling ==0{_gbeg .Style .HorizontalScaling =DefaultHorizontalScaling ;};_acfdd ._gbbce [0]=_gbeg ;};};};if _ddaf !=nil {_gefd :=_gcfc .NumLines ;if _gefd <=0{_gefd =3;
};var _gbgda *_gf .PdfFont ;var _fbab float64 ;if len (_acfdd ._gbbce )> 0{_gbgda =_acfdd ._gbbce [0].Style .Font ;_fbab =_acfdd ._gbbce [0].Style .FontSize ;}else if _acfdd ._dgaag .Font !=nil {_gbgda =_acfdd ._dgaag .Font ;_fbab =_acfdd ._dgaag .FontSize ;
}else {_gbgda =_ddaf .Style .Font ;_fbab =_ddaf .Style .FontSize ;};_abbad :=_bfcdf (_gbgda ,_fbab );_eecge :=_abbad ._bfefbg ;_faae :=_fbab ;_daagf :=_eecge +_faae ;if _daagf > _faae {_faae =_daagf ;};_eadg :=(_faae *float64 (_gefd ))-_eecge ;if _eadg <=0{_eadg =_fbab *float64 (_gefd );
};_ddaf .Style .FontSize =_eadg ;_acfdd ._bcfc =true ;_fagdc :=_acfdd ._gbbce ;_acfdd ._gbbce =[]*TextChunk {_ddaf };_acfdd ._gbbce =append (_acfdd ._gbbce ,_fagdc ...);};};};_acfdd ._aeggc =[][]*TextChunk {};var _gegfb []*TextChunk ;var _abegf float64 ;
_bcba :=_ge .IsSpace ;if !_caaceb {_bcba =func (rune )bool {return false };};_fccd :=_bafgb (_acfdd ._ffdb *1000.0,0.000001);_bfgde :=0;_bbccg :=0;var _dcgb *TextChunk ;if len (_acfdd ._gbbce )> 0&&_acfdd ._ceaf !=nil {_ccaac :=_acfdd ._ceaf ;if _ccaac .Type !=DropCapsNone &&_acfdd ._bcfc {_dcgb =_acfdd ._gbbce [0];
_bbccg =1;};};for _bdfgb :=_bbccg ;_bdfgb < len (_acfdd ._gbbce );_bdfgb ++{_aeffb :=_acfdd ._gbbce [_bdfgb ];_dabd :=_aeffb .Style ;_dace :=_aeffb ._cgbff ;_cddc :=_aeffb .VerticalAlignment ;var (_abaad []rune ;_eaec []float64 ;);_acfaf :=_cd .IsTextWriteDirectionLTR (_aeffb .Text );
for _ ,_dffea :=range _aeffb .Text {if _dffea =='\u000A'{if !_caaceb {_abaad =append (_abaad ,_dffea );};_gegfb =append (_gegfb ,&TextChunk {taggedDrawable :_aeffb .taggedDrawable ,Text :_b .TrimRightFunc (string (_abaad ),_bcba ),Style :_dabd ,_cgbff :_faecf (_dace ),VerticalAlignment :_cddc ,_afcbd :_aeffb ._afcbd ,_dcbb :_aeffb ._dcbb ,_bdgga :_aeffb ._bdgga });
if _beea :=_acfdd .addLine (_gegfb );!_beea {return nil ;};_bfgde ++;_gegfb =nil ;_abegf =0;_abaad =nil ;_eaec =nil ;continue ;};_bgbdd :=_dffea ==' ';_bgaeb ,_fadfe :=_dabd .Font .GetRuneMetrics (_dffea );if _bgaeb .Wx ==0&&_dabd .MultiFont !=nil ||_dabd .MultiFont !=nil &&!_fadfe {_bgaeb ,_fadfe =_dabd .MultiFont .GetRuneMetrics (_dffea );
};if !_fadfe {_ef .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dffea );return _g .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_fdbdb :=_dabd .FontSize *_bgaeb .Wx *_dabd .horizontalScale ();_cfbg :=_fdbdb ;if !_bgbdd {_cfbg =_fdbdb +_dabd .CharSpacing *1000.0;};_cdgg :=_fccd ;if _dcgb !=nil {_dabbg :=_acfdd ._ceaf ;var _ebcgc float64 ;_baece :=[]rune (_dcgb .Text );for _fefab ,_fccfc :=range _baece {_fdea ,_aagc :=_dcgb .Style .Font .GetRuneMetrics (_fccfc );
if _aagc {_ebcgc +=_dcgb .Style .FontSize *_fdea .Wx *_dcgb .Style .horizontalScale ()/1000.0;if _fefab < len (_baece )-1{_ebcgc +=_dcgb .Style .CharSpacing ;};};};_gfdfa :=_dabbg .Gap ;if _gfdfa <=0{_gfdfa =5.0;};switch _dabbg .Type {case DropCapsDrop :if _bfgde < _dabbg .NumLines {_cdgg =_fccd -(_ebcgc *1000.0)-(_gfdfa *1000.0);
};case DropCapsInline :_cdgg =_fccd -(_ebcgc *1000.0)-(_gfdfa *1000.0);};};if _abegf +_fdbdb > _cdgg {_fgaa :=-1;if !_bgbdd {for _eefcb :=len (_abaad )-1;_eefcb >=0;_eefcb --{if _abaad [_eefcb ]==' '{_fgaa =_eefcb ;break ;};};};if _acfdd ._fcgd {_eegbb :=len (_gegfb );
if _eegbb > 0{_gegfb [_eegbb -1].Text =_b .TrimRightFunc (_gegfb [_eegbb -1].Text ,_bcba );_acfdd ._aeggc =append (_acfdd ._aeggc ,_gegfb );_gegfb =[]*TextChunk {};};_abaad =append (_abaad ,_dffea );_eaec =append (_eaec ,_cfbg );if _fgaa >=0{_abaad =_abaad [_fgaa +1:];
_eaec =_eaec [_fgaa +1:];};_abegf =0;for _ ,_gefca :=range _eaec {_abegf +=_gefca ;};if _abegf > _fccd {_cdbg :=string (_abaad [:len (_abaad )-1]);if !_acfdd ._acgf {_cdbg =_cd .FormatWriteDirectionLTR (_cdbg ,_acfaf );};if !_caaceb &&_bgbdd {_cdbg +="\u0020";
};_gegfb =append (_gegfb ,&TextChunk {taggedDrawable :_aeffb .taggedDrawable ,Text :_b .TrimRightFunc (_cdbg ,_bcba ),Style :_dabd ,_cgbff :_faecf (_dace ),VerticalAlignment :_cddc ,_afcbd :_aeffb ._afcbd ,_dcbb :_aeffb ._dcbb ,_bdgga :_aeffb ._bdgga });
if _fbagb :=_acfdd .addLine (_gegfb );!_fbagb {return nil ;};_bfgde ++;_gegfb =[]*TextChunk {};_abaad =[]rune {_dffea };_eaec =[]float64 {_cfbg };_abegf =_cfbg ;};continue ;};_cegcg :=string (_abaad );if _fgaa >=0{_cegcg =string (_abaad [0:_fgaa +1]);_abaad =_abaad [_fgaa +1:];
_abaad =append (_abaad ,_dffea );_eaec =_eaec [_fgaa +1:];_eaec =append (_eaec ,_cfbg );_abegf =0;for _ ,_abcf :=range _eaec {_abegf +=_abcf ;};}else {if _bgbdd {_abegf =0;_abaad =[]rune {};_eaec =[]float64 {};}else {_abegf =_cfbg ;_abaad =[]rune {_dffea };
_eaec =[]float64 {_cfbg };};};if !_acfdd ._acgf {_cegcg =_cd .FormatWriteDirectionLTR (_cegcg ,_acfaf );};if !_caaceb &&_bgbdd {_cegcg +="\u0020";};_gegfb =append (_gegfb ,&TextChunk {taggedDrawable :_aeffb .taggedDrawable ,Text :_b .TrimRightFunc (_cegcg ,_bcba ),Style :_dabd ,_cgbff :_faecf (_dace ),VerticalAlignment :_cddc ,_afcbd :_aeffb ._afcbd ,_dcbb :_aeffb ._dcbb ,_bdgga :_aeffb ._bdgga });
if _afgdf :=_acfdd .addLine (_gegfb );!_afgdf {return nil ;};_bfgde ++;_gegfb =[]*TextChunk {};}else {_abegf +=_cfbg ;_abaad =append (_abaad ,_dffea );_eaec =append (_eaec ,_cfbg );};};if len (_abaad )> 0{_faeg :=string (_abaad );if !_acfdd ._acgf {_faeg =_cd .FormatWriteDirectionLTR (_faeg ,_acfaf );
};_gegfb =append (_gegfb ,&TextChunk {taggedDrawable :_aeffb .taggedDrawable ,Text :_faeg ,Style :_dabd ,_cgbff :_faecf (_dace ),VerticalAlignment :_cddc ,_afcbd :_aeffb ._afcbd ,_dcbb :_aeffb ._dcbb ,_bdgga :_aeffb ._bdgga });};};if len (_gegfb )> 0{if _eafg :=_acfdd .addLine (_gegfb );
!_eafg {return nil ;};_bfgde ++;};if _dcgb !=nil {if len (_acfdd ._aeggc )> 0{_acfdd ._aeggc [0]=append ([]*TextChunk {_dcgb },_acfdd ._aeggc [0]...);}else {_acfdd ._aeggc =append (_acfdd ._aeggc ,[]*TextChunk {_dcgb });};};return nil ;};

// SetBackgroundColor sets the cell's background color.
func (_gddgb *TableCell )SetBackgroundColor (col Color ){_gddgb ._cbbgf =col };

// FitMode returns the fit mode of the line.
func (_cdafa *Line )FitMode ()FitMode {return _cdafa ._gcfg };

// SetFillOpacity sets the fill opacity of the rectangle.
func (_gacdb *Rectangle )SetFillOpacity (opacity float64 ){_gacdb ._dgaab =opacity };func (_ggga *GraphicSVGElement )drawEllipse (_feef *_ebf .ContentCreator ,_cfcf *_gf .PdfPageResources ){_feef .Add_q ();_ggga .Style .toContentStream (_feef ,_cfcf ,_ggga );
_gagb ,_cgbg :=_fgde (_ggga .Attributes ["\u0063\u0078"],64);if _cgbg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_cgbg .Error ());
};_cfda ,_cgbg :=_fgde (_ggga .Attributes ["\u0063\u0079"],64);if _cgbg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_cgbg .Error ());
};_dgfc ,_cgbg :=_fgde (_ggga .Attributes ["\u0072\u0078"],64);if _cgbg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_cgbg .Error ());
};_agce ,_cgbg :=_fgde (_ggga .Attributes ["\u0072\u0079"],64);if _cgbg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_cgbg .Error ());
};_efed :=_dgfc *_ggga ._bcae ;_fdca :=_agce *_ggga ._bcae ;_aagbc :=_gagb *_ggga ._bcae ;_bbaff :=_cfda *_ggga ._bcae ;_cgca :=_efed *_bdfb ;_becfg :=_fdca *_bdfb ;_bbdd :=_dd .NewCubicBezierPath ();_bbdd =_bbdd .AppendCurve (_dd .NewCubicBezierCurve (-_efed ,0,-_efed ,_becfg ,-_cgca ,_fdca ,0,_fdca ));
_bbdd =_bbdd .AppendCurve (_dd .NewCubicBezierCurve (0,_fdca ,_cgca ,_fdca ,_efed ,_becfg ,_efed ,0));_bbdd =_bbdd .AppendCurve (_dd .NewCubicBezierCurve (_efed ,0,_efed ,-_becfg ,_cgca ,-_fdca ,0,-_fdca ));_bbdd =_bbdd .AppendCurve (_dd .NewCubicBezierCurve (0,-_fdca ,-_cgca ,-_fdca ,-_efed ,-_becfg ,-_efed ,0));
_bbdd =_bbdd .Offset (_aagbc ,_bbaff );if _ggga .Style .StrokeWidth > 0{_bbdd =_bbdd .Offset (_ggga .Style .StrokeWidth /2,_ggga .Style .StrokeWidth /2);};_dd .DrawBezierPathWithCreator (_bbdd ,_feef );_ggga .Style .fillStroke (_feef );_feef .Add_h ();
_feef .Add_Q ();};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{taggedDrawable ;_cbbgf Color ;_ggcef float64 ;_decca _dd .LineStyle ;_ddcce CellBorderStyle ;_agfge Color ;_bgeeg float64 ;_gebca CellBorderStyle ;_gdae Color ;_gafaf float64 ;_efabe CellBorderStyle ;_fcdd Color ;_cdeb float64 ;_cdefc CellBorderStyle ;
_dadeb Color ;_ecee float64 ;_efdd ,_facac int ;_addgb int ;_ggfdg int ;_ebagf VectorDrawable ;_edgce CellHorizontalAlignment ;_bdfedc CellVerticalAlignment ;_aagdg float64 ;_gceg *Table ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_deccc *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgbgf :=ctx ;_ffae ,ctx ,_agecc :=_deccc ._eccb .GeneratePageBlocks (ctx );if _agecc !=nil {return _ffae ,ctx ,_agecc ;};if _deccc ._dbbff .IsRelative (){ctx .X =_fgbgf .X ;
};if _deccc ._dbbff .IsAbsolute (){return _ffae ,_fgbgf ,nil ;};return _ffae ,ctx ,nil ;};func (_cceed *templateProcessor )parseTable (_gcega *templateNode )(interface{},error ){var _accgd int64 ;for _ ,_gbdec :=range _gcega ._fdbe .Attr {_fedbc :=_gbdec .Value ;
switch _gbbcaf :=_gbdec .Name .Local ;_gbbcaf {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_accgd =_cceed .parseInt64Attr (_gbbcaf ,_fedbc );};};if _accgd <=0{_cceed .nodeLogDebug (_gcega ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_accgd );
_accgd =1;};_feacd :=_cceed .creator .NewTable (int (_accgd ));for _ ,_cbaba :=range _gcega ._fdbe .Attr {_abgdc :=_cbaba .Value ;switch _affab :=_cbaba .Name .Local ;_affab {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_feacd .SetColumnWidths (_cceed .parseFloatArray (_affab ,_abgdc )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_dbfg :=_cceed .parseMarginAttr (_affab ,_abgdc );_feacd .SetMargins (_dbfg .Left ,_dbfg .Right ,_dbfg .Top ,_dbfg .Bottom );case "\u0078":_feacd .SetPos (_cceed .parseFloatAttr (_affab ,_abgdc ),_feacd ._befbg );
case "\u0079":_feacd .SetPos (_feacd ._ddfeb ,_cceed .parseFloatAttr (_affab ,_abgdc ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_feacd ._faaga =int (_cceed .parseInt64Attr (_affab ,_abgdc ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_feacd ._dagb =int (_cceed .parseInt64Attr (_affab ,_abgdc ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_feacd .EnableRowWrap (_cceed .parseBoolAttr (_affab ,_abgdc ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_feacd .EnablePageWrap (_cceed .parseBoolAttr (_affab ,_abgdc ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_cceed .nodeLogDebug (_gcega ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_affab );
};};if _feacd ._faaga !=0&&_feacd ._dagb !=0{_febfe :=_feacd .SetHeaderRows (_feacd ._faaga ,_feacd ._dagb );if _febfe !=nil {_cceed .nodeLogDebug (_gcega ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_febfe );
};}else {_feacd ._faaga =0;_feacd ._dagb =0;};return _feacd ,nil ;};

// NewFilledCurve returns a instance of filled curve.
func (_gbfd *Creator )NewFilledCurve ()*FilledCurve {return _ebgg ()};

// SetLineWidth sets the line width.
func (_fdef *Polyline )SetLineWidth (lineWidth float64 ){_fdef ._fbcfa .LineWidth =lineWidth };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetEnableWrap sets the line wrapping enabled flag.
func (_eddf *StyledParagraph )SetEnableWrap (enableWrap bool ){_eddf ._ffeac =enableWrap ;_eddf ._dddf =false ;};func _ebcc (_aadaf *GraphicSVGElement ,_ccfdf *_ebf .ContentCreator ){_dadf ,_egeba :=_aadaf .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];
if _egeba {_cbbd :=_b .Fields (_dadf );for _ ,_gaadd :=range _cbbd {_dage :=_b .FieldsFunc (_gaadd ,_bcbd );if len (_dage )< 3{_ef .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_dadf );
return ;};_bbgff ,_fedcc :=_fgde (_dage [1],64);if _fedcc !=nil {_ef .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_dadf );
return ;};_bbaga ,_fedcc :=_fgde (_dage [2],64);if _fedcc !=nil {_ef .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_dadf );
return ;};switch _dage [0]{case "\u0074r\u0061\u006e\u0073\u006c\u0061\u0074e":_ccfdf .Translate (_bbgff ,_bbaga );case "\u0073\u0063\u0061l\u0065":_ccfdf .Scale (_bbgff ,_bbaga );default:_ef .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_dadf );
return ;};};};};

// SetScaling sets scaling value for graphic SVG and maintain the aspect ratio.
func (_deca *GraphicSVGElement )SetScaling (xFactor ,yFactor float64 ){_bffg :=_deca .Width /_deca .ViewBox .W ;_egbaa :=_deca .Height /_deca .ViewBox .H ;_deca .setDefaultScaling (_fb .Max (_bffg ,_egbaa ));for _ ,_eddd :=range _deca .Children {_eddd .SetScaling (xFactor ,yFactor );
};};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_ecaac *RadialShading )SetBackgroundColor (backgroundColor Color ){_ecaac ._acad .SetBackgroundColor (backgroundColor );};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_bg *Block )ScaleToHeight (h float64 ){_ebgf :=h /_bg ._geb ;_bg .Scale (_ebgf ,_ebgf )};

// SetAngle sets the rotation angle in degrees.
func (_fe *Block )SetAngle (angleDeg float64 ){_fe ._aag =angleDeg };

// TOC returns the table of contents component of the creator.
func (_cgff *Creator )TOC ()*TOC {return _cgff ._fagf };

// SetText sets the text content of the Paragraph.
func (_fgee *Paragraph )SetText (text string ){_fgee ._edceg =text };type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_bbfbg Drawable )(Drawable ,error );};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{taggedDrawable ;_abbd int ;_cede string ;_egge *StyledParagraph ;_ebea []Drawable ;_ada int ;_dbf bool ;_gge bool ;_acef Positioning ;_egdc Margins ;_bad *Chapter ;_fged *TOC ;_ecd *_gf .Outline ;_ffgb *_gf .OutlineItem ;_abfc uint ;
};var _gac =_gg .MustCompile ("\u005c\u0064\u002b");

// SkipOver skips over a specified number of rows and cols.
func (_aecf *Table )SkipOver (rows ,cols int ){_bdffd :=rows *_aecf ._daebe +cols -1;if _bdffd < 0{_ef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _dcfbd :=0;_dcfbd < _bdffd ;_dcfbd ++{_aecf .NewCell ();};};func (_gegf *Division )ctxHeight (_dagcf float64 )float64 {_dagcf -=_gegf ._ffd .Left +_gegf ._ffd .Right +_gegf ._aeg .Left +_gegf ._aeg .Right ;var _aagb float64 ;for _ ,_bfgb :=range _gegf ._cbg {_aagb +=_efcg (_bfgb ,_dagcf );
};return _aagb ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};func _dggf (_dedff Color ,_gbfcd float64 )*ColorPoint {return &ColorPoint {_efdg :_dedff ,_bccb :_gbfcd };};func _bdgd (_dgfeg *_gf .PdfRectangle ,_ddde _ee .Matrix )*_gf .PdfRectangle {var _ceaa _gf .PdfRectangle ;
_ceaa .Llx ,_ceaa .Lly =_ddde .Transform (_dgfeg .Llx ,_dgfeg .Lly );_ceaa .Urx ,_ceaa .Ury =_ddde .Transform (_dgfeg .Urx ,_dgfeg .Ury );_ceaa .Normalize ();return &_ceaa ;};

// SetFillColor sets the fill color.
func (_adc *PolyBezierCurve )SetFillColor (color Color ){_adc ._gege =color ;_adc ._cega .FillColor =_fbd (color );};func _bbbca (_fbegd *templateProcessor ,_babbd *templateNode )(interface{},error ){return _fbegd .parseStyledParagraph (_babbd );};func (_fbdcc *templateProcessor )parseCellAlignmentAttr (_gdee ,_ddadc string )CellHorizontalAlignment {_ef .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gdee ,_ddadc );
_gbced :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_ddadc ];return _gbced ;
};func (_debge *Command )isAbsolute ()bool {return _debge .Symbol ==_b .ToUpper (_debge .Symbol )};

// SetWidthBottom sets border width for bottom.
func (_daf *border )SetWidthBottom (bw float64 ){_daf ._bcd =bw };

// AppendCurve appends a Bezier curve to the filled curve.
func (_dde *FilledCurve )AppendCurve (curve _dd .CubicBezierCurve )*FilledCurve {_dde ._ccggc =append (_dde ._ccggc ,curve );return _dde ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_aggg *RadialShading )AddShadingResource (block *Block )(_cffde _cd .PdfObjectName ,_bfdce error ){_cbae :=1;_cffde =_cd .PdfObjectName ("\u0053\u0068"+_ca .Itoa (_cbae ));for block ._ebe .HasShadingByName (_cffde ){_cbae ++;_cffde =_cd .PdfObjectName ("\u0053\u0068"+_ca .Itoa (_cbae ));
};if _ddbae :=block ._ebe .SetShadingByName (_cffde ,_aggg .shadingModel ().ToPdfObject ());_ddbae !=nil {return "",_ddbae ;};return _cffde ,nil ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_ecbc *Division )EnablePageWrap (enable bool ){_ecbc ._gffa =enable };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_cbf []*_gf .PdfPage ;_aea map[*_gf .PdfPage ]*Block ;_abge map[*_gf .PdfPage ]*pageTransformations ;_ddbg *_gf .PdfPage ;_bea PageSize ;_fcba DrawContext ;_feeg Margins ;_gaa ,_dag float64 ;_baga int ;_agdb func (_fdf FrontpageFunctionArgs );
_eaeb func (_gbe *TOC )error ;_ceed func (_fbde *Block ,_cbfe HeaderFunctionArgs );_deaa func (_fege *Block ,_gda FooterFunctionArgs );_acbf func (_faa PageFinalizeFunctionArgs )error ;_bbed func (_fcea *_gf .PdfWriter )error ;_ffbe bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_fagf *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_cced *_gf .Outline ;_adaf *_gf .PdfOutlineTreeNode ;_edg *_gf .PdfAcroForm ;_bcf _cd .PdfObject ;_egeb _gf .Optimizer ;_bbac []*_gf .PdfFont ;_dfac *_gf .PdfFont ;_eggg *_gf .PdfFont ;_bcgd bool ;_fae *_gf .KDict ;_fbg int64 ;_gec *_gf .StructTreeRoot ;
_bcdb *_gf .ViewerPreferences ;_fgeb string ;

// AutofixPageContentStream indicates whether the creator should attempt to fix
// page content streams that have unclosed `q` and `Q` commands.
// The default value is `true`.
// When set to `false`, the creator will skip the content stream checking and wrapping.
// This will speed up and optimize memory usage the creation of PDF, the drawback is
// need to ensure that the source of PDF content streams are well-formed.
AutofixPageContentStream bool ;};func (_cdga *GraphicSVGElement )drawText (_gdfda *_ebf .ContentCreator ,_bcag *_gf .PdfPageResources ){_gdfda .Add_BT ();_ebcdc ,_defbb :=_fgde (_cdga .Attributes ["\u0078"],64);if _defbb !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_defbb .Error ());
};_adacc ,_defbb :=_fgde (_cdga .Attributes ["\u0079"],64);if _defbb !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_defbb .Error ());
};_bfeba :=_cdga .Attributes ["\u0066\u0069\u006c\u006c"];var _dfgeb ,_aaade ,_bfedc float64 ;if _cfefe ,_cccd :=_ba .ColorMap [_bfeba ];_cccd {_egce ,_cdef ,_aggc ,_ :=_cfefe .RGBA ();_dfgeb ,_aaade ,_bfedc =float64 (_egce ),float64 (_cdef ),float64 (_aggc );
}else if _b .HasPrefix (_bfeba ,"\u0072\u0067\u0062\u0028"){_dfgeb ,_aaade ,_bfedc =_fedea (_bfeba );}else {_dfgeb ,_aaade ,_bfedc =ColorRGBFromHex (_bfeba ).ToRGB ();};_gdfda .Add_rg (_dfgeb ,_aaade ,_bfedc );_gbedf :=_cff ;if _ebbd ,_fcae :=_cdga .Attributes ["\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae"];
_fcae {_gbedf ,_defbb =_ca .ParseFloat (_ebbd ,64);if _defbb !=nil {_ef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067 \u0060\u0066\u006f\u006e\u0074\u002d\u0073\u0069\u007a\u0065\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_defbb .Error ());
_gbedf =_cff ;};};_bggbc :=_cdga ._bcae *_gbedf *PPI /_fafg ;_bceed :=_cd .PdfObjectName ("\u0053\u0046\u006fn\u0074");_effd :=_gf .DefaultFont ();_eead ,_edggg :=_cdga .Attributes ["f\u006f\u006e\u0074\u002d\u0066\u0061\u006d\u0069\u006c\u0079"];if _edggg {if _edba ,_aged :=_gccfd (_eead );
_aged ==nil {_effd =_edba ;_fcbad :=1;for _bcag .HasFontByName (_bceed ){_bceed =_cd .PdfObjectName ("\u0053\u0046\u006fn\u0074"+_ca .Itoa (_fcbad ));_fcbad ++;};};};_abcec :=0.0;_bdbff ,_edggg :=_cdga .Attributes ["t\u0065\u0078\u0074\u002d\u0061\u006e\u0063\u0068\u006f\u0072"];
if _edggg &&_bdbff !="\u0073\u0074\u0061r\u0074"{var _eggf float64 ;for _ ,_dceb :=range _cdga .Content {_cacaf ,_geceb :=_effd .GetRuneMetrics (_dceb );if !_geceb {_ef .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074e\u0064 \u0072u\u006e\u0065\u0020\u0025\u0076\u0020\u0069\u006e\u0020\u0066\u006f\u006e\u0074",_dceb );
};_eggf +=_cacaf .Wx ;};_eggf =_eggf *_bggbc /1000.0;switch _bdbff {case "\u006d\u0069\u0064\u0064\u006c\u0065":_abcec =-_eggf /2;case "\u0065\u006e\u0064":_abcec =-_eggf ;};};_gdfda .Add_Tm (1,0,0,-1,_ebcdc *_cdga ._bcae +_abcec ,_adacc *_cdga ._bcae );
_bcag .SetFontByName (_bceed ,_effd .ToPdfObject ());_gdfda .Add_Tf (_bceed ,_bggbc );_fggcg :=_cdga .Content ;_dgce :=_cd .MakeString (_fggcg );_gdfda .Add_Tj (*_dgce );_gdfda .Add_ET ();};func _eage (_ecbcg string )(_dfgd []float64 ,_cbadcg error ){var _acagg float64 ;
_ffegc :=0;_bebaaf :=true ;for _gbcagg ,_ccead :=range _ecbcg {if _ccead =='.'{if _bebaaf {_bebaaf =false ;continue ;};_acagg ,_cbadcg =_fgde (_ecbcg [_ffegc :_gbcagg ],64);if _cbadcg !=nil {return ;};_dfgd =append (_dfgd ,_acagg );_ffegc =_gbcagg ;};};
_acagg ,_cbadcg =_fgde (_ecbcg [_ffegc :],64);if _cbadcg !=nil {return ;};_dfgd =append (_dfgd ,_acagg );return ;};

// GenerateKDict generates a K dictionary for the drawable component.
func (_dfgb *taggedDrawable )GenerateKDict ()(*_gf .KDict ,error ){if _dfgb ._febd ==nil {return nil ,_g .New ("\u0073\u0074r\u0075\u0063\u0074\u0075\u0072\u0065\u0020\u0074\u0061\u0067\u0020\u0069\u006e\u0066\u006f\u0020\u0069\u0073\u0020\u006e\u006f\u0074 s\u0065\u0074");
};return _dfgb ._febd .GenerateKDict (),nil ;};func _ddecc (_accgg ,_egbfg ,_fbee TextChunk ,_afgdfc uint ,_fbbad TextStyle )*TOCLine {_ecca :=_bgdc (_fbbad );_ecca .SetEnableWrap (true );_ecca .SetTextAlignment (TextAlignmentLeft );_ecca .SetMargins (0,0,2,2);
_edebb :=&TOCLine {_eccb :_ecca ,Number :_accgg ,Title :_egbfg ,Page :_fbee ,Separator :TextChunk {Text :"\u002e",Style :_fbbad },_gggea :0,_bacb :_afgdfc ,_gdcafd :10,_dbbff :PositionRelative };_ecca ._dbge .Left =_edebb ._gggea +float64 (_edebb ._bacb -1)*_edebb ._gdcafd ;
_ecca ._egdcf =_edebb .prepareParagraph ;return _edebb ;};func (_cegc *Grid )addSectionTag (_cgea GridRowSection )*_gf .KDict {_eceg :=_gf .NewKDictionary ();_eceg .S =_cd .MakeName (string (_bbef [_cgea ]));_cegc ._febd .ComponentKObj .AddKChild (_eceg );
return _eceg ;};func _adad (_adeb ,_eadf ,_fbfa ,_beaf ,_eaedc ,_fede float64 )*Curve {_acf :=&Curve {};_acf ._bgb =_adeb ;_acf ._fabd =_eadf ;_acf ._gbfe =_fbfa ;_acf ._gfda =_beaf ;_acf ._eeec =_eaedc ;_acf ._ebeb =_fede ;_acf ._bbbb =ColorBlack ;_acf ._bfee =1.0;
return _acf ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_afbb *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_cee ,_ ,_bcg :=d .GeneratePageBlocks (ctx );if _bcg !=nil {return _bcg ;};if len (_cee )!=1{return ErrContentNotFit ;};for _ ,_gff :=range _cee {if _cea :=_afbb .mergeBlocks (_gff );
_cea !=nil {return _cea ;};};return nil ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_agcc *LinearShading )SetExtends (start bool ,end bool ){_agcc ._beecg .SetExtends (start ,end )};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_dee *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dee ._bade .Left ,_dee ._bade .Right ,_dee ._bade .Top ,_dee ._bade .Bottom ;};type pathParserError struct{_acgfb string };func (_gfcca *templateProcessor )parseChart (_ebfgg *templateNode )(interface{},error ){var _dbea string ;
for _ ,_gcab :=range _ebfgg ._fdbe .Attr {_gdafd :=_gcab .Value ;switch _bfeag :=_gcab .Name .Local ;_bfeag {case "\u0073\u0072\u0063":_dbea =_gdafd ;};};if _dbea ==""{_gfcca .nodeLogError (_ebfgg ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_ecdff ;};_acacd ,_ddada :=_gfcca ._caaec .ChartMap [_dbea ];if !_ddada {_gfcca .nodeLogError (_ebfgg ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_dbea );
return nil ,_ecdff ;};_aaeaeg :=NewChart (_acacd );for _ ,_gacga :=range _ebfgg ._fdbe .Attr {_eeaae :=_gacga .Value ;switch _efeb :=_gacga .Name .Local ;_efeb {case "\u0078":_aaeaeg .SetPos (_gfcca .parseFloatAttr (_efeb ,_eeaae ),_aaeaeg ._ggef );case "\u0079":_aaeaeg .SetPos (_aaeaeg ._gdgb ,_gfcca .parseFloatAttr (_efeb ,_eeaae ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_fcbaaa :=_gfcca .parseMarginAttr (_efeb ,_eeaae );_aaeaeg .SetMargins (_fcbaaa .Left ,_fcbaaa .Right ,_fcbaaa .Top ,_fcbaaa .Bottom );case "\u0077\u0069\u0064t\u0068":_aaeaeg ._ddba .SetWidth (int (_gfcca .parseFloatAttr (_efeb ,_eeaae )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_aaeaeg ._ddba .SetHeight (int (_gfcca .parseFloatAttr (_efeb ,_eeaae )));case "\u0073\u0072\u0063":break ;default:_gfcca .nodeLogDebug (_ebfgg ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_efeb );
};};return _aaeaeg ,nil ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_eagb *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_eagb .Text },nil ;};var _eedd []string ;var _eggd []rune ;var _fedcb float64 ;var _egff []float64 ;_cdad :=_eagb .Style ;_feec :=_cd .IsTextWriteDirectionLTR (_eagb .Text );
for _ ,_dgegaa :=range _eagb .Text {if _dgegaa =='\u000A'{_dabec :=_cd .FormatWriteDirectionLTR (string (_eggd ),_feec );_eedd =append (_eedd ,_b .TrimRightFunc (_dabec ,_ge .IsSpace )+string (_dgegaa ));_eggd =nil ;_fedcb =0;_egff =nil ;continue ;};_agda :=_dgegaa ==' ';
_ebecd ,_dadcc :=_cdad .Font .GetRuneMetrics (_dgegaa );if !_dadcc {_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_dgegaa ,_dgegaa ,_cdad .Font .BaseFont (),_cdad .Font .Subtype ());
_ef .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_cdad .Font );_ef .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_cdad .Font .Encoder ());return nil ,_g .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_ecdaa :=_cdad .FontSize *_ebecd .Wx ;_ddade :=_ecdaa ;if !_agda {_ddade =_ecdaa +_cdad .CharSpacing *1000.0;};if _fedcb +_ecdaa > width *1000.0{_bfccg :=-1;if !_agda {for _dbbe :=len (_eggd )-1;_dbbe >=0;_dbbe --{if _eggd [_dbbe ]==' '{_bfccg =_dbbe ;
break ;};};};_dcddc :=string (_eggd );if _bfccg > 0{_dcddc =string (_eggd [0:_bfccg +1]);_eggd =append (_eggd [_bfccg +1:],_dgegaa );_egff =append (_egff [_bfccg +1:],_ddade );_fedcb =0;for _ ,_gdbbe :=range _egff {_fedcb +=_gdbbe ;};}else {if _agda {_eggd =[]rune {};
_egff =[]float64 {};_fedcb =0;}else {_eggd =[]rune {_dgegaa };_egff =[]float64 {_ddade };_fedcb =_ddade ;};};_dcddc =_cd .FormatWriteDirectionLTR (_dcddc ,_feec );_eedd =append (_eedd ,_b .TrimRightFunc (_dcddc ,_ge .IsSpace ));}else {_eggd =append (_eggd ,_dgegaa );
_fedcb +=_ddade ;_egff =append (_egff ,_ddade );};};if len (_eggd )> 0{_gcde :=string (_eggd );_gcde =_cd .FormatWriteDirectionLTR (_gcde ,_feec );_eedd =append (_eedd ,_gcde );};return _eedd ,nil ;};func _bfbgf (_cbabd *templateProcessor ,_fgge *templateNode )(interface{},error ){return _cbabd .parseDivision (_fgge );
};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_caad *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _dbac (x1 ,y1 ,x2 ,y2 )};func (_acge *TableCell )width (_adee []float64 ,_fcdcdd float64 )float64 {_fcegb :=float64 (0.0);for _cfaf :=0;_cfaf < _acge ._ggfdg ;_cfaf ++{_fcegb +=_adee [_acge ._facac +_cfaf -1];
};return _fcegb *_fcdcdd ;};func _dbac (_gddfb ,_eacg ,_aaef ,_affd float64 )*Line {return &Line {_gbba :_gddfb ,_dfag :_eacg ,_bada :_aaef ,_bbacd :_affd ,_fgbd :ColorBlack ,_caabd :1.0,_gfbf :1.0,_gddg :[]int64 {1,1},_fbdb :PositionAbsolute };};func (_aadga *templateProcessor )parseLinearGradientAttr (creator *Creator ,_fcadd string )Color {_adebd :=ColorBlack ;
if _fcadd ==""{return _adebd ;};_dbcbd :=creator .NewLinearGradientColor ([]*ColorPoint {});_dbcbd .SetExtends (true ,true );var (_gedfa =_b .Split (_fcadd [16:len (_fcadd )-1],"\u002c");_begec =_b .TrimSpace (_gedfa [0]););if _b .HasSuffix (_begec ,"\u0064\u0065\u0067"){_gebcd ,_bfbag :=_ca .ParseFloat (_begec [:len (_begec )-3],64);
if _bfbag !=nil {_ef .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_bfbag );}else {_dbcbd .SetAngle (_gebcd );
};_gedfa =_gedfa [1:];};_adggf ,_fafeab :=_aadga .processGradientColorPair (_gedfa );if _adggf ==nil ||_fafeab ==nil {return _adebd ;};for _acggf :=0;_acggf < len (_adggf );_acggf ++{_dbcbd .AddColorStop (_adggf [_acggf ],_fafeab [_acggf ]);};return _dbcbd ;
};

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_eedf *border )SetStructPageNumber (pageNumber *int64 ){};func _aggeg (_aabega int )*Table {_cebeb :=&Table {_daebe :_aabega ,_ccfbe :10.0,_beeaca :[]float64 {},_acbg :[]float64 {},_agced :[]*TableCell {},_afbfce :make ([]int ,_aabega ),_ccea :true };
_cebeb ._gage =_gf .StructureTypeTable ;_cebeb .resetColumnWidths ();return _cebeb ;};func _cfga (_bgcef rune )bool {switch {case _bgcef >=0x1F600&&_bgcef <=0x1F64F:return true ;case _bgcef >=0x1F300&&_bgcef <=0x1F5FF:return true ;case _bgcef >=0x1F680&&_bgcef <=0x1F6FF:return true ;
case _bgcef >=0x1F1E6&&_bgcef <=0x1F1FF:return true ;case _bgcef >=0x1F900&&_bgcef <=0x1F9FF:return true ;case _bgcef >=0x1FA70&&_bgcef <=0x1FAFF:return true ;case _bgcef >=0x2600&&_bgcef <=0x26FF:return true ;case _bgcef >=0x2700&&_bgcef <=0x27BF:return true ;
case _bgcef ==0xFE0F||_bgcef ==0xFE0E:return true ;default:return false ;};};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_agd *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _agd ._gfc .Left ,_agd ._gfc .Right ,_agd ._gfc .Top ,_agd ._gfc .Bottom ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_adafcf *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_bfdbc :=&_adafcf ._cdefd ;_bfdbc .Left =left ;_bfdbc .Right =right ;_bfdbc .Top =top ;_bfdbc .Bottom =bottom ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_fcce *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_fcce ._cgadg =textOverflow };

// SetTitleStyle sets the style properties of the invoice title.
func (_debg *Invoice )SetTitleStyle (style TextStyle ){_debg ._cead =style };func (_adcgg *templateProcessor )run ()error {_fcabd :=_ec .NewDecoder (_c .NewReader (_adcgg ._dgac ));var _abbc *templateNode ;for {_bbbab ,_badeb :=_fcabd .Token ();if _badeb !=nil {if _badeb ==_fd .EOF {return nil ;
};return _badeb ;};if _bbbab ==nil {break ;};_efbedg ,_ffcg :=_bfca (_fcabd );_aagg :=_fcabd .InputOffset ();switch _cgfdg :=_bbbab .(type ){case _ec .StartElement :_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_cgfdg .Name .Local );
_cbcb ,_bdag :=_gbabd [_cgfdg .Name .Local ];if !_bdag {if _adcgg ._ceeff ==""{if _efbedg !=0{_ef .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_cgfdg .Name .Local ,_efbedg ,_ffcg );
}else {_ef .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_cgfdg .Name .Local ,_aagg );
};}else {if _efbedg !=0{_ef .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_cgfdg .Name .Local ,_adcgg ._ceeff ,_efbedg ,_ffcg );
}else {_ef .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_cgfdg .Name .Local ,_adcgg ._ceeff ,_aagg );
};};continue ;};_abbc =&templateNode {_fdbe :_cgfdg ,_ccbde :_abbc ,_cefe :_efbedg ,_cbgec :_ffcg ,_ceefe :_aagg };if _bdbfe :=_cbcb ._dagcfa ;_bdbfe !=nil {_abbc ._efefd ,_badeb =_bdbfe (_adcgg ,_abbc );if _badeb !=nil {return _badeb ;};};case _ec .EndElement :_ef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_cgfdg .Name .Local );
if _abbc !=nil {if _abbc ._efefd !=nil {if _bdcce :=_adcgg .renderNode (_abbc );_bdcce !=nil {return _bdcce ;};};_abbc =_abbc ._ccbde ;};case _ec .CharData :if _abbc !=nil &&_abbc ._efefd !=nil {if _gfbb :=_adcgg .addNodeText (_abbc ,string (_cgfdg ));
_gfbb !=nil {return _gfbb ;};};case _ec .Comment :_ef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_cgfdg ));
};};return nil ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default, it occupies the available width in the drawing context.
//
// Deprecated: This object is deprecated and will be removed in future versions.
//
// Use StyledParagraph instead as it provides more features and is more flexible.
type Paragraph struct{taggedDrawable ;_edceg string ;_abbaf *_gf .PdfFont ;_fagc float64 ;_eaag float64 ;_dbbg Color ;_abea TextAlignment ;_daabg bool ;_afeca float64 ;_egfcd int ;_fefe bool ;_bafe float64 ;_ecdf Margins ;_baea Positioning ;_dcff float64 ;
_debb float64 ;_gageb ,_dbga float64 ;_bbbd []string ;_cfde string ;};func _fffc (_bbaa *_gf .PdfAnnotationLink )*_gf .PdfAnnotationLink {if _bbaa ==nil {return nil ;};_cbgb :=_gf .NewPdfAnnotationLink ();_cbgb .CopyFrom (_bbaa .PdfAnnotation );_cbgb .BS =_bbaa .BS ;
_cbgb .A =_bbaa .A ;if _cfba ,_gfefd :=_bbaa .GetAction ();_gfefd ==nil &&_cfba !=nil {_cbgb .SetAction (_cfba );};if _edgbg ,_gcgd :=_bbaa .Dest .(*_cd .PdfObjectArray );_gcgd {_cbgb .Dest =_cd .MakeArray (_edgbg .Elements ()...);};return _cbgb ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_cgdc *TOC )SetLineSeparatorStyle (style TextStyle ){_cgdc ._cbdff =style };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_ecac *Creator )NewPolyBezierCurve (curves []_dd .CubicBezierCurve )*PolyBezierCurve {return _fgcc (curves );};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_abbfb *Rectangle )SetCoords (x ,y float64 ){_abbfb ._acaf =x ;_abbfb ._dgec =y };func _bfcdf (_egab *_gf .PdfFont ,_efbdc float64 )*fontMetrics {_gggcf :=&fontMetrics {};if _egab ==nil {_ef .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");
return _gggcf ;};_aagdc ,_efddf :=_egab .GetFontDescriptor ();if _efddf !=nil {_ef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_efddf );
return _gggcf ;};if _gggcf ._bfefbg ,_efddf =_aagdc .GetCapHeight ();_efddf !=nil {_ef .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_efddf );
};if int (_gggcf ._bfefbg )<=0{_ef .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_gggcf ._bfefbg =1000;};_gggcf ._bfefbg *=_efbdc /1000.0;if _gggcf ._abagf ,_efddf =_aagdc .GetXHeight ();_efddf !=nil {_ef .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_efddf );
};_gggcf ._abagf *=_efbdc /1000.0;if _gggcf ._daffb ,_efddf =_aagdc .GetAscent ();_efddf !=nil {_ef .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_efddf );
};_gggcf ._daffb *=_efbdc /1000.0;if _gggcf ._bdbba ,_efddf =_aagdc .GetDescent ();_efddf !=nil {_ef .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_efddf );
};_gggcf ._bdbba *=_efbdc /1000.0;return _gggcf ;};

// SetStyle sets paragraph style for all chunks.
func (_dffcg *StyledParagraph )SetStyle (style TextStyle ){_dffcg ._dgaag =style ;for _ ,_cfcgc :=range _dffcg ._gbbce {_cfcgc .Style =style ;};};

// SetActualText sets the actual text for the text chunk.
func (_edbed *TextChunk )SetActualText (text string ){_edbed ._dcbb =&text };func (_aeadc *StyledParagraph )wrapWordChunks (){if !_aeadc ._fcgd {return ;};var (_ddcdf []*TextChunk ;_edeg *_gf .PdfFont ;);for _ ,_ggae :=range _aeadc ._gbbce {_dgddf :=[]rune (_ggae .Text );
if _edeg ==nil {_edeg =_ggae .Style .Font ;};_fdagg :=_ggae ._cgbff ;_fdgb :=_ggae .VerticalAlignment ;if len (_ddcdf )> 0{if len (_dgddf )==1&&_ge .IsPunct (_dgddf [0])&&_ggae .Style .Font ==_edeg {_cbadb :=[]rune (_ddcdf [len (_ddcdf )-1].Text );_ddcdf [len (_ddcdf )-1].Text =string (append (_cbadb ,_dgddf [0]));
continue ;}else {_ ,_caeff :=_ca .Atoi (_ggae .Text );if _caeff ==nil {_cagcg :=[]rune (_ddcdf [len (_ddcdf )-1].Text );_aggb :=len (_cagcg );if _aggb >=2{_ ,_fccfe :=_ca .Atoi (string (_cagcg [_aggb -2]));if _fccfe ==nil &&_ge .IsPunct (_cagcg [_aggb -1]){_ddcdf [len (_ddcdf )-1].Text =string (append (_cagcg ,_dgddf ...));
continue ;};};};};};_cabfg ,_dedgf :=_cffec (_ggae .Text );if _dedgf !=nil {_ef .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_dedgf );
_cabfg =[]string {_ggae .Text };};for _ ,_faebd :=range _cabfg {_egfgd :=NewTextChunk (_faebd ,_ggae .Style );_egfgd ._cgbff =_faecf (_fdagg );_egfgd .VerticalAlignment =_fdgb ;_ddcdf =append (_ddcdf ,_egfgd );};_edeg =_ggae .Style .Font ;};if len (_ddcdf )> 0{_aeadc ._gbbce =_ddcdf ;
};};

// SetBorderWidth sets the border width.
func (_bbde *CurvePolygon )SetBorderWidth (borderWidth float64 ){_bbde ._feaa .BorderWidth =borderWidth };

// AddTag adds a tag to the list.
func (_cccea *List )AddTag (rootKObj *_gf .KDict ){if _cccea ._febd ==nil {_cccea ._febd =_gf .NewStructureTagInfo ();_cccea ._febd .StructureType =_gf .StructureTypeList ;};_cccea ._febd .ApplyTag =true ;_cccea ._febd .ParentKObj =rootKObj ;};func (_cebdf *TOCLine )getLineLink ()*_gf .PdfAnnotation {if _cebdf ._fgeee <=0{return nil ;
};return _ffbcd (_cebdf ._fgeee -1,_cebdf ._fdfd ,_cebdf ._abfdc ,0,"");};func (_accfc *Table )moveToNextAvailableCell ()int {_dgcgf :=(_accfc ._facb -1)%(_accfc ._daebe )+1;for {if _dgcgf -1>=len (_accfc ._afbfce ){if _accfc ._afbfce [0]==0{return _dgcgf ;
};_dgcgf =1;}else if _accfc ._afbfce [_dgcgf -1]==0{return _dgcgf ;};_accfc ._facb ++;_accfc ._afbfce [_dgcgf -1]--;_dgcgf ++;};};

// SetStructureType sets the structure type for the table.
func (_agbef *Table )SetStructureType (structureType _gf .StructureType ){if _agbef ._febd ==nil {_agbef ._febd =_gf .NewStructureTagInfo ();};_agbef ._febd .StructureType =structureType ;if _agbef ._febd .ComponentKObj !=nil {if _agbef ._febd .ParentKObj !=nil {_agbef ._febd .ParentKObj .RemoveKChild (_agbef ._febd .ComponentKObj );
};_agbef ._febd .ComponentKObj =_gf .NewKDictionary ();_agbef ._febd .ComponentKObj .S =_cd .MakeName (string (structureType ));_agbef ._febd .ParentKObj .AddKChild (_agbef ._febd .ComponentKObj );};};func (_egcd *templateProcessor )parseInt64Attr (_ggefb ,_defde string )int64 {_ef .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ggefb ,_defde );
_egecg ,_ :=_ca .ParseInt (_defde ,10,64);return _egecg ;};

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_aagdb *border )GenerateKDict ()(*_gf .KDict ,error ){return nil ,nil };

// SetBorder sets the cell's border style.
func (_gbfg *GridCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_gbfg ._beddg =CellBorderStyleSingle ;_gbfg ._ffegf =width ;_gbfg ._abeb =CellBorderStyleSingle ;
_gbfg ._gafdd =width ;_gbfg ._cgcb =CellBorderStyleSingle ;_gbfg ._caeea =width ;_gbfg ._cddd =CellBorderStyleSingle ;_gbfg ._cbde =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_gbfg ._beddg =CellBorderStyleDouble ;_gbfg ._ffegf =width ;
_gbfg ._abeb =CellBorderStyleDouble ;_gbfg ._gafdd =width ;_gbfg ._cgcb =CellBorderStyleDouble ;_gbfg ._caeea =width ;_gbfg ._cddd =CellBorderStyleDouble ;_gbfg ._cbde =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_gbfg ._beddg =style ;
_gbfg ._ffegf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_gbfg ._abeb =style ;_gbfg ._gafdd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_gbfg ._cgcb =style ;
_gbfg ._caeea =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_gbfg ._cddd =style ;_gbfg ._cbde =width ;};};

// SetLogo sets the logo of the invoice.
func (_cgafd *Invoice )SetLogo (logo *Image ){_cgafd ._gffb =logo };

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _ggf ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_afg :=&Creator {};_afg ._cbf =[]*_gf .PdfPage {};_afg ._aea =map[*_gf .PdfPage ]*Block {};_afg ._abge =map[*_gf .PdfPage ]*pageTransformations {};_afg .SetPageSize (PageSizeLetter );
_adea :=0.1*_afg ._gaa ;_afg ._feeg .Left =_adea ;_afg ._feeg .Right =_adea ;_afg ._feeg .Top =_adea ;_afg ._feeg .Bottom =_adea ;var _agbc error ;_afg ._dfac ,_agbc =_gf .NewStandard14Font (_gf .HelveticaName );if _agbc !=nil {_afg ._dfac =_gf .DefaultFont ();
};_afg ._eggg ,_agbc =_gf .NewStandard14Font (_gf .HelveticaBoldName );if _agbc !=nil {_afg ._dfac =_gf .DefaultFont ();};_afg ._fagf =_afg .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_afg .AddOutlines =true ;
_afg ._cced =_gf .NewOutline ();_afg .AutofixPageContentStream =true ;_ab .TrackUse (_ggf );return _afg ;};func _fbea (_degbgc ,_aadb ,_eagfa string ,_eafc uint ,_caeae TextStyle )*TOCLine {return _ddecc (TextChunk {Text :_degbgc ,Style :_caeae },TextChunk {Text :_aadb ,Style :_caeae },TextChunk {Text :_eagfa ,Style :_caeae },_eafc ,_caeae );
};func (_gffab *templateProcessor )parseImageEncoder (_baefde ,_bedcg string )_cd .StreamEncoder {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0028\u0060\u0025s\u0060\u002c \u0025\u0073\u0029\u002e",_baefde ,_bedcg );
switch _bedcg {case "\u0066\u006c\u0061t\u0065":return _cd .NewFlateEncoder ();case "\u0064\u0063\u0074":return _cd .NewDCTEncoder ();};_ef .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0076\u0061\u006cu\u0065\u0020\u006f\u0066 \u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u0020\u0066\u006f\u0075\u006e\u0064\u002e",_baefde ,_bedcg );
return nil ;};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_fgbg *Rectangle )SetPositioning (position Positioning ){_fgbg ._gbbdg =position };

// Angle returns the block rotation angle in degrees.
func (_ggb *Block )Angle ()float64 {return _ggb ._aag };

// RemoveArtifact removes the artifact associated with the paragraph, if any.
func (_efeg *StyledParagraph )RemoveArtifact (){_efeg ._ebff =nil };var PPI float64 =72;

// SetRowHeight sets the height for a specified row.
func (_ecfbd *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_ecfbd ._acbg ){return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ecfbd ._acbg [row -1]=h ;return nil ;
};

// MarkAsArtifact marks the paragraph as an artifact of the specified type.
//
// This would override regular structure tagging and accessibility
// properties, and the paragraph will be treated as an artifact in the PDF.
func (_eebfc *StyledParagraph )MarkAsArtifact (artifactType _gf .ArtifactType )*_gf .Artifact {_eebfc ._ebff =&_gf .Artifact {Type :artifactType };return _eebfc ._ebff ;};

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_adaga *Rectangle )FillOpacity ()float64 {return _adaga ._dgaab };

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_ceace *PageBreak )GenerateKDict ()(*_gf .KDict ,error ){return nil ,nil };type commands struct{_eedfg []string ;_gbgdc map[string ]int ;_fgbae string ;_gagaf string ;};

// SetMargins sets the margins of the graphic svg component.
func (_addf *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_addf ._bbcd .Left =left ;_addf ._bbcd .Right =right ;_addf ._bbcd .Top =top ;_addf ._bbcd .Bottom =bottom ;};

// Subpath is a collection of Commands, beginning with moveto command and
// usually ending with closepath command.
type Subpath struct{Commands []*Command ;};

// GeneratePageBlocks draw graphic svg into block.
func (_fabb *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abe :=ctx ;_dadb :=_fabb ._daeg .IsRelative ();var _fbaf []*Block ;if _dadb {_dfed :=1.0;_efea :=_fabb ._bbcd .Top ;if _fabb ._aagdf .Height > ctx .Height -_fabb ._bbcd .Top {_fbaf =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _abbe error ;if _ ,ctx ,_abbe =_fbbb ().GeneratePageBlocks (ctx );_abbe !=nil {return nil ,ctx ,_abbe ;};_efea =0;};ctx .X +=_fabb ._bbcd .Left +_dfed ;ctx .Y +=_efea ;ctx .Width -=_fabb ._bbcd .Left +_fabb ._bbcd .Right +2*_dfed ;ctx .Height -=_efea ;
}else {ctx .X =_fabb ._dffd ;ctx .Y =_fabb ._bcea ;};_cfgb :=_ebf .NewContentCreator ();_cfgb .Translate (0,ctx .PageHeight );_cfgb .Scale (1,-1);_cfgb .Translate (ctx .X ,ctx .Y );_dgg :=_fabb ._aagdf .Width /_fabb ._aagdf .ViewBox .W ;_dfeaf :=_fabb ._aagdf .Height /_fabb ._aagdf .ViewBox .H ;
_cabga :=0.0;_gfgg :=0.0;if _dadb {_cabga =_fabb ._dffd -(_fabb ._aagdf .ViewBox .X *_fb .Max (_dgg ,_dfeaf ));_gfgg =_fabb ._bcea -(_fabb ._aagdf .ViewBox .Y *_fb .Max (_dgg ,_dfeaf ));};_acff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fabb ._febd !=nil {_cfgb .Add_BDC (*_cd .MakeName (string (_fabb ._febd .StructureType )),map[string ]_cd .PdfObject {"\u004d\u0043\u0049\u0044":_cd .MakeInteger (_fabb ._febd .Mcid )});
};_fabb ._aagdf .SetPos (ctx .X ,ctx .Y );_fabb ._aagdf .ToContentCreator (_cfgb ,_acff ._ebe ,_dgg ,_dfeaf ,_cabga ,_gfgg );if _fabb ._febd !=nil {_cfgb .Add_EMC ();};_adfb :=_cfgb .Operations ();_adfb .WrapIfNeeded ();_acff .addWrappedContents (_adfb );
if _dadb {_abfd :=_fabb .Height ()+_fabb ._bbcd .Bottom ;ctx .Y +=_abfd ;ctx .Height -=_abfd ;}else {ctx =_abe ;};_fbaf =append (_fbaf ,_acff );return _fbaf ,ctx ,nil ;};func (_ecfdg *TOCLine )prepareParagraph (_bdcedb *StyledParagraph ,_gaadda DrawContext ){_cbadbb :=_ecfdg .Title .Text ;
if _ecfdg .Number .Text !=""{_cbadbb ="\u0020"+_cbadbb ;};_cbadbb +="\u0020";_cdgb :=_ecfdg .Page .Text ;if _cdgb !=""{_cdgb ="\u0020"+_cdgb ;};_bdgba :=[]*_gf .PdfAnnotation {};_bafa :=_ecfdg .getLineLink ();if _bafa !=nil {_bdgba =append (_bdgba ,_bafa );
};_bdcedb ._gbbce =[]*TextChunk {{Text :_ecfdg .Number .Text ,Style :_ecfdg .Number .Style ,_cgbff :_bdgba },{Text :_cbadbb ,Style :_ecfdg .Title .Style ,_cgbff :_bdgba },{Text :_cdgb ,Style :_ecfdg .Page .Style ,_cgbff :_bdgba }};_bdcedb .wrapText ();
_abgea :=len (_bdcedb ._aeggc );if _abgea ==0{return ;};_afeac :=_gaadda .Width *1000-_bdcedb .getTextLineWidth (_bdcedb ._aeggc [_abgea -1]);_aabee :=_bdcedb .getTextLineWidth ([]*TextChunk {&_ecfdg .Separator });_cadfa :=int (_afeac /_aabee );_bfec :=_b .Repeat (_ecfdg .Separator .Text ,_cadfa );
_gcba :=_ecfdg .Separator .Style ;_ggcage :=_bdcedb .Insert (2,_bfec );_ggcage .Style =_gcba ;_ggcage .SetAnnotation (_ecfdg .getLineLink ());_afeac =_afeac -float64 (_cadfa )*_aabee ;if _afeac > 500{_addc ,_cbcdg :=_gcba .Font .GetRuneMetrics (' ');if _cbcdg &&_afeac > _addc .Wx {_defbf :=int (_afeac /_addc .Wx );
if _defbf > 0{_bgedc :=_gcba ;_bgedc .FontSize =1;_ggcage =_bdcedb .Insert (2,_b .Repeat ("\u0020",_defbf ));_ggcage .Style =_bgedc ;_ggcage .SetAnnotation (_ecfdg .getLineLink ());};};};};

// SetOpacity sets opacity for Image.
func (_geega *Image )SetOpacity (opacity float64 ){_geega ._bdbfb =opacity };

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_cfcbf *Paragraph )SetLanguageIdentifier (id string ){if _cfcbf ._febd ==nil {_cfcbf ._febd =_gf .NewStructureTagInfo ();_cfcbf ._febd .StructureType =_gf .StructureTypeParagraph ;};_cfcbf ._cfde =id ;};func _ffbcd (_dadec int64 ,_caebd ,_dbab ,_ggcgc float64 ,_ccgag string )*_gf .PdfAnnotation {_bgff :=_gf .NewPdfAnnotationLink ();
_cdfbb :=_gf .NewBorderStyle ();_cdfbb .SetBorderWidth (0);_bgff .BS =_cdfbb .ToPdfObject ();if _dadec < 0{_dadec =0;};_bgff .Dest =_cd .MakeArray (_cd .MakeInteger (_dadec ),_cd .MakeName ("\u0058\u0059\u005a"),_cd .MakeFloat (_caebd ),_cd .MakeFloat (_dbab ),_cd .MakeFloat (_ggcgc ));
if _ccgag !=""{_bgff .Contents =_cd .MakeString (_ccgag );};return _bgff .PdfAnnotation ;};func (_beba *StyledParagraph )split (_gafe DrawContext )(_ebgc ,_bebf *StyledParagraph ,_begaa error ){if _begaa =_beba .wrapChunks (false );_begaa !=nil {return nil ,nil ,_begaa ;
};if len (_beba ._aeggc )==1&&_beba ._edcb > _gafe .Height {return _beba ,nil ,nil ;};_dgfdc :=func (_abad []*TextChunk ,_gddd []*TextChunk )[]*TextChunk {if len (_gddd )==0{return _abad ;};_aaadd :=len (_abad );if _aaadd ==0{return append (_abad ,_gddd ...);
};if _abad [_aaadd -1].Style ==_gddd [0].Style {_abad [_aaadd -1].Text +=_gddd [0].Text ;}else {_abad =append (_abad ,_gddd [0]);};return append (_abad ,_gddd [1:]...);};_ffgbf :=func (_agdbb *StyledParagraph ,_bbacc []*TextChunk )*StyledParagraph {if len (_bbacc )==0{return nil ;
};_dbgeb :=*_agdbb ;_dbgeb ._gbbce =_bbacc ;return &_dbgeb ;};var (_bbade float64 ;_bacc []*TextChunk ;_bbegb []*TextChunk ;);for _ ,_faaea :=range _beba ._aeggc {var _ffbcf float64 ;_ffgd :=make ([]*TextChunk ,0,len (_faaea ));for _ ,_cafcc :=range _faaea {if _ecef :=_cafcc .Style .FontSize ;
_ecef > _ffbcf {_ffbcf =_ecef ;};_ffgd =append (_ffgd ,_cafcc .clone ());};_ffbcf *=_beba ._edcb ;if _beba ._ggdeb .IsRelative (){if _bbade +_ffbcf > _gafe .Height {_bbegb =_dgfdc (_bbegb ,_ffgd );}else {_bacc =_dgfdc (_bacc ,_ffgd );};};_bbade +=_ffbcf ;
};_beba ._aeggc =nil ;if len (_bbegb )==0{return _beba ,nil ,nil ;};return _ffgbf (_beba ,_bacc ),_ffgbf (_beba ,_bbegb ),nil ;};

// SetStyleLeft sets border style for left side.
func (_fea *border )SetStyleLeft (style CellBorderStyle ){_fea ._dab =style };

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_ebgbf *Table )SetPos (x ,y float64 ){_ebgbf ._fddd =PositionAbsolute ;_ebgbf ._ddfeb =x ;_ebgbf ._befbg =y ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_geegd *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _g .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _g .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _g .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_geegd ._ccdcb =true ;_geegd ._faaga =startRow ;_geegd ._dagb =endRow ;return nil ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_bb *Block )SetPos (x ,y float64 ){_bb ._aa =PositionAbsolute ;_bb ._fc =x ;_bb ._eec =y };

// SetAlternateText sets the alternate text for the image.
func (_cfaac *Image )SetAlternateText (text string ){_cfaac ._bgcb =text };func _cge (_cebe ,_fdg *_gf .PdfPageResources )error {_cef ,_ :=_cebe .GetColorspaces ();if _cef !=nil &&len (_cef .Colorspaces )> 0{for _cabe ,_fed :=range _cef .Colorspaces {_caac :=*_cd .MakeName (_cabe );
if _fdg .HasColorspaceByName (_caac ){continue ;};_faf :=_fdg .SetColorspaceByName (_caac ,_fed );if _faf !=nil {return _faf ;};};};return nil ;};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_ffgg *Creator )SetForms (form *_gf .PdfAcroForm )error {_ffgg ._edg =form ;return nil };func (_dbgga *templateProcessor )addNodeText (_bdac *templateNode ,_gabec string )error {_ccaec :=_bdac ._efefd ;if _ccaec ==nil {return nil ;};switch _ggaba :=_ccaec .(type ){case *TextChunk :_ggaba .Text =_gabec ;
case *StyledParagraph :switch _bdac ._fdbe .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _bdac ._ccbde !=nil {if _eaegff ,_bbfd :=_bdac ._ccbde ._efefd .(*Chapter );_bbfd {_eaegff ._cede =_gabec ;
_ggaba .SetText (_eaegff .headingText ());};};};};return nil ;};

// GetOptimizer returns current PDF optimizer.
func (_def *Creator )GetOptimizer ()_gf .Optimizer {return _def ._egeb };func (_gfbg *Invoice )newColumn (_dgad string ,_affb CellHorizontalAlignment )*InvoiceCell {_cgfg :=&InvoiceCell {_gfbg ._abfde ,_dgad };_cgfg .Alignment =_affb ;return _cgfg ;};func _dgf (_eefd *_gf .Image )(*Image ,error ){_afce :=float64 (_eefd .Width );
_dacg :=float64 (_eefd .Height );return &Image {_addd :_eefd ,_bcbef :_afce ,_dccdg :_dacg ,_dgega :_afce ,_dfbd :_dacg ,_ggedf :0,_bdbfb :1.0,_cgaad :PositionRelative ,taggedDrawable :taggedDrawable {_gage :_gf .StructureTypeFigure }},nil ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_bgad *Creator )NewTextStyle ()TextStyle {return _ebage (_bgad ._dfac )};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_ggeda *Creator )EnableFontSubsetting (font *_gf .PdfFont ){_ggeda ._bbac =append (_ggeda ._bbac ,font );};func _ggd (_ccbc string )string {_ecfe :=_gac .FindAllString (_ccbc ,-1);if len (_ecfe )==0{_ccbc =_ccbc +"\u0030";}else {_gfaf ,_eae :=_ca .Atoi (_ecfe [len (_ecfe )-1]);
if _eae !=nil {_ef .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_eae );
_ccbc =_ccbc +"\u0030";}else {_gfaf ++;_cdb :=_b .LastIndex (_ccbc ,_ecfe [len (_ecfe )-1]);if _cdb ==-1{_ccbc =_e .Sprintf ("\u0025\u0073\u0025\u0064",_ccbc [:len (_ccbc )-1],_gfaf );}else {_ccbc =_ccbc [:_cdb ]+_ca .Itoa (_gfaf );};};};return _ccbc ;
};func _ecabg (_ageg ,_fbeba ,_caeefb int )[]int {_dbedg :=[]int {};for _egcb :=_ageg ;_egcb <=_caeefb ;_egcb +=_fbeba {_dbedg =append (_dbedg ,_egcb );};return _dbedg ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_dgbbf *StyledParagraph )SetText (text string )*TextChunk {_dgbbf .Reset ();return _dgbbf .Append (text );};

// GetCoords returns coordinates of border.
func (_ffe *border )GetCoords ()(float64 ,float64 ){return _ffe ._ecfc ,_ffe ._agg };

// ToContentCreator convert SVG and add elements contentstream then returns `contentstream.ContentCreator`.
func (_gdfg *GraphicSVGElement )ToContentCreator (cc *_ebf .ContentCreator ,res *_gf .PdfPageResources ,scaleX ,scaleY ,translateX ,translateY float64 )*_ebf .ContentCreator {if _gdfg .Name =="\u0073\u0076\u0067"{_gdfg .SetScaling (scaleX ,scaleY );cc .Add_cm (1,0,0,1,translateX ,translateY );
_gdfg .setDefaultScaling (_gdfg ._bcae );cc .Add_W ();cc .Add_n ();_gdfg .processDefs ();for _ ,_egde :=range _gdfg .Children {_egde .ViewBox =_gdfg .ViewBox ;_egde ._abca =_gdfg ._abca ;_egde ._ceefd =_gdfg ._ceefd ;_egde .toContentStream (cc ,res );};
return cc ;};return nil ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{taggedDrawable ;_feaa *_dd .CurvePolygon ;_ccc float64 ;_bdeb float64 ;_cdbc Color ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_accg *Chart )SetPos (x ,y float64 ){_accg ._ggcc =PositionAbsolute ;_accg ._gdgb =x ;_accg ._ggef =y ;};func (_fff grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _fff ._bacdf ,_fff ._bacdf ,_fff ._bacdf ;};func (_adcf *templateProcessor )parseDivision (_gfebg *templateNode )(interface{},error ){_cdab :=_adcf .creator .NewDivision ();
for _ ,_cgbad :=range _gfebg ._fdbe .Attr {_efbeg :=_cgbad .Value ;switch _gadab :=_cgbad .Name .Local ;_gadab {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_cdab .EnablePageWrap (_adcf .parseBoolAttr (_gadab ,_efbeg ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_gbeef :=_adcf .parseMarginAttr (_gadab ,_efbeg );_cdab .SetMargins (_gbeef .Left ,_gbeef .Right ,_gbeef .Top ,_gbeef .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_fbgd :=_adcf .parseMarginAttr (_gadab ,_efbeg );
_cdab .SetPadding (_fbgd .Left ,_fbgd .Right ,_fbgd .Top ,_fbgd .Bottom );default:_adcf .nodeLogDebug (_gfebg ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gadab );
};};return _cdab ,nil ;};func _fbgec (_gedb VectorDrawable ,_gdffe float64 ,_cccbg float64 ,_eddda CellVerticalAlignment ,_adeab bool ,_gbdeb *_gf .KDict ,_ggdbd int64 ,_dgaae float64 )(float64 ,float64 ,float64 ,*_gf .KDict ,bool ,error ){var (_bbccf bool ;
_ccaacd *_gf .KDict ;_eebbg float64 ;_dccb error ;);switch _fbgf :=_gedb .(type ){case *Paragraph :if _fbgf ._daabg {_gdffe =_fbgf .getMaxLineWidth ()/1000.0;};_ddbdd ,_abded ,_ :=_fbgf .getTextMetrics ();_gdfa ,_baadf :=_ddbdd *_fbgf ._eaag ,_abded *_fbgf ._eaag ;
_cccbg =_cccbg -_baadf +_gdfa ;_eebbg +=_gdfa -_baadf ;_acdf :=0.5;if _adeab {_acdf =0.3;};switch _eddda {case CellVerticalAlignmentTop :_eebbg +=_gdfa *_acdf ;case CellVerticalAlignmentBottom :_eebbg -=_gdfa *_acdf ;};_gdffe +=_fbgf ._ecdf .Left +_fbgf ._ecdf .Right ;
_cccbg +=_fbgf ._ecdf .Top +_fbgf ._ecdf .Bottom ;if _gbdeb !=nil {_fbgf .SetMarkedContentID (_ggdbd );_fbgf .SetStructureType (_gf .StructureTypeParagraph );_ccaacd ,_dccb =_fbgf .GenerateKDict ();if _dccb !=nil {return 0,0,0,nil ,false ,_e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u004b\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072a\u0070h\u003a\u0020\u0025\u0077",_dccb );
};};case *StyledParagraph :if _fbgf ._ffeac {_gdffe =_fbgf .getMaxLineWidth ()/1000.0;};_gafa ,_dafbg ,_edbdd :=_fbgf .getLineMetrics (0);_ddeg ,_ddege :=_gafa *_fbgf ._edcb ,_dafbg *_fbgf ._edcb ;if _fbgf ._bffb ==TextVerticalAlignmentCenter {_eebbg =_ddege -(_dafbg +(_gafa +_edbdd -_dafbg )/2+(_ddege -_dafbg )/2);
};if len (_fbgf ._aeggc )==1{_cccbg =_ddeg ;}else {_cccbg =_cccbg -_ddege +_ddeg ;};_eebbg +=_ddeg -_ddege ;switch _eddda {case CellVerticalAlignmentTop :_eebbg +=_ddeg *0.5;case CellVerticalAlignmentBottom :_eebbg -=_ddeg *0.5;};_gdffe +=_fbgf ._dbge .Left +_fbgf ._dbge .Right ;
_cccbg +=_fbgf ._dbge .Top +_fbgf ._dbge .Bottom ;if _gbdeb !=nil {_fbgf .SetMarkedContentID (_ggdbd );_fbgf .SetStructureType (_gf .StructureTypeParagraph );_ccaacd ,_dccb =_fbgf .GenerateKDict ();if _dccb !=nil {return 0,0,0,nil ,false ,_e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064 \u0074\u006f\u0020g\u0065\u006e\u0065r\u0061\u0074\u0065\u0020\u004b\u0020\u0064\u0069\u0063\u0074i\u006f\u006e\u0061\u0072\u0079 f\u006f\u0072\u0020\u0073\u0074\u0079\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0077",_dccb );
};};case *Table :_gdffe =_dgaae ;if _gbdeb !=nil {_fbgf .SetMarkedContentID (_ggdbd );_fbgf .AddTag (_gbdeb );_bbccf =true ;_ccaacd ,_dccb =_fbgf .GenerateKDict ();if _dccb !=nil {return 0,0,0,nil ,false ,_e .Errorf ("\u0066a\u0069\u006ce\u0064\u0020\u0074o\u0020\u0067\u0065\u006e\u0065\u0072\u0061t\u0065\u0020\u004b\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0066\u006f\u0072 \u0074\u0061\u0062\u006c\u0065\u003a\u0020\u0025\u0077",_dccb );
};};case *List :_gdffe =_dgaae ;if _gbdeb !=nil {_fbgf .SetMarkedContentID (_ggdbd );_fbgf .AddTag (_gbdeb );_bbccf =true ;_ccaacd ,_dccb =_fbgf .GenerateKDict ();if _dccb !=nil {return 0,0,0,nil ,false ,_e .Errorf ("\u0066a\u0069\u006ce\u0064\u0020\u0074\u006f \u0067\u0065\u006ee\u0072\u0061\u0074\u0065\u0020\u004b\u0020\u0064\u0069ct\u0069\u006f\u006ea\u0072\u0079 \u0066\u006f\u0072\u0020\u006c\u0069s\u0074\u003a \u0025\u0077",_dccb );
};};case *Division :_gdffe =_dgaae ;if _gbdeb !=nil {_fbgf .SetMarkedContentID (_ggdbd );_fbgf .AddTag (_gbdeb );_bbccf =true ;_ccaacd ,_dccb =_fbgf .GenerateKDict ();if _dccb !=nil {return 0,0,0,nil ,false ,_e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074o\u0020\u0067\u0065ne\u0072\u0061\u0074\u0065\u0020\u004b \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0066\u006f\u0072\u0020d\u0069\u0076\u0069\u0073\u0069\u006f\u006e\u003a \u0025\u0077",_dccb );
};};case *Chart :_gdffe =_dgaae ;case *Line :_cccbg +=_fbgf ._dfbfa .Top +_fbgf ._dfbfa .Bottom ;_eebbg -=_fbgf .Height ()/2;case *Image :_gdffe +=_fbgf ._gdgbd .Left +_fbgf ._gdgbd .Right ;_cccbg +=_fbgf ._gdgbd .Top +_fbgf ._gdgbd .Bottom ;};return _gdffe ,_cccbg ,_eebbg ,_ccaacd ,_bbccf ,nil ;
};func _ddgde (_eabgb *_f .File )([]*_gf .PdfPage ,error ){_adffb ,_efffb :=_gf .NewPdfReader (_eabgb );if _efffb !=nil {return nil ,_efffb ;};_fcegg ,_efffb :=_adffb .GetNumPages ();if _efffb !=nil {return nil ,_efffb ;};var _gcbac []*_gf .PdfPage ;for _efgga :=0;
_efgga < _fcegg ;_efgga ++{_gdaeb ,_ceebd :=_adffb .GetPage (_efgga +1);if _ceebd !=nil {return nil ,_ceebd ;};_gcbac =append (_gcbac ,_gdaeb );};return _gcbac ,nil ;};

// SetWidth sets the width of the ellipse.
func (_afca *Ellipse )SetWidth (width float64 ){_afca ._feeac =width };

// NewCell returns a new invoice table cell.
func (_cbfcb *Invoice )NewCell (value string )*InvoiceCell {return _cbfcb .newCell (value ,_cbfcb .NewCellProps ());};func _dbaeb (_ecce *templateProcessor ,_gdccg *templateNode )(interface{},error ){return _ecce .parseChart (_gdccg );};var _gbabd =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dagcfa :_bbbca },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_cgdd :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_dagcfa :_bdffa },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dagcfa :_bfbgf },"\u0074\u0061\u0062l\u0065":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dagcfa :_cafcd },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_cgdd :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_dagcfa :_fgaed },"\u006c\u0069\u006e\u0065":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dagcfa :_begc },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dagcfa :_bbdee },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dagcfa :_fegeg },"\u0069\u006d\u0061g\u0065":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dagcfa :_efeed },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dagcfa :_dfbce },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_cgdd :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dagcfa :_eagfgc },"\u0063\u0068\u0061r\u0074":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dagcfa :_dbaeb },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dagcfa :_bbgbd },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_cgdd :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_dagcfa :_adaef },"\u006c\u0069\u0073\u0074":&templateTag {_cgdd :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dagcfa :_bgbad },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_cgdd :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_dagcfa :_afba },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_cgdd :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dagcfa :_abbee }};


// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_edgb *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_cacg *_gf .PdfWriter )error ){_edgb ._bbed =pdfWriterAccessFunc ;};func (_degb *Creator )getActivePage ()*_gf .PdfPage {if _degb ._ddbg ==nil {if len (_degb ._cbf )==0{return nil ;
};return _degb ._cbf [len (_degb ._cbf )-1];};return _degb ._ddbg ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{taggedDrawable ;_bgb float64 ;_fabd float64 ;_gbfe float64 ;_gfda float64 ;_eeec float64 ;_ebeb float64 ;_bbbb Color ;_bfee float64 ;};

// Width returns the width of the specified text chunk.
func (_edbg *TextChunk )Width ()float64 {var (_cbgf float64 ;_gagac =_edbg .Style ;);for _ ,_efaag :=range _edbg .Text {_fceca ,_gddff :=_gagac .Font .GetRuneMetrics (_efaag );if !_gddff {_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_efaag ,_efaag ,_gagac .Font .BaseFont (),_gagac .Font .Subtype ());
_ef .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_gagac .Font );_ef .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_gagac .Font .Encoder ());};_gdegb :=_gagac .FontSize *_fceca .Wx ;_fdfbb :=_gdegb ;if _efaag !=' '{_fdfbb =_gdegb +_gagac .CharSpacing *1000.0;
};_cbgf +=_fdfbb ;};return _cbgf /1000.0;};

// SetIndent sets the cell's left indent.
func (_ebfge *TableCell )SetIndent (indent float64 ){_ebfge ._aagdg =indent };

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _dggf (color ,point )};func _gbga (_gagcg string )(_gbgf ,_dbcbc string ){if _gagcg ==""||(_gagcg [len (_gagcg )-1]>='0'&&_gagcg [len (_gagcg )-1]<='9'){return _gagcg ,"";};_gbgf =_gagcg ;
for _ ,_ddfa :=range _ecfa {if _b .Contains (_gbgf ,_ddfa ){_dbcbc =_ddfa ;};_gbgf =_b .TrimSuffix (_gbgf ,_ddfa );};return ;};

// SetBorderRadius sets the radius of the background corners.
func (_ga *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_ga .BorderRadiusTopLeft =topLeft ;_ga .BorderRadiusTopRight =topRight ;_ga .BorderRadiusBottomLeft =bottomLeft ;_ga .BorderRadiusBottomRight =bottomRight ;};type fontMetrics struct{_bfefbg float64 ;
_abagf float64 ;_daffb float64 ;_bdbba float64 ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_bbcc *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _bbcc ._caba .Left ,_bbcc ._caba .Right ,_bbcc ._caba .Top ,_bbcc ._caba .Bottom ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_gdeg *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bffc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcdcc ,_febf :=_bffc .setOpacity (_gdeg ._gbcea ,_gdeg ._cbac );if _febf !=nil {return nil ,ctx ,_febf ;
};_gdgea :=_gdeg ._cega ;_gdgea .FillEnabled =_gdgea .FillColor !=nil ;var (_gfde =ctx .PageHeight ;_ecbf =_gdgea .Curves ;_eccd =make ([]_dd .CubicBezierCurve ,0,len (_gdgea .Curves )););_ddagg :=_gf .PdfRectangle {};for _fagbc :=range _gdgea .Curves {_fcega :=_ecbf [_fagbc ];
_fcega .P0 .Y =_gfde -_fcega .P0 .Y ;_fcega .P1 .Y =_gfde -_fcega .P1 .Y ;_fcega .P2 .Y =_gfde -_fcega .P2 .Y ;_fcega .P3 .Y =_gfde -_fcega .P3 .Y ;_eccd =append (_eccd ,_fcega );_faga :=_fcega .GetBounds ();if _fagbc ==0{_ddagg =_faga ;}else {_ddagg .Llx =_fb .Min (_ddagg .Llx ,_faga .Llx );
_ddagg .Lly =_fb .Min (_ddagg .Lly ,_faga .Lly );_ddagg .Urx =_fb .Max (_ddagg .Urx ,_faga .Urx );_ddagg .Ury =_fb .Max (_ddagg .Ury ,_faga .Ury );};};_gdgea .Curves =_eccd ;defer func (){_gdgea .Curves =_ecbf }();if _gdgea .FillEnabled {_dbbb :=_bdced (_bffc ,_gdeg ._cega .FillColor ,_gdeg ._gege ,func ()Rectangle {return Rectangle {_acaf :_ddagg .Llx ,_dgec :_ddagg .Lly ,_egdeb :_ddagg .Width (),_ebef :_ddagg .Height ()};
});if _dbbb !=nil {return nil ,ctx ,_dbbb ;};};_afcc ,_ ,_febf :=_gdgea .MarkedDraw (_bcdcc ,_gdeg ._febd );if _febf !=nil {return nil ,ctx ,_febf ;};if _febf =_bffc .addContentsByString (string (_afcc ));_febf !=nil {return nil ,ctx ,_febf ;};return []*Block {_bffc },ctx ,nil ;
};

// SetIndent sets the cell's left indent.
func (_abfa *GridCell )SetIndent (indent float64 ){_abfa ._bcbg =indent };

// SetIndent sets the left offset of the list when nested into another list.
func (_cadbe *List )SetIndent (indent float64 ){_cadbe ._eafe =indent ;_cadbe ._dbdb =false };func _fgde (_ceecc string ,_fcfef int )(float64 ,error ){_eccff ,_dbcgc :=_gbga (_ceecc );_gfbcc ,_aadec :=_ca .ParseFloat (_eccff ,_fcfef );if _aadec !=nil {return 0,_aadec ;
};if _bcbbf ,_gfgfbe :=_ggaf [_dbcgc ];_gfgfbe {_gfbcc =_gfbcc *_bcbbf ;}else {_gfbcc =_gfbcc *_gfga ;};return _gfbcc ,nil ;};func _dagfd (_abaab ...interface{})[]interface{}{return _abaab };func _fgaed (_cgggc *templateProcessor ,_bffa *templateNode )(interface{},error ){return _cgggc .parseTableCell (_bffa );
};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_beac *Creator )MoveTo (x ,y float64 ){_beac ._fcba .X =x ;_beac ._fcba .Y =y };

// NewCellProps returns the default properties of an invoice cell.
func (_aafe *Invoice )NewCellProps ()InvoiceCellProps {_cdfc :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_aafe ._agdg ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_cdfc ,BorderColor :_cdfc ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// Link returns link information for this line.
func (_efga *TOCLine )Link ()(_fddfb int64 ,_aacad ,_aaag float64 ){return _efga ._fgeee ,_efga ._fdfd ,_efga ._abfdc ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_ebfgf *TOC )SetLineSeparator (separator string ){_ebfgf ._cfadf =separator };

// NewGrid creates a new Grid with a specified number of columns.
func (_fbcc *Creator )NewGrid (cols int )*Grid {return _bfdff (cols )};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};func (_fagg *templateProcessor )parseListMarker (_bbaeb *templateNode )(interface{},error ){if _bbaeb ._ccbde ==nil {_fagg .nodeLogError (_bbaeb ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_gdac ;};var _fbdga *TextChunk ;switch _eabd :=_bbaeb ._ccbde ._efefd .(type ){case *List :_fbdga =&_eabd ._eaeba ;case *listItem :_fbdga =&_eabd ._fdab ;default:_fagg .nodeLogError (_bbaeb ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_eabd );
return nil ,_gdac ;};if _ ,_dcagdf :=_fagg .parseTextChunk (_bbaeb ,_fbdga );_dcagdf !=nil {_fagg .nodeLogError (_bbaeb ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_dcagdf );
return nil ,nil ;};return _fbdga ,nil ;};func _cffec (_bacbd string )([]string ,error ){if !_ed .ValidString (_bacbd ){return []string {_bacbd },_g .New ("\u0069n\u0070\u0075\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020v\u0061\u006c\u0069\u0064\u0020\u0055\u0054\u0046\u002d\u0038");
};var (_fbfg []string ;_cdffd []rune ;);for _ ,_gcbcb :=range _bacbd {if _gcbcb =='\u000A'{if len (_cdffd )> 0{_fbfg =append (_fbfg ,string (_cdffd ));};_fbfg =append (_fbfg ,string (_gcbcb ));_cdffd =nil ;continue ;};_cdffd =append (_cdffd ,_gcbcb );};
if len (_cdffd )> 0{_fbfg =append (_fbfg ,string (_cdffd ));};var _aebb []string ;for _ ,_dbaeg :=range _fbfg {_gebba :=[]rune (_dbaeg );_efedc :=_a .NewScanner (_gebba );var _decag []rune ;for _ffddb :=0;_ffddb < len (_gebba );_ffddb ++{_ ,_geged ,_cgebe :=_efedc .Next ();
if _cgebe !=nil {return nil ,_cgebe ;};if _geged ==_a .BreakProhibited ||_ge .IsSpace (_gebba [_ffddb ]){_decag =append (_decag ,_gebba [_ffddb ]);if _ge .IsSpace (_gebba [_ffddb ]){_aebb =append (_aebb ,string (_decag ));_decag =[]rune {};};continue ;
}else {if len (_decag )> 0{_aebb =append (_aebb ,string (_decag ));};_decag =[]rune {_gebba [_ffddb ]};};};if len (_decag )> 0{_aebb =append (_aebb ,string (_decag ));};};return _aebb ,nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_fedcf *StyledParagraph )SetWidth (width float64 ){_fedcf ._ffdb =width ;_fedcf .wrapText ()};func (_bgceb *Table )clone ()*Table {_afebaa :=*_bgceb ;_afebaa ._acbg =make ([]float64 ,len (_bgceb ._acbg ));copy (_afebaa ._acbg ,_bgceb ._acbg );_afebaa ._beeaca =make ([]float64 ,len (_bgceb ._beeaca ));
copy (_afebaa ._beeaca ,_bgceb ._beeaca );_afebaa ._agced =make ([]*TableCell ,0,len (_bgceb ._agced ));for _ ,_ecfgc :=range _bgceb ._agced {_eeeggd :=*_ecfgc ;_eeeggd ._gceg =&_afebaa ;_afebaa ._agced =append (_afebaa ._agced ,&_eeeggd );};return &_afebaa ;
};func (_ccdg *templateProcessor )parseParagraph (_aaeed *templateNode ,_dbdf *StyledParagraph )(interface{},error ){if _dbdf ==nil {_dbdf =_ccdg .creator .NewStyledParagraph ();};for _ ,_feafe :=range _aaeed ._fdbe .Attr {_bfccd :=_feafe .Value ;switch _beeag :=_feafe .Name .Local ;
_beeag {case "\u0066\u006f\u006e\u0074":_dbdf .SetFont (_ccdg .parseFontAttr (_beeag ,_bfccd ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_dbdf .SetFontSize (_ccdg .parseFloatAttr (_beeag ,_bfccd ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_dbdf .SetTextAlignment (_ccdg .parseTextAlignmentAttr (_beeag ,_bfccd ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_dbdf .SetLineHeight (_ccdg .parseFloatAttr (_beeag ,_bfccd ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_dbdf .SetEnableWrap (_ccdg .parseBoolAttr (_beeag ,_bfccd ));
case "\u0063\u006f\u006co\u0072":_dbdf .SetFontColor (_ccdg .parseColorAttr (_beeag ,_bfccd ));case "\u0078":_dbdf .SetPos (_ccdg .parseFloatAttr (_beeag ,_bfccd ),_dbdf ._fcda );case "\u0079":_dbdf .SetPos (_dbdf ._bafb ,_ccdg .parseFloatAttr (_beeag ,_bfccd ));
case "\u0061\u006e\u0067l\u0065":_dbdf .SetAngle (_ccdg .parseFloatAttr (_beeag ,_bfccd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_efbbg :=_ccdg .parseMarginAttr (_beeag ,_bfccd );_dbdf .SetMargins (_efbbg .Left ,_efbbg .Right ,_efbbg .Top ,_efbbg .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_dbdf .SetMaxLines (int (_ccdg .parseInt64Attr (_beeag ,_bfccd )));default:_ccdg .nodeLogDebug (_aaeed ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_beeag );
};};return _dbdf ,nil ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_fcab *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_fcab ._caace .Left =left ;_fcab ._caace .Right =right ;_fcab ._caace .Top =top ;_fcab ._caace .Bottom =bottom ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fdbg *StyledParagraph )SetTextAlignment (align TextAlignment ){_fdbg ._abgad =align };

// SetSideBorderColor sets the cell's side border color.
func (_fgda *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_fgda ._dadeb =col ;_fgda ._gdae =col ;_fgda ._agfge =col ;_fgda ._fcdd =col ;case CellBorderSideTop :_fgda ._dadeb =col ;case CellBorderSideBottom :_fgda ._gdae =col ;
case CellBorderSideLeft :_fgda ._agfge =col ;case CellBorderSideRight :_fgda ._fcdd =col ;};};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_cbed *Creator )NewPage ()*_gf .PdfPage {_bfdc :=_cbed .newPage ();_cbed ._cbf =append (_cbed ._cbf ,_bfdc );_cbed ._fcba .Page ++;return _bfdc ;};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;
AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// ParseFromSVGStream creates a GraphicSVG instance from SVG stream input.
func ParseFromSVGStream (source _fd .Reader )(*GraphicSVGElement ,error ){_dgcgc :=_ec .NewDecoder (source );_dgcgc .CharsetReader =_edc .NewReaderLabel ;_acdgd ,_aaefe :=_badae (_dgcgc );if _aaefe !=nil {return nil ,_aaefe ;};if _gcdc :=_acdgd .Decode (_dgcgc );
_gcdc !=nil &&_gcdc !=_fd .EOF {return nil ,_gcdc ;};return _acdgd ,nil ;};func (_cgfdc *Paragraph )getTextWidth ()float64 {_fadcg :=0.0;for _ ,_bbgcc :=range _cgfdc ._edceg {if _bbgcc =='\u000A'{continue ;};_dabb ,_ebeag :=_cgfdc ._abbaf .GetRuneMetrics (_bbgcc );
if !_ebeag {_ef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bbgcc ,_bbgcc );
return -1;};_fadcg +=_cgfdc ._fagc *_dabb .Wx ;};return _fadcg ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_aebd *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_aebd ._feeg .Left =left ;_aebd ._feeg .Right =right ;_aebd ._feeg .Top =top ;_aebd ._feeg .Bottom =bottom ;};

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_bgbd *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bgbd ._ccafa .Left ,_bgbd ._ccafa .Right ,_bgbd ._ccafa .Top ,_bgbd ._ccafa .Bottom ;};

// Path is a collection of all the subpaths in 'd' attribute.
type Path struct{Subpaths []*Subpath ;};

// SetHeight sets the custom height for the row.
func (_bdcg *GridRow )SetHeight (h float64 ){_bdcg ._bef =h };

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_cafd *Chapter )Add (d Drawable )error {if Drawable (_cafd )==d {_ef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _ddb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_cafd ._ebea =append (_cafd ._ebea ,d );case containerDrawable :_fagb ,_bge :=_ddb .ContainerComponent (_cafd );
if _bge !=nil {return _bge ;};_cafd ._ebea =append (_cafd ._ebea ,_fagb );default:_ef .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func _ecabc (_fdfe string )(*Image ,error ){_bccc ,_aecc :=_f .Open (_fdfe );if _aecc !=nil {return nil ,_aecc ;};defer _bccc .Close ();_bdfc ,_aecc :=_gf .ImageHandling .Read (_bccc );if _aecc !=nil {_ef .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_aecc );
return nil ,_aecc ;};return _dgf (_bdfc );};func (_eed *Block )duplicate ()*Block {_cc :=&Block {};*_cc =*_eed ;_fa :=_ebf .ContentStreamOperations {};_fa =append (_fa ,*_eed ._bac ...);_cc ._bac =&_fa ;return _cc ;};

// SetAngle sets the rotation angle of the text.
func (_adbcd *StyledParagraph )SetAngle (angle float64 ){_adbcd ._eagdd =angle };

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_eadd *Rectangle )BorderOpacity ()float64 {return _eadd ._cgdba };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_dbfbf *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbbc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fcfg ,_agge :=_bbbc .setOpacity (_dbfbf ._fdffb ,_dbfbf ._fdffb );if _agge !=nil {return nil ,ctx ,_agge ;
};_bbdge :=_dbfbf ._fbcfa .Points ;for _caacc :=range _bbdge {_abfe :=&_bbdge [_caacc ];_abfe .Y =ctx .PageHeight -_abfe .Y ;};_bgag ,_ ,_agge :=_dbfbf ._fbcfa .MarkedDraw (_fcfg ,_dbfbf ._febd );if _agge !=nil {return nil ,ctx ,_agge ;};if _agge =_bbbc .addContentsByString (string (_bgag ));
_agge !=nil {return nil ,ctx ,_agge ;};return []*Block {_bbbc },ctx ,nil ;};

// Horizontal returns total horizontal (left + right) margin.
func (_acdc *Margins )Horizontal ()float64 {return _acdc .Left +_acdc .Right };

// GridRow defines a row which can contain cells.
type GridRow struct{_cffad []*GridCell ;_bef float64 ;_cedeg float64 ;_fbagff int ;_dcdde *Grid ;_baab *_gf .StructureTagInfo ;_ddce GridRowSection ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_cedec *Creator )DrawTemplate (r _fd .Reader ,data interface{},options *TemplateOptions )error {return _acffa (_cedec ,r ,data ,options ,_cedec );};

// Scale block by specified factors in the x and y directions.
func (_ecb *Block )Scale (sx ,sy float64 ){_bbb :=_ebf .NewContentCreator ().Scale (sx ,sy ).Operations ();*_ecb ._bac =append (*_bbb ,*_ecb ._bac ...);_ecb ._bac .WrapIfNeeded ();_ecb ._ddf *=sx ;_ecb ._geb *=sy ;};func (_fecda *StyledParagraph )getTextHeight ()float64 {var _dbfd float64 ;
for _ ,_eeegg :=range _fecda ._gbbce {_fabc :=_eeegg .Style .FontSize *_fecda ._edcb ;if _fabc > _dbfd {_dbfd =_fabc ;};};return _dbfd ;};

// SetAngle sets Image rotation angle in degrees.
func (_cgde *Image )SetAngle (angle float64 ){_cgde ._ggedf =angle };var _bbef =map[GridRowSection ]_gf .StructureType {GridRowSectionBody :_gf .StructureTypeTableBody ,GridRowSectionHeader :_gf .StructureTypeTableHead ,GridRowSectionFooter :_gf .StructureTypeTableFooter ,GridRowSectionUnknown :_gf .StructureTypeUnknown };


// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_fcaa :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_ef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcaa ;
};var _gcfad int ;if len (hexStr )==2{var _abc int ;_dge ,_cbd :=_e .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_abc );if _cbd !=nil {_ef .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_cbd );
return _fcaa ;};if _dge !=1{_ef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcaa ;};_gcfad =_abc *16+_abc ;}else {_bagb ,_feag :=_e .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_gcfad );
if _feag !=nil {_ef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcaa ;};if _bagb !=1{_ef .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bagb );
return _fcaa ;};};_fcaa ._bacdf =float64 (_gcfad )/255.0;return _fcaa ;};type token struct{_abfec string ;_dfbb bool ;};

// SetPos sets the grid positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the grid does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_gecf *Grid )SetPos (x ,y float64 ){_gecf ._gbfc =PositionAbsolute ;_gecf ._afcf =x ;_gecf ._aege =y ;};

// Text sets the text content of the Paragraph.
func (_agga *Paragraph )Text ()string {return _agga ._edceg };func _bbfcc (_dgff *Creator ,_ageab string ,_bgdedg []byte ,_cafg *TemplateOptions ,_begge componentRenderer )*templateProcessor {if _cafg ==nil {_cafg =&TemplateOptions {};};_cafg .init ();
if _begge ==nil {_begge =_dgff ;};return &templateProcessor {creator :_dgff ,_dgac :_bgdedg ,_caaec :_cafg ,_ffeca :_begge ,_ceeff :_ageab };};

// AddLine appends a new line to the invoice line items table.
func (_dbebd *Invoice )AddLine (values ...string )[]*InvoiceCell {_ccada :=len (_dbebd ._ccgf );var _gbcg []*InvoiceCell ;for _eagdag ,_acega :=range values {_egdg :=_dbebd .newCell (_acega ,_dbebd ._ccbg );if _eagdag < _ccada {_egdg .Alignment =_dbebd ._ccgf [_eagdag ].Alignment ;
};_gbcg =append (_gbcg ,_egdg );};_dbebd ._dafad =append (_dbebd ._dafad ,_gbcg );return _gbcg ;};const (GridRowSectionBody GridRowSection =iota ;GridRowSectionHeader ;GridRowSectionFooter ;GridRowSectionUnknown ;);

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_abfcd *TOCLine )SetStyle (style TextStyle ){_abfcd .Number .Style =style ;_abfcd .Title .Style =style ;_abfcd .Separator .Style =style ;_abfcd .Page .Style =style ;};

// Level returns the indentation level of the TOC line.
func (_fefad *TOCLine )Level ()uint {return _fefad ._bacb };func (_cgddd *templateProcessor )getNodeErrorLocation (_gedfg *templateNode ,_gcfeb string ,_aadcg ...interface{})string {_bgcba :=_e .Sprintf (_gcfeb ,_aadcg ...);_gcge :=_e .Sprintf ("\u0025\u0064",_gedfg ._ceefe );
if _gedfg ._cefe !=0{_gcge =_e .Sprintf ("\u0025\u0064\u003a%\u0064",_gedfg ._cefe ,_gedfg ._cbgec );};if _cgddd ._ceeff !=""{return _e .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_bgcba ,_cgddd ._ceeff ,_gcge );};return _e .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_bgcba ,_gcge );
};

// SetLineOpacity sets the line opacity.
func (_ccffa *Polyline )SetLineOpacity (opacity float64 ){_ccffa ._fdffb =opacity };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gbaa *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _gbaa ._gfcd [0],_gbaa ._gfcd [1]};func (_ccgc *Division )drawBackground (_ebec []*Block ,_cage ,_bgadd DrawContext ,_cbegf bool )([]*Block ,error ){_deaac :=len (_ebec );if _deaac ==0||_ccgc ._ecfg ==nil {return _ebec ,nil ;
};_efbd :=make ([]*Block ,0,len (_ebec ));for _fafea ,_ececc :=range _ebec {var (_deaacb =_ccgc ._ecfg .BorderRadiusTopLeft ;_ddbb =_ccgc ._ecfg .BorderRadiusTopRight ;_bace =_ccgc ._ecfg .BorderRadiusBottomLeft ;_gacb =_ccgc ._ecfg .BorderRadiusBottomRight ;
);_ggag :=_cage ;_ggag .Page +=_fafea ;if _fafea ==0{if _cbegf {_efbd =append (_efbd ,_ececc );continue ;};if _deaac ==1{_ggag .Height =_bgadd .Y -_cage .Y ;};}else {_ggag .X =_ggag .Margins .Left +_ccgc ._ffd .Left ;_ggag .Y =_ggag .Margins .Top ;_ggag .Width =_ggag .PageWidth -_ggag .Margins .Left -_ggag .Margins .Right -_ccgc ._ffd .Left -_ccgc ._ffd .Right ;
if _fafea ==_deaac -1{_ggag .Height =_bgadd .Y -_ggag .Margins .Top -_ccgc ._ffd .Top ;}else {_ggag .Height =_ggag .PageHeight -_ggag .Margins .Top -_ggag .Margins .Bottom ;};if !_cbegf {_deaacb =0;_ddbb =0;};};if _deaac > 1&&_fafea !=_deaac -1{_bace =0;
_gacb =0;};_agbba :=_geeef (_ggag .X ,_ggag .Y ,_ggag .Width ,_ggag .Height );_agbba .SetFillColor (_ccgc ._ecfg .FillColor );_agbba .SetBorderColor (_ccgc ._ecfg .BorderColor );_agbba .SetBorderWidth (_ccgc ._ecfg .BorderSize );_agbba .SetBorderRadius (_deaacb ,_ddbb ,_bace ,_gacb );
_fabe ,_ ,_ged :=_agbba .GeneratePageBlocks (_ggag );if _ged !=nil {return nil ,_ged ;};if len (_fabe )==0{continue ;};_gcda :=_fabe [0];if _ged =_gcda .mergeBlocks (_ececc );_ged !=nil {return nil ,_ged ;};_efbd =append (_efbd ,_gcda );};return _efbd ,nil ;
};func (_dcaga *TemplateOptions )init (){if _dcaga .SubtemplateMap ==nil {_dcaga .SubtemplateMap =map[string ]_fd .Reader {};};if _dcaga .FontMap ==nil {_dcaga .FontMap =map[string ]*_gf .PdfFont {};};if _dcaga .ImageMap ==nil {_dcaga .ImageMap =map[string ]*_gf .Image {};
};if _dcaga .ColorMap ==nil {_dcaga .ColorMap =map[string ]Color {};};if _dcaga .ChartMap ==nil {_dcaga .ChartMap =map[string ]_ce .ChartRenderable {};};};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_fgafg *Line )SetColor (color Color ){_fgafg ._fgbd =color };

// NewTOCLine creates a new table of contents line with the default style.
func (_aeac *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _fbea (number ,title ,page ,level ,_aeac .NewTextStyle ());};

// SetLineColor sets the line color.
func (_ecgg *Polyline )SetLineColor (color Color ){_ecgg ._fbcfa .LineColor =_fbd (color )};func _bdedd (_ggbfe DrawContext ,_beeac *_ebf .ContentCreator ,_gffbf *Block ,_fdbfe rune ,_bbcdf float64 ,_cgfbg *TextStyle ,_ebgad map[string ]_cd .PdfObject )(bool ,error ){var _dgbd *_gf .ColorGlyphInfo ;
if _cgfbg .MultiFont !=nil {_cgfbg .MultiFont .Reset ();_dgbd =_cgfbg .MultiFont .GetColorGlyphInfoByRune (_fdbfe );}else if _cbfef :=_cgfbg .Font .GetOTFType ();_cbfef !=nil {_dgbd =_gf .GetColorGlyphInfoByRune (_cbfef ,_fdbfe );};if _cfga (_fdbfe )&&_dgbd !=nil {if _dgbd .GlyphType ==_gf .ColorGlyphTypeSVG &&len (_dgbd .SVGData )> 0{_efbge :=string (_dgbd .SVGData );
_eaea ,_degeb :=_cggf (_efbge );if _degeb !=nil {return false ,_degeb ;};_eaea .ScaleToHeight (_cgfbg .FontSize );_eaea .SetPos (_bbcdf ,_ggbfe .Y );_beeac =_beeac .Add_ET ().Add_q ();_gbdaf ,_acgbf ,_degeb :=_eaea .GeneratePageBlocks (_ggbfe );if _degeb !=nil {return false ,_degeb ;
};if len (_gbdaf )!=1{return false ,_e .Errorf ("\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0031\u0020\u0062\u006c\u006f\u0063\u006b\u0020\u0066\u0072o\u006d\u0020\u0065\u006d\u006f\u006a\u0069\u0020\u0069\u006d\u0061\u0067\u0065\u002c\u0020\u0067\u006f\u0074\u0020\u0025\u0064",len (_gbdaf ));
};_gffbf .mergeBlocks (_gbdaf [0]);_gfbgf :=_eaea .Width ();_beeac .Add_Q ().Add_BT ().Translate (_gfbgf ,0);_acgbf .X +=_gfbgf ;if len (_ebgad )> 0{_beeac .Add_BMC (*_cd .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")));};return true ,nil ;
}else if _dgbd .GlyphType ==_gf .ColorGlyphTypeBitmap &&len (_dgbd .BitmapData )> 0{_ddea ,_fbcfb :=_dgge (_dgbd .BitmapData );if _fbcfb !=nil {return false ,_fbcfb ;};_ddea .SetEncoder (_cd .NewDCTEncoder ());if _dgbd .GetColorGlyphFormat ()=="\u0050\u004e\u0047"{_ddea .SetEncoder (_cd .NewFlateEncoder ());
};_cbagg :=_cgfbg .FontSize /float64 (_dgbd .BitmapHeight );_ecddd :=float64 (_dgbd .BitmapWidth )*_cbagg ;_aedc :=float64 (_dgbd .BitmapHeight )*_cbagg ;_ddea .SetWidth (_ecddd );_ddea .SetHeight (_aedc );_ddea .SetPos (_bbcdf ,_ggbfe .Y );_beeac =_beeac .Add_ET ().Add_q ();
_aedea ,_fceaf ,_fbcfb :=_ddea .GeneratePageBlocks (_ggbfe );if _fbcfb !=nil {return false ,_fbcfb ;};if len (_aedea )!=1{return false ,_e .Errorf ("\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0031\u0020\u0062\u006c\u006f\u0063\u006b\u0020\u0066\u0072o\u006d\u0020\u0065\u006d\u006f\u006a\u0069\u0020\u0069\u006d\u0061\u0067\u0065\u002c\u0020\u0067\u006f\u0074\u0020\u0025\u0064",len (_aedea ));
};_gffbf .mergeBlocks (_aedea [0]);_beeac .Add_Q ().Add_BT ().Translate (_ecddd ,0);_fceaf .X +=_ecddd ;if len (_ebgad )> 0{_beeac .Add_BMC (*_cd .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")));};return true ,nil ;};};return false ,nil ;
};func (_bcffd *templateProcessor )parseColor (_cfbfff string )Color {if _cfbfff ==""{return nil ;};_gcfebg ,_bcdd :=_bcffd ._caaec .ColorMap [_cfbfff ];if _bcdd {return _gcfebg ;};if _cfbfff [0]=='#'{return ColorRGBFromHex (_cfbfff );};return nil ;};type marginDrawable interface{VectorDrawable ;
GetMargins ()(float64 ,float64 ,float64 ,float64 );};func (_bagg *Grid )updateRowHeights (_eeaca float64 ){for _ ,_fdbdd :=range _bagg ._fdagc {_fdbdd .updateRowHeight (_eeaca );};};

// SetBorderColor sets the border color.
func (_badc *CurvePolygon )SetBorderColor (color Color ){_badc ._feaa .BorderColor =_fbd (color )};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_bcef *StyledParagraph )Insert (index uint ,text string )*TextChunk {_dcdge :=uint (len (_bcef ._gbbce ));if index > _dcdge {index =_dcdge ;};_cegfc :=NewTextChunk (text ,_bcef ._dgaag );_bcef ._gbbce =append (_bcef ._gbbce [:index ],append ([]*TextChunk {_cegfc },_bcef ._gbbce [index :]...)...);
_bcef .wrapText ();return _cegfc ;};func _adabe (_bbgde []token )([]*Command ,error ){var (_bdfed []*Command ;_bgecf []float64 ;);for _ecdea :=len (_bbgde )-1;_ecdea >=0;_ecdea --{_cbea :=_bbgde [_ecdea ];if _cbea ._dfbb {_fade :=_ggbad ._gbgdc [_b .ToLower (_cbea ._abfec )];
_gcdbb :=len (_bgecf );if _fade ==0&&_gcdbb ==0{_bbfce :=&Command {Symbol :_cbea ._abfec };_bdfed =append ([]*Command {_bbfce },_bdfed ...);}else if _fade !=0&&_gcdbb %_fade ==0{_ecbg :=_gcdbb /_fade ;for _gedg :=0;_gedg < _ecbg ;_gedg ++{_befe :=_cbea ._abfec ;
if _befe =="\u006d"&&_gedg < _ecbg -1{_befe ="\u006c";};if _befe =="\u004d"&&_gedg < _ecbg -1{_befe ="\u004c";};_cecdf :=&Command {_befe ,_afeae (_bgecf [:_fade ])};_bdfed =append ([]*Command {_cecdf },_bdfed ...);_bgecf =_bgecf [_fade :];};}else {_feaga :=pathParserError {"I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0070\u0061r\u0061\u006d\u0065\u0074\u0065\u0072\u0073\u0020\u0066\u006fr\u0020"+_cbea ._abfec };
return nil ,_feaga ;};}else {_fggf ,_cafa :=_fgde (_cbea ._abfec ,64);if _cafa !=nil {return nil ,_cafa ;};_bgecf =append (_bgecf ,_fggf );};};return _bdfed ,nil ;};

// SetTotal sets the total of the invoice.
func (_dade *Invoice )SetTotal (value string ){_dade ._dfad [1].Value =value };func _befec (_cecbf ,_afcac interface{})(interface{},error ){_abgfe ,_abaagb :=_bcceb (_cecbf );if _abaagb !=nil {return nil ,_abaagb ;};switch _fbaee :=_abgfe .(type ){case int64 :_abae ,_dgbbfg :=_bcceb (_afcac );
if _dgbbfg !=nil {return nil ,_dgbbfg ;};switch _geaed :=_abae .(type ){case int64 :return _fbaee +_geaed ,nil ;case float64 :return float64 (_fbaee )+_geaed ,nil ;};case float64 :_fedg ,_acceba :=_bcceb (_afcac );if _acceba !=nil {return nil ,_acceba ;
};switch _baaae :=_fedg .(type ){case int64 :return _fbaee +float64 (_baaae ),nil ;case float64 :return _fbaee +_baaae ,nil ;};};return nil ,_e .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_cecbf ,_afcac );
};

// Positioning returns the type of positioning the rectangle is set to use.
func (_daff *Rectangle )Positioning ()Positioning {return _daff ._gbbdg };

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_fefa *GridCell )SetContent (vd VectorDrawable )error {switch _dgcd :=vd .(type ){case *Paragraph :if _dgcd ._fefe {_dgcd ._daabg =true ;};_fefa ._bcfd =vd ;case *StyledParagraph :if _dgcd ._dddf {_dgcd ._ffeac =true ;};_fefa ._bcfd =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_fefa ._bcfd =vd ;
default:_ef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _cd .ErrTypeError ;};return nil ;};

// GraphicSVGElement represents SVG instances.
type GraphicSVGElement struct{

// ViewBox represents viewBox value of element.
ViewBox struct{X ,Y ,W ,H float64 ;};

// Name of element.
Name string ;

// Attributes of element.
Attributes map[string ]string ;

// Children elements.
Children []*GraphicSVGElement ;

// Content contains text value of element.
Content string ;

// Style element style attribute.
Style *GraphicSVGStyle ;

// Width of element.
Width float64 ;

// Height of element.
Height float64 ;_bcae float64 ;_abca map[string ]*LinearShading ;_ceefd map[string ]*RadialShading ;_fddeg float64 ;_fggg float64 ;};

// GetRowHeight returns the height of the specified row.
func (_bdadc *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_bdadc ._acbg ){return 0,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _bdadc ._acbg [row -1],nil ;
};

// Height returns the Block's height.
func (_gcb *Block )Height ()float64 {return _gcb ._geb };func (_bc *Block )addWrappedContents (_add *_ebf .ContentStreamOperations ){_bc ._bac .WrapIfNeeded ();_add .WrapIfNeeded ();*_bc ._bac =append (*_bc ._bac ,*_add ...);};

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_ebg *Block )SetMarkedContentID (id int64 ){};func _ebba (_cda _da .Image )(*Image ,error ){_gbca ,_abef :=_gf .ImageHandling .NewImageFromGoImage (_cda );if _abef !=nil {return nil ,_abef ;};return _dgf (_gbca );};

// SetNumber sets the number of the invoice.
func (_ggdb *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_ggdb ._gfcd [1].Value =number ;return _ggdb ._gfcd [0],_ggdb ._gfcd [1];};

// NewChapter creates a new chapter with the specified title as the heading.
func (_eeee *Creator )NewChapter (title string )*Chapter {_eeee ._baga ++;_cggd :=_eeee .NewTextStyle ();_cggd .FontSize =16;return _agde (nil ,_eeee ._fagf ,_eeee ._cced ,title ,_eeee ._baga ,_cggd );};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_cdeg *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cdeg ._bbcd .Left ,_cdeg ._bbcd .Right ,_cdeg ._bbcd .Top ,_cdeg ._bbcd .Bottom ;};

// Logo returns the logo of the invoice.
func (_efbbd *Invoice )Logo ()*Image {return _efbbd ._gffb };

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_efeab *Rectangle )SetFitMode (fitMode FitMode ){_efeab ._ffbcg =fitMode };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_caeac *Image )SetEncoder (encoder _cd .StreamEncoder ){_caeac ._dbfa =encoder };func (_bbagb *templateProcessor )parseTableCell (_cgcad *templateNode )(interface{},error ){if _cgcad ._ccbde ==nil {_bbagb .nodeLogError (_cgcad ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_gdac ;};_bafgd ,_cfgda :=_cgcad ._ccbde ._efefd .(*Table );if !_cfgda {_bbagb .nodeLogError (_cgcad ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_cgcad ._ccbde ._efefd );
return nil ,_gdac ;};var _cgag ,_gcgee int64 ;for _ ,_fcdge :=range _cgcad ._fdbe .Attr {_bfadc :=_fcdge .Value ;switch _gbdb :=_fcdge .Name .Local ;_gbdb {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_cgag =_bbagb .parseInt64Attr (_gbdb ,_bfadc );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_gcgee =_bbagb .parseInt64Attr (_gbdb ,_bfadc );
};};if _cgag <=0{_cgag =1;};if _gcgee <=0{_gcgee =1;};_fcfe :=_bafgd .MultiCell (int (_gcgee ),int (_cgag ));for _ ,_ggbcgf :=range _cgcad ._fdbe .Attr {_babgb :=_ggbcgf .Value ;switch _dece :=_ggbcgf .Name .Local ;_dece {case "\u0069\u006e\u0064\u0065\u006e\u0074":_fcfe .SetIndent (_bbagb .parseFloatAttr (_dece ,_babgb ));
case "\u0061\u006c\u0069g\u006e":_fcfe .SetHorizontalAlignment (_bbagb .parseCellAlignmentAttr (_dece ,_babgb ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_fcfe .SetVerticalAlignment (_bbagb .parseCellVerticalAlignmentAttr (_dece ,_babgb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_fcfe .SetSideBorderStyle (CellBorderSideAll ,_bbagb .parseCellBorderStyleAttr (_dece ,_babgb ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_fcfe .SetSideBorderStyle (CellBorderSideTop ,_bbagb .parseCellBorderStyleAttr (_dece ,_babgb ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_fcfe .SetSideBorderStyle (CellBorderSideBottom ,_bbagb .parseCellBorderStyleAttr (_dece ,_babgb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_fcfe .SetSideBorderStyle (CellBorderSideLeft ,_bbagb .parseCellBorderStyleAttr (_dece ,_babgb ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_fcfe .SetSideBorderStyle (CellBorderSideRight ,_bbagb .parseCellBorderStyleAttr (_dece ,_babgb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_fcfe .SetSideBorderWidth (CellBorderSideAll ,_bbagb .parseFloatAttr (_dece ,_babgb ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_fcfe .SetSideBorderWidth (CellBorderSideTop ,_bbagb .parseFloatAttr (_dece ,_babgb ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_fcfe .SetSideBorderWidth (CellBorderSideBottom ,_bbagb .parseFloatAttr (_dece ,_babgb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_fcfe .SetSideBorderWidth (CellBorderSideLeft ,_bbagb .parseFloatAttr (_dece ,_babgb ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_fcfe .SetSideBorderWidth (CellBorderSideRight ,_bbagb .parseFloatAttr (_dece ,_babgb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_fcfe .SetSideBorderColor (CellBorderSideAll ,_bbagb .parseColorAttr (_dece ,_babgb ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_fcfe .SetSideBorderColor (CellBorderSideTop ,_bbagb .parseColorAttr (_dece ,_babgb ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_fcfe .SetSideBorderColor (CellBorderSideBottom ,_bbagb .parseColorAttr (_dece ,_babgb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_fcfe .SetSideBorderColor (CellBorderSideLeft ,_bbagb .parseColorAttr (_dece ,_babgb ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_fcfe .SetSideBorderColor (CellBorderSideRight ,_bbagb .parseColorAttr (_dece ,_babgb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_fcfe .SetBorderLineStyle (_bbagb .parseLineStyleAttr (_dece ,_babgb ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_fcfe .SetBackgroundColor (_bbagb .parseColorAttr (_dece ,_babgb ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_bbagb .nodeLogDebug (_cgcad ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_dece );
};};return _fcfe ,nil ;};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_dccab *TOC )SetHeading (text string ,style TextStyle ){_dbfaf :=_dccab .Heading ();_dbfaf .Reset ();_defgd :=_dbfaf .Append (text );_defgd .Style =style ;};func (_fcbf *templateProcessor )nodeLogDebug (_gfff *templateNode ,_agcd string ,_bgdfg ...interface{}){_ef .Log .Debug (_fcbf .getNodeErrorLocation (_gfff ,_agcd ,_bgdfg ...));
};

// SkipRows skips over a specified number of rows in the table.
func (_egdca *Table )SkipRows (num int ){_aceb :=num *_egdca ._daebe -1;if _aceb < 0{_ef .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _ebab :=0;_ebab < _aceb ;_ebab ++{_egdca .NewCell ();};};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_eccg *Paragraph )SetColor (col Color ){_eccg ._dbbg =col };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cdaf *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edaf :=ctx ;_gbda :=[]func (_caagc DrawContext )([]*Block ,DrawContext ,error ){_cdaf .generateHeaderBlocks ,_cdaf .generateInformationBlocks ,_cdaf .generateLineBlocks ,_cdaf .generateTotalBlocks ,_cdaf .generateNoteBlocks };
var _febbc []*Block ;for _ ,_fcdgf :=range _gbda {_egfda ,_eagfg ,_dbee :=_fcdgf (ctx );if _dbee !=nil {return _febbc ,ctx ,_dbee ;};if len (_febbc )==0{_febbc =_egfda ;}else if len (_egfda )> 0{_febbc [len (_febbc )-1].mergeBlocks (_egfda [0]);_febbc =append (_febbc ,_egfda [1:]...);
};ctx =_eagfg ;};if _cdaf ._fbgb .IsRelative (){ctx .X =_edaf .X ;};if _cdaf ._fbgb .IsAbsolute (){return _febbc ,_edaf ,nil ;};return _febbc ,ctx ,nil ;};

// SetBorderRadius sets the radius of the rectangle corners.
func (_abdg *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_abdg ._ddfb =topLeft ;_abdg ._ebdg =topRight ;_abdg ._afdd =bottomLeft ;_abdg ._dbaed =bottomRight ;};

// SetTextExpansion sets the text expansion for the text chunk.
func (_fbgdc *TextChunk )SetTextExpansion (text string ){_fbgdc ._afcbd =&text };func (_ggcga *templateProcessor )parseColorAttr (_bfbed ,_fcbc string )Color {_ef .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bfbed ,_fcbc );
_fcbc =_b .TrimSpace (_fcbc );if _b .HasPrefix (_fcbc ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_b .HasSuffix (_fcbc ,"\u0029")&&len (_fcbc )> 17{return _ggcga .parseLinearGradientAttr (_ggcga .creator ,_fcbc );
};if _b .HasPrefix (_fcbc ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_b .HasSuffix (_fcbc ,"\u0029")&&len (_fcbc )> 17{return _ggcga .parseRadialGradientAttr (_ggcga .creator ,_fcbc );};if _deba :=_ggcga .parseColor (_fcbc );
_deba !=nil {return _deba ;};return ColorBlack ;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// NewPolygon creates a new polygon.
func (_dedf *Creator )NewPolygon (points [][]_dd .Point )*Polygon {return _afdc (points )};func _bcceb (_cdgag interface{})(interface{},error ){switch _cbbf :=_cdgag .(type ){case uint8 :return int64 (_cbbf ),nil ;case int8 :return int64 (_cbbf ),nil ;
case uint16 :return int64 (_cbbf ),nil ;case int16 :return int64 (_cbbf ),nil ;case uint32 :return int64 (_cbbf ),nil ;case int32 :return int64 (_cbbf ),nil ;case uint64 :return int64 (_cbbf ),nil ;case int64 :return _cbbf ,nil ;case int :return int64 (_cbbf ),nil ;
case float32 :return float64 (_cbbf ),nil ;case float64 :return _cbbf ,nil ;};return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_cdgag );
};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_ccedce *Line )SetMargins (left ,right ,top ,bottom float64 ){_ccedce ._dfbfa .Left =left ;_ccedce ._dfbfa .Right =right ;_ccedce ._dfbfa .Top =top ;_ccedce ._dfbfa .Bottom =bottom ;};

// SetLazy sets the lazy mode for the image.
func (_gaab *Image )SetLazy (lazy bool ){_gaab ._cbgdb =lazy };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_gffgf *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _adad (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_bdad *Paragraph )Height ()float64 {_bdad .wrapText ();return _eca .RoundDefault (float64 (len (_bdad ._bbbd ))*_bdad ._eaag *_bdad ._fagc );};type componentRenderer interface{Draw (_ceefg Drawable )error ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_aaba :float64 (r )/255.0,_caef :float64 (g )/255.0,_dgc :float64 (b )/255.0};};func _ebage (_eddcb *_gf .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_eddcb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetFont sets the font for the paragraph.
func (_ggbg *StyledParagraph )SetFont (font *_gf .PdfFont ){_ggbg ._dgaag .Font =font ;for _ ,_agff :=range _ggbg ._gbbce {_agff .Style .Font =font ;};};func _dabba (_bgdff ...interface{})(map[string ]interface{},error ){_bbdgee :=len (_bgdff );if _bbdgee %2!=0{_ef .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_bbdgee );
return nil ,_cd .ErrRangeError ;};_cfacg :=map[string ]interface{}{};for _ebaee :=0;_ebaee < _bbdgee ;_ebaee +=2{_cege ,_babfc :=_bgdff [_ebaee ].(string );if !_babfc {_ef .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_bgdff [_ebaee ]);
return nil ,_cd .ErrTypeError ;};_cfacg [_cege ]=_bgdff [_ebaee +1];};return _cfacg ,nil ;};func _gab (_cdfb [][]_dd .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_feaa :&_dd .CurvePolygon {Rings :_cdfb },_ccc :1.0,_bdeb :1.0};};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_bgac *Creator )MoveDown (dy float64 ){_bgac ._fcba .Y +=dy };

// TitleStyle returns the style properties used to render the invoice title.
func (_fdff *Invoice )TitleStyle ()TextStyle {return _fdff ._cead };func _bafgb (_ebcgac float64 ,_ebfad float64 )float64 {return _fb .Round (_ebcgac /_ebfad )*_ebfad };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_gcacc *TOCLine )SetLink (page int64 ,x ,y float64 ){_gcacc ._fdfd =x ;_gcacc ._abfdc =y ;_gcacc ._fgeee =page ;_bcaee :=_gcacc ._eccb ._eeeag .Color ;_gcacc .Number .Style .Color =_bcaee ;_gcacc .Title .Style .Color =_bcaee ;_gcacc .Separator .Style .Color =_bcaee ;
_gcacc .Page .Style .Color =_bcaee ;};func (_fecde *Command )compare (_ccbbf *Command )bool {if _fecde .Symbol !=_ccbbf .Symbol {return false ;};for _eagfgd ,_dgdae :=range _fecde .Params {if _dgdae !=_ccbbf .Params [_eagfgd ]{return false ;};};return true ;
};func _eagfgc (_dccg *templateProcessor ,_dbcd *templateNode )(interface{},error ){return _dccg .parseChapterHeading (_dbcd );};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_bcfa *Rectangle )Height ()float64 {return _bcfa ._ebef };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{taggedDrawable ;_fbcfa *_dd .Polyline ;_fdffb float64 ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_abab *List )Add (item VectorDrawable )(*TextChunk ,error ){_debf :=&listItem {_cceec :item ,_fdab :_abab ._eaeba };switch _beec :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _beec ._dbdb {_beec ._eafe =15;};case *Division :case *Image :case *Table :default:return nil ,_g .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_abab ._agec =append (_abab ._agec ,_debf );return &_debf ._fdab ,nil ;};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_fagbcb *Rectangle )GetCoords ()(float64 ,float64 ){return _fagbcb ._acaf ,_fagbcb ._dgec };

// BorderWidth returns the border width of the ellipse.
func (_gacf *Ellipse )BorderWidth ()float64 {return _gacf ._dcag };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_fbdcg *TOC )SetLinePageStyle (style TextStyle ){_fbdcg ._gagad =style };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_adcb *Table )MultiColCell (colspan int )*TableCell {return _adcb .MultiCell (1,colspan )};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_egbg *Image )SetMargins (left ,right ,top ,bottom float64 ){_egbg ._gdgbd .Left =left ;_egbg ._gdgbd .Right =right ;_egbg ._gdgbd .Top =top ;_egbg ._gdgbd .Bottom =bottom ;};func (_dfgf *templateProcessor )parseTextChunk (_bdebgb *templateNode ,_caec *TextChunk )(interface{},error ){if _bdebgb ._ccbde ==nil {_dfgf .nodeLogError (_bdebgb ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_gdac ;};var (_efacd =_dfgf .creator .NewTextStyle ();_egbc bool ;);for _ ,_efeabd :=range _bdebgb ._fdbe .Attr {if _efeabd .Name .Local =="\u006c\u0069\u006e\u006b"{_adgg ,_bebg :=_bdebgb ._ccbde ._efefd .(*StyledParagraph );if !_bebg {_dfgf .nodeLogError (_bdebgb ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_egbc =true ;}else {_efacd =_adgg ._eeeag ;};break ;};};if _caec ==nil {_caec =NewTextChunk ("",_efacd );};for _ ,_fcbag :=range _bdebgb ._fdbe .Attr {_cgffe :=_fcbag .Value ;switch _feabd :=_fcbag .Name .Local ;_feabd {case "\u0063\u006f\u006co\u0072":_caec .Style .Color =_dfgf .parseColorAttr (_feabd ,_cgffe );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_caec .Style .OutlineColor =_dfgf .parseColorAttr (_feabd ,_cgffe );case "\u0066\u006f\u006e\u0074":_caec .Style .Font =_dfgf .parseFontAttr (_feabd ,_cgffe );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_caec .Style .FontSize =_dfgf .parseFloatAttr (_feabd ,_cgffe );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_caec .Style .OutlineSize =_dfgf .parseFloatAttr (_feabd ,_cgffe );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_caec .Style .CharSpacing =_dfgf .parseFloatAttr (_feabd ,_cgffe );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_caec .Style .HorizontalScaling =_dfgf .parseFloatAttr (_feabd ,_cgffe );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_caec .Style .RenderingMode =_dfgf .parseTextRenderingModeAttr (_feabd ,_cgffe );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_caec .Style .Underline =_dfgf .parseBoolAttr (_feabd ,_cgffe );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_caec .Style .UnderlineStyle .Color =_dfgf .parseColorAttr (_feabd ,_cgffe );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_caec .Style .UnderlineStyle .Offset =_dfgf .parseFloatAttr (_feabd ,_cgffe );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_caec .Style .UnderlineStyle .Thickness =_dfgf .parseFloatAttr (_feabd ,_cgffe );
case "\u006c\u0069\u006e\u006b":if !_egbc {_caec .AddAnnotation (_dfgf .parseLinkAttr (_feabd ,_cgffe ));};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_caec .Style .TextRise =_dfgf .parseFloatAttr (_feabd ,_cgffe );default:_dfgf .nodeLogDebug (_bdebgb ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_feabd );
};};return _caec ,nil ;};func (_dgbbd *templateProcessor )parseCellBorderStyleAttr (_agbec ,_ebfea string )CellBorderStyle {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_agbec ,_ebfea );
_gdbde :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_ebfea ];return _gdbde ;};func (_fde *Block )mergeBlocks (_agf *Block )error {_ffb :=_feee (_fde ._bac ,_fde ._ebe ,_agf ._bac ,_agf ._ebe );
if _ffb !=nil {return _ffb ;};for _ ,_aaa :=range _agf ._geg {_fde .AddAnnotation (_aaa );};return nil ;};

// SetSellerAddress sets the seller address of the invoice.
func (_cacga *Invoice )SetSellerAddress (address *InvoiceAddress ){_cacga ._dfce =address };type grayColor struct{_bacdf float64 };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{taggedDrawable ;_cbg []VectorDrawable ;_abba Positioning ;_ffd Margins ;_aeg Margins ;_dfcc bool ;_gffa bool ;_ecfg *Background ;};type templateNode struct{_efefd interface{};_fdbe _ec .StartElement ;_ccbde *templateNode ;_cefe int ;
_cbgec int ;_ceefe int64 ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_eagda *GraphicSVG )Scale (xFactor ,yFactor float64 ){_eagda ._aagdf .Width =xFactor *_eagda ._aagdf .Width ;_eagda ._aagdf .Height =yFactor *_eagda ._aagdf .Height ;_eagda ._aagdf .SetScaling (xFactor ,yFactor );};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bedf *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bedf ._dbge .Left ,_bedf ._dbge .Right ,_bedf ._dbge .Top ,_bedf ._dbge .Bottom ;};func (_egca *pageTransformations )applyFlip (_degc *_gf .PdfPage )error {_dfaa ,_gfce :=_egca ._dffe ,_egca ._cfef ;
if !_dfaa &&!_gfce {return nil ;};if _degc ==nil {return _g .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_dca ,_bedb :=_degc .GetMediaBox ();if _bedb !=nil {return _bedb ;};_bdga ,_feegc :=_dca .Width (),_dca .Height ();
_fac ,_bedb :=_degc .GetRotate ();if _bedb !=nil {_ef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_bedb .Error ());
};if _acce :=_fac %360!=0&&_fac %90==0;_acce {if _cgaf :=(360+_fac %360)%360;_cgaf ==90||_cgaf ==270{_dfaa ,_gfce =_gfce ,_dfaa ;};};_ebfa ,_facg :=1.0,0.0;if _dfaa {_ebfa ,_facg =-1.0,-_bdga ;};_bdbf ,_gcgf :=1.0,0.0;if _gfce {_bdbf ,_gcgf =-1.0,-_feegc ;
};_ebeda :=_ebf .NewContentCreator ().Scale (_ebfa ,_bdbf ).Translate (_facg ,_gcgf );_gegg ,_bedb :=_cd .MakeStream (_ebeda .Bytes (),_cd .NewFlateEncoder ());if _bedb !=nil {return _bedb ;};_edccc :=_cd .MakeArray (_gegg );_edccc .Append (_degc .GetContentStreamObjs ()...);
_degc .Contents =_edccc ;return nil ;};

// SetFillOpacity sets the fill opacity.
func (_faddg *Polygon )SetFillOpacity (opacity float64 ){_faddg ._cccgd =opacity };

// AddExternalLinkWithTag adds a new external link to the paragraph with proper tagging for accessibility.
// The text parameter represents the text that is displayed and the url parameter sets the destination.
// The options parameter contains accessibility properties like tooltip, altText, and mcid.
func (_bdeag *StyledParagraph )AddExternalLinkWithTag (text ,url string ,options LinkTagOptions )(*TextChunk ,*_gf .KDict ){_aaedg :=_dffad (url ,options .Tooltip );_decd ,_cgdf ,_fcdf :=_bdeag .createAccessibleLinkChunk (text ,_aaedg ,options );if _fcdf !=nil {_ef .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0065\u0078\u0074\u0065\u0072n\u0061\u006c\u0020\u006c\u0069\u006e\u006b\u0020\u0077\u0069th\u0020\u0074\u0061g\u003a \u0025\u0076",_fcdf );
return nil ,nil ;};return _decd ,_cgdf ;};

// GeneratePageBlocks implements drawable interface.
func (_bbd *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dabg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fdeb :=_bbd ._ecfc ;_bfbf :=ctx .PageHeight -_bbd ._agg ;if _bbd ._gcd !=nil {_bae :=_dd .Rectangle {Opacity :1.0,X :_bbd ._ecfc ,Y :ctx .PageHeight -_bbd ._agg -_bbd ._efe ,Height :_bbd ._efe ,Width :_bbd ._aef };
_bae .FillEnabled =true ;_cgc :=_fbd (_bbd ._gcd );_agcf :=_bdced (_dabg ,_cgc ,_bbd ._gcd ,func ()Rectangle {return Rectangle {_acaf :_bae .X ,_dgec :_bae .Y ,_egdeb :_bae .Width ,_ebef :_bae .Height };});if _agcf !=nil {return nil ,ctx ,_agcf ;};_bae .FillColor =_cgc ;
_bae .BorderEnabled =false ;_ggcf :="";if _bbd ._dbeg < 1{_bbaf :=_cd .MakeDict ();_bbaf .Set ("\u0063\u0061",_cd .MakeFloat (_bbd ._dbeg ));_bbaf .Set ("\u0043\u0041",_cd .MakeFloat (_bbd ._dbeg ));_ccgg :=_dabg ._ebe .AddExtGState ("\u0067\u0073\u0031",_bbaf );
if _ccgg ==nil {_ggcf ="\u0067\u0073\u0031";};};_bdf ,_ ,_agcf :=_bae .Draw (_ggcf );if _agcf !=nil {return nil ,ctx ,_agcf ;};_agcf =_dabg .addContentsByString (string (_bdf ));if _agcf !=nil {return nil ,ctx ,_agcf ;};};_edcg :=_bbd ._ggc ;_fag :=_bbd ._bcd ;
_dgb :=_bbd ._bag ;_aae :=_bbd ._gebg ;_fbe :=_bbd ._ggc ;if _bbd ._aff ==CellBorderStyleDouble {_fbe +=2*_edcg ;};_affc :=_bbd ._bcd ;if _bbd ._cbc ==CellBorderStyleDouble {_affc +=2*_fag ;};_dfc :=_bbd ._bag ;if _bbd ._dab ==CellBorderStyleDouble {_dfc +=2*_dgb ;
};_adg :=_bbd ._gebg ;if _bbd ._gdb ==CellBorderStyleDouble {_adg +=2*_aae ;};_eagg :=(_fbe -_dfc )/2;_ddff :=(_fbe -_adg )/2;_dgaf :=(_affc -_dfc )/2;_edbf :=(_affc -_adg )/2;if _bbd ._ggc !=0{_fge :=_fdeb ;_ace :=_bfbf ;if _bbd ._aff ==CellBorderStyleDouble {_ace -=_edcg ;
_cggg :=_dd .BasicLine {LineColor :_fbd (_bbd ._ced ),Opacity :1.0,LineWidth :_bbd ._ggc ,LineStyle :_bbd .LineStyle ,X1 :_fge -_fbe /2+_eagg ,Y1 :_ace +2*_edcg ,X2 :_fge +_fbe /2-_ddff +_bbd ._aef ,Y2 :_ace +2*_edcg };_cga ,_ ,_egb :=_cggg .Draw ("");
if _egb !=nil {return nil ,ctx ,_egb ;};_egb =_dabg .addContentsByString (string (_cga ));if _egb !=nil {return nil ,ctx ,_egb ;};};_fefc :=_dd .BasicLine {LineWidth :_bbd ._ggc ,Opacity :1.0,LineColor :_fbd (_bbd ._ced ),LineStyle :_bbd .LineStyle ,X1 :_fge -_fbe /2+_eagg +(_dfc -_bbd ._bag ),Y1 :_ace ,X2 :_fge +_fbe /2-_ddff +_bbd ._aef -(_adg -_bbd ._gebg ),Y2 :_ace };
_ecab ,_ ,_fgag :=_fefc .Draw ("");if _fgag !=nil {return nil ,ctx ,_fgag ;};_fgag =_dabg .addContentsByString (string (_ecab ));if _fgag !=nil {return nil ,ctx ,_fgag ;};};if _bbd ._bcd !=0{_acac :=_fdeb ;_cgb :=_bfbf -_bbd ._efe ;if _bbd ._cbc ==CellBorderStyleDouble {_cgb +=_fag ;
_agbf :=_dd .BasicLine {LineWidth :_bbd ._bcd ,Opacity :1.0,LineColor :_fbd (_bbd ._bfb ),LineStyle :_bbd .LineStyle ,X1 :_acac -_affc /2+_dgaf ,Y1 :_cgb -2*_fag ,X2 :_acac +_affc /2-_edbf +_bbd ._aef ,Y2 :_cgb -2*_fag };_gag ,_ ,_gdf :=_agbf .Draw ("");
if _gdf !=nil {return nil ,ctx ,_gdf ;};_gdf =_dabg .addContentsByString (string (_gag ));if _gdf !=nil {return nil ,ctx ,_gdf ;};};_dbegd :=_dd .BasicLine {LineWidth :_bbd ._bcd ,Opacity :1.0,LineColor :_fbd (_bbd ._bfb ),LineStyle :_bbd .LineStyle ,X1 :_acac -_affc /2+_dgaf +(_dfc -_bbd ._bag ),Y1 :_cgb ,X2 :_acac +_affc /2-_edbf +_bbd ._aef -(_adg -_bbd ._gebg ),Y2 :_cgb };
_eff ,_ ,_fgdg :=_dbegd .Draw ("");if _fgdg !=nil {return nil ,ctx ,_fgdg ;};_fgdg =_dabg .addContentsByString (string (_eff ));if _fgdg !=nil {return nil ,ctx ,_fgdg ;};};if _bbd ._bag !=0{_gbg :=_fdeb ;_caf :=_bfbf ;if _bbd ._dab ==CellBorderStyleDouble {_gbg +=_dgb ;
_egaa :=_dd .BasicLine {LineWidth :_bbd ._bag ,Opacity :1.0,LineColor :_fbd (_bbd ._ebcg ),LineStyle :_bbd .LineStyle ,X1 :_gbg -2*_dgb ,Y1 :_caf +_dfc /2+_eagg ,X2 :_gbg -2*_dgb ,Y2 :_caf -_dfc /2-_dgaf -_bbd ._efe };_ecbb ,_ ,_ccbd :=_egaa .Draw ("");
if _ccbd !=nil {return nil ,ctx ,_ccbd ;};_ccbd =_dabg .addContentsByString (string (_ecbb ));if _ccbd !=nil {return nil ,ctx ,_ccbd ;};};_dgaa :=_dd .BasicLine {LineWidth :_bbd ._bag ,Opacity :1.0,LineColor :_fbd (_bbd ._ebcg ),LineStyle :_bbd .LineStyle ,X1 :_gbg ,Y1 :_caf +_dfc /2+_eagg -(_fbe -_bbd ._ggc ),X2 :_gbg ,Y2 :_caf -_dfc /2-_dgaf -_bbd ._efe +(_affc -_bbd ._bcd )};
_ebae ,_ ,_gffg :=_dgaa .Draw ("");if _gffg !=nil {return nil ,ctx ,_gffg ;};_gffg =_dabg .addContentsByString (string (_ebae ));if _gffg !=nil {return nil ,ctx ,_gffg ;};};if _bbd ._gebg !=0{_fcdg :=_fdeb +_bbd ._aef ;_bed :=_bfbf ;if _bbd ._gdb ==CellBorderStyleDouble {_fcdg -=_aae ;
_cdd :=_dd .BasicLine {LineWidth :_bbd ._gebg ,Opacity :1.0,LineColor :_fbd (_bbd ._acg ),LineStyle :_bbd .LineStyle ,X1 :_fcdg +2*_aae ,Y1 :_bed +_adg /2+_ddff ,X2 :_fcdg +2*_aae ,Y2 :_bed -_adg /2-_edbf -_bbd ._efe };_aaea ,_ ,_bbf :=_cdd .Draw ("");
if _bbf !=nil {return nil ,ctx ,_bbf ;};_bbf =_dabg .addContentsByString (string (_aaea ));if _bbf !=nil {return nil ,ctx ,_bbf ;};};_cfb :=_dd .BasicLine {LineWidth :_bbd ._gebg ,Opacity :1.0,LineColor :_fbd (_bbd ._acg ),LineStyle :_bbd .LineStyle ,X1 :_fcdg ,Y1 :_bed +_adg /2+_ddff -(_fbe -_bbd ._ggc ),X2 :_fcdg ,Y2 :_bed -_adg /2-_edbf -_bbd ._efe +(_affc -_bbd ._bcd )};
_eece ,_ ,_eeea :=_cfb .Draw ("");if _eeea !=nil {return nil ,ctx ,_eeea ;};_eeea =_dabg .addContentsByString (string (_eece ));if _eeea !=nil {return nil ,ctx ,_eeea ;};};return []*Block {_dabg },ctx ,nil ;};

// SetHeight sets the height of the rectangle.
func (_ffdd *Rectangle )SetHeight (height float64 ){_ffdd ._ebef =height };

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_egda *Invoice )AddressStyle ()TextStyle {return _egda ._afeef };

// LevelOffset returns the amount of space an indentation level occupies.
func (_gcfb *TOCLine )LevelOffset ()float64 {return _gcfb ._gdcafd };

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_bd *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_db :=_ee .IdentityMatrix ();_deg ,_fg :=_bd .Width (),_bd .Height ();if _bd ._aa .IsRelative (){_db =_db .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_fg );}else {_db =_db .Translate (_bd ._fc ,ctx .PageHeight -_bd ._eec -_fg );
};_cad :=_fg ;if _bd ._aag !=0{_db =_db .Translate (_deg /2,_fg /2).Rotate (_bd ._aag *_fb .Pi /180.0).Translate (-_deg /2,-_fg /2);_ ,_cad =_bd .RotatedSize ();};if _bd ._aa .IsRelative (){ctx .Y +=_cad ;};_gad :=_ebf .NewContentCreator ();_gad .Add_cm (_db [0],_db [1],_db [3],_db [4],_db [6],_db [7]);
_abb :=_bd .duplicate ();_gd :=append (*_gad .Operations (),*_abb ._bac ...);_gd .WrapIfNeeded ();_abb ._bac =&_gd ;for _ ,_fcd :=range _bd ._geg {_afb ,_aagd :=_cd .GetArray (_fcd .Rect );if !_aagd ||_afb .Len ()!=4{_ef .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_fcd .Rect );
continue ;};_ag ,_cag :=_gf .NewPdfRectangle (*_afb );if _cag !=nil {_ef .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_cag );
continue ;};_ag .Transform (_db );_fcd .Rect =_ag .ToPdfObject ();};return []*Block {_abb },ctx ,nil ;};func (_bcbcg *templateProcessor )loadImageFromSrc (_baddf string )(*Image ,error ){if _baddf ==""{_ef .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_ecdff ;};_afccd :=_b .Split (_baddf ,"\u002c");for _ ,_gcfee :=range _afccd {_gcfee =_b .TrimSpace (_gcfee );if _gcfee ==""{continue ;};_adggd ,_cgfbd :=_bcbcg ._caaec .ImageMap [_gcfee ];if _cgfbd {return _dgf (_adggd );};if _ebgbe :=_bcbcg .parseAttrPropList (_gcfee );
len (_ebgbe )> 0{if _gfbd ,_becgg :=_ebgbe ["\u0070\u0061\u0074\u0068"];_becgg {if _begacg ,_ggbcd :=_ecabc (_gfbd );_ggbcd !=nil {_ef .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_gfbd ,_ggbcd );
}else {return _begacg ,nil ;};};};};_ef .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_baddf );return nil ,_ecdff ;};func (_eecgg *templateProcessor )parseCellVerticalAlignmentAttr (_bgaab ,_feegca string )CellVerticalAlignment {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bgaab ,_feegca );
_gcegda :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_feegca ];return _gcegda ;
};func (_abgb *TableCell )height (_cgba float64 )float64 {var _bcada float64 ;switch _gdggf :=_abgb ._ebagf .(type ){case *Paragraph :if _gdggf ._daabg {_gdggf .SetWidth (_cgba -_abgb ._aagdg -_gdggf ._ecdf .Left -_gdggf ._ecdf .Right );};_bcada =_gdggf .Height ()+_gdggf ._ecdf .Top +_gdggf ._ecdf .Bottom ;
if !_abgb ._gceg ._gdbd {_bcada +=(0.5*_gdggf ._fagc *_gdggf ._eaag );};case *StyledParagraph :if _gdggf ._ffeac {_gdggf .SetWidth (_cgba -_abgb ._aagdg -_gdggf ._dbge .Left -_gdggf ._dbge .Right );};_bcada =_gdggf .Height ()+_gdggf ._dbge .Top +_gdggf ._dbge .Bottom ;
if !_abgb ._gceg ._gdbd {_bcada +=(0.5*_gdggf .getTextHeight ());};case *Image :_gdggf .applyFitMode (_cgba -_abgb ._aagdg );_bcada =_gdggf .Height ()+_gdggf ._gdgbd .Top +_gdggf ._gdgbd .Bottom ;case *Table :_gdggf .updateRowHeights (_cgba -_abgb ._aagdg -_gdggf ._efdf .Left -_gdggf ._efdf .Right );
_bcada =_gdggf .Height ()+_gdggf ._efdf .Top +_gdggf ._efdf .Bottom ;case *List :_bcada =_gdggf .ctxHeight (_cgba -_abgb ._aagdg )+_gdggf ._caba .Top +_gdggf ._caba .Bottom ;case *Division :_bcada =_gdggf .ctxHeight (_cgba -_abgb ._aagdg )+_gdggf ._ffd .Top +_gdggf ._ffd .Bottom +_gdggf ._aeg .Top +_gdggf ._aeg .Bottom ;
case *Chart :_bcada =_gdggf .Height ()+_gdggf ._bade .Top +_gdggf ._bade .Bottom ;case *Rectangle :_gdggf .applyFitMode (_cgba -_abgb ._aagdg );_bcada =_gdggf .Height ()+_gdggf ._ccafa .Top +_gdggf ._ccafa .Bottom +_gdggf ._daegc ;case *Ellipse :_gdggf .applyFitMode (_cgba -_abgb ._aagdg );
_bcada =_gdggf .Height ()+_gdggf ._caace .Top +_gdggf ._caace .Bottom ;case *Line :_bcada =_gdggf .Height ()+_gdggf ._dfbfa .Top +_gdggf ._dfbfa .Bottom ;};return _bcada ;};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{taggedDrawable ;_agec []*listItem ;_caba Margins ;_eaeba TextChunk ;_eafe float64 ;_dbdb bool ;_fabbb Positioning ;_gcace TextStyle ;};

// GetStructureType returns the structure type of this drawable.
func (_cbfc *taggedDrawable )GetStructureType ()_gf .StructureType {return _cbfc ._febd .StructureType };func (_cacge *Ellipse )applyFitMode (_afee float64 ){_afee -=_cacge ._caace .Left +_cacge ._caace .Right ;switch _cacge ._ccgb {case FitModeFillWidth :_cacge .ScaleToWidth (_afee );
};};

// SetColorTop sets border color for top.
func (_aede *border )SetColorTop (col Color ){_aede ._ced =col };

// DrawHeader sets a function to draw a header on created output pages.
func (_fcfd *Creator )DrawHeader (drawHeaderFunc func (_edgg *Block ,_abcg HeaderFunctionArgs )){_fcfd ._ceed =drawHeaderFunc ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_cgad *GridCell )SetVerticalAlignment (valign CellVerticalAlignment ){_cgad ._efbg =valign };func _agde (_bbfa *Chapter ,_edcc *TOC ,_aee *_gf .Outline ,_bcgb string ,_edbe int ,_febg TextStyle )*Chapter {var _dff uint =1;if _bbfa !=nil {_dff =_bbfa ._abfc +1;
};_cce :=&Chapter {_abbd :_edbe ,_cede :_bcgb ,_dbf :true ,_gge :true ,_bad :_bbfa ,_fged :_edcc ,_ecd :_aee ,_ebea :[]Drawable {},_abfc :_dff };_gdd :=_bgdc (_febg );_fgaf :=_gdd .SetText (_cce .headingText ());_fgaf .Style =_febg ;_cce ._egge =_gdd ;
return _cce ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetSideBorderStyle sets the cell's side border style.
func (_gcbfe *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_gcbfe ._cdefc =style ;_gcbfe ._gebca =style ;_gcbfe ._ddcce =style ;_gcbfe ._efabe =style ;case CellBorderSideTop :_gcbfe ._cdefc =style ;
case CellBorderSideBottom :_gcbfe ._gebca =style ;case CellBorderSideLeft :_gcbfe ._ddcce =style ;case CellBorderSideRight :_gcbfe ._efabe =style ;};};

// FillColor returns the fill color of the ellipse.
func (_dcage *Ellipse )FillColor ()Color {return _dcage ._cefg };

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_ebeg *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ebeg ._caace .Left ,_ebeg ._caace .Right ,_ebeg ._caace .Top ,_ebeg ._caace .Bottom ;};func (_abbgef *templateProcessor )parseFloatAttr (_aaaeb ,_bbddg string )float64 {_ef .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_aaaeb ,_bbddg );
_gdfcd ,_ :=_ca .ParseFloat (_bbddg ,64);return _gdfcd ;};

// Crop crops the Image to the specified bounds.
func (_cfddc *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_gcdfcg ,_ceebe :=_cfddc ._addd .ToGoImage ();if _ceebe !=nil {_df .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_ceebe );
};var _ccafc _da .Image ;_beab :=_da .Rect (x0 ,y0 ,x1 ,y1 );if _cacgeg :=_beab .Intersect (_gcdfcg .Bounds ());!_beab .Empty (){_ffeab :=_da .NewRGBA (_da .Rect (0,0,_beab .Dx (),_beab .Dy ()));for _geag :=_cacgeg .Min .Y ;_geag < _cacgeg .Max .Y ;_geag ++{for _cfbff :=_cacgeg .Min .X ;
_cfbff < _cacgeg .Max .X ;_cfbff ++{_ffeab .Set (_cfbff -_cacgeg .Min .X ,_geag -_cacgeg .Min .Y ,_gcdfcg .At (_cfbff ,_geag ));};};_ccafc =_ffeab ;}else {_ccafc =&_da .RGBA {};};_agfc ,_ceebe :=_gf .ImageHandling .NewImageFromGoImage (_ccafc );if _ceebe !=nil {_df .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_ceebe );
};_fbdc :=float64 (_agfc .Width );_cbaf :=float64 (_agfc .Height );_cfddc ._addd =_agfc ;_cfddc ._bcbef =_fbdc ;_cfddc ._dccdg =_cbaf ;_cfddc ._dgega =_fbdc ;_cfddc ._dfbd =_cbaf ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_gefc *Division )Width ()float64 {return 0};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_bdfg *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_bdfg ._bffb =align ;};func _ggccf (_ebca map[string ]interface{},_gcbg ...interface{})(map[string ]interface{},error ){_cecdb :=len (_gcbg );if _cecdb %2!=0{return nil ,_cd .ErrRangeError ;
};for _bfdeg :=0;_bfdeg < _cecdb ;_bfdeg +=2{_dffb ,_dbdef :=_gcbg [_bfdeg ].(string );if !_dbdef {return nil ,_cd .ErrTypeError ;};_ebca [_dffb ]=_gcbg [_bfdeg +1];};return _ebca ,nil ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{taggedDrawable ;_cega *_dd .PolyBezierCurve ;_gbcea float64 ;_cbac float64 ;_gege Color ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_gabd *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _gabd ._bbcef ==nil {if _bbdc :=_gabd .makeXObject ();_bbdc !=nil {return nil ,ctx ,_bbdc ;};};var _cabdf []*Block ;_ccdfa :=ctx ;_gccf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _gabd ._cgaad .IsRelative (){_gabd .applyFitMode (ctx .Width );ctx .X +=_gabd ._gdgbd .Left ;ctx .Y +=_gabd ._gdgbd .Top ;ctx .Width -=_gabd ._gdgbd .Left +_gabd ._gdgbd .Right ;ctx .Height -=_gabd ._gdgbd .Top +_gabd ._gdgbd .Bottom ;if _gabd ._dfbd > ctx .Height {_cabdf =append (_cabdf ,_gccf );
_gccf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gdcd :=ctx ;_gdcd .Y =ctx .Margins .Top +_gabd ._gdgbd .Top ;_gdcd .X =ctx .Margins .Left +_gabd ._gdgbd .Left ;_gdcd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gabd ._gdgbd .Top -_gabd ._gdgbd .Bottom ;
_gdcd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gabd ._gdgbd .Left -_gabd ._gdgbd .Right ;ctx =_gdcd ;};}else {ctx .X =_gabd ._dgda ;ctx .Y =_gabd ._eaede ;};ctx ,_dgfa :=_cfed (_gccf ,_gabd ,ctx );if _dgfa !=nil {return nil ,ctx ,_dgfa ;
};_cabdf =append (_cabdf ,_gccf );if _gabd ._cgaad .IsAbsolute (){ctx =_ccdfa ;}else {ctx .X =_ccdfa .X ;ctx .Width =_ccdfa .Width ;ctx .Y +=_gabd ._gdgbd .Bottom ;};return _cabdf ,ctx ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_fbc *Block )AddAnnotation (annotation *_gf .PdfAnnotation ){for _ ,_fec :=range _fbc ._geg {if _fec ==annotation {return ;};};_fbc ._geg =append (_fbc ._geg ,annotation );};

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_ebgfc *PageBreak )SetStructPageNumber (pageNumber *int64 ){};

// Add adds a new line with the default style to the table of contents.
func (_ebedd *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_cebee :=_ebedd .AddLine (_ddecc (TextChunk {Text :number ,Style :_ebedd ._bgbaa },TextChunk {Text :title ,Style :_ebedd ._bbeae },TextChunk {Text :page ,Style :_ebedd ._gagad },level ,_ebedd ._aafde ));
if _cebee ==nil {return nil ;};_gdgab :=&_ebedd ._cdefd ;_cebee .SetMargins (_gdgab .Left ,_gdgab .Right ,_gdgab .Top ,_gdgab .Bottom );_cebee .SetLevelOffset (_ebedd ._dcae );_cebee .Separator .Text =_ebedd ._cfadf ;_cebee .Separator .Style =_ebedd ._cbdff ;
return _cebee ;};func (_ddbab *Paragraph )getMaxLineWidth ()float64 {if _ddbab ._bbbd ==nil ||(_ddbab ._bbbd !=nil &&len (_ddbab ._bbbd )==0){_ddbab .wrapText ();};var _fcca float64 ;for _ ,_dcgee :=range _ddbab ._bbbd {_ddddb :=_ddbab .getTextLineWidth (_dcgee );
if _ddddb > _fcca {_fcca =_ddddb ;};};return _fcca ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_dcga *Rectangle )Width ()float64 {return _dcga ._egdeb };type border struct{_ecfc float64 ;_agg float64 ;_aef float64 ;_efe float64 ;_gcd Color ;_ebcg Color ;_bag float64 ;_bfb Color ;_bcd float64 ;_acg Color ;_gebg float64 ;_ced Color ;_ggc float64 ;
LineStyle _dd .LineStyle ;_dab CellBorderStyle ;_gdb CellBorderStyle ;_aff CellBorderStyle ;_cbc CellBorderStyle ;_dbeg float64 ;};func _bgfe (_gefef *_gf .PdfRectangle ,_gbeae float64 )[4]_dd .Point {_fgaga :=_gbeae *_fb .Pi /180.0;_cebcf :=_gefef .Width ();
_aeea :=_gefef .Height ();_adfab :=_fb .Sin (_fgaga );_dagge :=_fb .Cos (_fgaga );_bebff :=[4]_dd .Point {{X :_eca .RoundFloat (_gefef .Llx ,3),Y :_eca .RoundFloat (_gefef .Lly ,3)},{X :_eca .RoundFloat (_gefef .Llx +_cebcf *_dagge ,3),Y :_eca .RoundFloat (_gefef .Lly +_cebcf *_adfab ,3)},{X :_eca .RoundFloat (_gefef .Llx +_cebcf *_dagge -_aeea *_adfab ,3),Y :_eca .RoundFloat (_gefef .Lly +_cebcf *_adfab +_aeea *_dagge ,3)},{X :_eca .RoundFloat (_gefef .Llx -_aeea *_adfab ,3),Y :_eca .RoundFloat (_gefef .Lly +_aeea *_dagge ,3)}};
return _bebff ;};

// SetBorderOpacity sets the border opacity.
func (_gaddg *CurvePolygon )SetBorderOpacity (opacity float64 ){_gaddg ._bdeb =opacity };

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_cb *Block )GenerateKDict ()(*_gf .KDict ,error ){return nil ,nil };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_caa *Block )ScaleToWidth (w float64 ){_bce :=w /_caa ._ddf ;_caa .Scale (_bce ,_bce )};func (_faeda *List )ctxHeight (_dfadf float64 )float64 {_dfadf -=_faeda ._eafe ;var _ceabf float64 ;for _ ,_ecda :=range _faeda ._agec {_ceabf +=_ecda .ctxHeight (_dfadf );
};return _ceabf ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_gf .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_gf .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_ecge *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_ecge ._bdfedc =valign };func (_ecgf *Invoice )GenerateKDict ()(*_gf .KDict ,error ){return nil ,nil };

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_aadc *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _geeef (x ,y ,width ,height );};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eebeg *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _eebeg ._bdgb [0],_eebeg ._bdgb [1]};

// IsAbsolute checks if the positioning is absolute.
func (_dabga Positioning )IsAbsolute ()bool {return _dabga ==PositionAbsolute };func (_fcbaad *templateProcessor )parseChapter (_fgdf *templateNode )(interface{},error ){_daaa :=_fcbaad .creator .NewChapter ;if _fgdf ._ccbde !=nil {if _efacg ,_abbegf :=_fgdf ._ccbde ._efefd .(*Chapter );
_abbegf {_daaa =_efacg .NewSubchapter ;};};_fagdaa :=_daaa ("");for _ ,_cabad :=range _fgdf ._fdbe .Attr {_fbgcc :=_cabad .Value ;switch _cdce :=_cabad .Name .Local ;_cdce {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_fagdaa .SetShowNumbering (_fcbaad .parseBoolAttr (_cdce ,_fbgcc ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_fagdaa .SetIncludeInTOC (_fcbaad .parseBoolAttr (_cdce ,_fbgcc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gacaf :=_fcbaad .parseMarginAttr (_cdce ,_fbgcc );_fagdaa .SetMargins (_gacaf .Left ,_gacaf .Right ,_gacaf .Top ,_gacaf .Bottom );
default:_fcbaad .nodeLogDebug (_fgdf ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cdce );
};};return _fagdaa ,nil ;};

// SetViewerPreferences sets the viewer preferences for the PDF document.
func (_cgd *Creator )SetViewerPreferences (viewerPreferences *_gf .ViewerPreferences ){_cgd ._bcdb =viewerPreferences ;};func (_gefda *Table )addRowTag ()*_gf .KDict {_gfbff :=_gf .NewKDictionary ();_gfbff .S =_cd .MakeName (string (_gf .StructureTypeTableRow ));
_gefda ._febd .ComponentKObj .AddKChild (_gfbff );return _gfbff ;};type templateTag struct{_cgdd map[string ]struct{};_dagcfa func (*templateProcessor ,*templateNode )(interface{},error );};

// SetBorderColor sets the cell's border color.
func (_fbagf *GridCell )SetBorderColor (col Color ){_fbagf ._fceb =col ;_fbagf ._ggbe =col ;_fbagf ._bdgae =col ;_fbagf ._eeff =col ;};func _gaadc (_eafeb *Block ,_egcae *Paragraph ,_fdac DrawContext )(DrawContext ,error ){_eedc :=1;_cagb :=_cd .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ca .Itoa (_eedc ));
for _eafeb ._ebe .HasFontByName (_cagb ){_eedc ++;_cagb =_cd .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ca .Itoa (_eedc ));};_gbcdb :=_eafeb ._ebe .SetFontByName (_cagb ,_egcae ._abbaf .ToPdfObject ());if _gbcdb !=nil {return _fdac ,_gbcdb ;};_egcae .wrapText ();
_bbba :=_ebf .NewContentCreator ();_bbba .Add_q ();_cbfee :=_eca .RoundDefault (_fdac .PageHeight -_fdac .Y -_egcae ._fagc *_egcae ._eaag );_bbba .Translate (_fdac .X ,_cbfee );if _egcae ._bafe !=0{_bbba .RotateDeg (_egcae ._bafe );};_ecfec :=_fbd (_egcae ._dbbg );
_gbcdb =_bdced (_eafeb ,_ecfec ,_egcae ._dbbg ,func ()Rectangle {return Rectangle {_acaf :_fdac .X ,_dgec :_cbfee ,_egdeb :_egcae .getMaxLineWidth ()/1000.0,_ebef :_egcae .Height ()};});if _gbcdb !=nil {return _fdac ,_gbcdb ;};_bbba .Add_BT ();_cacae :=map[string ]_cd .PdfObject {};
if _egcae ._febd !=nil {_cacae ["\u004d\u0043\u0049\u0044"]=_cd .MakeInteger (_egcae ._febd .Mcid );};if _egcae ._cfde !=""{_cacae ["\u004c\u0061\u006e\u0067"]=_cd .MakeString (_egcae ._cfde );};if len (_cacae )> 0{_bbba .Add_BDC (*_cd .MakeName (string (_egcae ._febd .StructureType )),_cacae );
};_bbba .SetNonStrokingColor (_ecfec ).Add_Tf (_cagb ,_egcae ._fagc ).Add_TL (_egcae ._fagc *_egcae ._eaag );for _aeaa ,_fgef :=range _egcae ._bbbd {if _aeaa !=0{_bbba .Add_Tstar ();};_dcced :=[]rune (_fgef );_fbaef :=0.0;_gaac :=0;for _abedf ,_dcfbf :=range _dcced {if _dcfbf ==' '{_gaac ++;
continue ;};if _dcfbf =='\u000A'{continue ;};_dbda ,_daebd :=_egcae ._abbaf .GetRuneMetrics (_dcfbf );if !_daebd {_ef .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_abedf ,_dcfbf ,_dcfbf ,_egcae ._abbaf .BaseFont (),_egcae ._abbaf .Subtype ());
return _fdac ,_g .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_fbaef +=_egcae ._fagc *_dbda .Wx ;};var _fecd []_cd .PdfObject ;_fddc ,_begd :=_egcae ._abbaf .GetRuneMetrics (' ');
if !_begd {return _fdac ,_g .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_badf :=_fddc .Wx ;switch _egcae ._abea {case TextAlignmentJustify :if _gaac > 0&&_aeaa < len (_egcae ._bbbd )-1{_badf =(_egcae ._afeca *1000.0-_fbaef )/float64 (_gaac )/_egcae ._fagc ;
};case TextAlignmentCenter :_bceea :=_fbaef +float64 (_gaac )*_badf *_egcae ._fagc ;_ceec :=_eca .RoundDefault ((_egcae ._afeca *1000.0-_bceea )/2/_egcae ._fagc );_fecd =append (_fecd ,_cd .MakeFloat (-_ceec ));case TextAlignmentRight :_feegf :=_fbaef +float64 (_gaac )*_badf *_egcae ._fagc ;
_dgaed :=_eca .RoundDefault ((_egcae ._afeca *1000.0-_feegf )/_egcae ._fagc );_fecd =append (_fecd ,_cd .MakeFloat (-_dgaed ));};_bedg :=_egcae ._abbaf .Encoder ();var _bgggg []byte ;for _ ,_aage :=range _dcced {if _aage =='\u000A'{continue ;};if _aage ==' '{if len (_bgggg )> 0{_fecd =append (_fecd ,_cd .MakeStringFromBytes (_bgggg ));
_bgggg =nil ;};_fecd =append (_fecd ,_cd .MakeFloat (-_badf ));}else {if _ ,_febba :=_bedg .RuneToCharcode (_aage );!_febba {_gbcdb =UnsupportedRuneError {Message :_e .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_aage ,_aage ),Rune :_aage };
_fdac ._afbfc =append (_fdac ._afbfc ,_gbcdb );_ef .Log .Debug (_gbcdb .Error ());if _fdac ._deaaa <=0{continue ;};_aage =_fdac ._deaaa ;};_bgggg =append (_bgggg ,_bedg .Encode (string (_aage ))...);};};if len (_bgggg )> 0{_fecd =append (_fecd ,_cd .MakeStringFromBytes (_bgggg ));
};_bbba .Add_TJ (_fecd ...);};if len (_cacae )> 0{_bbba .Add_EMC ();};_bbba .Add_ET ();_bbba .Add_Q ();_dfbe :=_bbba .Operations ();_dfbe .WrapIfNeeded ();_eafeb .addWrappedContents (_dfbe );if _egcae ._baea .IsRelative (){_ecbe :=_egcae .Height ();_fdac .Y =_eca .RoundDefault (_fdac .Y +_ecbe );
_fdac .Height =_eca .RoundDefault (_fdac .Height -_ecbe );if _fdac .Inline {_fdac .X =_eca .RoundDefault (_fdac .X +_egcae .Width ()+_egcae ._ecdf .Right );};};return _fdac ,nil ;};

// SetStyle sets the style of the line (solid or dashed).
func (_caafg *Line )SetStyle (style _dd .LineStyle ){_caafg ._gcgff =style };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_gdgdb *TOC )SetLineTitleStyle (style TextStyle ){_gdgdb ._bbeae =style };

// AddColorStop add color stop info for rendering gradient color.
func (_abbge *RadialShading )AddColorStop (color Color ,point float64 ){_abbge ._acad .AddColorStop (color ,point );};

// SetOpacity sets the cell's opacity in the range 0-1.
func (_dgdg *GridCell )SetOpacity (opacity float64 ){_dgdg ._ccfb =opacity };

// GetDropCapsOptions returns the drop caps options set on the paragraph, if any.
func (_bgae *StyledParagraph )GetDropCapsOptions ()*DropCapsOptions {return _bgae ._ceaf };

// TagComponents instructs Creator whether or not to tag any component added after calling this function.
func (_dbd *Creator )TagComponents (enableTagging bool ){_dbd ._bcgd =enableTagging ;if enableTagging {_dbd ._fae =_gf .NewKDictionary ();_dbd ._fae .S =_cd .MakeName (string (_gf .StructureTypeDocument ));_dbd ._fae .ID =_cd .MakeString (_dbd ._fae .GenerateRandomID ());
if _dbd ._gec ==nil {_dbd ._gec =_gf .NewStructTreeRoot ();};_dbd ._gec .AddKDict (_dbd ._fae );};};

// GetIndent get the cell's left indent.
func (_gbfdb *GridCell )GetIndent ()float64 {return _gbfdb ._bcbg };

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{taggedDrawable ;_aagdf *GraphicSVGElement ;_daeg Positioning ;_dffd float64 ;_bcea float64 ;_bbcd Margins ;};

// ParseFromSVGString creates a GraphicSVG instance from string SVG.
func ParseFromSVGString (svgStr string )(*GraphicSVGElement ,error ){return ParseFromSVGStream (_b .NewReader (svgStr ));};

// GraphicSVGStyle represents style attributes for `GraphicSVG`.
type GraphicSVGStyle struct{FillColor string ;StrokeColor string ;StrokeWidth float64 ;FillOpacity float64 ;};func _gfcf (_bbgd _ec .StartElement )*GraphicSVGElement {_efaf :=&GraphicSVGElement {};_bbfc :=make (map[string ]string );for _ ,_fdaff :=range _bbgd .Attr {_bbfc [_fdaff .Name .Local ]=_fdaff .Value ;
};_efaf .Name =_bbgd .Name .Local ;_efaf .Attributes =_bbfc ;_efaf ._bcae =1;if _efaf .Name =="\u0073\u0076\u0067"{_fdee ,_bcbc :=_adgac (_bbfc ["\u0076i\u0065\u0077\u0042\u006f\u0078"]);if _bcbc !=nil {_ef .Log .Debug ("\u0055\u006ea\u0062\u006c\u0065\u0020t\u006f\u0020p\u0061\u0072\u0073\u0065\u0020\u0076\u0069\u0065w\u0042\u006f\u0078\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0025\u0076",_bcbc );
return nil ;};if len (_fdee )>=4{_efaf .ViewBox .X =_fdee [0];_efaf .ViewBox .Y =_fdee [1];_efaf .ViewBox .W =_fdee [2];_efaf .ViewBox .H =_fdee [3];};_efaf .Width =_efaf .ViewBox .W ;_efaf .Height =_efaf .ViewBox .H ;if _efdb ,_deee :=_bbfc ["\u0077\u0069\u0064t\u0068"];
_deee {if _b .HasSuffix (_efdb ,"\u0025"){_gcbc ,_dddb :=_ca .ParseFloat (_b .TrimSuffix (_efdb ,"\u0025"),64);if _dddb !=nil {_ef .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_dddb );
return nil ;};_efaf .Width =_gcbc *_efaf .ViewBox .W ;}else {_ebggb ,_dacad :=_fgde (_efdb ,64);if _dacad !=nil {_ef .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_dacad );
return nil ;};_efaf .Width =_ebggb ;if len (_fdee )< 4{_efaf .ViewBox .W =_ebggb ;};};};if _cfgeb ,_aebdc :=_bbfc ["\u0068\u0065\u0069\u0067\u0068\u0074"];_aebdc {if _b .HasSuffix (_cfgeb ,"\u0025"){_egegec ,_cfcb :=_ca .ParseFloat (_b .TrimSuffix (_cfgeb ,"\u0025"),64);
if _cfcb !=nil {_ef .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_cfcb );return nil ;};_efaf .Height =_egegec *_efaf .ViewBox .H ;
}else {_efaa ,_dedbb :=_fgde (_cfgeb ,64);if _dedbb !=nil {_ef .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_dedbb );return nil ;
};_efaf .Height =_efaa ;if len (_fdee )< 4{_efaf .ViewBox .H =_efaa ;};};};if _efaf .Width > 0&&_efaf .Height > 0{_efaf ._bcae =_efaf .Width /_efaf .ViewBox .W ;};};return _efaf ;};

// SetHeight sets the height of the ellipse.
func (_dgbf *Ellipse )SetHeight (height float64 ){_dgbf ._feegb =height };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_fdce *LinearShading )AddPatternResource (block *Block )(_cdgc _cd .PdfObjectName ,_bdcc error ){_cdag :=1;_bcaa :=_cd .PdfObjectName ("\u0050"+_ca .Itoa (_cdag ));for block ._ebe .HasPatternByName (_bcaa ){_cdag ++;_bcaa =_cd .PdfObjectName ("\u0050"+_ca .Itoa (_cdag ));
};if _fdgcg :=block ._ebe .SetPatternByName (_bcaa ,_fdce .ToPdfShadingPattern ().ToPdfObject ());_fdgcg !=nil {return "",_fdgcg ;};return _bcaa ,nil ;};func (_ccabe *templateProcessor )parseFloatArray (_bfff ,_fgeef string )[]float64 {_ef .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bfff ,_fgeef );
_aced :=_b .Fields (_fgeef );_cgdbc :=make ([]float64 ,0,len (_aced ));for _ ,_ccfbd :=range _aced {_dgeab ,_ :=_ca .ParseFloat (_ccfbd ,64);_cgdbc =append (_cgdbc ,_dgeab );};return _cgdbc ;};

// SetMargins sets the margins of the paragraph.
func (_baad *List )SetMargins (left ,right ,top ,bottom float64 ){_baad ._caba .Left =left ;_baad ._caba .Right =right ;_baad ._caba .Top =top ;_baad ._caba .Bottom =bottom ;};func (_cegab *GraphicSVGElement )drawLine (_bdbb *_ebf .ContentCreator ,_fedb *_gf .PdfPageResources ){_bdbb .Add_q ();
_cegab .Style .toContentStream (_bdbb ,_fedb ,_cegab );_accb ,_badgfg :=_fgde (_cegab .Attributes ["\u0078\u0031"],64);if _badgfg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badgfg .Error ());
};_dcdfd ,_badgfg :=_fgde (_cegab .Attributes ["\u0079\u0031"],64);if _badgfg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badgfg .Error ());
};_adegc ,_badgfg :=_fgde (_cegab .Attributes ["\u0078\u0032"],64);if _badgfg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badgfg .Error ());
};_eebcg ,_badgfg :=_fgde (_cegab .Attributes ["\u0079\u0032"],64);if _badgfg !=nil {_ef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badgfg .Error ());
};_bdbb .Add_m (_accb *_cegab ._bcae ,_dcdfd *_cegab ._bcae );_bdbb .Add_l (_adegc *_cegab ._bcae ,_eebcg *_cegab ._bcae );_cegab .Style .fillStroke (_bdbb );_bdbb .Add_h ();_bdbb .Add_Q ();};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_ecfgd *Table )EnableRowWrap (enable bool ){_ecfgd ._afeec =enable };

// DashPattern returns the dash pattern of the line.
func (_gbab *Line )DashPattern ()(_egggc []int64 ,_bbff int64 ){return _gbab ._gddg ,_gbab ._edaa };

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_gcfae *GraphicSVG )SetPos (x ,y float64 ){_gcfae ._daeg =PositionAbsolute ;_gcfae ._dffd =x ;_gcfae ._bcea =y ;};

// SetBorderColor sets the border color of the ellipse.
func (_fgcf *Ellipse )SetBorderColor (col Color ){_fgcf ._cgffb =col };

// AppendColumn appends a column to the line items table.
func (_faff *Invoice )AppendColumn (description string )*InvoiceCell {_ecg :=_faff .NewColumn (description );_faff ._ccgf =append (_faff ._ccgf ,_ecg );return _ecg ;};

// Width returns the current page width.
func (_feagg *Creator )Width ()float64 {return _feagg ._gaa };func (_bdadca *templateProcessor )parseHorizontalAlignmentAttr (_eaaec ,_aadef string )HorizontalAlignment {_ef .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_eaaec ,_aadef );
_ffbfg :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_aadef ];return _ffbfg ;};

// NewCell makes a new single cell and inserts it into the row at the current position.
func (_bgbf *GridRow )NewCell ()(*GridCell ,error ){return _bgbf .NewMultiCell (1,1)};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_cfgdg *TOC )SetLineNumberStyle (style TextStyle ){_cfgdg ._bgbaa =style };func (_bbgccc *TableCell )cloneProps (_acaa VectorDrawable )*TableCell {_gadaf :=*_bbgccc ;_gadaf ._ebagf =_acaa ;return &_gadaf ;};func _dffad (_eeefe ,_acbac string )*_gf .PdfAnnotation {_bbadf :=_gf .NewPdfAnnotationLink ();
_fbda :=_gf .NewBorderStyle ();_fbda .SetBorderWidth (0);_bbadf .BS =_fbda .ToPdfObject ();_bggf :=_gf .NewPdfActionURI ();_bggf .URI =_cd .MakeString (_eeefe );_bbadf .SetAction (_bggf .PdfAction );if _acbac !=""{_bbadf .Contents =_cd .MakeString (_acbac );
};return _bbadf .PdfAnnotation ;};func (_egbaaa *StyledParagraph )wrapText ()error {return _egbaaa .wrapChunks (true )};func (_eadcg *templateProcessor )parseFontAttr (_agbfcf ,_fabg string )*_gf .PdfFont {_ef .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_agbfcf ,_fabg );
_aefd :=_eadcg .creator ._dfac ;if _fabg ==""{return _aefd ;};_eaagg :=_b .Split (_fabg ,"\u002c");for _ ,_daffa :=range _eaagg {_daffa =_b .TrimSpace (_daffa );if _daffa ==""{continue ;};_efcff ,_fffeb :=_eadcg ._caaec .FontMap [_fabg ];if _fffeb {return _efcff ;
};_eeacee ,_fffeb :=map[string ]_gf .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_gf .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_gf .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_gf .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_gf .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_gf .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_gf .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_gf .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_gf .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_gf .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_gf .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_gf .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_gf .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_gf .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_gf .TimesBoldItalicName }[_fabg ];
if _fffeb {if _gbaaf ,_cfcc :=_gf .NewStandard14Font (_eeacee );_cfcc ==nil {return _gbaaf ;};};if _fccfg :=_eadcg .parseAttrPropList (_daffa );len (_fccfg )> 0{if _gddaa ,_bccg :=_fccfg ["\u0070\u0061\u0074\u0068"];_bccg {_cecf :=_gf .NewPdfFontFromTTFFile ;
if _feca ,_bbfacd :=_fccfg ["\u0074\u0079\u0070\u0065"];_bbfacd &&_feca =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_cecf =_gf .NewCompositePdfFontFromTTFFile ;};if _addgf ,_feeec :=_cecf (_gddaa );_feeec !=nil {_ef .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_gddaa ,_feeec );
}else {return _addgf ;};};};};return _aefd ;};

// SetBackground sets the background properties of the component.
func (_ddfd *Division )SetBackground (background *Background ){_ddfd ._ecfg =background };

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_baded *Invoice )InfoLines ()[][2]*InvoiceCell {_dfaae :=[][2]*InvoiceCell {_baded ._gfcd ,_baded ._bdgb ,_baded ._ccaab };return append (_dfaae ,_baded ._ceacc ...);};

// The Image type is used to draw an image onto PDF.
type Image struct{taggedDrawable ;_bbcef *_gf .XObjectImage ;_addd *_gf .Image ;_bgcb string ;_ggedf float64 ;_dgega ,_dfbd float64 ;_bcbef ,_dccdg float64 ;_cgaad Positioning ;_dagce HorizontalAlignment ;_dgda float64 ;_eaede float64 ;_bdbfb float64 ;
_gdgbd Margins ;_dagf ,_cfce float64 ;_dbfa _cd .StreamEncoder ;_aeeb FitMode ;_cbgdb bool ;_febda *_gf .Artifact ;};func _fedea (_cbfg string )(float64 ,float64 ,float64 ){_gbccb :=_b .TrimPrefix (_cbfg ,"\u0072\u0067\u0062\u0028");_gbccb =_b .TrimSuffix (_gbccb ,"\u0029");
_bebaf :=_b .Split (_gbccb ,"\u002c");if len (_bebaf )!=3{_ef .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_cbfg );
return 0,0,0;};var _bfggf ,_fdfbf ,_gdcce float64 ;_bfggf ,_efede :=_dfgc (_bebaf [0]);if _efede !=nil {_ef .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_cbfg );
return 0,0,0;};_fdfbf ,_efede =_dfgc (_bebaf [1]);if _efede !=nil {_ef .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_cbfg );
return 0,0,0;};_gdcce ,_efede =_dfgc (_bebaf [2]);if _efede !=nil {_ef .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_cbfg );
return 0,0,0;};_adggc :=_bfggf /255.0;_edgga :=_fdfbf /255.0;_ggbff :=_gdcce /255.0;return _adggc ,_edgga ,_ggbff ;};

// SetBorderOpacity sets the border opacity.
func (_faeb *Polygon )SetBorderOpacity (opacity float64 ){_faeb ._fafbf =opacity };