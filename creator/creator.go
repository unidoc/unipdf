//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_aa "bytes";_ef "errors";_cg "fmt";_aae "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/contentstream";_de "github.com/unidoc/unipdf/v3/contentstream/draw";_fef "github.com/unidoc/unipdf/v3/core";_ca "github.com/unidoc/unipdf/v3/model";_aag "image";_g "io";_f "math";_c "os";_a "sort";_fe "strconv";_ag "strings";_d "unicode";);

// SetFillColor sets background color for border.
func (_gcg *border )SetFillColor (col Color ){_gcg ._abae =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_aefca *TableCell )SetContent (vd VectorDrawable )error {switch _cdeg :=vd .(type ){case *Paragraph :if _cdeg ._afga {_cdeg ._fcff =true ;};_aefca ._efgea =vd ;case *StyledParagraph :if _cdeg ._afea {_cdeg ._bgf =true ;};_aefca ._efgea =vd ;case *Image :_aefca ._efgea =vd ;case *Table :_aefca ._efgea =vd ;case *List :_aefca ._efgea =vd ;case *Division :_aefca ._efgea =vd ;default:_aae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _fef .ErrTypeError ;};return nil ;};

// Scale scales Image by a constant factor, both width and height.
func (_afb *Image )Scale (xFactor ,yFactor float64 ){_afb ._bfaf =xFactor *_afb ._bfaf ;_afb ._ccdb =yFactor *_afb ._ccdb ;};

// Add adds a new line with the default style to the table of contents.
func (_babb *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_bffb :=_babb .AddLine (_dfbc (TextChunk {Text :number ,Style :_babb ._ffbg },TextChunk {Text :title ,Style :_babb ._dddg },TextChunk {Text :page ,Style :_babb ._bebc },level ,_babb ._acfa ));if _bffb ==nil {return nil ;};_deeb :=&_babb ._aeged ;_bffb .SetMargins (_deeb ._feag ,_deeb ._ddbb ,_deeb ._ecfa ,_deeb ._fbbc );_bffb .SetLevelOffset (_babb ._gefgb );_bffb .Separator .Text =_babb ._gbed ;_bffb .Separator .Style =_babb ._ggggd ;return _bffb ;};func (_cgbd *Creator )newPage ()*_ca .PdfPage {_fbbg :=_ca .NewPdfPage ();_facc :=_cgbd ._cdae [0];_fcf :=_cgbd ._cdae [1];_fed :=_ca .PdfRectangle {Llx :0,Lly :0,Urx :_facc ,Ury :_fcf };_fbbg .MediaBox =&_fed ;_cgbd ._dadc =_facc ;_cgbd ._fgc =_fcf ;_cgbd .initContext ();return _fbbg ;};func (_ceeb *StyledParagraph )getTextHeight ()float64 {var _faed float64 ;for _ ,_faec :=range _ceeb ._gdec {_gggg :=_faec .Style .FontSize *_ceeb ._bgea ;if _gggg > _faed {_faed =_gggg ;};};return _faed ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_bage *Table )SetPos (x ,y float64 ){_bage ._gfecga =_cef ;_bage ._gebga =x ;_bage ._fbdad =y };

// SetBorderColor sets the cell's border color.
func (_cfba *TableCell )SetBorderColor (col Color ){_cfba ._bdfe =_ca .NewPdfColorDeviceRGB (col .ToRGB ());_cfba ._agfb =_ca .NewPdfColorDeviceRGB (col .ToRGB ());_cfba ._aaec =_ca .NewPdfColorDeviceRGB (col .ToRGB ());_cfba ._acba =_ca .NewPdfColorDeviceRGB (col .ToRGB ());};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_afeff *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_dbaa float64 ;_bdfb uint ;_gefc float64 ;_fgff positioning ;_dcfc float64 ;_fbdgad float64 ;_gaed int64 ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_gcaae *StyledParagraph )SetText (text string )*TextChunk {_gcaae .Reset ();return _gcaae .Append (text );};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_cbfb *Invoice )Terms ()(string ,string ){return _cbfb ._feae [0],_cbfb ._feae [1]};

// NewInvoice returns an instance of an empty invoice.
func (_cbe *Creator )NewInvoice ()*Invoice {_ebdf :=_cbe .NewTextStyle ();_ebdf .Font =_cbe ._ddba ;return _gebd (_cbe .NewTextStyle (),_ebdf );};

// SetBorder sets the cell's border style.
func (_efcce *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_efcce ._dfgd =CellBorderStyleSingle ;_efcce ._gaeb =width ;_efcce ._baba =CellBorderStyleSingle ;_efcce ._aeed =width ;_efcce ._faddb =CellBorderStyleSingle ;_efcce ._ddcbe =width ;_efcce ._egfa =CellBorderStyleSingle ;_efcce ._gddd =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_efcce ._dfgd =CellBorderStyleDouble ;_efcce ._gaeb =width ;_efcce ._baba =CellBorderStyleDouble ;_efcce ._aeed =width ;_efcce ._faddb =CellBorderStyleDouble ;_efcce ._ddcbe =width ;_efcce ._egfa =CellBorderStyleDouble ;_efcce ._gddd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_efcce ._dfgd =style ;_efcce ._gaeb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_efcce ._baba =style ;_efcce ._aeed =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_efcce ._faddb =style ;_efcce ._ddcbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_efcce ._egfa =style ;_efcce ._gddd =width ;};};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// NewDivision returns a new Division container component.
func (_agae *Creator )NewDivision ()*Division {return _cga ()};func (_aad *Block )mergeBlocks (_dcb *Block )error {_ece :=_ecb (_aad ._agg ,_aad ._aac ,_dcb ._agg ,_dcb ._aac );if _ece !=nil {return _ece ;};for _ ,_fdf :=range _dcb ._add {_aad .AddAnnotation (_fdf );};return nil ;};type positioning int ;

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_cadc DrawContext )([]*Block ,DrawContext ,error );};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_acfe *StyledParagraph )SetWidth (width float64 ){_acfe ._fbbga =width ;_acfe .wrapText ()};

// SetFontSize sets the font size in document units (points).
func (_gfbf *Paragraph )SetFontSize (fontSize float64 ){_gfbf ._fccdc =fontSize };

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_abad *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _abad ._ecfce [0],_abad ._ecfce [1]};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_egda *Creator )NewStyledParagraph ()*StyledParagraph {return _bged (_egda .NewTextStyle ())};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_cbcg []VectorDrawable ;_bbb positioning ;_bfdf margins ;_edbc bool ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_fafb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_fafb ._fcgg =address };func (_defbg *Invoice )drawAddress (_dggf *InvoiceAddress )[]*StyledParagraph {var _dfde []*StyledParagraph ;if _dggf .Heading !=""{_abdbe :=_bged (_defbg ._dfbf );_abdbe .SetMargins (0,0,0,7);_abdbe .Append (_dggf .Heading );_dfde =append (_dfde ,_abdbe );};_aafb :=_bged (_defbg ._ggab );_aafb .SetLineHeight (1.2);_bbbg :=_dggf .Separator ;if _bbbg ==""{_bbbg =_defbg ._edca ;};_dbcab :=_dggf .City ;if _dggf .State !=""{if _dbcab !=""{_dbcab +=_bbbg ;};_dbcab +=_dggf .State ;};if _dggf .Zip !=""{if _dbcab !=""{_dbcab +=_bbbg ;};_dbcab +=_dggf .Zip ;};if _dggf .Name !=""{_aafb .Append (_dggf .Name +"\u000a");};if _dggf .Street !=""{_aafb .Append (_dggf .Street +"\u000a");};if _dggf .Street2 !=""{_aafb .Append (_dggf .Street2 +"\u000a");};if _dbcab !=""{_aafb .Append (_dbcab +"\u000a");};if _dggf .Country !=""{_aafb .Append (_dggf .Country +"\u000a");};_gfebg :=_bged (_defbg ._ggab );_gfebg .SetLineHeight (1.2);_gfebg .SetMargins (0,0,7,0);if _dggf .Phone !=""{_gfebg .Append (_cg .Sprintf ("\u0050\u0068\u006f\u006e\u0065\u003a\u0020\u0025\u0073\u000a",_dggf .Phone ));};if _dggf .Email !=""{_gfebg .Append (_cg .Sprintf ("\u0045\u006d\u0061\u0069\u006c\u003a\u0020\u0025\u0073\u000a",_dggf .Email ));};_dfde =append (_dfde ,_aafb ,_gfebg );return _dfde ;};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;};func _cgca (_cca ,_cdfge ,_ddf ,_ggbdg ,_cbcb ,_cccd float64 )*Curve {_agge :=&Curve {};_agge ._dddf =_cca ;_agge ._bac =_cdfge ;_agge ._defb =_ddf ;_agge ._cag =_ggbdg ;_agge ._fag =_cbcb ;_agge ._dcfe =_cccd ;_agge ._cdcg =_ca .NewPdfColorDeviceRGB (0,0,0);_agge ._bdcf =1.0;return _agge ;};func _fcgb (_cbb *Chapter ,_bgce *TOC ,_eec *_ca .Outline ,_eag string ,_ccf int ,_fgea TextStyle )*Chapter {var _fdcc uint =1;if _cbb !=nil {_fdcc =_cbb ._dgc +1;};_dcc :=&Chapter {_edf :_ccf ,_fac :_eag ,_abc :true ,_gde :true ,_gee :_cbb ,_fdag :_bgce ,_cddfb :_eec ,_deef :[]Drawable {},_dgc :_fdcc };_bbag :=_afbf (_dcc .headingText (),_fgea );_bbag .SetFont (_fgea .Font );_bbag .SetFontSize (_fgea .FontSize );_dcc ._gadf =_bbag ;return _dcc ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_bggc *Creator )EnableFontSubsetting (font *_ca .PdfFont ){_bggc ._aefa =append (_bggc ._aefa ,font );};

// SetMargins sets the Paragraph's margins.
func (_egag *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_egag ._bebaf ._feag =left ;_egag ._bebaf ._ddbb =right ;_egag ._bebaf ._ecfa =top ;_egag ._bebaf ._fbbc =bottom ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_gaca *Invoice )SetAddressHeadingStyle (style TextStyle ){_gaca ._dfbf =style };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_beac *TOC )SetHeading (text string ,style TextStyle ){_ceaae :=_beac .Heading ();_ceaae .Reset ();_gceg :=_ceaae .Append (text );_gceg .Style =style ;};

// SetColorTop sets border color for top.
func (_bece *border )SetColorTop (col Color ){_bece ._dbf =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_feegf *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bdcb []*Block ;_aeg :=ctx ;if _feegf ._bbb .isRelative (){ctx .X +=_feegf ._bfdf ._feag ;ctx .Y +=_feegf ._bfdf ._ecfa ;ctx .Width -=_feegf ._bfdf ._feag +_feegf ._bfdf ._ddbb ;ctx .Height -=_feegf ._bfdf ._ecfa +_feegf ._bfdf ._fbbc ;};ctx .Inline =_feegf ._edbc ;_bbab :=ctx ;_ggaf :=ctx ;var _gae float64 ;for _ ,_dfcb :=range _feegf ._cbcg {if ctx .Inline {if (ctx .X -_bbab .X )+_dfcb .Width ()<=ctx .Width {ctx .Y =_ggaf .Y ;ctx .Height =_ggaf .Height ;}else {ctx .X =_bbab .X ;ctx .Width =_bbab .Width ;_ggaf .Y +=_gae ;_ggaf .Height -=_gae ;_gae =0;};};_fefe ,_ecg ,_dfab :=_dfcb .GeneratePageBlocks (ctx );if _dfab !=nil {_aae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_dfab );return nil ,ctx ,_dfab ;};if len (_fefe )< 1{continue ;};if len (_bdcb )> 0{_bdcb [len (_bdcb )-1].mergeBlocks (_fefe [0]);_bdcb =append (_bdcb ,_fefe [1:]...);}else {_bdcb =append (_bdcb ,_fefe [0:]...);};if ctx .Inline {if ctx .Page !=_ecg .Page {_bbab .Y =ctx .Margins ._ecfa ;_bbab .Height =ctx .PageHeight -ctx .Margins ._ecfa ;_ggaf .Y =_bbab .Y ;_ggaf .Height =_bbab .Height ;_gae =_ecg .Height -_bbab .Height ;}else {if _aegg :=ctx .Height -_ecg .Height ;_aegg > _gae {_gae =_aegg ;};};}else {_ecg .X =ctx .X ;};ctx =_ecg ;};ctx .Inline =_aeg .Inline ;if _feegf ._bbb .isRelative (){ctx .X =_aeg .X ;};if _feegf ._bbb .isAbsolute (){return _bdcb ,_aeg ,nil ;};return _bdcb ,ctx ,nil ;};

// SetHeight sets the Image's document height to specified h.
func (_gcga *Image )SetHeight (h float64 ){_gcga ._ccdb =h };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_cge *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _fecc (x1 ,y1 ,x2 ,y2 )};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_agfe *Invoice )SetAddressStyle (style TextStyle ){_agfe ._ggab =style };

// SetPos sets absolute positioning with specified coordinates.
func (_ged *StyledParagraph )SetPos (x ,y float64 ){_ged ._fcee =_cef ;_ged ._cfge =x ;_ged ._gfee =y };func (_eaa *Creator )setActivePage (_fgf *_ca .PdfPage ){_eaa ._ffa =_fgf };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_dfdf *Creator )RotateDeg (angleDeg int64 )error {_agb :=_dfdf .getActivePage ();if _agb ==nil {_aae .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _ef .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_aae .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _ef .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _ecec int64 ;if _agb .Rotate !=nil {_ecec =*(_agb .Rotate );};_ecec +=angleDeg ;_agb .Rotate =&_ecec ;return nil ;};func _dcfa (_cfff *_ca .Image )(*Image ,error ){_ebbbe :=float64 (_cfff .Width );_fbbf :=float64 (_cfff .Height );return &Image {_fedfg :_cfff ,_aabb :_ebbbe ,_cecf :_fbbf ,_bfaf :_ebbbe ,_ccdb :_fbbf ,_fcfe :0,_bga :1.0,_egdc :_dbff },nil ;};

// SkipOver skips over a specified number of rows and cols.
func (_gcag *Table )SkipOver (rows ,cols int ){_gfecgd :=rows *_gcag ._caef +cols -1;if _gfecgd < 0{_aae .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_gcag ._fdgcg +=_gfecgd ;};

// SetBackgroundColor sets the cell's background color.
func (_edfb *TableCell )SetBackgroundColor (col Color ){_edfb ._fffb =_ca .NewPdfColorDeviceRGB (col .ToRGB ());};func (_gage *Invoice )newCell (_dbfg string ,_eebe InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_eebe ,_dbfg };};

// BuyerAddress returns the buyer address used in the invoice template.
func (_geaa *Invoice )BuyerAddress ()*InvoiceAddress {return _geaa ._fcgg };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_fcfg *TOCLine )SetLevelOffset (levelOffset float64 ){_fcfg ._gefc =levelOffset ;_fcfg ._afeff ._bebaf ._feag =_fcfg ._dbaa +float64 (_fcfg ._bdfb -1)*_fcfg ._gefc ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetBorderColor sets the border color.
func (_cdac *Ellipse )SetBorderColor (col Color ){_cdac ._efeb =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetIndent sets the left offset of the list when nested into another list.
func (_gbca *List )SetIndent (indent float64 ){_gbca ._bdea =indent ;_gbca ._bbbc =false };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_dbeg *Image )SetEncoder (encoder _fef .StreamEncoder ){_dbeg ._fded =encoder };var PPI float64 =72;var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_agcc *TOC )SetLineStyle (style TextStyle ){_agcc .SetLineNumberStyle (style );_agcc .SetLineTitleStyle (style );_agcc .SetLineSeparatorStyle (style );_agcc .SetLinePageStyle (style );};

// SellerAddress returns the seller address used in the invoice template.
func (_ddbaf *Invoice )SellerAddress ()*InvoiceAddress {return _ddbaf ._cadff };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fedcb *TOC )SetLineSeparator (separator string ){_fedcb ._gbed =separator };func _gbae (_ebbd _aag .Image )(*Image ,error ){_ebe ,_dbfe :=_ca .ImageHandling .NewImageFromGoImage (_ebbd );if _dbfe !=nil {return nil ,_dbfe ;};return _dcfa (_ebe );};

// SetBorderWidth sets the border width.
func (_fdaba *Rectangle )SetBorderWidth (bw float64 ){_fdaba ._baca =bw };func (_eagd *Image )makeXObject ()error {_ccea :=_eagd ._fded ;if _ccea ==nil {_ccea =_fef .NewFlateEncoder ();};_fdgb ,_aede :=_ca .NewXObjectImageFromImage (_eagd ._fedfg ,nil ,_ccea );if _aede !=nil {_aae .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_aede );return _aede ;};_eagd ._gge =_fdgb ;return nil ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_aecc int ;_caef int ;_fdgcg int ;_gffaf []float64 ;_febf []float64 ;_dcfg float64 ;_gaafc []*TableCell ;_gfecga positioning ;_gebga ,_fbdad float64 ;_gafag margins ;_eece bool ;_eedef int ;_bceb int ;};func (_efdae *Table )resetColumnWidths (){_efdae ._gffaf =[]float64 {};_dfgc :=float64 (1.0)/float64 (_efdae ._caef );for _beeec :=0;_beeec < _efdae ._caef ;_beeec ++{_efdae ._gffaf =append (_efdae ._gffaf ,_dfgc );};};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// Append adds a new text chunk to the paragraph.
func (_aaba *StyledParagraph )Append (text string )*TextChunk {_bffc :=NewTextChunk (text ,_aaba ._ffga );return _aaba .appendChunk (_bffc );};

// NewImageFromFile creates an Image from a file.
func (_eecc *Creator )NewImageFromFile (path string )(*Image ,error ){return _cgbf (path )};

// SetColorLeft sets border color for left.
func (_gga *border )SetColorLeft (col Color ){_gga ._eceed =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_gaadd *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _eadca []*Block ;_fafbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ebbf :=ctx ;if _gaadd ._gfecga .isAbsolute (){ctx .X =_gaadd ._gebga ;ctx .Y =_gaadd ._fbdad ;}else {ctx .X +=_gaadd ._gafag ._feag ;ctx .Y +=_gaadd ._gafag ._ecfa ;ctx .Width -=_gaadd ._gafag ._feag +_gaadd ._gafag ._ddbb ;ctx .Height -=_gaadd ._gafag ._fbbc +_gaadd ._gafag ._ecfa ;};_bgfa :=ctx .Width ;_cage :=ctx .X ;_deeg :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._fbbc ;_efgg :=ctx .Height ;_ebfac :=0;_geaeb :=-1;_becf :=-1;for _cgddc ,_fdcd :=range _gaadd ._gaafc {_dgada :=float64 (0.0);for _gbfd :=0;_gbfd < _fdcd ._cecd ;_gbfd ++{_dgada +=_gaadd ._gffaf [_fdcd ._aaee +_gbfd -1];};_feee :=float64 (0.0);for _egge :=0;_egge < _fdcd ._aaee -1;_egge ++{_feee +=_gaadd ._gffaf [_egge ]*_bgfa ;};_bbfdg :=float64 (0.0);for _beda :=_ebfac ;_beda < _fdcd ._bgeb -1;_beda ++{_bbfdg +=_gaadd ._febf [_beda ];};_edaa :=_dgada *_bgfa ;_bbff :=float64 (0.0);for _agcd :=0;_agcd < _fdcd ._fcbaf ;_agcd ++{_bbff +=_gaadd ._febf [_fdcd ._bgeb +_agcd -1];};if _gaadd ._eece {if _fdcd ._bgeb >=_gaadd ._eedef &&_fdcd ._bgeb <=_gaadd ._bceb {if _geaeb < 0{_geaeb =_cgddc ;};_becf =_cgddc ;};};switch _acce :=_fdcd ._efgea .(type ){case *Paragraph :_beeb :=_acce ;if _beeb ._fcff {_beeb .SetWidth (_edaa -_fdcd ._gfabg );};_adaf :=_beeb .Height ()+_beeb ._ecfg ._fbbc +_beeb ._ecfg ._fbbc ;_adaf +=0.5*_beeb ._fccdc *_beeb ._agaee ;if _adaf > _bbff {_gbbfd :=_adaf -_bbff ;_gaadd ._febf [_fdcd ._bgeb +_fdcd ._fcbaf -2]+=_gbbfd ;};case *StyledParagraph :_caafcg :=_acce ;if _caafcg ._bgf {_caafcg .SetWidth (_edaa -_fdcd ._gfabg );};_cbef :=_caafcg .Height ()+_caafcg ._bebaf ._ecfa +_caafcg ._bebaf ._fbbc ;_cbef +=0.5*_caafcg .getTextHeight ();if _cbef > _bbff {_dbce :=_cbef -_bbff ;_gaadd ._febf [_fdcd ._bgeb +_fdcd ._fcbaf -2]+=_dbce ;};case *Image :_fecde :=_acce ;_cegdg :=_fecde .Height ()+_fecde ._daa ._ecfa +_fecde ._daa ._fbbc ;if _cegdg > _bbff {_ebfd :=_cegdg -_bbff ;_gaadd ._febf [_fdcd ._bgeb +_fdcd ._fcbaf -2]+=_ebfd ;};case *Table :_ddbbg :=_acce ;_eacc :=_ddbbg .Height ()+_ddbbg ._gafag ._ecfa +_ddbbg ._gafag ._fbbc ;if _eacc > _bbff {_fddag :=_eacc -_bbff ;_gaadd ._febf [_fdcd ._bgeb +_fdcd ._fcbaf -2]+=_fddag ;};case *List :_gcbd :=_acce ;_dafg :=_gcbd .tableHeight (_edaa -_fdcd ._gfabg )+_gcbd ._gefg ._ecfa +_gcbd ._gefg ._fbbc ;if _dafg > _bbff {_bbbfa :=_dafg -_bbff ;_gaadd ._febf [_fdcd ._bgeb +_fdcd ._fcbaf -2]+=_bbbfa ;};case *Division :_ddfce :=_acce ;_ceged :=ctx ;_ceged .X =_feee ;_ceged .Y =_bbfdg ;_ceged .Width =_edaa ;_cecb ,_ ,_ffdd :=_ddfce .GeneratePageBlocks (_ceged );if _ffdd !=nil {return nil ,ctx ,_ffdd ;};if len (_cecb )> 1{_egec :=_ceged .Height -_bbff ;if _egec > _bbff {_gdeb :=_egec -_bbff ;_gaadd ._febf [_fdcd ._bgeb +_fdcd ._fcbaf -2]+=_gdeb ;};};_ccda :=_ddfce .Height ()+_ddfce ._bfdf ._ecfa +_ddfce ._bfdf ._fbbc ;if _ccda > _bbff {_abbaf :=_ccda -_bbff ;_gaadd ._febf [_fdcd ._bgeb +_fdcd ._fcbaf -2]+=_abbaf ;};};};var _afgb bool ;var _agcaa ,_eebc int ;for _afae :=0;_afae < len (_gaadd ._gaafc );_afae ++{_ggfb :=_gaadd ._gaafc [_afae ];_fbfb :=float64 (0.0);for _cdba :=0;_cdba < _ggfb ._cecd ;_cdba ++{_fbfb +=_gaadd ._gffaf [_ggfb ._aaee +_cdba -1];};_aefc :=float64 (0.0);for _bddc :=0;_bddc < _ggfb ._aaee -1;_bddc ++{_aefc +=_gaadd ._gffaf [_bddc ]*_bgfa ;};_efbcd :=float64 (0.0);for _cead :=_ebfac ;_cead < _ggfb ._bgeb -1;_cead ++{_efbcd +=_gaadd ._febf [_cead ];};_gebge :=_fbfb *_bgfa ;_daaf :=float64 (0.0);for _aegb :=0;_aegb < _ggfb ._fcbaf ;_aegb ++{_daaf +=_gaadd ._febf [_ggfb ._bgeb +_aegb -1];};ctx .Height =_efgg -_efbcd ;if _daaf > ctx .Height {_eadca =append (_eadca ,_fafbb );_fafbb =NewBlock (ctx .PageWidth ,ctx .PageHeight );_cage =ctx .Margins ._feag ;_deeg =ctx .Margins ._ecfa ;ctx .Height =ctx .PageHeight -ctx .Margins ._ecfa -ctx .Margins ._fbbc ;ctx .Page ++;_efgg =ctx .Height ;_ebfac =_ggfb ._bgeb -1;_efbcd =0;if _gaadd ._eece &&_geaeb >=0{_agcaa =_afae ;_afae =_geaeb -1;_eebc =_ebfac ;_ebfac =_gaadd ._eedef -1;_afgb =true ;continue ;};};ctx .Width =_gebge ;ctx .X =_cage +_aefc ;ctx .Y =_deeg +_efbcd ;_cegga :=_fge (ctx .X ,ctx .Y ,_gebge ,_daaf );if _ggfb ._fffb !=nil {_cfgg :=_ggfb ._fffb .R ();_ffb :=_ggfb ._fffb .G ();_fbaf :=_ggfb ._fffb .B ();_cegga .SetFillColor (ColorRGBFromArithmetic (_cfgg ,_ffb ,_fbaf ));};_cegga .LineStyle =_ggfb ._cbgg ;_cegga ._ebb =_ggfb ._dfgd ;_cegga ._abg =_ggfb ._faddb ;_cegga ._ega =_ggfb ._egfa ;_cegga ._aef =_ggfb ._baba ;if _ggfb ._bdfe !=nil {_cegga .SetColorLeft (ColorRGBFromArithmetic (_ggfb ._bdfe .R (),_ggfb ._bdfe .G (),_ggfb ._bdfe .B ()));};if _ggfb ._agfb !=nil {_cegga .SetColorBottom (ColorRGBFromArithmetic (_ggfb ._agfb .R (),_ggfb ._agfb .G (),_ggfb ._agfb .B ()));};if _ggfb ._aaec !=nil {_cegga .SetColorRight (ColorRGBFromArithmetic (_ggfb ._aaec .R (),_ggfb ._aaec .G (),_ggfb ._aaec .B ()));};if _ggfb ._acba !=nil {_cegga .SetColorTop (ColorRGBFromArithmetic (_ggfb ._acba .R (),_ggfb ._acba .G (),_ggfb ._acba .B ()));};_cegga .SetWidthBottom (_ggfb ._aeed );_cegga .SetWidthLeft (_ggfb ._gaeb );_cegga .SetWidthRight (_ggfb ._ddcbe );_cegga .SetWidthTop (_ggfb ._gddd );_aege :=_fafbb .Draw (_cegga );if _aege !=nil {_aae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_aege );};if _ggfb ._efgea !=nil {_bgdc :=_ggfb ._efgea .Width ();_aceb :=_ggfb ._efgea .Height ();_eceb :=0.0;switch _gacf :=_ggfb ._efgea .(type ){case *Paragraph :if _gacf ._fcff {_bgdc =_gacf .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _gacf ._bgf {_bgdc =_gacf .getMaxLineWidth ()/1000.0;};_cdea ,_ggda :=_gacf .getLineHeight (0);if len (_gacf ._dada )==1{_aceb =_cdea ;}else {_aceb =_aceb -_ggda +_cdea ;};_eceb =_cdea -_ggda ;switch _ggfb ._bbeb {case CellVerticalAlignmentTop :_eceb +=_cdea *0.5;case CellVerticalAlignmentBottom :_eceb -=_cdea *0.5;};case *Table :_bgdc =_gebge ;case *List :_bgdc =_gebge ;};switch _ggfb ._acee {case CellHorizontalAlignmentLeft :ctx .X +=_ggfb ._gfabg ;ctx .Width -=_ggfb ._gfabg ;case CellHorizontalAlignmentCenter :_gbcf :=_gebge -_bgdc ;if _gbcf > 0{ctx .X +=_gbcf /2;ctx .Width -=_gbcf /2;};case CellHorizontalAlignmentRight :if _gebge > _bgdc {ctx .X =ctx .X +_gebge -_bgdc -_ggfb ._gfabg ;ctx .Width -=_ggfb ._gfabg ;};};ctx .Y +=_eceb ;switch _ggfb ._bbeb {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_bbbb :=_daaf -_aceb ;if _bbbb > 0{ctx .Y +=_bbbb /2;ctx .Height -=_bbbb /2;};case CellVerticalAlignmentBottom :if _daaf > _aceb {ctx .Y =ctx .Y +_daaf -_aceb ;ctx .Height =_daaf ;};};_dcfd :=_fafbb .DrawWithContext (_ggfb ._efgea ,ctx );if _dcfd !=nil {_aae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dcfd );};ctx .Y -=_eceb ;};ctx .Y +=_daaf ;ctx .Height -=_daaf ;if _afgb &&_afae +1> _becf {_deeg +=_efbcd +_daaf ;_efgg -=_daaf +_efbcd ;_ebfac =_eebc ;_afae =_agcaa -1;_afgb =false ;};};_eadca =append (_eadca ,_fafbb );if _gaadd ._gfecga .isAbsolute (){return _eadca ,_ebbf ,nil ;};ctx .X =_ebbf .X ;ctx .Width =_ebbf .Width ;ctx .Y +=_gaadd ._gafag ._fbbc ;ctx .Height -=_gaadd ._gafag ._fbbc ;return _eadca ,ctx ,nil ;};func _ecb (_ddb *_cf .ContentStreamOperations ,_eggf *_ca .PdfPageResources ,_cac *_cf .ContentStreamOperations ,_dcf *_ca .PdfPageResources )error {_agd :=map[_fef .PdfObjectName ]_fef .PdfObjectName {};_be :=map[_fef .PdfObjectName ]_fef .PdfObjectName {};_ecfb :=map[_fef .PdfObjectName ]_fef .PdfObjectName {};_acf :=map[_fef .PdfObjectName ]_fef .PdfObjectName {};_bfd :=map[_fef .PdfObjectName ]_fef .PdfObjectName {};_dbb :=map[_fef .PdfObjectName ]_fef .PdfObjectName {};for _ ,_beb :=range *_cac {switch _beb .Operand {case "\u0044\u006f":if len (_beb .Params )==1{if _ade ,_ccc :=_beb .Params [0].(*_fef .PdfObjectName );_ccc {if _ ,_aff :=_agd [*_ade ];!_aff {var _da _fef .PdfObjectName ;_bgdg ,_ :=_dcf .GetXObjectByName (*_ade );if _bgdg !=nil {_da =*_ade ;for {_eda ,_ :=_eggf .GetXObjectByName (_da );if _eda ==nil ||_eda ==_bgdg {break ;};_da =_da +"\u0030";};};_eggf .SetXObjectByName (_da ,_bgdg );_agd [*_ade ]=_da ;};_cce :=_agd [*_ade ];_beb .Params [0]=&_cce ;};};case "\u0054\u0066":if len (_beb .Params )==2{if _cdd ,_ebc :=_beb .Params [0].(*_fef .PdfObjectName );_ebc {if _ ,_efe :=_be [*_cdd ];!_efe {_cgc ,_abag :=_dcf .GetFontByName (*_cdd );_dbg :=*_cdd ;if _abag &&_cgc !=nil {_dbg =_bba (_cdd .String (),_cgc ,_eggf );};_eggf .SetFontByName (_dbg ,_cgc );_be [*_cdd ]=_dbg ;};_gca :=_be [*_cdd ];_beb .Params [0]=&_gca ;};};case "\u0043\u0053","\u0063\u0073":if len (_beb .Params )==1{if _aggf ,_ga :=_beb .Params [0].(*_fef .PdfObjectName );_ga {if _ ,_cfaf :=_ecfb [*_aggf ];!_cfaf {var _ggb _fef .PdfObjectName ;_geab ,_fggg :=_dcf .GetColorspaceByName (*_aggf );if _fggg {_ggb =*_aggf ;for {_afd ,_gdc :=_eggf .GetColorspaceByName (_ggb );if !_gdc ||_geab ==_afd {break ;};_ggb =_ggb +"\u0030";};_eggf .SetColorspaceByName (_ggb ,_geab );_ecfb [*_aggf ]=_ggb ;}else {_aae .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _fgb ,_bcdf :=_ecfb [*_aggf ];_bcdf {_beb .Params [0]=&_fgb ;}else {_aae .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_aggf );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_beb .Params )==1{if _efa ,_ccbf :=_beb .Params [0].(*_fef .PdfObjectName );_ccbf {if _ ,_abe :=_acf [*_efa ];!_abe {var _fda _fef .PdfObjectName ;_fdef ,_gdce :=_dcf .GetPatternByName (*_efa );if _gdce {_fda =*_efa ;for {_gac ,_fbda :=_eggf .GetPatternByName (_fda );if !_fbda ||_gac ==_fdef {break ;};_fda =_fda +"\u0030";};_feac :=_eggf .SetPatternByName (_fda ,_fdef .ToPdfObject ());if _feac !=nil {return _feac ;};_acf [*_efa ]=_fda ;};};if _edgg ,_dbc :=_acf [*_efa ];_dbc {_beb .Params [0]=&_edgg ;};};};case "\u0073\u0068":if len (_beb .Params )==1{if _efbg ,_bd :=_beb .Params [0].(*_fef .PdfObjectName );_bd {if _ ,_gfdg :=_bfd [*_efbg ];!_gfdg {var _fbb _fef .PdfObjectName ;_adf ,_gef :=_dcf .GetShadingByName (*_efbg );if _gef {_fbb =*_efbg ;for {_caf ,_ecde :=_eggf .GetShadingByName (_fbb );if !_ecde ||_adf ==_caf {break ;};_fbb =_fbb +"\u0030";};_cb :=_eggf .SetShadingByName (_fbb ,_adf .ToPdfObject ());if _cb !=nil {_aae .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_cb );return _cb ;};_bfd [*_efbg ]=_fbb ;}else {_aae .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _deg ,_ada :=_bfd [*_efbg ];_ada {_beb .Params [0]=&_deg ;}else {_aae .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_efbg );};};};case "\u0067\u0073":if len (_beb .Params )==1{if _gad ,_bee :=_beb .Params [0].(*_fef .PdfObjectName );_bee {if _ ,_dga :=_dbb [*_gad ];!_dga {var _gbc _fef .PdfObjectName ;_cddf ,_efcc :=_dcf .GetExtGState (*_gad );if _efcc {_gbc =*_gad ;_dfa :=1;for {_gdb ,_ccg :=_eggf .GetExtGState (_gbc );if !_ccg ||_cddf ==_gdb {break ;};_gbc =_fef .PdfObjectName (_cg .Sprintf ("\u0047\u0053\u0025\u0064",_dfa ));_dfa ++;};};_eggf .AddExtGState (_gbc ,_cddf );_dbb [*_gad ]=_gbc ;};_afe :=_dbb [*_gad ];_beb .Params [0]=&_afe ;};};};*_ddb =append (*_ddb ,_beb );};return nil ;};

// SetBorderWidth sets the border width.
func (_dgdfd *Ellipse )SetBorderWidth (bw float64 ){_dgdfd ._edbf =bw };

// SetFillColor sets the fill color.
func (_cgceg *Rectangle )SetFillColor (col Color ){_cgceg ._faab =_ca .NewPdfColorDeviceRGB (col .ToRGB ());};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_efg *Division )Add (d VectorDrawable )error {_geba :=false ;switch d .(type ){case *Paragraph :_geba =true ;case *StyledParagraph :_geba =true ;case *Image :_geba =true ;};if !_geba {return _ef .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_efg ._cbcg =append (_efg ._cbcg ,d );return nil ;};

// Height returns the current page height.
func (_gfeb *Creator )Height ()float64 {return _gfeb ._fgc };const (_dbff positioning =iota ;_cef ;);

// New creates a new instance of the PDF Creator.
func New ()*Creator {_geee :=&Creator {};_geee ._feec =[]*_ca .PdfPage {};_geee ._feg =map[*_ca .PdfPage ]*Block {};_geee .SetPageSize (PageSizeLetter );_aeff :=0.1*_geee ._dadc ;_geee ._addc ._feag =_aeff ;_geee ._addc ._ddbb =_aeff ;_geee ._addc ._ecfa =_aeff ;_geee ._addc ._fbbc =_aeff ;var _gdbg error ;_geee ._aagc ,_gdbg =_ca .NewStandard14Font (_ca .HelveticaName );if _gdbg !=nil {_geee ._aagc =_ca .DefaultFont ();};_geee ._ddba ,_gdbg =_ca .NewStandard14Font (_ca .HelveticaBoldName );if _gdbg !=nil {_geee ._aagc =_ca .DefaultFont ();};_geee ._gfc =_geee .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_geee .AddOutlines =true ;_geee ._gfaa =_ca .NewOutline ();return _geee ;};func (_cab *Invoice )drawInformation ()*Table {_daba :=_dgde (2);_bbe :=append ([][2]*InvoiceCell {_cab ._fdccd ,_cab ._eead ,_cab ._ddcd },_cab ._fdcb ...);for _ ,_gdfg :=range _bbe {_edef ,_bccb :=_gdfg [0],_gdfg [1];if _bccb .Value ==""{continue ;};_fgec :=_daba .NewCell ();_fgec .SetBackgroundColor (_edef .BackgroundColor );_cab .setCellBorder (_fgec ,_edef );_fgdb :=_bged (_edef .TextStyle );_fgdb .Append (_edef .Value );_fgdb .SetMargins (0,0,2,1);_fgec .SetContent (_fgdb );_fgec =_daba .NewCell ();_fgec .SetBackgroundColor (_bccb .BackgroundColor );_cab .setCellBorder (_fgec ,_bccb );_fgdb =_bged (_bccb .TextStyle );_fgdb .Append (_bccb .Value );_fgdb .SetMargins (0,0,2,1);_fgec .SetContent (_fgdb );};return _daba ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_ddbc *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eebf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dega :=_de .Circle {X :_ddbc ._bda -_ddbc ._cgcd /2,Y :ctx .PageHeight -_ddbc ._bde -_ddbc ._cgbdb /2,Width :_ddbc ._cgcd ,Height :_ddbc ._cgbdb ,Opacity :1.0,BorderWidth :_ddbc ._edbf };if _ddbc ._gcea !=nil {_dega .FillEnabled =true ;_dega .FillColor =_ddbc ._gcea ;};if _ddbc ._efeb !=nil {_dega .BorderEnabled =true ;_dega .BorderColor =_ddbc ._efeb ;_dega .BorderWidth =_ddbc ._edbf ;};_dddfa ,_ ,_gddg :=_dega .Draw ("");if _gddg !=nil {return nil ,ctx ,_gddg ;};_gddg =_eebf .addContentsByString (string (_dddfa ));if _gddg !=nil {return nil ,ctx ,_gddg ;};return []*Block {_eebf },ctx ,nil ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_fbdg *TableCell )SetBorderLineStyle (style _de .LineStyle ){_fbdg ._cbgg =style };

// SetMargins sets the Paragraph's margins.
func (_dcge *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_dcge ._ecfg ._feag =left ;_dcge ._ecfg ._ddbb =right ;_dcge ._ecfg ._ecfa =top ;_dcge ._ecfg ._fbbc =bottom ;};

// SetDueDate sets the due date of the invoice.
func (_gadg *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_gadg ._ddcd [1].Value =dueDate ;return _gadg ._ddcd [0],_gadg ._ddcd [1];};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_gdfe *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _gdfe ._gge ==nil {if _ccfa :=_gdfe .makeXObject ();_ccfa !=nil {return nil ,ctx ,_ccfa ;};};var _bbd []*Block ;_fgaf :=ctx ;_ceb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gdfe ._egdc .isRelative (){if _gdfe ._ccdb > ctx .Height {_bbd =append (_bbd ,_ceb );_ceb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cafba :=ctx ;_cafba .Y =ctx .Margins ._ecfa ;_cafba .X =ctx .Margins ._feag +_gdfe ._daa ._feag ;_cafba .Height =ctx .PageHeight -ctx .Margins ._ecfa -ctx .Margins ._fbbc -_gdfe ._daa ._fbbc ;_cafba .Width =ctx .PageWidth -ctx .Margins ._feag -ctx .Margins ._ddbb -_gdfe ._daa ._feag -_gdfe ._daa ._ddbb ;ctx =_cafba ;}else {ctx .Y +=_gdfe ._daa ._ecfa ;ctx .Height -=_gdfe ._daa ._ecfa +_gdfe ._daa ._fbbc ;ctx .X +=_gdfe ._daa ._feag ;ctx .Width -=_gdfe ._daa ._feag +_gdfe ._daa ._ddbb ;};}else {ctx .X =_gdfe ._dbee ;ctx .Y =_gdfe ._gfgga ;};ctx ,_afg :=_aaab (_ceb ,_gdfe ,ctx );if _afg !=nil {return nil ,ctx ,_afg ;};_bbd =append (_bbd ,_ceb );if _gdfe ._egdc .isAbsolute (){ctx =_fgaf ;}else {ctx .Y +=_gdfe ._daa ._fbbc ;ctx .Height -=_gdfe ._daa ._fbbc ;};return _bbd ,ctx ,nil ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// CurCol returns the currently active cell's column number.
func (_babg *Table )CurCol ()int {_ccdf :=(_babg ._fdgcg -1)%(_babg ._caef )+1;return _ccdf };

// Heading returns the heading component of the table of contents.
func (_dded *TOC )Heading ()*StyledParagraph {return _dded ._deab };

// GeneratePageBlocks implements drawable interface.
func (_gcab *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_decg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bgc :=_gcab ._caa ;_gcd :=ctx .PageHeight -_gcab ._bag ;if _gcab ._abae !=nil {_efbge :=_de .Rectangle {Opacity :1.0,X :_gcab ._caa ,Y :ctx .PageHeight -_gcab ._bag -_gcab ._fbc ,Height :_gcab ._fbc ,Width :_gcab ._abb };_efbge .FillEnabled =true ;_efbge .FillColor =_gcab ._abae ;_efbge .BorderEnabled =false ;_dcef ,_ ,_gddf :=_efbge .Draw ("");if _gddf !=nil {return nil ,ctx ,_gddf ;};_gddf =_decg .addContentsByString (string (_dcef ));if _gddf !=nil {return nil ,ctx ,_gddf ;};};_bbf :=_gcab ._dbca ;_dcg :=_gcab ._aca ;_ded :=_gcab ._cgb ;_ffg :=_gcab ._ggc ;_bad :=_gcab ._dbca ;if _gcab ._ega ==CellBorderStyleDouble {_bad +=2*_bbf ;};_feff :=_gcab ._aca ;if _gcab ._aef ==CellBorderStyleDouble {_feff +=2*_dcg ;};_egfc :=_gcab ._cgb ;if _gcab ._ebb ==CellBorderStyleDouble {_egfc +=2*_ded ;};_fbbe :=_gcab ._ggc ;if _gcab ._abg ==CellBorderStyleDouble {_fbbe +=2*_ffg ;};if _gcab ._dbca !=0{_bea :=_bgc ;_aagd :=_gcd ;if _gcab ._ega ==CellBorderStyleDouble {_aagd -=_bbf ;_ebcc :=_de .BasicLine {};_ebcc .X1 =_bea -_bad /2;_ebcc .Y1 =_aagd +2*_bbf ;_ebcc .X2 =_bea +_gcab ._abb +_bad /2;_ebcc .Y2 =_aagd +2*_bbf ;_ebcc .LineColor =_gcab ._dbf ;_ebcc .LineWidth =_gcab ._dbca ;_ebcc .LineStyle =_gcab .LineStyle ;_adcg ,_ ,_aedc :=_ebcc .Draw ("");if _aedc !=nil {return nil ,ctx ,_aedc ;};_aedc =_decg .addContentsByString (string (_adcg ));if _aedc !=nil {return nil ,ctx ,_aedc ;};};_adef :=_de .BasicLine {LineWidth :_gcab ._dbca ,Opacity :1.0,LineColor :_gcab ._dbf ,X1 :_bea -_bad /2+(_egfc -_gcab ._cgb ),Y1 :_aagd ,X2 :_bea +_gcab ._abb +_bad /2-(_fbbe -_gcab ._ggc ),Y2 :_aagd ,LineStyle :_gcab .LineStyle };_gfda ,_ ,_gfgc :=_adef .Draw ("");if _gfgc !=nil {return nil ,ctx ,_gfgc ;};_gfgc =_decg .addContentsByString (string (_gfda ));if _gfgc !=nil {return nil ,ctx ,_gfgc ;};};if _gcab ._aca !=0{_dbbe :=_bgc ;_beec :=_gcd -_gcab ._fbc ;if _gcab ._aef ==CellBorderStyleDouble {_beec +=_dcg ;_fdgd :=_de .BasicLine {LineWidth :_gcab ._aca ,Opacity :1.0,LineColor :_gcab ._fga ,X1 :_dbbe -_feff /2,Y1 :_beec -2*_dcg ,X2 :_dbbe +_gcab ._abb +_feff /2,Y2 :_beec -2*_dcg ,LineStyle :_gcab .LineStyle };_degc ,_ ,_cgdb :=_fdgd .Draw ("");if _cgdb !=nil {return nil ,ctx ,_cgdb ;};_cgdb =_decg .addContentsByString (string (_degc ));if _cgdb !=nil {return nil ,ctx ,_cgdb ;};};_gce :=_de .BasicLine {LineWidth :_gcab ._aca ,Opacity :1.0,LineColor :_gcab ._fga ,X1 :_dbbe -_feff /2+(_egfc -_gcab ._cgb ),Y1 :_beec ,X2 :_dbbe +_gcab ._abb +_feff /2-(_fbbe -_gcab ._ggc ),Y2 :_beec ,LineStyle :_gcab .LineStyle };_gfgg ,_ ,_beg :=_gce .Draw ("");if _beg !=nil {return nil ,ctx ,_beg ;};_beg =_decg .addContentsByString (string (_gfgg ));if _beg !=nil {return nil ,ctx ,_beg ;};};if _gcab ._cgb !=0{_aaggf :=_bgc ;_edge :=_gcd ;if _gcab ._ebb ==CellBorderStyleDouble {_aaggf +=_ded ;_gba :=_de .BasicLine {LineWidth :_gcab ._cgb ,Opacity :1.0,LineColor :_gcab ._eceed ,X1 :_aaggf -2*_ded ,Y1 :_edge +_egfc /2,X2 :_aaggf -2*_ded ,Y2 :_edge -_gcab ._fbc -_egfc /2,LineStyle :_gcab .LineStyle };_ddg ,_ ,_gdac :=_gba .Draw ("");if _gdac !=nil {return nil ,ctx ,_gdac ;};_gdac =_decg .addContentsByString (string (_ddg ));if _gdac !=nil {return nil ,ctx ,_gdac ;};};_ffe :=_de .BasicLine {LineWidth :_gcab ._cgb ,Opacity :1.0,LineColor :_gcab ._eceed ,X1 :_aaggf ,Y1 :_edge +_egfc /2-(_bad -_gcab ._dbca ),X2 :_aaggf ,Y2 :_edge -_gcab ._fbc -_egfc /2+(_feff -_gcab ._aca ),LineStyle :_gcab .LineStyle };_dad ,_ ,_badf :=_ffe .Draw ("");if _badf !=nil {return nil ,ctx ,_badf ;};_badf =_decg .addContentsByString (string (_dad ));if _badf !=nil {return nil ,ctx ,_badf ;};};if _gcab ._ggc !=0{_gdae :=_bgc +_gcab ._abb ;_fcdd :=_gcd ;if _gcab ._abg ==CellBorderStyleDouble {_gdae -=_ffg ;_cda :=_de .BasicLine {LineWidth :_gcab ._ggc ,Opacity :1.0,LineColor :_gcab ._gda ,X1 :_gdae +2*_ffg ,Y1 :_fcdd +_fbbe /2,X2 :_gdae +2*_ffg ,Y2 :_fcdd -_gcab ._fbc -_fbbe /2,LineStyle :_gcab .LineStyle };_bgcd ,_ ,_ce :=_cda .Draw ("");if _ce !=nil {return nil ,ctx ,_ce ;};_ce =_decg .addContentsByString (string (_bgcd ));if _ce !=nil {return nil ,ctx ,_ce ;};};_ecdd :=_de .BasicLine {LineWidth :_gcab ._ggc ,Opacity :1.0,LineColor :_gcab ._gda ,X1 :_gdae ,Y1 :_fcdd +_fbbe /2-(_bad -_gcab ._dbca ),X2 :_gdae ,Y2 :_fcdd -_gcab ._fbc -_fbbe /2+(_feff -_gcab ._aca ),LineStyle :_gcab .LineStyle };_faeb ,_ ,_fba :=_ecdd .Draw ("");if _fba !=nil {return nil ,ctx ,_fba ;};_fba =_decg .addContentsByString (string (_faeb ));if _fba !=nil {return nil ,ctx ,_fba ;};};return []*Block {_decg },ctx ,nil ;};

// SetFillColor sets the fill color.
func (_efegd *Ellipse )SetFillColor (col Color ){_efegd ._gcea =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};func (_fae *Block )drawToPage (_gg *_ca .PdfPage )error {_eba ,_af :=_gg .GetAllContentStreams ();if _af !=nil {return _af ;};_edg :=_cf .NewContentStreamParser (_eba );_gbe ,_af :=_edg .Parse ();if _af !=nil {return _af ;};_gbe .WrapIfNeeded ();if _gg .Resources ==nil {_gg .Resources =_ca .NewPdfPageResources ();};_af =_ecb (_gbe ,_gg .Resources ,_fae ._agg ,_fae ._aac );if _af !=nil {return _af ;};if _af =_dac (_fae ._aac ,_gg .Resources );_af !=nil {return _af ;};_af =_gg .SetContentStreams ([]string {string (_gbe .Bytes ())},_fef .NewFlateEncoder ());if _af !=nil {return _af ;};for _ ,_aab :=range _fae ._add {_gg .AddAnnotation (_aab );};return nil ;};func _aadd (_gffa []byte )(*Image ,error ){_bdd :=_aa .NewReader (_gffa );_ebcb ,_gfff :=_ca .ImageHandling .Read (_bdd );if _gfff !=nil {_aae .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gfff );return nil ,_gfff ;};return _dcfa (_ebcb );};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_gdec []*TextChunk ;_ffga TextStyle ;_ebfe TextStyle ;_geefg TextAlignment ;_bgea float64 ;_bgf bool ;_fbbga float64 ;_afea bool ;_fdda float64 ;_bebaf margins ;_fcee positioning ;_cfge float64 ;_gfee float64 ;_bccaf float64 ;_fggbb float64 ;_dada [][]*TextChunk ;_fccf func (_bdb *StyledParagraph ,_bfbbe DrawContext );};

// NewCellProps returns the default properties of an invoice cell.
func (_bfga *Invoice )NewCellProps ()InvoiceCellProps {_bbfc :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_bfga ._dcdge ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_bbfc ,BorderColor :_bbfc ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};func _gbdg (_ebefe *_ca .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_ebefe ,FontSize :10};};

// Width returns the cell's width based on the input draw context.
func (_afde *TableCell )Width (ctx DrawContext )float64 {_eefe :=float64 (0.0);for _ccbbd :=0;_ccbbd < _afde ._cecd ;_ccbbd ++{_eefe +=_afde ._aeaf ._gffaf [_afde ._aaee +_ccbbd -1];};_eega :=ctx .Width *_eefe ;return _eega ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_bbbf *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_bbbf ._caef {_aae .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _ef .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bbbf ._gffaf =widths ;return nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_daf *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aefdb :=ctx ;_ebbee :=[]func (_eecb DrawContext )([]*Block ,DrawContext ,error ){_daf .generateHeaderBlocks ,_daf .generateInformationBlocks ,_daf .generateLineBlocks ,_daf .generateTotalBlocks ,_daf .generateNoteBlocks };var _gafa []*Block ;for _ ,_accae :=range _ebbee {_bcba ,_fdgf ,_aeaa :=_accae (ctx );if _aeaa !=nil {return _gafa ,ctx ,_aeaa ;};if len (_gafa )==0{_gafa =_bcba ;}else if len (_bcba )> 0{_gafa [len (_gafa )-1].mergeBlocks (_bcba [0]);_gafa =append (_gafa ,_bcba [1:]...);};ctx =_fdgf ;};if _daf ._dbeea .isRelative (){ctx .X =_aefdb .X ;};if _daf ._dbeea .isAbsolute (){return _gafa ,_aefdb ,nil ;};return _gafa ,ctx ,nil ;};func (_ggce *Paragraph )getTextWidth ()float64 {_acb :=0.0;for _ ,_ggcad :=range _ggce ._ddfc {if _ggcad =='\u000A'{continue ;};_dbdd ,_afad :=_ggce ._geegc .GetRuneMetrics (_ggcad );if !_afad {_aae .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_ggcad ,_ggcad );return -1;};_acb +=_ggce ._fccdc *_dbdd .Wx ;};return _acb ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_begb *List )Width ()float64 {return 0};type margins struct{_feag float64 ;_ddbb float64 ;_ecfa float64 ;_fbbc float64 ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_bdagb *Paragraph )SetWidth (width float64 ){_bdagb ._bdgb =width ;_bdagb .wrapText ()};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_cdce *StyledParagraph )SetTextAlignment (align TextAlignment ){_cdce ._geefg =align };

// Reset removes all the text chunks the paragraph contains.
func (_dcdc *StyledParagraph )Reset (){_dcdc ._gdec =[]*TextChunk {}};var PPMM =float64 (72*1.0/25.4);

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_ecgec *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebac :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ecdec :=_de .Rectangle {Opacity :1.0,X :_ecgec ._dcad ,Y :ctx .PageHeight -_ecgec ._dcag -_ecgec ._ebfb ,Height :_ecgec ._ebfb ,Width :_ecgec ._gdfd };if _ecgec ._faab !=nil {_ecdec .FillEnabled =true ;_ecdec .FillColor =_ecgec ._faab ;};if _ecgec ._ggf !=nil &&_ecgec ._baca > 0{_ecdec .BorderEnabled =true ;_ecdec .BorderColor =_ecgec ._ggf ;_ecdec .BorderWidth =_ecgec ._baca ;};_bfbc ,_ ,_bggdf :=_ecdec .Draw ("");if _bggdf !=nil {return nil ,ctx ,_bggdf ;};_bggdf =_ebac .addContentsByString (string (_bfbc ));if _bggdf !=nil {return nil ,ctx ,_bggdf ;};return []*Block {_ebac },ctx ,nil ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_gega *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _bcab (number ,title ,page ,level ,_gega .NewTextStyle ());};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_bcd *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bcd ._ab ._feag ,_bcd ._ab ._ddbb ,_bcd ._ab ._ecfa ,_bcd ._ab ._fbbc ;};

// SetWidth sets line width.
func (_fffa *Curve )SetWidth (width float64 ){_fffa ._bdcf =width };func (_efaaa *StyledParagraph )getTextWidth ()float64 {var _gaaf float64 ;_edfa :=len (_efaaa ._gdec );for _ffcb ,_aafed :=range _efaaa ._gdec {_gaada :=&_aafed .Style ;_agcf :=len (_aafed .Text );for _bgdd ,_bdeb :=range _aafed .Text {if _bdeb =='\u000A'{continue ;};_abgac ,_aeeg :=_gaada .Font .GetRuneMetrics (_bdeb );if !_aeeg {_aae .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bdeb );return -1;};_gaaf +=_gaada .FontSize *_abgac .Wx ;if _bdeb !=' '&&(_ffcb !=_edfa -1||_bgdd !=_agcf -1){_gaaf +=_gaada .CharSpacing *1000.0;};};};return _gaaf ;};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_edb :=rgbColor {};_edb ._degfg =float64 (r )/255.0;_edb ._aebc =float64 (g )/255.0;_edb ._abfd =float64 (b )/255.0;return _edb ;};

// Lines returns all the rows of the invoice line items table.
func (_dadba *Invoice )Lines ()[][]*InvoiceCell {return _dadba ._dbcb };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_cegd *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _cgca (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// SetStyleTop sets border style for top side.
func (_acfd *border )SetStyleTop (style CellBorderStyle ){_acfd ._ega =style };

// SetTitleStyle sets the style properties of the invoice title.
func (_eeda *Invoice )SetTitleStyle (style TextStyle ){_eeda ._bdaa =style };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_fgdd *Invoice )NoteStyle ()TextStyle {return _fgdd ._eggfe };

// MoveX moves the drawing context to absolute position x.
func (_adab *Creator )MoveX (x float64 ){_adab ._dade .X =x };

// SetLineHeight sets the line height (1.0 default).
func (_dadaa *StyledParagraph )SetLineHeight (lineheight float64 ){_dadaa ._bgea =lineheight };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_eab *Block )SetPos (x ,y float64 ){_eab ._ge =_cef ;_eab ._ad =x ;_eab ._ae =y };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_fffb *_ca .PdfColorDeviceRGB ;_cbgg _de .LineStyle ;_dfgd CellBorderStyle ;_bdfe *_ca .PdfColorDeviceRGB ;_gaeb float64 ;_baba CellBorderStyle ;_agfb *_ca .PdfColorDeviceRGB ;_aeed float64 ;_faddb CellBorderStyle ;_aaec *_ca .PdfColorDeviceRGB ;_ddcbe float64 ;_egfa CellBorderStyle ;_acba *_ca .PdfColorDeviceRGB ;_gddd float64 ;_bgeb ,_aaee int ;_fcbaf int ;_cecd int ;_efgea VectorDrawable ;_acee CellHorizontalAlignment ;_bbeb CellVerticalAlignment ;_gfabg float64 ;_aeaf *Table ;};func _cfbe ()*FilledCurve {_gcec :=FilledCurve {};_gcec ._gfab =[]_de .CubicBezierCurve {};return &_gcec ;};func _bdgd (_feffg TextStyle )*List {return &List {_deaf :TextChunk {Text :"\u2022\u0020",Style :_feffg },_bdea :0,_bbbc :true ,_geeg :_dbff ,_baef :_feffg };};

// SetLogo sets the logo of the invoice.
func (_feda *Invoice )SetLogo (logo *Image ){_feda ._aebd =logo };func _eaae ()*PageBreak {return &PageBreak {}};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_abdg *_ca .PdfAnnotation ;_adafb bool ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func _aaab (_fdgbe *Block ,_cebf *Image ,_adcf DrawContext )(DrawContext ,error ){_gbd :=_adcf ;_gcaa :=1;_dbdc :=_fef .PdfObjectName (_cg .Sprintf ("\u0049\u006d\u0067%\u0064",_gcaa ));for _fdgbe ._aac .HasXObjectByName (_dbdc ){_gcaa ++;_dbdc =_fef .PdfObjectName (_cg .Sprintf ("\u0049\u006d\u0067%\u0064",_gcaa ));};_cgdgb :=_fdgbe ._aac .SetXObjectImageByName (_dbdc ,_cebf ._gge );if _cgdgb !=nil {return _adcf ,_cgdgb ;};_cgae :=0;_eaaa :=_fef .PdfObjectName (_cg .Sprintf ("\u0047\u0053\u0025\u0064",_cgae ));for _fdgbe ._aac .HasExtGState (_eaaa ){_cgae ++;_eaaa =_fef .PdfObjectName (_cg .Sprintf ("\u0047\u0053\u0025\u0064",_cgae ));};_bfdab :=_fef .MakeDict ();_bfdab .Set ("\u0042\u004d",_fef .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _cebf ._bga < 1.0{_bfdab .Set ("\u0043\u0041",_fef .MakeFloat (_cebf ._bga ));_bfdab .Set ("\u0063\u0061",_fef .MakeFloat (_cebf ._bga ));};_cgdgb =_fdgbe ._aac .AddExtGState (_eaaa ,_fef .MakeIndirectObject (_bfdab ));if _cgdgb !=nil {return _adcf ,_cgdgb ;};_dccd :=_cebf .Width ();_aage :=_cebf .Height ();_ ,_cbg :=_cebf .rotatedSize ();_dcdg :=_adcf .X ;_dba :=_adcf .PageHeight -_adcf .Y -_aage ;if _cebf ._egdc .isRelative (){_dba -=(_cbg -_aage )/2;switch _cebf ._bcfa {case HorizontalAlignmentCenter :_dcdg +=(_adcf .Width -_dccd )/2;case HorizontalAlignmentRight :_dcdg =_adcf .PageWidth -_adcf .Margins ._ddbb -_cebf ._daa ._ddbb -_dccd ;};};_aggg :=_cebf ._fcfe ;_fcge :=_cf .NewContentCreator ();_fcge .Add_gs (_eaaa );_fcge .Translate (_dcdg ,_dba );if _aggg !=0{_fcge .Translate (_dccd /2,_aage /2);_fcge .RotateDeg (_aggg );_fcge .Translate (-_dccd /2,-_aage /2);};_fcge .Scale (_dccd ,_aage ).Add_Do (_dbdc );_cega :=_fcge .Operations ();_cega .WrapIfNeeded ();_fdgbe .addContents (_cega );if _cebf ._egdc .isRelative (){_adcf .Y +=_cbg ;_adcf .Height -=_cbg ;return _adcf ,nil ;};return _gbd ,nil ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_dgab *Creator )CreateTableOfContents (genTOCFunc func (_cae *TOC )error ){_dgab ._bdg =genTOCFunc ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_cbc *Creator )NewChapter (title string )*Chapter {_cbc ._egd ++;_bab :=_cbc .NewTextStyle ();_bab .FontSize =16;return _fcgb (nil ,_cbc ._gfc ,_cbc ._gfaa ,title ,_cbc ._egd ,_bab );};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// AddLine appends a new line to the invoice line items table.
func (_eed *Invoice )AddLine (values ...string )[]*InvoiceCell {_ceff :=len (_eed ._bcdc );var _bcgf []*InvoiceCell ;for _cbcf ,_aabe :=range values {_bcgc :=_eed .newCell (_aabe ,_eed ._fcga );if _cbcf < _ceff {_bcgc .Alignment =_eed ._bcdc [_cbcf ].Alignment ;};_bcgf =append (_bcgf ,_bcgc );};_eed ._dbcb =append (_eed ._dbcb ,_bcgf );return _bcgf ;};

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_f .Max (_f .Min (r ,1.0),0.0);g =_f .Max (_f .Min (g ,1.0),0.0);b =_f .Max (_f .Min (b ,1.0),0.0);_ebgb :=rgbColor {};_ebgb ._degfg =r ;_ebgb ._aebc =g ;_ebgb ._abfd =b ;return _ebgb ;};func (_acag *Invoice )generateTotalBlocks (_abga DrawContext )([]*Block ,DrawContext ,error ){_gdcf :=_dgde (4);_gdcf .SetMargins (0,0,10,10);_abbg :=[][2]*InvoiceCell {_acag ._adcdb };_abbg =append (_abbg ,_acag ._geca ...);_abbg =append (_abbg ,_acag ._ecfce );for _ ,_ggdg :=range _abbg {_abbb ,_abed :=_ggdg [0],_ggdg [1];if _abed .Value ==""{continue ;};_gdcf .SkipCells (2);_bcbf :=_gdcf .NewCell ();_bcbf .SetBackgroundColor (_abbb .BackgroundColor );_bcbf .SetHorizontalAlignment (_abed .Alignment );_acag .setCellBorder (_bcbf ,_abbb );_fggc :=_bged (_abbb .TextStyle );_fggc .SetMargins (0,0,2,1);_fggc .Append (_abbb .Value );_bcbf .SetContent (_fggc );_bcbf =_gdcf .NewCell ();_bcbf .SetBackgroundColor (_abed .BackgroundColor );_bcbf .SetHorizontalAlignment (_abed .Alignment );_acag .setCellBorder (_bcbf ,_abbb );_fggc =_bged (_abed .TextStyle );_fggc .SetMargins (0,0,2,1);_fggc .Append (_abed .Value );_bcbf .SetContent (_fggc );};return _gdcf .GeneratePageBlocks (_abga );};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_decd *Invoice )AddressStyle ()TextStyle {return _decd ._ggab };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_cgbfe []*listItem ;_gefg margins ;_deaf TextChunk ;_bdea float64 ;_bbbc bool ;_geeg positioning ;_baef TextStyle ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_faae *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_ebge :=NewTextChunk (text ,_faae ._ebfe );_ebge ._abdg =_ccgd (page -1,x ,y ,zoom );return _faae .appendChunk (_ebge );};

// Inline returns whether the inline mode of the division is active.
func (_ecdga *Division )Inline ()bool {return _ecdga ._edbc };

// The Image type is used to draw an image onto PDF.
type Image struct{_gge *_ca .XObjectImage ;_fedfg *_ca .Image ;_fcfe float64 ;_bfaf ,_ccdb float64 ;_aabb ,_cecf float64 ;_egdc positioning ;_bcfa HorizontalAlignment ;_dbee float64 ;_gfgga float64 ;_bga float64 ;_daa margins ;_eeae ,_cdfd float64 ;_fded _fef .StreamEncoder ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_feec []*_ca .PdfPage ;_feg map[*_ca .PdfPage ]*Block ;_ffa *_ca .PdfPage ;_cdae PageSize ;_dade DrawContext ;_addc margins ;_dadc ,_fgc float64 ;_egd int ;_efbd func (_feb FrontpageFunctionArgs );_bdg func (_ffae *TOC )error ;_aea func (_fcdg *Block ,_edc HeaderFunctionArgs );_ffgg func (_gfaf *Block ,_cace FooterFunctionArgs );_ddge func (_dbe *_ca .PdfWriter )error ;_edae bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_gfc *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gfaa *_ca .Outline ;_fcc *_ca .PdfOutlineTreeNode ;_gcgg *_ca .PdfAcroForm ;_fccd _fef .PdfObject ;_facf _ca .Optimizer ;_aefa []*_ca .PdfFont ;_aagc *_ca .PdfFont ;_ddba *_ca .PdfFont ;};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_dgcg float64 ;_dfae float64 ;_gbbd float64 ;_dgcga float64 ;_gbde *_ca .PdfColorDeviceRGB ;_adcc float64 ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_agfd *Creator )NewTextStyle ()TextStyle {return _gbdg (_agfd ._aagc )};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_gbaa *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bcg *_ca .PdfWriter )error ){_gbaa ._ddge =pdfWriterAccessFunc ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_aaebf *Image )SetMargins (left ,right ,top ,bottom float64 ){_aaebf ._daa ._feag =left ;_aaebf ._daa ._ddbb =right ;_aaebf ._daa ._ecfa =top ;_aaebf ._daa ._fbbc =bottom ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cddcb *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_eccc :=[2]*InvoiceCell {_cddcb .newCell (description ,_cddcb ._daeg ),_cddcb .newCell (value ,_cddcb ._daeg )};_cddcb ._fdcb =append (_cddcb ._fdcb ,_eccc );return _eccc [0],_eccc [1];};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_gegc *Image )SetWidth (w float64 ){_gegc ._bfaf =w };func _dgde (_cfbb int )*Table {_dabbg :=&Table {_caef :_cfbb ,_dcfg :10.0,_gffaf :[]float64 {},_febf :[]float64 {},_gaafc :[]*TableCell {}};_dabbg .resetColumnWidths ();return _dabbg ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_agg *_cf .ContentStreamOperations ;_aac *_ca .PdfPageResources ;_ge positioning ;_ad ,_ae float64 ;_fd float64 ;_eg float64 ;_cgf float64 ;_ab margins ;_add []*_ca .PdfAnnotation ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_ffggc *Invoice )Notes ()(string ,string ){return _ffggc ._fcac [0],_ffggc ._fcac [1]};

// SetTotal sets the total of the invoice.
func (_eedc *Invoice )SetTotal (value string ){_eedc ._ecfce [1].Value =value };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_febb *StyledParagraph )Insert (index uint ,text string )*TextChunk {_dacb :=uint (len (_febb ._gdec ));if index > _dacb {index =_dacb ;};_cbdb :=NewTextChunk (text ,_febb ._ffga );_febb ._gdec =append (_febb ._gdec [:index ],append ([]*TextChunk {_cbdb },_febb ._gdec [index :]...)...);_febb .wrapText ();return _cbdb ;};

// RotatedSize returns the width and height of the rotated block.
func (_fa *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_gfd ,_ace :=_ebga (_fa ._fd ,_fa ._eg ,_fa ._cgf );return _gfd ,_ace ;};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_bfce *Ellipse )GetCoords ()(float64 ,float64 ){return _bfce ._bda ,_bfce ._bde };

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_cdfg *Creator )SetPageSize (size PageSize ){_cdfg ._cdae =size ;_cdfg ._dadc =size [0];_cdfg ._fgc =size [1];_dgae :=0.1*_cdfg ._dadc ;_cdfg ._addc ._feag =_dgae ;_cdfg ._addc ._ddbb =_dgae ;_cdfg ._addc ._ecfa =_dgae ;_cdfg ._addc ._fbbc =_dgae ;};type border struct{_caa float64 ;_bag float64 ;_abb float64 ;_fbc float64 ;_abae *_ca .PdfColorDeviceRGB ;_eceed *_ca .PdfColorDeviceRGB ;_cgb float64 ;_fga *_ca .PdfColorDeviceRGB ;_aca float64 ;_gda *_ca .PdfColorDeviceRGB ;_ggc float64 ;_dbf *_ca .PdfColorDeviceRGB ;_dbca float64 ;LineStyle _de .LineStyle ;_ebb CellBorderStyle ;_abg CellBorderStyle ;_ega CellBorderStyle ;_aef CellBorderStyle ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_cea *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aebe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fffg ,_ ,_cbfg :=_cea .draw ("");_cbfg =_aebe .addContentsByString (string (_fffg ));if _cbfg !=nil {return nil ,ctx ,_cbfg ;};return []*Block {_aebe },ctx ,nil ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_bbcg *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bbcg ._gafag ._feag ,_bbcg ._gafag ._ddbb ,_bbcg ._gafag ._ecfa ,_bbcg ._gafag ._fbbc ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_ccfd *Paragraph )SetEnableWrap (enableWrap bool ){_ccfd ._fcff =enableWrap ;_ccfd ._afga =false };

// SetDate sets the date of the invoice.
func (_ceeg *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_ceeg ._eead [1].Value =date ;return _ceeg ._eead [0],_ceeg ._eead [1];};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_dcbbd *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _ef .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _ef .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _ef .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_dcbbd ._eece =true ;_dcbbd ._eedef =startRow ;_dcbbd ._bceb =endRow ;return nil ;};

// NewCell returns a new invoice table cell.
func (_abgf *Invoice )NewCell (value string )*InvoiceCell {return _abgf .newCell (value ,_abgf .NewCellProps ());};

// SkipRows skips over a specified number of rows in the table.
func (_cgdba *Table )SkipRows (num int ){_adac :=num *_cgdba ._caef -1;if _adac < 0{_aae .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_cgdba ._fdgcg +=_adac ;};func (_bfcb *Invoice )setCellBorder (_fbcc *TableCell ,_cgdd *InvoiceCell ){for _ ,_abeg :=range _cgdd .BorderSides {_fbcc .SetBorder (_abeg ,CellBorderStyleSingle ,_cgdd .BorderWidth );};_fbcc .SetBorderColor (_cgdd .BorderColor );};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_egdg *Table )Width ()float64 {return 0};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_fedf *Creator )Finalize ()error {if _fedf ._edae {return nil ;};_fdgg :=len (_fedf ._feec );_dae :=0;if _fedf ._efbd !=nil {_dae ++;};if _fedf .AddTOC {_fedf .initContext ();_fedf ._dade .Page =_dae +1;if _fedf ._bdg !=nil {if _eacg :=_fedf ._bdg (_fedf ._gfc );_eacg !=nil {return _eacg ;};};_gdcb ,_ ,_baa :=_fedf ._gfc .GeneratePageBlocks (_fedf ._dade );if _baa !=nil {_aae .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_baa );return _baa ;};_dae +=len (_gdcb );_gacc :=_fedf ._gfc .Lines ();for _ ,_def :=range _gacc {_bedde ,_dgb :=_fe .Atoi (_def .Page .Text );if _dgb !=nil {continue ;};_def .Page .Text =_fe .Itoa (_bedde +_dae );};};_geae :=false ;if _fedf ._efbd !=nil {_fdgg ++;_gaccg :=_fedf .newPage ();_fedf ._feec =append ([]*_ca .PdfPage {_gaccg },_fedf ._feec ...);_fedf .setActivePage (_gaccg );_gaa :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fdgg };_fedf ._efbd (_gaa );_geae =true ;};if _fedf .AddTOC {_fedf .initContext ();if _fedf ._bdg !=nil {if _fbdb :=_fedf ._bdg (_fedf ._gfc );_fbdb !=nil {_aae .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_fbdb );return _fbdb ;};};_aadc :=_fedf ._gfc .Lines ();for _ ,_egc :=range _aadc {_egc ._gaed +=int64 (_dae );};var _aga []*_ca .PdfPage ;_bgg ,_ ,_ :=_fedf ._gfc .GeneratePageBlocks (_fedf ._dade );for _ ,_fcfd :=range _bgg {_fcfd .SetPos (0,0);_fdgg ++;_fdfc :=_fedf .newPage ();_aga =append (_aga ,_fdfc );_fedf .setActivePage (_fdfc );_fedf .Draw (_fcfd );};if _geae {_feaf :=_fedf ._feec [0];_agbf :=_fedf ._feec [1:];_fedf ._feec =append ([]*_ca .PdfPage {_feaf },_aga ...);_fedf ._feec =append (_fedf ._feec ,_agbf ...);}else {_fedf ._feec =append (_aga ,_fedf ._feec ...);};};if _fedf ._gfaa !=nil &&_fedf .AddOutlines {var _dgaf func (_afc *_ca .OutlineItem );_dgaf =func (_ffea *_ca .OutlineItem ){_ffea .Dest .Page +=int64 (_dae );if _bdfg :=int (_ffea .Dest .Page );_bdfg >=0&&_bdfg < len (_fedf ._feec ){_ffea .Dest .PageObj =_fedf ._feec [_bdfg ].GetPageAsIndirectObject ();}else {_aae .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bdfg );};_ffea .Dest .Y =_fedf ._fgc -_ffea .Dest .Y ;_cbfe :=_ffea .Items ();for _ ,_eaab :=range _cbfe {_dgaf (_eaab );};};_fgd :=_fedf ._gfaa .Items ();for _ ,_bfb :=range _fgd {_dgaf (_bfb );};if _fedf .AddTOC {var _baee int ;if _geae {_baee =1;};_dgdf :=_ca .NewOutlineDest (int64 (_baee ),0,_fedf ._fgc );if _baee >=0&&_baee < len (_fedf ._feec ){_dgdf .PageObj =_fedf ._feec [_baee ].GetPageAsIndirectObject ();}else {_aae .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_baee );};_fedf ._gfaa .Insert (0,_ca .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_dgdf ));};};for _gecd ,_gcce :=range _fedf ._feec {_fedf .setActivePage (_gcce );if _fedf ._aea !=nil {_edfgf :=NewBlock (_fedf ._dadc ,_fedf ._addc ._ecfa );_agba :=HeaderFunctionArgs {PageNum :_gecd +1,TotalPages :_fdgg };_fedf ._aea (_edfgf ,_agba );_edfgf .SetPos (0,0);if _bef :=_fedf .Draw (_edfgf );_bef !=nil {_aae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_bef );return _bef ;};};if _fedf ._ffgg !=nil {_gfgf :=NewBlock (_fedf ._dadc ,_fedf ._addc ._fbbc );_cde :=FooterFunctionArgs {PageNum :_gecd +1,TotalPages :_fdgg };_fedf ._ffgg (_gfgf ,_cde );_gfgf .SetPos (0,_fedf ._fgc -_gfgf ._eg );if _cec :=_fedf .Draw (_gfgf );_cec !=nil {_aae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_cec );return _cec ;};};_gbff ,_dgba :=_fedf ._feg [_gcce ];if !_dgba {continue ;};if _abfg :=_gbff .drawToPage (_gcce );_abfg !=nil {_aae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_gecd +1,_abfg );return _abfg ;};};_fedf ._edae =true ;return nil ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_faef *Chapter )GetHeading ()*Paragraph {return _faef ._gadf };

// SetColorBottom sets border color for bottom.
func (_gfb *border )SetColorBottom (col Color ){_gfb ._fga =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_ecf *Block )SetMargins (left ,right ,top ,bottom float64 ){_ecf ._ab ._feag =left ;_ecf ._ab ._ddbb =right ;_ecf ._ab ._ecfa =top ;_ecf ._ab ._fbbc =bottom ;};func (_dfdg positioning )isRelative ()bool {return _dfdg ==_dbff };

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_ceffb *Paragraph )SetColor (col Color ){_dge :=_ca .NewPdfColorDeviceRGB (col .ToRGB ());_ceffb ._cebg =*_dge ;};

// NewTOC creates a new table of contents.
func (_ebcfd *Creator )NewTOC (title string )*TOC {_cgdg :=_ebcfd .NewTextStyle ();_cgdg .Font =_ebcfd ._ddba ;return _fcfdb (title ,_ebcfd .NewTextStyle (),_cgdg );};

// Height returns Image's document height.
func (_fbbge *Image )Height ()float64 {return _fbbge ._ccdb };

// Width returns the width of the Paragraph.
func (_bebad *StyledParagraph )Width ()float64 {if _bebad ._bgf &&int (_bebad ._fbbga )> 0{return _bebad ._fbbga ;};return _bebad .getTextWidth ()/1000.0;};func _dac (_fec ,_gfec *_ca .PdfPageResources )error {_eea ,_ :=_fec .GetColorspaces ();if _eea !=nil &&len (_eea .Colorspaces )> 0{for _feeb ,_bfc :=range _eea .Colorspaces {_adc :=*_fef .MakeName (_feeb );if _gfec .HasColorspaceByName (_adc ){continue ;};_agc :=_gfec .SetColorspaceByName (_adc ,_bfc );if _agc !=nil {return _agc ;};};};return nil ;};func _dfbc (_eeaed ,_ccfaa ,_adbc TextChunk ,_fafba uint ,_feca TextStyle )*TOCLine {_adde :=_bged (_feca );_adde .SetEnableWrap (true );_adde .SetTextAlignment (TextAlignmentLeft );_adde .SetMargins (0,0,2,2);_fgad :=&TOCLine {_afeff :_adde ,Number :_eeaed ,Title :_ccfaa ,Page :_adbc ,Separator :TextChunk {Text :"\u002e",Style :_feca },_dbaa :0,_bdfb :_fafba ,_gefc :10,_fgff :_dbff };_adde ._bebaf ._feag =_fgad ._dbaa +float64 (_fgad ._bdfb -1)*_fgad ._gefc ;_adde ._fccf =_fgad .prepareParagraph ;return _fgad ;};

// SetSellerAddress sets the seller address of the invoice.
func (_fgce *Invoice )SetSellerAddress (address *InvoiceAddress ){_fgce ._cadff =address };const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_bcca *Creator )NewImageFromGoImage (goimg _aag .Image )(*Image ,error ){return _gbae (goimg )};

// SetAngle sets Image rotation angle in degrees.
func (_ebae *Image )SetAngle (angle float64 ){_ebae ._fcfe =angle };func (_cacd *Table )newCell (_bfafb int )*TableCell {_cacd ._fdgcg ++;_bageb :=(_cacd ._fdgcg -1)/_cacd ._caef +1;for _bageb > _cacd ._aecc {_cacd ._aecc ++;_cacd ._febf =append (_cacd ._febf ,_cacd ._dcfg );};_gcddb :=(_cacd ._fdgcg -1)%(_cacd ._caef )+1;_bdgf :=&TableCell {};_bdgf ._bgeb =_bageb ;_bdgf ._aaee =_gcddb ;_bdgf ._fcbaf =1;_bdgf ._gfabg =5;_bdgf ._dfgd =CellBorderStyleNone ;_bdgf ._cbgg =_de .LineStyleSolid ;_bdgf ._acee =CellHorizontalAlignmentLeft ;_bdgf ._bbeb =CellVerticalAlignmentTop ;_bdgf ._gaeb =0;_bdgf ._aeed =0;_bdgf ._ddcbe =0;_bdgf ._gddd =0;_fbfc :=ColorBlack ;_bdgf ._bdfe =_ca .NewPdfColorDeviceRGB (_fbfc .ToRGB ());_bdgf ._agfb =_ca .NewPdfColorDeviceRGB (_fbfc .ToRGB ());_bdgf ._aaec =_ca .NewPdfColorDeviceRGB (_fbfc .ToRGB ());_bdgf ._acba =_ca .NewPdfColorDeviceRGB (_fbfc .ToRGB ());if _bfafb < 1{_aae .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_bfafb );_bfafb =1;};_efdb :=_cacd ._caef -(_bdgf ._aaee -1);if _bfafb > _efdb {_aae .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_bfafb ,_efdb );_bfafb =_efdb ;};_bdgf ._cecd =_bfafb ;_cacd ._fdgcg +=_bfafb -1;_cacd ._gaafc =append (_cacd ._gaafc ,_bdgf );_bdgf ._aeaf =_cacd ;return _bdgf ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// TOC returns the table of contents component of the creator.
func (_edbe *Creator )TOC ()*TOC {return _edbe ._gfc };

// AppendColumn appends a column to the line items table.
func (_fcae *Invoice )AppendColumn (description string )*InvoiceCell {_aefdc :=_fcae .NewColumn (description );_fcae ._bcdc =append (_fcae ._bcdc ,_aefdc );return _aefdc ;};func (_gfecc *TOCLine )prepareParagraph (_fbag *StyledParagraph ,_gace DrawContext ){_cegge :=_gfecc .Title .Text ;if _gfecc .Number .Text !=""{_cegge ="\u0020"+_cegge ;};_cegge +="\u0020";_fdae :=_gfecc .Page .Text ;if _fdae !=""{_fdae ="\u0020"+_fdae ;};_fbag ._gdec =[]*TextChunk {{Text :_gfecc .Number .Text ,Style :_gfecc .Number .Style ,_abdg :_gfecc .getLineLink ()},{Text :_cegge ,Style :_gfecc .Title .Style ,_abdg :_gfecc .getLineLink ()},{Text :_fdae ,Style :_gfecc .Page .Style ,_abdg :_gfecc .getLineLink ()}};_fbag .wrapText ();_daca :=len (_fbag ._dada );if _daca ==0{return ;};_ddfd :=_gace .Width *1000-_fbag .getTextLineWidth (_fbag ._dada [_daca -1]);_efcd :=_fbag .getTextLineWidth ([]*TextChunk {&_gfecc .Separator });_fgfbg :=int (_ddfd /_efcd );_bdagf :=_ag .Repeat (_gfecc .Separator .Text ,_fgfbg );_agdb :=_gfecc .Separator .Style ;_fbddf :=_fbag .Insert (2,_bdagf );_fbddf .Style =_agdb ;_fbddf ._abdg =_gfecc .getLineLink ();_ddfd =_ddfd -float64 (_fgfbg )*_efcd ;if _ddfd > 500{_dcggd ,_ecddd :=_agdb .Font .GetRuneMetrics (' ');if _ecddd &&_ddfd > _dcggd .Wx {_daed :=int (_ddfd /_dcggd .Wx );if _daed > 0{_dbeb :=_agdb ;_dbeb .FontSize =1;_fbddf =_fbag .Insert (2,_ag .Repeat ("\u0020",_daed ));_fbddf .Style =_dbeb ;_fbddf ._abdg =_gfecc .getLineLink ();};};};};

// SetWidthRight sets border width for right.
func (_dgd *border )SetWidthRight (bw float64 ){_dgd ._ggc =bw };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_dfe *Invoice )TotalLines ()[][2]*InvoiceCell {_dca :=[][2]*InvoiceCell {_dfe ._adcdb };_dca =append (_dca ,_dfe ._geca ...);return append (_dca ,_dfe ._ecfce );};

// Width returns the current page width.
func (_ggbd *Creator )Width ()float64 {return _ggbd ._dadc };func (_ebdfe *List )tableHeight (_faea float64 )float64 {var _eadcb float64 ;for _ ,_edeg :=range _ebdfe ._cgbfe {switch _ecced :=_edeg ._bgeg .(type ){case *Paragraph :_cfcgc :=_ecced ;if _cfcgc ._fcff {_cfcgc .SetWidth (_faea );};_eadcb +=_cfcgc .Height ()+_cfcgc ._ecfg ._fbbc +_cfcgc ._ecfg ._fbbc ;_eadcb +=0.5*_cfcgc ._fccdc *_cfcgc ._agaee ;case *StyledParagraph :_fdac :=_ecced ;if _fdac ._bgf {_fdac .SetWidth (_faea );};_eadcb +=_fdac .Height ()+_fdac ._bebaf ._ecfa +_fdac ._bebaf ._fbbc ;_eadcb +=0.5*_fdac .getTextHeight ();default:_eadcb +=_edeg ._bgeg .Height ();};};return _eadcb ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_eae *Invoice )AddressHeadingStyle ()TextStyle {return _eae ._bge };

// DrawFooter sets a function to draw a footer on created output pages.
func (_deca *Creator )DrawFooter (drawFooterFunc func (_cfd *Block ,_bcf FooterFunctionArgs )){_deca ._ffgg =drawFooterFunc ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_aeccg *TOCLine )LevelOffset ()float64 {return _aeccg ._gefc };

// AppendCurve appends a Bezier curve to the filled curve.
func (_bdac *FilledCurve )AppendCurve (curve _de .CubicBezierCurve )*FilledCurve {_bdac ._gfab =append (_bdac ._gfab ,curve );return _bdac ;};

// Scale block by specified factors in the x and y directions.
func (_cfa *Block )Scale (sx ,sy float64 ){_ff :=_cf .NewContentCreator ().Scale (sx ,sy ).Operations ();*_cfa ._agg =append (*_ff ,*_cfa ._agg ...);_cfa ._agg .WrapIfNeeded ();_cfa ._fd *=sx ;_cfa ._eg *=sy ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_gf *Block )AddAnnotation (annotation *_ca .PdfAnnotation ){for _ ,_fde :=range _gf ._add {if _fde ==annotation {return ;};};_gf ._add =append (_gf ._add ,annotation );};

// SetOpacity sets opacity for Image.
func (_dede *Image )SetOpacity (opacity float64 ){_dede ._bga =opacity };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ea :=&Block {};_ea ._agg =&_cf .ContentStreamOperations {};_ea ._aac =_ca .NewPdfPageResources ();_ea ._fd =width ;_ea ._eg =height ;return _ea ;};

// NewPageBreak create a new page break.
func (_dabb *Creator )NewPageBreak ()*PageBreak {return _eaae ()};

// SetShowLinks sets visibility of links for the TOC lines.
func (_fdceb *TOC )SetShowLinks (showLinks bool ){_fdceb ._gfcd =showLinks };

// NewColumn returns a new column for the line items invoice table.
func (_ebaa *Invoice )NewColumn (description string )*InvoiceCell {return _ebaa .newColumn (description ,CellHorizontalAlignmentLeft );};func (_gaaa *Invoice )newColumn (_cdab string ,_fdd CellHorizontalAlignment )*InvoiceCell {_ecge :=&InvoiceCell {_gaaa ._baf ,_cdab };_ecge .Alignment =_fdd ;return _ecge ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_ggcg *Creator )NewImage (img *_ca .Image )(*Image ,error ){return _dcfa (img )};func (_decc *Invoice )generateInformationBlocks (_bagf DrawContext )([]*Block ,DrawContext ,error ){_dbcd :=_bged (_decc ._dcdge );_dbcd .SetMargins (0,0,0,20);_dgdfc :=_decc .drawAddress (_decc ._cadff );_dgdfc =append (_dgdfc ,_dbcd );_dgdfc =append (_dgdfc ,_decc .drawAddress (_decc ._fcgg )...);_caafc :=_cga ();for _ ,_dgcb :=range _dgdfc {_caafc .Add (_dgcb );};_gbb :=_decc .drawInformation ();_cdec :=_dgde (2);_cdec .SetMargins (0,0,25,0);_eadc :=_cdec .NewCell ();_eadc .SetIndent (0);_eadc .SetContent (_caafc );_eadc =_cdec .NewCell ();_eadc .SetContent (_gbb );return _cdec .GeneratePageBlocks (_bagf );};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_dfc *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_dfc ._ege ._feag =left ;_dfc ._ege ._ddbb =right ;_dfc ._ege ._ecfa =top ;_dfc ._ege ._fbbc =bottom ;};

// NewList creates a new list.
func (_baea *Creator )NewList ()*List {return _bdgd (_baea .NewTextStyle ())};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aafe *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aafe ._bebaf ._feag ,_aafe ._bebaf ._ddbb ,_aafe ._bebaf ._ecfa ,_aafe ._bebaf ._fbbc ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_ebccg *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _ebaf (xc ,yc ,width ,height );};

// SetNotes sets the notes section of the invoice.
func (_cdb *Invoice )SetNotes (title ,content string ){_cdb ._fcac =[2]string {title ,content }};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_fff :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_aae .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fff ;};var _agca ,_bbfg ,_ccga int ;if len (hexStr )==4{var _dab ,_gfde ,_dgdb int ;_bgb ,_caaf :=_cg .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_dab ,&_gfde ,&_dgdb );if _caaf !=nil {_aae .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_caaf );return _fff ;};if _bgb !=3{_aae .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fff ;};_agca =_dab *16+_dab ;_bbfg =_gfde *16+_gfde ;_ccga =_dgdb *16+_dgdb ;}else {_cdfc ,_dfcd :=_cg .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_agca ,&_bbfg ,&_ccga );if _dfcd !=nil {_aae .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fff ;};if _cdfc !=3{_aae .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_cdfc );return _fff ;};};_cfb :=float64 (_agca )/255.0;_fdgc :=float64 (_bbfg )/255.0;_bbc :=float64 (_ccga )/255.0;_fff ._degfg =_cfb ;_fff ._aebc =_fdgc ;_fff ._abfd =_bbc ;return _fff ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_bafc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_bafc ._eadf =append (_bafc ._eadf ,line );return line ;};func (_dg *Block )translate (_cad ,_ccbg float64 ){_efb :=_cf .NewContentCreator ().Translate (_cad ,-_ccbg ).Operations ();*_dg ._agg =append (*_efb ,*_dg ._agg ...);_dg ._agg .WrapIfNeeded ();};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_gbcd *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcfb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ddbf :=_de .Line {LineWidth :_gbcd ._adcc ,Opacity :1.0,LineColor :_gbcd ._gbde ,LineEndingStyle1 :_de .LineEndingStyleNone ,LineEndingStyle2 :_de .LineEndingStyleNone ,X1 :_gbcd ._dgcg ,Y1 :ctx .PageHeight -_gbcd ._dfae ,X2 :_gbcd ._gbbd ,Y2 :ctx .PageHeight -_gbcd ._dgcga };_gceb ,_ ,_fdab :=_ddbf .Draw ("");if _fdab !=nil {return nil ,ctx ,_fdab ;};_fdab =_dcfb .addContentsByString (string (_gceb ));if _fdab !=nil {return nil ,ctx ,_fdab ;};return []*Block {_dcfb },ctx ,nil ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_cefa *Invoice )Sections ()[][2]string {return _cefa ._egfcf };

// SetNumber sets the number of the invoice.
func (_fdeb *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_fdeb ._fdccd [1].Value =number ;return _fdeb ._fdccd [0],_fdeb ._fdccd [1];};

// SkipCells skips over a specified number of cells in the table.
func (_faaba *Table )SkipCells (num int ){if num < 0{_aae .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_faaba ._fdgcg +=num ;};

// SetIndent sets the cell's left indent.
func (_cgece *TableCell )SetIndent (indent float64 ){_cgece ._gfabg =indent };func _fge (_gfg ,_gdd ,_fgeg ,_faa float64 )*border {_baed :=&border {};_baed ._caa =_gfg ;_baed ._bag =_gdd ;_baed ._abb =_fgeg ;_baed ._fbc =_faa ;_baed ._dbf =_ca .NewPdfColorDeviceRGB (0,0,0);_baed ._fga =_ca .NewPdfColorDeviceRGB (0,0,0);_baed ._eceed =_ca .NewPdfColorDeviceRGB (0,0,0);_baed ._gda =_ca .NewPdfColorDeviceRGB (0,0,0);_baed ._dbca =0;_baed ._aca =0;_baed ._cgb =0;_baed ._ggc =0;_baed .LineStyle =_de .LineStyleSolid ;return _baed ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);func (_abce *Invoice )generateNoteBlocks (_daab DrawContext )([]*Block ,DrawContext ,error ){_cbad :=_cga ();_bcgcb :=append ([][2]string {_abce ._fcac ,_abce ._feae },_abce ._egfcf ...);for _ ,_gdeab :=range _bcgcb {if _gdeab [1]!=""{_ebgbb :=_abce .drawSection (_gdeab [0],_gdeab [1]);for _ ,_eafc :=range _ebgbb {_cbad .Add (_eafc );};_dfcg :=_bged (_abce ._dcdge );_dfcg .SetMargins (0,0,10,0);_cbad .Add (_dfcg );};};return _cbad .GeneratePageBlocks (_daab );};

// SetLevel sets the indentation level of the TOC line.
func (_gbgec *TOCLine )SetLevel (level uint ){_gbgec ._bdfb =level ;_gbgec ._afeff ._bebaf ._feag =_gbgec ._dbaa +float64 (_gbgec ._bdfb -1)*_gbgec ._gefc ;};

// SetWidthBottom sets border width for bottom.
func (_aaeb *border )SetWidthBottom (bw float64 ){_aaeb ._aca =bw };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_eaaaf *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_defeb :=ctx ;_fcgga ,ctx ,_aeae :=_eaaaf ._afeff .GeneratePageBlocks (ctx );if _aeae !=nil {return _fcgga ,ctx ,_aeae ;};if _eaaaf ._fgff .isRelative (){ctx .X =_defeb .X ;};if _eaaaf ._fgff .isAbsolute (){return _fcgga ,_defeb ,nil ;};return _fcgga ,ctx ,nil ;};

// SetColorRight sets border color for right.
func (_cffa *border )SetColorRight (col Color ){_cffa ._gda =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};

// TextAlignment options for paragraph.
type TextAlignment int ;func (_gdca positioning )isAbsolute ()bool {return _gdca ==_cef };

// Rows returns the total number of rows the table has.
func (_gfbfc *Table )Rows ()int {return _gfbfc ._aecc };func _ebga (_fabg ,_cdda ,_abbba float64 )(_ceef ,_dcefe ,_gdbe ,_bbaa float64 ){if _abbba ==0{return 0,0,_fabg ,_cdda ;};_bcce :=_de .Path {Points :[]_de .Point {_de .NewPoint (0,0).Rotate (_abbba ),_de .NewPoint (_fabg ,0).Rotate (_abbba ),_de .NewPoint (0,_cdda ).Rotate (_abbba ),_de .NewPoint (_fabg ,_cdda ).Rotate (_abbba )}}.GetBoundingBox ();return _bcce .X ,_bcce .Y ,_bcce .Width ,_bcce .Height ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ebbe *Invoice )InfoLines ()[][2]*InvoiceCell {_fagf :=[][2]*InvoiceCell {_ebbe ._fdccd ,_ebbe ._eead ,_ebbe ._ddcd };return append (_fagf ,_ebbe ._fdcb ...);};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_gbg *Block )ScaleToWidth (w float64 ){_eb :=w /_gbg ._fd ;_gbg .Scale (_eb ,_eb )};

// SetTerms sets the terms and conditions section of the invoice.
func (_abfgc *Invoice )SetTerms (title ,content string ){_abfgc ._feae =[2]string {title ,content }};func _fcfdb (_becc string ,_efcg ,_acbb TextStyle )*TOC {_cacdf :=_acbb ;_cacdf .FontSize =14;_bgdef :=_bged (_cacdf );_bgdef .SetEnableWrap (true );_bgdef .SetTextAlignment (TextAlignmentLeft );_bgdef .SetMargins (0,0,0,5);_bcaf :=_bgdef .Append (_becc );_bcaf .Style =_cacdf ;return &TOC {_deab :_bgdef ,_eadf :[]*TOCLine {},_ffbg :_efcg ,_dddg :_efcg ,_ggggd :_efcg ,_bebc :_efcg ,_gbed :"\u002e",_gefgb :10,_aeged :margins {0,0,2,2},_dacd :_dbff ,_acfa :_efcg ,_gfcd :true };};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// GetCoords returns coordinates of border.
func (_edga *border )GetCoords ()(float64 ,float64 ){return _edga ._caa ,_edga ._bag };

// Indent returns the left offset of the list when nested into another list.
func (_eaef *List )Indent ()float64 {return _eaef ._bdea };func (_gb *Block )addContents (_dee *_cf .ContentStreamOperations ){_gb ._agg .WrapIfNeeded ();_dee .WrapIfNeeded ();*_gb ._agg =append (*_gb ._agg ,*_dee ...);};func _bbgaa (_ggeb *Block ,_fgbf *StyledParagraph ,_cdgf [][]*TextChunk ,_aacda DrawContext )(DrawContext ,[][]*TextChunk ,error ){_eaed :=1;_bgbe :=_fef .PdfObjectName (_cg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_eaed ));for _ggeb ._aac .HasFontByName (_bgbe ){_eaed ++;_bgbe =_fef .PdfObjectName (_cg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_eaed ));};_ebegc :=_ggeb ._aac .SetFontByName (_bgbe ,_fgbf ._ffga .Font .ToPdfObject ());if _ebegc !=nil {return _aacda ,nil ,_ebegc ;};_eaed ++;_afbfa :=_bgbe ;_bgeab :=_fgbf ._ffga .FontSize ;_ebed :=_fgbf ._fcee .isRelative ();var _fgedd [][]_fef .PdfObjectName ;var _bedb float64 ;var _baga [][]*TextChunk ;var _geaf float64 ;for _ccgg ,_cgaec :=range _cdgf {var _dadbc []_fef .PdfObjectName ;var _gede float64 ;for _ ,_egga :=range _cgaec {_cged :=_egga .Style ;if _ccgg ==0&&_cged .FontSize > _bedb {_bedb =_cged .FontSize ;};if _cged .FontSize > _gede {_gede =_cged .FontSize ;};_bgbe =_fef .PdfObjectName (_cg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_eaed ));_bgag :=_ggeb ._aac .SetFontByName (_bgbe ,_cged .Font .ToPdfObject ());if _bgag !=nil {return _aacda ,nil ,_bgag ;};_dadbc =append (_dadbc ,_bgbe );_eaed ++;};_gede *=_fgbf ._bgea ;if _ebed &&_geaf +_gede > _aacda .Height {_baga =_cdgf [_ccgg :];_cdgf =_cdgf [:_ccgg ];break ;};_geaf +=_gede ;_fgedd =append (_fgedd ,_dadbc );};_edea :=_cf .NewContentCreator ();_edea .Add_q ();_aadb :=_aacda .PageHeight -_aacda .Y -_bedb *_fgbf ._bgea ;_edea .Translate (_aacda .X ,_aadb );if _fgbf ._fdda !=0{_edea .RotateDeg (_fgbf ._fdda );};_edea .Add_BT ();_aebec :=_aadb ;for _dcbb ,_gfbg :=range _cdgf {_agde :=_aacda .X ;if _dcbb !=0{_edea .Add_Tstar ();};_aggd :=_dcbb ==len (_cdgf )-1;var (_cgfa float64 ;_bfde float64 ;_egad float64 ;_bcgb uint ;);var _addg []float64 ;for _ ,_bbed :=range _gfbg {_gbgeg :=&_bbed .Style ;if _gbgeg .FontSize > _bfde {_bfde =_gbgeg .FontSize ;};_gcde ,_gfecg :=_gbgeg .Font .GetRuneMetrics (' ');if !_gfecg {return _aacda ,nil ,_ef .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _fbdc uint ;var _bbdg float64 ;_aafa :=len (_bbed .Text );for _afgff ,_cffb :=range _bbed .Text {if _cffb ==' '{_fbdc ++;continue ;};if _cffb =='\u000A'{continue ;};_acgc ,_accfd :=_gbgeg .Font .GetRuneMetrics (_cffb );if !_accfd {_aae .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_cffb );return _aacda ,nil ,_ef .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bbdg +=_gbgeg .FontSize *_acgc .Wx ;if _afgff !=_aafa -1{_bbdg +=_gbgeg .CharSpacing *1000.0;};};_addg =append (_addg ,_bbdg );_cgfa +=_bbdg ;_egad +=float64 (_fbdc )*_gcde .Wx *_gbgeg .FontSize ;_bcgb +=_fbdc ;};_bfde *=_fgbf ._bgea ;var _ggggg []_fef .PdfObject ;_agbbd :=_fgbf ._fbbga *1000.0;if _fgbf ._geefg ==TextAlignmentJustify {if _bcgb > 0&&!_aggd {_egad =(_agbbd -_cgfa )/float64 (_bcgb )/_bgeab ;};}else if _fgbf ._geefg ==TextAlignmentCenter {_eeaf :=(_agbbd -_cgfa -_egad )/2;_fgbbd :=_eeaf /_bgeab ;_ggggg =append (_ggggg ,_fef .MakeFloat (-_fgbbd ));_agde +=_eeaf /1000.0;}else if _fgbf ._geefg ==TextAlignmentRight {_edda :=(_agbbd -_cgfa -_egad );_efcef :=_edda /_bgeab ;_ggggg =append (_ggggg ,_fef .MakeFloat (-_efcef ));_agde +=_edda /1000.0;};if len (_ggggg )> 0{_edea .Add_Tf (_afbfa ,_bgeab ).Add_TL (_bgeab *_fgbf ._bgea ).Add_TJ (_ggggg ...);};for _aegf ,_becg :=range _gfbg {_addcc :=&_becg .Style ;_aagdb ,_eeffe ,_bfcd :=_addcc .Color .ToRGB ();_gbbc :=_afbfa ;_bbfd :=_bgeab ;_edea .Add_Tr (int64 (_addcc .RenderingMode ));_edea .Add_Tc (_addcc .CharSpacing );if _fgbf ._geefg !=TextAlignmentJustify ||_aggd {_gcf ,_dcgf :=_addcc .Font .GetRuneMetrics (' ');if !_dcgf {return _aacda ,nil ,_ef .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_gbbc =_fgedd [_dcbb ][_aegf ];_bbfd =_addcc .FontSize ;_egad =_gcf .Wx ;};_degg :=_addcc .Font .Encoder ();var _cgcc []byte ;for _ ,_dcggc :=range _becg .Text {if _aagdb =='\u000A'{continue ;};if _dcggc ==' '{if len (_cgcc )> 0{_edea .Add_rg (_aagdb ,_eeffe ,_bfcd ).Add_Tf (_fgedd [_dcbb ][_aegf ],_addcc .FontSize ).Add_TL (_addcc .FontSize *_fgbf ._bgea ).Add_TJ ([]_fef .PdfObject {_fef .MakeStringFromBytes (_cgcc )}...);_cgcc =nil ;};_edea .Add_Tf (_gbbc ,_bbfd ).Add_TL (_bbfd *_fgbf ._bgea ).Add_TJ ([]_fef .PdfObject {_fef .MakeFloat (-_egad )}...);_addg [_aegf ]+=_egad *_bbfd ;}else {if _ ,_ecae :=_degg .RuneToCharcode (_dcggc );!_ecae {_aae .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_dcggc ,_dcggc );continue ;};_cgcc =append (_cgcc ,_degg .Encode (string (_dcggc ))...);};};if len (_cgcc )> 0{_edea .Add_rg (_aagdb ,_eeffe ,_bfcd ).Add_Tf (_fgedd [_dcbb ][_aegf ],_addcc .FontSize ).Add_TL (_addcc .FontSize *_fgbf ._bgea ).Add_TJ ([]_fef .PdfObject {_fef .MakeStringFromBytes (_cgcc )}...);};_fdeab :=_addg [_aegf ]/1000.0;if _becg ._abdg !=nil {var _fbdd *_fef .PdfObjectArray ;if !_becg ._adafb {switch _fgfd :=_becg ._abdg .GetContext ().(type ){case *_ca .PdfAnnotationLink :_fbdd =_fef .MakeArray ();_fgfd .Rect =_fbdd ;_bgdee ,_ccfed :=_fgfd .Dest .(*_fef .PdfObjectArray );if _ccfed &&_bgdee .Len ()==5{_efca ,_dbab :=_bgdee .Get (1).(*_fef .PdfObjectName );if _dbab &&_efca .String ()=="\u0058\u0059\u005a"{_dgf ,_efad :=_fef .GetNumberAsFloat (_bgdee .Get (3));if _efad ==nil {_bgdee .Set (3,_fef .MakeFloat (_aacda .PageHeight -_dgf ));};};};};_becg ._adafb =true ;};if _fbdd !=nil {_daag :=_de .NewPoint (_agde -_aacda .X ,_aebec -_aadb ).Rotate (_fgbf ._fdda );_daag .X +=_aacda .X ;_daag .Y +=_aadb ;_dfca ,_agfa ,_befda ,_ddgee :=_ebga (_fdeab ,_bfde ,_fgbf ._fdda );_daag .X +=_dfca ;_daag .Y +=_agfa ;_fbdd .Clear ();_fbdd .Append (_fef .MakeFloat (_daag .X ));_fbdd .Append (_fef .MakeFloat (_daag .Y ));_fbdd .Append (_fef .MakeFloat (_daag .X +_befda ));_fbdd .Append (_fef .MakeFloat (_daag .Y +_ddgee ));};_ggeb .AddAnnotation (_becg ._abdg );};_agde +=_fdeab ;_edea .Add_Tr (int64 (TextRenderingModeFill ));_edea .Add_Tc (0);};_aebec -=_bfde ;};_edea .Add_ET ();_edea .Add_Q ();_gabd :=_edea .Operations ();_gabd .WrapIfNeeded ();_ggeb .addContents (_gabd );if _ebed {_geeb :=_geaf +_fgbf ._bebaf ._fbbc ;_aacda .Y +=_geeb ;_aacda .Height -=_geeb ;if _aacda .Inline {_aacda .X +=_fgbf .Width ()+_fgbf ._bebaf ._ddbb ;};};return _aacda ,_baga ,nil ;};

// Height returns the height of the list.
func (_faag *List )Height ()float64 {var _dfee float64 ;for _ ,_cdde :=range _faag ._cgbfe {_dfee +=_cdde ._bgeg .Height ();};return _dfee ;};

// SetStyleLeft sets border style for left side.
func (_gag *border )SetStyleLeft (style CellBorderStyle ){_gag ._ebb =style };func (_aded *StyledParagraph )getMaxLineWidth ()float64 {if _aded ._dada ==nil ||len (_aded ._dada )==0{_aded .wrapText ();};var _fagb float64 ;for _ ,_feaeg :=range _aded ._dada {_fgbb :=_aded .getTextLineWidth (_feaeg );if _fgbb > _fagb {_fagb =_fgbb ;};};return _fagb ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_dddf float64 ;_bac float64 ;_defb float64 ;_cag float64 ;_fag float64 ;_dcfe float64 ;_cdcg *_ca .PdfColorDeviceRGB ;_bdcf float64 ;};type rgbColor struct{_degfg ,_aebc ,_abfd float64 };

// DrawWithContext draws the Block using the specified drawing context.
func (_ebd *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_fcd ,_ ,_gea :=d .GeneratePageBlocks (ctx );if _gea !=nil {return _gea ;};if len (_fcd )!=1{return _ef .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ecc :=range _fcd {if _dce :=_ebd .mergeBlocks (_ecc );_dce !=nil {return _dce ;};};return nil ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);func (_dcdd *Invoice )generateLineBlocks (_cffg DrawContext )([]*Block ,DrawContext ,error ){_abca :=_dgde (len (_dcdd ._bcdc ));_abca .SetMargins (0,0,25,0);for _ ,_edce :=range _dcdd ._bcdc {_acca :=_bged (_edce .TextStyle );_acca .SetMargins (0,0,1,0);_acca .Append (_edce .Value );_ebf :=_abca .NewCell ();_ebf .SetHorizontalAlignment (_edce .Alignment );_ebf .SetBackgroundColor (_edce .BackgroundColor );_dcdd .setCellBorder (_ebf ,_edce );_ebf .SetContent (_acca );};for _ ,_aagb :=range _dcdd ._dbcb {for _ ,_aacg :=range _aagb {_gdba :=_bged (_aacg .TextStyle );_gdba .SetMargins (0,0,3,2);_gdba .Append (_aacg .Value );_cceb :=_abca .NewCell ();_cceb .SetHorizontalAlignment (_aacg .Alignment );_cceb .SetBackgroundColor (_aacg .BackgroundColor );_dcdd .setCellBorder (_cceb ,_aacg );_cceb .SetContent (_gdba );};};return _abca .GeneratePageBlocks (_cffg );};

// CreateFrontPage sets a function to generate a front Page.
func (_ede *Creator )CreateFrontPage (genFrontPageFunc func (_dbea FrontpageFunctionArgs )){_ede ._efbd =genFrontPageFunc ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dcbag *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dcbag ._acee =halign ;};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_fcfb *Division )Width ()float64 {return 0};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_gfab []_de .CubicBezierCurve ;FillEnabled bool ;_gbge *_ca .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_fecd *_ca .PdfColorDeviceRGB ;};func (_dceb *FilledCurve )draw (_cege string )([]byte ,*_ca .PdfRectangle ,error ){_adfa :=_de .NewCubicBezierPath ();for _ ,_ccd :=range _dceb ._gfab {_adfa =_adfa .AppendCurve (_ccd );};creator :=_cf .NewContentCreator ();creator .Add_q ();if _dceb .FillEnabled {creator .Add_rg (_dceb ._gbge .R (),_dceb ._gbge .G (),_dceb ._gbge .B ());};if _dceb .BorderEnabled {creator .Add_RG (_dceb ._fecd .R (),_dceb ._fecd .G (),_dceb ._fecd .B ());creator .Add_w (_dceb .BorderWidth );};if len (_cege )> 1{creator .Add_gs (_fef .PdfObjectName (_cege ));};_de .DrawBezierPathWithCreator (_adfa ,creator );creator .Add_h ();if _dceb .FillEnabled &&_dceb .BorderEnabled {creator .Add_B ();}else if _dceb .FillEnabled {creator .Add_f ();}else if _dceb .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_bagdf :=_adfa .GetBoundingBox ();if _dceb .BorderEnabled {_bagdf .Height +=_dceb .BorderWidth ;_bagdf .Width +=_dceb .BorderWidth ;_bagdf .X -=_dceb .BorderWidth /2;_bagdf .Y -=_dceb .BorderWidth /2;};_dfg :=&_ca .PdfRectangle {};_dfg .Llx =_bagdf .X ;_dfg .Lly =_bagdf .Y ;_dfg .Urx =_bagdf .X +_bagdf .Width ;_dfg .Ury =_bagdf .Y +_bagdf .Height ;return creator .Bytes (),_dfg ,nil ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_eabd *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_cfdg :=uint (len (_eabd ._bcdc ));if index > _cfdg {index =_cfdg ;};_gdee :=_eabd .NewColumn (description );_eabd ._bcdc =append (_eabd ._bcdc [:index ],append ([]*InvoiceCell {_gdee },_eabd ._bcdc [index :]...)...);return _gdee ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_dcde *Table )MultiColCell (colspan int )*TableCell {return _dcde .newCell (colspan )};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aeag *Paragraph )SetTextAlignment (align TextAlignment ){_aeag ._ecgb =align };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_afee *Invoice )NoteHeadingStyle ()TextStyle {return _afee ._bggd };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_dcce *Paragraph )Height ()float64 {_dcce .wrapText ();return float64 (len (_dcce ._ggcd ))*_dcce ._agaee *_dcce ._fccdc ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fgcf *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _fgcf ._fdccd [0],_fgcf ._fdccd [1]};func _gebd (_abdb ,_ebcd TextStyle )*Invoice {_geff :=&Invoice {_ecad :"\u0049N\u0056\u004f\u0049\u0043\u0045",_edca :"\u002c\u0020",_dcdge :_abdb ,_bge :_ebcd };_geff ._cadff =&InvoiceAddress {Separator :_geff ._edca };_geff ._fcgg =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_geff ._edca };_begg :=ColorRGBFrom8bit (245,245,245);_bcb :=ColorRGBFrom8bit (155,155,155);_geff ._bdaa =_ebcd ;_geff ._bdaa .Color =_bcb ;_geff ._bdaa .FontSize =20;_geff ._ggab =_abdb ;_geff ._dfbf =_ebcd ;_geff ._eggfe =_abdb ;_geff ._bggd =_ebcd ;_geff ._daeg =_geff .NewCellProps ();_geff ._daeg .BackgroundColor =_begg ;_geff ._daeg .TextStyle =_ebcd ;_geff ._baf =_geff .NewCellProps ();_geff ._baf .TextStyle =_ebcd ;_geff ._baf .BackgroundColor =_begg ;_geff ._baf .BorderColor =_begg ;_geff ._fcga =_geff .NewCellProps ();_geff ._fcga .BorderColor =_begg ;_geff ._fcga .BorderSides =[]CellBorderSide {CellBorderSideBottom };_geff ._fcga .Alignment =CellHorizontalAlignmentRight ;_geff ._cfde =_geff .NewCellProps ();_geff ._cfde .Alignment =CellHorizontalAlignmentRight ;_geff ._fdccd =[2]*InvoiceCell {_geff .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_geff ._daeg ),_geff .newCell ("",_geff ._daeg )};_geff ._eead =[2]*InvoiceCell {_geff .newCell ("\u0044\u0061\u0074\u0065",_geff ._daeg ),_geff .newCell ("",_geff ._daeg )};_geff ._ddcd =[2]*InvoiceCell {_geff .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_geff ._daeg ),_geff .newCell ("",_geff ._daeg )};_geff ._adcdb =[2]*InvoiceCell {_geff .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_geff ._cfde ),_geff .newCell ("",_geff ._cfde )};_bege :=_geff ._cfde ;_bege .TextStyle =_ebcd ;_bege .BackgroundColor =_begg ;_bege .BorderColor =_begg ;_geff ._ecfce =[2]*InvoiceCell {_geff .newCell ("\u0054\u006f\u0074a\u006c",_bege ),_geff .newCell ("",_bege )};_geff ._fcac =[2]string {"\u004e\u006f\u0074e\u0073",""};_geff ._feae =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_geff ._bcdc =[]*InvoiceCell {_geff .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_geff .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_geff .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_geff .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _geff ;};

// Width returns the width of the Paragraph.
func (_acg *Paragraph )Width ()float64 {if _acg ._fcff &&int (_acg ._bdgb )> 0{return _acg ._bdgb ;};return _acg .getTextWidth ()/1000.0;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gegf *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fcdf float64 ;var _bace []*StyledParagraph ;for _ ,_ceaf :=range _gegf ._cgbfe {_fedd :=_bged (_gegf ._baef );_fedd .SetEnableWrap (false );_fedd .SetTextAlignment (TextAlignmentRight );_fedd .Append (_ceaf ._gaaag .Text ).Style =_ceaf ._gaaag .Style ;_agea :=_fedd .getTextWidth ()/1000.0/ctx .Width ;if _fcdf < _agea {_fcdf =_agea ;};_bace =append (_bace ,_fedd );};_ebccga :=_dgde (2);_ebccga .SetColumnWidths (_fcdf ,1-_fcdf );_ebccga .SetMargins (_gegf ._bdea ,0,0,0);for _gacd ,_fadd :=range _gegf ._cgbfe {_gcebb :=_ebccga .NewCell ();_gcebb .SetIndent (0);_gcebb .SetContent (_bace [_gacd ]);_gcebb =_ebccga .NewCell ();_gcebb .SetIndent (0);_gcebb .SetContent (_fadd ._bgeg );};return _ebccga .GeneratePageBlocks (ctx );};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_dcad float64 ;_dcag float64 ;_gdfd float64 ;_ebfb float64 ;_faab *_ca .PdfColorDeviceRGB ;_ggf *_ca .PdfColorDeviceRGB ;_baca float64 ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_eacgg *Image )ScaleToHeight (h float64 ){_ccec :=_eacgg ._bfaf /_eacgg ._ccdb ;_eacgg ._ccdb =h ;_eacgg ._bfaf =h *_ccec ;};

// GetOptimizer returns current PDF optimizer.
func (_dcga *Creator )GetOptimizer ()_ca .Optimizer {return _dcga ._facf };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_geg *Chapter )SetShowNumbering (show bool ){_geg ._abc =show ;_geg ._gadf .SetText (_geg .headingText ());};func _bba (_addb string ,_gab _fef .PdfObject ,_dbba *_ca .PdfPageResources )_fef .PdfObjectName {_cdc :=_ag .TrimRightFunc (_ag .TrimSpace (_addb ),func (_bec rune )bool {return _d .IsNumber (_bec )});if _cdc ==""{_cdc ="\u0046\u006f\u006e\u0074";};_bed :=0;_ggg :=_fef .PdfObjectName (_addb );for {_fca ,_ffc :=_dbba .GetFontByName (_ggg );if !_ffc ||_fca ==_gab {break ;};_bed ++;_ggg =_fef .PdfObjectName (_cg .Sprintf ("\u0025\u0073\u0025\u0064",_cdc ,_bed ));};return _ggg ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_dggb *Line )SetColor (col Color ){_dggb ._gbde =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};func _bged (_cdfdd TextStyle )*StyledParagraph {return &StyledParagraph {_gdec :[]*TextChunk {},_ffga :_cdfdd ,_ebfe :_edbec (_cdfdd .Font ),_bgea :1.0,_geefg :TextAlignmentLeft ,_bgf :true ,_afea :true ,_fdda :0,_bccaf :1,_fggbb :1,_fcee :_dbff };};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_dbbb *TOC )SetLineSeparatorStyle (style TextStyle ){_dbbb ._ggggd =style };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_bda float64 ;_bde float64 ;_cgcd float64 ;_cgbdb float64 ;_gcea *_ca .PdfColorDeviceRGB ;_efeb *_ca .PdfColorDeviceRGB ;_edbf float64 ;};func (_feaa *StyledParagraph )appendChunk (_aaeg *TextChunk )*TextChunk {_feaa ._gdec =append (_feaa ._gdec ,_aaeg );_feaa .wrapText ();return _aaeg ;};

// AddPage adds the specified page to the creator.
func (_cdff *Creator )AddPage (page *_ca .PdfPage )error {_ggca ,_beee :=page .GetMediaBox ();if _beee !=nil {_aae .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_beee );return _beee ;};_cdff ._dade .X =_ggca .Llx +_cdff ._addc ._feag ;_cdff ._dade .Y =_cdff ._addc ._ecfa ;_cdff ._dade .PageHeight =_ggca .Ury -_ggca .Lly ;_cdff ._dade .PageWidth =_ggca .Urx -_ggca .Llx ;_cdff ._feec =append (_cdff ._feec ,page );_cdff ._dade .Page ++;return nil ;};func _cga ()*Division {return &Division {_cbcg :[]VectorDrawable {}}};func _eedcd (_bbde string )*_ca .PdfAnnotation {_babf :=_ca .NewPdfAnnotationLink ();_fab :=_ca .NewBorderStyle ();_fab .SetBorderWidth (0);_babf .BS =_fab .ToPdfObject ();_bgddc :=_ca .NewPdfActionURI ();_bgddc .URI =_fef .MakeString (_bbde );_babf .SetAction (_bgddc .PdfAction );return _babf .PdfAnnotation ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_ecad string ;_aebd *Image ;_fcgg *InvoiceAddress ;_cadff *InvoiceAddress ;_edca string ;_fdccd [2]*InvoiceCell ;_eead [2]*InvoiceCell ;_ddcd [2]*InvoiceCell ;_fdcb [][2]*InvoiceCell ;_bcdc []*InvoiceCell ;_dbcb [][]*InvoiceCell ;_adcdb [2]*InvoiceCell ;_ecfce [2]*InvoiceCell ;_geca [][2]*InvoiceCell ;_fcac [2]string ;_feae [2]string ;_egfcf [][2]string ;_dcdge TextStyle ;_bge TextStyle ;_bdaa TextStyle ;_ggab TextStyle ;_dfbf TextStyle ;_eggfe TextStyle ;_bggd TextStyle ;_daeg InvoiceCellProps ;_baf InvoiceCellProps ;_fcga InvoiceCellProps ;_cfde InvoiceCellProps ;_dbeea positioning ;};

// SetFont sets the Paragraph's font.
func (_fbdbb *Paragraph )SetFont (font *_ca .PdfFont ){_fbdbb ._geegc =font };

// Columns returns all the columns in the invoice line items table.
func (_edfd *Invoice )Columns ()[]*InvoiceCell {return _edfd ._bcdc };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_febd *Creator )Draw (d Drawable )error {if _febd .getActivePage ()==nil {_febd .NewPage ();};_abd ,_dbcaf ,_dfag :=d .GeneratePageBlocks (_febd ._dade );if _dfag !=nil {return _dfag ;};for _dgg ,_ffd :=range _abd {if _dgg > 0{_febd .NewPage ();};_dedb :=_febd .getActivePage ();if _eggb ,_eeg :=_febd ._feg [_dedb ];_eeg {if _bbcc :=_eggb .mergeBlocks (_ffd );_bbcc !=nil {return _bbcc ;};if _beeca :=_dac (_ffd ._aac ,_eggb ._aac );_beeca !=nil {return _beeca ;};}else {_febd ._feg [_dedb ]=_ffd ;};};_febd ._dade .X =_dbcaf .X ;_febd ._dade .Y =_dbcaf .Y ;_febd ._dade .Height =_dbcaf .PageHeight -_dbcaf .Y -_dbcaf .Margins ._fbbc ;return nil ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_gbbf *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _gbbf ._dgcg ,_gbbf ._dfae ,_gbbf ._gbbd ,_gbbf ._dgcga ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_efc *Block )Draw (d Drawable )error {_ecd :=DrawContext {};_ecd .Width =_efc ._fd ;_ecd .Height =_efc ._eg ;_ecd .PageWidth =_efc ._fd ;_ecd .PageHeight =_efc ._eg ;_ecd .X =0;_ecd .Y =0;_fbe ,_ ,_egg :=d .GeneratePageBlocks (_ecd );if _egg !=nil {return _egg ;};if len (_fbe )!=1{return _ef .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_dfd :=range _fbe {if _fc :=_efc .mergeBlocks (_dfd );_fc !=nil {return _fc ;};};return nil ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_geb *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bf :=_cf .NewContentCreator ();_ec ,_fdc :=_geb .Width (),_geb .Height ();if _geb ._ge .isRelative (){_bf .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_fdc );}else {_bf .Translate (_geb ._ad ,ctx .PageHeight -_geb ._ae -_fdc );};_fbd :=_fdc ;if _geb ._cgf !=0{_bf .Translate (_ec /2,_fdc /2);_bf .RotateDeg (_geb ._cgf );_bf .Translate (-_ec /2,-_fdc /2);_ ,_fbd =_geb .RotatedSize ();};if _geb ._ge .isRelative (){ctx .Y +=_fbd ;};_cc :=_geb .duplicate ();_bfa :=append (*_bf .Operations (),*_cc ._agg ...);_bfa .WrapIfNeeded ();_cc ._agg =&_bfa ;return []*Block {_cc },ctx ,nil ;};

// Cols returns the total number of columns the table has.
func (_gbdc *Table )Cols ()int {return _gbdc ._caef };

// GeneratePageBlocks generates a page break block.
func (_dfcf *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_begeb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_cegg :=ctx ;_cegg .Y =ctx .Margins ._ecfa ;_cegg .X =ctx .Margins ._feag ;_cegg .Height =ctx .PageHeight -ctx .Margins ._ecfa -ctx .Margins ._fbbc ;_cegg .Width =ctx .PageWidth -ctx .Margins ._feag -ctx .Margins ._ddbb ;ctx =_cegg ;return _begeb ,ctx ,nil ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ca .PdfPage )(*Block ,error ){_fg :=&Block {};_db ,_aagg :=page .GetAllContentStreams ();if _aagg !=nil {return nil ,_aagg ;};_ac :=_cf .NewContentStreamParser (_db );_dd ,_aagg :=_ac .Parse ();if _aagg !=nil {return nil ,_aagg ;};_dd .WrapIfNeeded ();_fg ._agg =_dd ;if page .Resources !=nil {_fg ._aac =page .Resources ;}else {_fg ._aac =_ca .NewPdfPageResources ();};_fgg ,_aagg :=page .GetMediaBox ();if _aagg !=nil {return nil ,_aagg ;};if _fgg .Llx !=0||_fgg .Lly !=0{_fg .translate (-_fgg .Llx ,_fgg .Lly );};_fg ._fd =_fgg .Urx -_fgg .Llx ;_fg ._eg =_fgg .Ury -_fgg .Lly ;if page .Rotate !=nil {_fg ._cgf =-float64 (*page .Rotate );};return _fg ,nil ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_fggf *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_fggf ._gfc =toc ;};

// AddSection adds a new content section at the end of the invoice.
func (_aedg *Invoice )AddSection (title ,content string ){_aedg ._egfcf =append (_aedg ._egfcf ,[2]string {title ,content });};func _bcab (_deb ,_cbbd ,_fadg string ,_adg uint ,_ccdc TextStyle )*TOCLine {return _dfbc (TextChunk {Text :_deb ,Style :_ccdc },TextChunk {Text :_cbbd ,Style :_ccdc },TextChunk {Text :_fadg ,Style :_ccdc },_adg ,_ccdc );};

// Height returns the Block's height.
func (_aba *Block )Height ()float64 {return _aba ._eg };

// AddTotalLine adds a new line in the invoice totals table.
func (_febgd *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_befd :=&InvoiceCell {_febgd ._cfde ,desc };_gebdf :=&InvoiceCell {_febgd ._cfde ,value };_febgd ._geca =append (_febgd ._geca ,[2]*InvoiceCell {_befd ,_gebdf });return _befd ,_gebdf ;};

// Context returns the current drawing context.
func (_fgcb *Creator )Context ()DrawContext {return _fgcb ._dade };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fead *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_aedee :=_bged (_fead ._baef );_aedee .Append (text );_dcae ,_edcf :=_fead .Add (_aedee );return _aedee ,_dcae ,_edcf ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_eccef *StyledParagraph )SetEnableWrap (enableWrap bool ){_eccef ._bgf =enableWrap ;_eccef ._afea =false ;};

// Text sets the text content of the Paragraph.
func (_faeag *Paragraph )Text ()string {return _faeag ._ddfc };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Width returns the Block's width.
func (_bg *Block )Width ()float64 {return _bg ._fd };func (_acggd *StyledParagraph )getTextLineWidth (_beeg []*TextChunk )float64 {var _bbga float64 ;_adag :=len (_beeg );for _edbd ,_gabb :=range _beeg {_adda :=&_gabb .Style ;_edcfd :=len (_gabb .Text );for _gcb ,_aaege :=range _gabb .Text {if _aaege =='\u000A'{continue ;};_ffeg ,_fged :=_adda .Font .GetRuneMetrics (_aaege );if !_fged {_aae .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_aaege );return -1;};_bbga +=_adda .FontSize *_ffeg .Wx ;if _aaege !=' '&&(_edbd !=_adag -1||_gcb !=_edcfd -1){_bbga +=_adda .CharSpacing *1000.0;};};};return _bbga ;};func _dcgb (_cfca ,_eeff ,_bfdba ,_agbb float64 )*Rectangle {_cdgc :=&Rectangle {};_cdgc ._dcad =_cfca ;_cdgc ._dcag =_eeff ;_cdgc ._gdfd =_bfdba ;_cdgc ._ebfb =_agbb ;_cdgc ._ggf =_ca .NewPdfColorDeviceRGB (0,0,0);_cdgc ._baca =1.0;return _cdgc ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_gbgf *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_becfb ,_fcbf :=_gbgf .Wrap (width );if _fcbf !=nil {return nil ,_fcbf ;};_fbee :=int (height /_gbgf .Style .FontSize );if _fbee >=len (_becfb ){return nil ,nil ;};_gddff :="\u000a";_gbgf .Text =_ag .Replace (_ag .Join (_becfb [:_fbee ],"\u0020"),_gddff +"\u0020",_gddff ,-1);_bdgdg :=_ag .Replace (_ag .Join (_becfb [_fbee :],"\u0020"),_gddff +"\u0020",_gddff ,-1);return NewTextChunk (_bdgdg ,_gbgf .Style ),nil ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_cbf *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggcb :=ctx ;if _cbf ._bfda .isRelative (){ctx .X +=_cbf ._ege ._feag ;ctx .Y +=_cbf ._ege ._ecfa ;ctx .Width -=_cbf ._ege ._feag +_cbf ._ege ._ddbb ;ctx .Height -=_cbf ._ege ._ecfa ;};_gbf ,_agf ,_aaf :=_cbf ._gadf .GeneratePageBlocks (ctx );if _aaf !=nil {return _gbf ,ctx ,_aaf ;};ctx =_agf ;_efaa :=ctx .X ;_aeb :=ctx .Y -_cbf ._gadf .Height ();_aee :=int64 (ctx .Page );_cadf :=_cbf .headingNumber ();_bagd :=_cbf .headingText ();if _cbf ._gde {_degf :=_cbf ._fdag .Add (_cadf ,_cbf ._fac ,_fe .FormatInt (_aee ,10),_cbf ._dgc );if _cbf ._fdag ._gfcd {_degf .SetLink (_aee ,_efaa ,_aeb );};};if _cbf ._gcc ==nil {_cbf ._gcc =_ca .NewOutlineItem (_bagd ,_ca .NewOutlineDest (_aee -1,_efaa ,_aeb ));if _cbf ._gee !=nil {_cbf ._gee ._gcc .Add (_cbf ._gcc );}else {_cbf ._cddfb .Add (_cbf ._gcc );};}else {_bfg :=&_cbf ._gcc .Dest ;_bfg .Page =_aee -1;_bfg .X =_efaa ;_bfg .Y =_aeb ;};for _ ,_gfa :=range _cbf ._deef {_gaf ,_efeg ,_ebcf :=_gfa .GeneratePageBlocks (ctx );if _ebcf !=nil {return _gbf ,ctx ,_ebcf ;};if len (_gaf )< 1{continue ;};_gbf [len (_gbf )-1].mergeBlocks (_gaf [0]);_gbf =append (_gbf ,_gaf [1:]...);ctx =_efeg ;};if _cbf ._bfda .isRelative (){ctx .X =_ggcb .X ;};if _cbf ._bfda .isAbsolute (){return _gbf ,_ggcb ,nil ;};return _gbf ,ctx ,nil ;};func (_fgee *Chapter )headingNumber ()string {var _cffe string ;if _fgee ._abc {if _fgee ._edf !=0{_cffe =_fe .Itoa (_fgee ._edf )+"\u002e";};if _fgee ._gee !=nil {_afa :=_fgee ._gee .headingNumber ();if _afa !=""{_cffe =_afa +_cffe ;};};};return _cffe ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ebcbf *Image )ScaleToWidth (w float64 ){_dfda :=_ebcbf ._ccdb /_ebcbf ._bfaf ;_ebcbf ._bfaf =w ;_ebcbf ._ccdb =w *_dfda ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_bfdb *Chapter )NewSubchapter (title string )*Chapter {_cddc :=_gbdg (_bfdb ._gadf ._geegc );_cddc .FontSize =14;_bfdb ._abf ++;_dda :=_fcgb (_bfdb ,_bfdb ._fdag ,_bfdb ._cddfb ,title ,_bfdb ._abf ,_cddc );_bfdb .Add (_dda );return _dda ;};

// CurRow returns the currently active cell's row number.
func (_gaag *Table )CurRow ()int {_egb :=(_gaag ._fdgcg -1)/_gaag ._caef +1;return _egb };

// SetPos sets absolute positioning with specified coordinates.
func (_eafa *Paragraph )SetPos (x ,y float64 ){_eafa ._gbfc =_cef ;_eafa ._accf =x ;_eafa ._gfge =y };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_bacc *TOCLine )SetStyle (style TextStyle ){_bacc .Number .Style =style ;_bacc .Title .Style =style ;_bacc .Separator .Style =style ;_bacc .Page .Style =style ;};

// SetBorderColor sets the border color for the path.
func (_ecce *FilledCurve )SetBorderColor (color Color ){_ecce ._fecd =_ca .NewPdfColorDeviceRGB (color .ToRGB ());};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_cgcb *Invoice )SetNoteStyle (style TextStyle ){_cgcb ._eggfe =style };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_ccfb *TOC )SetLinePageStyle (style TextStyle ){_ccfb ._bebc =style };

// SetLineWidth sets the line width.
func (_fcb *Line )SetLineWidth (lw float64 ){_fcb ._adcc =lw };func _afbf (_ccfe string ,_fdacb TextStyle )*Paragraph {_geea :=&Paragraph {_ddfc :_ccfe ,_geegc :_fdacb .Font ,_fccdc :_fdacb .FontSize ,_agaee :1.0,_fcff :true ,_afga :true ,_ecgb :TextAlignmentLeft ,_eefc :0,_caea :1,_bgac :1,_gbfc :_dbff };_geea .SetColor (_fdacb .Color );return _geea ;};

// Add adds a new Drawable to the chapter.
func (_dcd *Chapter )Add (d Drawable )error {if Drawable (_dcd )==d {_aae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _ef .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_dcd ._deef =append (_dcd ._deef ,d );default:_aae .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _ef .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// Title returns the title of the invoice.
func (_gfae *Invoice )Title ()string {return _gfae ._ecad };func (_bcbfg *Invoice )generateHeaderBlocks (_ccge DrawContext )([]*Block ,DrawContext ,error ){_dbed :=_bged (_bcbfg ._bdaa );_dbed .SetEnableWrap (true );_dbed .Append (_bcbfg ._ecad );_dcgd :=_dgde (2);if _bcbfg ._aebd !=nil {_efbc :=_dcgd .NewCell ();_efbc .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_efbc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_efbc .SetIndent (0);_efbc .SetContent (_bcbfg ._aebd );_bcbfg ._aebd .ScaleToHeight (_dbed .Height ()+20);}else {_dcgd .SkipCells (1);};_abagb :=_dcgd .NewCell ();_abagb .SetHorizontalAlignment (CellHorizontalAlignmentRight );_abagb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_abagb .SetContent (_dbed );return _dcgd .GeneratePageBlocks (_ccge );};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_bead *TOC )SetLineLevelOffset (levelOffset float64 ){_bead ._gefgb =levelOffset };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_caff *StyledParagraph )Height ()float64 {_caff .wrapText ();var _ceaa float64 ;for _ ,_fbcf :=range _caff ._dada {var _acgg float64 ;for _ ,_gbffg :=range _fbcf {_afdb :=_caff ._bgea *_gbffg .Style .FontSize ;if _afdb > _acgg {_acgg =_afdb ;};};_ceaa +=_acgg ;};return _ceaa ;};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_eabb *Creator )SetForms (form *_ca .PdfAcroForm )error {_eabb ._gcgg =form ;return nil };func (_ebdd *TOCLine )getLineLink ()*_ca .PdfAnnotation {if _ebdd ._gaed <=0{return nil ;};return _ccgd (_ebdd ._gaed -1,_ebdd ._dcfc ,_ebdd ._fbdgad ,0);};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eagf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _eagf ._adcdb [0],_eagf ._adcdb [1];};

// SetRowHeight sets the height for a specified row.
func (_gcaf *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_gcaf ._febf ){return _ef .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gcaf ._febf [row -1]=h ;return nil ;};

// SetAngle sets the rotation angle in degrees.
func (_fb *Block )SetAngle (angleDeg float64 ){_fb ._cgf =angleDeg };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_gadd *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_ccgae :=range subtable ._gaafc {_bfbbeg :=&TableCell {};*_bfbbeg =*_ccgae ;_bfbbeg ._aeaf =_gadd ;_bfbbeg ._aaee +=col -1;if _bbabf :=_gadd ._caef -(_bfbbeg ._aaee -1);_bbabf < _bfbbeg ._cecd {_gadd ._caef +=_bfbbeg ._cecd -_bbabf ;_gadd .resetColumnWidths ();_aae .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_gadd ._caef );};_bfbbeg ._bgeb +=row -1;_gecf :=subtable ._febf [_ccgae ._bgeb -1];if _bfbbeg ._bgeb > _gadd ._aecc {for _bfbbeg ._bgeb > _gadd ._aecc {_gadd ._aecc ++;_gadd ._febf =append (_gadd ._febf ,_gadd ._dcfg );};_gadd ._febf [_bfbbeg ._bgeb -1]=_gecf ;}else {_gadd ._febf [_bfbbeg ._bgeb -1]=_f .Max (_gadd ._febf [_bfbbeg ._bgeb -1],_gecf );};_gadd ._gaafc =append (_gadd ._gaafc ,_bfbbeg );};_a .Slice (_gadd ._gaafc ,func (_cfdb ,_fbfg int )bool {_efbgc :=_gadd ._gaafc [_cfdb ]._bgeb ;_fedag :=_gadd ._gaafc [_fbfg ]._bgeb ;if _efbgc < _fedag {return true ;};if _efbgc > _fedag {return false ;};return _gadd ._gaafc [_cfdb ]._aaee < _gadd ._gaafc [_fbfg ]._aaee ;});};func _edbec (_dbeaa *_ca .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_dbeaa ,FontSize :10};};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_bfceb *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_abef :=&_bfceb ._afeff ._bebaf ;return _bfceb ._dbaa ,_abef ._ddbb ,_abef ._ecfa ,_abef ._fbbc ;};

// SetLineHeight sets the line height (1.0 default).
func (_fbgg *Paragraph )SetLineHeight (lineheight float64 ){_fbgg ._agaee =lineheight };

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_gaae *Invoice )SetNoteHeadingStyle (style TextStyle ){_gaae ._bggd =style };

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_egdce *Rectangle )GetCoords ()(float64 ,float64 ){return _egdce ._dcad ,_egdce ._dcag };

// GeneratePageBlocks draws the curve onto page blocks.
func (_dgca *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbcc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _dcec []string ;_dcec =append (_dcec ,_cg .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_dgca ._bdcf ));_dcec =append (_dcec ,_cg .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_dgca ._cdcg [0],_dgca ._cdcg [1],_dgca ._cdcg [2]));_dcec =append (_dcec ,_cg .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_dgca ._dddf ,ctx .PageHeight -_dgca ._bac ));_dcec =append (_dcec ,_cg .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_dgca ._defb ,ctx .PageHeight -_dgca ._cag ,_dgca ._fag ,ctx .PageHeight -_dgca ._dcfe ));_eef :=_cbcc .addContentsByString (_ag .Join (_dcec ,"\u000a"));if _eef !=nil {return nil ,ctx ,_eef ;};return []*Block {_cbcc },ctx ,nil ;};func _ebaf (_cffc ,_cbea ,_ecbd ,_bdag float64 )*Ellipse {_acd :=&Ellipse {};_acd ._bda =_cffc ;_acd ._bde =_cbea ;_acd ._cgcd =_ecbd ;_acd ._cgbdb =_bdag ;_acd ._efeb =_ca .NewPdfColorDeviceRGB (0,0,0);_acd ._edbf =1.0;return _acd ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_abfgd *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _abfgd ._ddcd [0],_abfgd ._ddcd [1];};

// GetRowHeight returns the height of the specified row.
func (_deac *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_deac ._febf ){return 0,_ef .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _deac ._febf [row -1],nil ;};

// SetStyleBottom sets border style for bottom side.
func (_dec *border )SetStyleBottom (style CellBorderStyle ){_dec ._aef =style };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_dea *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dea ._ege ._feag ,_dea ._ege ._ddbb ,_dea ._ege ._ecfa ,_dea ._ege ._fbbc ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_becec *Creator )MoveTo (x ,y float64 ){_becec ._dade .X =x ;_becec ._dade .Y =y };

// Level returns the indentation level of the TOC line.
func (_befdg *TOCLine )Level ()uint {return _befdg ._bdfb };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_faedf *TOCLine )SetLink (page int64 ,x ,y float64 ){_faedf ._dcfc =x ;_faedf ._fbdgad =y ;_faedf ._gaed =page ;_fcgbf :=_faedf ._afeff ._ebfe .Color ;_faedf .Number .Style .Color =_fcgbf ;_faedf .Title .Style .Color =_fcgbf ;_faedf .Separator .Style .Color =_fcgbf ;_faedf .Page .Style .Color =_fcgbf ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_ebbb *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_ebbb ._addc ._feag =left ;_ebbb ._addc ._ddbb =right ;_ebbb ._addc ._ecfa =top ;_ebbb ._addc ._fbbc =bottom ;};

// Write output of creator to io.Writer interface.
func (_ddd *Creator )Write (ws _g .Writer )error {if _cefb :=_ddd .Finalize ();_cefb !=nil {return _cefb ;};_edac :=_ca .NewPdfWriter ();_edac .SetOptimizer (_ddd ._facf );if _ddd ._gcgg !=nil {_dgbe :=_edac .SetForms (_ddd ._gcgg );if _dgbe !=nil {_aae .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_dgbe );return _dgbe ;};};if _ddd ._fcc !=nil {_edac .AddOutlineTree (_ddd ._fcc );}else if _ddd ._gfaa !=nil &&_ddd .AddOutlines {_edac .AddOutlineTree (&_ddd ._gfaa .ToPdfOutline ().PdfOutlineTreeNode );};if _ddd ._fccd !=nil {if _cfe :=_edac .SetPageLabels (_ddd ._fccd );_cfe !=nil {_aae .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_cfe );return _cfe ;};};if _ddd ._aefa !=nil {for _ ,_cfgd :=range _ddd ._aefa {_caae :=_cfgd .SubsetRegistered ();if _caae !=nil {_aae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_caae );return _caae ;};};};if _ddd ._ddge !=nil {_fbg :=_ddd ._ddge (&_edac );if _fbg !=nil {_aae .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fbg );return _fbg ;};};for _ ,_efd :=range _ddd ._feec {_ffed :=_edac .AddPage (_efd );if _ffed !=nil {_aae .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_ffed );return _ffed ;};};_cfcg :=_edac .Write (ws );if _cfcg !=nil {return _cfcg ;};return nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aec *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aec ._ecfg ._feag ,_aec ._ecfg ._ddbb ,_aec ._ecfg ._ecfa ,_aec ._ecfg ._fbbc ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};type listItem struct{_bgeg VectorDrawable ;_gaaag TextChunk ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_bfbd *Table )SetMargins (left ,right ,top ,bottom float64 ){_bfbd ._gafag ._feag =left ;_bfbd ._gafag ._ddbb =right ;_bfbd ._gafag ._ecfa =top ;_bfbd ._gafag ._fbbc =bottom ;};func (_edfg rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _edfg ._degfg ,_edfg ._aebc ,_edfg ._abfd ;};

// SetMargins sets the margins of the paragraph.
func (_afgf *List )SetMargins (left ,right ,top ,bottom float64 ){_afgf ._gefg ._feag =left ;_afgf ._gefg ._ddbb =right ;_afgf ._gefg ._ecfa =top ;_afgf ._gefg ._fbbc =bottom ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_abcb *Image )GetHorizontalAlignment ()HorizontalAlignment {return _abcb ._bcfa };

// NewImageFromData creates an Image from image data.
func (_cgef *Creator )NewImageFromData (data []byte )(*Image ,error ){return _aadd (data )};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_fbdga *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_fbdga .Text },nil ;};var _dcebf []string ;var _bcbg []rune ;var _affa float64 ;var _fdce []float64 ;_bccg :=_fbdga .Style ;_fbca :=[]rune (_fbdga .Text );for _ ,_geafe :=range _fbca {if _geafe =='\u000A'{_dcebf =append (_dcebf ,_ag .TrimRightFunc (string (_bcbg ),_d .IsSpace )+string (_geafe ));_bcbg =nil ;_affa =0;_fdce =nil ;continue ;};_fgge :=_geafe ==' ';_aecb ,_eddf :=_bccg .Font .GetRuneMetrics (_geafe );if !_eddf {_aae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_geafe ,_geafe ,_bccg .Font .BaseFont (),_bccg .Font .Subtype ());_aae .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bccg .Font );_aae .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bccg .Font .Encoder ());return nil ,_ef .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_dddc :=_bccg .FontSize *_aecb .Wx ;_bggdb :=_dddc ;if !_fgge {_bggdb =_dddc +_bccg .CharSpacing *1000.0;};if _affa +_dddc > width *1000.0{_bdcfb :=-1;if !_fgge {for _eggbb :=len (_bcbg )-1;_eggbb >=0;_eggbb --{if _bcbg [_eggbb ]==' '{_bdcfb =_eggbb ;break ;};};};_gdgc :=string (_bcbg );if _bdcfb > 0{_gdgc =string (_bcbg [0:_bdcfb +1]);_bcbg =append (_bcbg [_bdcfb +1:],_geafe );_fdce =append (_fdce [_bdcfb +1:],_bggdb );_affa =0;for _ ,_bdba :=range _fdce {_affa +=_bdba ;};}else {if _fgge {_bcbg =[]rune {};_fdce =[]float64 {};_affa =0;}else {_bcbg =[]rune {_geafe };_fdce =[]float64 {_bggdb };_affa =_bggdb ;};};_dcebf =append (_dcebf ,_ag .TrimRightFunc (_gdgc ,_d .IsSpace ));}else {_bcbg =append (_bcbg ,_geafe );_affa +=_bggdb ;_fdce =append (_fdce ,_bggdb );};};if len (_bcbg )> 0{_dcebf =append (_dcebf ,string (_bcbg ));};return _dcebf ,nil ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_cfeb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_cfeb ._bbeb =valign };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_dadb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _dfbc (number ,title ,page ,level ,style );};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ecfc *Creator )SetPageLabels (pageLabels _fef .PdfObject ){_ecfc ._fccd =pageLabels };

// Width returns Image's document width.
func (_fcag *Image )Width ()float64 {return _fcag ._bfaf };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_adfd *List )Add (item VectorDrawable )(*TextChunk ,error ){_gafb :=&listItem {_bgeg :item ,_gaaag :_adfd ._deaf };switch _aedga :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _aedga ._bbbc {_aedga ._bdea =15;};default:return nil ,_ef .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_adfd ._cgbfe =append (_adfd ._cgbfe ,_gafb );return &_gafb ._gaaag ,nil ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_gfe *Block )ScaleToHeight (h float64 ){_gff :=h /_gfe ._eg ;_gfe .Scale (_gff ,_gff )};

// Length calculates and returns the line length.
func (_cdg *Line )Length ()float64 {return _f .Sqrt (_f .Pow (_cdg ._gbbd -_cdg ._dgcg ,2.0)+_f .Pow (_cdg ._dgcga -_cdg ._dfae ,2.0));};func (_aacd *Paragraph )wrapText ()error {if !_aacd ._fcff ||int (_aacd ._bdgb )<=0{_aacd ._ggcd =[]string {_aacd ._ddfc };return nil ;};_gfcf :=NewTextChunk (_aacd ._ddfc ,TextStyle {Font :_aacd ._geegc ,FontSize :_aacd ._fccdc });_bfe ,_abfgf :=_gfcf .Wrap (_aacd ._bdgb );if _abfgf !=nil {return _abfgf ;};_aacd ._ggcd =_bfe ;return nil ;};func (_df *Block )duplicate ()*Block {_gd :=&Block {};*_gd =*_df ;_gdg :=_cf .ContentStreamOperations {};for _ ,_cgg :=range *_df ._agg {_gdg =append (_gdg ,_cgg );};_gd ._agg =&_gdg ;return _gd ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_feaff *Creator )NewParagraph (text string )*Paragraph {return _afbf (text ,_feaff .NewTextStyle ());};

// Margins returns the margins of the list: left, right, top, bottom.
func (_cgde *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _cgde ._gefg ._feag ,_cgde ._gefg ._ddbb ,_cgde ._gefg ._ecfa ,_cgde ._gefg ._fbbc ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ebafb *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _ebafb ._eead [0],_ebafb ._eead [1]};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_cfbeg *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_fgca :=NewTextChunk (text ,_cfbeg ._ebfe );_fgca ._abdg =_eedcd (url );return _cfbeg .appendChunk (_fgca );};

// SetColor sets the line color.
func (_cgeb *Curve )SetColor (col Color ){_cgeb ._cdcg =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};func (_bcc *Block )addContentsByString (_egf string )error {_ccb :=_cf .NewContentStreamParser (_egf );_ba ,_cgd :=_ccb .Parse ();if _cgd !=nil {return _cgd ;};_bcc ._agg .WrapIfNeeded ();_ba .WrapIfNeeded ();*_bcc ._agg =append (*_bcc ._agg ,*_ba ...);return nil ;};func (_edba *StyledParagraph )wrapText ()error {if !_edba ._bgf ||int (_edba ._fbbga )<=0{_edba ._dada =[][]*TextChunk {_edba ._gdec };return nil ;};_edba ._dada =[][]*TextChunk {};var _cgbc []*TextChunk ;var _dcca float64 ;_dcba :=func (_abcg *_ca .PdfAnnotation )*_ca .PdfAnnotation {if _abcg ==nil {return nil ;};var _afeb *_ca .PdfAnnotation ;switch _fdea :=_abcg .GetContext ().(type ){case *_ca .PdfAnnotationLink :if _dcgg :=_aebcg (_fdea );_dcgg !=nil {_afeb =_dcgg .PdfAnnotation ;};};return _afeb ;};for _ ,_ebfc :=range _edba ._gdec {_ebeg :=_ebfc .Style ;_dgcab :=_ebfc ._abdg ;var (_fcffg []rune ;_caeab []float64 ;);for _ ,_gbfa :=range _ebfc .Text {if _gbfa =='\u000A'{_cgbc =append (_cgbc ,&TextChunk {Text :_ag .TrimRightFunc (string (_fcffg ),_d .IsSpace ),Style :_ebeg ,_abdg :_dcba (_dgcab )});_edba ._dada =append (_edba ._dada ,_cgbc );_cgbc =nil ;_dcca =0;_fcffg =nil ;_caeab =nil ;continue ;};_ffef :=_gbfa ==' ';_cecg ,_efge :=_ebeg .Font .GetRuneMetrics (_gbfa );if !_efge {_aae .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_gbfa );return _ef .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_feadb :=_ebeg .FontSize *_cecg .Wx ;_dbgg :=_feadb ;if !_ffef {_dbgg =_feadb +_ebeg .CharSpacing *1000.0;};if _dcca +_feadb > _edba ._fbbga *1000.0{_bgae :=-1;if !_ffef {for _gabg :=len (_fcffg )-1;_gabg >=0;_gabg --{if _fcffg [_gabg ]==' '{_bgae =_gabg ;break ;};};};_cdfda :=string (_fcffg );if _bgae >=0{_cdfda =string (_fcffg [0:_bgae +1]);_fcffg =_fcffg [_bgae +1:];_fcffg =append (_fcffg ,_gbfa );_caeab =_caeab [_bgae +1:];_caeab =append (_caeab ,_dbgg );_dcca =0;for _ ,_ccdg :=range _caeab {_dcca +=_ccdg ;};}else {if _ffef {_dcca =0;_fcffg =[]rune {};_caeab =[]float64 {};}else {_dcca =_dbgg ;_fcffg =[]rune {_gbfa };_caeab =[]float64 {_dbgg };};};_cgbc =append (_cgbc ,&TextChunk {Text :_ag .TrimRightFunc (string (_cdfda ),_d .IsSpace ),Style :_ebeg ,_abdg :_dcba (_dgcab )});_edba ._dada =append (_edba ._dada ,_cgbc );_cgbc =[]*TextChunk {};}else {_dcca +=_dbgg ;_fcffg =append (_fcffg ,_gbfa );_caeab =append (_caeab ,_dbgg );};};if len (_fcffg )> 0{_cgbc =append (_cgbc ,&TextChunk {Text :string (_fcffg ),Style :_ebeg ,_abdg :_dcba (_dgcab )});};};if len (_cgbc )> 0{_edba ._dada =append (_edba ._dada ,_cgbc );};return nil ;};func _ccgd (_eccf int64 ,_adad ,_fafbd ,_dcaeb float64 )*_ca .PdfAnnotation {_abbf :=_ca .NewPdfAnnotationLink ();_dgbc :=_ca .NewBorderStyle ();_dgbc .SetBorderWidth (0);_abbf .BS =_dgbc .ToPdfObject ();if _eccf < 0{_eccf =0;};_abbf .Dest =_fef .MakeArray (_fef .MakeInteger (_eccf ),_fef .MakeName ("\u0058\u0059\u005a"),_fef .MakeFloat (_adad ),_fef .MakeFloat (_fafbd ),_fef .MakeFloat (_dcaeb ));return _abbf .PdfAnnotation ;};

// SetMargins sets the margins TOC line.
func (_fgcbb *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_fgcbb ._dbaa =left ;_bgba :=&_fgcbb ._afeff ._bebaf ;_bgba ._feag =_fgcbb ._dbaa +float64 (_fgcbb ._bdfb -1)*_fgcbb ._gefc ;_bgba ._ddbb =right ;_bgba ._ecfa =top ;_bgba ._fbbc =bottom ;};

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_fcdb *Division )Height ()float64 {_baeee :=0.0;_abfe :=0.0;for _ ,_adb :=range _fcdb ._cbcg {_fbf ,_cafb :=_adb .Width (),_adb .Height ();switch _ecdgg :=_adb .(type ){case *Paragraph :_cdef :=_ecdgg ;_fbf +=_cdef ._ecfg ._feag +_cdef ._ecfg ._ddbb ;_cafb +=_cdef ._ecfg ._ecfa +_cdef ._ecfg ._fbbc ;case *StyledParagraph :_cee :=_ecdgg ;_fbf +=_cee ._bebaf ._feag +_cee ._bebaf ._ddbb ;_cafb +=_cee ._bebaf ._ecfa +_cee ._bebaf ._fbbc ;};_baeee +=_cafb ;_abfe =_baeee ;};return _abfe ;};

// SetInline sets the inline mode of the division.
func (_eaaf *Division )SetInline (inline bool ){_eaaf ._edbc =inline };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_eefb *Image )ConvertToBinary ()error {return _eefb ._fedfg .ConvertToBinary ()};

// Lines returns all the lines the table of contents has.
func (_ebbc *TOC )Lines ()[]*TOCLine {return _ebbc ._eadf };

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_ca .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};func (_ggd *Creator )initContext (){_ggd ._dade .X =_ggd ._addc ._feag ;_ggd ._dade .Y =_ggd ._addc ._ecfa ;_ggd ._dade .Width =_ggd ._dadc -_ggd ._addc ._ddbb -_ggd ._addc ._feag ;_ggd ._dade .Height =_ggd ._fgc -_ggd ._addc ._fbbc -_ggd ._addc ._ecfa ;_ggd ._dade .PageHeight =_ggd ._fgc ;_ggd ._dade .PageWidth =_ggd ._dadc ;_ggd ._dade .Margins =_ggd ._addc ;};func _ddgd (_deff *_c .File )([]*_ca .PdfPage ,error ){_fcdc ,_bccd :=_ca .NewPdfReader (_deff );if _bccd !=nil {return nil ,_bccd ;};_fccg ,_bccd :=_fcdc .GetNumPages ();if _bccd !=nil {return nil ,_bccd ;};var _abdf []*_ca .PdfPage ;for _dead :=0;_dead < _fccg ;_dead ++{_gdeec ,_cbbb :=_fcdc .GetPage (_dead +1);if _cbbb !=nil {return nil ,_cbbb ;};_abdf =append (_abdf ,_gdeec );};return _abdf ,nil ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetSubtotal sets the subtotal of the invoice.
func (_baade *Invoice )SetSubtotal (value string ){_baade ._adcdb [1].Value =value };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_afdc *TOC )SetLineTitleStyle (style TextStyle ){_afdc ._dddg =style };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_eecg *Creator )SetOptimizer (optimizer _ca .Optimizer ){_eecg ._facf =optimizer };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_dfed *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebce :=ctx ;var _dgeb []*Block ;_dadg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dfed ._gbfc .isRelative (){ctx .X +=_dfed ._ecfg ._feag ;ctx .Y +=_dfed ._ecfg ._ecfa ;ctx .Width -=_dfed ._ecfg ._feag +_dfed ._ecfg ._ddbb ;ctx .Height -=_dfed ._ecfg ._ecfa +_dfed ._ecfg ._fbbc ;_dfed .SetWidth (ctx .Width );if _dfed .Height ()> ctx .Height {_dgeb =append (_dgeb ,_dadg );_dadg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_efde :=ctx ;_efde .Y =ctx .Margins ._ecfa ;_efde .X =ctx .Margins ._feag +_dfed ._ecfg ._feag ;_efde .Height =ctx .PageHeight -ctx .Margins ._ecfa -ctx .Margins ._fbbc -_dfed ._ecfg ._fbbc ;_efde .Width =ctx .PageWidth -ctx .Margins ._feag -ctx .Margins ._ddbb -_dfed ._ecfg ._feag -_dfed ._ecfg ._ddbb ;ctx =_efde ;};}else {if int (_dfed ._bdgb )<=0{_dfed .SetWidth (_dfed .getTextWidth ());};ctx .X =_dfed ._accf ;ctx .Y =_dfed ._gfge ;};ctx ,_cbgf :=_dgbd (_dadg ,_dfed ,ctx );if _cbgf !=nil {_aae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cbgf );return nil ,ctx ,_cbgf ;};_dgeb =append (_dgeb ,_dadg );if _dfed ._gbfc .isRelative (){ctx .X -=_dfed ._ecfg ._feag ;ctx .Width =_ebce .Width ;return _dgeb ,ctx ,nil ;};return _dgeb ,_ebce ,nil ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_ecdg *Chapter )SetIncludeInTOC (includeInTOC bool ){_ecdg ._gde =includeInTOC };

// NewTable create a new Table with a specified number of columns.
func (_egce *Creator )NewTable (cols int )*Table {return _dgde (cols )};

// DrawHeader sets a function to draw a header on created output pages.
func (_adee *Creator )DrawHeader (drawHeaderFunc func (_ceg *Block ,_dbd HeaderFunctionArgs )){_adee ._aea =drawHeaderFunc ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_edf int ;_fac string ;_gadf *Paragraph ;_deef []Drawable ;_abf int ;_abc bool ;_gde bool ;_bfda positioning ;_bedc ,_agdg float64 ;_ege margins ;_gee *Chapter ;_fdag *TOC ;_cddfb *_ca .Outline ;_gcc *_ca .OutlineItem ;_dgc uint ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_efebb *List )Marker ()*TextChunk {return &_efebb ._deaf };

// Height returns the total height of all rows.
func (_ebfa *Table )Height ()float64 {_aagf :=float64 (0.0);for _ ,_febfg :=range _ebfa ._febf {_aagf +=_febfg ;};return _aagf ;};

// MoveY moves the drawing context to absolute position y.
func (_aade *Creator )MoveY (y float64 ){_aade ._dade .Y =y };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_dbegf *Image )SetPos (x ,y float64 ){_dbegf ._egdc =_cef ;_dbegf ._dbee =x ;_dbegf ._gfgga =y };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_bdf *Creator )SetOutlineTree (outlineTree *_ca .PdfOutlineTreeNode ){_bdf ._fcc =outlineTree };func _fecc (_fad ,_dfcgf ,_edad ,_bce float64 )*Line {_gaad :=&Line {};_gaad ._dgcg =_fad ;_gaad ._dfae =_dfcgf ;_gaad ._gbbd =_edad ;_gaad ._dgcga =_bce ;_gaad ._gbde =_ca .NewPdfColorDeviceRGB (0,0,0);_gaad ._adcc =1.0;return _gaad ;};

// Logo returns the logo of the invoice.
func (_ddab *Invoice )Logo ()*Image {return _ddab ._aebd };

// SetStyleRight sets border style for right side.
func (_gebg *border )SetStyleRight (style CellBorderStyle ){_gebg ._abg =style };

// SetFillColor sets the fill color for the path.
func (_cgff *FilledCurve )SetFillColor (color Color ){_cgff ._gbge =_ca .NewPdfColorDeviceRGB (color .ToRGB ());};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_deab *StyledParagraph ;_eadf []*TOCLine ;_ffbg TextStyle ;_dddg TextStyle ;_ggggd TextStyle ;_bebc TextStyle ;_gbed string ;_gefgb float64 ;_aeged margins ;_dacd positioning ;_acfa TextStyle ;_gfcd bool ;};

// SetWidthLeft sets border width for left.
func (_ddc *border )SetWidthLeft (bw float64 ){_ddc ._cgb =bw };

// WriteToFile writes the Creator output to file specified by path.
func (_fgfb *Creator )WriteToFile (outputPath string )error {_eeb ,_ffad :=_c .Create (outputPath );if _ffad !=nil {return _ffad ;};defer _eeb .Close ();return _fgfb .Write (_eeb );};func (_fgbdg *Paragraph )getTextLineWidth (_cfgc string )float64 {var _cefad float64 ;for _ ,_cafc :=range _cfgc {if _cafc =='\u000A'{continue ;};_caac ,_abba :=_fgbdg ._geegc .GetRuneMetrics (_cafc );if !_abba {_aae .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_cafc ,_cafc );return -1;};_cefad +=_fgbdg ._fccdc *_caac .Wx ;};return _cefad ;};func (_ead *Image )rotatedSize ()(float64 ,float64 ){_dgge :=_ead ._bfaf ;_edcg :=_ead ._ccdb ;_gcca :=_ead ._fcfe ;if _gcca ==0{return _dgge ,_edcg ;};_ffcd :=_de .Path {Points :[]_de .Point {_de .NewPoint (0,0).Rotate (_gcca ),_de .NewPoint (_dgge ,0).Rotate (_gcca ),_de .NewPoint (0,_edcg ).Rotate (_gcca ),_de .NewPoint (_dgge ,_edcg ).Rotate (_gcca )}}.GetBoundingBox ();return _ffcd .Width ,_ffcd .Height ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_adcd *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_adcd ._bcfa =alignment };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_adaba *Invoice )SetColumns (cols []*InvoiceCell ){_adaba ._bcdc =cols };

// SetTitle sets the title of the invoice.
func (_acdc *Invoice )SetTitle (title string ){_acdc ._ecad =title };func _cgbf (_dfb string )(*Image ,error ){_gbgc ,_aaa :=_c .Open (_dfb );if _aaa !=nil {return nil ,_aaa ;};defer _gbgc .Close ();_becb ,_aaa :=_ca .ImageHandling .Read (_gbgc );if _aaa !=nil {_aae .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_aaa );return nil ,_aaa ;};return _dcfa (_becb );};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_ddfc string ;_geegc *_ca .PdfFont ;_fccdc float64 ;_agaee float64 ;_cebg _ca .PdfColorDeviceRGB ;_ecgb TextAlignment ;_fcff bool ;_bdgb float64 ;_afga bool ;_eefc float64 ;_ecfg margins ;_gbfc positioning ;_accf float64 ;_gfge float64 ;_caea ,_bgac float64 ;_ggcd []string ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fdfb *Creator )MoveDown (dy float64 ){_fdfb ._dade .Y +=dy };

// SetWidthTop sets border width for top.
func (_cfg *border )SetWidthTop (bw float64 ){_cfg ._dbca =bw };func (_feeg *Creator )getActivePage ()*_ca .PdfPage {if _feeg ._ffa ==nil {if len (_feeg ._feec )==0{return nil ;};return _feeg ._feec [len (_feeg ._feec )-1];};return _feeg ._ffa ;};func (_eee *StyledParagraph )getLineHeight (_bfed int )(_dcgad ,_dag float64 ){if _eee ._dada ==nil ||len (_eee ._dada )==0{_eee .wrapText ();};if _bfed < 0||_bfed > len (_eee ._dada )-1{_aae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_bfed );return 0,0;};_gcdd :=_eee ._dada [_bfed ];for _ ,_dgad :=range _gcdd {_dfbe ,_efgc :=_dgad .Style .Font .GetFontDescriptor ();if _efgc !=nil {_aae .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _edgf float64 ;if _dfbe !=nil {if _edgf ,_efgc =_dfbe .GetCapHeight ();_efgc !=nil {_aae .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_efgc );};};if int (_edgf )<=0{_aae .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_edgf =1000;};_edadg :=_edgf /1000.0*_dgad .Style .FontSize *_eee ._bgea ;if _edadg > _dcgad {_dcgad =_edadg ;};_edadg =_eee ._bgea *_dgad .Style .FontSize ;if _edadg > _dag {_dag =_edadg ;};};return _dcgad ,_dag ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_bgaec *TextChunk )SetAnnotation (annotation *_ca .PdfAnnotation ){_bgaec ._abdg =annotation };

// TitleStyle returns the style properties used to render the invoice title.
func (_geef *Invoice )TitleStyle ()TextStyle {return _geef ._bdaa };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_gecab *TOC )SetLineNumberStyle (style TextStyle ){_gecab ._ffbg =style };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_beba *Creator )MoveRight (dx float64 ){_beba ._dade .X +=dx };

// SetAngle sets the rotation angle of the text.
func (_cabg *Paragraph )SetAngle (angle float64 ){_cabg ._eefc =angle };

// NewFilledCurve returns a instance of filled curve.
func (_abagg *Creator )NewFilledCurve ()*FilledCurve {return _cfbe ()};

// Angle returns the block rotation angle in degrees.
func (_fee *Block )Angle ()float64 {return _fee ._cgf };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_efbb *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_fbcab :=&_efbb ._aeged ;_fbcab ._feag =left ;_fbcab ._ddbb =right ;_fbcab ._ecfa =top ;_fbcab ._fbbc =bottom ;};

// SetAngle sets the rotation angle of the text.
func (_gagb *StyledParagraph )SetAngle (angle float64 ){_gagb ._fdda =angle };func (_bedd *Chapter )headingText ()string {_aedf :=_bedd ._fac ;if _efcb :=_bedd .headingNumber ();_efcb !=""{_aedf =_cg .Sprintf ("\u0025\u0073\u0020%\u0073",_efcb ,_aedf );};return _aedf ;};func _aebcg (_edbeb *_ca .PdfAnnotationLink )*_ca .PdfAnnotationLink {if _edbeb ==nil {return nil ;};_gbbca :=_ca .NewPdfAnnotationLink ();_gbbca .BS =_edbeb .BS ;_gbbca .A =_edbeb .A ;if _beaa ,_ddfa :=_edbeb .GetAction ();_ddfa ==nil &&_beaa !=nil {_gbbca .SetAction (_beaa );};if _ebef ,_gbbfde :=_edbeb .Dest .(*_fef .PdfObjectArray );_gbbfde {_gbbca .Dest =_fef .MakeArray (_ebef .Elements ()...);};return _gbbca ;};func _dgbd (_fafc *Block ,_fcba *Paragraph ,_bddd DrawContext )(DrawContext ,error ){_ddce :=1;_defe :=_fef .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fe .Itoa (_ddce ));for _fafc ._aac .HasFontByName (_defe ){_ddce ++;_defe =_fef .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fe .Itoa (_ddce ));};_cacb :=_fafc ._aac .SetFontByName (_defe ,_fcba ._geegc .ToPdfObject ());if _cacb !=nil {return _bddd ,_cacb ;};_fcba .wrapText ();_bgee :=_cf .NewContentCreator ();_bgee .Add_q ();_cafe :=_bddd .PageHeight -_bddd .Y -_fcba ._fccdc *_fcba ._agaee ;_bgee .Translate (_bddd .X ,_cafe );if _fcba ._eefc !=0{_bgee .RotateDeg (_fcba ._eefc );};_bgee .Add_BT ().Add_rg (_fcba ._cebg .R (),_fcba ._cebg .G (),_fcba ._cebg .B ()).Add_Tf (_defe ,_fcba ._fccdc ).Add_TL (_fcba ._fccdc *_fcba ._agaee );for _bcff ,_cgce :=range _fcba ._ggcd {if _bcff !=0{_bgee .Add_Tstar ();};_ggag :=[]rune (_cgce );_cfea :=0.0;_caccf :=0;for _ddcb ,_ccbb :=range _ggag {if _ccbb ==' '{_caccf ++;continue ;};if _ccbb =='\u000A'{continue ;};_gdcff ,_aaggfb :=_fcba ._geegc .GetRuneMetrics (_ccbb );if !_aaggfb {_aae .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_ddcb ,_ccbb ,_ccbb ,_fcba ._geegc .BaseFont (),_fcba ._geegc .Subtype ());return _bddd ,_ef .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_cfea +=_fcba ._fccdc *_gdcff .Wx ;};var _abgc []_fef .PdfObject ;_efda ,_cgec :=_fcba ._geegc .GetRuneMetrics (' ');if !_cgec {return _bddd ,_ef .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ced :=_efda .Wx ;switch _fcba ._ecgb {case TextAlignmentJustify :if _caccf > 0&&_bcff < len (_fcba ._ggcd )-1{_ced =(_fcba ._bdgb *1000.0-_cfea )/float64 (_caccf )/_fcba ._fccdc ;};case TextAlignmentCenter :_abfb :=_cfea +float64 (_caccf )*_ced *_fcba ._fccdc ;_fcggd :=(_fcba ._bdgb *1000.0-_abfb )/2/_fcba ._fccdc ;_abgc =append (_abgc ,_fef .MakeFloat (-_fcggd ));case TextAlignmentRight :_fedc :=_cfea +float64 (_caccf )*_ced *_fcba ._fccdc ;_ceee :=(_fcba ._bdgb *1000.0-_fedc )/_fcba ._fccdc ;_abgc =append (_abgc ,_fef .MakeFloat (-_ceee ));};_gcef :=_fcba ._geegc .Encoder ();var _feebb []byte ;for _ ,_ggdd :=range _ggag {if _ggdd =='\u000A'{continue ;};if _ggdd ==' '{if len (_feebb )> 0{_abgc =append (_abgc ,_fef .MakeStringFromBytes (_feebb ));_feebb =nil ;};_abgc =append (_abgc ,_fef .MakeFloat (-_ced ));}else {if _ ,_edd :=_gcef .RuneToCharcode (_ggdd );!_edd {_aae .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ggdd ,_ggdd );continue ;};_feebb =append (_feebb ,_gcef .Encode (string (_ggdd ))...);};};if len (_feebb )> 0{_abgc =append (_abgc ,_fef .MakeStringFromBytes (_feebb ));};_bgee .Add_TJ (_abgc ...);};_bgee .Add_ET ();_bgee .Add_Q ();_bggda :=_bgee .Operations ();_bggda .WrapIfNeeded ();_fafc .addContents (_bggda );if _fcba ._gbfc .isRelative (){_bfdd :=_fcba .Height ()+_fcba ._ecfg ._fbbc ;_bddd .Y +=_bfdd ;_bddd .Height -=_bfdd ;if _bddd .Inline {_bddd .X +=_fcba .Width ()+_fcba ._ecfg ._ddbb ;};};return _bddd ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ceaaf *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebcef :=ctx ;_gaec ,ctx ,_ecgg :=_ceaaf ._deab .GeneratePageBlocks (ctx );if _ecgg !=nil {return _gaec ,ctx ,_ecgg ;};for _ ,_gcgc :=range _ceaaf ._eadf {_dgea :=_gcgc ._gaed ;if !_ceaaf ._gfcd {_gcgc ._gaed =0;};_bfaa ,_aaef ,_gbac :=_gcgc .GeneratePageBlocks (ctx );_gcgc ._gaed =_dgea ;if _gbac !=nil {return _gaec ,ctx ,_gbac ;};if len (_bfaa )< 1{continue ;};_gaec [len (_gaec )-1].mergeBlocks (_bfaa [0]);_gaec =append (_gaec ,_bfaa [1:]...);ctx =_aaef ;};if _ceaaf ._dacd .isRelative (){ctx .X =_ebcef .X ;};if _ceaaf ._dacd .isAbsolute (){return _gaec ,_ebcef ,nil ;};return _gaec ,ctx ,nil ;};func (_egea *Paragraph )getMaxLineWidth ()float64 {if _egea ._ggcd ==nil ||len (_egea ._ggcd )==0{_egea .wrapText ();};var _eede float64 ;for _ ,_feacb :=range _egea ._ggcd {_eedag :=_egea .getTextLineWidth (_feacb );if _eedag > _eede {_eede =_eedag ;};};return _eede ;};func (_ecdb *Invoice )drawSection (_bbg ,_dbaf string )[]*StyledParagraph {var _cacc []*StyledParagraph ;if _bbg !=""{_fce :=_bged (_ecdb ._bggd );_fce .SetMargins (0,0,0,5);_fce .Append (_bbg );_cacc =append (_cacc ,_fce );};if _dbaf !=""{_fgeb :=_bged (_ecdb ._eggfe );_fgeb .Append (_dbaf );_cacc =append (_cacc ,_fgeb );};return _cacc ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_cgda *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dagf :=ctx ;var _fdb []*Block ;_dde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cgda ._fcee .isRelative (){ctx .X +=_cgda ._bebaf ._feag ;ctx .Y +=_cgda ._bebaf ._ecfa ;ctx .Width -=_cgda ._bebaf ._feag +_cgda ._bebaf ._ddbb ;ctx .Height -=_cgda ._bebaf ._ecfa +_cgda ._bebaf ._fbbc ;_cgda .SetWidth (ctx .Width );}else {if int (_cgda ._fbbga )<=0{_cgda .SetWidth (_cgda .getTextWidth ());};ctx .X =_cgda ._cfge ;ctx .Y =_cgda ._gfee ;};if _cgda ._fccf !=nil {_cgda ._fccf (_cgda ,ctx );};if _gbfcf :=_cgda .wrapText ();_gbfcf !=nil {return nil ,ctx ,_gbfcf ;};_daae :=_cgda ._dada ;for {_aaad ,_fbbfe ,_egaf :=_bbgaa (_dde ,_cgda ,_daae ,ctx );if _egaf !=nil {_aae .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_egaf );return nil ,ctx ,_egaf ;};ctx =_aaad ;_fdb =append (_fdb ,_dde );if _daae =_fbbfe ;len (_fbbfe )==0{break ;};_dde =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_aaad =ctx ;_aaad .Y =ctx .Margins ._ecfa ;_aaad .X =ctx .Margins ._feag +_cgda ._bebaf ._feag ;_aaad .Height =ctx .PageHeight -ctx .Margins ._ecfa -ctx .Margins ._fbbc -_cgda ._bebaf ._fbbc ;_aaad .Width =ctx .PageWidth -ctx .Margins ._feag -ctx .Margins ._ddbb -_cgda ._bebaf ._feag -_cgda ._bebaf ._ddbb ;ctx =_aaad ;};if _cgda ._fcee .isRelative (){ctx .X -=_cgda ._bebaf ._feag ;ctx .Width =_dagf .Width ;return _fdb ,ctx ,nil ;};return _fdb ,_dagf ,nil ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_aefd *Creator )NewPage ()*_ca .PdfPage {_acc :=_aefd .newPage ();_aefd ._feec =append (_aefd ._feec ,_acc );_aefd ._dade .Page ++;return _acc ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_fggb *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fggb ._daa ._feag ,_fggb ._daa ._ddbb ,_fggb ._daa ._ecfa ,_fggb ._daa ._fbbc ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_egcf *Table )NewCell ()*TableCell {return _egcf .newCell (1)};

// SetText sets the text content of the Paragraph.
func (_efgb *Paragraph )SetText (text string ){_efgb ._ddfc =text };

// SetBorderColor sets border color.
func (_eegd *Rectangle )SetBorderColor (col Color ){_eegd ._ggf =_ca .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_dadef *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _dcgb (x ,y ,width ,height );};