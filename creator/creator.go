//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_d "bytes";_b "errors";_eac "fmt";_gg "github.com/unidoc/unipdf/v3/common";_eb "github.com/unidoc/unipdf/v3/contentstream";_gb "github.com/unidoc/unipdf/v3/contentstream/draw";_aa "github.com/unidoc/unipdf/v3/core";_ggb "github.com/unidoc/unipdf/v3/model";_a "image";_ea "io";_g "math";_ef "os";_bg "sort";_c "strconv";_de "strings";_eab "unicode";);

// NewSubchapter creates a new child chapter with the specified title.
func (_fdb *Chapter )NewSubchapter (title string )*Chapter {_gba :=_bddgd (_fdb ._bced ._eccc );_gba .FontSize =14;_fdb ._acd ++;_cbd :=_fda (_fdb ,_fdb ._efag ,_fdb ._bbgf ,title ,_fdb ._acd ,_gba );_fdb .Add (_cbd );return _cbd ;};func (_dec *Block )addContents (_dd *_eb .ContentStreamOperations ){_dec ._ae .WrapIfNeeded ();_dd .WrapIfNeeded ();*_dec ._ae =append (*_dec ._ae ,*_dd ...);};

// SetColor sets the line color.
func (_dbca *Curve )SetColor (col Color ){_dbca ._efe =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_bfac *TableCell )SetContent (vd VectorDrawable )error {switch _edcgg :=vd .(type ){case *Paragraph :if _edcgg ._eggd {_edcgg ._gadd =true ;};_bfac ._gcce =vd ;case *StyledParagraph :if _edcgg ._fgdg {_edcgg ._feab =true ;};_bfac ._gcce =vd ;case *Image :_bfac ._gcce =vd ;case *Table :_bfac ._gcce =vd ;case *List :_bfac ._gcce =vd ;case *Division :_bfac ._gcce =vd ;default:_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _aa .ErrTypeError ;};return nil ;};

// Lines returns all the rows of the invoice line items table.
func (_egc *Invoice )Lines ()[][]*InvoiceCell {return _egc ._cdgc };

// Height returns the current page height.
func (_ddef *Creator )Height ()float64 {return _ddef ._gagc };func _aggea (_fefe ,_dcfd ,_eeac ,_efdga ,_gcgga ,_gcbb float64 )*Curve {_aagc :=&Curve {};_aagc ._abdd =_fefe ;_aagc ._bbc =_dcfd ;_aagc ._gbfd =_eeac ;_aagc ._daaf =_efdga ;_aagc ._cacg =_gcgga ;_aagc ._fdcfc =_gcbb ;_aagc ._efe =_ggb .NewPdfColorDeviceRGB (0,0,0);_aagc ._cgda =1.0;return _aagc ;};

// MoveY moves the drawing context to absolute position y.
func (_gegd *Creator )MoveY (y float64 ){_gegd ._gedb .Y =y };func _cfgd (_bfg []byte )(*Image ,error ){_dfbe :=_d .NewReader (_bfg );_fccg ,_gcde :=_ggb .ImageHandling .Read (_dfbe );if _gcde !=nil {_gg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gcde );return nil ,_gcde ;};return _baad (_fccg );};

// SetTotal sets the total of the invoice.
func (_afff *Invoice )SetTotal (value string ){_afff ._efdge [1].Value =value };

// CurRow returns the currently active cell's row number.
func (_bgbb *Table )CurRow ()int {_eadff :=(_bgbb ._eega -1)/_bgbb ._adcf +1;return _eadff };func (_aaa *Block )drawToPage (_fc *_ggb .PdfPage )error {_cda :=&_eb .ContentStreamOperations {};if _fc .Resources ==nil {_fc .Resources =_ggb .NewPdfPageResources ();};_dcg :=_fggf (_cda ,_fc .Resources ,_aaa ._ae ,_aaa ._ce );if _dcg !=nil {return _dcg ;};if _dcg =_eae (_aaa ._ce ,_fc .Resources );_dcg !=nil {return _dcg ;};if _dcg =_fc .AppendContentBytes (_cda .Bytes (),true );_dcg !=nil {return _dcg ;};for _ ,_feb :=range _aaa ._ca {_fc .AddAnnotation (_feb );};return nil ;};

// Scale block by specified factors in the x and y directions.
func (_baa *Block )Scale (sx ,sy float64 ){_cd :=_eb .NewContentCreator ().Scale (sx ,sy ).Operations ();*_baa ._ae =append (*_cd ,*_baa ._ae ...);_baa ._ae .WrapIfNeeded ();_baa ._f *=sx ;_baa ._dc *=sy ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_gfe *Block )SetPos (x ,y float64 ){_gfe ._db =_fab ;_gfe ._cb =x ;_gfe ._bf =y };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_gd :=&Block {};_gd ._ae =&_eb .ContentStreamOperations {};_gd ._ce =_ggb .NewPdfPageResources ();_gd ._f =width ;_gd ._dc =height ;return _gd ;};func _geffb (_fbbdf string )*_ggb .PdfAnnotation {_dcec :=_ggb .NewPdfAnnotationLink ();_ebdcc :=_ggb .NewBorderStyle ();_ebdcc .SetBorderWidth (0);_dcec .BS =_ebdcc .ToPdfObject ();_gccef :=_ggb .NewPdfActionURI ();_gccef .URI =_aa .MakeString (_fbbdf );_dcec .SetAction (_gccef .PdfAction );return _dcec .PdfAnnotation ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// TextAlignment options for paragraph.
type TextAlignment int ;

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ge *Block )Draw (d Drawable )error {_decb :=DrawContext {};_decb .Width =_ge ._f ;_decb .Height =_ge ._dc ;_decb .PageWidth =_ge ._f ;_decb .PageHeight =_ge ._dc ;_decb .X =0;_decb .Y =0;_ecb ,_ ,_bbf :=d .GeneratePageBlocks (_decb );if _bbf !=nil {return _bbf ;};if len (_ecb )!=1{return _b .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_dde :=range _ecb {if _bad :=_ge .mergeBlocks (_dde );_bad !=nil {return _bad ;};};return nil ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_cccg *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_cccg ._fecg =toc ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_fffgb *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_ccegd ,_dcgf :=_fffgb .Wrap (width );if _dcgf !=nil {return nil ,_dcgf ;};_fdbf :=int (height /_fffgb .Style .FontSize );if _fdbf >=len (_ccegd ){return nil ,nil ;};_efdgc :="\u000a";_fffgb .Text =_de .Replace (_de .Join (_ccegd [:_fdbf ],"\u0020"),_efdgc +"\u0020",_efdgc ,-1);_gedgg :=_de .Replace (_de .Join (_ccegd [_fdbf :],"\u0020"),_efdgc +"\u0020",_efdgc ,-1);return NewTextChunk (_gedgg ,_fffgb .Style ),nil ;};func (_eed *StyledParagraph )appendChunk (_eagg *TextChunk )*TextChunk {_eed ._cdcgf =append (_eed ._cdcgf ,_eagg );_eed .wrapText ();return _eagg ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_bbcdd *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_bbcdd ._cfaf =halign ;};

// SetFont sets the Paragraph's font.
func (_dgba *Paragraph )SetFont (font *_ggb .PdfFont ){_dgba ._eccc =font };

// SetWidthTop sets border width for top.
func (_bcg *border )SetWidthTop (bw float64 ){_bcg ._eaf =bw };type border struct{_ddc float64 ;_dea float64 ;_da float64 ;_acb float64 ;_edae *_ggb .PdfColorDeviceRGB ;_ccg *_ggb .PdfColorDeviceRGB ;_bdg float64 ;_feg *_ggb .PdfColorDeviceRGB ;_dba float64 ;_dbc *_ggb .PdfColorDeviceRGB ;_bce float64 ;_fga *_ggb .PdfColorDeviceRGB ;_eaf float64 ;LineStyle _gb .LineStyle ;_ggf CellBorderStyle ;_cfe CellBorderStyle ;_bae CellBorderStyle ;_efb CellBorderStyle ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_accf *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_accf ._cacfa =append (_accf ._cacfa ,line );return line ;};func (_faec *Image )makeXObject ()error {_aabf :=_faec ._dbde ;if _aabf ==nil {_aabf =_aa .NewFlateEncoder ();};_fbdb ,_ccea :=_ggb .NewXObjectImageFromImage (_faec ._bbcd ,nil ,_aabf );if _ccea !=nil {_gg .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ccea );return _ccea ;};_faec ._gdec =_fbdb ;return nil ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fffe *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbed :=ctx ;_cfbc :=[]func (_afa DrawContext )([]*Block ,DrawContext ,error ){_fffe .generateHeaderBlocks ,_fffe .generateInformationBlocks ,_fffe .generateLineBlocks ,_fffe .generateTotalBlocks ,_fffe .generateNoteBlocks };var _cedbf []*Block ;for _ ,_aggee :=range _cfbc {_ddff ,_cdfae ,_edffd :=_aggee (ctx );if _edffd !=nil {return _cedbf ,ctx ,_edffd ;};if len (_cedbf )==0{_cedbf =_ddff ;}else if len (_ddff )> 0{_cedbf [len (_cedbf )-1].mergeBlocks (_ddff [0]);_cedbf =append (_cedbf ,_ddff [1:]...);};ctx =_cdfae ;};if _fffe ._cde .isRelative (){ctx .X =_cbed .X ;};if _fffe ._cde .isAbsolute (){return _cedbf ,_cbed ,nil ;};return _cedbf ,ctx ,nil ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_edfe *Invoice )AddressStyle ()TextStyle {return _edfe ._eafd };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_agcd *_gb .Polyline ;_cffg float64 ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_gabg *TOCLine )SetLevelOffset (levelOffset float64 ){_gabg ._bfff =levelOffset ;_gabg ._cfgg ._bddbc ._edbg =_gabg ._eacae +float64 (_gabg ._fcdd -1)*_gabg ._bfff ;};func (_dbbb *Chapter )headingText ()string {_beg :=_dbbb ._fcca ;if _gcgg :=_dbbb .headingNumber ();_gcgg !=""{_beg =_eac .Sprintf ("\u0025\u0073\u0020%\u0073",_gcgg ,_beg );};return _beg ;};func (_gcge *Chapter )headingNumber ()string {var _affe string ;if _gcge ._gddg {if _gcge ._eaff !=0{_affe =_c .Itoa (_gcge ._eaff )+"\u002e";};if _gcge ._gae !=nil {_dfed :=_gcge ._gae .headingNumber ();if _dfed !=""{_affe =_dfed +_affe ;};};};return _affe ;};

// SetBorderColor sets the border color for the path.
func (_bcgf *FilledCurve )SetBorderColor (color Color ){_bcgf ._efbf =_ggb .NewPdfColorDeviceRGB (color .ToRGB ());};func _fda (_efae *Chapter ,_bag *TOC ,_dfe *_ggb .Outline ,_bfc string ,_edbf int ,_fcec TextStyle )*Chapter {var _adef uint =1;if _efae !=nil {_adef =_efae ._gga +1;};_eca :=&Chapter {_eaff :_edbf ,_fcca :_bfc ,_gddg :true ,_abfa :true ,_gae :_efae ,_efag :_bag ,_bbgf :_dfe ,_fbd :[]Drawable {},_gga :_adef };_cbf :=_bcdb (_eca .headingText (),_fcec );_cbf .SetFont (_fcec .Font );_cbf .SetFontSize (_fcec .FontSize );_eca ._bced =_cbf ;return _eca ;};func _eae (_faed ,_ada *_ggb .PdfPageResources )error {_fge ,_ :=_faed .GetColorspaces ();if _fge !=nil &&len (_fge .Colorspaces )> 0{for _ead ,_adcbf :=range _fge .Colorspaces {_edb :=*_aa .MakeName (_ead );if _ada .HasColorspaceByName (_edb ){continue ;};_eea :=_ada .SetColorspaceByName (_edb ,_adcbf );if _eea !=nil {return _eea ;};};};return nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fbec *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fabca :=ctx ;_fgebg ,ctx ,_ebace :=_fbec ._gacf .GeneratePageBlocks (ctx );if _ebace !=nil {return _fgebg ,ctx ,_ebace ;};for _ ,_fgdcb :=range _fbec ._cacfa {_fgaae :=_fgdcb ._bggac ;if !_fbec ._dbda {_fgdcb ._bggac =0;};_babg ,_gadag ,_efbdd :=_fgdcb .GeneratePageBlocks (ctx );_fgdcb ._bggac =_fgaae ;if _efbdd !=nil {return _fgebg ,ctx ,_efbdd ;};if len (_babg )< 1{continue ;};_fgebg [len (_fgebg )-1].mergeBlocks (_babg [0]);_fgebg =append (_fgebg ,_babg [1:]...);ctx =_gadag ;};if _fbec ._fcbd .isRelative (){ctx .X =_fabca .X ;};if _fbec ._fcbd .isAbsolute (){return _fgebg ,_fabca ,nil ;};return _fgebg ,ctx ,nil ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_eee *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _efbe (number ,title ,page ,level ,_eee .NewTextStyle ());};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_egdg *TOC )SetHeading (text string ,style TextStyle ){_gaaaa :=_egdg .Heading ();_gaaaa .Reset ();_ddae :=_gaaaa .Append (text );_ddae .Style =style ;};

// SetFillColor sets the fill color.
func (_fcgd *Ellipse )SetFillColor (col Color ){_fcgd ._fcfb =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_ffcd *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aeec :=_gb .Rectangle {Opacity :1.0,X :_ffcd ._deeba ,Y :ctx .PageHeight -_ffcd ._gcdd -_ffcd ._gece ,Height :_ffcd ._gece ,Width :_ffcd ._cagg };if _ffcd ._abfde !=nil {_aeec .FillEnabled =true ;_aeec .FillColor =_ffcd ._abfde ;};if _ffcd ._baba !=nil &&_ffcd ._geca > 0{_aeec .BorderEnabled =true ;_aeec .BorderColor =_ffcd ._baba ;_aeec .BorderWidth =_ffcd ._geca ;};_dbfa ,_edbb :=_edcg .setOpacity (_ffcd ._fcea ,_ffcd ._fdeb );if _edbb !=nil {return nil ,ctx ,_edbb ;};_aabfb ,_ ,_edbb :=_aeec .Draw (_dbfa );if _edbb !=nil {return nil ,ctx ,_edbb ;};if _edbb =_edcg .addContentsByString (string (_aabfb ));_edbb !=nil {return nil ,ctx ,_edbb ;};return []*Block {_edcg },ctx ,nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);type listItem struct{_eagc VectorDrawable ;_fagf TextChunk ;};

// WriteToFile writes the Creator output to file specified by path.
func (_abb *Creator )WriteToFile (outputPath string )error {_faeb ,_gbgb :=_ef .Create (outputPath );if _gbgb !=nil {return _gbgb ;};defer _faeb .Close ();return _abb .Write (_faeb );};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// Width returns Image's document width.
func (_ecdc *Image )Width ()float64 {return _ecdc ._ddcb };func (_eddce *Invoice )drawAddress (_fdea *InvoiceAddress )[]*StyledParagraph {var _dfbg []*StyledParagraph ;if _fdea .Heading !=""{_fdae :=_bcbd (_eddce ._gaba );_fdae .SetMargins (0,0,0,7);_fdae .Append (_fdea .Heading );_dfbg =append (_dfbg ,_fdae );};_eecf :=_bcbd (_eddce ._eafd );_eecf .SetLineHeight (1.2);_ecgdd :=_fdea .Separator ;if _ecgdd ==""{_ecgdd =_eddce ._cggc ;};_cbff :=_fdea .City ;if _fdea .State !=""{if _cbff !=""{_cbff +=_ecgdd ;};_cbff +=_fdea .State ;};if _fdea .Zip !=""{if _cbff !=""{_cbff +=_ecgdd ;};_cbff +=_fdea .Zip ;};if _fdea .Name !=""{_eecf .Append (_fdea .Name +"\u000a");};if _fdea .Street !=""{_eecf .Append (_fdea .Street +"\u000a");};if _fdea .Street2 !=""{_eecf .Append (_fdea .Street2 +"\u000a");};if _cbff !=""{_eecf .Append (_cbff +"\u000a");};if _fdea .Country !=""{_eecf .Append (_fdea .Country +"\u000a");};_bbe :=_bcbd (_eddce ._eafd );_bbe .SetLineHeight (1.2);_bbe .SetMargins (0,0,7,0);if _fdea .Phone !=""{_bbe .Append (_eac .Sprintf ("\u0050\u0068\u006f\u006e\u0065\u003a\u0020\u0025\u0073\u000a",_fdea .Phone ));};if _fdea .Email !=""{_bbe .Append (_eac .Sprintf ("\u0045\u006d\u0061\u0069\u006c\u003a\u0020\u0025\u0073\u000a",_fdea .Email ));};_dfbg =append (_dfbg ,_eecf ,_bbe );return _dfbg ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_bdba []*_ggb .PdfPage ;_bfbg map[*_ggb .PdfPage ]*Block ;_begd *_ggb .PdfPage ;_dead PageSize ;_gedb DrawContext ;_eaca margins ;_edcf ,_gagc float64 ;_ecad int ;_agbg func (_dad FrontpageFunctionArgs );_bbgcg func (_def *TOC )error ;_cgeb func (_dbbfe *Block ,_dbcc HeaderFunctionArgs );_fccb func (_cfcb *Block ,_cfb FooterFunctionArgs );_bcfe func (_adf *_ggb .PdfWriter )error ;_ccga bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_fecg *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gda *_ggb .Outline ;_eeca *_ggb .PdfOutlineTreeNode ;_acc *_ggb .PdfAcroForm ;_gddf _aa .PdfObject ;_egd _ggb .Optimizer ;_gcf []*_ggb .PdfFont ;_fdcf *_ggb .PdfFont ;_cefd *_ggb .PdfFont ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_bdf *Block )ScaleToHeight (h float64 ){_dcc :=h /_bdf ._dc ;_bdf .Scale (_dcc ,_dcc )};

// SetAnnotation sets a annotation on a TextChunk.
func (_bcfed *TextChunk )SetAnnotation (annotation *_ggb .PdfAnnotation ){_bcfed ._gagee =annotation };

// SetFillOpacity sets the fill opacity.
func (_baadc *Polygon )SetFillOpacity (opacity float64 ){_baadc ._ebeed =opacity };

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_fafa *Invoice )SetAddressStyle (style TextStyle ){_fafa ._eafd =style };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_fgaef *Table )NewCell ()*TableCell {return _fgaef .newCell (1)};

// SetNumber sets the number of the invoice.
func (_dedde *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_dedde ._gbbc [1].Value =number ;return _dedde ._gbbc [0],_dedde ._gbbc [1];};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_beca *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _afcc (xc ,yc ,width ,height );};

// SetBorderColor sets the border color.
func (_dcb *Ellipse )SetBorderColor (col Color ){_dcb ._fefeb =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_afaf float64 ;_aaea float64 ;_cagb float64 ;_ccab float64 ;_bcfaf *_ggb .PdfColorDeviceRGB ;_caed float64 ;};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_ggb .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_gfgg *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_beda :=NewTextChunk (text ,_gfgg ._aabc );_beda ._gagee =_geffb (url );return _gfgg .appendChunk (_beda );};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_begc *Invoice )AddressHeadingStyle ()TextStyle {return _begc ._cbda };

// Text sets the text content of the Paragraph.
func (_gaag *Paragraph )Text ()string {return _gaag ._dgbf };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_dcbf *Image )SetWidth (w float64 ){_dcbf ._ddcb =w };

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_cegf *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcdf :=_gb .Line {LineWidth :_cegf ._caed ,Opacity :1.0,LineColor :_cegf ._bcfaf ,LineEndingStyle1 :_gb .LineEndingStyleNone ,LineEndingStyle2 :_gb .LineEndingStyleNone ,X1 :_cegf ._afaf ,Y1 :ctx .PageHeight -_cegf ._aaea ,X2 :_cegf ._cagb ,Y2 :ctx .PageHeight -_cegf ._ccab };_fdcb ,_ ,_acdf :=_bcdf .Draw ("");if _acdf !=nil {return nil ,ctx ,_acdf ;};_acdf =_bbca .addContentsByString (string (_fdcb ));if _acdf !=nil {return nil ,ctx ,_acdf ;};return []*Block {_bbca },ctx ,nil ;};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_cagd *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _eggde (x ,y ,width ,height );};

// SetMargins sets the Paragraph's margins.
func (_cdgd *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_cdgd ._dfdg ._edbg =left ;_cdgd ._dfdg ._gac =right ;_cdgd ._dfdg ._fedcf =top ;_cdgd ._dfdg ._ebfe =bottom ;};

// SetStyleBottom sets border style for bottom side.
func (_abd *border )SetStyleBottom (style CellBorderStyle ){_abd ._efb =style };

// SetFillOpacity sets the fill opacity.
func (_bcda *Rectangle )SetFillOpacity (opacity float64 ){_bcda ._fcea =opacity };

// SetFillOpacity sets the fill opacity.
func (_fgda *PolyBezierCurve )SetFillOpacity (opacity float64 ){_fgda ._bfbgf =opacity };

// Width returns the current page width.
func (_aab *Creator )Width ()float64 {return _aab ._edcf };

// SetBorder sets the cell's border style.
func (_ddd *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_ddd ._fegdg =CellBorderStyleSingle ;_ddd ._fdcfg =width ;_ddd ._gafc =CellBorderStyleSingle ;_ddd ._ecfbf =width ;_ddd ._cgff =CellBorderStyleSingle ;_ddd ._bcdg =width ;_ddd ._aaad =CellBorderStyleSingle ;_ddd ._egaab =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_ddd ._fegdg =CellBorderStyleDouble ;_ddd ._fdcfg =width ;_ddd ._gafc =CellBorderStyleDouble ;_ddd ._ecfbf =width ;_ddd ._cgff =CellBorderStyleDouble ;_ddd ._bcdg =width ;_ddd ._aaad =CellBorderStyleDouble ;_ddd ._egaab =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_ddd ._fegdg =style ;_ddd ._fdcfg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_ddd ._gafc =style ;_ddd ._ecfbf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_ddd ._cgff =style ;_ddd ._bcdg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_ddd ._aaad =style ;_ddd ._egaab =width ;};};

// SetFillColor sets the fill color.
func (_dffc *PolyBezierCurve )SetFillColor (color Color ){_dffc ._bcea .FillColor =_ggb .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetLineWidth sets the line width.
func (_gbgc *Polyline )SetLineWidth (lineWidth float64 ){_gbgc ._agcd .LineWidth =lineWidth };func (_cafg *Invoice )generateInformationBlocks (_bgbd DrawContext )([]*Block ,DrawContext ,error ){_feac :=_bcbd (_cafg ._ggca );_feac .SetMargins (0,0,0,20);_bffe :=_cafg .drawAddress (_cafg ._gaaf );_bffe =append (_bffe ,_feac );_bffe =append (_bffe ,_cafg .drawAddress (_cafg ._ecfcb )...);_febfc :=_eeab ();for _ ,_cbgd :=range _bffe {_febfc .Add (_cbgd );};_cbgbf :=_cafg .drawInformation ();_aece :=_begbg (2);_aece .SetMargins (0,0,25,0);_geae :=_aece .NewCell ();_geae .SetIndent (0);_geae .SetContent (_febfc );_geae =_aece .NewCell ();_geae .SetContent (_cbgbf );return _aece .GeneratePageBlocks (_bgbd );};

// SetAngle sets Image rotation angle in degrees.
func (_ebda *Image )SetAngle (angle float64 ){_ebda ._fcd =angle };const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetInline sets the inline mode of the division.
func (_afcd *Division )SetInline (inline bool ){_afcd ._dcdd =inline };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_fedc *Creator )SetOutlineTree (outlineTree *_ggb .PdfOutlineTreeNode ){_fedc ._eeca =outlineTree };

// CurCol returns the currently active cell's column number.
func (_adbag *Table )CurCol ()int {_faadf :=(_adbag ._eega -1)%(_adbag ._adcf )+1;return _faadf };func _deb (_edd string ,_dca _aa .PdfObject ,_dceaa *_ggb .PdfPageResources )_aa .PdfObjectName {_bgg :=_de .TrimRightFunc (_de .TrimSpace (_edd ),func (_cacf rune )bool {return _eab .IsNumber (_cacf )});if _bgg ==""{_bgg ="\u0046\u006f\u006e\u0074";};_gage :=0;_edc :=_aa .PdfObjectName (_edd );for {_gbe ,_baf :=_dceaa .GetFontByName (_edc );if !_baf ||_gbe ==_dca {break ;};_gage ++;_edc =_aa .PdfObjectName (_eac .Sprintf ("\u0025\u0073\u0025\u0064",_bgg ,_gage ));};return _edc ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_daa *Creator )NewChapter (title string )*Chapter {_daa ._ecad ++;_dbdd :=_daa .NewTextStyle ();_dbdd .FontSize =16;return _fda (nil ,_daa ._fecg ,_daa ._gda ,title ,_daa ._ecad ,_dbdd );};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_bcef :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bcef ;};var _decag ,_gggb ,_dbbf int ;if len (hexStr )==4{var _effd ,_gdcf ,_cdgg int ;_caef ,_ffad :=_eac .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_effd ,&_gdcf ,&_cdgg );if _ffad !=nil {_gg .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_ffad );return _bcef ;};if _caef !=3{_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bcef ;};_decag =_effd *16+_effd ;_gggb =_gdcf *16+_gdcf ;_dbbf =_cdgg *16+_cdgg ;}else {_efdg ,_cage :=_eac .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_decag ,&_gggb ,&_dbbf );if _cage !=nil {_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bcef ;};if _efdg !=3{_gg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_efdg );return _bcef ;};};_dfa :=float64 (_decag )/255.0;_ece :=float64 (_gggb )/255.0;_fcfd :=float64 (_dbbf )/255.0;_bcef ._edgf =_dfa ;_bcef ._cccd =_ece ;_bcef ._efd =_fcfd ;return _bcef ;};func (_fabg *TOCLine )getLineLink ()*_ggb .PdfAnnotation {if _fabg ._bggac <=0{return nil ;};return _bebd (_fabg ._bggac -1,_fabg ._efcb ,_fabg ._bffg ,0);};

// NewPageBreak create a new page break.
func (_agcg *Creator )NewPageBreak ()*PageBreak {return _bebg ()};

// GeneratePageBlocks generates a page break block.
func (_ecgb *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcad :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_cabb :=ctx ;_cabb .Y =ctx .Margins ._fedcf ;_cabb .X =ctx .Margins ._edbg ;_cabb .Height =ctx .PageHeight -ctx .Margins ._fedcf -ctx .Margins ._ebfe ;_cabb .Width =ctx .PageWidth -ctx .Margins ._edbg -ctx .Margins ._gac ;ctx =_cabb ;return _dcad ,ctx ,nil ;};func (_dge rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _dge ._edgf ,_dge ._cccd ,_dge ._efd };func (_afdb *Invoice )newColumn (_dgec string ,_dcded CellHorizontalAlignment )*InvoiceCell {_eag :=&InvoiceCell {_afdb ._fad ,_dgec };_eag .Alignment =_dcded ;return _eag ;};func _dbfb (_egfc ,_bfad TextStyle )*Invoice {_ffb :=&Invoice {_ddce :"\u0049N\u0056\u004f\u0049\u0043\u0045",_cggc :"\u002c\u0020",_ggca :_egfc ,_cbda :_bfad };_ffb ._gaaf =&InvoiceAddress {Separator :_ffb ._cggc };_ffb ._ecfcb =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_ffb ._cggc };_caba :=ColorRGBFrom8bit (245,245,245);_cbgea :=ColorRGBFrom8bit (155,155,155);_ffb ._baeg =_bfad ;_ffb ._baeg .Color =_cbgea ;_ffb ._baeg .FontSize =20;_ffb ._eafd =_egfc ;_ffb ._gaba =_bfad ;_ffb ._cffe =_egfc ;_ffb ._cdd =_bfad ;_ffb ._caaf =_ffb .NewCellProps ();_ffb ._caaf .BackgroundColor =_caba ;_ffb ._caaf .TextStyle =_bfad ;_ffb ._fad =_ffb .NewCellProps ();_ffb ._fad .TextStyle =_bfad ;_ffb ._fad .BackgroundColor =_caba ;_ffb ._fad .BorderColor =_caba ;_ffb ._becd =_ffb .NewCellProps ();_ffb ._becd .BorderColor =_caba ;_ffb ._becd .BorderSides =[]CellBorderSide {CellBorderSideBottom };_ffb ._becd .Alignment =CellHorizontalAlignmentRight ;_ffb ._aebe =_ffb .NewCellProps ();_ffb ._aebe .Alignment =CellHorizontalAlignmentRight ;_ffb ._gbbc =[2]*InvoiceCell {_ffb .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_ffb ._caaf ),_ffb .newCell ("",_ffb ._caaf )};_ffb ._fdgf =[2]*InvoiceCell {_ffb .newCell ("\u0044\u0061\u0074\u0065",_ffb ._caaf ),_ffb .newCell ("",_ffb ._caaf )};_ffb ._dgge =[2]*InvoiceCell {_ffb .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_ffb ._caaf ),_ffb .newCell ("",_ffb ._caaf )};_ffb ._gecb =[2]*InvoiceCell {_ffb .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_ffb ._aebe ),_ffb .newCell ("",_ffb ._aebe )};_bbff :=_ffb ._aebe ;_bbff .TextStyle =_bfad ;_bbff .BackgroundColor =_caba ;_bbff .BorderColor =_caba ;_ffb ._efdge =[2]*InvoiceCell {_ffb .newCell ("\u0054\u006f\u0074a\u006c",_bbff ),_ffb .newCell ("",_bbff )};_ffb ._fgbg =[2]string {"\u004e\u006f\u0074e\u0073",""};_ffb ._ccef =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_ffb ._gdaed =[]*InvoiceCell {_ffb .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_ffb .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_ffb .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_ffb .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _ffb ;};func _bbgfg (_gdcbg *Block ,_gdfa *Paragraph ,_gebce DrawContext )(DrawContext ,error ){_cgded :=1;_agdd :=_aa .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_cgded ));for _gdcbg ._ce .HasFontByName (_agdd ){_cgded ++;_agdd =_aa .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_cgded ));};_cacca :=_gdcbg ._ce .SetFontByName (_agdd ,_gdfa ._eccc .ToPdfObject ());if _cacca !=nil {return _gebce ,_cacca ;};_gdfa .wrapText ();_cgcg :=_eb .NewContentCreator ();_cgcg .Add_q ();_adbc :=_gebce .PageHeight -_gebce .Y -_gdfa ._fbga *_gdfa ._dffeb ;_cgcg .Translate (_gebce .X ,_adbc );if _gdfa ._bcbcf !=0{_cgcg .RotateDeg (_gdfa ._bcbcf );};_cgcg .Add_BT ().Add_rg (_gdfa ._fcad .R (),_gdfa ._fcad .G (),_gdfa ._fcad .B ()).Add_Tf (_agdd ,_gdfa ._fbga ).Add_TL (_gdfa ._fbga *_gdfa ._dffeb );for _bddf ,_efccb :=range _gdfa ._cfdc {if _bddf !=0{_cgcg .Add_Tstar ();};_ega :=[]rune (_efccb );_gbcc :=0.0;_gffc :=0;for _bafa ,_fggb :=range _ega {if _fggb ==' '{_gffc ++;continue ;};if _fggb =='\u000A'{continue ;};_cfbe ,_eaga :=_gdfa ._eccc .GetRuneMetrics (_fggb );if !_eaga {_gg .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_bafa ,_fggb ,_fggb ,_gdfa ._eccc .BaseFont (),_gdfa ._eccc .Subtype ());return _gebce ,_b .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_gbcc +=_gdfa ._fbga *_cfbe .Wx ;};var _cdff []_aa .PdfObject ;_fefa ,_fcba :=_gdfa ._eccc .GetRuneMetrics (' ');if !_fcba {return _gebce ,_b .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_abee :=_fefa .Wx ;switch _gdfa ._ggfb {case TextAlignmentJustify :if _gffc > 0&&_bddf < len (_gdfa ._cfdc )-1{_abee =(_gdfa ._fadb *1000.0-_gbcc )/float64 (_gffc )/_gdfa ._fbga ;};case TextAlignmentCenter :_edffe :=_gbcc +float64 (_gffc )*_abee *_gdfa ._fbga ;_gffed :=(_gdfa ._fadb *1000.0-_edffe )/2/_gdfa ._fbga ;_cdff =append (_cdff ,_aa .MakeFloat (-_gffed ));case TextAlignmentRight :_gdeg :=_gbcc +float64 (_gffc )*_abee *_gdfa ._fbga ;_cbgdc :=(_gdfa ._fadb *1000.0-_gdeg )/_gdfa ._fbga ;_cdff =append (_cdff ,_aa .MakeFloat (-_cbgdc ));};_eecc :=_gdfa ._eccc .Encoder ();var _eeaf []byte ;for _ ,_eaegd :=range _ega {if _eaegd =='\u000A'{continue ;};if _eaegd ==' '{if len (_eeaf )> 0{_cdff =append (_cdff ,_aa .MakeStringFromBytes (_eeaf ));_eeaf =nil ;};_cdff =append (_cdff ,_aa .MakeFloat (-_abee ));}else {if _ ,_dggb :=_eecc .RuneToCharcode (_eaegd );!_dggb {_gg .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_eaegd ,_eaegd );continue ;};_eeaf =append (_eeaf ,_eecc .Encode (string (_eaegd ))...);};};if len (_eeaf )> 0{_cdff =append (_cdff ,_aa .MakeStringFromBytes (_eeaf ));};_cgcg .Add_TJ (_cdff ...);};_cgcg .Add_ET ();_cgcg .Add_Q ();_bgef :=_cgcg .Operations ();_bgef .WrapIfNeeded ();_gdcbg .addContents (_bgef );if _gdfa ._aage .isRelative (){_fbdbg :=_gdfa .Height ()+_gdfa ._dfdg ._ebfe ;_gebce .Y +=_fbdbg ;_gebce .Height -=_fbdbg ;if _gebce .Inline {_gebce .X +=_gdfa .Width ()+_gdfa ._dfdg ._gac ;};};return _gebce ,nil ;};func _fggf (_ced *_eb .ContentStreamOperations ,_aea *_ggb .PdfPageResources ,_bbg *_eb .ContentStreamOperations ,_adb *_ggb .PdfPageResources )error {_ggd :=map[_aa .PdfObjectName ]_aa .PdfObjectName {};_cccc :=map[_aa .PdfObjectName ]_aa .PdfObjectName {};_bdd :=map[_aa .PdfObjectName ]_aa .PdfObjectName {};_fdg :=map[_aa .PdfObjectName ]_aa .PdfObjectName {};_gffe :=map[_aa .PdfObjectName ]_aa .PdfObjectName {};_eg :=map[_aa .PdfObjectName ]_aa .PdfObjectName {};for _ ,_efa :=range *_bbg {switch _efa .Operand {case "\u0044\u006f":if len (_efa .Params )==1{if _bdfa ,_geb :=_efa .Params [0].(*_aa .PdfObjectName );_geb {if _ ,_ace :=_ggd [*_bdfa ];!_ace {var _ccad _aa .PdfObjectName ;_abgb ,_ :=_adb .GetXObjectByName (*_bdfa );if _abgb !=nil {_ccad =*_bdfa ;for {_dga ,_ :=_aea .GetXObjectByName (_ccad );if _dga ==nil ||_dga ==_abgb {break ;};_ccad =_ccad +"\u0030";};};_aea .SetXObjectByName (_ccad ,_abgb );_ggd [*_bdfa ]=_ccad ;};_dcgc :=_ggd [*_bdfa ];_efa .Params [0]=&_dcgc ;};};case "\u0054\u0066":if len (_efa .Params )==2{if _afg ,_abf :=_efa .Params [0].(*_aa .PdfObjectName );_abf {if _ ,_dce :=_cccc [*_afg ];!_dce {_bab ,_fef :=_adb .GetFontByName (*_afg );_gfa :=*_afg ;if _fef &&_bab !=nil {_gfa =_deb (_afg .String (),_bab ,_aea );};_aea .SetFontByName (_gfa ,_bab );_cccc [*_afg ]=_gfa ;};_bec :=_cccc [*_afg ];_efa .Params [0]=&_bec ;};};case "\u0043\u0053","\u0063\u0073":if len (_efa .Params )==1{if _add ,_gee :=_efa .Params [0].(*_aa .PdfObjectName );_gee {if _ ,_faa :=_bdd [*_add ];!_faa {var _dfc _aa .PdfObjectName ;_gbf ,_fec :=_adb .GetColorspaceByName (*_add );if _fec {_dfc =*_add ;for {_adc ,_dbb :=_aea .GetColorspaceByName (_dfc );if !_dbb ||_gbf ==_adc {break ;};_dfc =_dfc +"\u0030";};_aea .SetColorspaceByName (_dfc ,_gbf );_bdd [*_add ]=_dfc ;}else {_gg .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _ee ,_fff :=_bdd [*_add ];_fff {_efa .Params [0]=&_ee ;}else {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_add );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_efa .Params )==1{if _cec ,_gea :=_efa .Params [0].(*_aa .PdfObjectName );_gea {if _ ,_cbb :=_fdg [*_cec ];!_cbb {var _gcb _aa .PdfObjectName ;_cdc ,_adcb :=_adb .GetPatternByName (*_cec );if _adcb {_gcb =*_cec ;for {_dcd ,_gge :=_aea .GetPatternByName (_gcb );if !_gge ||_dcd ==_cdc {break ;};_gcb =_gcb +"\u0030";};_cgg :=_aea .SetPatternByName (_gcb ,_cdc .ToPdfObject ());if _cgg !=nil {return _cgg ;};_fdg [*_cec ]=_gcb ;};};if _ecc ,_dfb :=_fdg [*_cec ];_dfb {_efa .Params [0]=&_ecc ;};};};case "\u0073\u0068":if len (_efa .Params )==1{if _ddab ,_faf :=_efa .Params [0].(*_aa .PdfObjectName );_faf {if _ ,_ade :=_gffe [*_ddab ];!_ade {var _cae _aa .PdfObjectName ;_fgb ,_cdf :=_adb .GetShadingByName (*_ddab );if _cdf {_cae =*_ddab ;for {_eda ,_fbg :=_aea .GetShadingByName (_cae );if !_fbg ||_fgb ==_eda {break ;};_cae =_cae +"\u0030";};_dbbc :=_aea .SetShadingByName (_cae ,_fgb .ToPdfObject ());if _dbbc !=nil {_gg .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_dbbc );return _dbbc ;};_gffe [*_ddab ]=_cae ;}else {_gg .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _gbcd ,_cba :=_gffe [*_ddab ];_cba {_efa .Params [0]=&_gbcd ;}else {_gg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ddab );};};};case "\u0067\u0073":if len (_efa .Params )==1{if _gde ,_dcea :=_efa .Params [0].(*_aa .PdfObjectName );_dcea {if _ ,_ged :=_eg [*_gde ];!_ged {var _fcc _aa .PdfObjectName ;_fbb ,_bbgc :=_adb .GetExtGState (*_gde );if _bbgc {_fcc =*_gde ;_dbe :=1;for {_bgf ,_deca :=_aea .GetExtGState (_fcc );if !_deca ||_fbb ==_bgf {break ;};_fcc =_aa .PdfObjectName (_eac .Sprintf ("\u0047\u0053\u0025\u0064",_dbe ));_dbe ++;};};_aea .AddExtGState (_fcc ,_fbb );_eg [*_gde ]=_fcc ;};_becg :=_eg [*_gde ];_efa .Params [0]=&_becg ;};};};*_ced =append (*_ced ,_efa );};return nil ;};func (_gec *Creator )setActivePage (_ddbb *_ggb .PdfPage ){_gec ._begd =_ddbb };

// AddLine appends a new line to the invoice line items table.
func (_ecgg *Invoice )AddLine (values ...string )[]*InvoiceCell {_dcbb :=len (_ecgg ._gdaed );var _adbd []*InvoiceCell ;for _efcc ,_gaff :=range values {_dgbe :=_ecgg .newCell (_gaff ,_ecgg ._becd );if _efcc < _dcbb {_dgbe .Alignment =_ecgg ._gdaed [_efcc ].Alignment ;};_adbd =append (_adbd ,_dgbe );};_ecgg ._cdgc =append (_ecgg ._cdgc ,_adbd );return _adbd ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_agfe *Paragraph )SetWidth (width float64 ){_agfe ._fadb =width ;_agfe .wrapText ()};

// SetBorderWidth sets the border width.
func (_aaeg *Ellipse )SetBorderWidth (bw float64 ){_aaeg ._gcc =bw };func (_adba *Table )resetColumnWidths (){_adba ._eegg =[]float64 {};_abcd :=float64 (1.0)/float64 (_adba ._adcf );for _efaa :=0;_efaa < _adba ._adcf ;_efaa ++{_adba ._eegg =append (_adba ._eegg ,_abcd );};};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_adbb *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_adbb ._caefg =alignment };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ebae *_ggb .PdfColorDeviceRGB ;_dfef _gb .LineStyle ;_fegdg CellBorderStyle ;_acdgf *_ggb .PdfColorDeviceRGB ;_fdcfg float64 ;_gafc CellBorderStyle ;_acfa *_ggb .PdfColorDeviceRGB ;_ecfbf float64 ;_cgff CellBorderStyle ;_cfec *_ggb .PdfColorDeviceRGB ;_bcdg float64 ;_aaad CellBorderStyle ;_bdbg *_ggb .PdfColorDeviceRGB ;_egaab float64 ;_edec ,_dbcgb int ;_cbef int ;_gedg int ;_gcce VectorDrawable ;_cfaf CellHorizontalAlignment ;_edaead CellVerticalAlignment ;_gdegf float64 ;_gdaeb *Table ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bfge *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bdbc float64 ;var _bcgfa []*StyledParagraph ;for _ ,_fcaa :=range _bfge ._gedee {_caeca :=_bcbd (_bfge ._caace );_caeca .SetEnableWrap (false );_caeca .SetTextAlignment (TextAlignmentRight );_caeca .Append (_fcaa ._fagf .Text ).Style =_fcaa ._fagf .Style ;_agccd :=_caeca .getTextWidth ()/1000.0/ctx .Width ;if _bdbc < _agccd {_bdbc =_agccd ;};_bcgfa =append (_bcgfa ,_caeca );};_efaf :=_begbg (2);_efaf .SetColumnWidths (_bdbc ,1-_bdbc );_efaf .SetMargins (_bfge ._fafc ,0,0,0);for _dafe ,_gddee :=range _bfge ._gedee {_fedd :=_efaf .NewCell ();_fedd .SetIndent (0);_fedd .SetContent (_bcgfa [_dafe ]);_fedd =_efaf .NewCell ();_fedd .SetIndent (0);_fedd .SetContent (_gddee ._eagc );};return _efaf .GeneratePageBlocks (ctx );};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_fccc *TOC )SetLineNumberStyle (style TextStyle ){_fccc ._geacf =style };

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_bgbe *Ellipse )GetCoords ()(float64 ,float64 ){return _bgbe ._cfdf ,_bgbe ._dbg };

// NewTOC creates a new table of contents.
func (_afcf *Creator )NewTOC (title string )*TOC {_gbef :=_afcf .NewTextStyle ();_gbef .Font =_afcf ._cefd ;return _aaega (title ,_afcf .NewTextStyle (),_gbef );};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gfdgg *TOCLine )SetStyle (style TextStyle ){_gfdgg .Number .Style =style ;_gfdgg .Title .Style =style ;_gfdgg .Separator .Style =style ;_gfdgg .Page .Style =style ;};

// NewFilledCurve returns a instance of filled curve.
func (_fbac *Creator )NewFilledCurve ()*FilledCurve {return _fac ()};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_fegee *Invoice )SetColumns (cols []*InvoiceCell ){_fegee ._gdaed =cols };

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_gcd *Division )Width ()float64 {return 0};

// SetFillColor sets the fill color.
func (_ccgd *Rectangle )SetFillColor (col Color ){_ccgd ._abfde =_ggb .NewPdfColorDeviceRGB (col .ToRGB ());};func (_bfea *StyledParagraph )getLineHeight (_ffdg int )(_cgfb ,_befc float64 ){if _bfea ._bgcf ==nil ||len (_bfea ._bgcf )==0{_bfea .wrapText ();};if _ffdg < 0||_ffdg > len (_bfea ._bgcf )-1{_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_ffdg );return 0,0;};_dccag :=_bfea ._bgcf [_ffdg ];for _ ,_befd :=range _dccag {_bgcb ,_aegd :=_befd .Style .Font .GetFontDescriptor ();if _aegd !=nil {_gg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _fbdbd float64 ;if _bgcb !=nil {if _fbdbd ,_aegd =_bgcb .GetCapHeight ();_aegd !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_aegd );};};if int (_fbdbd )<=0{_gg .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_fbdbd =1000;};_gagg :=_fbdbd /1000.0*_befd .Style .FontSize *_bfea ._cdfgf ;if _gagg > _cgfb {_cgfb =_gagg ;};_gagg =_bfea ._cdfgf *_befd .Style .FontSize ;if _gagg > _befc {_befc =_gagg ;};};return _cgfb ,_befc ;};

// SetAngle sets the rotation angle in degrees.
func (_cg *Block )SetAngle (angleDeg float64 ){_cg ._eba =angleDeg };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_ebeaf *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gcgf ,_edeg :=_edef .setOpacity (_ebeaf ._ebeed ,_ebeaf ._dfff );if _edeg !=nil {return nil ,ctx ,_edeg ;};_efede :=_ebeaf ._ecccb ;_efede .FillEnabled =_efede .FillColor !=nil ;_efede .BorderEnabled =_efede .BorderColor !=nil &&_efede .BorderWidth > 0;_aeff :=_efede .Points ;for _gadde :=range _aeff {for _cgf :=range _aeff [_gadde ]{_edcfdf :=&_aeff [_gadde ][_cgf ];_edcfdf .Y =ctx .PageHeight -_edcfdf .Y ;};};_cfgc ,_ ,_edeg :=_efede .Draw (_gcgf );if _edeg !=nil {return nil ,ctx ,_edeg ;};if _edeg =_edef .addContentsByString (string (_cfgc ));_edeg !=nil {return nil ,ctx ,_edeg ;};return []*Block {_edef },ctx ,nil ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_faafgg *Table )MultiColCell (colspan int )*TableCell {return _faafgg .newCell (colspan )};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_egfg *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _egfg ._gbbc [0],_egfg ._gbbc [1]};

// Add adds a new line with the default style to the table of contents.
func (_gaafe *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_ecac :=_gaafe .AddLine (_ggge (TextChunk {Text :number ,Style :_gaafe ._geacf },TextChunk {Text :title ,Style :_gaafe ._fade },TextChunk {Text :page ,Style :_gaafe ._abddd },level ,_gaafe ._ffdcd ));if _ecac ==nil {return nil ;};_ebfae :=&_gaafe ._bbdd ;_ecac .SetMargins (_ebfae ._edbg ,_ebfae ._gac ,_ebfae ._fedcf ,_ebfae ._ebfe );_ecac .SetLevelOffset (_gaafe ._dgfb );_ecac .Separator .Text =_gaafe ._cffed ;_ecac .Separator .Style =_gaafe ._cbfac ;return _ecac ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_aee *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dafee ,_efcf :=_cbga .setOpacity (_aee ._cffg ,_aee ._cffg );if _efcf !=nil {return nil ,ctx ,_efcf ;};_bgff :=_aee ._agcd .Points ;for _egcc :=range _bgff {_bedb :=&_bgff [_egcc ];_bedb .Y =ctx .PageHeight -_bedb .Y ;};_daafe ,_ ,_efcf :=_aee ._agcd .Draw (_dafee );if _efcf !=nil {return nil ,ctx ,_efcf ;};if _efcf =_cbga .addContentsByString (string (_daafe ));_efcf !=nil {return nil ,ctx ,_efcf ;};return []*Block {_cbga },ctx ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fgbbd *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fgbbd ._bddbc ._edbg ,_fgbbd ._bddbc ._gac ,_fgbbd ._bddbc ._fedcf ,_fgbbd ._bddbc ._ebfe ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_cfdag *TOC )SetShowLinks (showLinks bool ){_cfdag ._dbda =showLinks };func _bddgd (_febc *_ggb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_febc ,FontSize :10};};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_ecg *Creator )SetPageSize (size PageSize ){_ecg ._dead =size ;_ecg ._edcf =size [0];_ecg ._gagc =size [1];_fabc :=0.1*_ecg ._edcf ;_ecg ._eaca ._edbg =_fabc ;_ecg ._eaca ._gac =_fabc ;_ecg ._eaca ._fedcf =_fabc ;_ecg ._eaca ._ebfe =_fabc ;};

// NewCellProps returns the default properties of an invoice cell.
func (_ecge *Invoice )NewCellProps ()InvoiceCellProps {_beac :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_ecge ._ggca ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_beac ,BorderColor :_beac ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};

// SetIndent sets the cell's left indent.
func (_dcba *TableCell )SetIndent (indent float64 ){_dcba ._gdegf =indent };func (_efg *Block )setOpacity (_bd float64 ,_ga float64 )(string ,error ){if (_bd < 0||_bd >=1.0)&&(_ga < 0||_ga >=1.0){return "",nil ;};_gag :=0;_be :=_eac .Sprintf ("\u0047\u0053\u0025\u0064",_gag );for _efg ._ce .HasExtGState (_aa .PdfObjectName (_be )){_gag ++;_be =_eac .Sprintf ("\u0047\u0053\u0025\u0064",_gag );};_ab :=_aa .MakeDict ();if _bd >=0&&_bd < 1.0{_ab .Set ("\u0063\u0061",_aa .MakeFloat (_bd ));};if _ga >=0&&_ga < 1.0{_ab .Set ("\u0043\u0041",_aa .MakeFloat (_ga ));};_bff :=_efg ._ce .AddExtGState (_aa .PdfObjectName (_be ),_ab );if _bff !=nil {return "",_bff ;};return _be ,nil ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_gabf *Image )SetEncoder (encoder _aa .StreamEncoder ){_gabf ._dbde =encoder };

// Height returns the height of the list.
func (_bcbc *List )Height ()float64 {var _aecd float64 ;for _ ,_begg :=range _bcbc ._gedee {_aecd +=_begg ._eagc .Height ();};return _aecd ;};

// SetWidthBottom sets border width for bottom.
func (_dgae *border )SetWidthBottom (bw float64 ){_dgae ._dba =bw };

// SetPos sets absolute positioning with specified coordinates.
func (_aabcg *StyledParagraph )SetPos (x ,y float64 ){_aabcg ._aaaec =_fab ;_aabcg ._facgg =x ;_aabcg ._fbag =y ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_cdfcc *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cdfcc ._fgcfa ._edbg ,_cdfcc ._fgcfa ._gac ,_cdfcc ._fgcfa ._fedcf ,_cdfcc ._fgcfa ._ebfe ;};func (_ddfc *Invoice )generateLineBlocks (_deec DrawContext )([]*Block ,DrawContext ,error ){_cgge :=_begbg (len (_ddfc ._gdaed ));_cgge .SetMargins (0,0,25,0);for _ ,_aecf :=range _ddfc ._gdaed {_bgbed :=_bcbd (_aecf .TextStyle );_bgbed .SetMargins (0,0,1,0);_bgbed .Append (_aecf .Value );_gdea :=_cgge .NewCell ();_gdea .SetHorizontalAlignment (_aecf .Alignment );_gdea .SetBackgroundColor (_aecf .BackgroundColor );_ddfc .setCellBorder (_gdea ,_aecf );_gdea .SetContent (_bgbed );};for _ ,_fdaee :=range _ddfc ._cdgc {for _ ,_bcabf :=range _fdaee {_eeaca :=_bcbd (_bcabf .TextStyle );_eeaca .SetMargins (0,0,3,2);_eeaca .Append (_bcabf .Value );_gdgf :=_cgge .NewCell ();_gdgf .SetHorizontalAlignment (_bcabf .Alignment );_gdgf .SetBackgroundColor (_bcabf .BackgroundColor );_ddfc .setCellBorder (_gdgf ,_bcabf );_gdgf .SetContent (_eeaca );};};return _cgge .GeneratePageBlocks (_deec );};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_gcae *TOC )SetLineLevelOffset (levelOffset float64 ){_gcae ._dgfb =levelOffset };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_adfe *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_daca :=NewTextChunk (text ,_adfe ._aabc );_daca ._gagee =_bebd (page -1,x ,y ,zoom );return _adfe .appendChunk (_daca );};func (_eddf *Invoice )generateTotalBlocks (_ggdf DrawContext )([]*Block ,DrawContext ,error ){_cdfa :=_begbg (4);_cdfa .SetMargins (0,0,10,10);_fdgfg :=[][2]*InvoiceCell {_eddf ._gecb };_fdgfg =append (_fdgfg ,_eddf ._dggg ...);_fdgfg =append (_fdgfg ,_eddf ._efdge );for _ ,_abgcf :=range _fdgfg {_adfbg ,_eagf :=_abgcf [0],_abgcf [1];if _eagf .Value ==""{continue ;};_cdfa .SkipCells (2);_ceef :=_cdfa .NewCell ();_ceef .SetBackgroundColor (_adfbg .BackgroundColor );_ceef .SetHorizontalAlignment (_eagf .Alignment );_eddf .setCellBorder (_ceef ,_adfbg );_fgf :=_bcbd (_adfbg .TextStyle );_fgf .SetMargins (0,0,2,1);_fgf .Append (_adfbg .Value );_ceef .SetContent (_fgf );_ceef =_cdfa .NewCell ();_ceef .SetBackgroundColor (_eagf .BackgroundColor );_ceef .SetHorizontalAlignment (_eagf .Alignment );_eddf .setCellBorder (_ceef ,_adfbg );_fgf =_bcbd (_eagf .TextStyle );_fgf .SetMargins (0,0,2,1);_fgf .Append (_eagf .Value );_ceef .SetContent (_fgf );};return _cdfa .GeneratePageBlocks (_ggdf );};

// NewPolygon creates a new polygon.
func (_bcc *Creator )NewPolygon (points [][]_gb .Point )*Polygon {return _gcgc (points )};

// Add adds a new Drawable to the chapter.
func (_cdcg *Chapter )Add (d Drawable )error {if Drawable (_cdcg )==d {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_cdcg ._fbd =append (_cdcg ._fbd ,d );default:_gg .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _b .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dcce *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dcce ._eaca ._edbg =left ;_dcce ._eaca ._gac =right ;_dcce ._eaca ._fedcf =top ;_dcce ._eaca ._ebfe =bottom ;};

// SetStyleLeft sets border style for left side.
func (_cgc *border )SetStyleLeft (style CellBorderStyle ){_cgc ._ggf =style };func (_cbeg *StyledParagraph )getTextWidth ()float64 {var _dffgg float64 ;_dbccd :=len (_cbeg ._cdcgf );for _gebb ,_baee :=range _cbeg ._cdcgf {_baac :=&_baee .Style ;_cfaga :=len (_baee .Text );for _abgg ,_bcdaf :=range _baee .Text {if _bcdaf =='\u000A'{continue ;};_cbcg ,_bccc :=_baac .Font .GetRuneMetrics (_bcdaf );if !_bccc {_gg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bcdaf );return -1;};_dffgg +=_baac .FontSize *_cbcg .Wx ;if _bcdaf !=' '&&(_gebb !=_dbccd -1||_abgg !=_cfaga -1){_dffgg +=_baac .CharSpacing *1000.0;};};};return _dffgg ;};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_adbeg []VectorDrawable ;_gcea positioning ;_fbgg margins ;_dcdd bool ;};type positioning int ;

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_ecbe *Creator )NewTextStyle ()TextStyle {return _bddgd (_ecbe ._fdcf )};func (_cdad *Creator )newPage ()*_ggb .PdfPage {_dcgce :=_ggb .NewPdfPage ();_eacg :=_cdad ._dead [0];_ffece :=_cdad ._dead [1];_cccdg :=_ggb .PdfRectangle {Llx :0,Lly :0,Urx :_eacg ,Ury :_ffece };_dcgce .MediaBox =&_cccdg ;_cdad ._edcf =_eacg ;_cdad ._gagc =_ffece ;_cdad .initContext ();return _dcgce ;};func (_gab *Creator )initContext (){_gab ._gedb .X =_gab ._eaca ._edbg ;_gab ._gedb .Y =_gab ._eaca ._fedcf ;_gab ._gedb .Width =_gab ._edcf -_gab ._eaca ._gac -_gab ._eaca ._edbg ;_gab ._gedb .Height =_gab ._gagc -_gab ._eaca ._ebfe -_gab ._eaca ._fedcf ;_gab ._gedb .PageHeight =_gab ._gagc ;_gab ._gedb .PageWidth =_gab ._edcf ;_gab ._gedb .Margins =_gab ._eaca ;};

// SetBorderColor sets the cell's border color.
func (_fefed *TableCell )SetBorderColor (col Color ){_fefed ._acdgf =_ggb .NewPdfColorDeviceRGB (col .ToRGB ());_fefed ._acfa =_ggb .NewPdfColorDeviceRGB (col .ToRGB ());_fefed ._cfec =_ggb .NewPdfColorDeviceRGB (col .ToRGB ());_fefed ._bdbg =_ggb .NewPdfColorDeviceRGB (col .ToRGB ());};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_face *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_ffgc :=_bcbd (_face ._caace );_ffgc .Append (text );_ddac ,_dgff :=_face .Add (_ffgc );return _ffgc ,_ddac ,_dgff ;};

// Width returns the cell's width based on the input draw context.
func (_cbbab *TableCell )Width (ctx DrawContext )float64 {_aefdf :=float64 (0.0);for _aagd :=0;_aagd < _cbbab ._gedg ;_aagd ++{_aefdf +=_cbbab ._gdaeb ._eegg [_cbbab ._dbcgb +_aagd -1];};_edee :=ctx .Width *_aefdf ;return _edee ;};

// SetBorderColor sets the border color.
func (_befa *PolyBezierCurve )SetBorderColor (color Color ){_befa ._bcea .BorderColor =_ggb .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_fdab *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_fdab ._adcf {_gg .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdab ._eegg =widths ;return nil ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_acfb *TOCLine )SetLink (page int64 ,x ,y float64 ){_acfb ._efcb =x ;_acfb ._bffg =y ;_acfb ._bggac =page ;_bbfe :=_acfb ._cfgg ._aabc .Color ;_acfb .Number .Style .Color =_bbfe ;_acfb .Title .Style .Color =_bbfe ;_acfb .Separator .Style .Color =_bbfe ;_acfb .Page .Style .Color =_bbfe ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_ddbc *StyledParagraph )SetEnableWrap (enableWrap bool ){_ddbc ._feab =enableWrap ;_ddbc ._fgdg =false ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_fdd DrawContext )([]*Block ,DrawContext ,error );};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_cceg *List )Width ()float64 {return 0};

// The Image type is used to draw an image onto PDF.
type Image struct{_gdec *_ggb .XObjectImage ;_bbcd *_ggb .Image ;_fcd float64 ;_ddcb ,_adfd float64 ;_fefef ,_edff float64 ;_beaf positioning ;_caefg HorizontalAlignment ;_fdec float64 ;_cad float64 ;_fbgb float64 ;_ecgd margins ;_aeab ,_geafc float64 ;_dbde _aa .StreamEncoder ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// Title returns the title of the invoice.
func (_gagd *Invoice )Title ()string {return _gagd ._ddce };

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_eaed *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _eaed ._afaf ,_eaed ._aaea ,_eaed ._cagb ,_eaed ._ccab ;};

// SetAngle sets the rotation angle of the text.
func (_beabf *StyledParagraph )SetAngle (angle float64 ){_beabf ._efbd =angle };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_gedd *Invoice )TotalLines ()[][2]*InvoiceCell {_bgag :=[][2]*InvoiceCell {_gedd ._gecb };_bgag =append (_bgag ,_gedd ._dggg ...);return append (_bgag ,_gedd ._efdge );};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_bebb *Paragraph )SetMaxLines (maxLines int ){_bebb ._ecaa =maxLines ;_bebb .wrapText ()};

// Height returns the total height of all rows.
func (_afde *Table )Height ()float64 {_dgea :=float64 (0.0);for _ ,_fbcd :=range _afde ._facf {_dgea +=_fbcd ;};return _dgea ;};

// SetAngle sets the rotation angle of the text.
func (_bde *Paragraph )SetAngle (angle float64 ){_bde ._bcbcf =angle };func _afcc (_bcfb ,_aba ,_aaf ,_gacc float64 )*Ellipse {_dfee :=&Ellipse {};_dfee ._cfdf =_bcfb ;_dfee ._dbg =_aba ;_dfee ._abfd =_aaf ;_dfee ._gecg =_gacc ;_dfee ._fefeb =_ggb .NewPdfColorDeviceRGB (0,0,0);_dfee ._gcc =1.0;return _dfee ;};

// RotatedSize returns the width and height of the rotated block.
func (_abg *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_bgc ,_abc :=_gegfd (_abg ._f ,_abg ._dc ,_abg ._eba );return _bgc ,_abc ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_ffdc *FilledCurve )AppendCurve (curve _gb .CubicBezierCurve )*FilledCurve {_ffdc ._ccaf =append (_ffdc ._ccaf ,curve );return _ffdc ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_bcfg *List )Add (item VectorDrawable )(*TextChunk ,error ){_gbfbf :=&listItem {_eagc :item ,_fagf :_bcfg ._dbdb };switch _geded :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _geded ._bfgb {_geded ._fafc =15;};default:return nil ,_b .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_bcfg ._gedee =append (_bcfg ._gedee ,_gbfbf );return &_gbfbf ._fagf ,nil ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_eggg *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _b .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _b .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _b .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_eggg ._fgfb =true ;_eggg ._gebe =startRow ;_eggg ._dcfbd =endRow ;return nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// GetCoords returns coordinates of border.
func (_dgf *border )GetCoords ()(float64 ,float64 ){return _dgf ._ddc ,_dgf ._dea };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// SetText sets the text content of the Paragraph.
func (_afbc *Paragraph )SetText (text string ){_afbc ._dgbf =text };func _gcgc (_dgdd [][]_gb .Point )*Polygon {return &Polygon {_ecccb :&_gb .Polygon {Points :_dgdd },_ebeed :1.0,_dfff :1.0};};

// Invoice represents a configurable invoice template.
type Invoice struct{_ddce string ;_fegb *Image ;_ecfcb *InvoiceAddress ;_gaaf *InvoiceAddress ;_cggc string ;_gbbc [2]*InvoiceCell ;_fdgf [2]*InvoiceCell ;_dgge [2]*InvoiceCell ;_defg [][2]*InvoiceCell ;_gdaed []*InvoiceCell ;_cdgc [][]*InvoiceCell ;_gecb [2]*InvoiceCell ;_efdge [2]*InvoiceCell ;_dggg [][2]*InvoiceCell ;_fgbg [2]string ;_ccef [2]string ;_eafe [][2]string ;_ggca TextStyle ;_cbda TextStyle ;_baeg TextStyle ;_eafd TextStyle ;_gaba TextStyle ;_cffe TextStyle ;_cdd TextStyle ;_caaf InvoiceCellProps ;_fad InvoiceCellProps ;_becd InvoiceCellProps ;_aebe InvoiceCellProps ;_cde positioning ;};func (_ddfe *Invoice )drawSection (_fcde ,_dfcf string )[]*StyledParagraph {var _adbbg []*StyledParagraph ;if _fcde !=""{_aeae :=_bcbd (_ddfe ._cdd );_aeae .SetMargins (0,0,0,5);_aeae .Append (_fcde );_adbbg =append (_adbbg ,_aeae );};if _dfcf !=""{_eaeb :=_bcbd (_ddfe ._cffe );_eaeb .Append (_dfcf );_adbbg =append (_adbbg ,_eaeb );};return _adbbg ;};func (_dfeg *StyledParagraph )getTextLineWidth (_aaba []*TextChunk )float64 {var _gcad float64 ;_bbge :=len (_aaba );for _fefc ,_eabc :=range _aaba {_geee :=&_eabc .Style ;_ebdae :=len (_eabc .Text );for _dabg ,_dcee :=range _eabc .Text {if _dcee =='\u000A'{continue ;};_fdcg ,_fdgbg :=_geee .Font .GetRuneMetrics (_dcee );if !_fdgbg {_gg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dcee );return -1;};_gcad +=_geee .FontSize *_fdcg .Wx ;if _dcee !=' '&&(_fefc !=_bbge -1||_dabg !=_ebdae -1){_gcad +=_geee .CharSpacing *1000.0;};};};return _gcad ;};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_ebeg *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eaeg :=ctx ;var _gfac []*Block ;_bebc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ebeg ._aage .isRelative (){ctx .X +=_ebeg ._dfdg ._edbg ;ctx .Y +=_ebeg ._dfdg ._fedcf ;ctx .Width -=_ebeg ._dfdg ._edbg +_ebeg ._dfdg ._gac ;ctx .Height -=_ebeg ._dfdg ._fedcf +_ebeg ._dfdg ._ebfe ;_ebeg .SetWidth (ctx .Width );if _ebeg .Height ()> ctx .Height {_gfac =append (_gfac ,_bebc );_bebc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gfdg :=ctx ;_gfdg .Y =ctx .Margins ._fedcf ;_gfdg .X =ctx .Margins ._edbg +_ebeg ._dfdg ._edbg ;_gfdg .Height =ctx .PageHeight -ctx .Margins ._fedcf -ctx .Margins ._ebfe -_ebeg ._dfdg ._ebfe ;_gfdg .Width =ctx .PageWidth -ctx .Margins ._edbg -ctx .Margins ._gac -_ebeg ._dfdg ._edbg -_ebeg ._dfdg ._gac ;ctx =_gfdg ;};}else {if int (_ebeg ._fadb )<=0{_ebeg .SetWidth (_ebeg .getTextWidth ());};ctx .X =_ebeg ._fdcc ;ctx .Y =_ebeg ._bee ;};ctx ,_gbfe :=_bbgfg (_bebc ,_ebeg ,ctx );if _gbfe !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbfe );return nil ,ctx ,_gbfe ;};_gfac =append (_gfac ,_bebc );if _ebeg ._aage .isRelative (){ctx .X -=_ebeg ._dfdg ._edbg ;ctx .Width =_eaeg .Width ;return _gfac ,ctx ,nil ;};return _gfac ,_eaeg ,nil ;};const (_bbd positioning =iota ;_fab ;);

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_bca *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _bca ._gdec ==nil {if _accg :=_bca .makeXObject ();_accg !=nil {return nil ,ctx ,_accg ;};};var _afdc []*Block ;_cafd :=ctx ;_ggbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bca ._beaf .isRelative (){if _bca ._adfd > ctx .Height {_afdc =append (_afdc ,_ggbd );_ggbd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gacbg :=ctx ;_gacbg .Y =ctx .Margins ._fedcf ;_gacbg .X =ctx .Margins ._edbg +_bca ._ecgd ._edbg ;_gacbg .Height =ctx .PageHeight -ctx .Margins ._fedcf -ctx .Margins ._ebfe -_bca ._ecgd ._ebfe ;_gacbg .Width =ctx .PageWidth -ctx .Margins ._edbg -ctx .Margins ._gac -_bca ._ecgd ._edbg -_bca ._ecgd ._gac ;ctx =_gacbg ;}else {ctx .Y +=_bca ._ecgd ._fedcf ;ctx .Height -=_bca ._ecgd ._fedcf +_bca ._ecgd ._ebfe ;ctx .X +=_bca ._ecgd ._edbg ;ctx .Width -=_bca ._ecgd ._edbg +_bca ._ecgd ._gac ;};}else {ctx .X =_bca ._fdec ;ctx .Y =_bca ._cad ;};ctx ,_eeee :=_agd (_ggbd ,_bca ,ctx );if _eeee !=nil {return nil ,ctx ,_eeee ;};_afdc =append (_afdc ,_ggbd );if _bca ._beaf .isAbsolute (){ctx =_cafd ;}else {ctx .Y +=_bca ._ecgd ._ebfe ;ctx .Height -=_bca ._ecgd ._ebfe ;};return _afdc ,ctx ,nil ;};func _begbg (_eaae int )*Table {_dgdf :=&Table {_adcf :_eaae ,_fced :10.0,_eegg :[]float64 {},_facf :[]float64 {},_bedae :[]*TableCell {}};_dgdf .resetColumnWidths ();return _dgdf ;};

// Level returns the indentation level of the TOC line.
func (_gffg *TOCLine )Level ()uint {return _gffg ._fcdd };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_eef *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_eef ._eadf ._edbg =left ;_eef ._eadf ._gac =right ;_eef ._eadf ._fedcf =top ;_eef ._eadf ._ebfe =bottom ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_geaa *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dcde :=_gb .Circle {X :_geaa ._cfdf -_geaa ._abfd /2,Y :ctx .PageHeight -_geaa ._dbg -_geaa ._gecg /2,Width :_geaa ._abfd ,Height :_geaa ._gecg ,Opacity :1.0,BorderWidth :_geaa ._gcc };if _geaa ._fcfb !=nil {_dcde .FillEnabled =true ;_dcde .FillColor =_geaa ._fcfb ;};if _geaa ._fefeb !=nil {_dcde .BorderEnabled =true ;_dcde .BorderColor =_geaa ._fefeb ;_dcde .BorderWidth =_geaa ._gcc ;};_egf ,_ ,_bbcg :=_dcde .Draw ("");if _bbcg !=nil {return nil ,ctx ,_bbcg ;};_bbcg =_adae .addContentsByString (string (_egf ));if _bbcg !=nil {return nil ,ctx ,_bbcg ;};return []*Block {_adae },ctx ,nil ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetTerms sets the terms and conditions section of the invoice.
func (_edce *Invoice )SetTerms (title ,content string ){_edce ._ccef =[2]string {title ,content }};

// SetWidth sets line width.
func (_dded *Curve )SetWidth (width float64 ){_dded ._cgda =width };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_gaa *Creator )Finalize ()error {if _gaa ._ccga {return nil ;};_fgd :=len (_gaa ._bdba );_fbbgc :=0;if _gaa ._agbg !=nil {_fbbgc ++;};if _gaa .AddTOC {_gaa .initContext ();_gaa ._gedb .Page =_fbbgc +1;if _gaa ._bbgcg !=nil {if _becgd :=_gaa ._bbgcg (_gaa ._fecg );_becgd !=nil {return _becgd ;};};_afgb ,_ ,_abfe :=_gaa ._fecg .GeneratePageBlocks (_gaa ._gedb );if _abfe !=nil {_gg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_abfe );return _abfe ;};_fbbgc +=len (_afgb );_gadb :=_gaa ._fecg .Lines ();for _ ,_gbeg :=range _gadb {_dfbc ,_cdab :=_c .Atoi (_gbeg .Page .Text );if _cdab !=nil {continue ;};_gbeg .Page .Text =_c .Itoa (_dfbc +_fbbgc );};};_gdcfb :=false ;if _gaa ._agbg !=nil {_fgd ++;_caac :=_gaa .newPage ();_gaa ._bdba =append ([]*_ggb .PdfPage {_caac },_gaa ._bdba ...);_gaa .setActivePage (_caac );_fcg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fgd };_gaa ._agbg (_fcg );_gdcfb =true ;};if _gaa .AddTOC {_gaa .initContext ();if _gaa ._bbgcg !=nil {if _bge :=_gaa ._bbgcg (_gaa ._fecg );_bge !=nil {_gg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bge );return _bge ;};};_fedg :=_gaa ._fecg .Lines ();for _ ,_decagf :=range _fedg {_decagf ._bggac +=int64 (_fbbgc );};var _bga []*_ggb .PdfPage ;_fege ,_ ,_ :=_gaa ._fecg .GeneratePageBlocks (_gaa ._gedb );for _ ,_agc :=range _fege {_agc .SetPos (0,0);_fgd ++;_gede :=_gaa .newPage ();_bga =append (_bga ,_gede );_gaa .setActivePage (_gede );_gaa .Draw (_agc );};if _gdcfb {_eecg :=_gaa ._bdba [0];_dafb :=_gaa ._bdba [1:];_gaa ._bdba =append ([]*_ggb .PdfPage {_eecg },_bga ...);_gaa ._bdba =append (_gaa ._bdba ,_dafb ...);}else {_gaa ._bdba =append (_bga ,_gaa ._bdba ...);};};if _gaa ._gda !=nil &&_gaa .AddOutlines {var _dffe func (_beaa *_ggb .OutlineItem );_dffe =func (_gbg *_ggb .OutlineItem ){_gbg .Dest .Page +=int64 (_fbbgc );if _bada :=int (_gbg .Dest .Page );_bada >=0&&_bada < len (_gaa ._bdba ){_gbg .Dest .PageObj =_gaa ._bdba [_bada ].GetPageAsIndirectObject ();}else {_gg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bada );};_gbg .Dest .Y =_gaa ._gagc -_gbg .Dest .Y ;_caec :=_gbg .Items ();for _ ,_cbc :=range _caec {_dffe (_cbc );};};_cfgf :=_gaa ._gda .Items ();for _ ,_dfac :=range _cfgf {_dffe (_dfac );};if _gaa .AddTOC {var _gfeb int ;if _gdcfb {_gfeb =1;};_adfa :=_ggb .NewOutlineDest (int64 (_gfeb ),0,_gaa ._gagc );if _gfeb >=0&&_gfeb < len (_gaa ._bdba ){_adfa .PageObj =_gaa ._bdba [_gfeb ].GetPageAsIndirectObject ();}else {_gg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gfeb );};_gaa ._gda .Insert (0,_ggb .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_adfa ));};};for _fabb ,_ffaf :=range _gaa ._bdba {_gaa .setActivePage (_ffaf );if _gaa ._cgeb !=nil {_edbgf :=NewBlock (_gaa ._edcf ,_gaa ._eaca ._fedcf );_edf :=HeaderFunctionArgs {PageNum :_fabb +1,TotalPages :_fgd };_gaa ._cgeb (_edbgf ,_edf );_edbgf .SetPos (0,0);if _aga :=_gaa .Draw (_edbgf );_aga !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_aga );return _aga ;};};if _gaa ._fccb !=nil {_gfcd :=NewBlock (_gaa ._edcf ,_gaa ._eaca ._ebfe );_aec :=FooterFunctionArgs {PageNum :_fabb +1,TotalPages :_fgd };_gaa ._fccb (_gfcd ,_aec );_gfcd .SetPos (0,_gaa ._gagc -_gfcd ._dc );if _bdcg :=_gaa .Draw (_gfcd );_bdcg !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_bdcg );return _bdcg ;};};_age ,_geea :=_gaa ._bfbg [_ffaf ];if !_geea {continue ;};if _bbb :=_age .drawToPage (_ffaf );_bbb !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_fabb +1,_bbb );return _bbb ;};};_gaa ._ccga =true ;return nil ;};

// SetLineColor sets the line color.
func (_dgca *Polyline )SetLineColor (color Color ){_dgca ._agcd .LineColor =_ggb .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetSubtotal sets the subtotal of the invoice.
func (_fbggg *Invoice )SetSubtotal (value string ){_fbggg ._gecb [1].Value =value };func (_ebb *Block )translate (_fae ,_cga float64 ){_fgg :=_eb .NewContentCreator ().Translate (_fae ,-_cga ).Operations ();*_ebb ._ae =append (*_fgg ,*_ebb ._ae ...);_ebb ._ae .WrapIfNeeded ();};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_daae *Creator )NewImageFromGoImage (goimg _a .Image )(*Image ,error ){return _dfde (goimg )};

// SetTitle sets the title of the invoice.
func (_gefb *Invoice )SetTitle (title string ){_gefb ._ddce =title };

// NewDivision returns a new Division container component.
func (_ebfa *Creator )NewDivision ()*Division {return _eeab ()};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_gedee []*listItem ;_gebc margins ;_dbdb TextChunk ;_fafc float64 ;_bfgb bool ;_cgcf positioning ;_caace TextStyle ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_ecae *Creator )MoveRight (dx float64 ){_ecae ._gedb .X +=dx };

// Notes returns the notes section of the invoice as a title-content pair.
func (_edbfe *Invoice )Notes ()(string ,string ){return _edbfe ._fgbg [0],_edbfe ._fgbg [1]};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_gad *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gad ._eadf ._edbg ,_gad ._eadf ._gac ,_gad ._eadf ._fedcf ,_gad ._eadf ._ebfe ;};

// NewPolyline creates a new polyline.
func (_abbb *Creator )NewPolyline (points []_gb .Point )*Polyline {return _fdgb (points )};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_edcfd *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _edcfd ._fdgf [0],_edcfd ._fdgf [1]};func _eeab ()*Division {return &Division {_adbeg :[]VectorDrawable {}}};

// SetBorderColor sets the border color.
func (_bedc *Polygon )SetBorderColor (color Color ){_bedc ._ecccb .BorderColor =_ggb .NewPdfColorDeviceRGB (color .ToRGB ());};

// NewTable create a new Table with a specified number of columns.
func (_bedf *Creator )NewTable (cols int )*Table {return _begbg (cols )};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// NewInvoice returns an instance of an empty invoice.
func (_ddba *Creator )NewInvoice ()*Invoice {_fgaa :=_ddba .NewTextStyle ();_fgaa .Font =_ddba ._cefd ;return _dbfb (_ddba .NewTextStyle (),_fgaa );};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_fdbe *Rectangle )GetCoords ()(float64 ,float64 ){return _fdbe ._deeba ,_fdbe ._gcdd };

// AppendColumn appends a column to the line items table.
func (_ecfg *Invoice )AppendColumn (description string )*InvoiceCell {_edge :=_ecfg .NewColumn (description );_ecfg ._gdaed =append (_ecfg ._gdaed ,_edge );return _edge ;};

// SetPos sets absolute positioning with specified coordinates.
func (_gcdg *Paragraph )SetPos (x ,y float64 ){_gcdg ._aage =_fab ;_gcdg ._fdcc =x ;_gcdg ._bee =y };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);func _fac ()*FilledCurve {_fbgc :=FilledCurve {};_fbgc ._ccaf =[]_gb .CubicBezierCurve {};return &_fbgc ;};

// Reset removes all the text chunks the paragraph contains.
func (_ggcg *StyledParagraph )Reset (){_ggcg ._cdcgf =[]*TextChunk {}};

// LevelOffset returns the amount of space an indentation level occupies.
func (_adcg *TOCLine )LevelOffset ()float64 {return _adcg ._bfff };

// SetFillColor sets the fill color.
func (_ccbf *Polygon )SetFillColor (color Color ){_ccbf ._ecccb .FillColor =_ggb .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetLineWidth sets the line width.
func (_afgbb *Line )SetLineWidth (lw float64 ){_afgbb ._caed =lw };func (_bggg *FilledCurve )draw (_deeb string )([]byte ,*_ggb .PdfRectangle ,error ){_gaeg :=_gb .NewCubicBezierPath ();for _ ,_geaf :=range _bggg ._ccaf {_gaeg =_gaeg .AppendCurve (_geaf );};creator :=_eb .NewContentCreator ();creator .Add_q ();if _bggg .FillEnabled {creator .Add_rg (_bggg ._acbg .R (),_bggg ._acbg .G (),_bggg ._acbg .B ());};if _bggg .BorderEnabled {creator .Add_RG (_bggg ._efbf .R (),_bggg ._efbf .G (),_bggg ._efbf .B ());creator .Add_w (_bggg .BorderWidth );};if len (_deeb )> 1{creator .Add_gs (_aa .PdfObjectName (_deeb ));};_gb .DrawBezierPathWithCreator (_gaeg ,creator );creator .Add_h ();if _bggg .FillEnabled &&_bggg .BorderEnabled {creator .Add_B ();}else if _bggg .FillEnabled {creator .Add_f ();}else if _bggg .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_bgd :=_gaeg .GetBoundingBox ();if _bggg .BorderEnabled {_bgd .Height +=_bggg .BorderWidth ;_bgd .Width +=_bggg .BorderWidth ;_bgd .X -=_bggg .BorderWidth /2;_bgd .Y -=_bggg .BorderWidth /2;};_cbgb :=&_ggb .PdfRectangle {};_cbgb .Llx =_bgd .X ;_cbgb .Lly =_bgd .Y ;_cbgb .Urx =_bgd .X +_bgd .Width ;_cbgb .Ury =_bgd .Y +_bgd .Height ;return creator .Bytes (),_cbgb ,nil ;};

// Heading returns the heading component of the table of contents.
func (_aafa *TOC )Heading ()*StyledParagraph {return _aafa ._gacf };func (_adcd *Paragraph )getTextWidth ()float64 {_babd :=0.0;for _ ,_gbdg :=range _adcd ._dgbf {if _gbdg =='\u000A'{continue ;};_abdc ,_fbge :=_adcd ._eccc .GetRuneMetrics (_gbdg );if !_fbge {_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gbdg ,_gbdg );return -1;};_babd +=_adcd ._fbga *_abdc .Wx ;};return _babd ;};func (_gcfe *TOCLine )prepareParagraph (_dada *StyledParagraph ,_baea DrawContext ){_ddfa :=_gcfe .Title .Text ;if _gcfe .Number .Text !=""{_ddfa ="\u0020"+_ddfa ;};_ddfa +="\u0020";_dccdf :=_gcfe .Page .Text ;if _dccdf !=""{_dccdf ="\u0020"+_dccdf ;};_dada ._cdcgf =[]*TextChunk {{Text :_gcfe .Number .Text ,Style :_gcfe .Number .Style ,_gagee :_gcfe .getLineLink ()},{Text :_ddfa ,Style :_gcfe .Title .Style ,_gagee :_gcfe .getLineLink ()},{Text :_dccdf ,Style :_gcfe .Page .Style ,_gagee :_gcfe .getLineLink ()}};_dada .wrapText ();_ccdf :=len (_dada ._bgcf );if _ccdf ==0{return ;};_dbeb :=_baea .Width *1000-_dada .getTextLineWidth (_dada ._bgcf [_ccdf -1]);_dfcc :=_dada .getTextLineWidth ([]*TextChunk {&_gcfe .Separator });_ffddd :=int (_dbeb /_dfcc );_cgfd :=_de .Repeat (_gcfe .Separator .Text ,_ffddd );_cabbfd :=_gcfe .Separator .Style ;_dgbef :=_dada .Insert (2,_cgfd );_dgbef .Style =_cabbfd ;_dgbef ._gagee =_gcfe .getLineLink ();_dbeb =_dbeb -float64 (_ffddd )*_dfcc ;if _dbeb > 500{_aace ,_addb :=_cabbfd .Font .GetRuneMetrics (' ');if _addb &&_dbeb > _aace .Wx {_gged :=int (_dbeb /_aace .Wx );if _gged > 0{_ggcb :=_cabbfd ;_ggcb .FontSize =1;_dgbef =_dada .Insert (2,_de .Repeat ("\u0020",_gged ));_dgbef .Style =_ggcb ;_dgbef ._gagee =_gcfe .getLineLink ();};};};};func _gegfd (_dbfde ,_ffade ,_bbab float64 )(_dabbb ,_ecgef ,_eeeee ,_baae float64 ){if _bbab ==0{return 0,0,_dbfde ,_ffade ;};_eggb :=_gb .Path {Points :[]_gb .Point {_gb .NewPoint (0,0).Rotate (_bbab ),_gb .NewPoint (_dbfde ,0).Rotate (_bbab ),_gb .NewPoint (0,_ffade ).Rotate (_bbab ),_gb .NewPoint (_dbfde ,_ffade ).Rotate (_bbab )}}.GetBoundingBox ();return _eggb .X ,_eggb .Y ,_eggb .Width ,_eggb .Height ;};func (_cbfg *StyledParagraph )wrapText ()error {if !_cbfg ._feab ||int (_cbfg ._agbad )<=0{_cbfg ._bgcf =[][]*TextChunk {_cbfg ._cdcgf };return nil ;};_cbfg ._bgcf =[][]*TextChunk {};var _ccacb []*TextChunk ;var _bbfb float64 ;_gdad :=func (_bbad *_ggb .PdfAnnotation )*_ggb .PdfAnnotation {if _bbad ==nil {return nil ;};var _dfffa *_ggb .PdfAnnotation ;switch _gaafa :=_bbad .GetContext ().(type ){case *_ggb .PdfAnnotationLink :if _fccge :=_aebg (_gaafa );_fccge !=nil {_dfffa =_fccge .PdfAnnotation ;};};return _dfffa ;};for _ ,_cddg :=range _cbfg ._cdcgf {_gdb :=_cddg .Style ;_abbd :=_cddg ._gagee ;var (_agfa []rune ;_eacc []float64 ;);for _ ,_gecbd :=range _cddg .Text {if _gecbd =='\u000A'{_ccacb =append (_ccacb ,&TextChunk {Text :_de .TrimRightFunc (string (_agfa ),_eab .IsSpace ),Style :_gdb ,_gagee :_gdad (_abbd )});_cbfg ._bgcf =append (_cbfg ._bgcf ,_ccacb );_ccacb =nil ;_bbfb =0;_agfa =nil ;_eacc =nil ;continue ;};_aefc :=_gecbd ==' ';_fggdag ,_fddc :=_gdb .Font .GetRuneMetrics (_gecbd );if !_fddc {_gg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_gecbd );return _b .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_bcffd :=_gdb .FontSize *_fggdag .Wx ;_eabf :=_bcffd ;if !_aefc {_eabf =_bcffd +_gdb .CharSpacing *1000.0;};if _bbfb +_bcffd > _cbfg ._agbad *1000.0{_adefaf :=-1;if !_aefc {for _fbdf :=len (_agfa )-1;_fbdf >=0;_fbdf --{if _agfa [_fbdf ]==' '{_adefaf =_fbdf ;break ;};};};_feec :=string (_agfa );if _adefaf >=0{_feec =string (_agfa [0:_adefaf +1]);_agfa =_agfa [_adefaf +1:];_agfa =append (_agfa ,_gecbd );_eacc =_eacc [_adefaf +1:];_eacc =append (_eacc ,_eabf );_bbfb =0;for _ ,_aecg :=range _eacc {_bbfb +=_aecg ;};}else {if _aefc {_bbfb =0;_agfa =[]rune {};_eacc =[]float64 {};}else {_bbfb =_eabf ;_agfa =[]rune {_gecbd };_eacc =[]float64 {_eabf };};};_ccacb =append (_ccacb ,&TextChunk {Text :_de .TrimRightFunc (string (_feec ),_eab .IsSpace ),Style :_gdb ,_gagee :_gdad (_abbd )});_cbfg ._bgcf =append (_cbfg ._bgcf ,_ccacb );_ccacb =[]*TextChunk {};}else {_bbfb +=_eabf ;_agfa =append (_agfa ,_gecbd );_eacc =append (_eacc ,_eabf );};};if len (_agfa )> 0{_ccacb =append (_ccacb ,&TextChunk {Text :string (_agfa ),Style :_gdb ,_gagee :_gdad (_abbd )});};};if len (_ccacb )> 0{_cbfg ._bgcf =append (_cbfg ._bgcf ,_ccacb );};return nil ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_eefd *Creator )EnableFontSubsetting (font *_ggb .PdfFont ){_eefd ._gcf =append (_eefd ._gcf ,font )};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cbge *Creator )Draw (d Drawable )error {if _cbge .getActivePage ()==nil {_cbge .NewPage ();};_cdabg ,_bbfa ,_fabd :=d .GeneratePageBlocks (_cbge ._gedb );if _fabd !=nil {return _fabd ;};for _fcb ,_bcfa :=range _cdabg {if _fcb > 0{_cbge .NewPage ();};_fgeg :=_cbge .getActivePage ();if _dbcg ,_aef :=_cbge ._bfbg [_fgeg ];_aef {if _gfg :=_dbcg .mergeBlocks (_bcfa );_gfg !=nil {return _gfg ;};if _ebfg :=_eae (_bcfa ._ce ,_dbcg ._ce );_ebfg !=nil {return _ebfg ;};}else {_cbge ._bfbg [_fgeg ]=_bcfa ;};};_cbge ._gedb .X =_bbfa .X ;_cbge ._gedb .Y =_bbfa .Y ;_cbge ._gedb .Height =_bbfa .PageHeight -_bbfa .Y -_bbfa .Margins ._ebfe ;return nil ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_daff *Invoice )TitleStyle ()TextStyle {return _daff ._baeg };

// Margins returns the margins of the list: left, right, top, bottom.
func (_dbff *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _dbff ._gebc ._edbg ,_dbff ._gebc ._gac ,_dbff ._gebc ._fedcf ,_dbff ._gebc ._ebfe ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_daac int ;_adcf int ;_eega int ;_eegg []float64 ;_facf []float64 ;_fced float64 ;_bedae []*TableCell ;_dafba positioning ;_fecfa ,_efcfc float64 ;_fgcfa margins ;_fgfb bool ;_gebe int ;_dcfbd int ;};func _dae (_aac []_gb .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_bcea :&_gb .PolyBezierCurve {Curves :_aac ,BorderColor :_ggb .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_bfbgf :1.0,_bddg :1.0};};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_bged *TOC )SetLinePageStyle (style TextStyle ){_bged ._abddd =style };

// SetSellerAddress sets the seller address of the invoice.
func (_febg *Invoice )SetSellerAddress (address *InvoiceAddress ){_febg ._gaaf =address };

// SetFontSize sets the font size in document units (points).
func (_bef *Paragraph )SetFontSize (fontSize float64 ){_bef ._fbga =fontSize };func (_ag *Block )duplicate ()*Block {_cgb :=&Block {};*_cgb =*_ag ;_ebe :=_eb .ContentStreamOperations {};for _ ,_bc :=range *_ag ._ae {_ebe =append (_ebe ,_bc );};_cgb ._ae =&_ebe ;return _cgb ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_dcfb *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edfg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fbaa ,_ccdb :=_edfg .setOpacity (_dcfb ._bfbgf ,_dcfb ._bddg );if _ccdb !=nil {return nil ,ctx ,_ccdb ;};_bffb :=_dcfb ._bcea ;_bffb .FillEnabled =_bffb .FillColor !=nil ;_daaea :=_bffb .Curves ;_acbd :=ctx .PageHeight ;for _fadc :=range _daaea {_agdb :=&_daaea [_fadc ];_agdb .P0 .Y =_acbd -_agdb .P0 .Y ;_agdb .P1 .Y =_acbd -_agdb .P1 .Y ;_agdb .P2 .Y =_acbd -_agdb .P2 .Y ;_agdb .P3 .Y =_acbd -_agdb .P3 .Y ;};_faecd ,_ ,_ccdb :=_bffb .Draw (_fbaa );if _ccdb !=nil {return nil ,ctx ,_ccdb ;};if _ccdb =_edfg .addContentsByString (string (_faecd ));_ccdb !=nil {return nil ,ctx ,_ccdb ;};return []*Block {_edfg },ctx ,nil ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_cbad *Creator )DrawFooter (drawFooterFunc func (_fbcaa *Block ,_edbc FooterFunctionArgs )){_cbad ._fccb =drawFooterFunc ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_eafb *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_fddd :=[2]*InvoiceCell {_eafb .newCell (description ,_eafb ._caaf ),_eafb .newCell (value ,_eafb ._caaf )};_eafb ._defg =append (_eafb ._defg ,_fddd );return _fddd [0],_fddd [1];};var PPI float64 =72;

// SetLineHeight sets the line height (1.0 default).
func (_bcffc *StyledParagraph )SetLineHeight (lineheight float64 ){_bcffc ._cdfgf =lineheight };func _ggge (_eeegg ,_dgggb ,_bafed TextChunk ,_fffgg uint ,_aged TextStyle )*TOCLine {_aabaa :=_bcbd (_aged );_aabaa .SetEnableWrap (true );_aabaa .SetTextAlignment (TextAlignmentLeft );_aabaa .SetMargins (0,0,2,2);_acceg :=&TOCLine {_cfgg :_aabaa ,Number :_eeegg ,Title :_dgggb ,Page :_bafed ,Separator :TextChunk {Text :"\u002e",Style :_aged },_eacae :0,_fcdd :_fffgg ,_bfff :10,_faag :_bbd };_aabaa ._bddbc ._edbg =_acceg ._eacae +float64 (_acceg ._fcdd -1)*_acceg ._bfff ;_aabaa ._aggc =_acceg .prepareParagraph ;return _acceg ;};

// SetMargins sets the margins of the paragraph.
func (_bgcc *List )SetMargins (left ,right ,top ,bottom float64 ){_bgcc ._gebc ._edbg =left ;_bgcc ._gebc ._gac =right ;_bgcc ._gebc ._fedcf =top ;_bgcc ._gebc ._ebfe =bottom ;};

// SetDueDate sets the due date of the invoice.
func (_effa *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_effa ._dgge [1].Value =dueDate ;return _effa ._dgge [0],_effa ._dgge [1];};

// SetHeight sets the Image's document height to specified h.
func (_fabe *Image )SetHeight (h float64 ){_fabe ._adfd =h };

// SetText replaces all the text of the paragraph with the specified one.
func (_fgee *StyledParagraph )SetText (text string )*TextChunk {_fgee .Reset ();return _fgee .Append (text );};func _bebg ()*PageBreak {return &PageBreak {}};

// Angle returns the block rotation angle in degrees.
func (_fgc *Block )Angle ()float64 {return _fgc ._eba };

// Logo returns the logo of the invoice.
func (_badde *Invoice )Logo ()*Image {return _badde ._fegb };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_abdd float64 ;_bbc float64 ;_gbfd float64 ;_daaf float64 ;_cacg float64 ;_fdcfc float64 ;_efe *_ggb .PdfColorDeviceRGB ;_cgda float64 ;};

// GetOptimizer returns current PDF optimizer.
func (_ffec *Creator )GetOptimizer ()_ggb .Optimizer {return _ffec ._egd };func _efbe (_gcaee ,_ddbcc ,_fegdb string ,_fgbbc uint ,_eeba TextStyle )*TOCLine {return _ggge (TextChunk {Text :_gcaee ,Style :_eeba },TextChunk {Text :_ddbcc ,Style :_eeba },TextChunk {Text :_fegdb ,Style :_eeba },_fgbbc ,_eeba );};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_cagdg *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_cagdg ._edaead =valign };

// Lines returns all the lines the table of contents has.
func (_bgbbc *TOC )Lines ()[]*TOCLine {return _bgbbc ._cacfa };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bdga *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bdga .Text },nil ;};var _bdeb []string ;var _dbfe []rune ;var _efce float64 ;var _ggcc []float64 ;_gfbb :=_bdga .Style ;_cbea :=[]rune (_bdga .Text );for _ ,_cegb :=range _cbea {if _cegb =='\u000A'{_bdeb =append (_bdeb ,_de .TrimRightFunc (string (_dbfe ),_eab .IsSpace )+string (_cegb ));_dbfe =nil ;_efce =0;_ggcc =nil ;continue ;};_gadc :=_cegb ==' ';_dgfff ,_abfdd :=_gfbb .Font .GetRuneMetrics (_cegb );if !_abfdd {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_cegb ,_cegb ,_gfbb .Font .BaseFont (),_gfbb .Font .Subtype ());_gg .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_gfbb .Font );_gg .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_gfbb .Font .Encoder ());return nil ,_b .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_gcaa :=_gfbb .FontSize *_dgfff .Wx ;_edgdb :=_gcaa ;if !_gadc {_edgdb =_gcaa +_gfbb .CharSpacing *1000.0;};if _efce +_gcaa > width *1000.0{_gbea :=-1;if !_gadc {for _edcgf :=len (_dbfe )-1;_edcgf >=0;_edcgf --{if _dbfe [_edcgf ]==' '{_gbea =_edcgf ;break ;};};};_ccfb :=string (_dbfe );if _gbea > 0{_ccfb =string (_dbfe [0:_gbea +1]);_dbfe =append (_dbfe [_gbea +1:],_cegb );_ggcc =append (_ggcc [_gbea +1:],_edgdb );_efce =0;for _ ,_daea :=range _ggcc {_efce +=_daea ;};}else {if _gadc {_dbfe =[]rune {};_ggcc =[]float64 {};_efce =0;}else {_dbfe =[]rune {_cegb };_ggcc =[]float64 {_edgdb };_efce =_edgdb ;};};_bdeb =append (_bdeb ,_de .TrimRightFunc (_ccfb ,_eab .IsSpace ));}else {_dbfe =append (_dbfe ,_cegb );_efce +=_edgdb ;_ggcc =append (_ggcc ,_edgdb );};};if len (_dbfe )> 0{_bdeb =append (_bdeb ,string (_dbfe ));};return _bdeb ,nil ;};func (_dbce *Invoice )drawInformation ()*Table {_abe :=_begbg (2);_faedb :=append ([][2]*InvoiceCell {_dbce ._gbbc ,_dbce ._fdgf ,_dbce ._dgge },_dbce ._defg ...);for _ ,_becgc :=range _faedb {_cgee ,_addg :=_becgc [0],_becgc [1];if _addg .Value ==""{continue ;};_geac :=_abe .NewCell ();_geac .SetBackgroundColor (_cgee .BackgroundColor );_dbce .setCellBorder (_geac ,_cgee );_gdgc :=_bcbd (_cgee .TextStyle );_gdgc .Append (_cgee .Value );_gdgc .SetMargins (0,0,2,1);_geac .SetContent (_gdgc );_geac =_abe .NewCell ();_geac .SetBackgroundColor (_addg .BackgroundColor );_dbce .setCellBorder (_geac ,_addg );_gdgc =_bcbd (_addg .TextStyle );_gdgc .Append (_addg .Value );_gdgc .SetMargins (0,0,2,1);_geac .SetContent (_gdgc );};return _abe ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_dbed *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _ecd []*Block ;_cbdd :=ctx ;if _dbed ._gcea .isRelative (){ctx .X +=_dbed ._fbgg ._edbg ;ctx .Y +=_dbed ._fbgg ._fedcf ;ctx .Width -=_dbed ._fbgg ._edbg +_dbed ._fbgg ._gac ;ctx .Height -=_dbed ._fbgg ._fedcf +_dbed ._fbgg ._ebfe ;};ctx .Inline =_dbed ._dcdd ;_eabd :=ctx ;_fea :=ctx ;var _ffd float64 ;for _ ,_agf :=range _dbed ._adbeg {if ctx .Inline {if (ctx .X -_eabd .X )+_agf .Width ()<=ctx .Width {ctx .Y =_fea .Y ;ctx .Height =_fea .Height ;}else {ctx .X =_eabd .X ;ctx .Width =_eabd .Width ;_fea .Y +=_ffd ;_fea .Height -=_ffd ;_ffd =0;};};_gbed ,_fde ,_eegf :=_agf .GeneratePageBlocks (ctx );if _eegf !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_eegf );return nil ,ctx ,_eegf ;};if len (_gbed )< 1{continue ;};if len (_ecd )> 0{_ecd [len (_ecd )-1].mergeBlocks (_gbed [0]);_ecd =append (_ecd ,_gbed [1:]...);}else {_ecd =append (_ecd ,_gbed [0:]...);};if ctx .Inline {if ctx .Page !=_fde .Page {_eabd .Y =ctx .Margins ._fedcf ;_eabd .Height =ctx .PageHeight -ctx .Margins ._fedcf ;_fea .Y =_eabd .Y ;_fea .Height =_eabd .Height ;_ffd =_fde .Height -_eabd .Height ;}else {if _fgga :=ctx .Height -_fde .Height ;_fgga > _ffd {_ffd =_fgga ;};};}else {_fde .X =ctx .X ;};ctx =_fde ;};ctx .Inline =_cbdd .Inline ;if _dbed ._gcea .isRelative (){ctx .X =_cbdd .X ;};if _dbed ._gcea .isAbsolute (){return _ecd ,_cbdd ,nil ;};return _ecd ,ctx ,nil ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_caeg *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_dccd :=uint (len (_caeg ._gdaed ));if index > _dccd {index =_dccd ;};_edddd :=_caeg .NewColumn (description );_caeg ._gdaed =append (_caeg ._gdaed [:index ],append ([]*InvoiceCell {_edddd },_caeg ._gdaed [index :]...)...);return _edddd ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_fca *Invoice )NoteHeadingStyle ()TextStyle {return _fca ._cdd };

// SkipOver skips over a specified number of rows and cols.
func (_gfbc *Table )SkipOver (rows ,cols int ){_dcfc :=rows *_gfbc ._adcf +cols -1;if _dcfc < 0{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_gfbc ._eega +=_dcfc ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_bfe *Creator )SetPageLabels (pageLabels _aa .PdfObject ){_bfe ._gddf =pageLabels };

// New creates a new instance of the PDF Creator.
func New ()*Creator {_fag :=&Creator {};_fag ._bdba =[]*_ggb .PdfPage {};_fag ._bfbg =map[*_ggb .PdfPage ]*Block {};_fag .SetPageSize (PageSizeLetter );_eaab :=0.1*_fag ._edcf ;_fag ._eaca ._edbg =_eaab ;_fag ._eaca ._gac =_eaab ;_fag ._eaca ._fedcf =_eaab ;_fag ._eaca ._ebfe =_eaab ;var _fcee error ;_fag ._fdcf ,_fcee =_ggb .NewStandard14Font (_ggb .HelveticaName );if _fcee !=nil {_fag ._fdcf =_ggb .DefaultFont ();};_fag ._cefd ,_fcee =_ggb .NewStandard14Font (_ggb .HelveticaBoldName );if _fcee !=nil {_fag ._fdcf =_ggb .DefaultFont ();};_fag ._fecg =_fag .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_fag .AddOutlines =true ;_fag ._gda =_ggb .NewOutline ();return _fag ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_eafc *StyledParagraph )Height ()float64 {_eafc .wrapText ();var _abca float64 ;for _ ,_caggb :=range _eafc ._bgcf {var _dffd float64 ;for _ ,_fbbc :=range _caggb {_bcdfa :=_eafc ._cdfgf *_fbbc .Style .FontSize ;if _bcdfa > _dffd {_dffd =_bcdfa ;};};_abca +=_dffd ;};return _abca ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ae *_eb .ContentStreamOperations ;_ce *_ggb .PdfPageResources ;_db positioning ;_cb ,_bf float64 ;_f float64 ;_dc float64 ;_eba float64 ;_gbc margins ;_ca []*_ggb .PdfAnnotation ;};func (_gddd positioning )isAbsolute ()bool {return _gddd ==_fab };func (_gedf *Creator )getActivePage ()*_ggb .PdfPage {if _gedf ._begd ==nil {if len (_gedf ._bdba )==0{return nil ;};return _gedf ._bdba [len (_gedf ._bdba )-1];};return _gedf ._begd ;};

// SetFillColor sets background color for border.
func (_beb *border )SetFillColor (col Color ){_beb ._edae =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_bgggb *Image )SetMargins (left ,right ,top ,bottom float64 ){_bgggb ._ecgd ._edbg =left ;_bgggb ._ecgd ._gac =right ;_bgggb ._ecgd ._fedcf =top ;_bgggb ._ecgd ._ebfe =bottom ;};func (_fdgfe *Invoice )generateHeaderBlocks (_afbb DrawContext )([]*Block ,DrawContext ,error ){_ceg :=_bcbd (_fdgfe ._baeg );_ceg .SetEnableWrap (true );_ceg .Append (_fdgfe ._ddce );_bdca :=_begbg (2);if _fdgfe ._fegb !=nil {_bbbg :=_bdca .NewCell ();_bbbg .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bbbg .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bbbg .SetIndent (0);_bbbg .SetContent (_fdgfe ._fegb );_fdgfe ._fegb .ScaleToHeight (_ceg .Height ()+20);}else {_bdca .SkipCells (1);};_ebc :=_bdca .NewCell ();_ebc .SetHorizontalAlignment (CellHorizontalAlignmentRight );_ebc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ebc .SetContent (_ceg );return _bdca .GeneratePageBlocks (_afbb );};

// SetStyleTop sets border style for top side.
func (_egba *border )SetStyleTop (style CellBorderStyle ){_egba ._bae =style };func _ebd (_aff ,_faaf ,_edcd ,_gfc float64 )*border {_dag :=&border {};_dag ._ddc =_aff ;_dag ._dea =_faaf ;_dag ._da =_edcd ;_dag ._acb =_gfc ;_dag ._fga =_ggb .NewPdfColorDeviceRGB (0,0,0);_dag ._feg =_ggb .NewPdfColorDeviceRGB (0,0,0);_dag ._ccg =_ggb .NewPdfColorDeviceRGB (0,0,0);_dag ._dbc =_ggb .NewPdfColorDeviceRGB (0,0,0);_dag ._eaf =0;_dag ._dba =0;_dag ._bdg =0;_dag ._bce =0;_dag .LineStyle =_gb .LineStyleSolid ;return _dag ;};

// NewList creates a new list.
func (_dfce *Creator )NewList ()*List {return _dagf (_dfce .NewTextStyle ())};

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_g .Max (_g .Min (r ,1.0),0.0);g =_g .Max (_g .Min (g ,1.0),0.0);b =_g .Max (_g .Min (b ,1.0),0.0);_efac :=rgbColor {};_efac ._edgf =r ;_efac ._cccd =g ;_efac ._efd =b ;return _efac ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_cfgg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_eacae float64 ;_fcdd uint ;_bfff float64 ;_faag positioning ;_efcb float64 ;_bffg float64 ;_bggac int64 ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_bfbf *StyledParagraph )Insert (index uint ,text string )*TextChunk {_dcaa :=uint (len (_bfbf ._cdcgf ));if index > _dcaa {index =_dcaa ;};_cabbf :=NewTextChunk (text ,_bfbf ._aca );_bfbf ._cdcgf =append (_bfbf ._cdcgf [:index ],append ([]*TextChunk {_cabbf },_bfbf ._cdcgf [index :]...)...);_bfbf .wrapText ();return _cabbf ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_eged *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_gbdc :=range subtable ._bedae {_gcfa :=&TableCell {};*_gcfa =*_gbdc ;_gcfa ._gdaeb =_eged ;_gcfa ._dbcgb +=col -1;if _gbcf :=_eged ._adcf -(_gcfa ._dbcgb -1);_gbcf < _gcfa ._gedg {_eged ._adcf +=_gcfa ._gedg -_gbcf ;_eged .resetColumnWidths ();_gg .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_eged ._adcf );};_gcfa ._edec +=row -1;_cfbf :=subtable ._facf [_gbdc ._edec -1];if _gcfa ._edec > _eged ._daac {for _gcfa ._edec > _eged ._daac {_eged ._daac ++;_eged ._facf =append (_eged ._facf ,_eged ._fced );};_eged ._facf [_gcfa ._edec -1]=_cfbf ;}else {_eged ._facf [_gcfa ._edec -1]=_g .Max (_eged ._facf [_gcfa ._edec -1],_cfbf );};_eged ._bedae =append (_eged ._bedae ,_gcfa );};_bg .Slice (_eged ._bedae ,func (_aafe ,_abbc int )bool {_bdaf :=_eged ._bedae [_aafe ]._edec ;_bfadb :=_eged ._bedae [_abbc ]._edec ;if _bdaf < _bfadb {return true ;};if _bdaf > _bfadb {return false ;};return _eged ._bedae [_aafe ]._dbcgb < _eged ._bedae [_abbc ]._dbcgb ;});};func (_afd positioning )isRelative ()bool {return _afd ==_bbd };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fbgbg *StyledParagraph )SetTextAlignment (align TextAlignment ){_fbgbg ._ebgc =align };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_deeba float64 ;_gcdd float64 ;_cagg float64 ;_gece float64 ;_abfde *_ggb .PdfColorDeviceRGB ;_fcea float64 ;_baba *_ggb .PdfColorDeviceRGB ;_geca float64 ;_fdeb float64 ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_gcba *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_ccgdc :=&_gcba ._cfgg ._bddbc ;return _gcba ._eacae ,_ccgdc ._gac ,_ccgdc ._fedcf ,_ccgdc ._ebfe ;};func (_ccb *Block )mergeBlocks (_fce *Block )error {_gff :=_fggf (_ccb ._ae ,_ccb ._ce ,_fce ._ae ,_fce ._ce );if _gff !=nil {return _gff ;};for _ ,_cge :=range _fce ._ca {_ccb .AddAnnotation (_cge );};return nil ;};func (_eddb *Paragraph )wrapText ()error {if !_eddb ._gadd ||int (_eddb ._fadb )<=0{_eddb ._cfdc =[]string {_eddb ._dgbf };return nil ;};_degf :=NewTextChunk (_eddb ._dgbf ,TextStyle {Font :_eddb ._eccc ,FontSize :_eddb ._fbga });_gdcb ,_ffde :=_degf .Wrap (_eddb ._fadb );if _ffde !=nil {return _ffde ;};if _eddb ._ecaa > 0&&len (_gdcb )> _eddb ._ecaa {_gdcb =_gdcb [:_eddb ._ecaa ];};_eddb ._cfdc =_gdcb ;return nil ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetBorderOpacity sets the border opacity.
func (_afgd *Rectangle )SetBorderOpacity (opacity float64 ){_afgd ._fdeb =opacity };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bdcge *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egaf :=ctx ;_ddad ,ctx ,_egda :=_bdcge ._cfgg .GeneratePageBlocks (ctx );if _egda !=nil {return _ddad ,ctx ,_egda ;};if _bdcge ._faag .isRelative (){ctx .X =_egaf .X ;};if _bdcge ._faag .isAbsolute (){return _ddad ,_egaf ,nil ;};return _ddad ,ctx ,nil ;};

// SetLevel sets the indentation level of the TOC line.
func (_bdgab *TOCLine )SetLevel (level uint ){_bdgab ._fcdd =level ;_bdgab ._cfgg ._bddbc ._edbg =_bdgab ._eacae +float64 (_bdgab ._fcdd -1)*_bdgab ._bfff ;};

// GeneratePageBlocks implements drawable interface.
func (_ceea *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abgc :=_ceea ._ddc ;_ebf :=ctx .PageHeight -_ceea ._dea ;if _ceea ._edae !=nil {_agge :=_gb .Rectangle {Opacity :1.0,X :_ceea ._ddc ,Y :ctx .PageHeight -_ceea ._dea -_ceea ._acb ,Height :_ceea ._acb ,Width :_ceea ._da };_agge .FillEnabled =true ;_agge .FillColor =_ceea ._edae ;_agge .BorderEnabled =false ;_ecf ,_ ,_eec :=_agge .Draw ("");if _eec !=nil {return nil ,ctx ,_eec ;};_eec =_cbgg .addContentsByString (string (_ecf ));if _eec !=nil {return nil ,ctx ,_eec ;};};_bddb :=_ceea ._eaf ;_fgcd :=_ceea ._dba ;_ebg :=_ceea ._bdg ;_dbdc :=_ceea ._bce ;_abgd :=_ceea ._eaf ;if _ceea ._bae ==CellBorderStyleDouble {_abgd +=2*_bddb ;};_gce :=_ceea ._dba ;if _ceea ._efb ==CellBorderStyleDouble {_gce +=2*_fgcd ;};_aae :=_ceea ._bdg ;if _ceea ._ggf ==CellBorderStyleDouble {_aae +=2*_ebg ;};_caa :=_ceea ._bce ;if _ceea ._cfe ==CellBorderStyleDouble {_caa +=2*_dbdc ;};if _ceea ._eaf !=0{_eddc :=_abgc ;_gffd :=_ebf ;if _ceea ._bae ==CellBorderStyleDouble {_gffd -=_bddb ;_acf :=_gb .BasicLine {};_acf .X1 =_eddc -_abgd /2;_acf .Y1 =_gffd +2*_bddb ;_acf .X2 =_eddc +_ceea ._da +_abgd /2;_acf .Y2 =_gffd +2*_bddb ;_acf .LineColor =_ceea ._fga ;_acf .LineWidth =_ceea ._eaf ;_acf .LineStyle =_ceea .LineStyle ;_fgbb ,_ ,_eeb :=_acf .Draw ("");if _eeb !=nil {return nil ,ctx ,_eeb ;};_eeb =_cbgg .addContentsByString (string (_fgbb ));if _eeb !=nil {return nil ,ctx ,_eeb ;};};_caf :=_gb .BasicLine {LineWidth :_ceea ._eaf ,Opacity :1.0,LineColor :_ceea ._fga ,X1 :_eddc -_abgd /2+(_aae -_ceea ._bdg ),Y1 :_gffd ,X2 :_eddc +_ceea ._da +_abgd /2-(_caa -_ceea ._bce ),Y2 :_gffd ,LineStyle :_ceea .LineStyle };_fba ,_ ,_gfdf :=_caf .Draw ("");if _gfdf !=nil {return nil ,ctx ,_gfdf ;};_gfdf =_cbgg .addContentsByString (string (_fba ));if _gfdf !=nil {return nil ,ctx ,_gfdf ;};};if _ceea ._dba !=0{_badd :=_abgc ;_fed :=_ebf -_ceea ._acb ;if _ceea ._efb ==CellBorderStyleDouble {_fed +=_fgcd ;_gbb :=_gb .BasicLine {LineWidth :_ceea ._dba ,Opacity :1.0,LineColor :_ceea ._feg ,X1 :_badd -_gce /2,Y1 :_fed -2*_fgcd ,X2 :_badd +_ceea ._da +_gce /2,Y2 :_fed -2*_fgcd ,LineStyle :_ceea .LineStyle };_aed ,_ ,_affc :=_gbb .Draw ("");if _affc !=nil {return nil ,ctx ,_affc ;};_affc =_cbgg .addContentsByString (string (_aed ));if _affc !=nil {return nil ,ctx ,_affc ;};};_ebee :=_gb .BasicLine {LineWidth :_ceea ._dba ,Opacity :1.0,LineColor :_ceea ._feg ,X1 :_badd -_gce /2+(_aae -_ceea ._bdg ),Y1 :_fed ,X2 :_badd +_ceea ._da +_gce /2-(_caa -_ceea ._bce ),Y2 :_fed ,LineStyle :_ceea .LineStyle };_gbd ,_ ,_gffa :=_ebee .Draw ("");if _gffa !=nil {return nil ,ctx ,_gffa ;};_gffa =_cbgg .addContentsByString (string (_gbd ));if _gffa !=nil {return nil ,ctx ,_gffa ;};};if _ceea ._bdg !=0{_fecf :=_abgc ;_geg :=_ebf ;if _ceea ._ggf ==CellBorderStyleDouble {_fecf +=_ebg ;_gcg :=_gb .BasicLine {LineWidth :_ceea ._bdg ,Opacity :1.0,LineColor :_ceea ._ccg ,X1 :_fecf -2*_ebg ,Y1 :_geg +_aae /2,X2 :_fecf -2*_ebg ,Y2 :_geg -_ceea ._acb -_aae /2,LineStyle :_ceea .LineStyle };_gdeb ,_ ,_ddg :=_gcg .Draw ("");if _ddg !=nil {return nil ,ctx ,_ddg ;};_ddg =_cbgg .addContentsByString (string (_gdeb ));if _ddg !=nil {return nil ,ctx ,_ddg ;};};_aggf :=_gb .BasicLine {LineWidth :_ceea ._bdg ,Opacity :1.0,LineColor :_ceea ._ccg ,X1 :_fecf ,Y1 :_geg +_aae /2-(_abgd -_ceea ._eaf ),X2 :_fecf ,Y2 :_geg -_ceea ._acb -_aae /2+(_gce -_ceea ._dba ),LineStyle :_ceea .LineStyle };_dcca ,_ ,_adaa :=_aggf .Draw ("");if _adaa !=nil {return nil ,ctx ,_adaa ;};_adaa =_cbgg .addContentsByString (string (_dcca ));if _adaa !=nil {return nil ,ctx ,_adaa ;};};if _ceea ._bce !=0{_ffa :=_abgc +_ceea ._da ;_cce :=_ebf ;if _ceea ._cfe ==CellBorderStyleDouble {_ffa -=_dbdc ;_cacc :=_gb .BasicLine {LineWidth :_ceea ._bce ,Opacity :1.0,LineColor :_ceea ._dbc ,X1 :_ffa +2*_dbdc ,Y1 :_cce +_caa /2,X2 :_ffa +2*_dbdc ,Y2 :_cce -_ceea ._acb -_caa /2,LineStyle :_ceea .LineStyle };_ffaa ,_ ,_ddb :=_cacc .Draw ("");if _ddb !=nil {return nil ,ctx ,_ddb ;};_ddb =_cbgg .addContentsByString (string (_ffaa ));if _ddb !=nil {return nil ,ctx ,_ddb ;};};_eeg :=_gb .BasicLine {LineWidth :_ceea ._bce ,Opacity :1.0,LineColor :_ceea ._dbc ,X1 :_ffa ,Y1 :_cce +_caa /2-(_abgd -_ceea ._eaf ),X2 :_ffa ,Y2 :_cce -_ceea ._acb -_caa /2+(_gce -_ceea ._dba ),LineStyle :_ceea .LineStyle };_egg ,_ ,_ddgd :=_eeg .Draw ("");if _ddgd !=nil {return nil ,ctx ,_ddgd ;};_ddgd =_cbgg .addContentsByString (string (_egg ));if _ddgd !=nil {return nil ,ctx ,_ddgd ;};};return []*Block {_cbgg },ctx ,nil ;};

// SetRowHeight sets the height for a specified row.
func (_fdfg *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_fdfg ._facf ){return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdfg ._facf [row -1]=h ;return nil ;};

// SetBorderWidth sets the border width.
func (_ebfga *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_ebfga ._bcea .BorderWidth =borderWidth ;};

// SetStyleRight sets border style for right side.
func (_edg *border )SetStyleRight (style CellBorderStyle ){_edg ._cfe =style };

// SetEnableWrap sets the line wrapping enabled flag.
func (_eaaf *Paragraph )SetEnableWrap (enableWrap bool ){_eaaf ._gadd =enableWrap ;_eaaf ._eggd =false };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_aeef *Table )Width ()float64 {return 0};func (_feaca *Paragraph )getTextLineWidth (_bddec string )float64 {var _acdg float64 ;for _ ,_geeae :=range _bddec {if _geeae =='\u000A'{continue ;};_acff ,_ebac :=_feaca ._eccc .GetRuneMetrics (_geeae );if !_ebac {_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_geeae ,_geeae );return -1;};_acdg +=_feaca ._fbga *_acff .Wx ;};return _acdg ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func _fdgb (_cfdg []_gb .Point )*Polyline {return &Polyline {_agcd :&_gb .Polyline {Points :_cfdg ,LineColor :_ggb .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_cffg :1.0};};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_gebf *Image )SetPos (x ,y float64 ){_gebf ._beaf =_fab ;_gebf ._fdec =x ;_gebf ._cad =y };

// Scale scales Image by a constant factor, both width and height.
func (_caab *Image )Scale (xFactor ,yFactor float64 ){_caab ._ddcb =xFactor *_caab ._ddcb ;_caab ._adfd =yFactor *_caab ._adfd ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_eacga *List )SetIndent (indent float64 ){_eacga ._fafc =indent ;_eacga ._bfgb =false };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_efba *StyledParagraph )SetWidth (width float64 ){_efba ._agbad =width ;_efba .wrapText ()};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_gbfdd *Paragraph )SetColor (col Color ){_fdccf :=_ggb .NewPdfColorDeviceRGB (col .ToRGB ());_gbfdd ._fcad =*_fdccf ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_fbbd *Line )SetColor (col Color ){_fbbd ._bcfaf =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_ceda *Chapter )SetIncludeInTOC (includeInTOC bool ){_ceda ._abfa =includeInTOC };func _aad (_ggag *Block ,_ccf *StyledParagraph ,_bcgb [][]*TextChunk ,_cbba DrawContext )(DrawContext ,[][]*TextChunk ,error ){_agfc :=1;_fgag :=_aa .PdfObjectName (_eac .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agfc ));for _ggag ._ce .HasFontByName (_fgag ){_agfc ++;_fgag =_aa .PdfObjectName (_eac .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agfc ));};_deecg :=_ggag ._ce .SetFontByName (_fgag ,_ccf ._aca .Font .ToPdfObject ());if _deecg !=nil {return _cbba ,nil ,_deecg ;};_agfc ++;_ccdbg :=_fgag ;_abab :=_ccf ._aca .FontSize ;_daafg :=_ccf ._aaaec .isRelative ();var _gecd [][]_aa .PdfObjectName ;var _geef float64 ;var _dgaf [][]*TextChunk ;var _deaec float64 ;for _egaa ,_bdac :=range _bcgb {var _ggdg []_aa .PdfObjectName ;var _cbcgf float64 ;for _ ,_dbef :=range _bdac {_bbfd :=_dbef .Style ;if _egaa ==0&&_bbfd .FontSize > _geef {_geef =_bbfd .FontSize ;};if _bbfd .FontSize > _cbcgf {_cbcgf =_bbfd .FontSize ;};_fgag =_aa .PdfObjectName (_eac .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agfc ));_ceaa :=_ggag ._ce .SetFontByName (_fgag ,_bbfd .Font .ToPdfObject ());if _ceaa !=nil {return _cbba ,nil ,_ceaa ;};_ggdg =append (_ggdg ,_fgag );_agfc ++;};_cbcgf *=_ccf ._cdfgf ;if _daafg &&_deaec +_cbcgf > _cbba .Height {_dgaf =_bcgb [_egaa :];_bcgb =_bcgb [:_egaa ];break ;};_deaec +=_cbcgf ;_gecd =append (_gecd ,_ggdg );};_fegd :=_eb .NewContentCreator ();_fegd .Add_q ();_edaea :=_cbba .PageHeight -_cbba .Y -_geef *_ccf ._cdfgf ;_fegd .Translate (_cbba .X ,_edaea );if _ccf ._efbd !=0{_fegd .RotateDeg (_ccf ._efbd );};_fegd .Add_BT ();_eddcd :=_edaea ;for _eaegf ,_ccde :=range _bcgb {_adfaf :=_cbba .X ;if _eaegf !=0{_fegd .Add_Tstar ();};_cbfa :=_eaegf ==len (_bcgb )-1;var (_cdba float64 ;_bbfba float64 ;_fgbf float64 ;_eedc uint ;);var _bcded []float64 ;for _ ,_gbcg :=range _ccde {_gbec :=&_gbcg .Style ;if _gbec .FontSize > _bbfba {_bbfba =_gbec .FontSize ;};_agbgf ,_bgdc :=_gbec .Font .GetRuneMetrics (' ');if !_bgdc {return _cbba ,nil ,_b .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _aegb uint ;var _dafeg float64 ;_adaab :=len (_gbcg .Text );for _aaac ,_cfaa :=range _gbcg .Text {if _cfaa ==' '{_aegb ++;continue ;};if _cfaa =='\u000A'{continue ;};_dggd ,_fgae :=_gbec .Font .GetRuneMetrics (_cfaa );if !_fgae {_gg .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_cfaa );return _cbba ,nil ,_b .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dafeg +=_gbec .FontSize *_dggd .Wx ;if _aaac !=_adaab -1{_dafeg +=_gbec .CharSpacing *1000.0;};};_bcded =append (_bcded ,_dafeg );_cdba +=_dafeg ;_fgbf +=float64 (_aegb )*_agbgf .Wx *_gbec .FontSize ;_eedc +=_aegb ;};_bbfba *=_ccf ._cdfgf ;var _ecde []_aa .PdfObject ;_efda :=_ccf ._agbad *1000.0;if _ccf ._ebgc ==TextAlignmentJustify {if _eedc > 0&&!_cbfa {_fgbf =(_efda -_cdba )/float64 (_eedc )/_abab ;};}else if _ccf ._ebgc ==TextAlignmentCenter {_gdgg :=(_efda -_cdba -_fgbf )/2;_cfae :=_gdgg /_abab ;_ecde =append (_ecde ,_aa .MakeFloat (-_cfae ));_adfaf +=_gdgg /1000.0;}else if _ccf ._ebgc ==TextAlignmentRight {_dbcab :=(_efda -_cdba -_fgbf );_ccee :=_dbcab /_abab ;_ecde =append (_ecde ,_aa .MakeFloat (-_ccee ));_adfaf +=_dbcab /1000.0;};if len (_ecde )> 0{_fegd .Add_Tf (_ccdbg ,_abab ).Add_TL (_abab *_ccf ._cdfgf ).Add_TJ (_ecde ...);};for _gdac ,_ffgg :=range _ccde {_gfcf :=&_ffgg .Style ;_ddffb ,_fgdc ,_efgd :=_gfcf .Color .ToRGB ();_affgg :=_ccdbg ;_gefbe :=_abab ;_fegd .Add_Tr (int64 (_gfcf .RenderingMode ));_fegd .Add_Tc (_gfcf .CharSpacing );if _ccf ._ebgc !=TextAlignmentJustify ||_cbfa {_efeg ,_agcf :=_gfcf .Font .GetRuneMetrics (' ');if !_agcf {return _cbba ,nil ,_b .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_affgg =_gecd [_eaegf ][_gdac ];_gefbe =_gfcf .FontSize ;_fgbf =_efeg .Wx ;};_bbef :=_gfcf .Font .Encoder ();var _bdfab []byte ;for _ ,_edab :=range _ffgg .Text {if _ddffb =='\u000A'{continue ;};if _edab ==' '{if len (_bdfab )> 0{_fegd .Add_rg (_ddffb ,_fgdc ,_efgd ).Add_Tf (_gecd [_eaegf ][_gdac ],_gfcf .FontSize ).Add_TL (_gfcf .FontSize *_ccf ._cdfgf ).Add_TJ ([]_aa .PdfObject {_aa .MakeStringFromBytes (_bdfab )}...);_bdfab =nil ;};_fegd .Add_Tf (_affgg ,_gefbe ).Add_TL (_gefbe *_ccf ._cdfgf ).Add_TJ ([]_aa .PdfObject {_aa .MakeFloat (-_fgbf )}...);_bcded [_gdac ]+=_fgbf *_gefbe ;}else {if _ ,_cgaf :=_bbef .RuneToCharcode (_edab );!_cgaf {_gg .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_edab ,_edab );continue ;};_bdfab =append (_bdfab ,_bbef .Encode (string (_edab ))...);};};if len (_bdfab )> 0{_fegd .Add_rg (_ddffb ,_fgdc ,_efgd ).Add_Tf (_gecd [_eaegf ][_gdac ],_gfcf .FontSize ).Add_TL (_gfcf .FontSize *_ccf ._cdfgf ).Add_TJ ([]_aa .PdfObject {_aa .MakeStringFromBytes (_bdfab )}...);};_aaec :=_bcded [_gdac ]/1000.0;if _ffgg ._gagee !=nil {var _efca *_aa .PdfObjectArray ;if !_ffgg ._agca {switch _bgde :=_ffgg ._gagee .GetContext ().(type ){case *_ggb .PdfAnnotationLink :_efca =_aa .MakeArray ();_bgde .Rect =_efca ;_bbeg ,_gada :=_bgde .Dest .(*_aa .PdfObjectArray );if _gada &&_bbeg .Len ()==5{_cebf ,_dadd :=_bbeg .Get (1).(*_aa .PdfObjectName );if _dadd &&_cebf .String ()=="\u0058\u0059\u005a"{_eaba ,_ecgeg :=_aa .GetNumberAsFloat (_bbeg .Get (3));if _ecgeg ==nil {_bbeg .Set (3,_aa .MakeFloat (_cbba .PageHeight -_eaba ));};};};};_ffgg ._agca =true ;};if _efca !=nil {_aggd :=_gb .NewPoint (_adfaf -_cbba .X ,_eddcd -_edaea ).Rotate (_ccf ._efbd );_aggd .X +=_cbba .X ;_aggd .Y +=_edaea ;_efdd ,_babag ,_edcc ,_fcga :=_gegfd (_aaec ,_bbfba ,_ccf ._efbd );_aggd .X +=_efdd ;_aggd .Y +=_babag ;_efca .Clear ();_efca .Append (_aa .MakeFloat (_aggd .X ));_efca .Append (_aa .MakeFloat (_aggd .Y ));_efca .Append (_aa .MakeFloat (_aggd .X +_edcc ));_efca .Append (_aa .MakeFloat (_aggd .Y +_fcga ));};_ggag .AddAnnotation (_ffgg ._gagee );};_adfaf +=_aaec ;_fegd .Add_Tr (int64 (TextRenderingModeFill ));_fegd .Add_Tc (0);};_eddcd -=_bbfba ;};_fegd .Add_ET ();_fegd .Add_Q ();_gfb :=_fegd .Operations ();_gfb .WrapIfNeeded ();_ggag .addContents (_gfb );if _daafg {_dfcag :=_deaec +_ccf ._bddbc ._ebfe ;_cbba .Y +=_dfcag ;_cbba .Height -=_dfcag ;if _cbba .Inline {_cbba .X +=_ccf .Width ()+_ccf ._bddbc ._gac ;};};return _cbba ,_dgaf ,nil ;};

// NewCell returns a new invoice table cell.
func (_bcab *Invoice )NewCell (value string )*InvoiceCell {return _bcab .newCell (value ,_bcab .NewCellProps ());};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ggb .PdfPage )(*Block ,error ){_ff :=&Block {};_efc ,_bb :=page .GetAllContentStreams ();if _bb !=nil {return nil ,_bb ;};_cef :=_eb .NewContentStreamParser (_efc );_fg ,_bb :=_cef .Parse ();if _bb !=nil {return nil ,_bb ;};_fg .WrapIfNeeded ();_ff ._ae =_fg ;if page .Resources !=nil {_ff ._ce =page .Resources ;}else {_ff ._ce =_ggb .NewPdfPageResources ();};_cc ,_bb :=page .GetMediaBox ();if _bb !=nil {return nil ,_bb ;};if _cc .Llx !=0||_cc .Lly !=0{_ff .translate (-_cc .Llx ,_cc .Lly );};_ff ._f =_cc .Urx -_cc .Llx ;_ff ._dc =_cc .Ury -_cc .Lly ;if page .Rotate !=nil {_ff ._eba =-float64 (*page .Rotate );};return _ff ,nil ;};

// Write output of creator to io.Writer interface.
func (_cbe *Creator )Write (ws _ea .Writer )error {if _ffab :=_cbe .Finalize ();_ffab !=nil {return _ffab ;};_eegd :=_ggb .NewPdfWriter ();_eegd .SetOptimizer (_cbe ._egd );if _cbe ._acc !=nil {_gecf :=_eegd .SetForms (_cbe ._acc );if _gecf !=nil {_gg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_gecf );return _gecf ;};};if _cbe ._eeca !=nil {_eegd .AddOutlineTree (_cbe ._eeca );}else if _cbe ._gda !=nil &&_cbe .AddOutlines {_eegd .AddOutlineTree (&_cbe ._gda .ToPdfOutline ().PdfOutlineTreeNode );};if _cbe ._gddf !=nil {if _afc :=_eegd .SetPageLabels (_cbe ._gddf );_afc !=nil {_gg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_afc );return _afc ;};};if _cbe ._gcf !=nil {for _ ,_dee :=range _cbe ._gcf {_gega :=_dee .SubsetRegistered ();if _gega !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_gega );return _gega ;};};};if _cbe ._bcfe !=nil {_bgb :=_cbe ._bcfe (&_eegd );if _bgb !=nil {_gg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bgb );return _bgb ;};};for _ ,_fceg :=range _cbe ._bdba {_ccd :=_eegd .AddPage (_fceg );if _ccd !=nil {_gg .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_ccd );return _ccd ;};};_agba :=_eegd .Write (ws );if _agba !=nil {return _agba ;};return nil ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_beae *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgea :=ctx ;var _deae []*Block ;_fdda :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _beae ._aaaec .isRelative (){ctx .X +=_beae ._bddbc ._edbg ;ctx .Y +=_beae ._bddbc ._fedcf ;ctx .Width -=_beae ._bddbc ._edbg +_beae ._bddbc ._gac ;ctx .Height -=_beae ._bddbc ._fedcf +_beae ._bddbc ._ebfe ;_beae .SetWidth (ctx .Width );}else {if int (_beae ._agbad )<=0{_beae .SetWidth (_beae .getTextWidth ());};ctx .X =_beae ._facgg ;ctx .Y =_beae ._fbag ;};if _beae ._aggc !=nil {_beae ._aggc (_beae ,ctx );};if _agfbe :=_beae .wrapText ();_agfbe !=nil {return nil ,ctx ,_agfbe ;};_abce :=_beae ._bgcf ;for {_acec ,_afbcf ,_eeda :=_aad (_fdda ,_beae ,_abce ,ctx );if _eeda !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eeda );return nil ,ctx ,_eeda ;};ctx =_acec ;_deae =append (_deae ,_fdda );if _abce =_afbcf ;len (_afbcf )==0{break ;};_fdda =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_acec =ctx ;_acec .Y =ctx .Margins ._fedcf ;_acec .X =ctx .Margins ._edbg +_beae ._bddbc ._edbg ;_acec .Height =ctx .PageHeight -ctx .Margins ._fedcf -ctx .Margins ._ebfe -_beae ._bddbc ._ebfe ;_acec .Width =ctx .PageWidth -ctx .Margins ._edbg -ctx .Margins ._gac -_beae ._bddbc ._edbg -_beae ._bddbc ._gac ;ctx =_acec ;};if _beae ._aaaec .isRelative (){ctx .X -=_beae ._bddbc ._edbg ;ctx .Width =_fgea .Width ;return _deae ,ctx ,nil ;};return _deae ,_fgea ,nil ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_eaff int ;_fcca string ;_bced *Paragraph ;_fbd []Drawable ;_acd int ;_gddg bool ;_abfa bool ;_bdde positioning ;_bggc ,_bfb float64 ;_eadf margins ;_gae *Chapter ;_efag *TOC ;_bbgf *_ggb .Outline ;_gdde *_ggb .OutlineItem ;_gga uint ;};func _bcbd (_aeecg TextStyle )*StyledParagraph {return &StyledParagraph {_cdcgf :[]*TextChunk {},_aca :_aeecg ,_aabc :_gbda (_aeecg .Font ),_cdfgf :1.0,_ebgc :TextAlignmentLeft ,_feab :true ,_fgdg :true ,_efbd :0,_gcbbc :1,_bbcgg :1,_aaaec :_bbd };};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gagee *_ggb .PdfAnnotation ;_agca bool ;};

// SetColorTop sets border color for top.
func (_dbae *border )SetColorTop (col Color ){_dbae ._fga =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_dfdf *Invoice )InfoLines ()[][2]*InvoiceCell {_gaccb :=[][2]*InvoiceCell {_dfdf ._gbbc ,_dfdf ._fdgf ,_dfdf ._dgge };return append (_gaccb ,_dfdf ._defg ...);};

// SetWidthLeft sets border width for left.
func (_cff *border )SetWidthLeft (bw float64 ){_cff ._bdg =bw };

// SkipCells skips over a specified number of cells in the table.
func (_cafdf *Table )SkipCells (num int ){if num < 0{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_cafdf ._eega +=num ;};

// Width returns the Block's width.
func (_agg *Block )Width ()float64 {return _agg ._f };

// SetBorderWidth sets the border width.
func (_gfdc *Rectangle )SetBorderWidth (bw float64 ){_gfdc ._geca =bw };

// SetLineOpacity sets the line opacity.
func (_gbee *Polyline )SetLineOpacity (opacity float64 ){_gbee ._cffg =opacity };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_ec *Block )ScaleToWidth (w float64 ){_cdg :=w /_ec ._f ;_ec .Scale (_cdg ,_cdg )};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_gdg *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gdg ._ecgd ._edbg ,_gdg ._ecgd ._gac ,_gdg ._ecgd ._fedcf ,_gdg ._ecgd ._ebfe ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_gabc *Invoice )SetNoteHeadingStyle (style TextStyle ){_gabc ._cdd =style };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_bcea *_gb .PolyBezierCurve ;_bfbgf float64 ;_bddg float64 ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_gdebd *Invoice )SetTitleStyle (style TextStyle ){_gdebd ._baeg =style };func (_bcb *Invoice )newCell (_fada string ,_ddf InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_ddf ,_fada };};

// SetBorderOpacity sets the border opacity.
func (_eaad *Polygon )SetBorderOpacity (opacity float64 ){_eaad ._dfff =opacity };

// Cols returns the total number of columns the table has.
func (_deab *Table )Cols ()int {return _deab ._adcf };func _baad (_ebff *_ggb .Image )(*Image ,error ){_dceae :=float64 (_ebff .Width );_fffg :=float64 (_ebff .Height );return &Image {_bbcd :_ebff ,_fefef :_dceae ,_edff :_fffg ,_ddcb :_dceae ,_adfd :_fffg ,_fcd :0,_fbgb :1.0,_beaf :_bbd },nil ;};func _aebg (_gdbf *_ggb .PdfAnnotationLink )*_ggb .PdfAnnotationLink {if _gdbf ==nil {return nil ;};_egged :=_ggb .NewPdfAnnotationLink ();_egged .BS =_gdbf .BS ;_egged .A =_gdbf .A ;if _bdab ,_adgd :=_gdbf .GetAction ();_adgd ==nil &&_bdab !=nil {_egged .SetAction (_bdab );};if _fecb ,_aabag :=_gdbf .Dest .(*_aa .PdfObjectArray );_aabag {_egged .Dest =_aa .MakeArray (_fecb .Elements ()...);};return _egged ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_gebcf *TOC )SetLineSeparatorStyle (style TextStyle ){_gebcf ._cbfac =style };

// SetDate sets the date of the invoice.
func (_fdee *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_fdee ._fdgf [1].Value =date ;return _fdee ._fdgf [0],_fdee ._fdgf [1];};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_ecccb *_gb .Polygon ;_ebeed float64 ;_dfff float64 ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_bcff *Image )GetHorizontalAlignment ()HorizontalAlignment {return _bcff ._caefg };func (_fffee *StyledParagraph )getTextHeight ()float64 {var _beee float64 ;for _ ,_aecc :=range _fffee ._cdcgf {_cdef :=_aecc .Style .FontSize *_fffee ._cdfgf ;if _cdef > _beee {_beee =_cdef ;};};return _beee ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_eccf *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_ebege :=&_eccf ._bbdd ;_ebege ._edbg =left ;_ebege ._gac =right ;_ebege ._fedcf =top ;_ebege ._ebfe =bottom ;};

// Indent returns the left offset of the list when nested into another list.
func (_bcga *List )Indent ()float64 {return _bcga ._fafc };

// DrawWithContext draws the Block using the specified drawing context.
func (_fbc *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_bcd ,_ ,_fbca :=d .GeneratePageBlocks (ctx );if _fbca !=nil {return _fbca ;};if len (_bcd )!=1{return _b .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_aeg :=range _bcd {if _cag :=_fbc .mergeBlocks (_aeg );_cag !=nil {return _cag ;};};return nil ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bea *Creator )SetOptimizer (optimizer _ggb .Optimizer ){_bea ._egd =optimizer };

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ddfb *TOC )SetLineStyle (style TextStyle ){_ddfb .SetLineNumberStyle (style );_ddfb .SetLineTitleStyle (style );_ddfb .SetLineSeparatorStyle (style );_ddfb .SetLinePageStyle (style );};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_ccac *Division )Add (d VectorDrawable )error {_eccg :=false ;switch d .(type ){case *Paragraph :_eccg =true ;case *StyledParagraph :_eccg =true ;case *Image :_eccg =true ;};if !_eccg {return _b .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_ccac ._adbeg =append (_ccac ._adbeg ,d );return nil ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_dagc *Paragraph )Height ()float64 {_dagc .wrapText ();return float64 (len (_dagc ._cfdc ))*_dagc ._dffeb *_dagc ._fbga ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_fcf *Chapter )SetShowNumbering (show bool ){_fcf ._gddg =show ;_fcf ._bced .SetText (_fcf .headingText ());};

// SetBorderColor sets border color.
func (_fcff *Rectangle )SetBorderColor (col Color ){_fcff ._baba =_ggb .NewPdfColorDeviceRGB (col .ToRGB ());};

// AddTotalLine adds a new line in the invoice totals table.
func (_ede *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gcff :=&InvoiceCell {_ede ._aebe ,desc };_bfba :=&InvoiceCell {_ede ._aebe ,value };_ede ._dggg =append (_ede ._dggg ,[2]*InvoiceCell {_gcff ,_bfba });return _gcff ,_bfba ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gca *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _gca ._dgge [0],_gca ._dgge [1]};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_cded *Invoice )SetAddressHeadingStyle (style TextStyle ){_cded ._gaba =style };var PPMM =float64 (72*1.0/25.4);

// NewImageFromFile creates an Image from a file.
func (_fgcf *Creator )NewImageFromFile (path string )(*Image ,error ){return _cedb (path )};

// SetMargins sets the margins TOC line.
func (_efbed *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_efbed ._eacae =left ;_fddg :=&_efbed ._cfgg ._bddbc ;_fddg ._edbg =_efbed ._eacae +float64 (_efbed ._fcdd -1)*_efbed ._bfff ;_fddg ._gac =right ;_fddg ._fedcf =top ;_fddg ._ebfe =bottom ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_cfde *Creator )NewStyledParagraph ()*StyledParagraph {return _bcbd (_cfde .NewTextStyle ())};func _dgddg (_ffac *_ef .File )([]*_ggb .PdfPage ,error ){_gege ,_dbgee :=_ggb .NewPdfReader (_ffac );if _dbgee !=nil {return nil ,_dbgee ;};_abcda ,_dbgee :=_gege .GetNumPages ();if _dbgee !=nil {return nil ,_dbgee ;};var _eeeec []*_ggb .PdfPage ;for _aabd :=0;_aabd < _abcda ;_aabd ++{_eegb ,_dddd :=_gege .GetPage (_aabd +1);if _dddd !=nil {return nil ,_dddd ;};_eeeec =append (_eeeec ,_eegb );};return _eeeec ,nil ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_dcgd *Creator )CreateTableOfContents (genTOCFunc func (_aaae *TOC )error ){_dcgd ._bbgcg =genTOCFunc ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_fa *Block )SetMargins (left ,right ,top ,bottom float64 ){_fa ._gbc ._edbg =left ;_fa ._gbc ._gac =right ;_fa ._gbc ._fedcf =top ;_fa ._gbc ._ebfe =bottom ;};func (_fb *Block )addContentsByString (_cbg string )error {_ggba :=_eb .NewContentStreamParser (_cbg );_af ,_ba :=_ggba .Parse ();if _ba !=nil {return _ba ;};_fb ._ae .WrapIfNeeded ();_af .WrapIfNeeded ();*_fb ._ae =append (*_fb ._ae ,*_af ...);return nil ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_dcbc *Invoice )Terms ()(string ,string ){return _dcbc ._ccef [0],_dcbc ._ccef [1]};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_dfca *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dfca ._dfdg ._edbg ,_dfca ._dfdg ._gac ,_dfca ._dfdg ._fedcf ,_dfca ._dfdg ._ebfe ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_eceb *Creator )NewPage ()*_ggb .PdfPage {_gecc :=_eceb .newPage ();_eceb ._bdba =append (_eceb ._bdba ,_gecc );_eceb ._gedb .Page ++;return _gecc ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_ddbe *Invoice )BuyerAddress ()*InvoiceAddress {return _ddbe ._ecfcb };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// NewImage create a new image from a unidoc image (model.Image).
func (_dgd *Creator )NewImage (img *_ggb .Image )(*Image ,error ){return _baad (img )};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_dbaf *Creator )MoveTo (x ,y float64 ){_dbaf ._gedb .X =x ;_dbaf ._gedb .Y =y };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;func (_egbg *Paragraph )getMaxLineWidth ()float64 {if _egbg ._cfdc ==nil ||len (_egbg ._cfdc )==0{_egbg .wrapText ();};var _fggda float64 ;for _ ,_cdfc :=range _egbg ._cfdc {_gfgf :=_egbg .getTextLineWidth (_cdfc );if _gfgf > _fggda {_fggda =_gfgf ;};};return _fggda ;};type rgbColor struct{_edgf ,_cccd ,_efd float64 };func _cedb (_gdaf string )(*Image ,error ){_ebea ,_ecfc :=_ef .Open (_gdaf );if _ecfc !=nil {return nil ,_ecfc ;};defer _ebea .Close ();_dgbb ,_ecfc :=_ggb .ImageHandling .Read (_ebea );if _ecfc !=nil {_gg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ecfc );return nil ,_ecfc ;};return _baad (_dgbb );};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_cgdg *Invoice )SetNoteStyle (style TextStyle ){_cgdg ._cffe =style };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_dbddc *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _aggea (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_fbdg *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _egfca (x1 ,y1 ,x2 ,y2 )};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_ecbg *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efbff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfd ,_ ,_dace :=_ecbg .draw ("");_dace =_efbff .addContentsByString (string (_dfd ));if _dace !=nil {return nil ,ctx ,_dace ;};return []*Block {_efbff },ctx ,nil ;};func _aaega (_gaaa string ,_bdfabf ,_fdgg TextStyle )*TOC {_bbbc :=_fdgg ;_bbbc .FontSize =14;_ccbb :=_bcbd (_bbbc );_ccbb .SetEnableWrap (true );_ccbb .SetTextAlignment (TextAlignmentLeft );_ccbb .SetMargins (0,0,0,5);_fadg :=_ccbb .Append (_gaaa );_fadg .Style =_bbbc ;return &TOC {_gacf :_ccbb ,_cacfa :[]*TOCLine {},_geacf :_bdfabf ,_fade :_bdfabf ,_cbfac :_bdfabf ,_abddd :_bdfabf ,_cffed :"\u002e",_dgfb :10,_bbdd :margins {0,0,2,2},_fcbd :_bbd ,_ffdcd :_bdfabf ,_dbda :true };};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_aefd *Invoice )Sections ()[][2]string {return _aefd ._eafe };

// GeneratePageBlocks draws the curve onto page blocks.
func (_accc *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdag :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _feca []string ;_feca =append (_feca ,_eac .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_accc ._cgda ));_feca =append (_feca ,_eac .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_accc ._efe [0],_accc ._efe [1],_accc ._efe [2]));_feca =append (_feca ,_eac .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_accc ._abdd ,ctx .PageHeight -_accc ._bbc ));_feca =append (_feca ,_eac .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_accc ._gbfd ,ctx .PageHeight -_accc ._daaf ,_accc ._cacg ,ctx .PageHeight -_accc ._fdcfc ));_adfg :=_cdag .addContentsByString (_de .Join (_feca ,"\u000a"));if _adfg !=nil {return nil ,ctx ,_adfg ;};return []*Block {_cdag },ctx ,nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_cfdf float64 ;_dbg float64 ;_abfd float64 ;_gecg float64 ;_fcfb *_ggb .PdfColorDeviceRGB ;_fefeb *_ggb .PdfColorDeviceRGB ;_gcc float64 ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_fgeeb *Table )SetPos (x ,y float64 ){_fgeeb ._dafba =_fab ;_fgeeb ._fecfa =x ;_fgeeb ._efcfc =y };

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_fe *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggg :=_eb .NewContentCreator ();_bdb ,_gf :=_fe .Width (),_fe .Height ();if _fe ._db .isRelative (){_ggg .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_gf );}else {_ggg .Translate (_fe ._cb ,ctx .PageHeight -_fe ._bf -_gf );};_df :=_gf ;if _fe ._eba !=0{_ggg .Translate (_bdb /2,_gf /2);_ggg .RotateDeg (_fe ._eba );_ggg .Translate (-_bdb /2,-_gf /2);_ ,_df =_fe .RotatedSize ();};if _fe ._db .isRelative (){ctx .Y +=_df ;};_gdd :=_fe .duplicate ();_agb :=append (*_ggg .Operations (),*_gdd ._ae ...);_agb .WrapIfNeeded ();_gdd ._ae =&_agb ;return []*Block {_gdd },ctx ,nil ;};

// CreateFrontPage sets a function to generate a front Page.
func (_daf *Creator )CreateFrontPage (genFrontPageFunc func (_cfg FrontpageFunctionArgs )){_daf ._agbg =genFrontPageFunc ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_gbba *Table )SetMargins (left ,right ,top ,bottom float64 ){_gbba ._fgcfa ._edbg =left ;_gbba ._fgcfa ._gac =right ;_gbba ._fgcfa ._fedcf =top ;_gbba ._fgcfa ._ebfe =bottom ;};

// GetRowHeight returns the height of the specified row.
func (_adefc *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_adefc ._facf ){return 0,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _adefc ._facf [row -1],nil ;};func _gbda (_caega *_ggb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_caega ,FontSize :10};};

// DrawHeader sets a function to draw a header on created output pages.
func (_cece *Creator )DrawHeader (drawHeaderFunc func (_adfb *Block ,_ceb HeaderFunctionArgs )){_cece ._cgeb =drawHeaderFunc ;};func (_dcfe *Table )newCell (_bbefd int )*TableCell {_dcfe ._eega ++;_fffc :=(_dcfe ._eega -1)/_dcfe ._adcf +1;for _fffc > _dcfe ._daac {_dcfe ._daac ++;_dcfe ._facf =append (_dcfe ._facf ,_dcfe ._fced );};_fdeba :=(_dcfe ._eega -1)%(_dcfe ._adcf )+1;_efbg :=&TableCell {};_efbg ._edec =_fffc ;_efbg ._dbcgb =_fdeba ;_efbg ._cbef =1;_efbg ._gdegf =5;_efbg ._fegdg =CellBorderStyleNone ;_efbg ._dfef =_gb .LineStyleSolid ;_efbg ._cfaf =CellHorizontalAlignmentLeft ;_efbg ._edaead =CellVerticalAlignmentTop ;_efbg ._fdcfg =0;_efbg ._ecfbf =0;_efbg ._bcdg =0;_efbg ._egaab =0;_afcg :=ColorBlack ;_efbg ._acdgf =_ggb .NewPdfColorDeviceRGB (_afcg .ToRGB ());_efbg ._acfa =_ggb .NewPdfColorDeviceRGB (_afcg .ToRGB ());_efbg ._cfec =_ggb .NewPdfColorDeviceRGB (_afcg .ToRGB ());_efbg ._bdbg =_ggb .NewPdfColorDeviceRGB (_afcg .ToRGB ());if _bbefd < 1{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_bbefd );_bbefd =1;};_dccde :=_dcfe ._adcf -(_efbg ._dbcgb -1);if _bbefd > _dccde {_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_bbefd ,_dccde );_bbefd =_dccde ;};_efbg ._gedg =_bbefd ;_dcfe ._eega +=_bbefd -1;_dcfe ._bedae =append (_dcfe ._bedae ,_efbg );_efbg ._gdaeb =_dcfe ;return _efbg ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cfag *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _cfag ._efdge [0],_cfag ._efdge [1]};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_cdfgd *Chapter )GetHeading ()*Paragraph {return _cdfgd ._bced };func _bcdb (_bcedc string ,_eadg TextStyle )*Paragraph {_fegeb :=&Paragraph {_dgbf :_bcedc ,_eccc :_eadg .Font ,_fbga :_eadg .FontSize ,_dffeb :1.0,_gadd :true ,_eggd :true ,_ggfb :TextAlignmentLeft ,_bcbcf :0,_ffda :1,_aeca :1,_aage :_bbd };_fegeb .SetColor (_eadg .Color );return _fegeb ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_fgaf *Creator )RotateDeg (angleDeg int64 )error {_eddd :=_fgaf .getActivePage ();if _eddd ==nil {_gg .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _b .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_gg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _edgd int64 ;if _eddd .Rotate !=nil {_edgd =*(_eddd .Rotate );};_edgd +=angleDeg ;_eddd .Rotate =&_edgd ;return nil ;};

// SetColorBottom sets border color for bottom.
func (_dgg *border )SetColorBottom (col Color ){_dgg ._feg =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// Context returns the current drawing context.
func (_febe *Creator )Context ()DrawContext {return _febe ._gedb };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_cgde *Image )ConvertToBinary ()error {return _cgde ._bbcd .ConvertToBinary ()};func _dfde (_facg _a .Image )(*Image ,error ){_aefg ,_cgbd :=_ggb .ImageHandling .NewImageFromGoImage (_facg );if _cgbd !=nil {return nil ,_cgbd ;};return _baad (_aefg );};

// SetMargins sets the Paragraph's margins.
func (_fccf *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_fccf ._bddbc ._edbg =left ;_fccf ._bddbc ._gac =right ;_fccf ._bddbc ._fedcf =top ;_fccf ._bddbc ._ebfe =bottom ;};

// Height returns Image's document height.
func (_fdf *Image )Height ()float64 {return _fdf ._adfd };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_aag *Creator )SetForms (form *_ggb .PdfAcroForm )error {_aag ._acc =form ;return nil };

// SkipRows skips over a specified number of rows in the table.
func (_dbgf *Table )SkipRows (num int ){_cbab :=num *_dbgf ._adcf -1;if _cbab < 0{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_dbgf ._eega +=_cbab ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_ebeb *TOC )SetLineSeparator (separator string ){_ebeb ._cffed =separator };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_cfd *Creator )MoveDown (dy float64 ){_cfd ._gedb .Y +=dy };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetBackgroundColor sets the cell's background color.
func (_edccc *TableCell )SetBackgroundColor (col Color ){_edccc ._ebae =_ggb .NewPdfColorDeviceRGB (col .ToRGB ());};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_egaac *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bbcc []*Block ;_dfdfg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abag :=ctx ;if _egaac ._dafba .isAbsolute (){ctx .X =_egaac ._fecfa ;ctx .Y =_egaac ._efcfc ;}else {ctx .X +=_egaac ._fgcfa ._edbg ;ctx .Y +=_egaac ._fgcfa ._fedcf ;ctx .Width -=_egaac ._fgcfa ._edbg +_egaac ._fgcfa ._gac ;ctx .Height -=_egaac ._fgcfa ._ebfe +_egaac ._fgcfa ._fedcf ;};_dgcg :=ctx .Width ;_bage :=ctx .X ;_bfga :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._ebfe ;_gedff :=ctx .Height ;_abba :=0;_eebf :=-1;_cega :=-1;for _cdgf ,_dbdf :=range _egaac ._bedae {_bgae :=float64 (0.0);for _debf :=0;_debf < _dbdf ._gedg ;_debf ++{_bgae +=_egaac ._eegg [_dbdf ._dbcgb +_debf -1];};_afaa :=float64 (0.0);for _cdadd :=0;_cdadd < _dbdf ._dbcgb -1;_cdadd ++{_afaa +=_egaac ._eegg [_cdadd ]*_dgcg ;};_eace :=float64 (0.0);for _fbf :=_abba ;_fbf < _dbdf ._edec -1;_fbf ++{_eace +=_egaac ._facf [_fbf ];};_ffee :=_bgae *_dgcg ;_faba :=float64 (0.0);for _gefg :=0;_gefg < _dbdf ._cbef ;_gefg ++{_faba +=_egaac ._facf [_dbdf ._edec +_gefg -1];};if _egaac ._fgfb {if _dbdf ._edec >=_egaac ._gebe &&_dbdf ._edec <=_egaac ._dcfbd {if _eebf < 0{_eebf =_cdgf ;};_cega =_cdgf ;};};switch _bggcc :=_dbdf ._gcce .(type ){case *Paragraph :_dbge :=_bggcc ;if _dbge ._gadd {_dbge .SetWidth (_ffee -_dbdf ._gdegf );};_fbgd :=_dbge .Height ()+_dbge ._dfdg ._ebfe +_dbge ._dfdg ._ebfe ;_fbgd +=0.5*_dbge ._fbga *_dbge ._dffeb ;if _fbgd > _faba {_bgga :=_fbgd -_faba ;_egaac ._facf [_dbdf ._edec +_dbdf ._cbef -2]+=_bgga ;};case *StyledParagraph :_fcfdg :=_bggcc ;if _fcfdg ._feab {_fcfdg .SetWidth (_ffee -_dbdf ._gdegf );};_bgaf :=_fcfdg .Height ()+_fcfdg ._bddbc ._fedcf +_fcfdg ._bddbc ._ebfe ;_bgaf +=0.5*_fcfdg .getTextHeight ();if _bgaf > _faba {_bcdbd :=_bgaf -_faba ;_egaac ._facf [_dbdf ._edec +_dbdf ._cbef -2]+=_bcdbd ;};case *Image :_bfcd :=_bggcc ;_fedb :=_bfcd .Height ()+_bfcd ._ecgd ._fedcf +_bfcd ._ecgd ._ebfe ;if _fedb > _faba {_adcff :=_fedb -_faba ;_egaac ._facf [_dbdf ._edec +_dbdf ._cbef -2]+=_adcff ;};case *Table :_fccd :=_bggcc ;_fcfg :=_fccd .Height ()+_fccd ._fgcfa ._fedcf +_fccd ._fgcfa ._ebfe ;if _fcfg > _faba {_becgcc :=_fcfg -_faba ;_egaac ._facf [_dbdf ._edec +_dbdf ._cbef -2]+=_becgcc ;};case *List :_ecfb :=_bggcc ;_bbac :=_ecfb .tableHeight (_ffee -_dbdf ._gdegf )+_ecfb ._gebc ._fedcf +_ecfb ._gebc ._ebfe ;if _bbac > _faba {_cdeb :=_bbac -_faba ;_egaac ._facf [_dbdf ._edec +_dbdf ._cbef -2]+=_cdeb ;};case *Division :_bcabg :=_bggcc ;_cefb :=ctx ;_cefb .X =_afaa ;_cefb .Y =_eace ;_cefb .Width =_ffee ;_fadcg ,_ ,_fddda :=_bcabg .GeneratePageBlocks (_cefb );if _fddda !=nil {return nil ,ctx ,_fddda ;};if len (_fadcg )> 1{_fecff :=_cefb .Height -_faba ;if _fecff > _faba {_bbag :=_fecff -_faba ;_egaac ._facf [_dbdf ._edec +_dbdf ._cbef -2]+=_bbag ;};};_cfbcc :=_bcabg .Height ()+_bcabg ._fbgg ._fedcf +_bcabg ._fbgg ._ebfe ;if _cfbcc > _faba {_ebgb :=_cfbcc -_faba ;_egaac ._facf [_dbdf ._edec +_dbdf ._cbef -2]+=_ebgb ;};};};var _aagec bool ;var _edfga ,_efeff int ;for _dgggd :=0;_dgggd < len (_egaac ._bedae );_dgggd ++{_ebdc :=_egaac ._bedae [_dgggd ];_aageg :=float64 (0.0);for _ccdbf :=0;_ccdbf < _ebdc ._gedg ;_ccdbf ++{_aageg +=_egaac ._eegg [_ebdc ._dbcgb +_ccdbf -1];};_cege :=float64 (0.0);for _egdba :=0;_egdba < _ebdc ._dbcgb -1;_egdba ++{_cege +=_egaac ._eegg [_egdba ]*_dgcg ;};_ceeag :=float64 (0.0);for _fcgf :=_abba ;_fcgf < _ebdc ._edec -1;_fcgf ++{_ceeag +=_egaac ._facf [_fcgf ];};_gebea :=_aageg *_dgcg ;_fcbf :=float64 (0.0);for _fgagc :=0;_fgagc < _ebdc ._cbef ;_fgagc ++{_fcbf +=_egaac ._facf [_ebdc ._edec +_fgagc -1];};ctx .Height =_gedff -_ceeag ;if _fcbf > ctx .Height {_bbcc =append (_bbcc ,_dfdfg );_dfdfg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_bage =ctx .Margins ._edbg ;_bfga =ctx .Margins ._fedcf ;ctx .Height =ctx .PageHeight -ctx .Margins ._fedcf -ctx .Margins ._ebfe ;ctx .Page ++;_gedff =ctx .Height ;_abba =_ebdc ._edec -1;_ceeag =0;if _egaac ._fgfb &&_eebf >=0{_edfga =_dgggd ;_dgggd =_eebf -1;_efeff =_abba ;_abba =_egaac ._gebe -1;_aagec =true ;continue ;};};ctx .Width =_gebea ;ctx .X =_bage +_cege ;ctx .Y =_bfga +_ceeag ;_gdafe :=_ebd (ctx .X ,ctx .Y ,_gebea ,_fcbf );if _ebdc ._ebae !=nil {_gfbf :=_ebdc ._ebae .R ();_edga :=_ebdc ._ebae .G ();_ceca :=_ebdc ._ebae .B ();_gdafe .SetFillColor (ColorRGBFromArithmetic (_gfbf ,_edga ,_ceca ));};_gdafe .LineStyle =_ebdc ._dfef ;_gdafe ._ggf =_ebdc ._fegdg ;_gdafe ._cfe =_ebdc ._cgff ;_gdafe ._bae =_ebdc ._aaad ;_gdafe ._efb =_ebdc ._gafc ;if _ebdc ._acdgf !=nil {_gdafe .SetColorLeft (ColorRGBFromArithmetic (_ebdc ._acdgf .R (),_ebdc ._acdgf .G (),_ebdc ._acdgf .B ()));};if _ebdc ._acfa !=nil {_gdafe .SetColorBottom (ColorRGBFromArithmetic (_ebdc ._acfa .R (),_ebdc ._acfa .G (),_ebdc ._acfa .B ()));};if _ebdc ._cfec !=nil {_gdafe .SetColorRight (ColorRGBFromArithmetic (_ebdc ._cfec .R (),_ebdc ._cfec .G (),_ebdc ._cfec .B ()));};if _ebdc ._bdbg !=nil {_gdafe .SetColorTop (ColorRGBFromArithmetic (_ebdc ._bdbg .R (),_ebdc ._bdbg .G (),_ebdc ._bdbg .B ()));};_gdafe .SetWidthBottom (_ebdc ._ecfbf );_gdafe .SetWidthLeft (_ebdc ._fdcfg );_gdafe .SetWidthRight (_ebdc ._bcdg );_gdafe .SetWidthTop (_ebdc ._egaab );_cdgea :=_dfdfg .Draw (_gdafe );if _cdgea !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cdgea );};if _ebdc ._gcce !=nil {_ecag :=_ebdc ._gcce .Width ();_gebcc :=_ebdc ._gcce .Height ();_beeeb :=0.0;switch _edfdb :=_ebdc ._gcce .(type ){case *Paragraph :if _edfdb ._gadd {_ecag =_edfdb .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _edfdb ._feab {_ecag =_edfdb .getMaxLineWidth ()/1000.0;};_becdd ,_dafd :=_edfdb .getLineHeight (0);if len (_edfdb ._bgcf )==1{_gebcc =_becdd ;}else {_gebcc =_gebcc -_dafd +_becdd ;};_beeeb =_becdd -_dafd ;switch _ebdc ._edaead {case CellVerticalAlignmentTop :_beeeb +=_becdd *0.5;case CellVerticalAlignmentBottom :_beeeb -=_becdd *0.5;};case *Table :_ecag =_gebea ;case *List :_ecag =_gebea ;};switch _ebdc ._cfaf {case CellHorizontalAlignmentLeft :ctx .X +=_ebdc ._gdegf ;ctx .Width -=_ebdc ._gdegf ;case CellHorizontalAlignmentCenter :_feddg :=_gebea -_ecag ;if _feddg > 0{ctx .X +=_feddg /2;ctx .Width -=_feddg /2;};case CellHorizontalAlignmentRight :if _gebea > _ecag {ctx .X =ctx .X +_gebea -_ecag -_ebdc ._gdegf ;ctx .Width -=_ebdc ._gdegf ;};};ctx .Y +=_beeeb ;switch _ebdc ._edaead {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_bdaa :=_fcbf -_gebcc ;if _bdaa > 0{ctx .Y +=_bdaa /2;ctx .Height -=_bdaa /2;};case CellVerticalAlignmentBottom :if _fcbf > _gebcc {ctx .Y =ctx .Y +_fcbf -_gebcc ;ctx .Height =_fcbf ;};};_gccb :=_dfdfg .DrawWithContext (_ebdc ._gcce ,ctx );if _gccb !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gccb );};ctx .Y -=_beeeb ;};ctx .Y +=_fcbf ;ctx .Height -=_fcbf ;if _aagec &&_dgggd +1> _cega {_bfga +=_ceeag +_fcbf ;_gedff -=_fcbf +_ceeag ;_abba =_efeff ;_dgggd =_edfga -1;_aagec =false ;};};_bbcc =append (_bbcc ,_dfdfg );if _egaac ._dafba .isAbsolute (){return _bbcc ,_abag ,nil ;};ctx .X =_abag .X ;ctx .Width =_abag .Width ;ctx .Y +=_egaac ._fgcfa ._ebfe ;ctx .Height -=_egaac ._fgcfa ._ebfe ;return _bbcc ,ctx ,nil ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_ebdd *Invoice )SetBuyerAddress (address *InvoiceAddress ){_ebdd ._ecfcb =address };

// SetBorderWidth sets the border width.
func (_efbc *Polygon )SetBorderWidth (borderWidth float64 ){_efbc ._ecccb .BorderWidth =borderWidth };

// Length calculates and returns the line length.
func (_beab *Line )Length ()float64 {return _g .Sqrt (_g .Pow (_beab ._cagb -_beab ._afaf ,2.0)+_g .Pow (_beab ._ccab -_beab ._aaea ,2.0));};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_gacf *StyledParagraph ;_cacfa []*TOCLine ;_geacf TextStyle ;_fade TextStyle ;_cbfac TextStyle ;_abddd TextStyle ;_cffed string ;_dgfb float64 ;_bbdd margins ;_fcbd positioning ;_ffdcd TextStyle ;_dbda bool ;};

// Width returns the width of the Paragraph.
func (_befg *StyledParagraph )Width ()float64 {if _befg ._feab &&int (_befg ._agbad )> 0{return _befg ._agbad ;};return _befg .getTextWidth ()/1000.0;};

// NewColumn returns a new column for the line items invoice table.
func (_gbfb *Invoice )NewColumn (description string )*InvoiceCell {return _gbfb .newColumn (description ,CellHorizontalAlignmentLeft );};func (_aaga *List )tableHeight (_affeg float64 )float64 {var _ecdce float64 ;for _ ,_cdfgg :=range _aaga ._gedee {switch _fee :=_cdfgg ._eagc .(type ){case *Paragraph :_cbbb :=_fee ;if _cbbb ._gadd {_cbbb .SetWidth (_affeg );};_ecdce +=_cbbb .Height ()+_cbbb ._dfdg ._ebfe +_cbbb ._dfdg ._ebfe ;_ecdce +=0.5*_cbbb ._fbga *_cbbb ._dffeb ;case *StyledParagraph :_ccae :=_fee ;if _ccae ._feab {_ccae .SetWidth (_affeg );};_ecdce +=_ccae .Height ()+_ccae ._bddbc ._fedcf +_ccae ._bddbc ._ebfe ;_ecdce +=0.5*_ccae .getTextHeight ();default:_ecdce +=_cdfgg ._eagc .Height ();};};return _ecdce ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dbbd *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _dbbd ._gecb [0],_dbbd ._gecb [1]};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_ccaf []_gb .CubicBezierCurve ;FillEnabled bool ;_acbg *_ggb .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_efbf *_ggb .PdfColorDeviceRGB ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_dgbf string ;_eccc *_ggb .PdfFont ;_fbga float64 ;_dffeb float64 ;_fcad _ggb .PdfColorDeviceRGB ;_ggfb TextAlignment ;_gadd bool ;_fadb float64 ;_ecaa int ;_eggd bool ;_bcbcf float64 ;_dfdg margins ;_aage positioning ;_fdcc float64 ;_bee float64 ;_ffda ,_aeca float64 ;_cfdc []string ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func _bebd (_eegfa int64 ,_fegbe ,_gcfb ,_gdgfg float64 )*_ggb .PdfAnnotation {_gaagg :=_ggb .NewPdfAnnotationLink ();_fbe :=_ggb .NewBorderStyle ();_fbe .SetBorderWidth (0);_gaagg .BS =_fbe .ToPdfObject ();if _eegfa < 0{_eegfa =0;};_gaagg .Dest =_aa .MakeArray (_aa .MakeInteger (_eegfa ),_aa .MakeName ("\u0058\u0059\u005a"),_aa .MakeFloat (_fegbe ),_aa .MakeFloat (_gcfb ),_aa .MakeFloat (_gdgfg ));return _gaagg .PdfAnnotation ;};

// Inline returns whether the inline mode of the division is active.
func (_gfde *Division )Inline ()bool {return _gfde ._dcdd };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_efef *Paragraph )SetTextAlignment (align TextAlignment ){_efef ._ggfb =align };

// AddSection adds a new content section at the end of the invoice.
func (_cfea *Invoice )AddSection (title ,content string ){_cfea ._eafe =append (_cfea ._eafe ,[2]string {title ,content });};

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_eeeg *Division )Height ()float64 {_cea :=0.0;_fecfc :=0.0;for _ ,_cecc :=range _eeeg ._adbeg {_begb ,_febf :=_cecc .Width (),_cecc .Height ();switch _edgfe :=_cecc .(type ){case *Paragraph :_gaf :=_edgfe ;_begb +=_gaf ._dfdg ._edbg +_gaf ._dfdg ._gac ;_febf +=_gaf ._dfdg ._fedcf +_gaf ._dfdg ._ebfe ;case *StyledParagraph :_addf :=_edgfe ;_begb +=_addf ._bddbc ._edbg +_addf ._bddbc ._gac ;_febf +=_addf ._bddbc ._fedcf +_addf ._bddbc ._ebfe ;};_cea +=_febf ;_fecfc =_cea ;};return _fecfc ;};

// AddPage adds the specified page to the creator.
// NOTE: When working with arbitrary PDF files, it may be helpful to
// normalize the pages prior to adding them to the creator in order
// to avoid any unexpected geometric effects from the page properties.
// Example:
//   pdfutil.NormalizePage(page)
//   c.AddPage(page)
func (_acde *Creator )AddPage (page *_ggb .PdfPage )error {_bda ,_deg :=page .GetMediaBox ();if _deg !=nil {_gg .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_deg );return _deg ;};_acde ._gedb .X =_bda .Llx +_acde ._eaca ._edbg ;_acde ._gedb .Y =_acde ._eaca ._fedcf ;_acde ._gedb .PageHeight =_bda .Ury -_bda .Lly ;_acde ._gedb .PageWidth =_bda .Urx -_bda .Llx ;_acde ._bdba =append (_acde ._bdba ,page );_acde ._gedb .Page ++;return nil ;};func _egfca (_egea ,_dbbbd ,_ffc ,_cadf float64 )*Line {_cdge :=&Line {};_cdge ._afaf =_egea ;_cdge ._aaea =_dbbbd ;_cdge ._cagb =_ffc ;_cdge ._ccab =_cadf ;_cdge ._bcfaf =_ggb .NewPdfColorDeviceRGB (0,0,0);_cdge ._caed =1.0;return _cdge ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gdae *Creator )NewParagraph (text string )*Paragraph {return _bcdb (text ,_gdae .NewTextStyle ())};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_efdc *TableCell )SetBorderLineStyle (style _gb .LineStyle ){_efdc ._dfef =style };

// Rows returns the total number of rows the table has.
func (_bccd *Table )Rows ()int {return _bccd ._daac };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_dged *TOC )SetLineTitleStyle (style TextStyle ){_dged ._fade =style };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_dbd *Block )AddAnnotation (annotation *_ggb .PdfAnnotation ){for _ ,_dg :=range _dbd ._ca {if _dg ==annotation {return ;};};_dbd ._ca =append (_dbd ._ca ,annotation );};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_cdcgf []*TextChunk ;_aca TextStyle ;_aabc TextStyle ;_ebgc TextAlignment ;_cdfgf float64 ;_feab bool ;_agbad float64 ;_fgdg bool ;_efbd float64 ;_bddbc margins ;_aaaec positioning ;_facgg float64 ;_fbag float64 ;_gcbbc float64 ;_bbcgg float64 ;_bgcf [][]*TextChunk ;_aggc func (_bagd *StyledParagraph ,_faafg DrawContext );};type margins struct{_edbg float64 ;_gac float64 ;_fedcf float64 ;_ebfe float64 ;};

// SetColorRight sets border color for right.
func (_bcde *border )SetColorRight (col Color ){_bcde ._dbc =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetOpacity sets opacity for Image.
func (_bafe *Image )SetOpacity (opacity float64 ){_bafe ._fbgb =opacity };

// SetFillColor sets the fill color for the path.
func (_agcc *FilledCurve )SetFillColor (color Color ){_agcc ._acbg =_ggb .NewPdfColorDeviceRGB (color .ToRGB ());};

// Append adds a new text chunk to the paragraph.
func (_ddfd *StyledParagraph )Append (text string )*TextChunk {_ffafa :=NewTextChunk (text ,_ddfd ._aca );return _ddfd .appendChunk (_ffafa );};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_agea *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _ggge (number ,title ,page ,level ,style );};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_dcf *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dff :=ctx ;if _dcf ._bdde .isRelative (){ctx .X +=_dcf ._eadf ._edbg ;ctx .Y +=_dcf ._eadf ._fedcf ;ctx .Width -=_dcf ._eadf ._edbg +_dcf ._eadf ._gac ;ctx .Height -=_dcf ._eadf ._fedcf ;};_fbce ,_daga ,_aeaa :=_dcf ._bced .GeneratePageBlocks (ctx );if _aeaa !=nil {return _fbce ,ctx ,_aeaa ;};ctx =_daga ;_ggc :=ctx .X ;_dgc :=ctx .Y -_dcf ._bced .Height ();_egge :=int64 (ctx .Page );_debd :=_dcf .headingNumber ();_fbbg :=_dcf .headingText ();if _dcf ._abfa {_gbfc :=_dcf ._efag .Add (_debd ,_dcf ._fcca ,_c .FormatInt (_egge ,10),_dcf ._gga );if _dcf ._efag ._dbda {_gbfc .SetLink (_egge ,_ggc ,_dgc );};};if _dcf ._gdde ==nil {_dcf ._gdde =_ggb .NewOutlineItem (_fbbg ,_ggb .NewOutlineDest (_egge -1,_ggc ,_dgc ));if _dcf ._gae !=nil {_dcf ._gae ._gdde .Add (_dcf ._gdde );}else {_dcf ._bbgf .Add (_dcf ._gdde );};}else {_adg :=&_dcf ._gdde .Dest ;_adg .Page =_egge -1;_adg .X =_ggc ;_adg .Y =_dgc ;};for _ ,_fgbbb :=range _dcf ._fbd {_ffe ,_aeac ,_cfa :=_fgbbb .GeneratePageBlocks (ctx );if _cfa !=nil {return _fbce ,ctx ,_cfa ;};if len (_ffe )< 1{continue ;};_fbce [len (_fbce )-1].mergeBlocks (_ffe [0]);_fbce =append (_fbce ,_ffe [1:]...);ctx =_aeac ;};if _dcf ._bdde .isRelative (){ctx .X =_dff .X ;};if _dcf ._bdde .isAbsolute (){return _fbce ,_dff ,nil ;};return _fbce ,ctx ,nil ;};func (_bccf *Image )rotatedSize ()(float64 ,float64 ){_gef :=_bccf ._ddcb ;_faad :=_bccf ._adfd ;_gbfg :=_bccf ._fcd ;if _gbfg ==0{return _gef ,_faad ;};_aegc :=_gb .Path {Points :[]_gb .Point {_gb .NewPoint (0,0).Rotate (_gbfg ),_gb .NewPoint (_gef ,0).Rotate (_gbfg ),_gb .NewPoint (0,_faad ).Rotate (_gbfg ),_gb .NewPoint (_gef ,_faad ).Rotate (_gbfg )}}.GetBoundingBox ();return _aegc .Width ,_aegc .Height ;};func _eggde (_cbgdd ,_affg ,_fdeg ,_gageb float64 )*Rectangle {return &Rectangle {_deeba :_cbgdd ,_gcdd :_affg ,_cagg :_fdeg ,_gece :_gageb ,_baba :_ggb .NewPdfColorDeviceRGB (0,0,0),_geca :1.0,_fcea :1.0,_fdeb :1.0};};

// SellerAddress returns the seller address used in the invoice template.
func (_ceff *Invoice )SellerAddress ()*InvoiceAddress {return _ceff ._gaaf };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ffdd *Image )ScaleToWidth (w float64 ){_dafc :=_ffdd ._adfd /_ffdd ._ddcb ;_ffdd ._ddcb =w ;_ffdd ._adfd =w *_dafc ;};

// TOC returns the table of contents component of the creator.
func (_bdbb *Creator )TOC ()*TOC {return _bdbb ._fecg };func (_fbbe *Invoice )generateNoteBlocks (_gafgd DrawContext )([]*Block ,DrawContext ,error ){_bbga :=_eeab ();_ffeg :=append ([][2]string {_fbbe ._fgbg ,_fbbe ._ccef },_fbbe ._eafe ...);for _ ,_feffb :=range _ffeg {if _feffb [1]!=""{_dcga :=_fbbe .drawSection (_feffb [0],_feffb [1]);for _ ,_afbd :=range _dcga {_bbga .Add (_afbd );};_dbbfea :=_bcbd (_fbbe ._ggca );_dbbfea .SetMargins (0,0,10,0);_bbga .Add (_dbbfea );};};return _bbga .GeneratePageBlocks (_gafgd );};

// Height returns the Block's height.
func (_cfc *Block )Height ()float64 {return _cfc ._dc };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_bccfb *List )Marker ()*TextChunk {return &_bccfb ._dbdb };

// SetLineHeight sets the line height (1.0 default).
func (_fcef *Paragraph )SetLineHeight (lineheight float64 ){_fcef ._dffeb =lineheight };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_bfcf *Creator )NewPolyBezierCurve (curves []_gb .CubicBezierCurve )*PolyBezierCurve {return _dae (curves );};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_cac *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cac ._gbc ._edbg ,_cac ._gbc ._gac ,_cac ._gbc ._fedcf ,_cac ._gbc ._ebfe ;};

// MoveX moves the drawing context to absolute position x.
func (_gbbd *Creator )MoveX (x float64 ){_gbbd ._gedb .X =x };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_efed *Image )ScaleToHeight (h float64 ){_decba :=_efed ._ddcb /_efed ._adfd ;_efed ._adfd =h ;_efed ._ddcb =h *_decba ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_adefa *Invoice )NoteStyle ()TextStyle {return _adefa ._cffe };

// SetColorLeft sets border color for left.
func (_dac *border )SetColorLeft (col Color ){_dac ._ccg =_ggb .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetLogo sets the logo of the invoice.
func (_edfd *Invoice )SetLogo (logo *Image ){_edfd ._fegb =logo };func _agd (_aaef *Block ,_eaaa *Image ,_afgc DrawContext )(DrawContext ,error ){_fgeb :=_afgc ;_abaa :=1;_geff :=_aa .PdfObjectName (_eac .Sprintf ("\u0049\u006d\u0067%\u0064",_abaa ));for _aaef ._ce .HasXObjectByName (_geff ){_abaa ++;_geff =_aa .PdfObjectName (_eac .Sprintf ("\u0049\u006d\u0067%\u0064",_abaa ));};_bbda :=_aaef ._ce .SetXObjectImageByName (_geff ,_eaaa ._gdec );if _bbda !=nil {return _afgc ,_bbda ;};_feff :=0;_gdf :=_aa .PdfObjectName (_eac .Sprintf ("\u0047\u0053\u0025\u0064",_feff ));for _aaef ._ce .HasExtGState (_gdf ){_feff ++;_gdf =_aa .PdfObjectName (_eac .Sprintf ("\u0047\u0053\u0025\u0064",_feff ));};_ccccf :=_aa .MakeDict ();_ccccf .Set ("\u0042\u004d",_aa .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _eaaa ._fbgb < 1.0{_ccccf .Set ("\u0043\u0041",_aa .MakeFloat (_eaaa ._fbgb ));_ccccf .Set ("\u0063\u0061",_aa .MakeFloat (_eaaa ._fbgb ));};_bbda =_aaef ._ce .AddExtGState (_gdf ,_aa .MakeIndirectObject (_ccccf ));if _bbda !=nil {return _afgc ,_bbda ;};_afdg :=_eaaa .Width ();_bdda :=_eaaa .Height ();_ ,_fabf :=_eaaa .rotatedSize ();_geaae :=_afgc .X ;_agfb :=_afgc .PageHeight -_afgc .Y -_bdda ;if _eaaa ._beaf .isRelative (){_agfb -=(_fabf -_bdda )/2;switch _eaaa ._caefg {case HorizontalAlignmentCenter :_geaae +=(_afgc .Width -_afdg )/2;case HorizontalAlignmentRight :_geaae =_afgc .PageWidth -_afgc .Margins ._gac -_eaaa ._ecgd ._gac -_afdg ;};};_afb :=_eaaa ._fcd ;_dbfd :=_eb .NewContentCreator ();_dbfd .Add_gs (_gdf );_dbfd .Translate (_geaae ,_agfb );if _afb !=0{_dbfd .Translate (_afdg /2,_bdda /2);_dbfd .RotateDeg (_afb );_dbfd .Translate (-_afdg /2,-_bdda /2);};_dbfd .Scale (_afdg ,_bdda ).Add_Do (_geff );_faca :=_dbfd .Operations ();_faca .WrapIfNeeded ();_aaef .addContents (_faca );if _eaaa ._beaf .isRelative (){_afgc .Y +=_fabf ;_afgc .Height -=_fabf ;return _afgc ,nil ;};return _fgeb ,nil ;};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_fdc :=rgbColor {};_fdc ._edgf =float64 (r )/255.0;_fdc ._cccd =float64 (g )/255.0;_fdc ._efd =float64 (b )/255.0;return _fdc ;};

// SetBorderOpacity sets the border opacity.
func (_cfge *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_cfge ._bddg =opacity };func (_dabb *Invoice )setCellBorder (_gddb *TableCell ,_bggb *InvoiceCell ){for _ ,_aefe :=range _bggb .BorderSides {_gddb .SetBorder (_aefe ,CellBorderStyleSingle ,_bggb .BorderWidth );};_gddb .SetBorderColor (_bggb .BorderColor );};

// SetWidthRight sets border width for right.
func (_bed *border )SetWidthRight (bw float64 ){_bed ._bce =bw };

// SetNotes sets the notes section of the invoice.
func (_gdce *Invoice )SetNotes (title ,content string ){_gdce ._fgbg =[2]string {title ,content }};

// NewImageFromData creates an Image from image data.
func (_adfac *Creator )NewImageFromData (data []byte )(*Image ,error ){return _cfgd (data )};func (_cdee *StyledParagraph )getMaxLineWidth ()float64 {if _cdee ._bgcf ==nil ||len (_cdee ._bgcf )==0{_cdee .wrapText ();};var _baec float64 ;for _ ,_cdage :=range _cdee ._bgcf {_abaae :=_cdee .getTextLineWidth (_cdage );if _abaae > _baec {_baec =_abaae ;};};return _baec ;};

// Width returns the width of the Paragraph.
func (_fbdgg *Paragraph )Width ()float64 {if _fbdgg ._gadd &&int (_fbdgg ._fadb )> 0{return _fbdgg ._fadb ;};return _fbdgg .getTextWidth ()/1000.0;};

// Columns returns all the columns in the invoice line items table.
func (_gafg *Invoice )Columns ()[]*InvoiceCell {return _gafg ._gdaed };func _dagf (_cgbf TextStyle )*List {return &List {_dbdb :TextChunk {Text :"\u2022\u0020",Style :_cgbf },_fafc :0,_bfgb :true ,_cgcf :_bbd ,_caace :_cgbf };};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_acg *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_fggd *_ggb .PdfWriter )error ){_acg ._bcfe =pdfWriterAccessFunc ;};