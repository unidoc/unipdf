//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_e "bytes";_gd "encoding/xml";_fab "errors";_a "fmt";_ed "github.com/gorilla/i18n/linebreak";_ea "github.com/unidoc/unichart/render";_fge "github.com/unidoc/unipdf/v4/common";_fgc "github.com/unidoc/unipdf/v4/contentstream";_ggb "github.com/unidoc/unipdf/v4/contentstream/draw";
_cdf "github.com/unidoc/unipdf/v4/core";_ag "github.com/unidoc/unipdf/v4/internal/graphic2d";_ae "github.com/unidoc/unipdf/v4/internal/integrations/unichart";_dg "github.com/unidoc/unipdf/v4/internal/license";_fag "github.com/unidoc/unipdf/v4/internal/precision";
_cf "github.com/unidoc/unipdf/v4/internal/transform";_cd "github.com/unidoc/unipdf/v4/model";_dd "golang.org/x/net/html/charset";_ga "image";_bg "io";_df "log";_bd "math";_ac "os";_d "path/filepath";_fg "regexp";_fa "sort";_c "strconv";_gg "strings";_f "text/template";
_gaf "unicode";_g "unicode/utf8";);func (_dfcf *templateProcessor )parseInt64Array (_fbade ,_gbae string )[]int64 {_fge .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fbade ,_gbae );
_ffbff :=_gg .Fields (_gbae );_dfdcc :=make ([]int64 ,0,len (_ffbff ));for _ ,_dffc :=range _ffbff {_gbdfg ,_ :=_c .ParseInt (_dffc ,10,64);_dfdcc =append (_dfdcc ,_gbdfg );};return _dfdcc ;};

// Width returns the width of the graphic svg.
func (_gfffa *GraphicSVG )Width ()float64 {return _gfffa ._dcdb .Width };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);func (_abbb *Invoice )drawAddress (_cddg *InvoiceAddress )[]*StyledParagraph {var _gfafeg []*StyledParagraph ;
if _cddg .Heading !=""{_cgcc :=_dgdda (_abbb ._cabf );_cgcc .SetMargins (0,0,0,7);_cgcc .Append (_cddg .Heading );_gfafeg =append (_gfafeg ,_cgcc );};_cdbfb :=_dgdda (_abbb ._fdcd );_cdbfb .SetLineHeight (1.2);_cgadc :=_cddg .Separator ;if _cgadc ==""{_cgadc =_abbb ._fgagg ;
};_ccadd :=_cddg .City ;if _cddg .State !=""{if _ccadd !=""{_ccadd +=_cgadc ;};_ccadd +=_cddg .State ;};if _cddg .Zip !=""{if _ccadd !=""{_ccadd +=_cgadc ;};_ccadd +=_cddg .Zip ;};if _cddg .Name !=""{_cdbfb .Append (_cddg .Name +"\u000a");};if _cddg .Street !=""{_cdbfb .Append (_cddg .Street +"\u000a");
};if _cddg .Street2 !=""{_cdbfb .Append (_cddg .Street2 +"\u000a");};if _ccadd !=""{_cdbfb .Append (_ccadd +"\u000a");};if _cddg .Country !=""{_cdbfb .Append (_cddg .Country +"\u000a");};_abffe :=_dgdda (_abbb ._fdcd );_abffe .SetLineHeight (1.2);_abffe .SetMargins (0,0,7,0);
if _cddg .Phone !=""{_abffe .Append (_cddg .fmtLine (_cddg .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_cddg .HidePhoneLabel ));};if _cddg .Email !=""{_abffe .Append (_cddg .fmtLine (_cddg .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_cddg .HideEmailLabel ));
};_gfafeg =append (_gfafeg ,_cdbfb ,_abffe );return _gfafeg ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_edbe *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _fegdc (x1 ,y1 ,cx ,cy ,x2 ,y2 );};func (_dac *Block )mergeBlocks (_ec *Block )error {_gcb :=_ddd (_dac ._fc ,_dac ._gaa ,_ec ._fc ,_ec ._gaa );if _gcb !=nil {return _gcb ;};
for _ ,_gdf :=range _ec ._ffa {_dac .AddAnnotation (_gdf );};return nil ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_afdd *Creator )EnableFontSubsetting (font *_cd .PdfFont ){_afdd ._ebce =append (_afdd ._ebce ,font );};

// GraphicSVGStyle represents style attributes for `GraphicSVG`.
type GraphicSVGStyle struct{FillColor string ;StrokeColor string ;StrokeWidth float64 ;FillOpacity float64 ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gbfee *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _gbfee ._gega [0],_gbfee ._gega [1]};

// GetHeight get the current height for the row.
func (_dagf *GridRow )GetHeight ()float64 {return _dagf ._dada };func (_aebd *Chapter )headingNumber ()string {var _fabfe string ;if _aebd ._fbf {if _aebd ._egg !=0{_fabfe =_c .Itoa (_aebd ._egg )+"\u002e";};if _aebd ._aagc !=nil {_eaf :=_aebd ._aagc .headingNumber ();
if _eaf !=""{_fabfe =_eaf +_fabfe ;};};};return _fabfe ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{taggedDrawable ;_bbgfb *StyledParagraph ;_affbb []*TOCLine ;_cbgg TextStyle ;_ecacc TextStyle ;_acbdd TextStyle ;_accg TextStyle ;_cgaeg string ;_fbaf float64 ;_fabff Margins ;_cgeec Positioning ;_cagc TextStyle ;_accgc bool ;};

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_fdfb *PageBreak )SetStructureType (structureType _cd .StructureType ){};

// Scale scales Image by a constant factor, both width and height.
func (_cffa *Image )Scale (xFactor ,yFactor float64 ){_cffa ._dbdfea =xFactor *_cffa ._dbdfea ;_cffa ._eafg =yFactor *_cffa ._eafg ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_gebg *Invoice )SetTitleStyle (style TextStyle ){_gebg ._gbgee =style };type border struct{_gae float64 ;_acc float64 ;_degf float64 ;_ddf float64 ;_ggf Color ;_dfc Color ;_gbdg float64 ;_aagb Color ;_bbf float64 ;_gfef Color ;_bbff float64 ;_afd Color ;
_beb float64 ;LineStyle _ggb .LineStyle ;_bffb CellBorderStyle ;_bdf CellBorderStyle ;_dbda CellBorderStyle ;_cff CellBorderStyle ;_fccfa float64 ;};func _cdgg (_dgfc *templateProcessor ,_eedbe *templateNode )(interface{},error ){return _dgfc .parseRectangle (_eedbe );
};

// Opacity returns the opacity of the line.
func (_daggb *Line )Opacity ()float64 {return _daggb ._accf };

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_cdae *Creator )SetPageSize (size PageSize ){_cdae ._cga =size ;_cdae ._ebgd =size [0];_cdae ._bda =size [1];_fbda :=0.1*_cdae ._ebgd ;_cdae ._ecba .Left =_fbda ;_cdae ._ecba .Right =_fbda ;_cdae ._ecba .Top =_fbda ;_cdae ._ecba .Bottom =_fbda ;};


// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_db *Block )SetPos (x ,y float64 ){_db ._edf =PositionAbsolute ;_db ._fd =x ;_db ._be =y };type shading struct{_dcfb Color ;_ggfe bool ;_fcce []bool ;_ecgf []*ColorPoint ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_ggac *Division )EnablePageWrap (enable bool ){_ggac ._agaad =enable };

// SetBorderOpacity sets the border opacity.
func (_fdbc *CurvePolygon )SetBorderOpacity (opacity float64 ){_fdbc ._add =opacity };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;var (ErrContentNotFit =_fab .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);func _fcefg (_bcbb []_ggb .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_fbac :&_ggb .PolyBezierCurve {Curves :_bcbb ,BorderColor :_cd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_edfe :1.0,_eaecf :1.0};};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_afbb *Paragraph )SetTextAlignment (align TextAlignment ){_afbb ._aegb =align };func (_abec *templateProcessor )parseBackground (_bdabg *templateNode )(interface{},error ){_gggbg :=&Background {};for _ ,_aeaaa :=range _bdabg ._bcaga .Attr {_ccebf :=_aeaaa .Value ;
switch _cdfec :=_aeaaa .Name .Local ;_cdfec {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_gggbg .FillColor =_abec .parseColorAttr (_cdfec ,_ccebf );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gggbg .BorderColor =_abec .parseColorAttr (_cdfec ,_ccebf );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_gggbg .BorderSize =_abec .parseFloatAttr (_cdfec ,_ccebf );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_ceaf ,_eaeca ,_gfbee ,_eccdc :=_abec .parseBorderRadiusAttr (_cdfec ,_ccebf );
_gggbg .SetBorderRadius (_ceaf ,_eaeca ,_eccdc ,_gfbee );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_gggbg .BorderRadiusTopLeft =_abec .parseFloatAttr (_cdfec ,_ccebf );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gggbg .BorderRadiusTopRight =_abec .parseFloatAttr (_cdfec ,_ccebf );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_gggbg .BorderRadiusBottomLeft =_abec .parseFloatAttr (_cdfec ,_ccebf );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_gggbg .BorderRadiusBottomRight =_abec .parseFloatAttr (_cdfec ,_ccebf );
default:_abec .nodeLogDebug (_bdabg ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_cdfec );
};};return _gggbg ,nil ;};

// GridCell defines a cell which can contain a Drawable as content.
type GridCell struct{taggedDrawable ;_adfc Color ;_gfafe float64 ;_adfcb _ggb .LineStyle ;_bbbb CellBorderStyle ;_bbcda Color ;_bfaa float64 ;_eegca CellBorderStyle ;_feaeg Color ;_efbfef float64 ;_bdd CellBorderStyle ;_cfbg Color ;_edadde float64 ;_dfcd CellBorderStyle ;
_eeada Color ;_bbdaf float64 ;_ddad VectorDrawable ;_affb ,_gebd int ;_fdca int ;_cdfdb int ;_bbga CellHorizontalAlignment ;_efdb CellVerticalAlignment ;_dedf float64 ;};

// SetColorLeft sets border color for left.
func (_cdc *border )SetColorLeft (col Color ){_cdc ._dfc =col };func (_dfefd *Subpath )compare (_edbec *Subpath )bool {if len (_dfefd .Commands )!=len (_edbec .Commands ){return false ;};for _dfaae ,_cfbge :=range _dfefd .Commands {if !_cfbge .compare (_edbec .Commands [_dfaae ]){return false ;
};};return true ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_cfefa *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_addgb :=&_cfefa ._fabff ;_addgb .Left =left ;_addgb .Right =right ;_addgb .Top =top ;_addgb .Bottom =bottom ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_ggg *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ggg ._cfad .Left ,_ggg ._cfad .Right ,_ggg ._cfad .Top ,_ggg ._cfad .Bottom ;};func (_eefab *GridCell )width (_gcgf []float64 ,_cffbb float64 )float64 {_adgeg :=float64 (0.0);
for _dfccd :=0;_dfccd < _eefab ._cdfdb ;_dfccd ++{_adgeg +=_gcgf [_eefab ._gebd +_dfccd ];};return _adgeg *_cffbb ;};

// SetWidth sets the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_cfge *Paragraph )SetWidth (width float64 ){_cfge ._efbe =width ;_cfge .wrapText ()};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_dege *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _aecb (x1 ,y1 ,x2 ,y2 )};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_gdfaa *LinearShading )SetBackgroundColor (backgroundColor Color ){_gdfaa ._bedba .SetBackgroundColor (backgroundColor );};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_bfc *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _bbaf (x ,y ,innerRadius ,outerRadius ,colorPoints );};func (_ebbbc *GraphicSVGStyle )fillStroke (_cfdg *_fgc .ContentCreator ){if _ebbbc .FillColor !=""&&_ebbbc .StrokeColor !=""{_cfdg .Add_B ();
}else if _ebbbc .FillColor !=""{_cfdg .Add_f ();}else if _ebbbc .StrokeColor !=""{_cfdg .Add_S ();};};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_fgcf *TOC )SetLineStyle (style TextStyle ){_fgcf .SetLineNumberStyle (style );_fgcf .SetLineTitleStyle (style );_fgcf .SetLineSeparatorStyle (style );_fgcf .SetLinePageStyle (style );};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_baada *Line )SetPositioning (positioning Positioning ){_baada ._gdef =positioning };func (_acgdga *templateProcessor )getNodeErrorLocation (_gaagc *templateNode ,_fgegfe string ,_bbaac ...interface{})string {_gdaef :=_a .Sprintf (_fgegfe ,_bbaac ...);
_acee :=_a .Sprintf ("\u0025\u0064",_gaagc ._fedb );if _gaagc ._aggca !=0{_acee =_a .Sprintf ("\u0025\u0064\u003a%\u0064",_gaagc ._aggca ,_gaagc ._bbffb );};if _acgdga ._cgcdc !=""{return _a .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_gdaef ,_acgdga ._cgcdc ,_acee );
};return _a .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_gdaef ,_acee );};var PPI float64 =72;

// SetFont sets the font for the paragraph.
func (_bdfc *StyledParagraph )SetFont (font *_cd .PdfFont ){_bdfc ._eeac .Font =font ;for _ ,_adbdgf :=range _bdfc ._bcebd {_adbdgf .Style .Font =font ;};};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_gac *Block )ScaleToHeight (h float64 ){_ffc :=h /_gac ._ff ;_gac .Scale (_ffc ,_ffc )};func (_gaff *Paragraph )getTextMetrics ()(_dddcd ,_dacd ,_acada float64 ){_ddea :=_fded (_gaff ._gcfa ,_gaff ._dgdde );if _ddea ._eggfc > _dddcd {_dddcd =_ddea ._eggfc ;
};if _ddea ._aebfd < _acada {_acada =_ddea ._aebfd ;};if _deadb :=_gaff ._dgdde ;_deadb > _dacd {_dacd =_deadb ;};return _dddcd ,_dacd ,_acada ;};func (_cfbaba *templateProcessor )parseImageEncoder (_eaad ,_ebfdb string )_cdf .StreamEncoder {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0028\u0060\u0025s\u0060\u002c \u0025\u0073\u0029\u002e",_eaad ,_ebfdb );
if _ebfdb =="\u0066\u006c\u0061t\u0065"{return _cdf .NewFlateEncoder ();}else if _ebfdb =="\u0064\u0063\u0074"{return _cdf .NewDCTEncoder ();};_fge .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0076\u0061\u006cu\u0065\u0020\u006f\u0066 \u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u0020\u0066\u006f\u0075\u006e\u0064\u002e",_eaad ,_ebfdb );
return nil ;};func _dggd (_aaeae string )(*_cd .PdfFont ,error ){_gdfega ,_dfef :=map[string ]_cd .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_cd .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_cd .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_cd .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_cd .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_cd .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_cd .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_cd .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_cd .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_cd .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_cd .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_cd .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_cd .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_cd .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_cd .TimesBoldItalicName }[_aaeae ];
if !_dfef {return nil ,_a .Errorf ("\u0066\u006f\u006e\u0074\u002df\u0061\u006d\u0069\u006c\u0079\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u006c\u0069\u0073t",_aaeae );
};_bfbe ,_eebb :=_cd .NewStandard14Font (_gdfega );if _eebb !=nil {return nil ,_eebb ;};return _bfbe ,nil ;};func (_bbgb *Invoice )generateLineBlocks (_eagb DrawContext )([]*Block ,DrawContext ,error ){_aaeg :=_gecca (len (_bbgb ._bdfec ));_aaeg .SetMargins (0,0,25,0);
for _ ,_fffe :=range _bbgb ._bdfec {_agee :=_dgdda (_fffe .TextStyle );_agee .SetMargins (0,0,1,0);_agee .Append (_fffe .Value );_egcfe :=_aaeg .NewCell ();_egcfe .SetHorizontalAlignment (_fffe .Alignment );_egcfe .SetBackgroundColor (_fffe .BackgroundColor );
_bbgb .setCellBorder (_egcfe ,_fffe );_egcfe .SetContent (_agee );};for _ ,_feaed :=range _bbgb ._abff {for _ ,_fgae :=range _feaed {_cafca :=_dgdda (_fgae .TextStyle );_cafca .SetMargins (0,0,3,2);_cafca .Append (_fgae .Value );_gdbgd :=_aaeg .NewCell ();
_gdbgd .SetHorizontalAlignment (_fgae .Alignment );_gdbgd .SetBackgroundColor (_fgae .BackgroundColor );_bbgb .setCellBorder (_gdbgd ,_fgae );_gdbgd .SetContent (_cafca );};};return _aaeg .GeneratePageBlocks (_eagb );};

// SetMarkedContentID sets marked content ID.
func (_dabc *Invoice )SetMarkedContentID (id int64 ){};func (_cdaaa *Table )clone ()*Table {_bgcdg :=*_cdaaa ;_bgcdg ._fgege =make ([]float64 ,len (_cdaaa ._fgege ));copy (_bgcdg ._fgege ,_cdaaa ._fgege );_bgcdg ._fefea =make ([]float64 ,len (_cdaaa ._fefea ));
copy (_bgcdg ._fefea ,_cdaaa ._fefea );_bgcdg ._dfcec =make ([]*TableCell ,0,len (_cdaaa ._dfcec ));for _ ,_eccb :=range _cdaaa ._dfcec {_cfffb :=*_eccb ;_cfffb ._acgc =&_bgcdg ;_bgcdg ._dfcec =append (_bgcdg ._dfcec ,&_cfffb );};return &_bgcdg ;};

// This method is not supported by Chapter component and exists solely to satisfy the Drawable interface.
func (_afcd *Chapter )SetMarkedContentID (id int64 ){};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{taggedDrawable ;_agaga *_ggb .Polygon ;_cfab float64 ;_fdbe float64 ;_fcfd Color ;};

// SetFillOpacity sets the fill opacity.
func (_acbe *PolyBezierCurve )SetFillOpacity (opacity float64 ){_acbe ._edfe =opacity };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetMargins sets the margins of the graphic svg component.
func (_bffc *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_bffc ._cded .Left =left ;_bffc ._cded .Right =right ;_bffc ._cded .Top =top ;_bffc ._cded .Bottom =bottom ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_ecbge *Rectangle )SetFillOpacity (opacity float64 ){_ecbge ._abbd =opacity };

// SetMargins sets the Paragraph's margins.
func (_dfgb *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_dfgb ._dcfd .Left =left ;_dfgb ._dcfd .Right =right ;_dfgb ._dcfd .Top =top ;_dfgb ._dcfd .Bottom =bottom ;};func _bceca (_eefad VectorDrawable ,_agbe float64 ,_cceae float64 ,_cbgbf CellVerticalAlignment ,_edeb bool ,_caaee *_cd .KDict ,_accad int64 ,_dceb float64 )(float64 ,float64 ,float64 ,*_cd .KDict ,bool ,error ){var (_eegf bool ;
_eabbd *_cd .KDict ;_ageda float64 ;_ffadg error ;);switch _bfdfe :=_eefad .(type ){case *Paragraph :if _bfdfe ._fabc {_agbe =_bfdfe .getMaxLineWidth ()/1000.0;};_gafga ,_aabbg ,_ :=_bfdfe .getTextMetrics ();_egfc ,_gabfg :=_gafga *_bfdfe ._fbdcb ,_aabbg *_bfdfe ._fbdcb ;
_cceae =_cceae -_gabfg +_egfc ;_ageda +=_egfc -_gabfg ;_gfacb :=0.5;if _edeb {_gfacb =0.3;};switch _cbgbf {case CellVerticalAlignmentTop :_ageda +=_egfc *_gfacb ;case CellVerticalAlignmentBottom :_ageda -=_egfc *_gfacb ;};_agbe +=_bfdfe ._dcfd .Left +_bfdfe ._dcfd .Right ;
_cceae +=_bfdfe ._dcfd .Top +_bfdfe ._dcfd .Bottom ;if _caaee !=nil {_bfdfe .SetMarkedContentID (_accad );_bfdfe .SetStructureType (_cd .StructureTypeParagraph );_eabbd ,_ffadg =_bfdfe .GenerateKDict ();if _ffadg !=nil {return 0,0,0,nil ,false ,_a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u004b\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072a\u0070h\u003a\u0020\u0025\u0077",_ffadg );
};};case *StyledParagraph :if _bfdfe ._bccfb {_agbe =_bfdfe .getMaxLineWidth ()/1000.0;};_afed ,_beedf ,_gebdf :=_bfdfe .getLineMetrics (0);_efgcc ,_dcga :=_afed *_bfdfe ._dgbeg ,_beedf *_bfdfe ._dgbeg ;if _bfdfe ._fcdg ==TextVerticalAlignmentCenter {_ageda =_dcga -(_beedf +(_afed +_gebdf -_beedf )/2+(_dcga -_beedf )/2);
};if len (_bfdfe ._adcf )==1{_cceae =_efgcc ;}else {_cceae =_cceae -_dcga +_efgcc ;};_ageda +=_efgcc -_dcga ;switch _cbgbf {case CellVerticalAlignmentTop :_ageda +=_efgcc *0.5;case CellVerticalAlignmentBottom :_ageda -=_efgcc *0.5;};_agbe +=_bfdfe ._acgdg .Left +_bfdfe ._acgdg .Right ;
_cceae +=_bfdfe ._acgdg .Top +_bfdfe ._acgdg .Bottom ;if _caaee !=nil {_bfdfe .SetMarkedContentID (_accad );_bfdfe .SetStructureType (_cd .StructureTypeParagraph );_eabbd ,_ffadg =_bfdfe .GenerateKDict ();if _ffadg !=nil {return 0,0,0,nil ,false ,_a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064 \u0074\u006f\u0020g\u0065\u006e\u0065r\u0061\u0074\u0065\u0020\u004b\u0020\u0064\u0069\u0063\u0074i\u006f\u006e\u0061\u0072\u0079 f\u006f\u0072\u0020\u0073\u0074\u0079\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0077",_ffadg );
};};case *Table :_agbe =_dceb ;if _caaee !=nil {_bfdfe .SetMarkedContentID (_accad );_bfdfe .AddTag (_caaee );_eegf =true ;_eabbd ,_ffadg =_bfdfe .GenerateKDict ();if _ffadg !=nil {return 0,0,0,nil ,false ,_a .Errorf ("\u0066a\u0069\u006ce\u0064\u0020\u0074o\u0020\u0067\u0065\u006e\u0065\u0072\u0061t\u0065\u0020\u004b\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0066\u006f\u0072 \u0074\u0061\u0062\u006c\u0065\u003a\u0020\u0025\u0077",_ffadg );
};};case *List :_agbe =_dceb ;if _caaee !=nil {_bfdfe .SetMarkedContentID (_accad );_bfdfe .AddTag (_caaee );_eegf =true ;_eabbd ,_ffadg =_bfdfe .GenerateKDict ();if _ffadg !=nil {return 0,0,0,nil ,false ,_a .Errorf ("\u0066a\u0069\u006ce\u0064\u0020\u0074o\u0020\u0067\u0065\u006e\u0065\u0072\u0061t\u0065\u0020\u004b\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0066\u006f\u0072 \u0074\u0061\u0062\u006c\u0065\u003a\u0020\u0025\u0077",_ffadg );
};};case *Division :_agbe =_dceb ;case *Chart :_agbe =_dceb ;case *Line :_cceae +=_bfdfe ._adac .Top +_bfdfe ._adac .Bottom ;_ageda -=_bfdfe .Height ()/2;case *Image :_agbe +=_bfdfe ._begc .Left +_bfdfe ._begc .Right ;_cceae +=_bfdfe ._begc .Top +_bfdfe ._begc .Bottom ;
};return _agbe ,_cceae ,_ageda ,_eabbd ,_eegf ,nil ;};func (_aeeac *GraphicSVGElement )setDefaultScaling (_fage float64 ){_aeeac ._fgdg =_fage ;if _aeeac .Style !=nil &&_aeeac .Style .StrokeWidth > 0{_aeeac .Style .StrokeWidth =_aeeac .Style .StrokeWidth *_aeeac ._fgdg ;
};for _ ,_bdfg :=range _aeeac .Children {_bdfg .setDefaultScaling (_fage );};};

// GenerateKDict generates a K dictionary for the drawable component.
func (_bdgf *taggedDrawable )GenerateKDict ()(*_cd .KDict ,error ){if _bdgf ._aefb ==nil {return nil ,_fab .New ("\u0073\u0074r\u0075\u0063\u0074\u0075\u0072\u0065\u0020\u0074\u0061\u0067\u0020\u0069\u006e\u0066\u006f\u0020\u0069\u0073\u0020\u006e\u006f\u0074 s\u0065\u0074");
};return _bdgf ._aefb .GenerateKDict (),nil ;};

// SetFillColor sets the fill color.
func (_gbg *CurvePolygon )SetFillColor (color Color ){_gbg ._aed =color ;_gbg ._cgbfg .FillColor =_acac (color );};

// SetFillColor sets background color for border.
func (_gag *border )SetFillColor (col Color ){_gag ._ggf =col };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_gagd *Creator )RotateDeg (angleDeg int64 )error {_gcaf :=_gagd .getActivePage ();if _gcaf ==nil {_fge .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _fab .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_fge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _fab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _eafa int64 ;if _gcaf .Rotate !=nil {_eafa =*(_gcaf .Rotate );};_eafa +=angleDeg ;_gcaf .Rotate =&_eafa ;return nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_ffffb *StyledParagraph )SetPos (x ,y float64 ){_ffffb ._cdaea =PositionAbsolute ;_ffffb ._beacb =x ;_ffffb ._decdca =y ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_fbdde *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebbde :=ctx ;var _fgadd []*Block ;_gbgega :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fbdde ._cdaea .IsRelative (){ctx .X +=_fbdde ._acgdg .Left ;
ctx .Y +=_fbdde ._acgdg .Top ;ctx .Width -=_fbdde ._acgdg .Left +_fbdde ._acgdg .Right ;ctx .Height -=_fbdde ._acgdg .Top ;_fbdde .SetWidth (ctx .Width );}else {if int (_fbdde ._fcced )<=0{_fbdde .SetWidth (_fbdde .getTextWidth ()/1000.0);};ctx .X =_fbdde ._beacb ;
ctx .Y =_fbdde ._decdca ;};if _fbdde ._beab !=nil {_fbdde ._beab (_fbdde ,ctx );};if _bbcc :=_fbdde .wrapText ();_bbcc !=nil {return nil ,ctx ,_bbcc ;};_ffdad :=_fbdde ._adcf ;_gcbaf :=0;for {_ggbea ,_daff ,_gbda :=_fbdf (_gbgega ,_fbdde ,_ffdad ,ctx );
if _gbda !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbda );return nil ,ctx ,_gbda ;};ctx =_ggbea ;_fgadd =append (_fgadd ,_gbgega );if _ffdad =_daff ;len (_daff )==0{break ;};if len (_daff )==_gcbaf {return nil ,ctx ,_fab .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_gbgega =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ggbea =ctx ;_ggbea .Y =ctx .Margins .Top ;_ggbea .X =ctx .Margins .Left +_fbdde ._acgdg .Left ;_ggbea .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_ggbea .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fbdde ._acgdg .Left -_fbdde ._acgdg .Right ;
ctx =_ggbea ;_gcbaf =len (_daff );};if _fbdde ._cdaea .IsRelative (){ctx .Y +=_fbdde ._acgdg .Bottom ;ctx .Height -=_fbdde ._acgdg .Bottom ;if !ctx .Inline {ctx .X =_ebbde .X ;ctx .Width =_ebbde .Width ;};return _fgadd ,ctx ,nil ;};return _fgadd ,_ebbde ,nil ;
};

// SetBorderOpacity sets the border opacity.
func (_ceed *Polygon )SetBorderOpacity (opacity float64 ){_ceed ._fdbe =opacity };

// Height returns the height of the chart.
func (_caaf *Chart )Height ()float64 {return float64 (_caaf ._ggab .Height ())};

// SetWidthTop sets border width for top.
func (_afda *border )SetWidthTop (bw float64 ){_afda ._beb =bw };func _cdgfe (_bdgec *templateProcessor ,_dgdgc *templateNode )(interface{},error ){return _bdgec .parseDivision (_dgdgc );};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default, it occupies the available width in the drawing context.
//
// Deprecated: This object is deprecated and will be removed in future versions.
//
// Use StyledParagraph instead as it provides more features and is more flexible.
type Paragraph struct{taggedDrawable ;_egda string ;_gcfa *_cd .PdfFont ;_dgdde float64 ;_fbdcb float64 ;_fdae Color ;_aegb TextAlignment ;_fabc bool ;_efbe float64 ;_dgbg int ;_bdag bool ;_ebfdg float64 ;_dcfd Margins ;_bgcg Positioning ;_dbed float64 ;
_bdgeg float64 ;_dafa ,_abgdf float64 ;_dcfdd []string ;_fegef string ;};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_ffdf *Rectangle )BorderOpacity ()float64 {return _ffdf ._cbfae };func _dbac (_bfadg ...interface{})[]interface{}{return _bfadg };const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;
);func _acac (_cebg Color )_cd .PdfColor {if _cebg ==nil {_cebg =ColorBlack ;};switch _agef :=_cebg .(type ){case grayColor :return _cd .NewPdfColorDeviceGray (_agef ._adae );case cmykColor :return _cd .NewPdfColorDeviceCMYK (_agef ._daee ,_agef ._faab ,_agef ._afde ,_agef ._daeec );
case *LinearShading :return _cd .NewPdfColorPatternType2 ();case *RadialShading :return _cd .NewPdfColorPatternType3 ();};return _cd .NewPdfColorDeviceRGB (_cebg .ToRGB ());};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_adbdg *Grid )SetColumnWidths (widths ...float64 )error {if len (widths )!=_adbdg ._abgd {_fge .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _fab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adbdg ._gded =widths ;return nil ;};

// SetBorderColor sets the cell's border color.
func (_bagc *GridCell )SetBorderColor (col Color ){_bagc ._bbcda =col ;_bagc ._feaeg =col ;_bagc ._cfbg =col ;_bagc ._eeada =col ;};func (_dffea *StyledParagraph )createAccessibleLinkChunk (_becb string ,_gdaf *_cd .PdfAnnotation ,_ccadg LinkTagOptions )(*TextChunk ,*_cd .KDict ,error ){var _gffc *_cd .KDict ;
_dadbe :=NewTextChunk (_becb ,_dffea ._adfa );_dadbe .AddAnnotation (_gdaf );if _ccadg .MCID > 0{_dadbe .SetMarkedContentID (_ccadg .MCID );_dadbe .SetStructureType (_cd .StructureTypeLink );if _ccadg .AltText !=""&&_ccadg .AltText !=_becb {_dadbe .SetAltText (_ccadg .AltText );
};_dadbe .AssociateAnnotationWithStructure (_gdaf );_fbcbb ,_ecbcf :=_dadbe .GenerateKDict ();if _ecbcf !=nil {return nil ,nil ,_a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020t\u006f\u0020\u0067e\u006e\u0065\u0072\u0061t\u0065\u0020\u004b\u0044\u0069\u0063\u0074\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u006e\u006b\u0020\u0063\u0068\u0075\u006e\u006b\u003a\u0020\u0025\u0076",_ecbcf );
};if _ccadg .AltText !=""&&_ccadg .AltText !=_becb {_fbcbb .Alt =_cdf .MakeString (_ccadg .AltText );};_gffc =_fbcbb ;};_dffea .appendChunk (_dadbe );return _dadbe ,_gffc ,nil ;};

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_abe *border )SetStructPageNumber (pageNumber *int64 ){};

// TOC returns the table of contents component of the creator.
func (_cgab *Creator )TOC ()*TOC {return _cgab ._gege };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_cgeac *Table )NewCell ()*TableCell {return _cgeac .MultiCell (1,1)};func (_aece *Table )wrapRow (_bfce int ,_fgabc DrawContext ,_afddc float64 )(bool ,error ){if !_aece ._gefgf {return false ,nil ;};var (_gceab =_aece ._dfcec [_bfce ];_gcbd =-1;
_efcea []*TableCell ;_eebe float64 ;_ffdfb bool ;_dbbea =make ([]float64 ,0,len (_aece ._fefea )););_efdbe :=func (_afadb *TableCell ,_bbed VectorDrawable ,_edgbb bool )*TableCell {_cbgea :=*_afadb ;_cbgea ._effe =_bbed ;if _edgbb {_cbgea ._cfdga ++;};
return &_cbgea ;};_aggc :=func (_ecdg int ,_ageef VectorDrawable ){var _bfecc float64 =-1;if _ageef ==nil {if _cdafd :=_dbbea [_ecdg -_bfce ];_cdafd > _fgabc .Height {_ageef =_aece ._dfcec [_ecdg ]._effe ;_aece ._dfcec [_ecdg ]._effe =nil ;_dbbea [_ecdg -_bfce ]=0;
_bfecc =_cdafd ;};};_eeeea :=_efdbe (_aece ._dfcec [_ecdg ],_ageef ,true );_efcea =append (_efcea ,_eeeea );if _bfecc < 0{_bfecc =_eeeea .height (_fgabc .Width );};if _bfecc > _eebe {_eebe =_bfecc ;};};for _gdbab :=_bfce ;_gdbab < len (_aece ._dfcec );
_gdbab ++{_bccba :=_aece ._dfcec [_gdbab ];if _gceab ._cfdga !=_bccba ._cfdga {_gcbd =_gdbab ;break ;};_fgabc .Width =_bccba .width (_aece ._fefea ,_afddc );_egge :=_bccba .height (_fgabc .Width );var _ebfg VectorDrawable ;switch _dbaac :=_bccba ._effe .(type ){case *StyledParagraph :if _egge > _fgabc .Height {_afgd :=_fgabc ;
_afgd .Height =_bd .Floor (_fgabc .Height -_dbaac ._acgdg .Top -_dbaac ._acgdg .Bottom -0.5*_dbaac .getTextHeight ());_fbga ,_eggec ,_bcegb :=_dbaac .split (_afgd );if _bcegb !=nil {return false ,_bcegb ;};if _fbga !=nil &&_eggec !=nil {_dbaac =_fbga ;
_bccba =_efdbe (_bccba ,_fbga ,false );_aece ._dfcec [_gdbab ]=_bccba ;_ebfg =_eggec ;_ffdfb =true ;};_egge =_bccba .height (_fgabc .Width );};case *Division :if _egge > _fgabc .Height {_gfbc :=_fgabc ;_gfbc .Height =_bd .Floor (_fgabc .Height -_dbaac ._gadc .Top -_dbaac ._gadc .Bottom );
_gfdb ,_fgeb :=_dbaac .split (_gfbc );if _gfdb !=nil &&_fgeb !=nil {_dbaac =_gfdb ;_bccba =_efdbe (_bccba ,_gfdb ,false );_aece ._dfcec [_gdbab ]=_bccba ;_ebfg =_fgeb ;_ffdfb =true ;if _gfdb ._aebdf !=nil {_gfdb ._aebdf .BorderRadiusBottomLeft =0;_gfdb ._aebdf .BorderRadiusBottomRight =0;
};if _fgeb ._aebdf !=nil {_fgeb ._aebdf .BorderRadiusTopLeft =0;_fgeb ._aebdf .BorderRadiusTopRight =0;};_egge =_bccba .height (_fgabc .Width );};};case *List :if _egge > _fgabc .Height {_fgade :=_fgabc ;_fgade .Height =_bd .Floor (_fgabc .Height -_dbaac ._bcefc .Vertical ());
_eeag ,_fdaf :=_dbaac .split (_fgade );if _eeag !=nil {_dbaac =_eeag ;_bccba =_efdbe (_bccba ,_eeag ,false );_aece ._dfcec [_gdbab ]=_bccba ;};if _fdaf !=nil {_ebfg =_fdaf ;_ffdfb =true ;};_egge =_bccba .height (_fgabc .Width );};};_dbbea =append (_dbbea ,_egge );
if _ffdfb {if _efcea ==nil {_efcea =make ([]*TableCell ,0,len (_aece ._fefea ));for _acbb :=_bfce ;_acbb < _gdbab ;_acbb ++{_aggc (_acbb ,nil );};};_aggc (_gdbab ,_ebfg );};};var _eddf float64 ;for _ ,_abfd :=range _dbbea {if _abfd > _eddf {_eddf =_abfd ;
};};if _ffdfb &&_eddf < _fgabc .Height {if _gcbd < 0{_gcbd =len (_aece ._dfcec );};_bdaf :=_aece ._dfcec [_gcbd -1]._cfdga +_aece ._dfcec [_gcbd -1]._aecg -1;for _fgccg :=_gcbd ;_fgccg < len (_aece ._dfcec );_fgccg ++{_aece ._dfcec [_fgccg ]._cfdga ++;
};_aece ._dfcec =append (_aece ._dfcec [:_gcbd ],append (_efcea ,_aece ._dfcec [_gcbd :]...)...);_aece ._fgege =append (_aece ._fgege [:_bdaf ],append ([]float64 {_eebe },_aece ._fgege [_bdaf :]...)...);_aece ._fgege [_gceab ._cfdga +_gceab ._aecg -2]=_eddf ;
};return _ffdfb ,nil ;};func (_fdcab *templateProcessor )parseListMarker (_gccff *templateNode )(interface{},error ){if _gccff ._fbddd ==nil {_fdcab .nodeLogError (_gccff ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_egfg ;};var _ccde *TextChunk ;switch _gaafc :=_gccff ._fbddd ._bcacc .(type ){case *List :_ccde =&_gaafc ._fccc ;case *listItem :_ccde =&_gaafc ._ceaga ;default:_fdcab .nodeLogError (_gccff ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_gaafc );
return nil ,_egfg ;};if _ ,_ffbed :=_fdcab .parseTextChunk (_gccff ,_ccde );_ffbed !=nil {_fdcab .nodeLogError (_gccff ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_ffbed );
return nil ,nil ;};return _ccde ,nil ;};func _dgdda (_edcfd TextStyle )*StyledParagraph {return &StyledParagraph {_bcebd :[]*TextChunk {},_eeac :_edcfd ,_adfa :_bafc (_edcfd .Font ),_dgbeg :1.0,_dffe :TextAlignmentLeft ,_bccfb :true ,_agcga :true ,_bgeb :false ,_cebgb :0,_afefc :1,_deba :1,_cdaea :PositionRelative ,_cdeb :"",_deafc :nil ,taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeParagraph }};
};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_afcgb *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_dcdg :=&_afcgb ._gbbaf ._acgdg ;return _afcgb ._ecece ,_dcdg .Right ,_dcdg .Top ,_dcdg .Bottom ;};func (_bdca *Block )transform (_cgg _cf .Matrix ){_ee :=_fgc .NewContentCreator ().Add_cm (_cgg [0],_cgg [1],_cgg [3],_cgg [4],_cgg [6],_cgg [7]).Operations ();
*_bdca ._fc =append (*_ee ,*_bdca ._fc ...);_bdca ._fc .WrapIfNeeded ();};func (_ad *Block )addWrappedContents (_fdb *_fgc .ContentStreamOperations ){_ad ._fc .WrapIfNeeded ();_fdb .WrapIfNeeded ();*_ad ._fc =append (*_ad ._fc ,*_fdb ...);};

// NewInvoice returns an instance of an empty invoice.
func (_dedc *Creator )NewInvoice ()*Invoice {_eegc :=_dedc .NewTextStyle ();_eegc .Font =_dedc ._aefg ;return _ccga (_dedc .NewTextStyle (),_eegc );};

// GeneratePageBlocks implements drawable interface.
func (_acce *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfff :=_acce ._gae ;_caff :=ctx .PageHeight -_acce ._acc ;if _acce ._ggf !=nil {_fabfd :=_ggb .Rectangle {Opacity :1.0,X :_acce ._gae ,Y :ctx .PageHeight -_acce ._acc -_acce ._ddf ,Height :_acce ._ddf ,Width :_acce ._degf };
_fabfd .FillEnabled =true ;_eadd :=_acac (_acce ._ggf );_ebdd :=_dbdga (_fce ,_eadd ,_acce ._ggf ,func ()Rectangle {return Rectangle {_bdcc :_fabfd .X ,_dbgd :_fabfd .Y ,_bfed :_fabfd .Width ,_abdcf :_fabfd .Height };});if _ebdd !=nil {return nil ,ctx ,_ebdd ;
};_fabfd .FillColor =_eadd ;_fabfd .BorderEnabled =false ;_ecfe :="";if _acce ._fccfa < 1{_ddg :=_cdf .MakeDict ();_ddg .Set ("\u0063\u0061",_cdf .MakeFloat (_acce ._fccfa ));_ddg .Set ("\u0043\u0041",_cdf .MakeFloat (_acce ._fccfa ));_agfg :=_fce ._gaa .AddExtGState ("\u0067\u0073\u0031",_ddg );
if _agfg ==nil {_ecfe ="\u0067\u0073\u0031";};};_edb ,_ ,_ebdd :=_fabfd .Draw (_ecfe );if _ebdd !=nil {return nil ,ctx ,_ebdd ;};_ebdd =_fce .addContentsByString (string (_edb ));if _ebdd !=nil {return nil ,ctx ,_ebdd ;};};_gaab :=_acce ._beb ;_babb :=_acce ._bbf ;
_dbf :=_acce ._gbdg ;_ccf :=_acce ._bbff ;_dda :=_acce ._beb ;if _acce ._dbda ==CellBorderStyleDouble {_dda +=2*_gaab ;};_caed :=_acce ._bbf ;if _acce ._cff ==CellBorderStyleDouble {_caed +=2*_babb ;};_ada :=_acce ._gbdg ;if _acce ._bffb ==CellBorderStyleDouble {_ada +=2*_dbf ;
};_fegd :=_acce ._bbff ;if _acce ._bdf ==CellBorderStyleDouble {_fegd +=2*_ccf ;};_aee :=(_dda -_ada )/2;_cbg :=(_dda -_fegd )/2;_decg :=(_caed -_ada )/2;_ecc :=(_caed -_fegd )/2;if _acce ._beb !=0{_gdc :=_dfff ;_gaaf :=_caff ;if _acce ._dbda ==CellBorderStyleDouble {_gaaf -=_gaab ;
_fgg :=_ggb .BasicLine {LineColor :_acac (_acce ._afd ),Opacity :1.0,LineWidth :_acce ._beb ,LineStyle :_acce .LineStyle ,X1 :_gdc -_dda /2+_aee ,Y1 :_gaaf +2*_gaab ,X2 :_gdc +_dda /2-_cbg +_acce ._degf ,Y2 :_gaaf +2*_gaab };_ddeg ,_ ,_gcea :=_fgg .Draw ("");
if _gcea !=nil {return nil ,ctx ,_gcea ;};_gcea =_fce .addContentsByString (string (_ddeg ));if _gcea !=nil {return nil ,ctx ,_gcea ;};};_caffc :=_ggb .BasicLine {LineWidth :_acce ._beb ,Opacity :1.0,LineColor :_acac (_acce ._afd ),LineStyle :_acce .LineStyle ,X1 :_gdc -_dda /2+_aee +(_ada -_acce ._gbdg ),Y1 :_gaaf ,X2 :_gdc +_dda /2-_cbg +_acce ._degf -(_fegd -_acce ._bbff ),Y2 :_gaaf };
_ece ,_ ,_bbae :=_caffc .Draw ("");if _bbae !=nil {return nil ,ctx ,_bbae ;};_bbae =_fce .addContentsByString (string (_ece ));if _bbae !=nil {return nil ,ctx ,_bbae ;};};if _acce ._bbf !=0{_ecd :=_dfff ;_gafb :=_caff -_acce ._ddf ;if _acce ._cff ==CellBorderStyleDouble {_gafb +=_babb ;
_ggd :=_ggb .BasicLine {LineWidth :_acce ._bbf ,Opacity :1.0,LineColor :_acac (_acce ._aagb ),LineStyle :_acce .LineStyle ,X1 :_ecd -_caed /2+_decg ,Y1 :_gafb -2*_babb ,X2 :_ecd +_caed /2-_ecc +_acce ._degf ,Y2 :_gafb -2*_babb };_faea ,_ ,_faa :=_ggd .Draw ("");
if _faa !=nil {return nil ,ctx ,_faa ;};_faa =_fce .addContentsByString (string (_faea ));if _faa !=nil {return nil ,ctx ,_faa ;};};_bac :=_ggb .BasicLine {LineWidth :_acce ._bbf ,Opacity :1.0,LineColor :_acac (_acce ._aagb ),LineStyle :_acce .LineStyle ,X1 :_ecd -_caed /2+_decg +(_ada -_acce ._gbdg ),Y1 :_gafb ,X2 :_ecd +_caed /2-_ecc +_acce ._degf -(_fegd -_acce ._bbff ),Y2 :_gafb };
_gcef ,_ ,_bced :=_bac .Draw ("");if _bced !=nil {return nil ,ctx ,_bced ;};_bced =_fce .addContentsByString (string (_gcef ));if _bced !=nil {return nil ,ctx ,_bced ;};};if _acce ._gbdg !=0{_dfa :=_dfff ;_dfg :=_caff ;if _acce ._bffb ==CellBorderStyleDouble {_dfa +=_dbf ;
_fea :=_ggb .BasicLine {LineWidth :_acce ._gbdg ,Opacity :1.0,LineColor :_acac (_acce ._dfc ),LineStyle :_acce .LineStyle ,X1 :_dfa -2*_dbf ,Y1 :_dfg +_ada /2+_aee ,X2 :_dfa -2*_dbf ,Y2 :_dfg -_ada /2-_decg -_acce ._ddf };_adc ,_ ,_fdad :=_fea .Draw ("");
if _fdad !=nil {return nil ,ctx ,_fdad ;};_fdad =_fce .addContentsByString (string (_adc ));if _fdad !=nil {return nil ,ctx ,_fdad ;};};_afdb :=_ggb .BasicLine {LineWidth :_acce ._gbdg ,Opacity :1.0,LineColor :_acac (_acce ._dfc ),LineStyle :_acce .LineStyle ,X1 :_dfa ,Y1 :_dfg +_ada /2+_aee -(_dda -_acce ._beb ),X2 :_dfa ,Y2 :_dfg -_ada /2-_decg -_acce ._ddf +(_caed -_acce ._bbf )};
_gbad ,_ ,_gafg :=_afdb .Draw ("");if _gafg !=nil {return nil ,ctx ,_gafg ;};_gafg =_fce .addContentsByString (string (_gbad ));if _gafg !=nil {return nil ,ctx ,_gafg ;};};if _acce ._bbff !=0{_cgdd :=_dfff +_acce ._degf ;_bcb :=_caff ;if _acce ._bdf ==CellBorderStyleDouble {_cgdd -=_ccf ;
_faaa :=_ggb .BasicLine {LineWidth :_acce ._bbff ,Opacity :1.0,LineColor :_acac (_acce ._gfef ),LineStyle :_acce .LineStyle ,X1 :_cgdd +2*_ccf ,Y1 :_bcb +_fegd /2+_cbg ,X2 :_cgdd +2*_ccf ,Y2 :_bcb -_fegd /2-_ecc -_acce ._ddf };_gda ,_ ,_abbf :=_faaa .Draw ("");
if _abbf !=nil {return nil ,ctx ,_abbf ;};_abbf =_fce .addContentsByString (string (_gda ));if _abbf !=nil {return nil ,ctx ,_abbf ;};};_bdg :=_ggb .BasicLine {LineWidth :_acce ._bbff ,Opacity :1.0,LineColor :_acac (_acce ._gfef ),LineStyle :_acce .LineStyle ,X1 :_cgdd ,Y1 :_bcb +_fegd /2+_cbg -(_dda -_acce ._beb ),X2 :_cgdd ,Y2 :_bcb -_fegd /2-_ecc -_acce ._ddf +(_caed -_acce ._bbf )};
_bccf ,_ ,_bbca :=_bdg .Draw ("");if _bbca !=nil {return nil ,ctx ,_bbca ;};_bbca =_fce .addContentsByString (string (_bccf ));if _bbca !=nil {return nil ,ctx ,_bbca ;};};return []*Block {_fce },ctx ,nil ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_ggad *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fbgb []*Block ;_dgad bool ;_gafd error ;_bbaec =_ggad ._fege .IsRelative ();_fbdgg =_ggad ._gadc .Top ;);if _bbaec &&!_ggad ._agaad &&!_ggad ._abdc {_adec :=_ggad .ctxHeight (ctx .Width );
if _adec > ctx .Height -_ggad ._gadc .Top &&_adec <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _fbgb ,ctx ,_gafd =_acga ().GeneratePageBlocks (ctx );_gafd !=nil {return nil ,ctx ,_gafd ;};_dgad =true ;_fbdgg =0;};};_faage :=ctx ;_cbdda :=ctx ;
if _bbaec {ctx .X +=_ggad ._gadc .Left ;ctx .Y +=_fbdgg ;ctx .Width -=_ggad ._gadc .Left +_ggad ._gadc .Right ;ctx .Height -=_fbdgg ;_cbdda =ctx ;ctx .X +=_ggad ._egcf .Left ;ctx .Y +=_ggad ._egcf .Top ;ctx .Width -=_ggad ._egcf .Left +_ggad ._egcf .Right ;
ctx .Height -=_ggad ._egcf .Top ;ctx .Margins .Top +=_ggad ._egcf .Top ;ctx .Margins .Bottom +=_ggad ._egcf .Bottom ;ctx .Margins .Left +=_ggad ._gadc .Left +_ggad ._egcf .Left ;ctx .Margins .Right +=_ggad ._gadc .Right +_ggad ._egcf .Right ;};ctx .Inline =_ggad ._abdc ;
_agdd :=ctx ;_cada :=ctx ;var _bcgg float64 ;for _ ,_agag :=range _ggad ._decb {if ctx .Inline {if (ctx .X -_agdd .X )+_agag .Width ()<=ctx .Width {ctx .Y =_cada .Y ;ctx .Height =_cada .Height ;}else {ctx .X =_agdd .X ;ctx .Width =_agdd .Width ;_cada .Y +=_bcgg ;
_cada .Height -=_bcgg ;_bcgg =0;};};_cbb ,_fbed ,_aafd :=_agag .GeneratePageBlocks (ctx );if _aafd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_aafd );
return nil ,ctx ,_aafd ;};if len (_cbb )< 1{continue ;};if len (_fbgb )> 0{_fbgb [len (_fbgb )-1].mergeBlocks (_cbb [0]);_fbgb =append (_fbgb ,_cbb [1:]...);}else {if _ddegd :=_cbb [0]._fc ;_ddegd ==nil ||len (*_ddegd )==0{_dgad =true ;};_fbgb =append (_fbgb ,_cbb [0:]...);
};_efec :=0.0;switch _ccacf :=_agag .(type ){case *Paragraph :_efec =(0.5*_ccacf ._dgdde *_ccacf ._fbdcb );case *StyledParagraph :_efec =(0.5*_ccacf .getTextHeight ());};_fbed .Y +=_efec ;_fbed .Height -=_efec ;if ctx .Inline {if ctx .Page !=_fbed .Page {_agdd .Y =ctx .Margins .Top ;
_agdd .Height =ctx .PageHeight -ctx .Margins .Top ;_cada .Y =_agdd .Y ;_cada .Height =_agdd .Height ;_bcgg =_fbed .Height -_agdd .Height ;}else {if _cgebf :=ctx .Height -_fbed .Height ;_cgebf > _bcgg {_bcgg =_cgebf ;};};}else {_fbed .X =ctx .X ;};ctx =_fbed ;
};if len (_ggad ._decb )==0{_ecde :=NewBlock (ctx .Width ,0);_fbgb =append (_fbgb ,_ecde );};ctx .Inline =_faage .Inline ;ctx .Margins =_faage .Margins ;if _bbaec {ctx .X =_faage .X ;ctx .Width =_faage .Width ;ctx .Y +=_ggad ._egcf .Bottom ;ctx .Height -=_ggad ._egcf .Bottom ;
};if _ggad ._aebdf !=nil {_fbgb ,_gafd =_ggad .drawBackground (_fbgb ,_cbdda ,ctx ,_dgad );if _gafd !=nil {return nil ,ctx ,_gafd ;};};if _ggad ._fege .IsAbsolute (){return _fbgb ,_faage ,nil ;};ctx .Y +=_ggad ._gadc .Bottom ;ctx .Height -=_ggad ._gadc .Bottom ;
return _fbgb ,ctx ,nil ;};const (_afg =0.72;_bade =28.3464;_abg =_bade /10;_dddf =0.551784;_aecd =96;_adga =16.0;);

// SetBorderWidth sets the border width.
func (_bbad *CurvePolygon )SetBorderWidth (borderWidth float64 ){_bbad ._cgbfg .BorderWidth =borderWidth ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;
);func (_deeb *GraphicSVGElement )drawCircle (_bafe *_fgc .ContentCreator ,_fbdff *_cd .PdfPageResources ){_bafe .Add_q ();_deeb .Style .toContentStream (_bafe ,_fbdff ,_deeb );_bfebc ,_fdefg :=_gfgbeb (_deeb .Attributes ["\u0063\u0078"],64);if _fdefg !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fdefg .Error ());
};_fgbdc ,_fdefg :=_gfgbeb (_deeb .Attributes ["\u0063\u0079"],64);if _fdefg !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fdefg .Error ());
};_faggb ,_fdefg :=_gfgbeb (_deeb .Attributes ["\u0072"],64);if _fdefg !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0072\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_fdefg .Error ());
};_gcbfc :=_faggb *_deeb ._fgdg ;_bfbfc :=_faggb *_deeb ._fgdg ;_acddf :=_gcbfc *_dddf ;_acdg :=_bfbfc *_dddf ;_cgfbb :=_ggb .NewCubicBezierPath ();_cgfbb =_cgfbb .AppendCurve (_ggb .NewCubicBezierCurve (-_gcbfc ,0,-_gcbfc ,_acdg ,-_acddf ,_bfbfc ,0,_bfbfc ));
_cgfbb =_cgfbb .AppendCurve (_ggb .NewCubicBezierCurve (0,_bfbfc ,_acddf ,_bfbfc ,_gcbfc ,_acdg ,_gcbfc ,0));_cgfbb =_cgfbb .AppendCurve (_ggb .NewCubicBezierCurve (_gcbfc ,0,_gcbfc ,-_acdg ,_acddf ,-_bfbfc ,0,-_bfbfc ));_cgfbb =_cgfbb .AppendCurve (_ggb .NewCubicBezierCurve (0,-_bfbfc ,-_acddf ,-_bfbfc ,-_gcbfc ,-_acdg ,-_gcbfc ,0));
_cgfbb =_cgfbb .Offset (_bfebc *_deeb ._fgdg ,_fgbdc *_deeb ._fgdg );if _deeb .Style .StrokeWidth > 0{_cgfbb =_cgfbb .Offset (_deeb .Style .StrokeWidth /2,_deeb .Style .StrokeWidth /2);};_ggb .DrawBezierPathWithCreator (_cgfbb ,_bafe );_deeb .Style .fillStroke (_bafe );
_bafe .Add_h ();_bafe .Add_Q ();};func _fddb (_fegc ,_aacdf ,_decdc ,_cfag float64 )*Rectangle {return &Rectangle {_bdcc :_fegc ,_dbgd :_aacdf ,_bfed :_decdc ,_abdcf :_cfag ,_afbe :PositionAbsolute ,_abbd :1.0,_feedc :ColorBlack ,_effb :1.0,_cbfae :1.0};
};

// SetColorTop sets border color for top.
func (_adg *border )SetColorTop (col Color ){_adg ._afd =col };

// Rows returns the total number of rows the table has.
func (_eebcc *Table )Rows ()int {return _eebcc ._ecga };func (_faeaa *TableCell )cloneProps (_dcbba VectorDrawable )*TableCell {_fgeae :=*_faeaa ;_fgeae ._effe =_dcbba ;return &_fgeae ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_edcc *TableCell )SetContent (vd VectorDrawable )error {switch _bffaac :=vd .(type ){case *Paragraph :if _bffaac ._bdag {_bffaac ._fabc =true ;};_edcc ._effe =vd ;case *StyledParagraph :if _bffaac ._agcga {_bffaac ._bccfb =true ;};_edcc ._effe =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_edcc ._effe =vd ;default:_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _cdf .ErrTypeError ;};return nil ;};

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_beecd *List )Add (item VectorDrawable )(*TextChunk ,error ){_bgaaa :=&listItem {_gdcgce :item ,_ceaga :_beecd ._fccc };switch _dgdaa :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _dgdaa ._efab {_dgdaa ._bdge =15;};case *Division :case *Image :case *Table :default:return nil ,_fab .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_beecd ._gecb =append (_beecd ._gecb ,_bgaaa );return &_bgaaa ._ceaga ,nil ;};func (_bfef *LinearShading )shadingModel ()*_cd .PdfShadingType2 {_eafada :=_ggb .NewPoint (_bfef ._gbgeb .Llx +_bfef ._gbgeb .Width ()/2,_bfef ._gbgeb .Lly +_bfef ._gbgeb .Height ()/2);
_ebbe :=_ggb .NewPoint (_bfef ._gbgeb .Llx ,_bfef ._gbgeb .Lly +_bfef ._gbgeb .Height ()/2).Add (-_eafada .X ,-_eafada .Y ).Rotate (_bfef ._bffe ).Add (_eafada .X ,_eafada .Y );_ebbe =_ggb .NewPoint (_bd .Max (_bd .Min (_ebbe .X ,_bfef ._gbgeb .Urx ),_bfef ._gbgeb .Llx ),_bd .Max (_bd .Min (_ebbe .Y ,_bfef ._gbgeb .Ury ),_bfef ._gbgeb .Lly ));
_bcedgf :=_ggb .NewPoint (_bfef ._gbgeb .Urx ,_bfef ._gbgeb .Lly +_bfef ._gbgeb .Height ()/2).Add (-_eafada .X ,-_eafada .Y ).Rotate (_bfef ._bffe ).Add (_eafada .X ,_eafada .Y );_bcedgf =_ggb .NewPoint (_bd .Min (_bd .Max (_bcedgf .X ,_bfef ._gbgeb .Llx ),_bfef ._gbgeb .Urx ),_bd .Min (_bd .Max (_bcedgf .Y ,_bfef ._gbgeb .Lly ),_bfef ._gbgeb .Ury ));
_bcaab :=_cd .NewPdfShadingType2 ();_bcaab .ShadingType =_cdf .MakeInteger (2);_bcaab .ColorSpace =_cd .NewPdfColorspaceDeviceRGB ();_bcaab .AntiAlias =_cdf .MakeBool (_bfef ._bedba ._ggfe );_bcaab .Coords =_cdf .MakeArrayFromFloats ([]float64 {_ebbe .X ,_ebbe .Y ,_bcedgf .X ,_bcedgf .Y });
_bcaab .Extend =_cdf .MakeArray (_cdf .MakeBool (_bfef ._bedba ._fcce [0]),_cdf .MakeBool (_bfef ._bedba ._fcce [1]));_bcaab .Function =_bfef ._bedba .generatePdfFunctions ();return _bcaab ;};func _gdgcc (_efbac string )(_fbfd ,_cgcab string ){if _efbac ==""||(_efbac [len (_efbac )-1]>='0'&&_efbac [len (_efbac )-1]<='9'){return _efbac ,"";
};_fbfd =_efbac ;for _ ,_fccfc :=range _abefb {if _gg .Contains (_fbfd ,_fccfc ){_cgcab =_fccfc ;};_fbfd =_gg .TrimSuffix (_fbfd ,_fccfc );};return ;};func (_bgdc *Paragraph )wrapText ()error {if !_bgdc ._fabc ||int (_bgdc ._efbe )<=0{_bgdc ._dcfdd =[]string {_bgdc ._egda };
return nil ;};_gbgef :=NewTextChunk (_bgdc ._egda ,TextStyle {Font :_bgdc ._gcfa ,FontSize :_bgdc ._dgdde });_edce ,_fecf :=_gbgef .Wrap (_bgdc ._efbe );if _fecf !=nil {return _fecf ;};if _bgdc ._dgbg > 0&&len (_edce )> _bgdc ._dgbg {_edce =_edce [:_bgdc ._dgbg ];
};_bgdc ._dcfdd =_edce ;return nil ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_cfadf *Paragraph )SetColor (col Color ){_cfadf ._fdae =col };func (_fdaa *List )split (_ebabab DrawContext )(_ffbd ,_cfef *List ){var (_bfbf float64 ;_bdacd ,_dfdd []*listItem ;);_decc :=_ebabab .Width -_fdaa ._bcefc .Horizontal ()-_fdaa ._bdge -_fdaa .markerWidth ();
_bfdf :=_fdaa .markerWidth ();for _geded ,_ecdb :=range _fdaa ._gecb {_ddaa :=_ecdb .ctxHeight (_decc );_bfbf +=_ddaa ;if _bfbf <=_ebabab .Height {_bdacd =append (_bdacd ,_ecdb );}else {switch _fccba :=_ecdb ._gdcgce .(type ){case *List :_cbcb :=_ebabab ;
_cbcb .Height =_bd .Floor (_ddaa -(_bfbf -_ebabab .Height ));_fcgf ,_facfg :=_fccba .split (_cbcb );if _fcgf !=nil {_ccbc :=_cccd ();_ccbc ._ceaga =_ecdb ._ceaga ;_ccbc ._gdcgce =_fcgf ;_bdacd =append (_bdacd ,_ccbc );};if _facfg !=nil {_bcec :=_fccba ._fccc .Style .FontSize ;
_gaeg ,_bage :=_fccba ._fccc .Style .Font .GetRuneMetrics (' ');if _bage {_bcec =_fccba ._fccc .Style .FontSize *_gaeg .Wx *_fccba ._fccc .Style .horizontalScale ()/1000.0;};_bdbaa :=_gg .Repeat ("\u0020",int (_bfdf /_bcec ));_cgcg :=_cccd ();_cgcg ._ceaga =*NewTextChunk (_bdbaa ,_fccba ._fccc .Style );
_cgcg ._gdcgce =_facfg ;_dfdd =append (_dfdd ,_cgcg );_dfdd =append (_dfdd ,_fdaa ._gecb [_geded +1:]...);};default:_dfdd =_fdaa ._gecb [_geded :];};if len (_dfdd )> 0{break ;};};};if len (_bdacd )> 0{_ffbd =_abfg (_fdaa ._cedde );*_ffbd =*_fdaa ;_ffbd ._gecb =_bdacd ;
};if len (_dfdd )> 0{_cfef =_abfg (_fdaa ._cedde );*_cfef =*_fdaa ;_cfef ._gecb =_dfdd ;};return _ffbd ,_cfef ;};func (_adaff *StyledParagraph )getTextWidth ()float64 {var _dgfgc float64 ;_gdgda :=len (_adaff ._bcebd );for _dfce ,_acdag :=range _adaff ._bcebd {_dbeg :=&_acdag .Style ;
_bbfa :=len (_acdag .Text );for _acba ,_abgg :=range _acdag .Text {if _abgg =='\u000A'{continue ;};_fgcga ,_bfffb :=_dbeg .Font .GetRuneMetrics (_abgg );if !_bfffb {_fge .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_abgg );
return -1;};_dgfgc +=_dbeg .FontSize *_fgcga .Wx *_dbeg .horizontalScale ();if _abgg !=' '&&(_dfce !=_gdgda -1||_acba !=_bbfa -1){_dgfgc +=_dbeg .CharSpacing *1000.0;};};};return _dgfgc ;};

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_gbgde *PageBreak )SetMarkedContentID (id int64 ){};

// SetFillColor sets the fill color for the path.
func (_dbcb *FilledCurve )SetFillColor (color Color ){_dbcb ._feaf =color };

// SetBorderRadius sets the radius of the rectangle corners.
func (_dagea *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_dagea ._cedf =topLeft ;_dagea ._ebaa =topRight ;_dagea ._bdgee =bottomLeft ;_dagea ._geeg =bottomRight ;};

// SetFillOpacity sets the fill opacity.
func (_agbc *CurvePolygon )SetFillOpacity (opacity float64 ){_agbc ._ddca =opacity };

// NewTOC creates a new table of contents.
func (_ged *Creator )NewTOC (title string )*TOC {_bbfb :=_ged .NewTextStyle ();_bbfb .Font =_ged ._aefg ;return _faaaf (title ,_ged .NewTextStyle (),_bbfb );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cbba *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ecgb :=ctx ;_gbbg :=[]func (_bcedc DrawContext )([]*Block ,DrawContext ,error ){_cbba .generateHeaderBlocks ,_cbba .generateInformationBlocks ,_cbba .generateLineBlocks ,_cbba .generateTotalBlocks ,_cbba .generateNoteBlocks };
var _dged []*Block ;for _ ,_dafcf :=range _gbbg {_edbaf ,_gbea ,_bbeb :=_dafcf (ctx );if _bbeb !=nil {return _dged ,ctx ,_bbeb ;};if len (_dged )==0{_dged =_edbaf ;}else if len (_edbaf )> 0{_dged [len (_dged )-1].mergeBlocks (_edbaf [0]);_dged =append (_dged ,_edbaf [1:]...);
};ctx =_gbea ;};if _cbba ._dcgc .IsRelative (){ctx .X =_ecgb .X ;};if _cbba ._dcgc .IsAbsolute (){return _dged ,_ecgb ,nil ;};return _dged ,ctx ,nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{taggedDrawable ;_adbf float64 ;_gggg float64 ;_bgfbe float64 ;_ffaee float64 ;_dgc Positioning ;_beg Color ;_aadae float64 ;_ddfb Color ;_dffd float64 ;_bdfd float64 ;_ffdg Margins ;_aeae FitMode ;};func (_afaa *GraphicSVGElement )drawPolyline (_egeb *_fgc .ContentCreator ,_fdcba *_cd .PdfPageResources ){_egeb .Add_q ();
_afaa .Style .toContentStream (_egeb ,_fdcba ,_afaa );_afbbb ,_fedce :=_gaade (_afaa .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);if _fedce !=nil {_fge .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_fedce );
return ;};if len (_afbbb )%2> 0{_fge .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _dfec :=0;_dfec < len (_afbbb );{if _dfec ==0{_egeb .Add_m (_afbbb [_dfec ]*_afaa ._fgdg ,_afbbb [_dfec +1]*_afaa ._fgdg );}else {_egeb .Add_l (_afbbb [_dfec ]*_afaa ._fgdg ,_afbbb [_dfec +1]*_afaa ._fgdg );};_dfec +=2;};_afaa .Style .fillStroke (_egeb );
_egeb .Add_h ();_egeb .Add_Q ();};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ecad *Invoice )InfoLines ()[][2]*InvoiceCell {_debg :=[][2]*InvoiceCell {_ecad ._dcfg ,_ecad ._gega ,_ecad ._bbbc };return append (_debg ,_ecad ._bdgbg ...);};type GridRowSection int ;func (_fabea *StyledParagraph )getTextHeight ()float64 {var _eecd float64 ;
for _ ,_baaf :=range _fabea ._bcebd {_fgfc :=_baaf .Style .FontSize *_fabea ._dgbeg ;if _fgfc > _eecd {_eecd =_fgfc ;};};return _eecd ;};

// SetBorderColor sets the border color of the ellipse.
func (_ecae *Ellipse )SetBorderColor (col Color ){_ecae ._ddfb =col };

// SetBuyerAddress sets the buyer address of the invoice.
func (_fabde *Invoice )SetBuyerAddress (address *InvoiceAddress ){_fabde ._cabc =address };type rgbColor struct{_ecdce ,_baae ,_acaa float64 };

// SetWidth sets the width of the rectangle.
func (_dedbe *Rectangle )SetWidth (width float64 ){_dedbe ._bfed =width };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_deef *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddcdc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbff ,_fdeg :=_ddcdc .setOpacity (_deef ._edfe ,_deef ._eaecf );if _fdeg !=nil {return nil ,ctx ,_fdeg ;
};_bedb :=_deef ._fbac ;_bedb .FillEnabled =_bedb .FillColor !=nil ;var (_bgffd =ctx .PageHeight ;_dbadff =_bedb .Curves ;_ccebb =make ([]_ggb .CubicBezierCurve ,0,len (_bedb .Curves )););_cfggf :=_cd .PdfRectangle {};for _ebdfc :=range _bedb .Curves {_deeff :=_dbadff [_ebdfc ];
_deeff .P0 .Y =_bgffd -_deeff .P0 .Y ;_deeff .P1 .Y =_bgffd -_deeff .P1 .Y ;_deeff .P2 .Y =_bgffd -_deeff .P2 .Y ;_deeff .P3 .Y =_bgffd -_deeff .P3 .Y ;_ccebb =append (_ccebb ,_deeff );_ccebe :=_deeff .GetBounds ();if _ebdfc ==0{_cfggf =_ccebe ;}else {_cfggf .Llx =_bd .Min (_cfggf .Llx ,_ccebe .Llx );
_cfggf .Lly =_bd .Min (_cfggf .Lly ,_ccebe .Lly );_cfggf .Urx =_bd .Max (_cfggf .Urx ,_ccebe .Urx );_cfggf .Ury =_bd .Max (_cfggf .Ury ,_ccebe .Ury );};};_bedb .Curves =_ccebb ;defer func (){_bedb .Curves =_dbadff }();if _bedb .FillEnabled {_accda :=_dbdga (_ddcdc ,_deef ._fbac .FillColor ,_deef ._bfae ,func ()Rectangle {return Rectangle {_bdcc :_cfggf .Llx ,_dbgd :_cfggf .Lly ,_bfed :_cfggf .Width (),_abdcf :_cfggf .Height ()};
});if _accda !=nil {return nil ,ctx ,_accda ;};};_cgac ,_ ,_fdeg :=_bedb .MarkedDraw (_dbff ,_deef ._aefb );if _fdeg !=nil {return nil ,ctx ,_fdeg ;};if _fdeg =_ddcdc .addContentsByString (string (_cgac ));_fdeg !=nil {return nil ,ctx ,_fdeg ;};return []*Block {_ddcdc },ctx ,nil ;
};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_aegg *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_aegg ._gbgeb =&_cd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_befag *TOC )SetLineSeparator (separator string ){_befag ._cgaeg =separator };

// Width returns the width of the specified text chunk.
func (_gabeed *TextChunk )Width ()float64 {var (_gggeg float64 ;_ecaef =_gabeed .Style ;);for _ ,_gefc :=range _gabeed .Text {_egdb ,_fegebg :=_ecaef .Font .GetRuneMetrics (_gefc );if !_fegebg {_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_gefc ,_gefc ,_ecaef .Font .BaseFont (),_ecaef .Font .Subtype ());
_fge .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ecaef .Font );_fge .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ecaef .Font .Encoder ());};_ddfca :=_ecaef .FontSize *_egdb .Wx ;_fcec :=_ddfca ;if _gefc !=' '{_fcec =_ddfca +_ecaef .CharSpacing *1000.0;
};_gggeg +=_fcec ;};return _gggeg /1000.0;};

// SetScaling sets scaling value for graphic SVG and maintain the aspect ratio.
func (_afcb *GraphicSVGElement )SetScaling (xFactor ,yFactor float64 ){_adcb :=_afcb .Width /_afcb .ViewBox .W ;_egbe :=_afcb .Height /_afcb .ViewBox .H ;_afcb .setDefaultScaling (_bd .Max (_adcb ,_egbe ));for _ ,_eedg :=range _afcb .Children {_eedg .SetScaling (xFactor ,yFactor );
};};func (_fefde *Table )sortCells (){_fa .Slice (_fefde ._dfcec ,func (_adagd ,_gabee int )bool {_gbdgd :=_fefde ._dfcec [_adagd ]._cfdga ;_aecbc :=_fefde ._dfcec [_gabee ]._cfdga ;if _gbdgd < _aecbc {return true ;};if _gbdgd > _aecbc {return false ;};
return _fefde ._dfcec [_adagd ]._ebgdb < _fefde ._dfcec [_gabee ]._ebgdb ;});};

// CreateFrontPage sets a function to generate a front Page.
func (_ceee *Creator )CreateFrontPage (genFrontPageFunc func (_dcbd FrontpageFunctionArgs )){_ceee ._gcd =genFrontPageFunc ;};func _dbacf (_aggcac *_cd .PdfRectangle ,_aeecb _cf .Matrix )*_cd .PdfRectangle {var _cdafe _cd .PdfRectangle ;_cdafe .Llx ,_cdafe .Lly =_aeecb .Transform (_aggcac .Llx ,_aggcac .Lly );
_cdafe .Urx ,_cdafe .Ury =_aeecb .Transform (_aggcac .Urx ,_aggcac .Ury );_cdafe .Normalize ();return &_cdafe ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_edaa *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdda :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aagbd ,_ ,_ceddf :=_edaa .draw (_fdda ,"");if _ceddf !=nil {return nil ,ctx ,_ceddf ;};_ceddf =_fdda .addContentsByString (string (_aagbd ));
if _ceddf !=nil {return nil ,ctx ,_ceddf ;};return []*Block {_fdda },ctx ,nil ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_baf *Ellipse )SetFitMode (fitMode FitMode ){_baf ._aeae =fitMode };

// SetDueDate sets the due date of the invoice.
func (_aebb *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_aebb ._bbbc [1].Value =dueDate ;return _aebb ._bbbc [0],_aebb ._bbbc [1];};

// SetBorderColor sets the cell's border color.
func (_bdbba *TableCell )SetBorderColor (col Color ){_bdbba ._fbgff =col ;_bdbba ._gfdc =col ;_bdbba ._feddc =col ;_bdbba ._fgaeaf =col ;};

// Text sets the text content of the Paragraph.
func (_dbca *Paragraph )Text ()string {return _dbca ._egda };

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_fee *border )SetMarkedContentID (id int64 ){};

// SetBorder sets the cell's border style.
func (_ebag *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_ebag ._bgcac =CellBorderStyleSingle ;_ebag ._agdfa =width ;_ebag ._cfbc =CellBorderStyleSingle ;
_ebag ._gdff =width ;_ebag ._eedc =CellBorderStyleSingle ;_ebag ._cdfba =width ;_ebag ._cfddd =CellBorderStyleSingle ;_ebag ._geadb =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_ebag ._bgcac =CellBorderStyleDouble ;_ebag ._agdfa =width ;
_ebag ._cfbc =CellBorderStyleDouble ;_ebag ._gdff =width ;_ebag ._eedc =CellBorderStyleDouble ;_ebag ._cdfba =width ;_ebag ._cfddd =CellBorderStyleDouble ;_ebag ._geadb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_ebag ._bgcac =style ;
_ebag ._agdfa =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_ebag ._cfbc =style ;_ebag ._gdff =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_ebag ._eedc =style ;
_ebag ._cdfba =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_ebag ._cfddd =style ;_ebag ._geadb =width ;};};func _dfad (_gbgd *GraphicSVGElement )(*GraphicSVG ,error ){return &GraphicSVG {_dcdb :_gbgd ,_acgg :PositionRelative ,_cded :Margins {Top :10,Bottom :10},taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeFigure }},nil ;
};func (_egbf *templateProcessor )parseHorizontalAlignmentAttr (_fafege ,_gcfef string )HorizontalAlignment {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_fafege ,_gcfef );
_bedbab :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_gcfef ];return _bedbab ;};func _bfded ()commands {var _dcbgd =map[string ]int {"\u006d":2,"\u007a":0,"\u006c":2,"\u0068":1,"\u0076":1,"\u0063":6,"\u0073":4,"\u0071":4,"\u0074":2,"\u0061":7};
var _eecbc []string ;for _efff :=range _dcbgd {_eecbc =append (_eecbc ,_efff );};return commands {_eecbc ,_dcbgd ,"\u006d","\u007a"};};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aeabf *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _adfcd float64 ;var _aedcc []*StyledParagraph ;_gfgf :=_aeabf ._aefb !=nil &&_aeabf ._aefb .ApplyTag ;for _ ,_gafa :=range _aeabf ._gecb {_gcfc :=_dgdda (_aeabf ._cedde );
_gcfc .SetEnableWrap (false );_gcfc .SetTextAlignment (TextAlignmentRight );_gcfc .Append (_gafa ._ceaga .Text ).Style =_gafa ._ceaga .Style ;_bagd :=_gcfc .getTextWidth ()/1000.0/ctx .Width ;if _adfcd < _bagd {_adfcd =_bagd ;};_aedcc =append (_aedcc ,_gcfc );
};_ggdaf :=_gecca (2);_ggdaf .SetColumnWidths (_adfcd ,1-_adfcd );_ggdaf .SetMargins (_aeabf ._bcefc .Left +_aeabf ._bdge ,_aeabf ._bcefc .Right ,_aeabf ._bcefc .Top ,_aeabf ._bcefc .Bottom );_ggdaf .EnableRowWrap (true );if _gfgf {_ggdaf .SetStructPageNumber (_aeabf ._aefb .StructPageNumber );
_ggdaf .AddTag (_aeabf ._aefb .ParentKObj );_ggdaf .SetStructureType (_cd .StructureTypeList );};for _ebbf ,_dbcdg :=range _aeabf ._gecb {_ffcb :=_ggdaf .NewCell ();_ffcb .SetIndent (0);_ffcb .SetContent (_aedcc [_ebbf ]);if _gfgf {_ffcb .SetStructPageNumber (_aeabf ._aefb .StructPageNumber );
_ffcb .SetStructureType (_cd .StructureTypeLabel );};_ffcb =_ggdaf .NewCell ();_ffcb .SetIndent (0);_ffcb .SetContent (_dbcdg ._gdcgce );if _gfgf {_ffcb .SetStructPageNumber (_aeabf ._aefb .StructPageNumber );_ffcb .SetStructureType (_cd .StructureTypeListBody );
};};return _ggdaf .GeneratePageBlocks (ctx );};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fedf *Creator )MoveDown (dy float64 ){_fedf ._fga .Y +=dy };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_ccab *shading )SetAntiAlias (enable bool ){_ccab ._ggfe =enable };var (_abefb =[]string {"\u0063\u006d","\u006d\u006d","\u0070\u0078","\u0070\u0074"};_fdbd =map[string ]float64 {"\u0063\u006d":_bade ,"\u006d\u006d":_abg ,"\u0070\u0078":_afg ,"\u0070\u0074":1};
);

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_efdc *Paragraph )SetLanguageIdentifier (id string ){if _efdc ._aefb ==nil {_efdc ._aefb =_cd .NewStructureTagInfo ();_efdc ._aefb .StructureType =_cd .StructureTypeParagraph ;};_efdc ._fegef =id ;};func _gffbe (_efeb *Creator ,_caadd string ,_gfgbe []byte ,_cfbgc *TemplateOptions ,_bgfd componentRenderer )*templateProcessor {if _cfbgc ==nil {_cfbgc =&TemplateOptions {};
};_cfbgc .init ();if _bgfd ==nil {_bgfd =_efeb ;};return &templateProcessor {creator :_efeb ,_facb :_gfgbe ,_ccdf :_cfbgc ,_bgdf :_bgfd ,_cgcdc :_caadd };};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_ecdce :float64 (r )/255.0,_baae :float64 (g )/255.0,_acaa :float64 (b )/255.0};};func _fef (_dfca _ea .ChartRenderable )*Chart {return &Chart {_ggab :_dfca ,_cgde :PositionRelative ,_cfad :Margins {Top :10,Bottom :10},taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeFigure }};
};func _geabd (_ccaa []*Command )*Path {_gfaac :=&Path {};var _baccf []*Command ;for _cdadf ,_fcdbb :=range _ccaa {switch _gg .ToLower (_fcdbb .Symbol ){case _abea ._geee :if len (_baccf )> 0{_gfaac .Subpaths =append (_gfaac .Subpaths ,&Subpath {_baccf });
};_baccf =[]*Command {_fcdbb };case _abea ._gcdba :_baccf =append (_baccf ,_fcdbb );_gfaac .Subpaths =append (_gfaac .Subpaths ,&Subpath {_baccf });_baccf =[]*Command {};default:_baccf =append (_baccf ,_fcdbb );if len (_ccaa )==_cdadf +1{_gfaac .Subpaths =append (_gfaac .Subpaths ,&Subpath {_baccf });
};};};return _gfaac ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_da :=&Block {};_da ._fc =&_fgc .ContentStreamOperations {};_da ._gaa =_cd .NewPdfPageResources ();_da ._ce =width ;_da ._ff =height ;return _da ;};

// SetStructTreeRoot sets the structure tree root to be appended in the document that will be created.
func (_ccfc *Creator )SetStructTreeRoot (structTreeRoot *_cd .StructTreeRoot ){_ccfc ._gaaeb =structTreeRoot ;};func _caged (_fdge *templateProcessor ,_dbaf *templateNode )(interface{},error ){return _fdge .parseListItem (_dbaf );};func (_febd *Invoice )setCellBorder (_cadgf *TableCell ,_dcaf *InvoiceCell ){for _ ,_bbcb :=range _dcaf .BorderSides {_cadgf .SetBorder (_bbcb ,CellBorderStyleSingle ,_dcaf .BorderWidth );
};_cadgf .SetBorderColor (_dcaf .BorderColor );};func (_bdefac *Path )compare (_fcaf *Path )bool {if len (_bdefac .Subpaths )!=len (_fcaf .Subpaths ){return false ;};for _cebf ,_eddgd :=range _bdefac .Subpaths {if !_eddgd .compare (_fcaf .Subpaths [_cebf ]){return false ;
};};return true ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_deffd *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_deffd .Text },nil ;};var _cceab []string ;var _afbac []rune ;var _ecacg float64 ;var _efcf []float64 ;_ffgc :=_deffd .Style ;_bdbeb :=_cdf .IsTextWriteDirectionLTR (_deffd .Text );
for _ ,_feaa :=range _deffd .Text {if _feaa =='\u000A'{_fegcf :=_cdf .FormatWriteDirectionLTR (string (_afbac ),_bdbeb );_cceab =append (_cceab ,_gg .TrimRightFunc (_fegcf ,_gaf .IsSpace )+string (_feaa ));_afbac =nil ;_ecacg =0;_efcf =nil ;continue ;};
_fdag :=_feaa ==' ';_cafdd ,_abfa :=_ffgc .Font .GetRuneMetrics (_feaa );if !_abfa {_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_feaa ,_feaa ,_ffgc .Font .BaseFont (),_ffgc .Font .Subtype ());
_fge .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ffgc .Font );_fge .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ffgc .Font .Encoder ());return nil ,_fab .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_bfgbg :=_ffgc .FontSize *_cafdd .Wx ;_deefa :=_bfgbg ;if !_fdag {_deefa =_bfgbg +_ffgc .CharSpacing *1000.0;};if _ecacg +_bfgbg > width *1000.0{_fcfa :=-1;if !_fdag {for _edcea :=len (_afbac )-1;_edcea >=0;_edcea --{if _afbac [_edcea ]==' '{_fcfa =_edcea ;
break ;};};};_abace :=string (_afbac );if _fcfa > 0{_abace =string (_afbac [0:_fcfa +1]);_afbac =append (_afbac [_fcfa +1:],_feaa );_efcf =append (_efcf [_fcfa +1:],_deefa );_ecacg =0;for _ ,_fgbe :=range _efcf {_ecacg +=_fgbe ;};}else {if _fdag {_afbac =[]rune {};
_efcf =[]float64 {};_ecacg =0;}else {_afbac =[]rune {_feaa };_efcf =[]float64 {_deefa };_ecacg =_deefa ;};};_abace =_cdf .FormatWriteDirectionLTR (_abace ,_bdbeb );_cceab =append (_cceab ,_gg .TrimRightFunc (_abace ,_gaf .IsSpace ));}else {_afbac =append (_afbac ,_feaa );
_ecacg +=_deefa ;_efcf =append (_efcf ,_deefa );};};if len (_afbac )> 0{_beeda :=string (_afbac );_beeda =_cdf .FormatWriteDirectionLTR (_beeda ,_bdbeb );_cceab =append (_cceab ,_beeda );};return _cceab ,nil ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_ecdce :_bd .Max (_bd .Min (r ,1.0),0.0),_baae :_bd .Max (_bd .Min (g ,1.0),0.0),_acaa :_bd .Max (_bd .Min (b ,1.0),0.0)};};

// MoveY moves the drawing context to absolute position y.
func (_fgag *Creator )MoveY (y float64 ){_fgag ._fga .Y =y };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_bcfgg *TOCLine )SetLevelOffset (levelOffset float64 ){_bcfgg ._fdgca =levelOffset ;_bcfgg ._gbbaf ._acgdg .Left =_bcfgg ._ecece +float64 (_bcfgg ._feacc -1)*_bcfgg ._fdgca ;};

// Path is a collection of all the subpaths in 'd' attribute.
type Path struct{Subpaths []*Subpath ;};

// BorderColor returns the border color of the ellipse.
func (_cdgd *Ellipse )BorderColor ()Color {return _cdgd ._ddfb };

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_cadg *GridCell )SetContent (vd VectorDrawable )error {switch _adbab :=vd .(type ){case *Paragraph :if _adbab ._bdag {_adbab ._fabc =true ;};_cadg ._ddad =vd ;case *StyledParagraph :if _adbab ._agcga {_adbab ._bccfb =true ;};_cadg ._ddad =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_cadg ._ddad =vd ;
default:_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _cdf .ErrTypeError ;};return nil ;};

// NewColumn returns a new column for the line items invoice table.
func (_cabd *Invoice )NewColumn (description string )*InvoiceCell {return _cabd .newColumn (description ,CellHorizontalAlignmentLeft );};func _cabe (_eagba string )(float64 ,float64 ,float64 ){_bggad :=_gg .TrimPrefix (_eagba ,"\u0072\u0067\u0062\u0028");
_bggad =_gg .TrimSuffix (_bggad ,"\u0029");_eegcf :=_gg .Split (_bggad ,"\u002c");if len (_eegcf )!=3{_fge .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_eagba );
return 0,0,0;};var _fbbeb ,_adcaa ,_edgegb float64 ;_fbbeb ,_decfb :=_dede (_eegcf [0]);if _decfb !=nil {_fge .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_eagba );
return 0,0,0;};_adcaa ,_decfb =_dede (_eegcf [1]);if _decfb !=nil {_fge .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_eagba );
return 0,0,0;};_edgegb ,_decfb =_dede (_eegcf [2]);if _decfb !=nil {_fge .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_eagba );
return 0,0,0;};_bbeba :=_fbbeb /255.0;_befba :=_adcaa /255.0;_bdgeee :=_edgegb /255.0;return _bbeba ,_befba ,_bdgeee ;};

// GridRow defines a row which can contain cells.
type GridRow struct{_adgg []*GridCell ;_dada float64 ;_fede float64 ;_bfeeg int ;_cbgd *Grid ;_ddda *_cd .StructureTagInfo ;_ccbe GridRowSection ;};func (_gefb *Grid )insertRowAfter (_ecgg int ,_fegebb *GridRow ){_gefb ._gafbe =append (_gefb ._gafbe ,&GridRow {});
copy (_gefb ._gafbe [_ecgg +2:],_gefb ._gafbe [_ecgg +1:]);_gefb ._gafbe [_ecgg +1]=_fegebb ;for _efed ,_cfgb :=range _gefb ._gafbe {if _efed > _ecgg +1{_cfgb ._bfeeg +=1;for _ ,_cbde :=range _cfgb ._adgg {_cbde ._affb +=1;};};};};

// SetBorderColor sets border color of the rectangle.
func (_cffe *Rectangle )SetBorderColor (col Color ){_cffe ._feedc =col };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};func (_acfg *GraphicSVGStyle )toContentStream (_aaea *_fgc .ContentCreator ,_dgbe *_cd .PdfPageResources ,_fddd *GraphicSVGElement ){if _acfg ==nil {return ;};if _acfg .FillColor !=""{var _fddgg ,_bdba ,_dcge float64 ;
if _agff ,_fbag :=_ag .ColorMap [_acfg .FillColor ];_fbag {_ffbc ,_eegd ,_aefge ,_ :=_agff .RGBA ();_fddgg ,_bdba ,_dcge =float64 (_ffbc ),float64 (_eegd ),float64 (_aefge );_aaea .Add_rg (_fddgg ,_bdba ,_dcge );}else if _gg .HasPrefix (_acfg .FillColor ,"\u0072\u0067\u0062\u0028"){_fddgg ,_bdba ,_dcge =_cabe (_acfg .FillColor );
_aaea .Add_rg (_fddgg ,_bdba ,_dcge );}else if _gg .HasPrefix (_acfg .FillColor ,"\u0075\u0072\u006c\u0028"){_dced :=_gg .TrimPrefix (_acfg .FillColor ,"\u0075\u0072\u006c\u0028\u0027\u0023");_dced =_gg .TrimPrefix (_dced ,"\u0075\u0072\u006c(\u0023");
_dced =_gg .TrimSuffix (_dced ,"\u0027\u0029");_dced =_gg .TrimSuffix (_dced ,"\u0029");if _fddd ._aeea [_dced ]!=nil {_dgbe .SetPatternByName (*_cdf .MakeName (_dced ),_fddd ._aeea [_dced ].ToPdfShadingPattern ().ToPdfObject ());_aaea .Add_cs (*_cdf .MakeName ("\u0050a\u0074\u0074\u0065\u0072\u006e"));
_aaea .Add_scn_pattern (*_cdf .MakeName (_dced ));}else if _fddd ._edbee [_dced ]!=nil {_dgbe .SetPatternByName (*_cdf .MakeName (_dced ),_fddd ._edbee [_dced ].ToPdfShadingPattern ().ToPdfObject ());_aaea .Add_cs (*_cdf .MakeName ("\u0050a\u0074\u0074\u0065\u0072\u006e"));
_aaea .Add_scn_pattern (*_cdf .MakeName (_dced ));};}else {_fddgg ,_bdba ,_dcge =ColorRGBFromHex (_acfg .FillColor ).ToRGB ();_aaea .Add_rg (_fddgg ,_bdba ,_dcge );};};if _acfg .FillOpacity < 1.0{_cba :=0;_ceeaa :=_cdf .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_cba ));
for {_ ,_gaag :=_dgbe .GetExtGState (_ceeaa );if !_gaag {break ;};_cba ++;_ceeaa =_cdf .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_cba ));};_aaac :=_cdf .MakeDict ();_aaac .Set ("\u0063\u0061",_cdf .MakeFloat (_acfg .FillOpacity ));_dagg :=_dgbe .AddExtGState (_ceeaa ,_cdf .MakeIndirectObject (_aaac ));
if _dagg !=nil {_fge .Log .Debug (_dagg .Error ());return ;};_aaea .Add_gs (_ceeaa );};if _acfg .StrokeColor !=""{var _dcbf ,_cdecd ,_fbdac float64 ;if _bafg ,_bccfc :=_ag .ColorMap [_acfg .StrokeColor ];_bccfc {_baaae ,_adca ,_dafd ,_ :=_bafg .RGBA ();
_dcbf ,_cdecd ,_fbdac =float64 (_baaae )/255.0,float64 (_adca )/255.0,float64 (_dafd )/255.0;}else if _gg .HasPrefix (_acfg .FillColor ,"\u0072\u0067\u0062\u0028"){_dcbf ,_cdecd ,_fbdac =_cabe (_acfg .FillColor );}else {_dcbf ,_cdecd ,_fbdac =ColorRGBFromHex (_acfg .StrokeColor ).ToRGB ();
};_aaea .Add_RG (_dcbf ,_cdecd ,_fbdac );};if _acfg .StrokeWidth > 0{_aaea .Add_w (_acfg .StrokeWidth );};};func (_afbag *Invoice )drawInformation ()*Table {_effab :=_gecca (2);_dcbc :=append ([][2]*InvoiceCell {_afbag ._dcfg ,_afbag ._gega ,_afbag ._bbbc },_afbag ._bdgbg ...);
for _ ,_acbf :=range _dcbc {_eccgg ,_fgac :=_acbf [0],_acbf [1];if _fgac .Value ==""{continue ;};_dfbac :=_effab .NewCell ();_dfbac .SetBackgroundColor (_eccgg .BackgroundColor );_afbag .setCellBorder (_dfbac ,_eccgg );_ggafd :=_dgdda (_eccgg .TextStyle );
_ggafd .Append (_eccgg .Value );_ggafd .SetMargins (0,0,2,1);_dfbac .SetContent (_ggafd );_dfbac =_effab .NewCell ();_dfbac .SetBackgroundColor (_fgac .BackgroundColor );_afbag .setCellBorder (_dfbac ,_fgac );_ggafd =_dgdda (_fgac .TextStyle );_ggafd .Append (_fgac .Value );
_ggafd .SetMargins (0,0,2,1);_dfbac .SetContent (_ggafd );};return _effab ;};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_bggc *GraphicSVG )SetPos (x ,y float64 ){_bggc ._acgg =PositionAbsolute ;_bggc ._fdgf =x ;_bggc ._fegbbc =y ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_fecb *Image )ConvertToBinary ()error {return _fecb ._dbfc .ConvertToBinary ()};

// BorderColor returns the border color of the rectangle.
func (_fdcgg *Rectangle )BorderColor ()Color {return _fdcgg ._feedc };func (_eadea *Invoice )SetStructureType (structureType _cd .StructureType ){};func (_dbcddg *templateProcessor )parseFontAttr (_bffda ,_fedgb string )*_cd .PdfFont {_fge .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bffda ,_fedgb );
_fcfgb :=_dbcddg .creator ._ccbd ;if _fedgb ==""{return _fcfgb ;};_gfcgb :=_gg .Split (_fedgb ,"\u002c");for _ ,_eefbf :=range _gfcgb {_eefbf =_gg .TrimSpace (_eefbf );if _eefbf ==""{continue ;};_begbb ,_gfcb :=_dbcddg ._ccdf .FontMap [_fedgb ];if _gfcb {return _begbb ;
};_addeb ,_gfcb :=map[string ]_cd .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_cd .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_cd .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_cd .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_cd .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_cd .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_cd .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_cd .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_cd .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_cd .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_cd .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_cd .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_cd .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_cd .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_cd .TimesBoldItalicName }[_fedgb ];
if _gfcb {if _eadca ,_fagfb :=_cd .NewStandard14Font (_addeb );_fagfb ==nil {return _eadca ;};};if _gffbb :=_dbcddg .parseAttrPropList (_eefbf );len (_gffbb )> 0{if _gadad ,_ffbea :=_gffbb ["\u0070\u0061\u0074\u0068"];_ffbea {_efgeff :=_cd .NewPdfFontFromTTFFile ;
if _bfagc ,_abdgf :=_gffbb ["\u0074\u0079\u0070\u0065"];_abdgf &&_bfagc =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_efgeff =_cd .NewCompositePdfFontFromTTFFile ;};if _ffdffc ,_bcdea :=_efgeff (_gadad );_bcdea !=nil {_fge .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_gadad ,_bcdea );
}else {return _ffdffc ;};};};};return _fcfgb ;};func (_bcgc *FilledCurve )draw (_dage *Block ,_fddg string )([]byte ,*_cd .PdfRectangle ,error ){_ffaa :=_ggb .NewCubicBezierPath ();for _ ,_bfda :=range _bcgc ._dbdfe {_ffaa =_ffaa .AppendCurve (_bfda );
};creator :=_fgc .NewContentCreator ();if _bcgc ._aefb !=nil {creator .Add_BDC (*_cdf .MakeName (string (_bcgc ._aefb .StructureType )),map[string ]_cdf .PdfObject {"\u004d\u0043\u0049\u0044":_cdf .MakeInteger (_bcgc ._aefb .Mcid )});};creator .Add_q ();
if _bcgc .FillEnabled &&_bcgc ._feaf !=nil {_cdbg :=_acac (_bcgc ._feaf );_fgbf :=_dbdga (_dage ,_cdbg ,_bcgc ._feaf ,func ()Rectangle {_adfd :=_ggb .NewCubicBezierPath ();for _ ,_fedd :=range _bcgc ._dbdfe {_adfd =_adfd .AppendCurve (_fedd );};_cegb :=_adfd .GetBoundingBox ();
if _bcgc .BorderEnabled {_cegb .Height +=_bcgc .BorderWidth ;_cegb .Width +=_bcgc .BorderWidth ;_cegb .X -=_bcgc .BorderWidth /2;_cegb .Y -=_bcgc .BorderWidth /2;};return Rectangle {_bdcc :_cegb .X ,_dbgd :_cegb .Y ,_bfed :_cegb .Width ,_abdcf :_cegb .Height };
});if _fgbf !=nil {return nil ,nil ,_fgbf ;};creator .SetNonStrokingColor (_cdbg );};if _bcgc .BorderEnabled {if _bcgc ._fbgc !=nil {creator .SetStrokingColor (_acac (_bcgc ._fbgc ));};creator .Add_w (_bcgc .BorderWidth );};if len (_fddg )> 1{creator .Add_gs (_cdf .PdfObjectName (_fddg ));
};_ggb .DrawBezierPathWithCreator (_ffaa ,creator );creator .Add_h ();if _bcgc .FillEnabled &&_bcgc .BorderEnabled {creator .Add_B ();}else if _bcgc .FillEnabled {creator .Add_f ();}else if _bcgc .BorderEnabled {creator .Add_S ();};creator .Add_Q ();if _bcgc ._aefb !=nil {creator .Add_EMC ();
};_febc :=_ffaa .GetBoundingBox ();if _bcgc .BorderEnabled {_febc .Height +=_bcgc .BorderWidth ;_febc .Width +=_bcgc .BorderWidth ;_febc .X -=_bcgc .BorderWidth /2;_febc .Y -=_bcgc .BorderWidth /2;};_aead :=&_cd .PdfRectangle {};_aead .Llx =_febc .X ;_aead .Lly =_febc .Y ;
_aead .Urx =_febc .X +_febc .Width ;_aead .Ury =_febc .Y +_febc .Height ;return creator .Bytes (),_aead ,nil ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_eabg *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fbgf []*Block ;_bbg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_cbe =ctx ;);_eede :=_eabg ._dgc .IsRelative ();if _eede {_eabg .applyFitMode (ctx .Width );
ctx .X +=_eabg ._ffdg .Left ;ctx .Y +=_eabg ._ffdg .Top ;ctx .Width -=_eabg ._ffdg .Left +_eabg ._ffdg .Right ;ctx .Height -=_eabg ._ffdg .Top +_eabg ._ffdg .Bottom ;if _eabg ._ffaee > ctx .Height {_fbgf =append (_fbgf ,_bbg );_bbg =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_gdbc :=ctx ;_gdbc .Y =ctx .Margins .Top +_eabg ._ffdg .Top ;_gdbc .X =ctx .Margins .Left +_eabg ._ffdg .Left ;_gdbc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_eabg ._ffdg .Top -_eabg ._ffdg .Bottom ;_gdbc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_eabg ._ffdg .Left -_eabg ._ffdg .Right ;
ctx =_gdbc ;};}else {ctx .X =_eabg ._adbf -_eabg ._bgfbe /2;ctx .Y =_eabg ._gggg -_eabg ._ffaee /2;};_bfgb :=_ggb .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_eabg ._ffaee ,Width :_eabg ._bgfbe ,Height :_eabg ._ffaee ,BorderWidth :_eabg ._dffd ,Opacity :1.0};
if _eabg ._beg !=nil {_bfgb .FillEnabled =true ;_gcec :=_acac (_eabg ._beg );_fcb :=_dbdga (_bbg ,_gcec ,_eabg ._beg ,func ()Rectangle {return Rectangle {_bdcc :_bfgb .X ,_dbgd :_bfgb .Y ,_bfed :_bfgb .Width ,_abdcf :_bfgb .Height };});if _fcb !=nil {return nil ,ctx ,_fcb ;
};_bfgb .FillColor =_gcec ;};if _eabg ._ddfb !=nil {_bfgb .BorderEnabled =false ;if _eabg ._dffd > 0{_bfgb .BorderEnabled =true ;};_bfgb .BorderColor =_acac (_eabg ._ddfb );_bfgb .BorderWidth =_eabg ._dffd ;};_bacb ,_ddb :=_bbg .setOpacity (_eabg ._aadae ,_eabg ._bdfd );
if _ddb !=nil {return nil ,ctx ,_ddb ;};_agbf ,_ ,_ddb :=_bfgb .MarkedDraw (_bacb ,_eabg ._aefb );if _ddb !=nil {return nil ,ctx ,_ddb ;};_ddb =_bbg .addContentsByString (string (_agbf ));if _ddb !=nil {return nil ,ctx ,_ddb ;};if _eede {ctx .X =_cbe .X ;
ctx .Width =_cbe .Width ;ctx .Y +=_eabg ._ffaee +_eabg ._ffdg .Bottom ;ctx .Height -=_eabg ._ffaee ;}else {ctx =_cbe ;};_fbgf =append (_fbgf ,_bbg );return _fbgf ,ctx ,nil ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{taggedDrawable ;_gbgg *_ggb .Polyline ;_becd float64 ;};

// SetBackgroundColor sets the cell's background color.
func (_edbfe *TableCell )SetBackgroundColor (col Color ){_edbfe ._dbdge =col };func _dcff (_fggg *templateProcessor ,_eacdb *templateNode )(interface{},error ){return _fggg .parseTableCell (_eacdb );};func _gfdf (_gecd string )(_ceedc []float64 ,_abcbe error ){var _ddag float64 ;
_gdge :=0;_adgdf :=true ;for _dcbgc ,_fgfa :=range _gecd {if _fgfa =='.'{if _adgdf {_adgdf =false ;continue ;};_ddag ,_abcbe =_gfgbeb (_gecd [_gdge :_dcbgc ],64);if _abcbe !=nil {return ;};_ceedc =append (_ceedc ,_ddag );_gdge =_dcbgc ;};};_ddag ,_abcbe =_gfgbeb (_gecd [_gdge :],64);
if _abcbe !=nil {return ;};_ceedc =append (_ceedc ,_ddag );return ;};

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_facg *GraphicSVG )ScaleToHeight (h float64 ){_faeac :=_facg ._dcdb .Width /_facg ._dcdb .Height ;_facg ._dcdb .Height =h ;_facg ._dcdb .Width =h *_faeac ;_facg ._dcdb .SetScaling (_faeac ,_faeac );};func (_gbdc *shading )generatePdfFunctions ()[]_cd .PdfFunction {if len (_gbdc ._ecgf )==0{return nil ;
}else if len (_gbdc ._ecgf )<=2{_gdedd ,_cdbeb ,_gfdd :=_gbdc ._ecgf [0]._efddc .ToRGB ();_ebea ,_dgce ,_aaggc :=_gbdc ._ecgf [len (_gbdc ._ecgf )-1]._efddc .ToRGB ();return []_cd .PdfFunction {&_cd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_gdedd ,_cdbeb ,_gfdd },C1 :[]float64 {_ebea ,_dgce ,_aaggc }}};
}else {_gdbf :=[]_cd .PdfFunction {};_bdgcff :=[]float64 {};for _cfgba :=0;_cfgba < len (_gbdc ._ecgf )-1;_cfgba ++{_abefa ,_ffdac ,_fgbff :=_gbdc ._ecgf [_cfgba ]._efddc .ToRGB ();_bacf ,_cgbg ,_edeed :=_gbdc ._ecgf [_cfgba +1]._efddc .ToRGB ();_feagg :=&_cd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_abefa ,_ffdac ,_fgbff },C1 :[]float64 {_bacf ,_cgbg ,_edeed }};
_gdbf =append (_gdbf ,_feagg );if _cfgba > 0{_bdgcff =append (_bdgcff ,_gbdc ._ecgf [_cfgba ]._feag );};};_gcbc :=[]float64 {};for range _gdbf {_gcbc =append (_gcbc ,[]float64 {0.0,1.0}...);};return []_cd .PdfFunction {&_cd .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_gdbf ,Bounds :_bdgcff ,Encode :_gcbc }};
};};

// ParseFromSVGStream creates a GraphicSVG instance from SVG stream input.
func ParseFromSVGStream (source _bg .Reader )(*GraphicSVGElement ,error ){_abfb :=_gd .NewDecoder (source );_abfb .CharsetReader =_dd .NewReaderLabel ;_accdaf ,_eafadg :=_bagg (_abfb );if _eafadg !=nil {return nil ,_eafadg ;};if _afead :=_accdaf .Decode (_abfb );
_afead !=nil &&_afead !=_bg .EOF {return nil ,_afead ;};return _accdaf ,nil ;};func (_aca *Block )addContentsByString (_edg string )error {_eg :=_fgc .NewContentStreamParser (_edg );_eff ,_de :=_eg .Parse ();if _de !=nil {return _de ;};_aca ._fc .WrapIfNeeded ();
_eff .WrapIfNeeded ();*_aca ._fc =append (*_aca ._fc ,*_eff ...);return nil ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cfgg *Invoice )NoteHeadingStyle ()TextStyle {return _cfgg ._gebdb };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);
ColorYellow =ColorRGBFromArithmetic (1,1,0););func _ddac (_ggdf interface{})(interface{},error ){switch _gfeae :=_ggdf .(type ){case uint8 :return int64 (_gfeae ),nil ;case int8 :return int64 (_gfeae ),nil ;case uint16 :return int64 (_gfeae ),nil ;case int16 :return int64 (_gfeae ),nil ;
case uint32 :return int64 (_gfeae ),nil ;case int32 :return int64 (_gfeae ),nil ;case uint64 :return int64 (_gfeae ),nil ;case int64 :return _gfeae ,nil ;case int :return int64 (_gfeae ),nil ;case float32 :return float64 (_gfeae ),nil ;case float64 :return _gfeae ,nil ;
};return nil ,_a .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_ggdf );};func (_cfadd *templateProcessor )parseLine (_gdggbc *templateNode )(interface{},error ){_cgadd :=_cfadd .creator .NewLine (0,0,0,0);
for _ ,_agfc :=range _gdggbc ._bcaga .Attr {_cbgab :=_agfc .Value ;switch _bcfa :=_agfc .Name .Local ;_bcfa {case "\u0078\u0031":_cgadd ._bacec =_cfadd .parseFloatAttr (_bcfa ,_cbgab );case "\u0079\u0031":_cgadd ._cbcf =_cfadd .parseFloatAttr (_bcfa ,_cbgab );
case "\u0078\u0032":_cgadd ._bfdg =_cfadd .parseFloatAttr (_bcfa ,_cbgab );case "\u0079\u0032":_cgadd ._ebgdf =_cfadd .parseFloatAttr (_bcfa ,_cbgab );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_cgadd .SetLineWidth (_cfadd .parseFloatAttr (_bcfa ,_cbgab ));
case "\u0063\u006f\u006co\u0072":_cgadd .SetColor (_cfadd .parseColorAttr (_bcfa ,_cbgab ));case "\u0073\u0074\u0079l\u0065":_cgadd .SetStyle (_cfadd .parseLineStyleAttr (_bcfa ,_cbgab ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_cgadd .SetDashPattern (_cfadd .parseInt64Array (_bcfa ,_cbgab ),_cgadd ._cbce );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_cgadd .SetDashPattern (_cgadd ._egaeg ,_cfadd .parseInt64Attr (_bcfa ,_cbgab ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_cgadd .SetOpacity (_cfadd .parseFloatAttr (_bcfa ,_cbgab ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_cgadd .SetPositioning (_cfadd .parsePositioningAttr (_bcfa ,_cbgab ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_cgadd .SetFitMode (_cfadd .parseFitModeAttr (_bcfa ,_cbgab ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gedfb :=_cfadd .parseMarginAttr (_bcfa ,_cbgab );
_cgadd .SetMargins (_gedfb .Left ,_gedfb .Right ,_gedfb .Top ,_gedfb .Bottom );default:_cfadd .nodeLogDebug (_gdggbc ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bcfa );
};};return _cgadd ,nil ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_gbde :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_fge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gbde ;
};var _eaddg ,_gdfe ,_aadd int ;if len (hexStr )==4{var _dgf ,_adba ,_bbe int ;_cege ,_daa :=_a .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_dgf ,&_adba ,&_bbe );if _daa !=nil {_fge .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_daa );
return _gbde ;};if _cege !=3{_fge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gbde ;};_eaddg =_dgf *16+_dgf ;_gdfe =_adba *16+_adba ;_aadd =_bbe *16+_bbe ;}else {_ebc ,_acaf :=_a .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_eaddg ,&_gdfe ,&_aadd );
if _acaf !=nil {_fge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gbde ;};if _ebc !=3{_fge .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_ebc );
return _gbde ;};};_egec :=float64 (_eaddg )/255.0;_gbadd :=float64 (_gdfe )/255.0;_cacb :=float64 (_aadd )/255.0;_gbde ._ecdce =_egec ;_gbde ._baae =_gbadd ;_gbde ._acaa =_cacb ;return _gbde ;};

// SellerAddress returns the seller address used in the invoice template.
func (_fccbf *Invoice )SellerAddress ()*InvoiceAddress {return _fccbf ._cfccb };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_cbec *TOC )SetLineLevelOffset (levelOffset float64 ){_cbec ._fbaf =levelOffset };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_egg int ;_dfd string ;_bebf *StyledParagraph ;_ecbg []Drawable ;_acd int ;_fbf bool ;_agfe bool ;_dgg Positioning ;_fdef ,_cgb float64 ;_acgfb Margins ;_aagc *Chapter ;_fbfg *TOC ;_dbb *_cd .Outline ;_fdg *_cd .OutlineItem ;_gffb uint ;
};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_cddd *Creator )Flip (flipH ,flipV bool )error {_badc :=_cddd .getActivePage ();if _badc ==nil {return _fab .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_ebfc ,_baaa :=_cddd ._bdb [_badc ];if !_baaa {_ebfc =&pageTransformations {};
_cddd ._bdb [_badc ]=_ebfc ;};_ebfc ._cgbf =flipH ;_ebfc ._ccac =flipV ;return nil ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_fgfd *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// SetLanguage sets the language identifier that will be stored inside document catalog.
func (_gbegd *Creator )SetLanguage (language string ){_gbegd ._gdcd =language };func _fgdd (_dgfa string )(float64 ,error ){_dgfa =_gg .TrimSpace (_dgfa );var _aebbcc float64 ;if _gg .HasSuffix (_dgfa ,"\u0025"){_ecfgde ,_dbfca :=_c .ParseFloat (_gg .TrimSuffix (_dgfa ,"\u0025"),64);
if _dbfca !=nil {return 0,_dbfca ;};_aebbcc =_ecfgde /100.0;}else {_gbfef ,_dgbgb :=_c .ParseFloat (_dgfa ,64);if _dgbgb !=nil {return 0,_dgbgb ;};_aebbcc =_gbfef ;};return _aebbcc ,nil ;};func (_abgeg *templateProcessor )parseBorderRadiusAttr (_bcbcb ,_ebddf string )(_bcedf ,_dbebg ,_cfbgea ,_ebgb float64 ){_fge .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_bcbcb ,_ebddf );
switch _ebceg :=_gg .Fields (_ebddf );len (_ebceg ){case 1:_bcedf ,_ =_c .ParseFloat (_ebceg [0],64);_dbebg =_bcedf ;_cfbgea =_bcedf ;_ebgb =_bcedf ;case 2:_bcedf ,_ =_c .ParseFloat (_ebceg [0],64);_cfbgea =_bcedf ;_dbebg ,_ =_c .ParseFloat (_ebceg [1],64);
_ebgb =_dbebg ;case 3:_bcedf ,_ =_c .ParseFloat (_ebceg [0],64);_dbebg ,_ =_c .ParseFloat (_ebceg [1],64);_ebgb =_dbebg ;_cfbgea ,_ =_c .ParseFloat (_ebceg [2],64);case 4:_bcedf ,_ =_c .ParseFloat (_ebceg [0],64);_dbebg ,_ =_c .ParseFloat (_ebceg [1],64);
_cfbgea ,_ =_c .ParseFloat (_ebceg [2],64);_ebgb ,_ =_c .ParseFloat (_ebceg [3],64);};return _bcedf ,_dbebg ,_cfbgea ,_ebgb ;};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_ddgg *Table )EnablePageWrap (enable bool ){_ddgg ._ddcg =enable };

// Reset removes all the text chunks the paragraph contains.
func (_dfcggb *StyledParagraph )Reset (){_dfcggb ._bcebd =[]*TextChunk {}};

// Scale scales the rectangle dimensions by the specified factors.
func (_bcdd *Rectangle )Scale (xFactor ,yFactor float64 ){_bcdd ._bfed =xFactor *_bcdd ._bfed ;_bcdd ._abdcf =yFactor *_bcdd ._abdcf ;};func (_gffee *TOCLine )getLineLink ()*_cd .PdfAnnotation {if _gffee ._abcc <=0{return nil ;};return _aegef (_gffee ._abcc -1,_gffee ._fbbd ,_gffee ._bbefa ,0,"");
};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_gfce *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_gfce ._ggda =alignment };

// Width returns the width of the Paragraph.
func (_gaed *Paragraph )Width ()float64 {if _gaed ._fabc &&int (_gaed ._efbe )> 0{return _gaed ._efbe ;};return _gaed .getTextWidth ()/1000.0;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_egbc *Invoice )AddressStyle ()TextStyle {return _egbc ._fdcd };

// SetSideBorderWidth sets the cell's side border width.
func (_cegg *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_cegg ._geadb =width ;_cegg ._gdff =width ;_cegg ._agdfa =width ;_cegg ._cdfba =width ;case CellBorderSideTop :_cegg ._geadb =width ;case CellBorderSideBottom :_cegg ._gdff =width ;
case CellBorderSideLeft :_cegg ._agdfa =width ;case CellBorderSideRight :_cegg ._cdfba =width ;};};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_ebfda *Invoice )TotalLines ()[][2]*InvoiceCell {_gagdg :=[][2]*InvoiceCell {_ebfda ._fdfe };_gagdg =append (_gagdg ,_ebfda ._fbece ...);return append (_gagdg ,_ebfda ._eacee );};

// LineWidth returns the width of the line.
func (_cdaff *Line )LineWidth ()float64 {return _cdaff ._ebee };func (_bfea *Creator )getActivePage ()*_cd .PdfPage {if _bfea ._feda ==nil {if len (_bfea ._agdb )==0{return nil ;};return _bfea ._agdb [len (_bfea ._agdb )-1];};return _bfea ._feda ;};func (_bdaaaf *Table )updateRowHeights (_afeb float64 ){for _ ,_dbfcg :=range _bdaaaf ._dfcec {_eddde :=_dbfcg .width (_bdaaaf ._fefea ,_afeb );
_cbfdb :=_dbfcg .height (_eddde );_bgcd :=_bdaaaf ._fgege [_dbfcg ._cfdga +_dbfcg ._aecg -2];if _dbfcg ._aecg > 1{_acfga :=0.0;_bagga :=_bdaaaf ._fgege [_dbfcg ._cfdga -1:(_dbfcg ._cfdga +_dbfcg ._aecg -1)];for _ ,_caae :=range _bagga {_acfga +=_caae ;
};if _cbfdb <=_acfga {continue ;};};if _cbfdb > _bgcd {_cccfb :=_cbfdb /float64 (_dbfcg ._aecg );if _cccfb > _bgcd {for _gagag :=1;_gagag <=_dbfcg ._aecg ;_gagag ++{if _cccfb > _bdaaaf ._fgege [_dbfcg ._cfdga +_gagag -2]{_bdaaaf ._fgege [_dbfcg ._cfdga +_gagag -2]=_cccfb ;
};};};};};};func _babc ()*FilledCurve {_bbfg :=FilledCurve {};_bbfg ._dbdfe =[]_ggb .CubicBezierCurve {};return &_bbfg ;};func (_abac *StyledParagraph )wrapWordChunks (){if !_abac ._bgeb {return ;};var (_gcge []*TextChunk ;_bcfg *_cd .PdfFont ;);for _ ,_gfddc :=range _abac ._bcebd {_dbeb :=[]rune (_gfddc .Text );
if _bcfg ==nil {_bcfg =_gfddc .Style .Font ;};_eaea :=_gfddc ._badce ;_baebc :=_gfddc .VerticalAlignment ;if len (_gcge )> 0{if len (_dbeb )==1&&_gaf .IsPunct (_dbeb [0])&&_gfddc .Style .Font ==_bcfg {_dfcae :=[]rune (_gcge [len (_gcge )-1].Text );_gcge [len (_gcge )-1].Text =string (append (_dfcae ,_dbeb [0]));
continue ;}else {_ ,_fgfcg :=_c .Atoi (_gfddc .Text );if _fgfcg ==nil {_ddee :=[]rune (_gcge [len (_gcge )-1].Text );_cgabc :=len (_ddee );if _cgabc >=2{_ ,_cbee :=_c .Atoi (string (_ddee [_cgabc -2]));if _cbee ==nil &&_gaf .IsPunct (_ddee [_cgabc -1]){_gcge [len (_gcge )-1].Text =string (append (_ddee ,_dbeb ...));
continue ;};};};};};_fgegf ,_dbab :=_fdade (_gfddc .Text );if _dbab !=nil {_fge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_dbab );
_fgegf =[]string {_gfddc .Text };};for _ ,_cgbeg :=range _fgegf {_gfffd :=NewTextChunk (_cgbeg ,_gfddc .Style );_gfffd ._badce =_faecg (_eaea );_gfffd .VerticalAlignment =_baebc ;_gcge =append (_gcge ,_gfffd );};_bcfg =_gfddc .Style .Font ;};if len (_gcge )> 0{_abac ._bcebd =_gcge ;
};};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_ccbca *Rectangle )ScaleToWidth (w float64 ){_gfbd :=_ccbca ._abdcf /_ccbca ._bfed ;_ccbca ._bfed =w ;_ccbca ._abdcf =w *_gfbd ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// AddAnnotation adds an annotation on a TextChunk.
func (_adbe *TextChunk )AddAnnotation (annotation *_cd .PdfAnnotation ){if annotation ==nil {return ;};_adbe ._badce =append (_adbe ._badce ,annotation );};func _bbfc (_gdebe *templateProcessor ,_dgde *templateNode )(interface{},error ){return _gdebe .parseChart (_dgde );
};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destination of the link.
func (_gceag *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_fgecg :=url ;if _gg .HasPrefix (url ,"\u0068\u0074\u0074\u0070"){_fgecg =text ;};_bffea :=NewTextChunk (text ,_gceag ._adfa );_bffea .AddAnnotation (_egce (url ,_fgecg ));return _gceag .appendChunk (_bffea );
};

// Title returns the title of the invoice.
func (_baebg *Invoice )Title ()string {return _baebg ._egcc };

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_gccgba *Rectangle )SetCoords (x ,y float64 ){_gccgba ._bdcc =x ;_gccgba ._dbgd =y };

// SetSideBorderColor sets the cell's side border color.
func (_dgced *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_dgced ._fgaeaf =col ;_dgced ._gfdc =col ;_dgced ._fbgff =col ;_dgced ._feddc =col ;case CellBorderSideTop :_dgced ._fgaeaf =col ;case CellBorderSideBottom :_dgced ._gfdc =col ;
case CellBorderSideLeft :_dgced ._fbgff =col ;case CellBorderSideRight :_dgced ._feddc =col ;};};

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_cde *Block )SetMarkedContentID (id int64 ){};

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_ca *Block )SetStructPageNumber (pageNumber *int64 ){};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_deff *Creator )NewPolyBezierCurve (curves []_ggb .CubicBezierCurve )*PolyBezierCurve {return _fcefg (curves );};func (_ffgfea *templateProcessor )parseCellVerticalAlignmentAttr (_ggfdc ,_gdfeb string )CellVerticalAlignment {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ggfdc ,_gdfeb );
_abfbe :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_gdfeb ];return _abfbe ;
};

// Command is a representation of an SVG path command and its parameters.
type Command struct{Symbol string ;Params []float64 ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{taggedDrawable ;_eee float64 ;_fbdg float64 ;_bae float64 ;_gdac float64 ;_cddf float64 ;_aaec float64 ;_agbd Color ;_dbec float64 ;};

// SetTitle sets the title of the invoice.
func (_eccf *Invoice )SetTitle (title string ){_eccf ._egcc =title };

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eefaa *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _eefaa ._eacee [0],_eefaa ._eacee [1];};

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_bceb *Rectangle )FillOpacity ()float64 {return _bceb ._abbd };

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_ffff *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _cgega (colorPoints );};type pathParserError struct{_ccafg string };

// GeneratePageBlocks generates the grid page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_gead *Grid )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fcgaa []*Block ;_ffga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gead .updateRowHeights (ctx .Width -_gead ._eacc .Left -_gead ._eacc .Right );_egfe :=_gead ._eacc .Top ;
_gbff :=ctx ;if _gead ._dgda .IsAbsolute (){ctx .X =_gead ._cfade ;ctx .Y =_gead ._bdef ;}else {ctx .X +=_gead ._eacc .Left ;ctx .Y +=_egfe ;ctx .Width -=_gead ._eacc .Left +_gead ._eacc .Right ;ctx .Height -=_egfe ;};_adaf :=ctx .Width ;_eddg :=ctx .X ;
_adgd :=ctx .Y ;_feeee :=ctx .Height ;var (_cbca =0;_ggfc =false ;_cccb int64 ;_gggf *_cd .KDict ;_gdcf =GridRowSectionUnknown ;_gcbf =_gead ._aefb !=nil &&_gead ._aefb .ApplyTag ;);if _gcbf {_faefe (_ffga ,_gead ._aefb );_cccb =_gead ._aefb .Mcid +1;_gggf =_gead ._aefb .ComponentKObj ;
};for _edgd :=0;_edgd < len (_gead ._gafbe );_edgd ++{_dfbae :=_gead ._gafbe [_edgd ];if _gcbf {if _gdcf !=_dfbae ._ccbe {if _gdcf !=GridRowSectionUnknown {_fdbg (_ffga );};_gdcf =_dfbae ._ccbe ;_gggf =_gead .addSectionTag (_gdcf );_faefe (_ffga ,&_cd .StructureTagInfo {Mcid :_cccb ,StructureType :_eaec [_gdcf ]});
_cccb ++;};_ecbf :=_cd .StructureTypeTableRow ;_faefe (_ffga ,&_cd .StructureTagInfo {Mcid :_cccb ,StructureType :_ecbf });_dfbae .AddTag (_gggf );_cccb ++;};_eegbb :=float64 (0.0);for _acda :=_cbca ;_acda < _dfbae ._bfeeg ;_acda ++{_eegbb +=_gead ._gafbe [_acda ]._fede ;
};ctx .Height =_feeee -_eegbb ;if _ggfc {_fcgaa =append (_fcgaa ,_ffga );_ffga =NewBlock (ctx .PageWidth ,ctx .PageHeight );_eddg =ctx .Margins .Left +_gead ._eacc .Left ;_adgd =ctx .Margins .Top ;ctx .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
ctx .Page ++;_feeee =ctx .Height ;_cbca =_edgd ;_eegbb =0;_ggfc =false ;};if _dfbae ._fede > ctx .Height {_aacd :=_gead .cloneRow (_dfbae ._bfeeg );_dedca :=false ;for _ddgf ,_badef :=range _dfbae ._adgg {switch _cbgb :=_badef ._ddad .(type ){case *StyledParagraph :_geec :=ctx ;
_geec .Height =_bd .Floor (ctx .Height -_cbgb ._acgdg .Top -_cbgb ._acgdg .Bottom -0.5*_cbgb .getTextHeight ());_ecfea ,_ffgg ,_eefac :=_cbgb .split (_geec );if _eefac !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eefac );};if _ecfea !=nil &&_ffgg !=nil &&_aacd !=nil {_badef .SetContent (_ecfea );
_aacd ._adgg [_ddgf ].SetContent (_ffgg );_dedca =true ;};case *Division :_dcee :=ctx ;_dcee .Height =_bd .Floor (ctx .Height -_cbgb ._gadc .Top -_cbgb ._gadc .Bottom );_ggbf ,_aafda :=_cbgb .split (_dcee );if _ggbf !=nil &&_aafda !=nil &&_aacd !=nil {_badef .SetContent (_ggbf );
_aacd ._adgg [_ddgf ].SetContent (_aafda );_dedca =true ;};case *List :_ggaf :=ctx ;_ggaf .Height =_bd .Floor (ctx .Height -_cbgb ._bcefc .Vertical ());_aecad ,_cacc :=_cbgb .split (_ggaf );if _aecad !=nil &&_cacc !=nil &&_aacd !=nil {_badef .SetContent (_aecad );
_aacd ._adgg [_ddgf ].SetContent (_cacc );_dedca =true ;};};};_ggfc =true ;if _dedca {_gead .insertRowAfter (_dfbae ._bfeeg ,_aacd );_dfbae .updateRowHeight (_adaf );_aacd .updateRowHeight (_adaf );}else {_edgd -=1;continue ;};};for _ ,_eaaa :=range _dfbae ._adgg {var _cace *_cd .KDict ;
if _gcbf {_eaaa .SetMarkedContentID (_cccb );_fced :=_cd .StructureTypeTableData ;if _dfbae .IsHeader (){_fced =_cd .StructureTypeTableHeaderCell ;};_eaaa .SetStructureType (_fced );_faefe (_ffga ,&_cd .StructureTagInfo {Mcid :_cccb ,StructureType :_fced });
_cace =_cd .NewKDictionary ();_cace .S =_cdf .MakeName (string (_fced ));_ggbdf :=_cd .NewKValue ();_ggbdf .SetMCID (int (_cccb ));_cace .AddChild (_ggbdf );_dfbae ._ddda .ComponentKObj .AddKChild (_cace );_cccb ++;};_fagg :=_eaaa .width (_gead ._gded ,_adaf );
_deged :=float64 (0.0);for _bfgd :=0;_bfgd < _eaaa ._gebd ;_bfgd ++{_deged +=_gead ._gded [_bfgd ]*_adaf ;};_egff :=float64 (0.0);for _ddgd :=0;_ddgd < _eaaa ._fdca ;_ddgd ++{_egff +=_gead ._gafbe [_eaaa ._affb +_ddgd ]._fede ;};ctx .Width =_fagg ;ctx .X =_eddg +_deged ;
ctx .Y =_adgd +_eegbb ;_bdfdc :=_aaf (ctx .X ,ctx .Y ,_fagg ,_egff );if _eaaa ._adfc !=nil {_bdfdc .SetFillColor (_eaaa ._adfc );};_bdfdc .SetOpacity (_eaaa ._gfafe );_bdfdc .LineStyle =_eaaa ._adfcb ;_bdfdc ._bffb =_eaaa ._bbbb ;_bdfdc ._bdf =_eaaa ._bdd ;
_bdfdc ._dbda =_eaaa ._dfcd ;_bdfdc ._cff =_eaaa ._eegca ;if _eaaa ._bbcda !=nil {_bdfdc .SetColorLeft (_eaaa ._bbcda );};if _eaaa ._feaeg !=nil {_bdfdc .SetColorBottom (_eaaa ._feaeg );};if _eaaa ._cfbg !=nil {_bdfdc .SetColorRight (_eaaa ._cfbg );};if _eaaa ._eeada !=nil {_bdfdc .SetColorTop (_eaaa ._eeada );
};_bdfdc .SetWidthBottom (_eaaa ._efbfef );_bdfdc .SetWidthLeft (_eaaa ._bfaa );_bdfdc .SetWidthRight (_eaaa ._edadde );_bdfdc .SetWidthTop (_eaaa ._bbdaf );_caedb :=_ffga .Draw (_bdfdc );if _caedb !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_caedb );
};if _eaaa ._ddad !=nil {_bdefc :=_eaaa ._ddad .Width ();_gaged :=_eaaa ._ddad .Height ();_bdefc ,_gaged ,_fefd ,_eefd ,_gacae ,_babe :=_bceca (_eaaa ._ddad ,_bdefc ,_gaged ,_eaaa ._efdb ,false ,_cace ,_cccb ,_fagg );if _babe !=nil {return nil ,ctx ,_babe ;
};if _eefd !=nil {if !_gacae {_cace .AddKChild (_eefd );};_cccb ++;};switch _eaaa ._bbga {case CellHorizontalAlignmentLeft :ctx .X +=_eaaa ._dedf ;ctx .Width -=_eaaa ._dedf ;case CellHorizontalAlignmentCenter :if _aabf :=_fagg -_bdefc ;_aabf > 0{ctx .X +=_aabf /2;
ctx .Width -=_aabf /2;};case CellHorizontalAlignmentRight :if _fagg > _bdefc {ctx .X =ctx .X +_fagg -_bdefc -_eaaa ._dedf ;ctx .Width -=_eaaa ._dedf ;};};_eaab :=ctx .Y ;_cafd :=ctx .Height ;ctx .Y +=_fefd ;switch _eaaa ._efdb {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _ebec :=_egff -_gaged ;
_ebec > 0{ctx .Y +=_ebec /2;ctx .Height -=_ebec /2;};case CellVerticalAlignmentBottom :if _egff > _gaged {ctx .Y =ctx .Y +_egff -_gaged ;ctx .Height =_egff ;};};_babe =_ffga .DrawWithContext (_eaaa ._ddad ,ctx );if _babe !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_babe );
};ctx .Y =_eaab ;ctx .Height =_cafd ;};if _gcbf {_fdbg (_ffga );};};ctx .Y +=_dfbae ._fede ;if _gcbf {_fdbg (_ffga );};};if _gcbf {if _gdcf !=GridRowSectionUnknown {_fdbg (_ffga );};_fdbg (_ffga );};_fcgaa =append (_fcgaa ,_ffga );if _gead ._dgda .IsAbsolute (){return _fcgaa ,_gbff ,nil ;
};ctx .X =_gbff .X ;ctx .Width =_gbff .Width ;ctx .Y +=_gead ._eacc .Bottom ;ctx .Height -=_gead ._eacc .Bottom ;return _fcgaa ,ctx ,nil ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ea .ChartRenderable )*Chart {return _fef (chart )};

// SetTextExpansion sets the text expansion for the text chunk.
func (_eecfg *TextChunk )SetTextExpansion (text string ){_eecfg ._gdaff =&text };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_ddfg rune ;_cedd []error ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_agfdb *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_agfdb ._ccabb {_fge .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _fab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_agfdb ._fefea =widths ;return nil ;};

// SetFillColor sets the fill color of the ellipse.
func (_cdccf *Ellipse )SetFillColor (col Color ){_cdccf ._beg =col };

// SetStructureType sets the structure type for the drawable.
func (_cdcc *taggedDrawable )SetStructureType (structureType _cd .StructureType ){if _cdcc ._aefb ==nil {_cdcc ._aefb =_cd .NewStructureTagInfo ();};_cdcc ._aefb .StructureType =structureType ;};

// Style returns the style of the line.
func (_dgge *Line )Style ()_ggb .LineStyle {return _dgge ._fdcg };func (_gfbb *StyledParagraph )appendChunk (_adgde *TextChunk )*TextChunk {_gfbb ._bcebd =append (_gfbb ._bcebd ,_adgde );_gfbb .wrapText ();return _adgde ;};

// AddSection adds a new content section at the end of the invoice.
func (_ecfg *Invoice )AddSection (title ,content string ){_ecfg ._begf =append (_ecfg ._begf ,[2]string {title ,content });};func _gcfd (_gadff *Block ,_dbfd *Paragraph ,_fecd DrawContext )(DrawContext ,error ){_cbea :=1;_ccadb :=_cdf .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_cbea ));
for _gadff ._gaa .HasFontByName (_ccadb ){_cbea ++;_ccadb =_cdf .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_cbea ));};_geca :=_gadff ._gaa .SetFontByName (_ccadb ,_dbfd ._gcfa .ToPdfObject ());if _geca !=nil {return _fecd ,_geca ;};_dbfd .wrapText ();
_febe :=_fgc .NewContentCreator ();_febe .Add_q ();_fedga :=_fag .RoundDefault (_fecd .PageHeight -_fecd .Y -_dbfd ._dgdde *_dbfd ._fbdcb );_febe .Translate (_fecd .X ,_fedga );if _dbfd ._ebfdg !=0{_febe .RotateDeg (_dbfd ._ebfdg );};_cgba :=_acac (_dbfd ._fdae );
_geca =_dbdga (_gadff ,_cgba ,_dbfd ._fdae ,func ()Rectangle {return Rectangle {_bdcc :_fecd .X ,_dbgd :_fedga ,_bfed :_dbfd .getMaxLineWidth ()/1000.0,_abdcf :_dbfd .Height ()};});if _geca !=nil {return _fecd ,_geca ;};_febe .Add_BT ();_fgcg :=map[string ]_cdf .PdfObject {};
if _dbfd ._aefb !=nil {_fgcg ["\u004d\u0043\u0049\u0044"]=_cdf .MakeInteger (_dbfd ._aefb .Mcid );};if _dbfd ._fegef !=""{_fgcg ["\u004c\u0061\u006e\u0067"]=_cdf .MakeString (_dbfd ._fegef );};if len (_fgcg )> 0{_febe .Add_BDC (*_cdf .MakeName (string (_dbfd ._aefb .StructureType )),_fgcg );
};_febe .SetNonStrokingColor (_cgba ).Add_Tf (_ccadb ,_dbfd ._dgdde ).Add_TL (_dbfd ._dgdde *_dbfd ._fbdcb );for _faggc ,_cegaf :=range _dbfd ._dcfdd {if _faggc !=0{_febe .Add_Tstar ();};_fega :=[]rune (_cegaf );_fcgg :=0.0;_caea :=0;for _cdaee ,_bdbd :=range _fega {if _bdbd ==' '{_caea ++;
continue ;};if _bdbd =='\u000A'{continue ;};_dgdac ,_gbba :=_dbfd ._gcfa .GetRuneMetrics (_bdbd );if !_gbba {_fge .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_cdaee ,_bdbd ,_bdbd ,_dbfd ._gcfa .BaseFont (),_dbfd ._gcfa .Subtype ());
return _fecd ,_fab .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_fcgg +=_dbfd ._dgdde *_dgdac .Wx ;};var _ggdga []_cdf .PdfObject ;_gffgf ,_baceaa :=_dbfd ._gcfa .GetRuneMetrics (' ');
if !_baceaa {return _fecd ,_fab .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_fcbe :=_gffgf .Wx ;switch _dbfd ._aegb {case TextAlignmentJustify :if _caea > 0&&_faggc < len (_dbfd ._dcfdd )-1{_fcbe =(_dbfd ._efbe *1000.0-_fcgg )/float64 (_caea )/_dbfd ._dgdde ;
};case TextAlignmentCenter :_bcad :=_fcgg +float64 (_caea )*_fcbe *_dbfd ._dgdde ;_dadb :=_fag .RoundDefault ((_dbfd ._efbe *1000.0-_bcad )/2/_dbfd ._dgdde );_ggdga =append (_ggdga ,_cdf .MakeFloat (-_dadb ));case TextAlignmentRight :_adbc :=_fcgg +float64 (_caea )*_fcbe *_dbfd ._dgdde ;
_gfed :=_fag .RoundDefault ((_dbfd ._efbe *1000.0-_adbc )/_dbfd ._dgdde );_ggdga =append (_ggdga ,_cdf .MakeFloat (-_gfed ));};_gbgeg :=_dbfd ._gcfa .Encoder ();var _fdcc []byte ;for _ ,_dcac :=range _fega {if _dcac =='\u000A'{continue ;};if _dcac ==' '{if len (_fdcc )> 0{_ggdga =append (_ggdga ,_cdf .MakeStringFromBytes (_fdcc ));
_fdcc =nil ;};_ggdga =append (_ggdga ,_cdf .MakeFloat (-_fcbe ));}else {if _ ,_ggcf :=_gbgeg .RuneToCharcode (_dcac );!_ggcf {_geca =UnsupportedRuneError {Message :_a .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_dcac ,_dcac ),Rune :_dcac };
_fecd ._cedd =append (_fecd ._cedd ,_geca );_fge .Log .Debug (_geca .Error ());if _fecd ._ddfg <=0{continue ;};_dcac =_fecd ._ddfg ;};_fdcc =append (_fdcc ,_gbgeg .Encode (string (_dcac ))...);};};if len (_fdcc )> 0{_ggdga =append (_ggdga ,_cdf .MakeStringFromBytes (_fdcc ));
};_febe .Add_TJ (_ggdga ...);};if len (_fgcg )> 0{_febe .Add_EMC ();};_febe .Add_ET ();_febe .Add_Q ();_eacb :=_febe .Operations ();_eacb .WrapIfNeeded ();_gadff .addWrappedContents (_eacb );if _dbfd ._bgcg .IsRelative (){_dagc :=_dbfd .Height ();_fecd .Y =_fag .RoundDefault (_fecd .Y +_dagc );
_fecd .Height =_fag .RoundDefault (_fecd .Height -_dagc );if _fecd .Inline {_fecd .X =_fag .RoundDefault (_fecd .X +_dbfd .Width ()+_dbfd ._dcfd .Right );};};return _fecd ,nil ;};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_ebaf *shading )SetExtends (start bool ,end bool ){_ebaf ._fcce =[]bool {start ,end }};

// Positioning returns the type of positioning the rectangle is set to use.
func (_beace *Rectangle )Positioning ()Positioning {return _beace ._afbe };

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_agca *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_agca ._egaeg =dashArray ;_agca ._cbce =dashPhase ;};

// FitMode returns the fit mode of the line.
func (_fbgfd *Line )FitMode ()FitMode {return _fbgfd ._bded };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_cdbf *Image )SetWidth (w float64 ){_cdbf ._dbdfea =w };const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetBorderWidth sets the border width of the rectangle.
func (_cdce *Rectangle )SetBorderWidth (bw float64 ){_cdce ._effb =bw };

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_dccc *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dccc ._ffdg .Left ,_dccc ._ffdg .Right ,_dccc ._ffdg .Top ,_dccc ._ffdg .Bottom ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_gbbd *GraphicSVG )Scale (xFactor ,yFactor float64 ){_gbbd ._dcdb .Width =xFactor *_gbbd ._dcdb .Width ;_gbbd ._dcdb .Height =yFactor *_gbbd ._dcdb .Height ;_gbbd ._dcdb .SetScaling (xFactor ,yFactor );};

// Height returns the total height of all rows.
func (_bfbb *Grid )Height ()float64 {_aaaee :=float64 (0.0);for _ ,_ddbc :=range _bfbb ._gafbe {_aaaee +=_ddbc ._dada ;};return _aaaee ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_bdbe *Creator )NewPage ()*_cd .PdfPage {_bgd :=_bdbe .newPage ();_bdbe ._agdb =append (_bdbe ._agdb ,_bgd );_bdbe ._fga .Page ++;return _bgd ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_gede DrawContext )([]*Block ,DrawContext ,error );

// SetMarkedContentID sets the marked content id for the drawable.
SetMarkedContentID (_eggf int64 );

// SetStructureType sets the structure type for the drawable.
SetStructureType (_bfeb _cd .StructureType );

// GenerateKDict generates a K dictionary for the drawable.
GenerateKDict ()(*_cd .KDict ,error );

// SetStructPageNumber sets the page number where the structure element for this drawable is located.
SetStructPageNumber (_bbda *int64 );};func (_gddfe *Command )isAbsolute ()bool {return _gddfe .Symbol ==_gg .ToUpper (_gddfe .Symbol )};type grayColor struct{_adae float64 };func _cgbfc (_ggafe *templateProcessor ,_dcce *templateNode )(interface{},error ){return _ggafe .parseListMarker (_dcce );
};func _gaade (_faabg string )([]float64 ,error ){_aaffg :=-1;var _fffa []float64 ;_bbcfa :=' ';for _cgbag ,_dcefe :=range _faabg {if !_gaf .IsNumber (_dcefe )&&_dcefe !='.'&&!(_dcefe =='-'&&_bbcfa =='e')&&_dcefe !='e'{if _aaffg !=-1{_cggd ,_bffee :=_gfdf (_faabg [_aaffg :_cgbag ]);
if _bffee !=nil {return _fffa ,_bffee ;};_fffa =append (_fffa ,_cggd ...);};if _dcefe =='-'{_aaffg =_cgbag ;}else {_aaffg =-1;};}else if _aaffg ==-1{_aaffg =_cgbag ;};_bbcfa =_dcefe ;};if _aaffg !=-1&&_aaffg !=len (_faabg ){_bgacd ,_edfcb :=_gfdf (_faabg [_aaffg :]);
if _edfcb !=nil {return _fffa ,_edfcb ;};_fffa =append (_fffa ,_bgacd ...);};return _fffa ,nil ;};func _faagd (_aeaf ,_acgcf ,_dfabe float64 )(_ddgbd ,_dggfe ,_acgde ,_fegdf float64 ){if _dfabe ==0{return 0,0,_aeaf ,_acgcf ;};_fccac :=_ggb .Path {Points :[]_ggb .Point {_ggb .NewPoint (0,0).Rotate (_dfabe ),_ggb .NewPoint (_aeaf ,0).Rotate (_dfabe ),_ggb .NewPoint (0,_acgcf ).Rotate (_dfabe ),_ggb .NewPoint (_aeaf ,_acgcf ).Rotate (_dfabe )}}.GetBoundingBox ();
return _fccac .X ,_fccac .Y ,_fccac .Width ,_fccac .Height ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_fabeg *Line )SetColor (color Color ){_fabeg ._bgec =color };

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_cebbb *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _cebbb ._ecggf ==nil {if _gbbdb :=_cebbb .makeXObject ();_gbbdb !=nil {return nil ,ctx ,_gbbdb ;};};var _egfa []*Block ;_ebfcf :=ctx ;_cagb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _cebbb ._adde .IsRelative (){_cebbb .applyFitMode (ctx .Width );ctx .X +=_cebbb ._begc .Left ;ctx .Y +=_cebbb ._begc .Top ;ctx .Width -=_cebbb ._begc .Left +_cebbb ._begc .Right ;ctx .Height -=_cebbb ._begc .Top +_cebbb ._begc .Bottom ;if _cebbb ._eafg > ctx .Height {_egfa =append (_egfa ,_cagb );
_cagb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fcgd :=ctx ;_fcgd .Y =ctx .Margins .Top +_cebbb ._begc .Top ;_fcgd .X =ctx .Margins .Left +_cebbb ._begc .Left ;_fcgd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cebbb ._begc .Top -_cebbb ._begc .Bottom ;
_fcgd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cebbb ._begc .Left -_cebbb ._begc .Right ;ctx =_fcgd ;};}else {ctx .X =_cebbb ._aeaef ;ctx .Y =_cebbb ._dbgg ;};ctx ,_bcae :=_gbfd (_cagb ,_cebbb ,ctx );if _bcae !=nil {return nil ,ctx ,_bcae ;
};_egfa =append (_egfa ,_cagb );if _cebbb ._adde .IsAbsolute (){ctx =_ebfcf ;}else {ctx .X =_ebfcf .X ;ctx .Width =_ebfcf .Width ;ctx .Y +=_cebbb ._begc .Bottom ;};return _egfa ,ctx ,nil ;};func _cccf (_dbfa string ,_gafgc TextStyle )*Paragraph {_feefa :=&Paragraph {_egda :_dbfa ,_gcfa :_gafgc .Font ,_dgdde :_gafgc .FontSize ,_fbdcb :1.0,_fabc :true ,_bdag :true ,_aegb :TextAlignmentLeft ,_ebfdg :0,_dafa :1,_abgdf :1,_bgcg :PositionRelative ,_fegef :""};
_feefa .SetColor (_gafgc .Color );_feefa ._efgb =_cd .StructureTypeParagraph ;return _feefa ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_bafb *StyledParagraph )SetWidth (width float64 ){_bafb ._fcced =width ;_bafb .wrapText ()};

// SetColor sets the line color.
func (_dab *Curve )SetColor (col Color ){_dab ._agbd =col };

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _beed ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_ffd :=&Creator {};_ffd ._agdb =[]*_cd .PdfPage {};_ffd ._dfdg =map[*_cd .PdfPage ]*Block {};_ffd ._bdb =map[*_cd .PdfPage ]*pageTransformations {};_ffd .SetPageSize (PageSizeLetter );
_ade :=0.1*_ffd ._ebgd ;_ffd ._ecba .Left =_ade ;_ffd ._ecba .Right =_ade ;_ffd ._ecba .Top =_ade ;_ffd ._ecba .Bottom =_ade ;var _bcca error ;_ffd ._ccbd ,_bcca =_cd .NewStandard14Font (_cd .HelveticaName );if _bcca !=nil {_ffd ._ccbd =_cd .DefaultFont ();
};_ffd ._aefg ,_bcca =_cd .NewStandard14Font (_cd .HelveticaBoldName );if _bcca !=nil {_ffd ._ccbd =_cd .DefaultFont ();};_ffd ._gege =_ffd .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_ffd .AddOutlines =true ;
_ffd ._fff =_cd .NewOutline ();_ffd .AutofixPageContentStream =true ;_dg .TrackUse (_beed );return _ffd ;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_accb *Line )SetFitMode (fitMode FitMode ){_accb ._bded =fitMode };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_eegdc *Image )SetPos (x ,y float64 ){_eegdc ._adde =PositionAbsolute ;_eegdc ._aeaef =x ;_eegdc ._dbgg =y ;};

// SetAlternateText sets the alternate text for the image.
func (_gfgb *Image )SetAlternateText (text string ){_gfgb ._fbdc =text };

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_bfac *Table )MultiCell (rowspan ,colspan int )*TableCell {_bfac ._gecgc ++;_gacf :=(_bfac .moveToNextAvailableCell ()-1)%(_bfac ._ccabb )+1;_ffagd :=(_bfac ._gecgc -1)/_bfac ._ccabb +1;for _ffagd > _bfac ._ecga {_bfac ._ecga ++;_bfac ._fgege =append (_bfac ._fgege ,_bfac ._eecff );
};_fcfga :=&TableCell {};_fcfga ._cfdga =_ffagd ;_fcfga ._ebgdb =_gacf ;_fcfga ._efgb =_cd .StructureTypeTableData ;_fcfga ._aefb =_cd .NewStructureTagInfo ();_fcfga ._aefb .StructureType =_cd .StructureTypeTableData ;_fcfga ._bdgg =5;_fcfga ._bgcac =CellBorderStyleNone ;
_fcfga ._cfbf =_ggb .LineStyleSolid ;_fcfga ._eeea =CellHorizontalAlignmentLeft ;_fcfga ._bcag =CellVerticalAlignmentTop ;_fcfga ._agdfa =0;_fcfga ._gdff =0;_fcfga ._cdfba =0;_fcfga ._geadb =0;_cecg :=ColorBlack ;_fcfga ._fbgff =_cecg ;_fcfga ._gfdc =_cecg ;
_fcfga ._feddc =_cecg ;_fcfga ._fgaeaf =_cecg ;_fcfga ._eecec =1.0;if rowspan < 1{_fge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_cgegb :=_bfac ._ecga -(_fcfga ._cfdga -1);if rowspan > _cgegb {_fge .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_cgegb );
_bfac ._ecga +=rowspan -1;for _dcef :=0;_dcef <=rowspan -_cgegb ;_dcef ++{_bfac ._fgege =append (_bfac ._fgege ,_bfac ._eecff );};};for _bdeb :=0;_bdeb < colspan &&_gacf +_bdeb -1< len (_bfac ._fgff );_bdeb ++{_bfac ._fgff [_gacf +_bdeb -1]=rowspan -1;
};_fcfga ._aecg =rowspan ;if colspan < 1{_fge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_fceda :=_bfac ._ccabb -(_fcfga ._ebgdb -1);if colspan > _fceda {_fge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_fceda );
colspan =_fceda ;};_fcfga ._gfeff =colspan ;_bfac ._gecgc +=colspan -1;_bfac ._dfcec =append (_bfac ._dfcec ,_fcfga );_fcfga ._acgc =_bfac ;return _fcfga ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _bcbd (color ,point )};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_fafe *Invoice )SetNoteStyle (style TextStyle ){_fafe ._acef =style };

// SetSideBorderStyle sets the cell's side border style.
func (_affd *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_affd ._cfddd =style ;_affd ._cfbc =style ;_affd ._bgcac =style ;_affd ._eedc =style ;case CellBorderSideTop :_affd ._cfddd =style ;
case CellBorderSideBottom :_affd ._cfbc =style ;case CellBorderSideLeft :_affd ._bgcac =style ;case CellBorderSideRight :_affd ._eedc =style ;};};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _f .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_bg .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_cd .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_cd .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ea .ChartRenderable ;};func _bfgab (_dcdead ,_bdegc ,_egeag string ,_edfba uint ,_gfdgg TextStyle )*TOCLine {return _gabfd (TextChunk {Text :_dcdead ,Style :_gfdgg },TextChunk {Text :_bdegc ,Style :_gfdgg },TextChunk {Text :_egeag ,Style :_gfdgg },_edfba ,_gfdgg );
};

// SetFillColor sets the fill color.
func (_eeed *Polygon )SetFillColor (color Color ){_eeed ._fcfd =color ;_eeed ._agaga .FillColor =_acac (color );};func _cgbge (_gcabg *GraphicSVGElement ,_efbae *_fgc .ContentCreator ){_gccgc ,_adcad :=_gcabg .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];
if _adcad {_dcbde :=_gg .Fields (_gccgc );for _ ,_bdefg :=range _dcbde {_dbagb :=_gg .FieldsFunc (_bdefg ,_dffed );if len (_dbagb )< 3{_fge .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gccgc );
return ;};_eegga ,_gebfa :=_gfgbeb (_dbagb [1],64);if _gebfa !=nil {_fge .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gccgc );
return ;};_bgfff ,_gebfa :=_gfgbeb (_dbagb [2],64);if _gebfa !=nil {_fge .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gccgc );
return ;};if _dbagb [0]=="\u0074r\u0061\u006e\u0073\u006c\u0061\u0074e"{_efbae .Translate (_eegga ,_bgfff );}else if _dbagb [0]=="\u0073\u0063\u0061l\u0065"{_efbae .Scale (_eegga ,_bgfff );}else {_fge .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gccgc );
return ;};};};};

// Margins returns the margins of the list: left, right, top, bottom.
func (_beba *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _beba ._bcefc .Left ,_beba ._bcefc .Right ,_beba ._bcefc .Top ,_beba ._bcefc .Bottom ;};func (_beea *Division )drawBackground (_eggdg []*Block ,_dbde ,_gceb DrawContext ,_bcdec bool )([]*Block ,error ){_babg :=len (_eggdg );
if _babg ==0||_beea ._aebdf ==nil {return _eggdg ,nil ;};_dcc :=make ([]*Block ,0,len (_eggdg ));for _ddaea ,_afdfe :=range _eggdg {var (_egdf =_beea ._aebdf .BorderRadiusTopLeft ;_acdd =_beea ._aebdf .BorderRadiusTopRight ;_aaaf =_beea ._aebdf .BorderRadiusBottomLeft ;
_egac =_beea ._aebdf .BorderRadiusBottomRight ;);_ffae :=_dbde ;_ffae .Page +=_ddaea ;if _ddaea ==0{if _bcdec {_dcc =append (_dcc ,_afdfe );continue ;};if _babg ==1{_ffae .Height =_gceb .Y -_dbde .Y ;};}else {_ffae .X =_ffae .Margins .Left +_beea ._gadc .Left ;
_ffae .Y =_ffae .Margins .Top ;_ffae .Width =_ffae .PageWidth -_ffae .Margins .Left -_ffae .Margins .Right -_beea ._gadc .Left -_beea ._gadc .Right ;if _ddaea ==_babg -1{_ffae .Height =_gceb .Y -_ffae .Margins .Top -_beea ._gadc .Top ;}else {_ffae .Height =_ffae .PageHeight -_ffae .Margins .Top -_ffae .Margins .Bottom ;
};if !_bcdec {_egdf =0;_acdd =0;};};if _babg > 1&&_ddaea !=_babg -1{_aaaf =0;_egac =0;};_fcdf :=_fddb (_ffae .X ,_ffae .Y ,_ffae .Width ,_ffae .Height );_fcdf .SetFillColor (_beea ._aebdf .FillColor );_fcdf .SetBorderColor (_beea ._aebdf .BorderColor );
_fcdf .SetBorderWidth (_beea ._aebdf .BorderSize );_fcdf .SetBorderRadius (_egdf ,_acdd ,_aaaf ,_egac );_gcba ,_ ,_bcgd :=_fcdf .GeneratePageBlocks (_ffae );if _bcgd !=nil {return nil ,_bcgd ;};if len (_gcba )==0{continue ;};_cedc :=_gcba [0];if _bcgd =_cedc .mergeBlocks (_afdfe );
_bcgd !=nil {return nil ,_bcgd ;};_dcc =append (_dcc ,_cedc );};return _dcc ,nil ;};func (_cage *Table )addRowTag ()*_cd .KDict {_aaefg :=_cd .NewKDictionary ();_aaefg .S =_cdf .MakeName (string (_cd .StructureTypeTableRow ));_cage ._aefb .ComponentKObj .AddKChild (_aaefg );
return _aaefg ;};

// Context returns the current drawing context.
func (_bacg *Creator )Context ()DrawContext {return _bacg ._fga };

// IsHeader returns whether this row is a header row.
func (_ecff *GridRow )IsHeader ()bool {return _ecff ._ccbe ==GridRowSectionHeader };

// SetMargins sets the margins of the paragraph.
func (_bdec *List )SetMargins (left ,right ,top ,bottom float64 ){_bdec ._bcefc .Left =left ;_bdec ._bcefc .Right =right ;_bdec ._bcefc .Top =top ;_bdec ._bcefc .Bottom =bottom ;};

// SetStyleTop sets border style for top side.
func (_dfcc *border )SetStyleTop (style CellBorderStyle ){_dfcc ._dbda =style };func (_gcdc *StyledParagraph )addLine (_dbgeb []*TextChunk )bool {if _gcdc ._befa > 0&&len (_gcdc ._adcf )+1>=_gcdc ._befa {if len (_dbgeb )> 0{_gcdc ._adcf =append (_gcdc ._adcf ,_dbgeb );
};return false ;};_gcdc ._adcf =append (_gcdc ._adcf ,_dbgeb );return true ;};

// MarkAsArtifact marks the paragraph as an artifact of the specified type.
//
// This would override regular structure tagging and accessibility
// properties, and the paragraph will be treated as an artifact in the PDF.
func (_ebbg *StyledParagraph )MarkAsArtifact (artifactType _cd .ArtifactType )*_cd .Artifact {_ebbg ._deafc =&_cd .Artifact {Type :artifactType };return _ebbg ._deafc ;};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_cbaad *Rectangle )GetCoords ()(float64 ,float64 ){return _cbaad ._bdcc ,_cbaad ._dbgd };

// BuyerAddress returns the buyer address used in the invoice template.
func (_cbbg *Invoice )BuyerAddress ()*InvoiceAddress {return _cbbg ._cabc };

// Append adds a new text chunk to the paragraph.
func (_fgacb *StyledParagraph )Append (text string )*TextChunk {_gbegcf :=NewTextChunk (text ,_fgacb ._eeac );return _fgacb .appendChunk (_gbegcf );};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_egae *Ellipse )BorderOpacity ()float64 {return _egae ._bdfd };

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_dgfb *Table )MultiRowCell (rowspan int )*TableCell {return _dgfb .MultiCell (rowspan ,1)};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_efddc Color ;_feag float64 ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_gegad *Invoice )SetNoteHeadingStyle (style TextStyle ){_gegad ._gebdb =style };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_ggaa *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_decf :=[2]*InvoiceCell {_ggaa .newCell (description ,_ggaa ._ebgc ),_ggaa .newCell (value ,_ggaa ._ebgc )};_ggaa ._bdgbg =append (_ggaa ._bdgbg ,_decf );return _decf [0],_decf [1];
};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_cfeg *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _fab .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _fab .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _fab .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_cfeg ._ffdag =true ;_cfeg ._egeab =startRow ;_cfeg ._gdab =endRow ;return nil ;};func (_ebcaad *TableCell )width (_ecafc []float64 ,_gffgd float64 )float64 {_caaec :=float64 (0.0);for _cacdb :=0;_cacdb < _ebcaad ._gfeff ;_cacdb ++{_caaec +=_ecafc [_ebcaad ._ebgdb +_cacdb -1];
};return _caaec *_gffgd ;};func _acga ()*PageBreak {return &PageBreak {}};func (_cbaa *Image )applyFitMode (_bccb float64 ){_bccb -=_cbaa ._begc .Left +_cbaa ._begc .Right ;switch _cbaa ._ebdf {case FitModeFillWidth :_cbaa .ScaleToWidth (_bccb );};};

// SetBorderWidth sets the border width.
func (_faae *Polygon )SetBorderWidth (borderWidth float64 ){_faae ._agaga .BorderWidth =borderWidth };func (_gegcb *templateProcessor )renderNode (_ceaff *templateNode )error {_bcaeg :=_ceaff ._bcacc ;if _bcaeg ==nil {return nil ;};_ecedb :=_ceaff ._bcaga .Name .Local ;
_geade ,_egfag :=_abadg [_ecedb ];if !_egfag {_gegcb .nodeLogDebug (_ceaff ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_ecedb );return nil ;};var _acfb interface{};
if _ceaff ._fbddd !=nil &&_ceaff ._fbddd ._bcacc !=nil {_efbbf :=_ceaff ._fbddd ._bcaga .Name .Local ;if _ ,_egfag =_geade ._fecba [_efbbf ];!_egfag {_gegcb .nodeLogDebug (_ceaff ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_efbbf ,_ecedb );
return _egfg ;};_acfb =_ceaff ._fbddd ._bcacc ;}else {_aaaedg :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _gegcb ._bgdf .(type ){case *Block :_aaaedg ="\u0062\u006c\u006fc\u006b";};if _ ,_egfag =_geade ._fecba [_aaaedg ];!_egfag {_gegcb .nodeLogDebug (_ceaff ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_aaaedg ,_ecedb );
return _egfg ;};_acfb =_gegcb ._bgdf ;};switch _eabba :=_acfb .(type ){case componentRenderer :_cacf ,_deca :=_bcaeg .(Drawable );if !_deca {_gegcb .nodeLogError (_ceaff ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_ecedb ,_bcaeg );
return _bgaag ;};_gaegc :=_eabba .Draw (_cacf );if _gaegc !=nil {return _gegcb .nodeError (_ceaff ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_ecedb ,_bcaeg ,_gaegc );
};case *Division :switch _gcfeb :=_bcaeg .(type ){case *Background :_eabba .SetBackground (_gcfeb );case VectorDrawable :_ccdea :=_eabba .Add (_gcfeb );if _ccdea !=nil {return _gegcb .nodeError (_ceaff ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_ecedb ,_bcaeg ,_ccdea );
};};case *TableCell :_eaedf ,_bafbd :=_bcaeg .(VectorDrawable );if !_bafbd {_gegcb .nodeLogError (_ceaff ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_ecedb ,_bcaeg );
return _bgaag ;};_bgagaa :=_eabba .SetContent (_eaedf );if _bgagaa !=nil {return _gegcb .nodeError (_ceaff ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_ecedb ,_bcaeg ,_bgagaa );
};case *StyledParagraph :_fdaad ,_adbcd :=_bcaeg .(*TextChunk );if !_adbcd {_gegcb .nodeLogError (_ceaff ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_ecedb ,_bcaeg );
return _bgaag ;};_eabba .appendChunk (_fdaad );case *Chapter :switch _fgceg :=_bcaeg .(type ){case *Chapter :return nil ;case *StyledParagraph :if _ceaff ._bcaga .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_bdedd :=_eabba .Add (_fgceg );if _bdedd !=nil {return _gegcb .nodeError (_ceaff ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_ecedb ,_bcaeg ,_bdedd );
};case Drawable :_gcgfg :=_eabba .Add (_fgceg );if _gcgfg !=nil {return _gegcb .nodeError (_ceaff ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_ecedb ,_bcaeg ,_gcgfg );
};};case *List :switch _eadedg :=_bcaeg .(type ){case *TextChunk :case *listItem :_eabba ._gecb =append (_eabba ._gecb ,_eadedg );default:_gegcb .nodeLogError (_ceaff ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ecedb ,_bcaeg );
};case *listItem :switch _edbd :=_bcaeg .(type ){case *TextChunk :case *StyledParagraph :_eabba ._gdcgce =_edbd ;case *List :if _edbd ._efab {_edbd ._bdge =15;};_eabba ._gdcgce =_edbd ;case *Image :_eabba ._gdcgce =_edbd ;case *Division :_eabba ._gdcgce =_edbd ;
case *Table :_eabba ._gdcgce =_edbd ;default:_gegcb .nodeLogError (_ceaff ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_ecedb ,_bcaeg );
return _bgaag ;};};return nil ;};

// Width returns Image's document width.
func (_acbg *Image )Width ()float64 {return _acbg ._dbdfea };

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// Height returns the Block's height.
func (_ge *Block )Height ()float64 {return _ge ._ff };func (_acfe *Invoice )generateInformationBlocks (_gfdge DrawContext )([]*Block ,DrawContext ,error ){_gebe :=_dgdda (_acfe ._dfeb );_gebe .SetMargins (0,0,0,20);_deaf :=_acfe .drawAddress (_acfe ._cfccb );
_deaf =append (_deaf ,_gebe );_deaf =append (_deaf ,_acfe .drawAddress (_acfe ._cabc )...);_fbca :=_ecg ();for _ ,_bdcab :=range _deaf {_fbca .Add (_bdcab );};_aadf :=_acfe .drawInformation ();_eggfb :=_gecca (2);_eggfb .SetMargins (0,0,25,0);_gdaa :=_eggfb .NewCell ();
_gdaa .SetIndent (0);_gdaa .SetContent (_fbca );_gdaa =_eggfb .NewCell ();_gdaa .SetContent (_aadf );return _eggfb .GeneratePageBlocks (_gfdge );};

// Scale scales the ellipse dimensions by the specified factors.
func (_fdab *Ellipse )Scale (xFactor ,yFactor float64 ){_fdab ._bgfbe =xFactor *_fdab ._bgfbe ;_fdab ._ffaee =yFactor *_fdab ._ffaee ;};func (_gaccg *StyledParagraph )wrapChunks (_fbagb bool )error {if !_gaccg ._bccfb ||int (_gaccg ._fcced )<=0{_gaccg ._adcf =[][]*TextChunk {_gaccg ._bcebd };
return nil ;};if _gaccg ._bgeb {_gaccg .wrapWordChunks ();};_gaccg ._adcf =[][]*TextChunk {};var _fbad []*TextChunk ;var _gdae float64 ;_gbgcc :=_gaf .IsSpace ;if !_fbagb {_gbgcc =func (rune )bool {return false };};_gdec :=_efdde (_gaccg ._fcced *1000.0,0.000001);
for _ ,_cbcff :=range _gaccg ._bcebd {_ebgg :=_cbcff .Style ;_dfcdd :=_cbcff ._badce ;_bbgf :=_cbcff .VerticalAlignment ;var (_bceg []rune ;_cffea []float64 ;);_ebeee :=_cdf .IsTextWriteDirectionLTR (_cbcff .Text );for _ ,_ecdad :=range _cbcff .Text {if _ecdad =='\u000A'{if !_fbagb {_bceg =append (_bceg ,_ecdad );
};_fbad =append (_fbad ,&TextChunk {taggedDrawable :_cbcff .taggedDrawable ,Text :_gg .TrimRightFunc (string (_bceg ),_gbgcc ),Style :_ebgg ,_badce :_faecg (_dfcdd ),VerticalAlignment :_bbgf ,_gdaff :_cbcff ._gdaff ,_eegdf :_cbcff ._eegdf ,_dgeff :_cbcff ._dgeff });
if _cgae :=_gaccg .addLine (_fbad );!_cgae {return nil ;};_fbad =nil ;_gdae =0;_bceg =nil ;_cffea =nil ;continue ;};_abag :=_ecdad ==' ';_abad ,_cfcg :=_ebgg .Font .GetRuneMetrics (_ecdad );if _abad .Wx ==0&&_ebgg .MultiFont !=nil ||_ebgg .MultiFont !=nil &&!_cfcg {_abad ,_cfcg =_ebgg .MultiFont .GetRuneMetrics (_ecdad );
};if !_cfcg {_fge .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ecdad );return _fab .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_abadc :=_ebgg .FontSize *_abad .Wx *_ebgg .horizontalScale ();_daaa :=_abadc ;if !_abag {_daaa =_abadc +_ebgg .CharSpacing *1000.0;};if _gdae +_abadc > _gdec {_effd :=-1;if !_abag {for _bebdf :=len (_bceg )-1;_bebdf >=0;_bebdf --{if _bceg [_bebdf ]==' '{_effd =_bebdf ;
break ;};};};if _gaccg ._bgeb {_edddb :=len (_fbad );if _edddb > 0{_fbad [_edddb -1].Text =_gg .TrimRightFunc (_fbad [_edddb -1].Text ,_gbgcc );_gaccg ._adcf =append (_gaccg ._adcf ,_fbad );_fbad =[]*TextChunk {};};_bceg =append (_bceg ,_ecdad );_cffea =append (_cffea ,_daaa );
if _effd >=0{_bceg =_bceg [_effd +1:];_cffea =_cffea [_effd +1:];};_gdae =0;for _ ,_gaga :=range _cffea {_gdae +=_gaga ;};if _gdae > _gdec {_fefe :=string (_bceg [:len (_bceg )-1]);_fefe =_cdf .FormatWriteDirectionLTR (_fefe ,_ebeee );if !_fbagb &&_abag {_fefe +="\u0020";
};_fbad =append (_fbad ,&TextChunk {taggedDrawable :_cbcff .taggedDrawable ,Text :_gg .TrimRightFunc (_fefe ,_gbgcc ),Style :_ebgg ,_badce :_faecg (_dfcdd ),VerticalAlignment :_bbgf ,_gdaff :_cbcff ._gdaff ,_eegdf :_cbcff ._eegdf ,_dgeff :_cbcff ._dgeff });
if _gbgcf :=_gaccg .addLine (_fbad );!_gbgcf {return nil ;};_fbad =[]*TextChunk {};_bceg =[]rune {_ecdad };_cffea =[]float64 {_daaa };_gdae =_daaa ;};continue ;};_dcdea :=string (_bceg );if _effd >=0{_dcdea =string (_bceg [0:_effd +1]);_bceg =_bceg [_effd +1:];
_bceg =append (_bceg ,_ecdad );_cffea =_cffea [_effd +1:];_cffea =append (_cffea ,_daaa );_gdae =0;for _ ,_gdfab :=range _cffea {_gdae +=_gdfab ;};}else {if _abag {_gdae =0;_bceg =[]rune {};_cffea =[]float64 {};}else {_gdae =_daaa ;_bceg =[]rune {_ecdad };
_cffea =[]float64 {_daaa };};};_dcdea =_cdf .FormatWriteDirectionLTR (_dcdea ,_ebeee );if !_fbagb &&_abag {_dcdea +="\u0020";};_fbad =append (_fbad ,&TextChunk {taggedDrawable :_cbcff .taggedDrawable ,Text :_gg .TrimRightFunc (_dcdea ,_gbgcc ),Style :_ebgg ,_badce :_faecg (_dfcdd ),VerticalAlignment :_bbgf ,_gdaff :_cbcff ._gdaff ,_eegdf :_cbcff ._eegdf ,_dgeff :_cbcff ._dgeff });
if _fcfc :=_gaccg .addLine (_fbad );!_fcfc {return nil ;};_fbad =[]*TextChunk {};}else {_gdae +=_daaa ;_bceg =append (_bceg ,_ecdad );_cffea =append (_cffea ,_daaa );};};if len (_bceg )> 0{_dffee :=_cdf .FormatWriteDirectionLTR (string (_bceg ),_ebeee );
_fbad =append (_fbad ,&TextChunk {taggedDrawable :_cbcff .taggedDrawable ,Text :_dffee ,Style :_ebgg ,_badce :_faecg (_dfcdd ),VerticalAlignment :_bbgf ,_gdaff :_cbcff ._gdaff ,_eegdf :_cbcff ._eegdf ,_dgeff :_cbcff ._dgeff });};};if len (_fbad )> 0{if _deda :=_gaccg .addLine (_fbad );
!_deda {return nil ;};};return nil ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_fadc *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_fadc ._decgc =&_cd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetFont sets the Paragraph's font.
func (_gdca *Paragraph )SetFont (font *_cd .PdfFont ){_gdca ._gcfa =font };

// SetWidthRight sets border width for right.
func (_acgf *border )SetWidthRight (bw float64 ){_acgf ._bbff =bw };

// SetStyleRight sets border style for right side.
func (_aec *border )SetStyleRight (style CellBorderStyle ){_aec ._bdf =style };

// Height returns the height of the line.
func (_fdff *Line )Height ()float64 {_bfec :=_fdff ._ebee ;if _fdff ._bacec ==_fdff ._bfdg {_bfec /=2;};return _bd .Abs (_fdff ._ebgdf -_fdff ._cbcf )+_bfec ;};

// FillColor returns the fill color of the ellipse.
func (_edfg *Ellipse )FillColor ()Color {return _edfg ._beg };

// SetStyleBottom sets border style for bottom side.
func (_bga *border )SetStyleBottom (style CellBorderStyle ){_bga ._cff =style };

// Width returns the width of the ellipse.
func (_cgea *Ellipse )Width ()float64 {return _cgea ._bgfbe };var _ebeb =_fg .MustCompile ("\u005c\u0064\u002b");

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;type templateTag struct{_fecba map[string ]struct{};_dfag func (*templateProcessor ,*templateNode )(interface{},error );};func (_bdc *Block )addContents (_efd *_fgc .ContentStreamOperations ){*_bdc ._fc =append (*_bdc ._fc ,*_efd ...);
};

// The Image type is used to draw an image onto PDF.
type Image struct{taggedDrawable ;_ecggf *_cd .XObjectImage ;_dbfc *_cd .Image ;_fbdc string ;_bgbef float64 ;_dbdfea ,_eafg float64 ;_gabe ,_agbff float64 ;_adde Positioning ;_ggda HorizontalAlignment ;_aeaef float64 ;_dbgg float64 ;_bdffe float64 ;_begc Margins ;
_aeaec ,_gaef float64 ;_gdcgc _cdf .StreamEncoder ;_ebdf FitMode ;_dbgf bool ;_bgge *_cd .Artifact ;};

// Width returns the cell's width based on the input draw context.
func (_ebbce *TableCell )Width (ctx DrawContext )float64 {_ebaae :=float64 (0.0);for _dgdcd :=0;_dgdcd < _ebbce ._gfeff ;_dgdcd ++{_ebaae +=_ebbce ._acgc ._fefea [_ebbce ._ebgdb +_dgdcd -1];};_agec :=ctx .Width *_ebaae ;return _agec ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{taggedDrawable ;_bcebd []*TextChunk ;_eeac TextStyle ;_adfa TextStyle ;_dffe TextAlignment ;_fcdg TextVerticalAlignment ;_dgbeg float64 ;_bccfb bool ;_fcced float64 ;_bgeb bool ;_befa int ;_agcga bool ;_eccfd TextOverflow ;_cebgb float64 ;
_acgdg Margins ;_cdaea Positioning ;_beacb float64 ;_decdca float64 ;_afefc float64 ;_deba float64 ;_adcf [][]*TextChunk ;_beab func (_fcba *StyledParagraph ,_caggb DrawContext );_cdeb string ;_deafc *_cd .Artifact ;};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_cdab *LinearShading )SetAngle (angle float64 ){_cdab ._bffe =angle };func (_efa *Creator )initContext (){_efa ._fga .X =_fag .RoundDefault (_efa ._ecba .Left );_efa ._fga .Y =_fag .RoundDefault (_efa ._ecba .Top );_efa ._fga .Width =_fag .RoundDefault (_efa ._ebgd -_efa ._ecba .Right -_efa ._ecba .Left );
_efa ._fga .Height =_fag .RoundDefault (_efa ._bda -_efa ._ecba .Bottom -_efa ._ecba .Top );_efa ._fga .PageHeight =_fag .RoundDefault (_efa ._bda );_efa ._fga .PageWidth =_fag .RoundDefault (_efa ._ebgd );_efa ._fga .Margins =_efa ._ecba ;_efa ._fga ._ddfg =_efa .UnsupportedCharacterReplacement ;
};func _efdde (_bfcca float64 ,_ecbfe float64 )float64 {return _bd .Round (_bfcca /_ecbfe )*_ecbfe };

// SetOpacity sets opacity for Image.
func (_gcfg *Image )SetOpacity (opacity float64 ){_gcfg ._bdffe =opacity };func _ageb (_cdd *Chapter ,_dfb *TOC ,_dae *_cd .Outline ,_gage string ,_acbc int ,_edag TextStyle )*Chapter {var _aad uint =1;if _cdd !=nil {_aad =_cdd ._gffb +1;};_faag :=&Chapter {_egg :_acbc ,_dfd :_gage ,_fbf :true ,_agfe :true ,_aagc :_cdd ,_fbfg :_dfb ,_dbb :_dae ,_ecbg :[]Drawable {},_gffb :_aad };
_fgcb :=_dgdda (_edag );_aecf :=_fgcb .SetText (_faag .headingText ());_aecf .Style =_edag ;_faag ._bebf =_fgcb ;return _faag ;};func (_eceg *Creator )newPage ()*_cd .PdfPage {_bgg :=_cd .NewPdfPage ();_fbae :=_eceg ._cga [0];_cbcc :=_eceg ._cga [1];_aaag :=_cd .PdfRectangle {Llx :0,Lly :0,Urx :_fbae ,Ury :_cbcc };
_bgg .MediaBox =&_aaag ;_eceg ._ebgd =_fbae ;_eceg ._bda =_cbcc ;_eceg .initContext ();return _bgg ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_daba *Invoice )Notes ()(string ,string ){return _daba ._eeadg [0],_daba ._eeadg [1]};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_gfec *Image )GetHorizontalAlignment ()HorizontalAlignment {return _gfec ._ggda };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_cd .PdfPage )(*Block ,error ){_af :=&Block {};_gf ,_dge :=page .GetAllContentStreams ();if _dge !=nil {return nil ,_dge ;};_eb :=_fgc .NewContentStreamParser (_gf );_gga ,_dge :=_eb .Parse ();if _dge !=nil {return nil ,_dge ;
};_gga .WrapIfNeeded ();_af ._fc =_gga ;if page .Resources !=nil {_af ._gaa =page .Resources ;}else {_af ._gaa =_cd .NewPdfPageResources ();};_fda ,_dge :=page .GetMediaBox ();if _dge !=nil {return nil ,_dge ;};if _fda .Llx !=0||_fda .Lly !=0{_af .translate (-_fda .Llx ,_fda .Lly );
};_af ._ce =_fda .Urx -_fda .Llx ;_af ._ff =_fda .Ury -_fda .Lly ;if page .Rotate !=nil {_af ._gc =-float64 (*page .Rotate );};return _af ,nil ;};func _abbda (_aggg *_ac .File )([]*_cd .PdfPage ,error ){_gcecb ,_cgcfb :=_cd .NewPdfReader (_aggg );if _cgcfb !=nil {return nil ,_cgcfb ;
};_eeda ,_cgcfb :=_gcecb .GetNumPages ();if _cgcfb !=nil {return nil ,_cgcfb ;};var _bedda []*_cd .PdfPage ;for _ggedc :=0;_ggedc < _eeda ;_ggedc ++{_dbgbe ,_gddgc :=_gcecb .GetPage (_ggedc +1);if _gddgc !=nil {return nil ,_gddgc ;};_bedda =append (_bedda ,_dbgbe );
};return _bedda ,nil ;};

// AddTag adds the table tag to the root K object.
func (_abfe *Table )AddTag (rootKObj *_cd .KDict ){if rootKObj ==nil {_fge .Log .Debug ("\u0054\u0061\u0062\u006ce\u003a\u0020\u0041\u0064\u0064\u0054\u0061\u0067\u0020c\u0061\u006c\u006c\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u0069\u006c\u0020\u0072\u006f\u006ft\u004b\u004f\u0062\u006a\u002c \u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0074\u0061\u0067\u0067\u0069\u006e\u0067\u002e");
return ;};if _abfe ._aefb ==nil {_abfe ._aefb =_cd .NewStructureTagInfo ();_abfe ._aefb .StructureType =_abfe ._efgb ;};_abfe ._aefb .ApplyTag =true ;_abfe ._aefb .ParentKObj =rootKObj ;_abfe ._aefb .ComponentKObj =_cd .NewKDictionary ();_abfe ._aefb .ComponentKObj .S =_cdf .MakeName (string (_abfe ._aefb .StructureType ));
_abfe ._aefb .ParentKObj .AddKChild (_abfe ._aefb .ComponentKObj );};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_egcfc *Line )Width ()float64 {return _bd .Abs (_egcfc ._bfdg -_egcfc ._bacec )};func (_ccffb *templateProcessor )parseLineStyleAttr (_baffg ,_fdaec string )_ggb .LineStyle {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_baffg ,_fdaec );
_bfaeb :=map[string ]_ggb .LineStyle {"\u0073\u006f\u006ci\u0064":_ggb .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_ggb .LineStyleDashed }[_fdaec ];return _bfaeb ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{taggedDrawable ;_dbdfe []_ggb .CubicBezierCurve ;FillEnabled bool ;_feaf Color ;BorderEnabled bool ;BorderWidth float64 ;_fbgc Color ;};

// BorderWidth returns the border width of the ellipse.
func (_baab *Ellipse )BorderWidth ()float64 {return _baab ._dffd };

// Height returns Image's document height.
func (_faeeg *Image )Height ()float64 {return _faeeg ._eafg };type templateNode struct{_bcacc interface{};_bcaga _gd .StartElement ;_fbddd *templateNode ;_aggca int ;_bbffb int ;_fedb int64 ;};func _cgfa ()*GraphicSVGStyle {return &GraphicSVGStyle {FillColor :"\u00230\u0030\u0030\u0030\u0030\u0030",StrokeColor :"",StrokeWidth :0,FillOpacity :1.0};
};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_bacc *Rectangle )Width ()float64 {return _bacc ._bfed };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_ffece *TOC )SetLineNumberStyle (style TextStyle ){_ffece ._cbgg =style };

// RemoveArtifact removes the artifact associated with the paragraph, if any.
func (_fegg *StyledParagraph )RemoveArtifact (){_fegg ._deafc =nil };func _cdcg (_edeg *templateProcessor ,_feca *templateNode )(interface{},error ){return _edeg .parseChapter (_feca );};

// FitMode returns the fit mode of the ellipse.
func (_caab *Ellipse )FitMode ()FitMode {return _caab ._aeae };func (_gbgccb *templateProcessor )parseRectangle (_egbg *templateNode )(interface{},error ){_fgagf :=_gbgccb .creator .NewRectangle (0,0,0,0);for _ ,_fcea :=range _egbg ._bcaga .Attr {_cagf :=_fcea .Value ;
switch _abbba :=_fcea .Name .Local ;_abbba {case "\u0078":_fgagf ._bdcc =_gbgccb .parseFloatAttr (_abbba ,_cagf );case "\u0079":_fgagf ._dbgd =_gbgccb .parseFloatAttr (_abbba ,_cagf );case "\u0077\u0069\u0064t\u0068":_fgagf .SetWidth (_gbgccb .parseFloatAttr (_abbba ,_cagf ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_fgagf .SetHeight (_gbgccb .parseFloatAttr (_abbba ,_cagf ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_fgagf .SetFillColor (_gbgccb .parseColorAttr (_abbba ,_cagf ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_fgagf .SetFillOpacity (_gbgccb .parseFloatAttr (_abbba ,_cagf ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_fgagf .SetBorderColor (_gbgccb .parseColorAttr (_abbba ,_cagf ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_fgagf .SetBorderOpacity (_gbgccb .parseFloatAttr (_abbba ,_cagf ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_fgagf .SetBorderWidth (_gbgccb .parseFloatAttr (_abbba ,_cagf ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_ddbcb ,_bcaag ,_fedgg ,_deebda :=_gbgccb .parseBorderRadiusAttr (_abbba ,_cagf );
_fgagf .SetBorderRadius (_ddbcb ,_bcaag ,_deebda ,_fedgg );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_fgagf ._cedf =_gbgccb .parseFloatAttr (_abbba ,_cagf );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_fgagf ._ebaa =_gbgccb .parseFloatAttr (_abbba ,_cagf );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_fgagf ._bdgee =_gbgccb .parseFloatAttr (_abbba ,_cagf );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_fgagf ._geeg =_gbgccb .parseFloatAttr (_abbba ,_cagf );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_fgagf .SetPositioning (_gbgccb .parsePositioningAttr (_abbba ,_cagf ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fgagf .SetFitMode (_gbgccb .parseFitModeAttr (_abbba ,_cagf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_adeef :=_gbgccb .parseMarginAttr (_abbba ,_cagf );
_fgagf .SetMargins (_adeef .Left ,_adeef .Right ,_adeef .Top ,_adeef .Bottom );default:_gbgccb .nodeLogDebug (_egbg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_abbba );
};};return _fgagf ,nil ;};func (_fadab *templateProcessor )parseStyledParagraph (_afadf *templateNode )(interface{},error ){_cgfef :=_fadab .creator .NewStyledParagraph ();for _ ,_gbdbg :=range _afadf ._bcaga .Attr {_adgc :=_gbdbg .Value ;switch _efcaf :=_gbdbg .Name .Local ;
_efcaf {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cgfef .SetTextAlignment (_fadab .parseTextAlignmentAttr (_efcaf ,_adgc ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cgfef .SetTextVerticalAlignment (_fadab .parseTextVerticalAlignmentAttr (_efcaf ,_adgc ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_cgfef .SetLineHeight (_fadab .parseFloatAttr (_efcaf ,_adgc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_babcb :=_fadab .parseMarginAttr (_efcaf ,_adgc );_cgfef .SetMargins (_babcb .Left ,_babcb .Right ,_babcb .Top ,_babcb .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_cgfef .SetEnableWrap (_fadab .parseBoolAttr (_efcaf ,_adgc ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_cgfef .EnableWordWrap (_fadab .parseBoolAttr (_efcaf ,_adgc ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_cgfef .SetTextOverflow (_fadab .parseTextOverflowAttr (_efcaf ,_adgc ));case "\u0078":_cgfef .SetPos (_fadab .parseFloatAttr (_efcaf ,_adgc ),_cgfef ._decdca );case "\u0079":_cgfef .SetPos (_cgfef ._beacb ,_fadab .parseFloatAttr (_efcaf ,_adgc ));
case "\u0061\u006e\u0067l\u0065":_cgfef .SetAngle (_fadab .parseFloatAttr (_efcaf ,_adgc ));default:_fadab .nodeLogDebug (_afadf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_efcaf );
};};return _cgfef ,nil ;};func _aegef (_cdddf int64 ,_dgaba ,_befaa ,_adgfa float64 ,_dgaf string )*_cd .PdfAnnotation {_edbecb :=_cd .NewPdfAnnotationLink ();_bfgbe :=_cd .NewBorderStyle ();_bfgbe .SetBorderWidth (0);_edbecb .BS =_bfgbe .ToPdfObject ();
if _cdddf < 0{_cdddf =0;};_edbecb .Dest =_cdf .MakeArray (_cdf .MakeInteger (_cdddf ),_cdf .MakeName ("\u0058\u0059\u005a"),_cdf .MakeFloat (_dgaba ),_cdf .MakeFloat (_befaa ),_cdf .MakeFloat (_adgfa ));if _dgaf !=""{_edbecb .Contents =_cdf .MakeString (_dgaf );
};return _edbecb .PdfAnnotation ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cadf *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _cadf ._bbbc [0],_cadf ._bbbc [1]};func (_accc *Division )split (_ccg DrawContext )(_abdg ,_bgbd *Division ){var (_ggfa float64 ;_fddf ,_fgbg []VectorDrawable ;);_agbde :=_ccg .Width -_accc ._gadc .Left -_accc ._gadc .Right -_accc ._egcf .Left -_accc ._egcf .Right ;
for _dbfb ,_fegbb :=range _accc ._decb {_ggfa +=_agbaa (_fegbb ,_agbde );if _ggfa < _ccg .Height {_fddf =append (_fddf ,_fegbb );}else {_fgbg =_accc ._decb [_dbfb :];break ;};};if len (_fddf )> 0{_abdg =_ecg ();*_abdg =*_accc ;_abdg ._decb =_fddf ;if _accc ._aebdf !=nil {_abdg ._aebdf =&Background {};
*_abdg ._aebdf =*_accc ._aebdf ;};};if len (_fgbg )> 0{_bgbd =_ecg ();*_bgbd =*_accc ;_bgbd ._decb =_fgbg ;if _accc ._aebdf !=nil {_bgbd ._aebdf =&Background {};*_bgbd ._aebdf =*_accc ._aebdf ;};};return _abdg ,_bgbd ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_cbdf *Image )SetEncoder (encoder _cdf .StreamEncoder ){_cbdf ._gdcgc =encoder };func (_cgfg *templateProcessor )parseTextChunk (_ffbfa *templateNode ,_ggbde *TextChunk )(interface{},error ){if _ffbfa ._fbddd ==nil {_cgfg .nodeLogError (_ffbfa ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_egfg ;};var (_eaca =_cgfg .creator .NewTextStyle ();_gbadf bool ;);for _ ,_dadaa :=range _ffbfa ._bcaga .Attr {if _dadaa .Name .Local =="\u006c\u0069\u006e\u006b"{_eabcbd ,_agde :=_ffbfa ._fbddd ._bcacc .(*StyledParagraph );if !_agde {_cgfg .nodeLogError (_ffbfa ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_gbadf =true ;}else {_eaca =_eabcbd ._adfa ;};break ;};};if _ggbde ==nil {_ggbde =NewTextChunk ("",_eaca );};for _ ,_afbba :=range _ffbfa ._bcaga .Attr {_gdcgd :=_afbba .Value ;switch _ffgd :=_afbba .Name .Local ;_ffgd {case "\u0063\u006f\u006co\u0072":_ggbde .Style .Color =_cgfg .parseColorAttr (_ffgd ,_gdcgd );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_ggbde .Style .OutlineColor =_cgfg .parseColorAttr (_ffgd ,_gdcgd );case "\u0066\u006f\u006e\u0074":_ggbde .Style .Font =_cgfg .parseFontAttr (_ffgd ,_gdcgd );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_ggbde .Style .FontSize =_cgfg .parseFloatAttr (_ffgd ,_gdcgd );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_ggbde .Style .OutlineSize =_cgfg .parseFloatAttr (_ffgd ,_gdcgd );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_ggbde .Style .CharSpacing =_cgfg .parseFloatAttr (_ffgd ,_gdcgd );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_ggbde .Style .HorizontalScaling =_cgfg .parseFloatAttr (_ffgd ,_gdcgd );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_ggbde .Style .RenderingMode =_cgfg .parseTextRenderingModeAttr (_ffgd ,_gdcgd );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_ggbde .Style .Underline =_cgfg .parseBoolAttr (_ffgd ,_gdcgd );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_ggbde .Style .UnderlineStyle .Color =_cgfg .parseColorAttr (_ffgd ,_gdcgd );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_ggbde .Style .UnderlineStyle .Offset =_cgfg .parseFloatAttr (_ffgd ,_gdcgd );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_ggbde .Style .UnderlineStyle .Thickness =_cgfg .parseFloatAttr (_ffgd ,_gdcgd );
case "\u006c\u0069\u006e\u006b":if !_gbadf {_ggbde .AddAnnotation (_cgfg .parseLinkAttr (_ffgd ,_gdcgd ));};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_ggbde .Style .TextRise =_cgfg .parseFloatAttr (_ffgd ,_gdcgd );default:_cgfg .nodeLogDebug (_ffbfa ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ffgd );
};};return _ggbde ,nil ;};func (_dedfa *GraphicSVGElement )drawPolygon (_bfbgd *_fgc .ContentCreator ,_cadae *_cd .PdfPageResources ){_bfbgd .Add_q ();_dedfa .Style .toContentStream (_bfbgd ,_cadae ,_dedfa );_egfdg ,_eggaf :=_gaade (_dedfa .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);
if _eggaf !=nil {_fge .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_eggaf );
return ;};if len (_egfdg )%2> 0{_fge .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _gfgfg :=0;_gfgfg < len (_egfdg );{if _gfgfg ==0{_bfbgd .Add_m (_egfdg [_gfgfg ]*_dedfa ._fgdg ,_egfdg [_gfgfg +1]*_dedfa ._fgdg );}else {_bfbgd .Add_l (_egfdg [_gfgfg ]*_dedfa ._fgdg ,_egfdg [_gfgfg +1]*_dedfa ._fgdg );};_gfgfg +=2;};_bfbgd .Add_l (_egfdg [0]*_dedfa ._fgdg ,_egfdg [1]*_dedfa ._fgdg );
_dedfa .Style .fillStroke (_bfbgd );_bfbgd .Add_h ();_bfbgd .Add_Q ();};var (_afaad =_fg .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_bgbdd =_fab .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_egfg =_fab .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_bgaag =_fab .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_geccd =_fab .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_cdfb *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cdfb ._ef .Left ,_cdfb ._ef .Right ,_cdfb ._ef .Top ,_cdfb ._ef .Bottom ;};

// AddHighlightedText adds a new highlighted text to the paragraph.
func (_cbged *StyledParagraph )AddHighlightedText (text string ,color Color ,alpha float64 )*TextChunk {_efgbc :=NewTextChunk (text ,_cbged ._eeac );_efgbc .Highlight (color ,alpha );return _cbged .appendChunk (_efgbc );};

// AddTag adds a tag to the list.
func (_aeeab *List )AddTag (rootKObj *_cd .KDict ){if _aeeab ._aefb ==nil {_aeeab ._aefb =_cd .NewStructureTagInfo ();_aeeab ._aefb .StructureType =_cd .StructureTypeList ;};_aeeab ._aefb .ApplyTag =true ;_aeeab ._aefb .ParentKObj =rootKObj ;};func _bagg (_fgaea *_gd .Decoder )(*GraphicSVGElement ,error ){for {_eacf ,_ggfbg :=_fgaea .Token ();
if _eacf ==nil &&_ggfbg ==_bg .EOF {break ;};if _ggfbg !=nil {return nil ,_ggfbg ;};switch _bfgeff :=_eacf .(type ){case _gd .StartElement :return _bdac (_bfgeff ),nil ;};};return &GraphicSVGElement {},nil ;};func (_egaec *templateProcessor )parseTextVerticalAlignmentAttr (_fbff ,_eddc string )TextVerticalAlignment {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fbff ,_eddc );
_cdecdb :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_eddc ];return _cdecdb ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_gfa *Creator )MoveRight (dx float64 ){_gfa ._fga .X +=dx };

// Height returns the height of the graphic svg.
func (_gdea *GraphicSVG )Height ()float64 {return _gdea ._dcdb .Height };var _abadg =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dfag :_efga },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_fecba :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_dfag :_gbbge },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dfag :_cdgfe },"\u0074\u0061\u0062l\u0065":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dfag :_aecdb },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_fecba :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_dfag :_dcff },"\u006c\u0069\u006e\u0065":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dfag :_bdee },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dfag :_cdgg },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dfag :_aceee },"\u0069\u006d\u0061g\u0065":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dfag :_bggcc },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dfag :_cdcg },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_fecba :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dfag :_gbdgf },"\u0063\u0068\u0061r\u0074":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dfag :_bbfc },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_dfag :_abbbf },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_fecba :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_dfag :_cffbc },"\u006c\u0069\u0073\u0074":&templateTag {_fecba :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dfag :_cbfdc },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_fecba :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_dfag :_caged },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_fecba :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_dfag :_cgbfc }};


// SetEnableWrap sets the line wrapping enabled flag.
func (_dbgb *StyledParagraph )SetEnableWrap (enableWrap bool ){_dbgb ._bccfb =enableWrap ;_dbgb ._agcga =false ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_aacfeb *RadialShading )SetExtends (start bool ,end bool ){_aacfeb ._ggbe .SetExtends (start ,end )};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_aabd *Paragraph )SetMaxLines (maxLines int ){_aabd ._dgbg =maxLines ;_aabd .wrapText ()};

// SetSellerAddress sets the seller address of the invoice.
func (_ceff *Invoice )SetSellerAddress (address *InvoiceAddress ){_ceff ._cfccb =address };

// MoveX moves the drawing context to absolute position x.
func (_afe *Creator )MoveX (x float64 ){_afe ._fga .X =x };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_baba *Creator )DrawTemplate (r _bg .Reader ,data interface{},options *TemplateOptions )error {return _dgcd (_baba ,r ,data ,options ,_baba );};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{taggedDrawable ;_fbac *_ggb .PolyBezierCurve ;_edfe float64 ;_eaecf float64 ;_bfae Color ;};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_fbgd *Chapter )Add (d Drawable )error {if Drawable (_fbgd )==d {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _fab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _efbc :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_fbgd ._ecbg =append (_fbgd ._ecbg ,d );case containerDrawable :_dce ,_dag :=_efbc .ContainerComponent (_fbgd );
if _dag !=nil {return _dag ;};_fbgd ._ecbg =append (_fbgd ._ecbg ,_dce );default:_fge .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _fab .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func _dbdga (_cbeb *Block ,_egdff _cd .PdfColor ,_cdaa Color ,_becdg func ()Rectangle )error {switch _befee :=_egdff .(type ){case *_cd .PdfColorPatternType2 :_abffea ,_bcfb :=_cdaa .(*LinearShading );if !_bcfb {return _a .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");
};_feac :=_becdg ();_abffea .SetBoundingBox (_feac ._bdcc ,_feac ._dbgd ,_feac ._bfed ,_feac ._abdcf );_fgeg ,_bgae :=_abffea .AddPatternResource (_cbeb );if _bgae !=nil {return _a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_bgae );
};_befee .PatternName =_fgeg ;case *_cd .PdfColorPatternType3 :_gbcg ,_gabf :=_cdaa .(*RadialShading );if !_gabf {return _a .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_agaf :=_becdg ();_gbcg .SetBoundingBox (_agaf ._bdcc ,_agaf ._dbgd ,_agaf ._bfed ,_agaf ._abdcf );_ebbff ,_efbbd :=_gbcg .AddPatternResource (_cbeb );if _efbbd !=nil {return _a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_efbbd );
};_befee .PatternName =_ebbff ;};return nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_dccce *List )Indent ()float64 {return _dccce ._bdge };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_aabc *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_aabc ._fcdg =align ;};

// SetNotes sets the notes section of the invoice.
func (_dgcg *Invoice )SetNotes (title ,content string ){_dgcg ._eeadg =[2]string {title ,content }};

// SetBorder sets the cell's border style.
func (_bfee *GridCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_bfee ._bbbb =CellBorderStyleSingle ;_bfee ._bfaa =width ;_bfee ._eegca =CellBorderStyleSingle ;_bfee ._efbfef =width ;
_bfee ._bdd =CellBorderStyleSingle ;_bfee ._edadde =width ;_bfee ._dfcd =CellBorderStyleSingle ;_bfee ._bbdaf =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_bfee ._bbbb =CellBorderStyleDouble ;_bfee ._bfaa =width ;_bfee ._eegca =CellBorderStyleDouble ;
_bfee ._efbfef =width ;_bfee ._bdd =CellBorderStyleDouble ;_bfee ._edadde =width ;_bfee ._dfcd =CellBorderStyleDouble ;_bfee ._bbdaf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_bfee ._bbbb =style ;
_bfee ._bfaa =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_bfee ._eegca =style ;_bfee ._efbfef =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_bfee ._bdd =style ;
_bfee ._edadde =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_bfee ._dfcd =style ;_bfee ._bbdaf =width ;};};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_bdce *Creator )AddPage (page *_cd .PdfPage )error {if _bdce .AutofixPageContentStream {_ggfb ,_bdga :=_bdce .wrapPageIfNeeded (page );if _bdga !=nil {return _bdga ;};if _ggfb !=nil {page =_ggfb ;};};_ebab ,_ebef :=page .GetMediaBox ();if _ebef !=nil {_fge .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_ebef );
return _ebef ;};_ebab .Normalize ();_acadc ,_dbbd :=_ebab .Llx ,_ebab .Lly ;_eaef :=_ebab ;if _bdae :=page .CropBox ;_bdae !=nil &&*_bdae !=*_ebab {_bdae .Normalize ();_acadc ,_dbbd =_bdae .Llx ,_bdae .Lly ;_eaef =_bdae ;};_bdfe :=_cf .IdentityMatrix ();
_dfde ,_ebef :=page .GetRotate ();if _ebef !=nil {_fge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_ebef .Error ());
};_cdb :=_dfde %360!=0&&_dfde %90==0;if _cdb {_aege :=float64 ((360+_dfde %360)%360);switch _aege {case 90:_bdfe =_bdfe .Translate (_eaef .Width (),0);case 180:_bdfe =_bdfe .Translate (_eaef .Width (),_eaef .Height ());case 270:_bdfe =_bdfe .Translate (0,_eaef .Height ());
};_bdfe =_bdfe .Mult (_cf .RotationMatrix (_aege *_bd .Pi /180));_bdfe =_bdfe .Round (0.000001);_fabd :=_dbacf (_eaef ,_bdfe );_eaef =_fabd ;_eaef .Normalize ();};if _acadc !=0||_dbbd !=0{_bdfe =_cf .TranslationMatrix (_acadc ,_dbbd ).Mult (_bdfe );};if !_bdfe .Identity (){_bdfe =_bdfe .Round (0.000001);
_bdce ._bdb [page ]=&pageTransformations {_aafa :&_bdfe };};_bdce ._ebgd =_eaef .Width ();_bdce ._bda =_eaef .Height ();_bdce .initContext ();_bdce ._agdb =append (_bdce ._agdb ,page );_bdce ._fga .Page ++;return nil ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_bcef *Invoice )SetTerms (title ,content string ){_bcef ._bcggc =[2]string {title ,content }};

// SetBorderColor sets the border color.
func (_abdde *Polygon )SetBorderColor (color Color ){_abdde ._agaga .BorderColor =_acac (color )};func (_bfgc *pageTransformations )transformBlock (_dfcg *Block ){if _bfgc ._aafa !=nil {_dfcg .transform (*_bfgc ._aafa );};};func _cdbe (_beecf [][]_ggb .Point )*Polygon {return &Polygon {_agaga :&_ggb .Polygon {Points :_beecf },_cfab :1.0,_fdbe :1.0};
};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{taggedDrawable ;_ecga int ;_ccabb int ;_gecgc int ;_fefea []float64 ;_fgege []float64 ;_eecff float64 ;_dfcec []*TableCell ;_fgff []int ;_acbec Positioning ;_cgdfe ,_aabg float64 ;_ffegb Margins ;_ffdag bool ;_egeab int ;_gdab int ;_gefgf bool ;
_ddcg bool ;_dedfd bool ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_cdgb *Creator )DrawFooter (drawFooterFunc func (_cgeb *Block ,_aba FooterFunctionArgs )){_cdgb ._gdb =drawFooterFunc ;};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_fec *Ellipse )SetPositioning (position Positioning ){_fec ._dgc =position };

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_aaeaa *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_baeb *Ellipse )ScaleToWidth (w float64 ){_dgfg :=_baeb ._ffaee /_baeb ._bgfbe ;_baeb ._bgfbe =w ;_baeb ._ffaee =w *_dgfg ;};

// SetHeight sets the height of the ellipse.
func (_gfaf *Ellipse )SetHeight (height float64 ){_gfaf ._ffaee =height };

// SetBorderRadius sets the radius of the background corners.
func (_fb *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_fb .BorderRadiusTopLeft =topLeft ;_fb .BorderRadiusTopRight =topRight ;_fb .BorderRadiusBottomLeft =bottomLeft ;_fb .BorderRadiusBottomRight =bottomRight ;};func _bab (_gfeb ,_fdbad *_cd .PdfPageResources )error {_eda ,_ :=_gfeb .GetColorspaces ();
if _eda !=nil &&len (_eda .Colorspaces )> 0{for _cce ,_dga :=range _eda .Colorspaces {_dgdb :=*_cdf .MakeName (_cce );if _fdbad .HasColorspaceByName (_dgdb ){continue ;};_gff :=_fdbad .SetColorspaceByName (_dgdb ,_dga );if _gff !=nil {return _gff ;};};
};return nil ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_beag *Table )EnableRowWrap (enable bool ){_beag ._gefgf =enable };

// SetColPosition sets cell column position.
func (_cdbcc *TableCell )SetColPosition (col int ){_cdbcc ._ebgdb =col };

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_cgbefc *LinearShading )SetExtends (start bool ,end bool ){_cgbefc ._bedba .SetExtends (start ,end )};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_bgdbf *TOC )SetLineSeparatorStyle (style TextStyle ){_bgdbf ._acbdd =style };

// GetStructureType returns the structure type of this drawable.
func (_bgce *taggedDrawable )GetStructureType ()_cd .StructureType {return _bgce ._aefb .StructureType };func (_dbcg *GridRow )updateRowHeight (_ccge float64 ){_dbcg ._fede =_dbcg ._dada ;for _ ,_edgg :=range _dbcg ._adgg {_fada :=_edgg .width (_dbcg ._cbgd ._gded ,_ccge );
_bccg :=_edgg .height (_fada );if _bccg > _dbcg ._fede {_dbcg ._fede =_bccg ;};};};func _bgfa (_ffbe *_cd .Image )(*Image ,error ){_faac :=float64 (_ffbe .Width );_gbcb :=float64 (_ffbe .Height );return &Image {_dbfc :_ffbe ,_gabe :_faac ,_agbff :_gbcb ,_dbdfea :_faac ,_eafg :_gbcb ,_bgbef :0,_bdffe :1.0,_adde :PositionRelative ,taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeFigure }},nil ;
};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_cbcd *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_baaba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcf ,_dacdc :=_baaba .setOpacity (_cbcd ._becd ,_cbcd ._becd );if _dacdc !=nil {return nil ,ctx ,_dacdc ;};
_geeb :=_cbcd ._gbgg .Points ;for _ebcea :=range _geeb {_baea :=&_geeb [_ebcea ];_baea .Y =ctx .PageHeight -_baea .Y ;};_dbcgd ,_ ,_dacdc :=_cbcd ._gbgg .MarkedDraw (_bcf ,_cbcd ._aefb );if _dacdc !=nil {return nil ,ctx ,_dacdc ;};if _dacdc =_baaba .addContentsByString (string (_dbcgd ));
_dacdc !=nil {return nil ,ctx ,_dacdc ;};return []*Block {_baaba },ctx ,nil ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_bgga *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _gabfd (number ,title ,page ,level ,style );};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_agdba *Creator )SetOptimizer (optimizer _cd .Optimizer ){_agdba ._ecaf =optimizer };func (_fcbed *Table )resetColumnWidths (){_fcbed ._fefea =[]float64 {};_geabdd :=float64 (1.0)/float64 (_fcbed ._ccabb );for _fgbdb :=0;_fgbdb < _fcbed ._ccabb ;
_fgbdb ++{_fcbed ._fefea =append (_fcbed ._fefea ,_geabdd );};};

// Write output of creator to io.Writer interface.
func (_ddae *Creator )Write (ws _bg .Writer )error {if _aaae :=_ddae .Finalize ();_aaae !=nil {return _aaae ;};_bcde :="";if _eafac ,_afbc :=ws .(*_ac .File );_afbc {_bcde =_eafac .Name ();};_bdbg :=_cd .NewPdfWriter ();_bdbg .SetOptimizer (_ddae ._ecaf );
_bdbg .SetFileName (_bcde );if _ddae ._aegc !=nil {_cbfd :=_bdbg .SetForms (_ddae ._aegc );if _cbfd !=nil {_fge .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cbfd );return _cbfd ;};};if _ddae ._ddccc !=nil {_bdbg .AddOutlineTree (_ddae ._ddccc );
}else if _ddae ._fff !=nil &&_ddae .AddOutlines {_bdbg .AddOutlineTree (&_ddae ._fff .ToPdfOutline ().PdfOutlineTreeNode );};if _ddae ._fafg !=nil {if _eddb :=_bdbg .SetPageLabels (_ddae ._fafg );_eddb !=nil {_fge .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_eddb );
return _eddb ;};};if _ddae ._ebce !=nil {for _ ,_ffcd :=range _ddae ._ebce {_bgbe :=_ffcd .SubsetRegistered ();if _bgbe !=nil {_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_bgbe );
return _bgbe ;};};};if _ddae ._afdg &&_ddae ._gaaeb !=nil {_bdbg .SetCatalogMarkInfo (_cdf .MakeDictMap (map[string ]_cdf .PdfObject {"\u004d\u0061\u0072\u006b\u0065\u0064":_cdf .MakeBool (true )}));};if _ddae ._bfad !=nil {_ggbd :=_ddae ._bfad (&_bdbg );
if _ggbd !=nil {_fge .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_ggbd );return _ggbd ;};};for _gafe ,_gecgf :=range _ddae ._agdb {_adeb :=_bdbg .AddPage (_gecgf );if _adeb !=nil {_fge .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_adeb );
return _adeb ;};if _ddae ._gaaeb !=nil {if _ddae ._afdg {_gecgf .SetStructParentsKey (_gafe );};_gffbf :=_ddae ._gaaeb .K ;_efbb ,_bfag :=_bdbg .GetPageIndirectObject (_gafe );if _bfag !=nil {_fge .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0043\u006fu\u006c\u0064\u0020n\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061ge\u0020\u0069\u006ed\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074 \u0025\u0076",_bfag );
};var _egf func (_aafe *_cd .KDict );_egf =func (_cebc *_cd .KDict ){if _cebc ==nil {return ;};if _cebc .GetPageNumber ()-1==int64 (_gafe ){_cebc .SetPage (_efbb );};for _ ,_cdgf :=range _cebc .GetChildren (){if _ffed :=_cdgf .GetKDict ();_ffed !=nil {_egf (_ffed );
};};};for _ ,_cebec :=range _gffbf {_egf (_cebec );};};};if _ddae ._gaaeb !=nil {if _baad :=_bdbg .SetCatalogStructTreeRoot (_ddae ._gaaeb .ToPdfObject ());_baad !=nil {_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020n\u006f\u0074\u0020\u0073\u0065\u0074 \u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006ft\u003a\u0020\u0025\u0076",_baad );
return _baad ;};};if _ddae ._bdgb !=nil {if _dfdf :=_bdbg .SetCatalogViewerPreferences (_ddae ._bdgb .ToPdfObject ());_dfdf !=nil {_fge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074\u0020\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073\u003a\u0020\u0025\u0076",_dfdf );
return _dfdf ;};};if _ddae ._gdcd !=""{if _agad :=_bdbg .SetCatalogLanguage (_cdf .MakeString (_ddae ._gdcd ));_agad !=nil {_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065t\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006c\u0061\u006e\u0067\u0075\u0061\u0067\u0065\u003a\u0020\u0025\u0076",_agad );
return _agad ;};};_ceec :=_bdbg .Write (ws );if _ceec !=nil {return _ceec ;};return nil ;};func _gfgbeb (_gfgc string ,_bbffc int )(float64 ,error ){_gfeab ,_agecc :=_gdgcc (_gfgc );_ebaed ,_ceffg :=_c .ParseFloat (_gfeab ,_bbffc );if _ceffg !=nil {return 0,_ceffg ;
};if _fbcf ,_bfbae :=_fdbd [_agecc ];_bfbae {_ebaed =_ebaed *_fbcf ;}else {_ebaed =_ebaed *_afg ;};return _ebaed ,nil ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_fedg *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _bfgab (number ,title ,page ,level ,_fedg .NewTextStyle ());};

// This method is not supported by Chapter component and exists solely to satisfy the Drawable interface.
func (_deb *Chapter )SetStructureType (structureType _cd .StructureType ){};func (_cbaaa *Line )computeCoords (_cdbc DrawContext )(_edae ,_defa ,_aagdg ,_fgdf float64 ){_edae =_cdbc .X ;_aagdg =_edae +_cbaaa ._bfdg -_cbaaa ._bacec ;_fgga :=_cbaaa ._ebee ;
if _cbaaa ._bacec ==_cbaaa ._bfdg {_fgga /=2;};if _cbaaa ._cbcf < _cbaaa ._ebgdf {_defa =_cdbc .PageHeight -_cdbc .Y -_fgga ;_fgdf =_defa -_cbaaa ._ebgdf +_cbaaa ._cbcf ;}else {_fgdf =_cdbc .PageHeight -_cdbc .Y -_fgga ;_defa =_fgdf -_cbaaa ._cbcf +_cbaaa ._ebgdf ;
};switch _cbaaa ._bded {case FitModeFillWidth :_aagdg =_edae +_cdbc .Width ;};return _edae ,_defa ,_aagdg ,_fgdf ;};func _fbcb (_dbaa []_ggb .Point )*Polyline {return &Polyline {_gbgg :&_ggb .Polyline {Points :_dbaa ,LineColor :_cd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_becd :1.0};
};func _ccga (_ecfd ,_eecb TextStyle )*Invoice {_bffbb :=&Invoice {_egcc :"\u0049N\u0056\u004f\u0049\u0043\u0045",_fgagg :"\u002c\u0020",_dfeb :_ecfd ,_ebfd :_eecb };_bffbb ._cfccb =&InvoiceAddress {Separator :_bffbb ._fgagg };_bffbb ._cabc =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_bffbb ._fgagg };
_fceeb :=ColorRGBFrom8bit (245,245,245);_edaf :=ColorRGBFrom8bit (155,155,155);_bffbb ._gbgee =_eecb ;_bffbb ._gbgee .Color =_edaf ;_bffbb ._gbgee .FontSize =20;_bffbb ._fdcd =_ecfd ;_bffbb ._cabf =_eecb ;_bffbb ._acef =_ecfd ;_bffbb ._gebdb =_eecb ;_bffbb ._ebgc =_bffbb .NewCellProps ();
_bffbb ._ebgc .BackgroundColor =_fceeb ;_bffbb ._ebgc .TextStyle =_eecb ;_bffbb ._fdcdb =_bffbb .NewCellProps ();_bffbb ._fdcdb .TextStyle =_eecb ;_bffbb ._fdcdb .BackgroundColor =_fceeb ;_bffbb ._fdcdb .BorderColor =_fceeb ;_bffbb ._fabdg =_bffbb .NewCellProps ();
_bffbb ._fabdg .BorderColor =_fceeb ;_bffbb ._fabdg .BorderSides =[]CellBorderSide {CellBorderSideBottom };_bffbb ._fabdg .Alignment =CellHorizontalAlignmentRight ;_bffbb ._gaagg =_bffbb .NewCellProps ();_bffbb ._gaagg .Alignment =CellHorizontalAlignmentRight ;
_bffbb ._dcfg =[2]*InvoiceCell {_bffbb .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_bffbb ._ebgc ),_bffbb .newCell ("",_bffbb ._ebgc )};_bffbb ._gega =[2]*InvoiceCell {_bffbb .newCell ("\u0044\u0061\u0074\u0065",_bffbb ._ebgc ),_bffbb .newCell ("",_bffbb ._ebgc )};
_bffbb ._bbbc =[2]*InvoiceCell {_bffbb .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_bffbb ._ebgc ),_bffbb .newCell ("",_bffbb ._ebgc )};_bffbb ._fdfe =[2]*InvoiceCell {_bffbb .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_bffbb ._gaagg ),_bffbb .newCell ("",_bffbb ._gaagg )};
_daac :=_bffbb ._gaagg ;_daac .TextStyle =_eecb ;_daac .BackgroundColor =_fceeb ;_daac .BorderColor =_fceeb ;_bffbb ._eacee =[2]*InvoiceCell {_bffbb .newCell ("\u0054\u006f\u0074a\u006c",_daac ),_bffbb .newCell ("",_daac )};_bffbb ._eeadg =[2]string {"\u004e\u006f\u0074e\u0073",""};
_bffbb ._bcggc =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_bffbb ._bdfec =[]*InvoiceCell {_bffbb .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_bffbb .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_bffbb .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_bffbb .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _bffbb ;};func _ddd (_fed *_fgc .ContentStreamOperations ,_bfg *_cd .PdfPageResources ,_bbd *_fgc .ContentStreamOperations ,_ddef *_cd .PdfPageResources )error {_ege :=map[_cdf .PdfObjectName ]_cdf .PdfObjectName {};_fdbab :=map[_cdf .PdfObjectName ]_cdf .PdfObjectName {};
_bfge :=map[_cdf .PdfObjectName ]_cdf .PdfObjectName {};_acb :=map[_cdf .PdfObjectName ]_cdf .PdfObjectName {};_eca :=map[_cdf .PdfObjectName ]_cdf .PdfObjectName {};_ffe :=map[_cdf .PdfObjectName ]_cdf .PdfObjectName {};for _ ,_cef :=range *_bbd {switch _cef .Operand {case "\u0044\u006f":if len (_cef .Params )==1{if _ba ,_bff :=_cef .Params [0].(*_cdf .PdfObjectName );
_bff {if _ ,_dea :=_ege [*_ba ];!_dea {var _feb _cdf .PdfObjectName ;_bcd ,_ :=_ddef .GetXObjectByName (*_ba );if _bcd !=nil {_feb =*_ba ;for {_ecb ,_ :=_bfg .GetXObjectByName (_feb );if _ecb ==nil ||_ecb ==_bcd {break ;};_feb =*_cdf .MakeName (_gbd (_feb .String ()));
};};_bfg .SetXObjectByName (_feb ,_bcd );_ege [*_ba ]=_feb ;};_aff :=_ege [*_ba ];_cef .Params [0]=&_aff ;};};case "\u0054\u0066":if len (_cef .Params )==2{if _gace ,_eea :=_cef .Params [0].(*_cdf .PdfObjectName );_eea {if _ ,_def :=_fdbab [*_gace ];!_def {_gad ,_eeb :=_ddef .GetFontByName (*_gace );
_cb :=*_gace ;if _eeb &&_gad !=nil {_cb =_ebf (_gace .String (),_gad ,_bfg );};_bfg .SetFontByName (_cb ,_gad );_fdbab [*_gace ]=_cb ;};_dcb :=_fdbab [*_gace ];_cef .Params [0]=&_dcb ;};};case "\u0043\u0053","\u0063\u0073":if len (_cef .Params )==1{if _acad ,_bbc :=_cef .Params [0].(*_cdf .PdfObjectName );
_bbc {if _ ,_bcg :=_bfge [*_acad ];!_bcg {var _ffad _cdf .PdfObjectName ;_ega ,_bba :=_ddef .GetColorspaceByName (*_acad );if _bba {_ffad =*_acad ;for {_bfe ,_fca :=_bfg .GetColorspaceByName (_ffad );if !_fca ||_ega ==_bfe {break ;};_ffad =*_cdf .MakeName (_gbd (_ffad .String ()));
};_bfg .SetColorspaceByName (_ffad ,_ega );_bfge [*_acad ]=_ffad ;}else {_fge .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _dfe ,_bfa :=_bfge [*_acad ];_bfa {_cef .Params [0]=&_dfe ;
}else {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_acad );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_cef .Params )==1{if _cac ,_ccc :=_cef .Params [0].(*_cdf .PdfObjectName );
_ccc {if _ ,_ffab :=_acb [*_cac ];!_ffab {var _dead _cdf .PdfObjectName ;_gfdg ,_fgba :=_ddef .GetPatternByName (*_cac );if _fgba {_dead =*_cac ;for {_acag ,_aaa :=_bfg .GetPatternByName (_dead );if !_aaa ||_acag ==_gfdg {break ;};_dead =*_cdf .MakeName (_gbd (_dead .String ()));
};_fagb :=_bfg .SetPatternByName (_dead ,_gfdg .ToPdfObject ());if _fagb !=nil {return _fagb ;};_acb [*_cac ]=_dead ;};};if _cgd ,_bec :=_acb [*_cac ];_bec {_cef .Params [0]=&_cgd ;};};};case "\u0073\u0068":if len (_cef .Params )==1{if _bde ,_fcca :=_cef .Params [0].(*_cdf .PdfObjectName );
_fcca {if _ ,_fccf :=_eca [*_bde ];!_fccf {var _gab _cdf .PdfObjectName ;_aac ,_agf :=_ddef .GetShadingByName (*_bde );if _agf {_gab =*_bde ;for {_feg ,_egeg :=_bfg .GetShadingByName (_gab );if !_egeg ||_aac ==_feg {break ;};_gab =*_cdf .MakeName (_gbd (_gab .String ()));
};_agb :=_bfg .SetShadingByName (_gab ,_aac .ToPdfObject ());if _agb !=nil {_fge .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_agb );return _agb ;};_eca [*_bde ]=_gab ;}else {_fge .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");
};};if _bbdb ,_baa :=_eca [*_bde ];_baa {_cef .Params [0]=&_bbdb ;}else {_fge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_bde );};};};case "\u0067\u0073":if len (_cef .Params )==1{if _afa ,_gb :=_cef .Params [0].(*_cdf .PdfObjectName );
_gb {if _ ,_eebc :=_ffe [*_afa ];!_eebc {var _fgf _cdf .PdfObjectName ;_ceb ,_afc :=_ddef .GetExtGState (*_afa );if _afc {_fgf =*_afa ;for {_daf ,_ecf :=_bfg .GetExtGState (_fgf );if !_ecf ||_ceb ==_daf {break ;};_fgf =*_cdf .MakeName (_gbd (_fgf .String ()));
};};_bfg .AddExtGState (_fgf ,_ceb );_ffe [*_afa ]=_fgf ;};_cbc :=_ffe [*_afa ];_cef .Params [0]=&_cbc ;};};};*_fed =append (*_fed ,_cef );};return nil ;};

// SetLevel sets the indentation level of the TOC line.
func (_dbdfb *TOCLine )SetLevel (level uint ){_dbdfb ._feacc =level ;_dbdfb ._gbbaf ._acgdg .Left =_dbdfb ._ecece +float64 (_dbdfb ._feacc -1)*_dbdfb ._fdgca ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetWidthBottom sets border width for bottom.
func (_ggc *border )SetWidthBottom (bw float64 ){_ggc ._bbf =bw };func _fbaed (_gffd *_gd .Decoder )(int ,int ){return _gffd .InputPos ()};

// GetArtifact returns the artifact associated with the image, if any.
func (_bddgb *Image )GetArtifact ()*_cd .Artifact {return _bddgb ._bgge };

// MarkAsArtifact marks the image as an artifact of the specified type.
//
// This would override regular structure tagging and accessibility
// properties, and the image will be treated as an artifact in the PDF.
func (_bdbf *Image )MarkAsArtifact (artifactType _cd .ArtifactType )*_cd .Artifact {_bdbf ._bgge =&_cd .Artifact {Type :artifactType };return _bdbf ._bgge ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_gcf *Creator )NewChapter (title string )*Chapter {_gcf ._aeff ++;_dcbe :=_gcf .NewTextStyle ();_dcbe .FontSize =16;return _ageb (nil ,_gcf ._gege ,_gcf ._fff ,title ,_gcf ._aeff ,_dcbe );};

// Angle returns the block rotation angle in degrees.
func (_eba *Block )Angle ()float64 {return _eba ._gc };func _bbaf (_afbae float64 ,_egecg float64 ,_fbagg float64 ,_fdeb float64 ,_gabc []*ColorPoint )*RadialShading {return &RadialShading {_ggbe :&shading {_dcfb :ColorWhite ,_ggfe :false ,_fcce :[]bool {false ,false },_ecgf :_gabc },_cfde :_afbae ,_afgb :_egecg ,_gaad :_fbagg ,_febda :_fdeb ,_ccbcd :AnchorCenter };
};

// GetIndent get the cell's left indent.
func (_cddge *TableCell )GetIndent ()float64 {return _cddge ._bdgg };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// SetColorBottom sets border color for bottom.
func (_gea *border )SetColorBottom (col Color ){_gea ._aagb =col };

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_efefg *Division )Add (d VectorDrawable )error {switch _fdecc :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_fcd ,_bgaa :=_fdecc .ContainerComponent (_efefg );
if _bgaa !=nil {return _bgaa ;};_fcfe ,_acdc :=_fcd .(VectorDrawable );if !_acdc {return _a .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_fcd );
};d =_fcfe ;default:return _fab .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_efefg ._decb =append (_efefg ._decb ,d );return nil ;};const (CellBorderSideLeft CellBorderSide =iota ;
CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// TitleStyle returns the style properties used to render the invoice title.
func (_adbabc *Invoice )TitleStyle ()TextStyle {return _adbabc ._gbgee };

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_gggb *Line )SetMargins (left ,right ,top ,bottom float64 ){_gggb ._adac .Left =left ;_gggb ._adac .Right =right ;_gggb ._adac .Top =top ;_gggb ._adac .Bottom =bottom ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_ccfe *StyledParagraph )Height ()float64 {_ccfe .wrapText ();var _dgbc float64 ;for _ ,_badb :=range _ccfe ._adcf {var _eacd float64 ;for _ ,_dcedfe :=range _badb {_fgca :=_ccfe ._dgbeg *_dcedfe .Style .FontSize ;if _fgca > _eacd {_eacd =_fgca ;};
};_dgbc +=_eacd ;};return _dgbc ;};func (_gdbe *Invoice )GenerateKDict ()(*_cd .KDict ,error ){return nil ,nil };

// SetSection sets whether this row is a header row.
func (_ebebc *GridRow )SetSection (role GridRowSection ){_ebebc ._ccbe =role };

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_edafg *Rectangle )SetPositioning (position Positioning ){_edafg ._afbe =position };func (_afec *Invoice )SetStructPageNumber (pageNumber *int64 ){};func (_fgdaf *templateProcessor )parseLinkAttr (_gabca ,_gbaea string )*_cd .PdfAnnotation {_gbaea =_gg .TrimSpace (_gbaea );
if _gg .HasPrefix (_gbaea ,"\u0075\u0072\u006c(\u0027")&&_gg .HasSuffix (_gbaea ,"\u0027\u0029")&&len (_gbaea )> 7{return _egce (_gbaea [5:len (_gbaea )-2],"");};if _gg .HasPrefix (_gbaea ,"\u0070\u0061\u0067e\u0028")&&_gg .HasSuffix (_gbaea ,"\u0029")&&len (_gbaea )> 6{var (_ffaeb error ;
_facff int64 ;_eggag float64 ;_bbdff float64 ;_dedbc =1.0;_ddaaf =_gg .Split (_gbaea [5:len (_gbaea )-1],"\u002c"););_facff ,_ffaeb =_c .ParseInt (_gg .TrimSpace (_ddaaf [0]),10,64);if _ffaeb !=nil {_fge .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ffaeb );
return nil ;};if len (_ddaaf )>=2{_eggag ,_ffaeb =_c .ParseFloat (_gg .TrimSpace (_ddaaf [1]),64);if _ffaeb !=nil {_fge .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ffaeb );
return nil ;};};if len (_ddaaf )>=3{_bbdff ,_ffaeb =_c .ParseFloat (_gg .TrimSpace (_ddaaf [2]),64);if _ffaeb !=nil {_fge .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ffaeb );
return nil ;};};if len (_ddaaf )>=4{_dedbc ,_ffaeb =_c .ParseFloat (_gg .TrimSpace (_ddaaf [3]),64);if _ffaeb !=nil {_fge .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ffaeb );
return nil ;};};return _aegef (_facff -1,_eggag ,_bbdff ,_dedbc ,"");};return nil ;};

// AddColorStop add color stop info for rendering gradient color.
func (_deeg *LinearShading )AddColorStop (color Color ,point float64 ){_deeg ._bedba .AddColorStop (color ,point );};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_dcae *Invoice )Sections ()[][2]string {return _dcae ._begf };

// FitMode returns the fit mode of the image.
func (_bgdd *Image )FitMode ()FitMode {return _bgdd ._ebdf };

// SetHeight sets the height of the rectangle.
func (_geea *Rectangle )SetHeight (height float64 ){_geea ._abdcf =height };

// GeneratePageBlocks draws the chart onto a block.
func (_feef *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcg :=ctx ;_eaed :=_feef ._cgde .IsRelative ();var _gaae []*Block ;if _eaed {_aagcf :=1.0;_fcga :=_feef ._cfad .Top ;if float64 (_feef ._ggab .Height ())> ctx .Height -_feef ._cfad .Top {_gaae =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _bebb error ;if _ ,ctx ,_bebb =_acga ().GeneratePageBlocks (ctx );_bebb !=nil {return nil ,ctx ,_bebb ;};_fcga =0;};ctx .X +=_feef ._cfad .Left +_aagcf ;ctx .Y +=_fcga ;ctx .Width -=_feef ._cfad .Left +_feef ._cfad .Right +2*_aagcf ;ctx .Height -=_fcga ;
_feef ._ggab .SetWidth (int (ctx .Width ));}else {ctx .X =_feef ._cceb ;ctx .Y =_feef ._cfa ;};_edad :=_fgc .NewContentCreator ();if _feef ._aefb !=nil {_edad .Add_BDC (*_cdf .MakeName (string (_feef ._aefb .StructureType )),map[string ]_cdf .PdfObject {"\u004d\u0043\u0049\u0044":_cdf .MakeInteger (_feef ._aefb .Mcid )});
};_edad .Translate (0,ctx .PageHeight );_edad .Scale (1,-1);_edad .Translate (ctx .X ,ctx .Y );_edade :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_feef ._ggab .Render (_ae .NewRenderer (_edad ,_edade ._gaa ),nil );if _feef ._aefb !=nil {_edad .Add_EMC ();
};if _ceba :=_edade .addContentsByString (_edad .String ());_ceba !=nil {return nil ,ctx ,_ceba ;};if _eaed {_gada :=_feef .Height ()+_feef ._cfad .Bottom ;ctx .Y +=_gada ;ctx .Height -=_gada ;}else {ctx =_fcg ;};_gaae =append (_gaae ,_edade );return _gaae ,ctx ,nil ;
};

// RotatedSize returns the width and height of the rotated block.
func (_aea *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_gfd ,_gec :=_faagd (_aea ._ce ,_aea ._ff ,_aea ._gc );return _gfd ,_gec ;};func (_ffdga *Grid )updateRowHeights (_bdfdca float64 ){for _ ,_aecc :=range _ffdga ._gafbe {_aecc .updateRowHeight (_bdfdca );
};};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_bggfe *shading )SetBackgroundColor (backgroundColor Color ){_bggfe ._dcfb =backgroundColor };func _fegdc (_adfb ,_edeeg ,_bdfa ,_efda ,_ggde ,_gbfe float64 )*Curve {_afdf :=&Curve {};_afdf ._eee =_adfb ;_afdf ._fbdg =_edeeg ;_afdf ._bae =_bdfa ;
_afdf ._gdac =_efda ;_afdf ._cddf =_ggde ;_afdf ._aaec =_gbfe ;_afdf ._agbd =ColorBlack ;_afdf ._dbec =1.0;return _afdf ;};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_cafgf *Rectangle )SetBorderOpacity (opacity float64 ){_cafgf ._cbfae =opacity };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_gggeea *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_bfdcd ,_gdcge :=_gggeea .Wrap (width );if _gdcge !=nil {return nil ,_gdcge ;};_ecbdb :=int (height /_gggeea .Style .FontSize );if _ecbdb >=len (_bfdcd ){return nil ,nil ;};_gabcc :="\u000a";
_gggeea .Text =_gg .ReplaceAll (_gg .Join (_bfdcd [:_ecbdb ],"\u0020"),_gabcc +"\u0020",_gabcc );_eeceg :=_gg .ReplaceAll (_gg .Join (_bfdcd [_ecbdb :],"\u0020"),_gabcc +"\u0020",_gabcc );return NewTextChunk (_eeceg ,_gggeea .Style ),nil ;};type marginDrawable interface{VectorDrawable ;
GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// CreateTableOfContents sets a function to generate table of contents.
func (_ffcc *Creator )CreateTableOfContents (genTOCFunc func (_bea *TOC )error ){_ffcc ._aacf =genTOCFunc ;};func (_gbgdb *templateProcessor )parseTable (_faaef *templateNode )(interface{},error ){var _bdgcc int64 ;for _ ,_bfbbb :=range _faaef ._bcaga .Attr {_fabca :=_bfbbb .Value ;
switch _agfda :=_bfbbb .Name .Local ;_agfda {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_bdgcc =_gbgdb .parseInt64Attr (_agfda ,_fabca );};};if _bdgcc <=0{_gbgdb .nodeLogDebug (_faaef ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_bdgcc );
_bdgcc =1;};_eeaga :=_gbgdb .creator .NewTable (int (_bdgcc ));for _ ,_eaeff :=range _faaef ._bcaga .Attr {_gcebf :=_eaeff .Value ;switch _gdce :=_eaeff .Name .Local ;_gdce {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_eeaga .SetColumnWidths (_gbgdb .parseFloatArray (_gdce ,_gcebf )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_fdcad :=_gbgdb .parseMarginAttr (_gdce ,_gcebf );_eeaga .SetMargins (_fdcad .Left ,_fdcad .Right ,_fdcad .Top ,_fdcad .Bottom );case "\u0078":_eeaga .SetPos (_gbgdb .parseFloatAttr (_gdce ,_gcebf ),_eeaga ._aabg );
case "\u0079":_eeaga .SetPos (_eeaga ._cgdfe ,_gbgdb .parseFloatAttr (_gdce ,_gcebf ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_eeaga ._egeab =int (_gbgdb .parseInt64Attr (_gdce ,_gcebf ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_eeaga ._gdab =int (_gbgdb .parseInt64Attr (_gdce ,_gcebf ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_eeaga .EnableRowWrap (_gbgdb .parseBoolAttr (_gdce ,_gcebf ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_eeaga .EnablePageWrap (_gbgdb .parseBoolAttr (_gdce ,_gcebf ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_gbgdb .nodeLogDebug (_faaef ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_gdce );
};};if _eeaga ._egeab !=0&&_eeaga ._gdab !=0{_bcbc :=_eeaga .SetHeaderRows (_eeaga ._egeab ,_eeaga ._gdab );if _bcbc !=nil {_gbgdb .nodeLogDebug (_faaef ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_bcbc );
};}else {_eeaga ._egeab =0;_eeaga ._gdab =0;};return _eeaga ,nil ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_cdbd *LinearShading )AddShadingResource (block *Block )(_cbbe _cdf .PdfObjectName ,_ebafc error ){_ebegc :=1;_cbbe =_cdf .PdfObjectName ("\u0053\u0068"+_c .Itoa (_ebegc ));for block ._gaa .HasShadingByName (_cbbe ){_ebegc ++;_cbbe =_cdf .PdfObjectName ("\u0053\u0068"+_c .Itoa (_ebegc ));
};if _ecbe :=block ._gaa .SetShadingByName (_cbbe ,_cdbd .shadingModel ().ToPdfObject ());_ecbe !=nil {return "",_ecbe ;};return _cbbe ,nil ;};

// SetFontSize sets the font size in document units (points).
func (_agfd *Paragraph )SetFontSize (fontSize float64 ){_agfd ._dgdde =fontSize };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_eaaf *RadialShading )SetBackgroundColor (backgroundColor Color ){_eaaf ._ggbe .SetBackgroundColor (backgroundColor );};func (_cedcf *templateProcessor )parseFloatAttr (_dgeec ,_cfec string )float64 {_fge .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_dgeec ,_cfec );
_gdffg ,_ :=_c .ParseFloat (_cfec ,64);return _gdffg ;};func (_dgdc *GraphicSVGElement )toContentStream (_gddg *_fgc .ContentCreator ,_acf *_cd .PdfPageResources ){_aeac ,_dcg :=_cdee (_dgdc .Attributes ,_dgdc ._fgdg );if _dcg !=nil {_fge .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_dcg );
};_dgdc .Style =_aeac ;switch _dgdc .Name {case "\u0070\u0061\u0074\u0068":_dgdc .drawPath (_gddg ,_acf );for _ ,_gcafc :=range _dgdc .Children {_gcafc .toContentStream (_gddg ,_acf );};case "\u0072\u0065\u0063\u0074":_dgdc .drawRect (_gddg ,_acf );for _ ,_edbc :=range _dgdc .Children {_edbc .toContentStream (_gddg ,_acf );
};case "\u0063\u0069\u0072\u0063\u006c\u0065":_dgdc .drawCircle (_gddg ,_acf );for _ ,_afdef :=range _dgdc .Children {_afdef .toContentStream (_gddg ,_acf );};case "\u0065l\u006c\u0069\u0070\u0073\u0065":_dgdc .drawEllipse (_gddg ,_acf );for _ ,_gdba :=range _dgdc .Children {_gdba .toContentStream (_gddg ,_acf );
};case "\u0070\u006f\u006c\u0079\u006c\u0069\u006e\u0065":_dgdc .drawPolyline (_gddg ,_acf );for _ ,_gfda :=range _dgdc .Children {_gfda .toContentStream (_gddg ,_acf );};case "\u0070o\u006c\u0079\u0067\u006f\u006e":_dgdc .drawPolygon (_gddg ,_acf );for _ ,_dbcd :=range _dgdc .Children {_dbcd .toContentStream (_gddg ,_acf );
};case "\u006c\u0069\u006e\u0065":_dgdc .drawLine (_gddg ,_acf );for _ ,_bebc :=range _dgdc .Children {_bebc .toContentStream (_gddg ,_acf );};case "\u0074\u0065\u0078\u0074":_dgdc .drawText (_gddg ,_acf );for _ ,_geab :=range _dgdc .Children {_geab .toContentStream (_gddg ,_acf );
};case "\u0067":_dddc ,_ffbfg :=_dgdc .Attributes ["\u0066\u0069\u006c\u006c"];_agcg ,_baef :=_dgdc .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];_gccc ,_cdbgd :=_dgdc .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
_decgg ,_egcbg :=_dgdc .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];for _ ,_dcde :=range _dgdc .Children {if _ ,_cfgf :=_dcde .Attributes ["\u0066\u0069\u006c\u006c"];!_cfgf &&_ffbfg {_dcde .Attributes ["\u0066\u0069\u006c\u006c"]=_dddc ;
};if _ ,_ggaec :=_dcde .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];!_ggaec &&_baef {_dcde .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"]=_agcg ;};if _ ,_ebfcb :=_dcde .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
!_ebfcb &&_cdbgd {_dcde .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"]=_gccc ;};if _ ,_ggca :=_dcde .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];!_ggca &&_egcbg {_dcde .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"]=_decgg ;
};_dcde .toContentStream (_gddg ,_acf );};};};func (_efecb *Table )addListItemTag ()*_cd .KDict {_begfa :=_cd .NewKDictionary ();_begfa .S =_cdf .MakeName (string (_cd .StructureTypeListItem ));_efecb ._aefb .ComponentKObj .AddKChild (_begfa );return _begfa ;
};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{taggedDrawable ;

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_badce []*_cd .PdfAnnotation ;_dgefd []bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;_gdaff *string ;_eegdf *string ;_dgeff *string ;};func (_gdag *GraphicSVGElement )drawText (_ccbff *_fgc .ContentCreator ,_ccbba *_cd .PdfPageResources ){_ccbff .Add_BT ();_aeefe ,_adbdd :=_gfgbeb (_gdag .Attributes ["\u0078"],64);
if _adbdd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_adbdd .Error ());};_cdgfd ,_adbdd :=_gfgbeb (_gdag .Attributes ["\u0079"],64);
if _adbdd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_adbdd .Error ());};_ecadc :=_gdag .Attributes ["\u0066\u0069\u006c\u006c"];
var _aeffe ,_fadf ,_babec float64 ;if _eaded ,_agffd :=_ag .ColorMap [_ecadc ];_agffd {_egca ,_eaba ,_fggaf ,_ :=_eaded .RGBA ();_aeffe ,_fadf ,_babec =float64 (_egca ),float64 (_eaba ),float64 (_fggaf );}else if _gg .HasPrefix (_ecadc ,"\u0072\u0067\u0062\u0028"){_aeffe ,_fadf ,_babec =_cabe (_ecadc );
}else {_aeffe ,_fadf ,_babec =ColorRGBFromHex (_ecadc ).ToRGB ();};_ccbff .Add_rg (_aeffe ,_fadf ,_babec );_ecdee :=_adga ;if _cfaf ,_fcgbf :=_gdag .Attributes ["\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae"];_fcgbf {_ecdee ,_adbdd =_c .ParseFloat (_cfaf ,64);
if _adbdd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067 \u0060\u0066\u006f\u006e\u0074\u002d\u0073\u0069\u007a\u0065\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_adbdd .Error ());
_ecdee =_adga ;};};_afacb :=_gdag ._fgdg *_ecdee *PPI /_aecd ;_dcbb :=_cdf .PdfObjectName ("\u0053\u0046\u006fn\u0074");_eegg :=_cd .DefaultFont ();_eafd ,_deadbb :=_gdag .Attributes ["f\u006f\u006e\u0074\u002d\u0066\u0061\u006d\u0069\u006c\u0079"];if _deadbb {if _agffc ,_gdgf :=_dggd (_eafd );
_gdgf ==nil {_eegg =_agffc ;_gdbac :=1;for _ccbba .HasFontByName (_dcbb ){_dcbb =_cdf .PdfObjectName ("\u0053\u0046\u006fn\u0074"+_c .Itoa (_gdbac ));_gdbac ++;};};};_bbgbf :=0.0;_ffbgg ,_deadbb :=_gdag .Attributes ["t\u0065\u0078\u0074\u002d\u0061\u006e\u0063\u0068\u006f\u0072"];
if _deadbb &&_ffbgg !="\u0073\u0074\u0061r\u0074"{var _fbgfc float64 ;for _ ,_baeac :=range _gdag .Content {_fffb ,_cdebg :=_eegg .GetRuneMetrics (_baeac );if !_cdebg {_fge .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074e\u0064 \u0072u\u006e\u0065\u0020\u0025\u0076\u0020\u0069\u006e\u0020\u0066\u006f\u006e\u0074",_baeac );
};_fbgfc +=_fffb .Wx ;};_fbgfc =_fbgfc *_afacb /1000.0;if _ffbgg =="\u006d\u0069\u0064\u0064\u006c\u0065"{_bbgbf =-_fbgfc /2;}else if _ffbgg =="\u0065\u006e\u0064"{_bbgbf =-_fbgfc ;};};_ccbff .Add_Tm (1,0,0,-1,_aeefe *_gdag ._fgdg +_bbgbf ,_cdgfd *_gdag ._fgdg );
_ccbba .SetFontByName (_dcbb ,_eegg .ToPdfObject ());_ccbff .Add_Tf (_dcbb ,_afacb );_cfda :=_gdag .Content ;_ebaac :=_cdf .MakeString (_cfda );_ccbff .Add_Tj (*_ebaac );_ccbff .Add_ET ();};func _gbfd (_dcccd *Block ,_bfcc *Image ,_ecbb DrawContext )(DrawContext ,error ){_ebdb :=_ecbb ;
_gced :=1;_fcda :=_cdf .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_gced ));for _dcccd ._gaa .HasXObjectByName (_fcda ){_gced ++;_fcda =_cdf .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_gced ));};_ccca :=_dcccd ._gaa .SetXObjectImageByNameLazy (_fcda ,_bfcc ._ecggf ,_bfcc ._dbgf );
if _ccca !=nil {return _ecbb ,_ccca ;};_efge :=0;_eddgb :=_cdf .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_efge ));for _dcccd ._gaa .HasExtGState (_eddgb ){_efge ++;_eddgb =_cdf .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_efge ));
};_fbgcb :=_cdf .MakeDict ();_fbgcb .Set ("\u0042\u004d",_cdf .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _bfcc ._bdffe < 1.0{_fbgcb .Set ("\u0043\u0041",_cdf .MakeFloat (_bfcc ._bdffe ));_fbgcb .Set ("\u0063\u0061",_cdf .MakeFloat (_bfcc ._bdffe ));
};_ccca =_dcccd ._gaa .AddExtGState (_eddgb ,_cdf .MakeIndirectObject (_fbgcb ));if _ccca !=nil {return _ecbb ,_ccca ;};_dgbbe :=_bfcc .Width ();_ffda :=_bfcc .Height ();_ ,_dacg :=_bfcc .rotatedSize ();_dfcgg :=_ecbb .X ;_gbegc :=_ecbb .PageHeight -_ecbb .Y -_ffda ;
if _bfcc ._adde .IsRelative (){_gbegc -=(_dacg -_ffda )/2;switch _bfcc ._ggda {case HorizontalAlignmentCenter :_dfcgg +=(_ecbb .Width -_dgbbe )/2;case HorizontalAlignmentRight :_dfcgg =_ecbb .PageWidth -_ecbb .Margins .Right -_bfcc ._begc .Right -_dgbbe ;
};};_cged :=_bfcc ._bgbef ;_efca :=_fgc .NewContentCreator ();if _bfcc ._bgge ==nil {if _bfcc ._aefb !=nil {_efca .Add_BDC (*_cdf .MakeName (string (_bfcc ._aefb .StructureType )),map[string ]_cdf .PdfObject {"\u004d\u0043\u0049\u0044":_cdf .MakeInteger (_bfcc ._aefb .Mcid )});
};}else {_ecffc :=_bfcc ._bgge .GenerateMap ();if len (_ecffc )> 0{_efca .Add_BDC (*_cdf .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")),_ecffc );}else {_efca .Add_BMC (*_cdf .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")));
};};_efca .Add_gs (_eddgb );_efca .Translate (_dfcgg ,_gbegc );if _cged !=0{_efca .Translate (_dgbbe /2,_ffda /2);_efca .RotateDeg (_cged );_efca .Translate (-_dgbbe /2,-_ffda /2);};_efca .Scale (_dgbbe ,_ffda ).Add_Do (_fcda );if _bfcc ._aefb !=nil ||_bfcc ._bgge !=nil {_efca .Add_EMC ();
};_acgd :=_efca .Operations ();_acgd .WrapIfNeeded ();_dcccd .addWrappedContents (_acgd );if _bfcc ._adde .IsRelative (){_ecbb .Y +=_dacg ;_ecbb .Height -=_dacg ;return _ecbb ,nil ;};return _ebdb ,nil ;};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;
AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_agge *PageBreak )SetStructPageNumber (pageNumber *int64 ){};

// LinkTagOptions represents optional parameters for tagged link annotations,
// providing flexibility for adding accessibility features.
type LinkTagOptions struct{

// MCID is the marked content identifier for structure tree association
MCID int64 ;

// AltText is alternative text for screen readers (only used if different from visible text)
AltText string ;

// Tooltip sets the annotation's Contents field (tooltip on hover)
Tooltip string ;};

// SkipCells skips over a specified number of cells in the table.
func (_babcf *Table )SkipCells (num int ){if num < 0{_fge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _cfddb :=0;_cfddb < num ;_cfddb ++{_babcf .NewCell ();};};func (_bfged *GridCell )height (_cdaf float64 )float64 {var _gdeg float64 ;switch _aaga :=_bfged ._ddad .(type ){case *Paragraph :if _aaga ._fabc {_aaga .SetWidth (_cdaf -_bfged ._dedf -_aaga ._dcfd .Left -_aaga ._dcfd .Right );
};_gdeg =_aaga .Height ()+_aaga ._dcfd .Top +_aaga ._dcfd .Bottom ;case *StyledParagraph :if _aaga ._bccfb {_aaga .SetWidth (_cdaf -_bfged ._dedf -_aaga ._acgdg .Left -_aaga ._acgdg .Right );};_gdeg =_aaga .Height ()+_aaga ._acgdg .Top +_aaga ._acgdg .Bottom ;
case *Image :_aaga .applyFitMode (_cdaf -_bfged ._dedf );_gdeg =_aaga .Height ()+_aaga ._begc .Top +_aaga ._begc .Bottom ;case *Table :_aaga .updateRowHeights (_cdaf -_bfged ._dedf -_aaga ._ffegb .Left -_aaga ._ffegb .Right );_gdeg =_aaga .Height ()+_aaga ._ffegb .Top +_aaga ._ffegb .Bottom ;
case *List :_gdeg =_aaga .ctxHeight (_cdaf -_bfged ._dedf )+_aaga ._bcefc .Top +_aaga ._bcefc .Bottom ;case *Division :_gdeg =_aaga .ctxHeight (_cdaf -_bfged ._dedf )+_aaga ._gadc .Top +_aaga ._gadc .Bottom +_aaga ._egcf .Top +_aaga ._egcf .Bottom ;case *Chart :_gdeg =_aaga .Height ()+_aaga ._cfad .Top +_aaga ._cfad .Bottom ;
case *Rectangle :_aaga .applyFitMode (_cdaf -_bfged ._dedf );_gdeg =_aaga .Height ()+_aaga ._fcfgf .Top +_aaga ._fcfgf .Bottom +_aaga ._effb ;case *Ellipse :_aaga .applyFitMode (_cdaf -_bfged ._dedf );_gdeg =_aaga .Height ()+_aaga ._ffdg .Top +_aaga ._ffdg .Bottom ;
case *Line :_gdeg =_aaga .Height ()+_aaga ._adac .Top +_aaga ._adac .Bottom ;};return _gdeg ;};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _dbbe (svgStr )};

// DrawWithContext draws the Block using the specified drawing context.
func (_acg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_aab ,_ ,_acae :=d .GeneratePageBlocks (ctx );if _acae !=nil {return _acae ;};if len (_aab )!=1{return ErrContentNotFit ;};for _ ,_ded :=range _aab {if _bgb :=_acg .mergeBlocks (_ded );
_bgb !=nil {return _bgb ;};};return nil ;};func _aceee (_bbfdf *templateProcessor ,_bacbc *templateNode )(interface{},error ){return _bbfdf .parseEllipse (_bacbc );};func _gbefc (_bggaf string )(*Path ,error ){_abea =_bfded ();_gcgaf ,_efgf :=_affe (_bacfg (_bggaf ));
if _efgf !=nil {return nil ,_efgf ;};return _geabd (_gcgaf ),nil ;};func (_eeega *templateProcessor )parseImage (_cgef *templateNode )(interface{},error ){var _gedcg string ;for _ ,_gecad :=range _cgef ._bcaga .Attr {_acgbd :=_gecad .Value ;switch _cbbbg :=_gecad .Name .Local ;
_cbbbg {case "\u0073\u0072\u0063":_gedcg =_acgbd ;};};_cfbab ,_ddgdg :=_eeega .loadImageFromSrc (_gedcg );if _ddgdg !=nil {return nil ,_ddgdg ;};var _cgafe _cdf .StreamEncoder ;_bfdag :=_gg .ToLower (_d .Ext (_gedcg ));if _bfdag =="\u006a\u0070\u0067"||_bfdag =="\u006a\u0070\u0065\u0067"{_cgafe =_cdf .NewDCTEncoder ();
}else {_cgafe =_cdf .NewFlateEncoder ();};_cfbab .SetEncoder (_cgafe );for _ ,_dfaff :=range _cgef ._bcaga .Attr {_eecbb :=_dfaff .Value ;switch _bedf :=_dfaff .Name .Local ;_bedf {case "\u0061\u006c\u0069g\u006e":_cfbab .SetHorizontalAlignment (_eeega .parseHorizontalAlignmentAttr (_bedf ,_eecbb ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_cfbab .SetOpacity (_eeega .parseFloatAttr (_bedf ,_eecbb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cafbg :=_eeega .parseMarginAttr (_bedf ,_eecbb );_cfbab .SetMargins (_cafbg .Left ,_cafbg .Right ,_cafbg .Top ,_cafbg .Bottom );
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_cfbab .SetFitMode (_eeega .parseFitModeAttr (_bedf ,_eecbb ));case "\u0078":_cfbab .SetPos (_eeega .parseFloatAttr (_bedf ,_eecbb ),_cfbab ._dbgg );case "\u0079":_cfbab .SetPos (_cfbab ._aeaef ,_eeega .parseFloatAttr (_bedf ,_eecbb ));
case "\u0077\u0069\u0064t\u0068":_cfbab .SetWidth (_eeega .parseFloatAttr (_bedf ,_eecbb ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_cfbab .SetHeight (_eeega .parseFloatAttr (_bedf ,_eecbb ));case "\u0061\u006e\u0067l\u0065":_cfbab .SetAngle (_eeega .parseFloatAttr (_bedf ,_eecbb ));
case "\u0065n\u0063\u006f\u0064\u0065\u0072":_cgafe =_eeega .parseImageEncoder (_bedf ,_eecbb );if _cgafe !=nil {_cfbab .SetEncoder (_cgafe );};case "\u0073\u0072\u0063":break ;default:_eeega .nodeLogDebug (_cgef ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_bedf );
};};return _cfbab ,nil ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetBorderColor sets the border color.
func (_cdgc *PolyBezierCurve )SetBorderColor (color Color ){_cdgc ._fbac .BorderColor =_acac (color )};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_fdcb *Image )SetMargins (left ,right ,top ,bottom float64 ){_fdcb ._begc .Left =left ;_fdcb ._begc .Right =right ;_fdcb ._begc .Top =top ;_fdcb ._begc .Bottom =bottom ;};type componentRenderer interface{Draw (_agebf Drawable )error ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{taggedDrawable ;_dbdge Color ;_eecec float64 ;_cfbf _ggb .LineStyle ;_bgcac CellBorderStyle ;_fbgff Color ;_agdfa float64 ;_cfbc CellBorderStyle ;_gfdc Color ;_gdff float64 ;_eedc CellBorderStyle ;_feddc Color ;_cdfba float64 ;_cfddd CellBorderStyle ;
_fgaeaf Color ;_geadb float64 ;_cfdga ,_ebgdb int ;_aecg int ;_gfeff int ;_effe VectorDrawable ;_eeea CellHorizontalAlignment ;_bcag CellVerticalAlignment ;_bdgg float64 ;_acgc *Table ;};

// Scale block by specified factors in the x and y directions.
func (_fae *Block )Scale (sx ,sy float64 ){_fba :=_fgc .NewContentCreator ().Scale (sx ,sy ).Operations ();*_fae ._fc =append (*_fba ,*_fae ._fc ...);_fae ._fc .WrapIfNeeded ();_fae ._ce *=sx ;_fae ._ff *=sy ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_dgca *Invoice )AddressHeadingStyle ()TextStyle {return _dgca ._ebfd };

// SetBorderWidth sets the border width.
func (_fgbd *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_fgbd ._fbac .BorderWidth =borderWidth ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_cegad *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_dgcf :=uint (len (_cegad ._bdfec ));if index > _dgcf {index =_dgcf ;};_dcedf :=_cegad .NewColumn (description );_cegad ._bdfec =append (_cegad ._bdfec [:index ],append ([]*InvoiceCell {_dcedf },_cegad ._bdfec [index :]...)...);
return _dcedf ;};func _caad (_cgff []byte )(*Image ,error ){_eddgf :=_e .NewReader (_cgff );_cbcg ,_bfgf :=_cd .ImageHandling .Read (_eddgf );if _bfgf !=nil {_fge .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bfgf );
return nil ,_bfgf ;};return _bgfa (_cbcg );};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_fedc *Invoice )Terms ()(string ,string ){return _fedc ._bcggc [0],_fedc ._bcggc [1]};

// NewCell returns a new invoice table cell.
func (_ffbg *Invoice )NewCell (value string )*InvoiceCell {return _ffbg .newCell (value ,_ffbg .NewCellProps ());};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_ecfeac *TOCLine )SetStyle (style TextStyle ){_ecfeac .Number .Style =style ;_ecfeac .Title .Style =style ;_ecfeac .Separator .Style =style ;_ecfeac .Page .Style =style ;};

// SetViewerPreferences sets the viewer preferences for the PDF document.
func (_ebge *Creator )SetViewerPreferences (viewerPreferences *_cd .ViewerPreferences ){_ebge ._bdgb =viewerPreferences ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gffa *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfaag :=ctx ;_begce ,ctx ,_daffg :=_gffa ._bbgfb .GeneratePageBlocks (ctx );if _daffg !=nil {return _begce ,ctx ,_daffg ;};for _ ,_feaaf :=range _gffa ._affbb {_fefa :=_feaaf ._abcc ;
if !_gffa ._accgc {_feaaf ._abcc =0;};_egfef ,_cfadg ,_ebcfd :=_feaaf .GeneratePageBlocks (ctx );_feaaf ._abcc =_fefa ;if _ebcfd !=nil {return _begce ,ctx ,_ebcfd ;};if len (_egfef )< 1{continue ;};_begce [len (_begce )-1].mergeBlocks (_egfef [0]);_begce =append (_begce ,_egfef [1:]...);
ctx =_cfadg ;};if _gffa ._cgeec .IsRelative (){ctx .X =_cfaag .X ;};if _gffa ._cgeec .IsAbsolute (){return _begce ,_cfaag ,nil ;};return _begce ,ctx ,nil ;};

// FitMode returns the fit mode of the rectangle.
func (_cbbd *Rectangle )FitMode ()FitMode {return _cbbd ._cdgbe };

// Highlight adds a highlight annotation to the text chunk with the specified color and alpha value.
func (_bcdgd *TextChunk )Highlight (color Color ,alpha float64 )*_cd .PdfAnnotation {_eegfc ,_dedab ,_baec :=color .ToRGB ();_dbeda :=_cd .NewPdfAnnotationHighlight ();_dbeda .C =_cdf .MakeArrayFromFloats ([]float64 {_eegfc ,_dedab ,_baec });_dbeda .CA =_cdf .MakeFloat (alpha );
_bcdgd .AddAnnotation (_dbeda .PdfAnnotation );return _dbeda .PdfAnnotation ;};var _abea commands ;

// SetStyle sets the style of the line (solid or dashed).
func (_cgbef *Line )SetStyle (style _ggb .LineStyle ){_cgbef ._fdcg =style };

// Width returns the width of the Paragraph.
func (_cabfg *StyledParagraph )Width ()float64 {if _cabfg ._bccfb &&int (_cabfg ._fcced )> 0{return _cabfg ._fcced ;};return _cabfg .getTextWidth ()/1000.0;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bccd *RadialShading )SetAntiAlias (enable bool ){_bccd ._ggbe .SetAntiAlias (enable )};func _abfg (_bgca TextStyle )*List {return &List {_fccc :TextChunk {Text :"\u2022\u0020",Style :_bgca },_bdge :0,_efab :true ,_bdeg :PositionRelative ,_cedde :_bgca ,taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeList }};
};func (_dbgca *Invoice )generateTotalBlocks (_bgff DrawContext )([]*Block ,DrawContext ,error ){_baadd :=_gecca (4);_baadd .SetMargins (0,0,10,10);_eecea :=[][2]*InvoiceCell {_dbgca ._fdfe };_eecea =append (_eecea ,_dbgca ._fbece ...);_eecea =append (_eecea ,_dbgca ._eacee );
for _ ,_gcgc :=range _eecea {_ggfab ,_dbae :=_gcgc [0],_gcgc [1];if _dbae .Value ==""{continue ;};_baadd .SkipCells (2);_gfgbd :=_baadd .NewCell ();_gfgbd .SetBackgroundColor (_ggfab .BackgroundColor );_gfgbd .SetHorizontalAlignment (_dbae .Alignment );
_dbgca .setCellBorder (_gfgbd ,_ggfab );_gbag :=_dgdda (_ggfab .TextStyle );_gbag .SetMargins (0,0,2,1);_gbag .Append (_ggfab .Value );_gfgbd .SetContent (_gbag );_gfgbd =_baadd .NewCell ();_gfgbd .SetBackgroundColor (_dbae .BackgroundColor );_gfgbd .SetHorizontalAlignment (_dbae .Alignment );
_dbgca .setCellBorder (_gfgbd ,_ggfab );_gbag =_dgdda (_dbae .TextStyle );_gbag .SetMargins (0,0,2,1);_gbag .Append (_dbae .Value );_gfgbd .SetContent (_gbag );};return _baadd .GeneratePageBlocks (_bgff );};

// SetWidth sets line width.
func (_cffb *Curve )SetWidth (width float64 ){_cffb ._dbec =width };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_agdb []*_cd .PdfPage ;_dfdg map[*_cd .PdfPage ]*Block ;_bdb map[*_cd .PdfPage ]*pageTransformations ;_feda *_cd .PdfPage ;_cga PageSize ;_fga DrawContext ;_ecba Margins ;_ebgd ,_bda float64 ;_aeff int ;_gcd func (_gcab FrontpageFunctionArgs );
_aacf func (_eafb *TOC )error ;_abdb func (_dade *Block ,_cbgc HeaderFunctionArgs );_gdb func (_fbfa *Block ,_cge FooterFunctionArgs );_gfg func (_eccg PageFinalizeFunctionArgs )error ;_bfad func (_bbeg *_cd .PdfWriter )error ;_gabg bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_gege *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_fff *_cd .Outline ;_ddccc *_cd .PdfOutlineTreeNode ;_aegc *_cd .PdfAcroForm ;_fafg _cdf .PdfObject ;_ecaf _cd .Optimizer ;_ebce []*_cd .PdfFont ;_ccbd *_cd .PdfFont ;_aefg *_cd .PdfFont ;_afdg bool ;_cfc *_cd .KDict ;_cagg int64 ;_gaaeb *_cd .StructTreeRoot ;
_bdgb *_cd .ViewerPreferences ;_gdcd string ;

// AutofixPageContentStream indicates whether the creator should attempt to fix
// page content streams that have unclosed `q` and `Q` commands.
// The default value is `true`.
// When set to `false`, the creator will skip the content stream checking and wrapping.
// This will speed up and optimize memory usage the creation of PDF, the drawback is
// need to ensure that the source of PDF content streams are well-formed.
AutofixPageContentStream bool ;};func (_eeec *List )ctxHeight (_fbdd float64 )float64 {_fbdd -=_eeec ._bdge ;var _edgeg float64 ;for _ ,_cccag :=range _eeec ._gecb {_edgeg +=_cccag .ctxHeight (_fbdd );};return _edgeg ;};func (_agbda *templateProcessor )nodeError (_faacg *templateNode ,_cfbe string ,_egfgf ...interface{})error {return _a .Errorf ("\u0025\u0073",_agbda .getNodeErrorLocation (_faacg ,_cfbe ,_egfgf ...));
};func (_dfdb grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _dfdb ._adae ,_dfdb ._adae ,_dfdb ._adae ;};

// SetFontColor sets the font color for the paragraph.
func (_cfbgg *StyledParagraph )SetFontColor (color Color ){_cfbgg ._eeac .Color =color ;for _ ,_aefff :=range _cfbgg ._bcebd {_aefff .Style .Color =color ;};};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_bebd *Chapter )SetShowNumbering (show bool ){_bebd ._fbf =show ;_bebd ._bebf .SetText (_bebd .headingText ());};func _fded (_cgedb *_cd .PdfFont ,_cadge float64 )*fontMetrics {_eeceb :=&fontMetrics {};if _cgedb ==nil {_fge .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");
return _eeceb ;};_edcd ,_adffca :=_cgedb .GetFontDescriptor ();if _adffca !=nil {_fge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_adffca );
return _eeceb ;};if _eeceb ._eggfc ,_adffca =_edcd .GetCapHeight ();_adffca !=nil {_fge .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_adffca );
};if int (_eeceb ._eggfc )<=0{_fge .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_eeceb ._eggfc =1000;};_eeceb ._eggfc *=_cadge /1000.0;if _eeceb ._fgcaf ,_adffca =_edcd .GetXHeight ();_adffca !=nil {_fge .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_adffca );
};_eeceb ._fgcaf *=_cadge /1000.0;if _eeceb ._bedd ,_adffca =_edcd .GetAscent ();_adffca !=nil {_fge .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_adffca );
};_eeceb ._bedd *=_cadge /1000.0;if _eeceb ._aebfd ,_adffca =_edcd .GetDescent ();_adffca !=nil {_fge .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_adffca );
};_eeceb ._aebfd *=_cadge /1000.0;return _eeceb ;};

// GraphicSVGElement represents SVG instances.
type GraphicSVGElement struct{

// ViewBox represents viewBox value of element.
ViewBox struct{X ,Y ,W ,H float64 ;};

// Name of element.
Name string ;

// Attributes of element.
Attributes map[string ]string ;

// Children elements.
Children []*GraphicSVGElement ;

// Content contains text value of element.
Content string ;

// Style element style attribute.
Style *GraphicSVGStyle ;

// Width of element.
Width float64 ;

// Height of element.
Height float64 ;_fgdg float64 ;_aeea map[string ]*LinearShading ;_edbee map[string ]*RadialShading ;_dgaa float64 ;_gcgd float64 ;};func _ebf (_cae string ,_deg _cdf .PdfObject ,_ebd *_cd .PdfPageResources )_cdf .PdfObjectName {_abb :=_gg .TrimRightFunc (_gg .TrimSpace (_cae ),func (_fabf rune )bool {return _gaf .IsNumber (_fabf )});
if _abb ==""{_abb ="\u0046\u006f\u006e\u0074";};_gba :=0;_gecg :=_cdf .PdfObjectName (_cae );for {_gfff ,_fdd :=_ebd .GetFontByName (_gecg );if !_fdd ||_gfff ==_deg {break ;};_gba ++;_gecg =_cdf .PdfObjectName (_a .Sprintf ("\u0025\u0073\u0025\u0064",_abb ,_gba ));
};return _gecg ;};func _dbbe (_gffe string )(*GraphicSVG ,error ){_fdf ,_edcb :=ParseFromSVGString (_gffe );if _edcb !=nil {return nil ,_edcb ;};return _dfad (_fdf );};func (_cdba *InvoiceAddress )fmtLine (_dddg ,_ggbfa string ,_eced bool )string {if _eced {_ggbfa ="";
};return _a .Sprintf ("\u0025\u0073\u0025s\u000a",_ggbfa ,_dddg );};func (_dccbg *templateProcessor )parseTextAlignmentAttr (_fgfg ,_dgage string )TextAlignment {_fge .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fgfg ,_dgage );
_acbdf :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_dgage ];
return _acbdf ;};

// SetBorderColor sets the border color for the path.
func (_cgad *FilledCurve )SetBorderColor (color Color ){_cgad ._fbgc =color };func _dgcd (_eafc *Creator ,_aggeg _bg .Reader ,_fabbe interface{},_ffdff *TemplateOptions ,_cbdeg componentRenderer )error {if _eafc ==nil {_fge .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _bgbdd ;};_cbcfe :="";if _eeeb ,_daeb :=_aggeg .(*_ac .File );_daeb {_cbcfe =_eeeb .Name ();};_fgdc :=_e .NewBuffer (nil );if _ ,_fffbg :=_bg .Copy (_fgdc ,_aggeg );_fffbg !=nil {return _fffbg ;};_ecbda :=_f .FuncMap {"\u0064\u0069\u0063\u0074":_gcbcb ,"\u0061\u0064\u0064":_adacc ,"\u0061\u0072\u0072a\u0079":_dbac ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_fbab ,"\u006da\u006b\u0065\u0053\u0065\u0071":_facge };
if _ffdff !=nil &&_ffdff .HelperFuncMap !=nil {for _degb ,_cfeac :=range _ffdff .HelperFuncMap {if _ ,_bdgag :=_ecbda [_degb ];_bdgag {_fge .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_degb );
continue ;};_ecbda [_degb ]=_cfeac ;};};_eega ,_dded :=_f .New ("").Funcs (_ecbda ).Parse (_fgdc .String ());if _dded !=nil {return _dded ;};if _ffdff !=nil &&_ffdff .SubtemplateMap !=nil {for _dadeb ,_baff :=range _ffdff .SubtemplateMap {if _dadeb ==""{_fge .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _baff ==nil {_fge .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_cfffa :=_e .NewBuffer (nil );if _ ,_caeee :=_bg .Copy (_cfffa ,_baff );_caeee !=nil {return _caeee ;};if _ ,_dbfcgc :=_eega .New (_dadeb ).Parse (_cfffa .String ());_dbfcgc !=nil {return _dbfcgc ;};};};_fgdc .Reset ();if _edbag :=_eega .Execute (_fgdc ,_fabbe );
_edbag !=nil {return _edbag ;};return _gffbe (_eafc ,_cbcfe ,_fgdc .Bytes (),_ffdff ,_cbdeg ).run ();};

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_ccce *Table )SetCompactMode (enable bool ){_ccce ._dedfd =enable };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cegc *Creator )Draw (d Drawable )error {if _cegc .getActivePage ()==nil {_cegc .NewPage ();};if _cegc ._afdg {_cegc ._cagg ++;_efaa :=int64 (len (_cegc ._agdb ));d .SetStructPageNumber (&_efaa );switch _bdaa :=d .(type ){case *Table :_bdaa .AddTag (_cegc ._cfc );
_bdaa .SetMarkedContentID (_cegc ._cagg );case *Grid :_bdaa .AddTag (_cegc ._cfc );_bdaa .SetMarkedContentID (_cegc ._cagg );case *List :_bdaa .AddTag (_cegc ._cfc );_bdaa .SetMarkedContentID (_cegc ._cagg );default:_bdaa .SetMarkedContentID (_cegc ._cagg );
_edfa ,_dgdba :=_bdaa .GenerateKDict ();if _dgdba !=nil {return _dgdba ;};if _edfa !=nil {_cegc ._cfc .AddKChild (_edfa );};};};_cbga ,_eabcb ,_dfba :=d .GeneratePageBlocks (_cegc ._fga );if _dfba !=nil {return _dfba ;};if len (_eabcb ._cedd )> 0{_cegc .Errors =append (_cegc .Errors ,_eabcb ._cedd ...);
};for _fdga ,_deec :=range _cbga {if _fdga > 0{_cegc .NewPage ();};_abf :=_cegc .getActivePage ();if _cfb ,_gbc :=_cegc ._dfdg [_abf ];_gbc {if _dfed :=_cfb .mergeBlocks (_deec );_dfed !=nil {return _dfed ;};if _aeaa :=_bab (_deec ._gaa ,_cfb ._gaa );_aeaa !=nil {return _aeaa ;
};}else {_cegc ._dfdg [_abf ]=_deec ;};};_cegc ._fga .X =_eabcb .X ;_cegc ._fga .Y =_eabcb .Y ;_cegc ._fga .Height =_fag .RoundDefault (_eabcb .PageHeight -_eabcb .Y -_eabcb .Margins .Bottom );return nil ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_gffg *List )Width ()float64 {return 0};func (_bceef *templateProcessor )parseMarginAttr (_beae ,_bagge string )Margins {_fge .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_beae ,_bagge );
_ecacf :=Margins {};switch _beeec :=_gg .Fields (_bagge );len (_beeec ){case 1:_ecacf .Top ,_ =_c .ParseFloat (_beeec [0],64);_ecacf .Bottom =_ecacf .Top ;_ecacf .Left =_ecacf .Top ;_ecacf .Right =_ecacf .Top ;case 2:_ecacf .Top ,_ =_c .ParseFloat (_beeec [0],64);
_ecacf .Bottom =_ecacf .Top ;_ecacf .Left ,_ =_c .ParseFloat (_beeec [1],64);_ecacf .Right =_ecacf .Left ;case 3:_ecacf .Top ,_ =_c .ParseFloat (_beeec [0],64);_ecacf .Left ,_ =_c .ParseFloat (_beeec [1],64);_ecacf .Right =_ecacf .Left ;_ecacf .Bottom ,_ =_c .ParseFloat (_beeec [2],64);
case 4:_ecacf .Top ,_ =_c .ParseFloat (_beeec [0],64);_ecacf .Right ,_ =_c .ParseFloat (_beeec [1],64);_ecacf .Bottom ,_ =_c .ParseFloat (_beeec [2],64);_ecacf .Left ,_ =_c .ParseFloat (_beeec [3],64);};return _ecacf ;};func (_bfde *StyledParagraph )getLineMetrics (_gdbbe int )(_gfae ,_cgabb ,_dafdb float64 ){if _bfde ._adcf ==nil ||(_bfde ._adcf !=nil &&len (_bfde ._adcf )==0){_bfde .wrapText ();
};if _gdbbe < 0||_gdbbe > len (_bfde ._adcf )-1{_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_gdbbe );
return 0,0,0;};_ggce :=_bfde ._adcf [_gdbbe ];for _ ,_fcbad :=range _ggce {_fabcc :=_fded (_fcbad .Style .Font ,_fcbad .Style .FontSize );if _fabcc ._eggfc > _gfae {_gfae =_fabcc ._eggfc ;};if _fabcc ._aebfd < _dafdb {_dafdb =_fabcc ._aebfd ;};if _geed :=_fcbad .Style .FontSize ;
_geed > _cgabb {_cgabb =_geed ;};};return _gfae ,_cgabb ,_dafdb ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_cfaeg *Invoice )SetAddressHeadingStyle (style TextStyle ){_cfaeg ._cabf =style };

// This method is not supported by Chapter component and exists solely to satisfy the Drawable interface.
func (_aef *Chapter )GenerateKDict ()(*_cd .KDict ,error ){return nil ,nil };

// LevelOffset returns the amount of space an indentation level occupies.
func (_beged *TOCLine )LevelOffset ()float64 {return _beged ._fdgca };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func _adacc (_cdgbed ,_bgdfa interface{})(interface{},error ){_fgcae ,_ecbdg :=_ddac (_cdgbed );if _ecbdg !=nil {return nil ,_ecbdg ;};switch _baceg :=_fgcae .(type ){case int64 :_cfce ,_dafae :=_ddac (_bgdfa );if _dafae !=nil {return nil ,_dafae ;
};switch _cdcef :=_cfce .(type ){case int64 :return _baceg +_cdcef ,nil ;case float64 :return float64 (_baceg )+_cdcef ,nil ;};case float64 :_dcacf ,_cddb :=_ddac (_bgdfa );if _cddb !=nil {return nil ,_cddb ;};switch _fdgef :=_dcacf .(type ){case int64 :return _baceg +float64 (_fdgef ),nil ;
case float64 :return _baceg +_fdgef ,nil ;};};return nil ,_a .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_cdgbed ,_bgdfa );};func (_edff *templateProcessor )parseEllipse (_dfgdc *templateNode )(interface{},error ){_gaba :=_edff .creator .NewEllipse (0,0,0,0);
for _ ,_fcbea :=range _dfgdc ._bcaga .Attr {_ebfb :=_fcbea .Value ;switch _cacbd :=_fcbea .Name .Local ;_cacbd {case "\u0063\u0078":_gaba ._adbf =_edff .parseFloatAttr (_cacbd ,_ebfb );case "\u0063\u0079":_gaba ._gggg =_edff .parseFloatAttr (_cacbd ,_ebfb );
case "\u0077\u0069\u0064t\u0068":_gaba .SetWidth (_edff .parseFloatAttr (_cacbd ,_ebfb ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_gaba .SetHeight (_edff .parseFloatAttr (_cacbd ,_ebfb ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_gaba .SetFillColor (_edff .parseColorAttr (_cacbd ,_ebfb ));
case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_gaba .SetFillOpacity (_edff .parseFloatAttr (_cacbd ,_ebfb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gaba .SetBorderColor (_edff .parseColorAttr (_cacbd ,_ebfb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_gaba .SetBorderOpacity (_edff .parseFloatAttr (_cacbd ,_ebfb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_gaba .SetBorderWidth (_edff .parseFloatAttr (_cacbd ,_ebfb ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_gaba .SetPositioning (_edff .parsePositioningAttr (_cacbd ,_ebfb ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_gaba .SetFitMode (_edff .parseFitModeAttr (_cacbd ,_ebfb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cbcae :=_edff .parseMarginAttr (_cacbd ,_ebfb );
_gaba .SetMargins (_cbcae .Left ,_cbcae .Right ,_cbcae .Top ,_cbcae .Bottom );default:_edff .nodeLogDebug (_dfgdc ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cacbd );
};};return _gaba ,nil ;};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_dbadf *Ellipse )GetCoords ()(float64 ,float64 ){return _dbadf ._adbf ,_dbadf ._gggg };

// TextAlignment options for paragraph.
type TextAlignment int ;func (_ededa *templateProcessor )parseLinearGradientAttr (creator *Creator ,_dgeaa string )Color {_caffce :=ColorBlack ;if _dgeaa ==""{return _caffce ;};_bgffce :=creator .NewLinearGradientColor ([]*ColorPoint {});_bgffce .SetExtends (true ,true );
var (_ccegbe =_gg .Split (_dgeaa [16:len (_dgeaa )-1],"\u002c");_cdadcc =_gg .TrimSpace (_ccegbe [0]););if _gg .HasSuffix (_cdadcc ,"\u0064\u0065\u0067"){_edgfe ,_fbdbg :=_c .ParseFloat (_cdadcc [:len (_cdadcc )-3],64);if _fbdbg !=nil {_fge .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_fbdbg );
}else {_bgffce .SetAngle (_edgfe );};_ccegbe =_ccegbe [1:];};_addbf ,_aedbb :=_ededa .processGradientColorPair (_ccegbe );if _addbf ==nil ||_aedbb ==nil {return _caffce ;};for _fccbg :=0;_fccbg < len (_addbf );_fccbg ++{_bgffce .AddColorStop (_addbf [_fccbg ],_aedbb [_fccbg ]);
};return _bgffce ;};

// SetTotal sets the total of the invoice.
func (_badd *Invoice )SetTotal (value string ){_badd ._eacee [1].Value =value };

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{taggedDrawable ;_decb []VectorDrawable ;_fege Positioning ;_gadc Margins ;_egcf Margins ;_abdc bool ;_agaad bool ;_aebdf *Background ;};

// SetBorderOpacity sets the border opacity.
func (_gegef *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_gegef ._eaecf =opacity };func (_gccdce *templateProcessor )loadImageFromSrc (_acge string )(*Image ,error ){if _acge ==""{_fge .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_geccd ;};_caddb :=_gg .Split (_acge ,"\u002c");for _ ,_cgacb :=range _caddb {_cgacb =_gg .TrimSpace (_cgacb );if _cgacb ==""{continue ;};_gbfde ,_egcdb :=_gccdce ._ccdf .ImageMap [_cgacb ];if _egcdb {return _bgfa (_gbfde );};if _ecea :=_gccdce .parseAttrPropList (_cgacb );
len (_ecea )> 0{if _eedb ,_edcg :=_ecea ["\u0070\u0061\u0074\u0068"];_edcg {if _bfcef ,_dbeac :=_dcba (_eedb );_dbeac !=nil {_fge .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_eedb ,_dbeac );
}else {return _bfcef ,nil ;};};};};_fge .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_acge );return nil ,_geccd ;};func _abddf (_cadc *Table ,_gbdab DrawContext )([]*Block ,DrawContext ,error ){var _faef []*Block ;
_gaabf :=NewBlock (_gbdab .PageWidth ,_gbdab .PageHeight );_cadc .updateRowHeights (_gbdab .Width -_cadc ._ffegb .Left -_cadc ._ffegb .Right );_ebcaa :=_cadc ._ffegb .Top ;if _cadc ._acbec .IsRelative ()&&!_cadc ._ddcg {_ecegd :=_cadc .Height ();if _ecegd > _gbdab .Height -_cadc ._ffegb .Top &&_ecegd <=_gbdab .PageHeight -_gbdab .Margins .Top -_gbdab .Margins .Bottom {_faef =[]*Block {NewBlock (_gbdab .PageWidth ,_gbdab .PageHeight -_gbdab .Y )};
var _ebga error ;if _ ,_gbdab ,_ebga =_acga ().GeneratePageBlocks (_gbdab );_ebga !=nil {return nil ,_gbdab ,_ebga ;};_ebcaa =0;};};_dfaf :=_gbdab ;if _cadc ._acbec .IsAbsolute (){_gbdab .X =_cadc ._cgdfe ;_gbdab .Y =_cadc ._aabg ;}else {_gbdab .X +=_cadc ._ffegb .Left ;
_gbdab .Y +=_ebcaa ;_gbdab .Width -=_cadc ._ffegb .Left +_cadc ._ffegb .Right ;_gbdab .Height -=_ebcaa ;};_bcecd :=_gbdab .Width ;_cdadd :=_gbdab .X ;_dffeed :=_gbdab .Y ;_bfeac :=_gbdab .Height ;_dfcgd :=0;_fdgd ,_ddfc :=-1,-1;if _cadc ._ffdag {for _fbdfa ,_geecf :=range _cadc ._dfcec {if _geecf ._cfdga < _cadc ._egeab {continue ;
};if _geecf ._cfdga > _cadc ._gdab {break ;};if _fdgd < 0{_fdgd =_fbdfa ;};_ddfc =_fbdfa ;};};if _caecd :=_cadc .wrapContent (_gbdab );_caecd !=nil {return nil ,_gbdab ,_caecd ;};_cadc .updateRowHeights (_gbdab .Width -_cadc ._ffegb .Left -_cadc ._ffegb .Right );
var (_aabb bool ;_aebf int ;_ggcd int ;_bbbe bool ;_afge int ;_efece error ;_fbeec int64 ;_bfffa *_cd .KDict ;_abcb =_cadc ._aefb !=nil &&_cadc ._aefb .ApplyTag ;);if _abcb {_faefe (_gaabf ,_cadc ._aefb );_fbeec =_cadc ._aefb .Mcid +1;};for _bcff :=0;_bcff < len (_cadc ._dfcec );
_bcff ++{_gabgf :=_cadc ._dfcec [_bcff ];if _abcb &&_gabgf ._cfdga > _afge {switch _cadc ._aefb .StructureType {case _cd .StructureTypeTable :_faefe (_gaabf ,&_cd .StructureTagInfo {Mcid :_fbeec ,StructureType :_cd .StructureTypeTableRow });_bfffa =_cadc .addRowTag ();
case _cd .StructureTypeList :_faefe (_gaabf ,&_cd .StructureTagInfo {Mcid :_fbeec ,StructureType :_cd .StructureTypeListItem });_bfffa =_cadc .addListItemTag ();};_afge =_gabgf ._cfdga ;_fbeec ++;};if _afgg ,_efce :=_cadc .getLastCellFromCol (_gabgf ._ebgdb );
_afgg ==_bcff {if (_efce ._cfdga +_efce ._aecg -1)< _cadc ._ecga {for _gdggb :=_gabgf ._cfdga ;_gdggb < _cadc ._ecga ;_gdggb ++{_faec :=&TableCell {};_faec ._cfdga =_gdggb +1;_faec ._aecg =1;_faec ._ebgdb =_gabgf ._ebgdb ;_cadc ._dfcec =append (_cadc ._dfcec ,_faec );
};};};_fbacd :=_gabgf .width (_cadc ._fefea ,_bcecd );_geae :=float64 (0.0);for _edgda :=0;_edgda < _gabgf ._ebgdb -1;_edgda ++{_geae +=_cadc ._fefea [_edgda ]*_bcecd ;};_cccbd :=float64 (0.0);for _dabf :=_dfcgd ;_dabf < _gabgf ._cfdga -1;_dabf ++{_cccbd +=_cadc ._fgege [_dabf ];
};_gbdab .Height =_bfeac -_cccbd ;_bddfd :=float64 (0.0);for _aedb :=0;_aedb < _gabgf ._aecg ;_aedb ++{_bddfd +=_cadc ._fgege [_gabgf ._cfdga +_aedb -1];};_faga :=_bbbe &&_gabgf ._cfdga !=_afge ;_afge =_gabgf ._cfdga ;if _faga ||_bddfd > _gbdab .Height {if _cadc ._gefgf &&!_bbbe {_bbbe ,_efece =_cadc .wrapRow (_bcff ,_gbdab ,_bcecd );
if _efece !=nil {return nil ,_gbdab ,_efece ;};if _bbbe {_bcff --;continue ;};};_faef =append (_faef ,_gaabf );_gaabf =NewBlock (_gbdab .PageWidth ,_gbdab .PageHeight );_cdadd =_gbdab .Margins .Left +_cadc ._ffegb .Left ;_dffeed =_gbdab .Margins .Top ;
_gbdab .Height =_gbdab .PageHeight -_gbdab .Margins .Top -_gbdab .Margins .Bottom ;_gbdab .Page ++;_bfeac =_gbdab .Height ;_dfcgd =_gabgf ._cfdga -1;_cccbd =0;_bbbe =false ;if _cadc ._ffdag &&_fdgd >=0{_aebf =_bcff ;_bcff =_fdgd -1;_ggcd =_dfcgd ;_dfcgd =_cadc ._egeab -1;
_aabb =true ;if _gabgf ._aecg > (_cadc ._ecga -_afge )||(_gabgf ._aecg > 1&&_bcff < 0){_fge .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_aabb =false ;_fdgd ,_ddfc =-1,-1;};continue ;};if _faga {_bcff --;continue ;};};_gbdab .Width =_fbacd ;_gbdab .X =_cdadd +_geae ;_gbdab .Y =_dffeed +_cccbd ;if _bddfd > _gbdab .PageHeight -_gbdab .Margins .Top -_gbdab .Margins .Bottom {_bddfd =_gbdab .PageHeight -_gbdab .Margins .Top -_gbdab .Margins .Bottom ;
};_dgdg :=_aaf (_gbdab .X ,_gbdab .Y ,_fbacd ,_bddfd );if _gabgf ._dbdge !=nil {_dgdg .SetFillColor (_gabgf ._dbdge );};_dgdg .SetOpacity (_gabgf ._eecec );_dgdg .LineStyle =_gabgf ._cfbf ;_dgdg ._bffb =_gabgf ._bgcac ;_dgdg ._bdf =_gabgf ._eedc ;_dgdg ._dbda =_gabgf ._cfddd ;
_dgdg ._cff =_gabgf ._cfbc ;if _gabgf ._fbgff !=nil {_dgdg .SetColorLeft (_gabgf ._fbgff );};if _gabgf ._gfdc !=nil {_dgdg .SetColorBottom (_gabgf ._gfdc );};if _gabgf ._feddc !=nil {_dgdg .SetColorRight (_gabgf ._feddc );};if _gabgf ._fgaeaf !=nil {_dgdg .SetColorTop (_gabgf ._fgaeaf );
};_dgdg .SetWidthBottom (_gabgf ._gdff );_dgdg .SetWidthLeft (_gabgf ._agdfa );_dgdg .SetWidthRight (_gabgf ._cdfba );_dgdg .SetWidthTop (_gabgf ._geadb );_ccea :=NewBlock (_gaabf ._ce ,_gaabf ._ff );_cgbegb :=_gaabf .Draw (_dgdg );if _cgbegb !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cgbegb );
};if _gabgf ._effe !=nil {var _eeaca *_cd .KDict ;if _abcb {_gabgf .SetMarkedContentID (_fbeec );_gabgf .SetStructPageNumber (_cadc ._aefb .StructPageNumber );_bcega :=_cd .StructureTypeTableData ;if _gabgf ._aefb .StructureType !=_cd .StructureTypeTableData {_bcega =_gabgf ._aefb .StructureType ;
}else {_gabgf .SetStructureType (_cd .StructureTypeTableData );};_faefe (_gaabf ,&_cd .StructureTagInfo {Mcid :_fbeec ,StructureType :_bcega });_eeaca =_cd .NewKDictionary ();_eeaca .S =_cdf .MakeName (string (_bcega ));_dabcg :=_cd .NewKValue ();_dabcg .SetMCID (int (_fbeec ));
_eeaca .AddChild (_dabcg );_bfffa .AddKChild (_eeaca );_fbeec ++;};_aebbd :=_gabgf ._effe .Width ();_aaggf :=_gabgf ._effe .Height ();_aebbd ,_aaggf ,_adfcfa ,_dgbcb ,_ebbcb ,_egad :=_bceca (_gabgf ._effe ,_aebbd ,_aaggf ,_gabgf ._bcag ,_cadc ._dedfd ,_eeaca ,_fbeec ,_fbacd );
if _egad !=nil {return nil ,_gbdab ,_egad ;};if _dgbcb !=nil {if !_ebbcb {_eeaca .AddKChild (_dgbcb );};_fbeec ++;};switch _gabgf ._eeea {case CellHorizontalAlignmentLeft :_gbdab .X +=_gabgf ._bdgg ;_gbdab .Width -=_gabgf ._bdgg ;case CellHorizontalAlignmentCenter :if _fbbe :=_fbacd -_aebbd ;
_fbbe > 0{_gbdab .X +=_fbbe /2;_gbdab .Width -=_fbbe /2;};case CellHorizontalAlignmentRight :if _fbacd > _aebbd {_gbdab .X =_gbdab .X +_fbacd -_aebbd -_gabgf ._bdgg ;_gbdab .Width -=_gabgf ._bdgg ;};};_beecfa :=_gbdab .Y ;_beca :=_gbdab .Height ;_gbdab .Y +=_adfcfa ;
switch _gabgf ._bcag {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _bcdc :=_bddfd -_aaggf ;_bcdc > 0{_gbdab .Y +=_bcdc /2;_gbdab .Height -=_bcdc /2;};case CellVerticalAlignmentBottom :if _bddfd > _aaggf {_gbdab .Y =_gbdab .Y +_bddfd -_aaggf ;
_gbdab .Height =_bddfd ;};};_egad =_gaabf .DrawWithContext (_gabgf ._effe ,_gbdab );if _egad !=nil {if _fab .Is (_egad ,ErrContentNotFit )&&!_faga {_gaabf =_ccea ;_faga =true ;_bcff --;continue ;};_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_egad );
};_gbdab .Y =_beecfa ;_gbdab .Height =_beca ;};_gbdab .Y +=_bddfd ;_gbdab .Height -=_bddfd ;if _aabb &&_bcff +1> _ddfc {_dffeed +=_cccbd +_bddfd ;_bfeac -=_bddfd +_cccbd ;_dfcgd =_ggcd ;_bcff =_aebf -1;_aabb =false ;};if _abcb {_fdbg (_gaabf );if _bcff +1==len (_cadc ._dfcec )||_cadc ._dfcec [_bcff +1]._cfdga > _afge {_fdbg (_gaabf );
};};};if _abcb {_fdbg (_gaabf );};_faef =append (_faef ,_gaabf );if _cadc ._acbec .IsAbsolute (){return _faef ,_dfaf ,nil ;};_gbdab .X =_dfaf .X ;_gbdab .Width =_dfaf .Width ;_gbdab .Y +=_cadc ._ffegb .Bottom ;_gbdab .Height -=_cadc ._ffegb .Bottom ;return _faef ,_gbdab ,nil ;
};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_ebbc *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_cadb []*Block ;_baca =NewBlock (ctx .PageWidth ,ctx .PageHeight );_fgfba =ctx ;_aeffd =_ebbc ._effb /2;);_ccgg :=_ebbc ._afbe .IsRelative ();if _ccgg {_ebbc .applyFitMode (ctx .Width );
ctx .X +=_ebbc ._fcfgf .Left +_aeffd ;ctx .Y +=_ebbc ._fcfgf .Top +_aeffd ;ctx .Width -=_ebbc ._fcfgf .Left +_ebbc ._fcfgf .Right ;ctx .Height -=_ebbc ._fcfgf .Top +_ebbc ._fcfgf .Bottom ;if _ebbc ._abdcf > ctx .Height {_cadb =append (_cadb ,_baca );_baca =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_cabdb :=ctx ;_cabdb .Y =ctx .Margins .Top +_ebbc ._fcfgf .Top +_aeffd ;_cabdb .X =ctx .Margins .Left +_ebbc ._fcfgf .Left +_aeffd ;_cabdb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ebbc ._fcfgf .Top -_ebbc ._fcfgf .Bottom ;
_cabdb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ebbc ._fcfgf .Left -_ebbc ._fcfgf .Right ;ctx =_cabdb ;};}else {ctx .X =_ebbc ._bdcc ;ctx .Y =_ebbc ._dbgd ;};_ceeae :=_ggb .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_ebbc ._abdcf ,Width :_ebbc ._bfed ,Height :_ebbc ._abdcf ,BorderRadiusTopLeft :_ebbc ._cedf ,BorderRadiusTopRight :_ebbc ._ebaa ,BorderRadiusBottomLeft :_ebbc ._bdgee ,BorderRadiusBottomRight :_ebbc ._geeg ,Opacity :1.0};
if _ebbc ._bfcd !=nil {_ceeae .FillEnabled =true ;_gebf :=_acac (_ebbc ._bfcd );_ggafb :=_dbdga (_baca ,_gebf ,_ebbc ._bfcd ,func ()Rectangle {return Rectangle {_bdcc :_ceeae .X ,_dbgd :_ceeae .Y ,_bfed :_ceeae .Width ,_abdcf :_ceeae .Height };});if _ggafb !=nil {return nil ,ctx ,_ggafb ;
};_ceeae .FillColor =_gebf ;};if _ebbc ._feedc !=nil &&_ebbc ._effb > 0{_ceeae .BorderEnabled =true ;_ceeae .BorderColor =_acac (_ebbc ._feedc );_ceeae .BorderWidth =_ebbc ._effb ;};_ebacd ,_cgca :=_baca .setOpacity (_ebbc ._abbd ,_ebbc ._cbfae );if _cgca !=nil {return nil ,ctx ,_cgca ;
};_efeeg ,_ ,_cgca :=_ceeae .MarkedDraw (_ebacd ,_ebbc ._aefb );if _cgca !=nil {return nil ,ctx ,_cgca ;};if _cgca =_baca .addContentsByString (string (_efeeg ));_cgca !=nil {return nil ,ctx ,_cgca ;};if _ccgg {ctx .X =_fgfba .X ;ctx .Width =_fgfba .Width ;
_dgff :=_ebbc ._abdcf +_aeffd ;ctx .Y +=_dgff +_ebbc ._fcfgf .Bottom ;ctx .Height -=_dgff ;}else {ctx =_fgfba ;};_cadb =append (_cadb ,_baca );return _cadb ,ctx ,nil ;};func (_cbddf *Ellipse )applyFitMode (_dgfgb float64 ){_dgfgb -=_cbddf ._ffdg .Left +_cbddf ._ffdg .Right ;
switch _cbddf ._aeae {case FitModeFillWidth :_cbddf .ScaleToWidth (_dgfgb );};};

// SetIndent sets the left offset of the list when nested into another list.
func (_egfd *List )SetIndent (indent float64 ){_egfd ._bdge =indent ;_egfd ._efab =false };type fontMetrics struct{_eggfc float64 ;_fgcaf float64 ;_bedd float64 ;_aebfd float64 ;};func _gbd (_eae string )string {_age :=_ebeb .FindAllString (_eae ,-1);if len (_age )==0{_eae =_eae +"\u0030";
}else {_adf ,_ace :=_c .Atoi (_age [len (_age )-1]);if _ace !=nil {_fge .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_ace );
_eae =_eae +"\u0030";}else {_adf ++;_gbf :=_gg .LastIndex (_eae ,_age [len (_age )-1]);if _gbf ==-1{_eae =_a .Sprintf ("\u0025\u0073\u0025\u0064",_eae [:len (_eae )-1],_adf );}else {_eae =_eae [:_gbf ]+_c .Itoa (_adf );};};};return _eae ;};func (_defdc *templateProcessor )parseCellAlignmentAttr (_ebacb ,_bgfda string )CellHorizontalAlignment {_fge .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ebacb ,_bgfda );
_fadfd :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_bgfda ];return _fadfd ;
};func _cafdb (_aggd *_cd .PdfAnnotationLink )*_cd .PdfAnnotationLink {if _aggd ==nil {return nil ;};_ddgbb :=_cd .NewPdfAnnotationLink ();_ddgbb .CopyFrom (_aggd .PdfAnnotation );_ddgbb .BS =_aggd .BS ;_ddgbb .A =_aggd .A ;if _dfbe ,_geag :=_aggd .GetAction ();
_geag ==nil &&_dfbe !=nil {_ddgbb .SetAction (_dfbe );};if _bfba ,_cfdab :=_aggd .Dest .(*_cdf .PdfObjectArray );_cfdab {_ddgbb .Dest =_cdf .MakeArray (_bfba .Elements ()...);};return _ddgbb ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_efgc *StyledParagraph )SetText (text string )*TextChunk {_efgc .Reset ();return _efgc .Append (text );};

// SetActualText sets the actual text for the text chunk.
func (_afcf *TextChunk )SetActualText (text string ){_afcf ._eegdf =&text };func _cffbc (_ffgec *templateProcessor ,_fcgef *templateNode )(interface{},error ){return _ffgec .parseBackground (_fcgef );};

// SetPos sets the grid positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the grid does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_feddg *Grid )SetPos (x ,y float64 ){_feddg ._dgda =PositionAbsolute ;_feddg ._cfade =x ;_feddg ._bdef =y ;};func _dede (_gbec string )(float64 ,error ){_gbec =_gg .TrimSpace (_gbec );var _ecdbg float64 ;if _gg .HasSuffix (_gbec ,"\u0025"){_efgdg ,_bffeag :=_c .ParseFloat (_gg .TrimSuffix (_gbec ,"\u0025"),64);
if _bffeag !=nil {return 0,_bffeag ;};_ecdbg =(_efgdg *255.0)/100.0;}else {_cgfbd ,_dcgeb :=_c .Atoi (_gbec );if _dcgeb !=nil {return 0,_dcgeb ;};_ecdbg =float64 (_cgfbd );};return _ecdbg ,nil ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_fe *Block )ScaleToWidth (w float64 ){_fgef :=w /_fe ._ce ;_fe .Scale (_fgef ,_fgef )};func (_edaad *templateProcessor )parseBoolAttr (_bcaabb ,_gaebgd string )bool {_fge .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bcaabb ,_gaebgd );
_cgcec ,_ :=_c .ParseBool (_gaebgd );return _gaebgd ==""||_cgcec ;};func (_abdd *Division )ctxHeight (_ddcd float64 )float64 {_ddcd -=_abdd ._gadc .Left +_abdd ._gadc .Right +_abdd ._egcf .Left +_abdd ._egcf .Right ;var _efbfe float64 ;for _ ,_ceea :=range _abdd ._decb {_efbfe +=_agbaa (_ceea ,_ddcd );
};return _efbfe ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_daee :_bd .Max (_bd .Min (c ,1.0),0.0),_faab :_bd .Max (_bd .Min (m ,1.0),0.0),_afde :_bd .Max (_bd .Min (y ,1.0),0.0),_daeec :_bd .Max (_bd .Min (k ,1.0),0.0)};};const (PositionRelative Positioning =iota ;
PositionAbsolute ;);func (_cadd *Grid )addSectionTag (_bgea GridRowSection )*_cd .KDict {_dccd :=_cd .NewKDictionary ();_dccd .S =_cdf .MakeName (string (_eaec [_bgea ]));_cadd ._aefb .ComponentKObj .AddKChild (_dccd );return _dccd ;};func _cbfdc (_fead *templateProcessor ,_bagca *templateNode )(interface{},error ){return _fead .parseList (_bagca );
};

// Crop crops the Image to the specified bounds.
func (_abeff *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_efcd ,_eefg :=_abeff ._dbfc .ToGoImage ();if _eefg !=nil {_df .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_eefg );
};var _cdccg _ga .Image ;_bddg :=_ga .Rect (x0 ,y0 ,x1 ,y1 );if _ddbb :=_bddg .Intersect (_efcd .Bounds ());!_bddg .Empty (){_dcf :=_ga .NewRGBA (_ga .Rect (0,0,_bddg .Dx (),_bddg .Dy ()));for _fbeg :=_ddbb .Min .Y ;_fbeg < _ddbb .Max .Y ;_fbeg ++{for _gafdd :=_ddbb .Min .X ;
_gafdd < _ddbb .Max .X ;_gafdd ++{_dcf .Set (_gafdd -_ddbb .Min .X ,_fbeg -_ddbb .Min .Y ,_efcd .At (_gafdd ,_fbeg ));};};_cdccg =_dcf ;}else {_cdccg =&_ga .RGBA {};};_aded ,_eefg :=_cd .ImageHandling .NewImageFromGoImage (_cdccg );if _eefg !=nil {_df .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_eefg );
};_acaba :=float64 (_aded .Width );_befbg :=float64 (_aded .Height );_abeff ._dbfc =_aded ;_abeff ._gabe =_acaba ;_abeff ._agbff =_befbg ;_abeff ._dbdfea =_acaba ;_abeff ._eafg =_befbg ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_dcd *Division )Width ()float64 {return 0};func _gbbge (_abfc *templateProcessor ,_fbde *templateNode )(interface{},error ){return _abfc .parseTextChunk (_fbde ,nil );};func (_gcfdf *templateProcessor )parsePositioningAttr (_cgebdg ,_cgdfa string )Positioning {_fge .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cgebdg ,_cgdfa );
_adcdc :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_cgdfa ];return _adcdc ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_dgba *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgba ._begc .Left ,_dgba ._begc .Right ,_dgba ._begc .Top ,_dgba ._begc .Bottom ;};

// SetCoords sets the center coordinates of the ellipse.
func (_fcfg *Ellipse )SetCoords (xc ,yc float64 ){_fcfg ._adbf =xc ;_fcfg ._gggg =yc };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ggfg *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _ggfg ._dcfg [0],_ggfg ._dcfg [1]};

// SetHeight sets the custom height for the row.
func (_degd *GridRow )SetHeight (h float64 ){_degd ._dada =h };

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_egaf *TableCell )SetBorderLineStyle (style _ggb .LineStyle ){_egaf ._cfbf =style };

// NewTable create a new Table with a specified number of columns.
func (_dcbg *Creator )NewTable (cols int )*Table {return _gecca (cols )};func _bdac (_bbea _gd .StartElement )*GraphicSVGElement {_cdef :=&GraphicSVGElement {};_dfbc :=make (map[string ]string );for _ ,_aeee :=range _bbea .Attr {_dfbc [_aeee .Name .Local ]=_aeee .Value ;
};_cdef .Name =_bbea .Name .Local ;_cdef .Attributes =_dfbc ;_cdef ._fgdg =1;if _cdef .Name =="\u0073\u0076\u0067"{_ddeb ,_cab :=_gaade (_dfbc ["\u0076i\u0065\u0077\u0042\u006f\u0078"]);if _cab !=nil {_fge .Log .Debug ("\u0055\u006ea\u0062\u006c\u0065\u0020t\u006f\u0020p\u0061\u0072\u0073\u0065\u0020\u0076\u0069\u0065w\u0042\u006f\u0078\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0025\u0076",_cab );
return nil ;};if len (_ddeb )>=4{_cdef .ViewBox .X =_ddeb [0];_cdef .ViewBox .Y =_ddeb [1];_cdef .ViewBox .W =_ddeb [2];_cdef .ViewBox .H =_ddeb [3];};_cdef .Width =_cdef .ViewBox .W ;_cdef .Height =_cdef .ViewBox .H ;if _facf ,_cgge :=_dfbc ["\u0077\u0069\u0064t\u0068"];
_cgge {if _gg .HasSuffix (_facf ,"\u0025"){_badg ,_gcgb :=_c .ParseFloat (_gg .TrimSuffix (_facf ,"\u0025"),64);if _gcgb !=nil {_fge .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_gcgb );
return nil ;};_cdef .Width =_badg *_cdef .ViewBox .W ;}else {_acca ,_gbfad :=_gfgbeb (_facf ,64);if _gbfad !=nil {_fge .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_gbfad );
return nil ;};_cdef .Width =_acca ;if len (_ddeb )< 4{_cdef .ViewBox .W =_acca ;};};};if _eace ,_ebgde :=_dfbc ["\u0068\u0065\u0069\u0067\u0068\u0074"];_ebgde {if _gg .HasSuffix (_eace ,"\u0025"){_dbge ,_bagf :=_c .ParseFloat (_gg .TrimSuffix (_eace ,"\u0025"),64);
if _bagf !=nil {_fge .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_bagf );return nil ;};_cdef .Height =_dbge *_cdef .ViewBox .H ;
}else {_agbdd ,_fbaeg :=_gfgbeb (_eace ,64);if _fbaeg !=nil {_fge .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_fbaeg );
return nil ;};_cdef .Height =_agbdd ;if len (_ddeb )< 4{_cdef .ViewBox .H =_agbdd ;};};};if _cdef .Width > 0&&_cdef .Height > 0{_cdef ._fgdg =_cdef .Width /_cdef .ViewBox .W ;};};return _cdef ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_abd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfed :=ctx ;if _abd ._dgg .IsRelative (){ctx .X +=_abd ._acgfb .Left ;ctx .Y +=_abd ._acgfb .Top ;ctx .Width -=_abd ._acgfb .Left +_abd ._acgfb .Right ;ctx .Height -=_abd ._acgfb .Top ;
};_dceg ,_efg ,_eafe :=_abd ._bebf .GeneratePageBlocks (ctx );if _eafe !=nil {return _dceg ,ctx ,_eafe ;};ctx =_efg ;_bag :=ctx .X ;_afac :=ctx .Y -_abd ._bebf .Height ();_eegb :=int64 (ctx .Page );_aagg :=_abd .headingNumber ();_dfgd :=_abd .headingText ();
if _abd ._agfe {_feae :=_abd ._fbfg .Add (_aagg ,_abd ._dfd ,_c .FormatInt (_eegb ,10),_abd ._gffb );if _abd ._fbfg ._accgc {_feae .SetLink (_eegb ,_bag ,_afac );};};if _abd ._fdg ==nil {_abd ._fdg =_cd .NewOutlineItem (_dfgd ,_cd .NewOutlineDest (_eegb -1,_bag ,_afac ));
if _abd ._aagc !=nil {_abd ._aagc ._fdg .Add (_abd ._fdg );}else {_abd ._dbb .Add (_abd ._fdg );};}else {_fbe :=&_abd ._fdg .Dest ;_fbe .Page =_eegb -1;_fbe .X =_bag ;_fbe .Y =_afac ;};for _ ,_ebbac :=range _abd ._ecbg {_ebbd ,_caac ,_aefe :=_ebbac .GeneratePageBlocks (ctx );
if _aefe !=nil {return _dceg ,ctx ,_aefe ;};if len (_ebbd )< 1{continue ;};_dceg [len (_dceg )-1].mergeBlocks (_ebbd [0]);_dceg =append (_dceg ,_ebbd [1:]...);ctx =_caac ;};if _abd ._dgg .IsRelative (){ctx .X =_cfed .X ;};if _abd ._dgg .IsAbsolute (){return _dceg ,_cfed ,nil ;
};return _dceg ,ctx ,nil ;};

// ParseFromSVGFile creates a GraphicSVG instance from file.
func ParseFromSVGFile (path string )(*GraphicSVGElement ,error ){_efdad ,_dbcde :=_ac .Open (path );if _dbcde !=nil {return nil ,_dbcde ;};defer _efdad .Close ();return ParseFromSVGStream (_efdad );};

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_dccdg *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dccdg ._fcfgf .Left ,_dccdg ._fcfgf .Right ,_dccdg ._fcfgf .Top ,_dccdg ._fcfgf .Bottom ;};const (GridRowSectionBody GridRowSection =iota ;GridRowSectionHeader ;GridRowSectionFooter ;
GridRowSectionUnknown ;);

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_egb *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_egb ._ecba .Left =left ;_egb ._ecba .Right =right ;_egb ._ecba .Top =top ;_egb ._ecba .Bottom =bottom ;};func _affe (_feeea []token )([]*Command ,error ){var (_afefb []*Command ;_eecdb []float64 ;
);for _adbg :=len (_feeea )-1;_adbg >=0;_adbg --{_degc :=_feeea [_adbg ];if _degc ._aeeeg {_beadc :=_abea ._bffdf [_gg .ToLower (_degc ._dgade )];_ddab :=len (_eecdb );if _beadc ==0&&_ddab ==0{_eaff :=&Command {Symbol :_degc ._dgade };_afefb =append ([]*Command {_eaff },_afefb ...);
}else if _beadc !=0&&_ddab %_beadc ==0{_bgaga :=_ddab /_beadc ;for _eadc :=0;_eadc < _bgaga ;_eadc ++{_cebcc :=_degc ._dgade ;if _cebcc =="\u006d"&&_eadc < _bgaga -1{_cebcc ="\u006c";};if _cebcc =="\u004d"&&_eadc < _bgaga -1{_cebcc ="\u004c";};_befea :=&Command {_cebcc ,_dbbee (_eecdb [:_beadc ])};
_afefb =append ([]*Command {_befea },_afefb ...);_eecdb =_eecdb [_beadc :];};}else {_gbgcff :=pathParserError {"I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0070\u0061r\u0061\u006d\u0065\u0074\u0065\u0072\u0073\u0020\u0066\u006fr\u0020"+_degc ._dgade };
return nil ,_gbgcff ;};}else {_caeef ,_ceeac :=_gfgbeb (_degc ._dgade ,64);if _ceeac !=nil {return nil ,_ceeac ;};_eecdb =append (_eecdb ,_caeef );};};return _afefb ,nil ;};func (_dddfa *Grid )cloneRow (_bagfd int )*GridRow {_eaeg :=&GridRow {_dada :_dddfa ._ffgb ,_bfeeg :_bagfd +1,_cbgd :_dddfa };
for _ ,_gafdf :=range _dddfa ._gafbe [_bagfd ]._adgg {_gdad ,_ :=_eaeg .NewMultiCell (_gafdf ._cdfdb ,1);if _gdad !=nil {_gdad ._adfc =_gafdf ._adfc ;_gdad ._feaeg =_gafdf ._feaeg ;_gdad ._bbcda =_gafdf ._bbcda ;_gdad ._cfbg =_gafdf ._cfbg ;_gdad ._eeada =_gafdf ._eeada ;
_gdad ._adfcb =_gafdf ._adfcb ;_gdad ._eegca =_gafdf ._eegca ;_gdad ._bbbb =_gafdf ._bbbb ;_gdad ._bdd =_gafdf ._bdd ;_gdad ._dfcd =_gafdf ._dfcd ;_gdad ._efbfef =_gafdf ._efbfef ;_gdad ._bfaa =_gafdf ._bfaa ;_gdad ._edadde =_gafdf ._edadde ;_gdad ._bbdaf =_gafdf ._bbdaf ;
_gdad ._gebd =_gafdf ._gebd ;_gdad ._bbga =_gafdf ._bbga ;_gdad ._dedf =_gafdf ._dedf ;_gdad ._gfafe =_gafdf ._gfafe ;_gdad ._affb =_bagfd +1;_gdad ._efdb =_gafdf ._efdb ;};};return _eaeg ;};func (_eedcd *TextStyle )horizontalScale ()float64 {return _eedcd .HorizontalScaling /100};
func (_adbdb *templateProcessor )parseInt64Attr (_gggee ,_fdbag string )int64 {_fge .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gggee ,_fdbag );
_dccb ,_ :=_c .ParseInt (_fdbag ,10,64);return _dccb ;};func (_afgac *templateProcessor )parseCellBorderStyleAttr (_gcaff ,_ggcab string )CellBorderStyle {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_gcaff ,_ggcab );
_gbaee :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_ggcab ];return _gbaee ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_ccb *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ccb ._acgfb .Left ,_ccb ._acgfb .Right ,_ccb ._acgfb .Top ,_ccb ._acgfb .Bottom ;};

// SetFillOpacity sets the fill opacity.
func (_daeg *Polygon )SetFillOpacity (opacity float64 ){_daeg ._cfab =opacity };

// SetEnableWrap sets the line wrapping enabled flag.
func (_ebac *Paragraph )SetEnableWrap (enableWrap bool ){_ebac ._fabc =enableWrap ;_ebac ._bdag =false };func _abbbf (_ffcf *templateProcessor ,_ccdba *templateNode )(interface{},error ){return _ffcf .parsePageBreak (_ccdba );};func _bafc (_fabfea *_cd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_fabfea ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func (_bacfd *templateProcessor )parseChapter (_dbgbb *templateNode )(interface{},error ){_gfbg :=_bacfd .creator .NewChapter ;if _dbgbb ._fbddd !=nil {if _gcff ,_ecgba :=_dbgbb ._fbddd ._bcacc .(*Chapter );_ecgba {_gfbg =_gcff .NewSubchapter ;};};_gfbf :=_gfbg ("");
for _ ,_fcffc :=range _dbgbb ._bcaga .Attr {_ebfea :=_fcffc .Value ;switch _afdee :=_fcffc .Name .Local ;_afdee {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_gfbf .SetShowNumbering (_bacfd .parseBoolAttr (_afdee ,_ebfea ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_gfbf .SetIncludeInTOC (_bacfd .parseBoolAttr (_afdee ,_ebfea ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cgaea :=_bacfd .parseMarginAttr (_afdee ,_ebfea );_gfbf .SetMargins (_cgaea .Left ,_cgaea .Right ,_cgaea .Top ,_cgaea .Bottom );
default:_bacfd .nodeLogDebug (_dbgbb ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_afdee );
};};return _gfbf ,nil ;};

// NewImageFromData creates an Image from image data.
func (_ffbf *Creator )NewImageFromData (data []byte )(*Image ,error ){return _caad (data )};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bggeg *LinearShading )SetAntiAlias (enable bool ){_bggeg ._bedba .SetAntiAlias (enable )};func _faecg (_eeagd []*_cd .PdfAnnotation )[]*_cd .PdfAnnotation {var _ffccd []*_cd .PdfAnnotation ;for _ ,_eageb :=range _eeagd {_ffccd =append (_ffccd ,_fdccb (_eageb ));
};return _ffccd ;};func (_fdfee *TOCLine )prepareParagraph (_fbafd *StyledParagraph ,_fagbef DrawContext ){_ccggf :=_fdfee .Title .Text ;if _fdfee .Number .Text !=""{_ccggf ="\u0020"+_ccggf ;};_ccggf +="\u0020";_abbc :=_fdfee .Page .Text ;if _abbc !=""{_abbc ="\u0020"+_abbc ;
};_efdbb :=[]*_cd .PdfAnnotation {};_eebbg :=_fdfee .getLineLink ();if _eebbg !=nil {_efdbb =append (_efdbb ,_eebbg );};_fbafd ._bcebd =[]*TextChunk {{Text :_fdfee .Number .Text ,Style :_fdfee .Number .Style ,_badce :_efdbb },{Text :_ccggf ,Style :_fdfee .Title .Style ,_badce :_efdbb },{Text :_abbc ,Style :_fdfee .Page .Style ,_badce :_efdbb }};
_fbafd .wrapText ();_dfbd :=len (_fbafd ._adcf );if _dfbd ==0{return ;};_cbcfd :=_fagbef .Width *1000-_fbafd .getTextLineWidth (_fbafd ._adcf [_dfbd -1]);_eggage :=_fbafd .getTextLineWidth ([]*TextChunk {&_fdfee .Separator });_dfabc :=int (_cbcfd /_eggage );
_efag :=_gg .Repeat (_fdfee .Separator .Text ,_dfabc );_caeag :=_fdfee .Separator .Style ;_eaecg :=_fbafd .Insert (2,_efag );_eaecg .Style =_caeag ;_eaecg .SetAnnotation (_fdfee .getLineLink ());_cbcfd =_cbcfd -float64 (_dfabc )*_eggage ;if _cbcfd > 500{_baegb ,_eaffg :=_caeag .Font .GetRuneMetrics (' ');
if _eaffg &&_cbcfd > _baegb .Wx {_dgbdc :=int (_cbcfd /_baegb .Wx );if _dgbdc > 0{_effgf :=_caeag ;_effgf .FontSize =1;_eaecg =_fbafd .Insert (2,_gg .Repeat ("\u0020",_dgbdc ));_eaecg .Style =_effgf ;_eaecg .SetAnnotation (_fdfee .getLineLink ());};};};
};

// Inline returns whether the inline mode of the division is active.
func (_edadd *Division )Inline ()bool {return _edadd ._abdc };

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_adcd *Division )SetMargins (left ,right ,top ,bottom float64 ){_adcd ._gadc .Left =left ;_adcd ._gadc .Right =right ;_adcd ._gadc .Top =top ;_adcd ._gadc .Bottom =bottom ;};type commands struct{_bbcdd []string ;_bffdf map[string ]int ;_geee string ;
_gcdba string ;};

// SkipRows skips over a specified number of rows in the table.
func (_fcab *Table )SkipRows (num int ){_baage :=num *_fcab ._ccabb -1;if _baage < 0{_fge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _gdeffc :=0;_gdeffc < _baage ;_gdeffc ++{_fcab .NewCell ();};};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_ebdff *List )Marker ()*TextChunk {return &_ebdff ._fccc };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_fdgb *templateProcessor )parseFitModeAttr (_bgfg ,_cedcd string )FitMode {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_bgfg ,_cedcd );
_dcgfg :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_cedcd ];return _dcgfg ;};

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};

// GeneratePageBlocks draw graphic svg into block.
func (_bggd *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faee :=ctx ;_faed :=_bggd ._acgg .IsRelative ();var _ecdf []*Block ;if _faed {_ggdee :=1.0;_cfba :=_bggd ._cded .Top ;if _bggd ._dcdb .Height > ctx .Height -_bggd ._cded .Top {_ecdf =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _eade error ;if _ ,ctx ,_eade =_acga ().GeneratePageBlocks (ctx );_eade !=nil {return nil ,ctx ,_eade ;};_cfba =0;};ctx .X +=_bggd ._cded .Left +_ggdee ;ctx .Y +=_cfba ;ctx .Width -=_bggd ._cded .Left +_bggd ._cded .Right +2*_ggdee ;ctx .Height -=_cfba ;
}else {ctx .X =_bggd ._fdgf ;ctx .Y =_bggd ._fegbbc ;};_bffa :=_fgc .NewContentCreator ();_bffa .Translate (0,ctx .PageHeight );_bffa .Scale (1,-1);_bffa .Translate (ctx .X ,ctx .Y );_ecda :=_bggd ._dcdb .Width /_bggd ._dcdb .ViewBox .W ;_bagbg :=_bggd ._dcdb .Height /_bggd ._dcdb .ViewBox .H ;
_bffd :=0.0;_egacf :=0.0;if _faed {_bffd =_bggd ._fdgf -(_bggd ._dcdb .ViewBox .X *_bd .Max (_ecda ,_bagbg ));_egacf =_bggd ._fegbbc -(_bggd ._dcdb .ViewBox .Y *_bd .Max (_ecda ,_bagbg ));};_gegcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bggd ._aefb !=nil {_bffa .Add_BDC (*_cdf .MakeName (string (_bggd ._aefb .StructureType )),map[string ]_cdf .PdfObject {"\u004d\u0043\u0049\u0044":_cdf .MakeInteger (_bggd ._aefb .Mcid )});
};_bggd ._dcdb .SetPos (ctx .X ,ctx .Y );_bggd ._dcdb .ToContentCreator (_bffa ,_gegcg ._gaa ,_ecda ,_bagbg ,_bffd ,_egacf );if _bggd ._aefb !=nil {_bffa .Add_EMC ();};if _caeg :=_gegcg .addContentsByString (_bffa .String ());_caeg !=nil {return nil ,ctx ,_caeg ;
};if _faed {_dgcb :=_bggd .Height ()+_bggd ._cded .Bottom ;ctx .Y +=_dgcb ;ctx .Height -=_dgcb ;}else {ctx =_faee ;};_ecdf =append (_ecdf ,_gegcg );return _ecdf ,ctx ,nil ;};

// Height returns the total height of all rows.
func (_eadee *Table )Height ()float64 {_bdcf :=float64 (0.0);for _ ,_bdfcb :=range _eadee ._fgege {_bdcf +=_bdfcb ;};return _bdcf ;};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_eggd *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _efgd (xc ,yc ,width ,height );};func _dbbee (_deecb []float64 )[]float64 {for _gdgb ,_begb :=0,len (_deecb )-1;_gdgb < _begb ;_gdgb ,_begb =_gdgb +1,_begb -1{_deecb [_gdgb ],_deecb [_begb ]=_deecb [_begb ],_deecb [_gdgb ];
};return _deecb ;};

// NewGrid creates a new Grid with a specified number of columns.
func (_efc *Creator )NewGrid (cols int )*Grid {return _feed (cols )};

// SetLineOpacity sets the line opacity.
func (_cdead *Polyline )SetLineOpacity (opacity float64 ){_cdead ._becd =opacity };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_efef *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdgcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egc ,_cfcc :=_bdgcg .setOpacity (_efef ._ddca ,_efef ._add );if _cfcc !=nil {return nil ,ctx ,_cfcc ;};
_gece :=_efef ._cgbfg ;_gece .FillEnabled =_gece .FillColor !=nil ;_gece .BorderEnabled =_gece .BorderColor !=nil &&_gece .BorderWidth > 0;var (_bbef =ctx .PageHeight ;_bcea =_gece .Rings ;_bcac =make ([][]_ggb .CubicBezierCurve ,0,len (_gece .Rings ));
);_ggec :=_cd .PdfRectangle {};if len (_bcea )> 0&&len (_bcea [0])> 0{_fabb :=_bcea [0][0];_fabb .P0 .Y =_bbef -_fabb .P0 .Y ;_fabb .P1 .Y =_bbef -_fabb .P1 .Y ;_fabb .P2 .Y =_bbef -_fabb .P2 .Y ;_fabb .P3 .Y =_bbef -_fabb .P3 .Y ;_ggec =_fabb .GetBounds ();
};for _ ,_ffag :=range _bcea {_gefa :=make ([]_ggb .CubicBezierCurve ,0,len (_ffag ));for _ ,_bggf :=range _ffag {_egcd :=_bggf ;_egcd .P0 .Y =_bbef -_egcd .P0 .Y ;_egcd .P1 .Y =_bbef -_egcd .P1 .Y ;_egcd .P2 .Y =_bbef -_egcd .P2 .Y ;_egcd .P3 .Y =_bbef -_egcd .P3 .Y ;
_gefa =append (_gefa ,_egcd );_eaa :=_egcd .GetBounds ();_ggec .Llx =_bd .Min (_ggec .Llx ,_eaa .Llx );_ggec .Lly =_bd .Min (_ggec .Lly ,_eaa .Lly );_ggec .Urx =_bd .Max (_ggec .Urx ,_eaa .Urx );_ggec .Ury =_bd .Max (_ggec .Ury ,_eaa .Ury );};_bcac =append (_bcac ,_gefa );
};_gece .Rings =_bcac ;defer func (){_gece .Rings =_bcea }();if _gece .FillEnabled {_gcad :=_dbdga (_bdgcg ,_efef ._cgbfg .FillColor ,_efef ._aed ,func ()Rectangle {return Rectangle {_bdcc :_ggec .Llx ,_dbgd :_ggec .Lly ,_bfed :_ggec .Width (),_abdcf :_ggec .Height ()};
});if _gcad !=nil {return nil ,ctx ,_gcad ;};};_ecec ,_ ,_cfcc :=_gece .MarkedDraw (_egc ,_efef ._aefb );if _cfcc !=nil {return nil ,ctx ,_cfcc ;};if _cfcc =_bdgcg .addContentsByString (string (_ecec ));_cfcc !=nil {return nil ,ctx ,_cfcc ;};return []*Block {_bdgcg },ctx ,nil ;
};

// SetMargins sets the margins of the chart component.
func (_bbfe *Chart )SetMargins (left ,right ,top ,bottom float64 ){_bbfe ._cfad .Left =left ;_bbfe ._cfad .Right =right ;_bbfe ._cfad .Top =top ;_bbfe ._cfad .Bottom =bottom ;};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _gegc (path )};

// SetBorderColor sets the border color.
func (_cfea *CurvePolygon )SetBorderColor (color Color ){_cfea ._cgbfg .BorderColor =_acac (color )};

// Heading returns the heading component of the table of contents.
func (_daaf *TOC )Heading ()*StyledParagraph {return _daaf ._bbgfb };

// SetOpacity sets the opacity of the line (0-1).
func (_dcgf *Line )SetOpacity (opacity float64 ){_dcgf ._accf =opacity };func (_bdcga *GraphicSVGElement )drawRect (_aeacg *_fgc .ContentCreator ,_ggeg *_cd .PdfPageResources ){_aeacg .Add_q ();_bdcga .Style .toContentStream (_aeacg ,_ggeg ,_bdcga );_facef ,_gbcd :=_gfgbeb (_bdcga .Attributes ["\u0078"],64);
if _gbcd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_gbcd .Error ());};_cgfc ,_gbcd :=_gfgbeb (_bdcga .Attributes ["\u0079"],64);
if _gbcd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_gbcd .Error ());};_accbf ,_gbcd :=_gfgbeb (_bdcga .Attributes ["\u0077\u0069\u0064t\u0068"],64);
if _gbcd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gbcd .Error ());
};_acadg ,_gbcd :=_gfgbeb (_bdcga .Attributes ["\u0068\u0065\u0069\u0067\u0068\u0074"],64);if _gbcd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0077h\u0069\u006c\u0065 \u0070\u0061\u0072\u0073i\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gbcd .Error ());
};_aeacg .Add_re (_facef *_bdcga ._fgdg ,_cgfc *_bdcga ._fgdg ,_accbf *_bdcga ._fgdg ,_acadg *_bdcga ._fgdg );_bdcga .Style .fillStroke (_aeacg );_aeacg .Add_Q ();};func _agbaa (_gceba VectorDrawable ,_fdbcf float64 )float64 {switch _ecbcd :=_gceba .(type ){case *Paragraph :if _ecbcd ._fabc {_ecbcd .SetWidth (_fdbcf -_ecbcd ._dcfd .Left -_ecbcd ._dcfd .Right );
};return _ecbcd .Height ()+_ecbcd ._dcfd .Top +_ecbcd ._dcfd .Bottom +(0.5*_ecbcd ._dgdde *_ecbcd ._fbdcb );case *StyledParagraph :if _ecbcd ._bccfb {_ecbcd .SetWidth (_fdbcf -_ecbcd ._acgdg .Left -_ecbcd ._acgdg .Right );};return _ecbcd .Height ()+_ecbcd ._acgdg .Top +_ecbcd ._acgdg .Bottom +(0.5*_ecbcd .getTextHeight ());
case *Image :_ecbcd .applyFitMode (_fdbcf );return _ecbcd .Height ()+_ecbcd ._begc .Top +_ecbcd ._begc .Bottom ;case *Rectangle :_ecbcd .applyFitMode (_fdbcf );return _ecbcd .Height ()+_ecbcd ._fcfgf .Top +_ecbcd ._fcfgf .Bottom +_ecbcd ._effb ;case *Ellipse :_ecbcd .applyFitMode (_fdbcf );
return _ecbcd .Height ()+_ecbcd ._ffdg .Top +_ecbcd ._ffdg .Bottom ;case *Division :return _ecbcd .ctxHeight (_fdbcf )+_ecbcd ._gadc .Top +_ecbcd ._gadc .Bottom +_ecbcd ._egcf .Top +_ecbcd ._egcf .Bottom ;case *Table :_ecbcd .updateRowHeights (_fdbcf -_ecbcd ._ffegb .Left -_ecbcd ._ffegb .Right );
return _ecbcd .Height ()+_ecbcd ._ffegb .Top +_ecbcd ._ffegb .Bottom ;case *List :return _ecbcd .ctxHeight (_fdbcf )+_ecbcd ._bcefc .Top +_ecbcd ._bcefc .Bottom ;case marginDrawable :_ ,_ ,_bfb ,_dfcb :=_ecbcd .GetMargins ();return _ecbcd .Height ()+_bfb +_dfcb ;
default:return _ecbcd .Height ();};};func (_cgdf rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _cgdf ._ecdce ,_cgdf ._baae ,_cgdf ._acaa ;};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_eagbg *TOC )SetHeading (text string ,style TextStyle ){_fcde :=_eagbg .Heading ();_fcde .Reset ();_ffgfef :=_fcde .Append (text );_ffgfef .Style =style ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_acbdc *RadialShading )AddPatternResource (block *Block )(_fbdb _cdf .PdfObjectName ,_cbcde error ){_edfb :=1;_bebbe :=_cdf .PdfObjectName ("\u0050"+_c .Itoa (_edfb ));for block ._gaa .HasPatternByName (_bebbe ){_edfb ++;_bebbe =_cdf .PdfObjectName ("\u0050"+_c .Itoa (_edfb ));
};if _ecfeg :=block ._gaa .SetPatternByName (_bebbe ,_acbdc .ToPdfShadingPattern ().ToPdfObject ());_ecfeg !=nil {return "",_ecfeg ;};return _bebbe ,nil ;};

// SetStructureType sets the structure type for the grid.
func (_gbfff *Grid )SetStructureType (structureType _cd .StructureType ){if _gbfff ._aefb ==nil {_gbfff ._aefb =&_cd .StructureTagInfo {};};_gbfff ._aefb .StructureType =structureType ;if _gbfff ._aefb .ComponentKObj ==nil {if _gbfff ._aefb .ParentKObj !=nil {_gbfff ._aefb .ParentKObj .RemoveKChild (_gbfff ._aefb .ComponentKObj );
};_gbfff ._aefb .ComponentKObj =_cd .NewKDictionary ();_gbfff ._aefb .ComponentKObj .S =_cdf .MakeName (string (structureType ));_gbfff ._aefb .ParentKObj .AddKChild (_gbfff ._aefb .ComponentKObj );};};

// Lines returns all the lines the table of contents has.
func (_gacga *TOC )Lines ()[]*TOCLine {return _gacga ._affbb };

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_fbd *Block )SetStructureType (structureType _cd .StructureType ){};func (_gdebb *templateProcessor )parseChart (_efcg *templateNode )(interface{},error ){var _adaa string ;for _ ,_befc :=range _efcg ._bcaga .Attr {_gfge :=_befc .Value ;switch _bgcfe :=_befc .Name .Local ;
_bgcfe {case "\u0073\u0072\u0063":_adaa =_gfge ;};};if _adaa ==""{_gdebb .nodeLogError (_efcg ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_geccd ;};_geebb ,_eaae :=_gdebb ._ccdf .ChartMap [_adaa ];if !_eaae {_gdebb .nodeLogError (_efcg ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_adaa );
return nil ,_geccd ;};_daad :=NewChart (_geebb );for _ ,_bdbbd :=range _efcg ._bcaga .Attr {_ffagdb :=_bdbbd .Value ;switch _fdeca :=_bdbbd .Name .Local ;_fdeca {case "\u0078":_daad .SetPos (_gdebb .parseFloatAttr (_fdeca ,_ffagdb ),_daad ._cfa );case "\u0079":_daad .SetPos (_daad ._cceb ,_gdebb .parseFloatAttr (_fdeca ,_ffagdb ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_agdef :=_gdebb .parseMarginAttr (_fdeca ,_ffagdb );_daad .SetMargins (_agdef .Left ,_agdef .Right ,_agdef .Top ,_agdef .Bottom );case "\u0077\u0069\u0064t\u0068":_daad ._ggab .SetWidth (int (_gdebb .parseFloatAttr (_fdeca ,_ffagdb )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_daad ._ggab .SetHeight (int (_gdebb .parseFloatAttr (_fdeca ,_ffagdb )));case "\u0073\u0072\u0063":break ;default:_gdebb .nodeLogDebug (_efcg ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fdeca );
};};return _daad ,nil ;};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_bbdg *Ellipse )ScaleToHeight (h float64 ){_efcb :=_bbdg ._bgfbe /_bbdg ._ffaee ;_bbdg ._ffaee =h ;_bbdg ._bgfbe =h *_efcb ;};

// AddColorStop add color stop info for rendering gradient color.
func (_egbad *RadialShading )AddColorStop (color Color ,point float64 ){_egbad ._ggbe .AddColorStop (color ,point );};func (_cacg *Paragraph )getTextWidth ()float64 {_edacb :=0.0;for _ ,_bgacb :=range _cacg ._egda {if _bgacb =='\u000A'{continue ;};_dggf ,_dddfb :=_cacg ._gcfa .GetRuneMetrics (_bgacb );
if !_dddfb {_fge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bgacb ,_bgacb );
return -1;};_edacb +=_cacg ._dgdde *_dggf .Wx ;};return _edacb ;};func (_ccdd *Grid )resetColumnWidths (){_ccdd ._gded =[]float64 {};_dgbb :=float64 (1.0)/float64 (_ccdd ._abgd );for _cefa :=0;_cefa < _ccdd ._abgd ;_cefa ++{_ccdd ._gded =append (_ccdd ._gded ,_dgbb );
};};

// This method is not supported by PageBreak component and exists solely to satisfy the Drawable interface.
func (_cgdc *PageBreak )GenerateKDict ()(*_cd .KDict ,error ){return nil ,nil };

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_efdd *Chapter )GetHeading ()*StyledParagraph {return _efdd ._bebf };

// Level returns the indentation level of the TOC line.
func (_efgg *TOCLine )Level ()uint {return _efgg ._feacc };func _gbdgf (_ddbae *templateProcessor ,_dgac *templateNode )(interface{},error ){return _ddbae .parseChapterHeading (_dgac );};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_bed *Block )Draw (d Drawable )error {_cc :=DrawContext {};_cc .Width =_bed ._ce ;_cc .Height =_bed ._ff ;_cc .PageWidth =_bed ._ce ;_cc .PageHeight =_bed ._ff ;_cc .X =0;_cc .Y =0;_gacc ,_ ,_fad :=d .GeneratePageBlocks (_cc );if _fad !=nil {return _fad ;
};if len (_gacc )!=1{return ErrContentNotFit ;};for _ ,_dba :=range _gacc {if _ddc :=_bed .mergeBlocks (_dba );_ddc !=nil {return _ddc ;};};return nil ;};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{taggedDrawable ;_dcdb *GraphicSVGElement ;_acgg Positioning ;_fdgf float64 ;_fegbbc float64 ;_cded Margins ;};

// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_bdff :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_fge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bdff ;
};var _abef int ;if len (hexStr )==2{var _ceda int ;_bdgc ,_ceag :=_a .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_ceda );if _ceag !=nil {_fge .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_ceag );
return _bdff ;};if _bdgc !=1{_fge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bdff ;};_abef =_ceda *16+_ceda ;}else {_eef ,_bdcd :=_a .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_abef );
if _bdcd !=nil {_fge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bdff ;};if _eef !=1{_fge .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_eef );
return _bdff ;};};_bdff ._adae =float64 (_abef )/255.0;return _bdff ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_edee *Creator )SetPageLabels (pageLabels _cdf .PdfObject ){_edee ._fafg =pageLabels };func _gcbcb (_adcadb ...interface{})(map[string ]interface{},error ){_ebae :=len (_adcadb );if _ebae %2!=0{_fge .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_ebae );
return nil ,_cdf .ErrRangeError ;};_fbdge :=map[string ]interface{}{};for _ecbaa :=0;_ecbaa < _ebae ;_ecbaa +=2{_badfd ,_eeegb :=_adcadb [_ecbaa ].(string );if !_eeegb {_fge .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_adcadb [_ecbaa ]);
return nil ,_cdf .ErrTypeError ;};_fbdge [_badfd ]=_adcadb [_ecbaa +1];};return _fbdge ,nil ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_ccbdb *FilledCurve )AppendCurve (curve _ggb .CubicBezierCurve )*FilledCurve {_ccbdb ._dbdfe =append (_ccbdb ._dbdfe ,curve );return _ccbdb ;};

// SetLineHeight sets the line height (1.0 default).
func (_bdgfc *Paragraph )SetLineHeight (lineheight float64 ){_bdgfc ._fbdcb =lineheight };func (_baeg *Invoice )newColumn (_dcaef string ,_dfdgg CellHorizontalAlignment )*InvoiceCell {_babdc :=&InvoiceCell {_baeg ._fdcdb ,_dcaef };_babdc .Alignment =_dfdgg ;
return _babdc ;};const (DefaultHorizontalScaling =100;);

// GetIndent get the cell's left indent.
func (_dcbfd *GridCell )GetIndent ()float64 {return _dcbfd ._dedf };

// AddTag adds the table row tag for Grid to the root K object.
func (_ecffa *GridRow )AddTag (rootKObj *_cd .KDict ){if rootKObj ==nil {_fge .Log .Debug ("\u0054\u0061\u0062\u006ce\u003a\u0020\u0041\u0064\u0064\u0054\u0061\u0067\u0020c\u0061\u006c\u006c\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u0069\u006c\u0020\u0072\u006f\u006ft\u004b\u004f\u0062\u006a\u002c \u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0074\u0061\u0067\u0067\u0069\u006e\u0067\u002e");
return ;};if _ecffa ._ddda ==nil {_ecffa ._ddda =_cd .NewStructureTagInfo ();_ecffa ._ddda .StructureType =_cd .StructureTypeTableRow ;};_ecffa ._ddda .ParentKObj =rootKObj ;_ecffa ._ddda .ComponentKObj =_cd .NewKDictionary ();_ecffa ._ddda .ComponentKObj .S =_cdf .MakeName (string (_ecffa ._ddda .StructureType ));
_ecffa ._ddda .ParentKObj .AddKChild (_ecffa ._ddda .ComponentKObj );};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gddc *StyledParagraph )SetTextAlignment (align TextAlignment ){_gddc ._dffe =align };

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_ede *Chart )Width ()float64 {return float64 (_ede ._ggab .Width ())};

// NewImage create a new image from a unidoc image (model.Image).
func (_dbdc *Creator )NewImage (img *_cd .Image )(*Image ,error ){return _bgfa (img )};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_gabb *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_gabb ._acgfb .Left =left ;_gabb ._acgfb .Right =right ;_gabb ._acgfb .Top =top ;_gabb ._acgfb .Bottom =bottom ;};func (_bfbg *Paragraph )getMaxLineWidth ()float64 {if _bfbg ._dcfdd ==nil ||(_bfbg ._dcfdd !=nil &&len (_bfbg ._dcfdd )==0){_bfbg .wrapText ();
};var _gdfb float64 ;for _ ,_cbad :=range _bfbg ._dcfdd {_adfbc :=_bfbg .getTextLineWidth (_cbad );if _adfbc > _gdfb {_gdfb =_adfbc ;};};return _gdfb ;};

// Subpath is a collection of Commands, beginning with moveto command and
// usually ending with closepath command.
type Subpath struct{Commands []*Command ;};func (_cbaec *templateProcessor )parseTableCell (_adcgb *templateNode )(interface{},error ){if _adcgb ._fbddd ==nil {_cbaec .nodeLogError (_adcgb ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_egfg ;};_efcdb ,_eefb :=_adcgb ._fbddd ._bcacc .(*Table );if !_eefb {_cbaec .nodeLogError (_adcgb ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_adcgb ._fbddd ._bcacc );
return nil ,_egfg ;};var _dcbce ,_aaacf int64 ;for _ ,_fgaef :=range _adcgb ._bcaga .Attr {_gbcf :=_fgaef .Value ;switch _fdeac :=_fgaef .Name .Local ;_fdeac {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_dcbce =_cbaec .parseInt64Attr (_fdeac ,_gbcf );
case "\u0072o\u0077\u0073\u0070\u0061\u006e":_aaacf =_cbaec .parseInt64Attr (_fdeac ,_gbcf );};};if _dcbce <=0{_dcbce =1;};if _aaacf <=0{_aaacf =1;};_gfbe :=_efcdb .MultiCell (int (_aaacf ),int (_dcbce ));for _ ,_aaab :=range _adcgb ._bcaga .Attr {_gggce :=_aaab .Value ;
switch _ccefb :=_aaab .Name .Local ;_ccefb {case "\u0069\u006e\u0064\u0065\u006e\u0074":_gfbe .SetIndent (_cbaec .parseFloatAttr (_ccefb ,_gggce ));case "\u0061\u006c\u0069g\u006e":_gfbe .SetHorizontalAlignment (_cbaec .parseCellAlignmentAttr (_ccefb ,_gggce ));
case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_gfbe .SetVerticalAlignment (_cbaec .parseCellVerticalAlignmentAttr (_ccefb ,_gggce ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_gfbe .SetSideBorderStyle (CellBorderSideAll ,_cbaec .parseCellBorderStyleAttr (_ccefb ,_gggce ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_gfbe .SetSideBorderStyle (CellBorderSideTop ,_cbaec .parseCellBorderStyleAttr (_ccefb ,_gggce ));case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gfbe .SetSideBorderStyle (CellBorderSideBottom ,_cbaec .parseCellBorderStyleAttr (_ccefb ,_gggce ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_gfbe .SetSideBorderStyle (CellBorderSideLeft ,_cbaec .parseCellBorderStyleAttr (_ccefb ,_gggce ));case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_gfbe .SetSideBorderStyle (CellBorderSideRight ,_cbaec .parseCellBorderStyleAttr (_ccefb ,_gggce ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_gfbe .SetSideBorderWidth (CellBorderSideAll ,_cbaec .parseFloatAttr (_ccefb ,_gggce ));case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_gfbe .SetSideBorderWidth (CellBorderSideTop ,_cbaec .parseFloatAttr (_ccefb ,_gggce ));
case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gfbe .SetSideBorderWidth (CellBorderSideBottom ,_cbaec .parseFloatAttr (_ccefb ,_gggce ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_gfbe .SetSideBorderWidth (CellBorderSideLeft ,_cbaec .parseFloatAttr (_ccefb ,_gggce ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_gfbe .SetSideBorderWidth (CellBorderSideRight ,_cbaec .parseFloatAttr (_ccefb ,_gggce ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gfbe .SetSideBorderColor (CellBorderSideAll ,_cbaec .parseColorAttr (_ccefb ,_gggce ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_gfbe .SetSideBorderColor (CellBorderSideTop ,_cbaec .parseColorAttr (_ccefb ,_gggce ));case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gfbe .SetSideBorderColor (CellBorderSideBottom ,_cbaec .parseColorAttr (_ccefb ,_gggce ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_gfbe .SetSideBorderColor (CellBorderSideLeft ,_cbaec .parseColorAttr (_ccefb ,_gggce ));case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_gfbe .SetSideBorderColor (CellBorderSideRight ,_cbaec .parseColorAttr (_ccefb ,_gggce ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_gfbe .SetBorderLineStyle (_cbaec .parseLineStyleAttr (_ccefb ,_gggce ));case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_gfbe .SetBackgroundColor (_cbaec .parseColorAttr (_ccefb ,_gggce ));
case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;default:_cbaec .nodeLogDebug (_adcgb ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ccefb );
};};return _gfbe ,nil ;};

// Padding returns the padding of the component.
func (_gbfg *Division )Padding ()(_gecgb ,_gdde ,_ffgf ,_ebbb float64 ){return _gbfg ._egcf .Left ,_gbfg ._egcf .Right ,_gbfg ._egcf .Top ,_gbfg ._egcf .Bottom ;};func (_dgbae *GraphicSVGElement )drawPath (_dggea *_fgc .ContentCreator ,_fdcf *_cd .PdfPageResources ){_dggea .Add_q ();
_dgbae .Style .toContentStream (_dggea ,_fdcf ,_dgbae );_cgbge (_dgbae ,_dggea );_gceaa ,_gdfba :=_gbefc (_dgbae .Attributes ["\u0064"]);if _gdfba !=nil {_fge .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025s",_gdfba .Error ());};var (_ffdca ,_gfafg =0.0,0.0;
_cbaef ,_fcbaa =0.0,0.0;_gabbf *Command ;);for _ ,_fbcg :=range _gceaa .Subpaths {for _ ,_eceed :=range _fbcg .Commands {switch _gg .ToLower (_eceed .Symbol ){case "\u006d":_cbaef ,_fcbaa =_eceed .Params [0]*_dgbae ._fgdg ,_eceed .Params [1]*_dgbae ._fgdg ;
if !_eceed .isAbsolute (){_cbaef ,_fcbaa =_ffdca +_cbaef -_dgbae .ViewBox .X ,_gfafg +_fcbaa -_dgbae .ViewBox .Y ;};_dggea .Add_m (_fag .RoundFloat (_cbaef ,3),_fag .RoundFloat (_fcbaa ,3));_ffdca ,_gfafg =_cbaef ,_fcbaa ;case "\u0063":_bbbbe ,_edgf ,_agdc ,_bbdbc ,_bfbd ,_adbcg :=_eceed .Params [0]*_dgbae ._fgdg ,_eceed .Params [1]*_dgbae ._fgdg ,_eceed .Params [2]*_dgbae ._fgdg ,_eceed .Params [3]*_dgbae ._fgdg ,_eceed .Params [4]*_dgbae ._fgdg ,_eceed .Params [5]*_dgbae ._fgdg ;
if !_eceed .isAbsolute (){_bbbbe ,_edgf ,_agdc ,_bbdbc ,_bfbd ,_adbcg =_ffdca +_bbbbe ,_gfafg +_edgf ,_ffdca +_agdc ,_gfafg +_bbdbc ,_ffdca +_bfbd ,_gfafg +_adbcg ;};_dggea .Add_c (_fag .RoundFloat (_bbbbe ,3),_fag .RoundFloat (_edgf ,3),_fag .RoundFloat (_agdc ,3),_fag .RoundFloat (_bbdbc ,3),_fag .RoundFloat (_bfbd ,3),_fag .RoundFloat (_adbcg ,3));
_ffdca ,_gfafg =_bfbd ,_adbcg ;case "\u0073":_daggd ,_dfadb ,_begdc ,_cefagc :=_eceed .Params [0]*_dgbae ._fgdg ,_eceed .Params [1]*_dgbae ._fgdg ,_eceed .Params [2]*_dgbae ._fgdg ,_eceed .Params [3]*_dgbae ._fgdg ;if !_eceed .isAbsolute (){_daggd ,_dfadb ,_begdc ,_cefagc =_ffdca +_daggd ,_gfafg +_dfadb ,_ffdca +_begdc ,_gfafg +_cefagc ;
};_dggea .Add_c (_fag .RoundFloat (_ffdca ,3),_fag .RoundFloat (_gfafg ,3),_fag .RoundFloat (_daggd ,3),_fag .RoundFloat (_dfadb ,3),_fag .RoundFloat (_begdc ,3),_fag .RoundFloat (_cefagc ,3));_ffdca ,_gfafg =_begdc ,_cefagc ;case "\u006c":_cdag ,_feeg :=_eceed .Params [0]*_dgbae ._fgdg ,_eceed .Params [1]*_dgbae ._fgdg ;
if !_eceed .isAbsolute (){_cdag ,_feeg =_ffdca +_cdag ,_gfafg +_feeg ;};_dggea .Add_l (_fag .RoundFloat (_cdag ,3),_fag .RoundFloat (_feeg ,3));_ffdca ,_gfafg =_cdag ,_feeg ;case "\u0068":_bcce :=_eceed .Params [0]*_dgbae ._fgdg ;if !_eceed .isAbsolute (){_bcce =_ffdca +_bcce ;
};_dggea .Add_l (_fag .RoundFloat (_bcce ,3),_fag .RoundFloat (_gfafg ,3));_ffdca =_bcce ;case "\u0076":_gfea :=_eceed .Params [0]*_dgbae ._fgdg ;if !_eceed .isAbsolute (){_gfea =_gfafg +_gfea ;};_dggea .Add_l (_fag .RoundFloat (_ffdca ,3),_fag .RoundFloat (_gfea ,3));
_gfafg =_gfea ;case "\u0071":_aedag ,_cbdab ,_bfgcc ,_eafacc :=_eceed .Params [0]*_dgbae ._fgdg ,_eceed .Params [1]*_dgbae ._fgdg ,_eceed .Params [2]*_dgbae ._fgdg ,_eceed .Params [3]*_dgbae ._fgdg ;if !_eceed .isAbsolute (){_aedag ,_cbdab ,_bfgcc ,_eafacc =_ffdca +_aedag ,_gfafg +_cbdab ,_ffdca +_bfgcc ,_gfafg +_eafacc ;
};_gaaebe ,_gfaeb :=_ag .QuadraticToCubicBezier (_ffdca ,_gfafg ,_aedag ,_cbdab ,_bfgcc ,_eafacc );_dggea .Add_c (_fag .RoundFloat (_gaaebe .X ,3),_fag .RoundFloat (_gaaebe .Y ,3),_fag .RoundFloat (_gfaeb .X ,3),_fag .RoundFloat (_gfaeb .Y ,3),_fag .RoundFloat (_bfgcc ,3),_fag .RoundFloat (_eafacc ,3));
_ffdca ,_gfafg =_bfgcc ,_eafacc ;case "\u0074":var _agab ,_ddcf _ag .Point ;_eaaaf ,_cbab :=_eceed .Params [0]*_dgbae ._fgdg ,_eceed .Params [1]*_dgbae ._fgdg ;if !_eceed .isAbsolute (){_eaaaf ,_cbab =_ffdca +_eaaaf ,_gfafg +_cbab ;};if _gabbf !=nil &&_gg .ToLower (_gabbf .Symbol )=="\u0071"{_dffdc :=_ag .Point {X :_gabbf .Params [0]*_dgbae ._fgdg ,Y :_gabbf .Params [1]*_dgbae ._fgdg };
_bcbbf :=_ag .Point {X :_gabbf .Params [2]*_dgbae ._fgdg ,Y :_gabbf .Params [3]*_dgbae ._fgdg };_gcfb :=_bcbbf .Mul (2.0).Sub (_dffdc );_agab ,_ddcf =_ag .QuadraticToCubicBezier (_ffdca ,_gfafg ,_gcfb .X ,_gcfb .Y ,_eaaaf ,_cbab );};_dggea .Add_c (_fag .RoundFloat (_agab .X ,3),_fag .RoundFloat (_agab .Y ,3),_fag .RoundFloat (_ddcf .X ,3),_fag .RoundFloat (_ddcf .Y ,3),_fag .RoundFloat (_eaaaf ,3),_fag .RoundFloat (_cbab ,3));
_ffdca ,_gfafg =_eaaaf ,_cbab ;case "\u0061":_fcdfd ,_fgagd :=_eceed .Params [0]*_dgbae ._fgdg ,_eceed .Params [1]*_dgbae ._fgdg ;_fdada :=_eceed .Params [2];_aacbg :=_eceed .Params [3]> 0;_gccdc :=_eceed .Params [4]> 0;_agdcg ,_debc :=_eceed .Params [5]*_dgbae ._fgdg ,_eceed .Params [6]*_dgbae ._fgdg ;
if !_eceed .isAbsolute (){_agdcg ,_debc =_ffdca +_agdcg ,_gfafg +_debc ;};_cdabg :=_ag .EllipseToCubicBeziers (_ffdca ,_gfafg ,_fcdfd ,_fgagd ,_fdada ,_aacbg ,_gccdc ,_agdcg ,_debc );for _ ,_gcedd :=range _cdabg {_dggea .Add_c (_fag .RoundFloat (_gcedd [1].X ,3),_fag .RoundFloat ((_gcedd [1].Y ),3),_fag .RoundFloat ((_gcedd [2].X ),3),_fag .RoundFloat ((_gcedd [2].Y ),3),_fag .RoundFloat ((_gcedd [3].X ),3),_fag .RoundFloat ((_gcedd [3].Y ),3));
};_ffdca ,_gfafg =_agdcg ,_debc ;case "\u007a":_dggea .Add_h ();};_gabbf =_eceed ;};};_dgbae .Style .fillStroke (_dggea );_dggea .Add_h ();_dggea .Add_Q ();};

// NewCell makes a new single cell and inserts it into the row at the current position.
func (_fcdb *GridRow )NewCell ()(*GridCell ,error ){return _fcdb .NewMultiCell (1,1)};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_bedba *shading ;_gbgeb *_cd .PdfRectangle ;_bffe float64 ;};func (_cee *Block )setOpacity (_bc float64 ,_gfe float64 )(string ,error ){if (_bc < 0||_bc >=1.0)&&(_gfe < 0||_gfe >=1.0){return "",nil ;};_ab :=0;_fde :=_a .Sprintf ("\u0047\u0053\u0025\u0064",_ab );
for _cee ._gaa .HasExtGState (_cdf .PdfObjectName (_fde )){_ab ++;_fde =_a .Sprintf ("\u0047\u0053\u0025\u0064",_ab );};_aa :=_cdf .MakeDict ();if _bc >=0&&_bc < 1.0{_aa .Set ("\u0063\u0061",_cdf .MakeFloat (_bc ));};if _gfe >=0&&_gfe < 1.0{_aa .Set ("\u0043\u0041",_cdf .MakeFloat (_gfe ));
};_dde :=_cee ._gaa .AddExtGState (_cdf .PdfObjectName (_fde ),_aa );if _dde !=nil {return "",_dde ;};return _fde ,nil ;};

// SetText sets the text content of the Paragraph.
func (_eaeb *Paragraph )SetText (text string ){_eaeb ._egda =text };

// Color returns the color of the line.
func (_acbd *Line )Color ()Color {return _acbd ._bgec };

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_cbge *Ellipse )FillOpacity ()float64 {return _cbge ._aadae };

// SetStructPageNumber sets the page object where the structure element for this drawable is located.
func (_bebg *taggedDrawable )SetStructPageNumber (pageNumber *int64 ){if _bebg ._aefb ==nil {_bebg ._aefb =_cd .NewStructureTagInfo ();_bebg ._aefb .StructureType =_bebg ._efgb ;};_bebg ._aefb .StructPageNumber =pageNumber ;};

// SetAngle sets Image rotation angle in degrees.
func (_bfaab *Image )SetAngle (angle float64 ){_bfaab ._bgbef =angle };func (_fafc *Table )getLastCellFromCol (_aaecec int )(int ,*TableCell ){for _defd :=len (_fafc ._dfcec )-1;_defd >=0;_defd --{if _fafc ._dfcec [_defd ]._ebgdb <=_aaecec &&_aaecec <=_fafc ._dfcec [_defd ]._ebgdb +_fafc ._dfcec [_defd ]._gfeff {return _defd ,_fafc ._dfcec [_defd ];
};};return 0,nil ;};

// NewRow makes a new row and inserts it into the table at the current position.
func (_dcdce *Grid )NewRow ()*GridRow {_cfae :=&GridRow {_dada :_dcdce ._ffgb ,_bfeeg :len (_dcdce ._gafbe ),_cbgd :_dcdce };_dcdce ._gafbe =append (_dcdce ._gafbe ,_cfae );return _cfae ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_agcd *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adcgd :=ctx ;_afcga ,ctx ,_edbeg :=_agcd ._gbbaf .GeneratePageBlocks (ctx );if _edbeg !=nil {return _afcga ,ctx ,_edbeg ;};if _agcd ._dfgbe .IsRelative (){ctx .X =_adcgd .X ;
};if _agcd ._dfgbe .IsAbsolute (){return _afcga ,_adcgd ,nil ;};return _afcga ,ctx ,nil ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{taggedDrawable ;_cgbfg *_ggb .CurvePolygon ;_ddca float64 ;_add float64 ;_aed Color ;};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gdgd *Rectangle )SetFitMode (fitMode FitMode ){_gdgd ._cdgbe =fitMode };func (_acfab *templateProcessor )parseListItem (_dfbcg *templateNode )(interface{},error ){if _dfbcg ._fbddd ==nil {_acfab .nodeLogError (_dfbcg ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_egfg ;};_dcdfg ,_dfab :=_dfbcg ._fbddd ._bcacc .(*List );if !_dfab {_acfab .nodeLogError (_dfbcg ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_egfg ;};_gcac :=_cccd ();_gcac ._ceaga =_dcdfg ._fccc ;return _gcac ,nil ;};func (_baabg *templateProcessor )nodeLogDebug (_bcdgf *templateNode ,_cggb string ,_gecgfa ...interface{}){_fge .Log .Debug (_baabg .getNodeErrorLocation (_bcdgf ,_cggb ,_gecgfa ...));
};func _abcaa (_ebfa _ga .Image )(*Image ,error ){_bcgcf ,_acfa :=_cd .ImageHandling .NewImageFromGoImage (_ebfa );if _acfa !=nil {return nil ,_acfa ;};return _bgfa (_bcgcf );};

// This method is not supported by Block component and exists solely to satisfy the Drawable interface.
func (_fgce *Block )GenerateKDict ()(*_cd .KDict ,error ){return nil ,nil };

// CurRow returns the currently active cell's row number.
func (_dfgba *Table )CurRow ()int {_afecd :=(_dfgba ._gecgc -1)/_dfgba ._ccabb +1;return _afecd };

// Positioning returns the type of positioning the line is set to use.
func (_ecbfg *Line )Positioning ()Positioning {return _ecbfg ._gdef };type listItem struct{_gdcgce VectorDrawable ;_ceaga TextChunk ;};func (_defb *Invoice )generateNoteBlocks (_caddf DrawContext )([]*Block ,DrawContext ,error ){_ebcee :=_ecg ();_dgbdg :=append ([][2]string {_defb ._eeadg ,_defb ._bcggc },_defb ._begf ...);
for _ ,_eeca :=range _dgbdg {if _eeca [1]!=""{_eadec :=_defb .drawSection (_eeca [0],_eeca [1]);for _ ,_cbdg :=range _eadec {_ebcee .Add (_cbdg );};_eccgb :=_dgdda (_defb ._dfeb );_eccgb .SetMargins (0,0,10,0);_ebcee .Add (_eccgb );};};return _ebcee .GeneratePageBlocks (_caddf );
};

// AddTotalLine adds a new line in the invoice totals table.
func (_cafbe *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_dfeg :=&InvoiceCell {_cafbe ._gaagg ,desc };_decd :=&InvoiceCell {_cafbe ._gaagg ,value };_cafbe ._fbece =append (_cafbe ._fbece ,[2]*InvoiceCell {_dfeg ,_decd });return _dfeg ,_decd ;
};func (_cbgadc *templateProcessor )run ()error {_dedfab :=_gd .NewDecoder (_e .NewReader (_cbgadc ._facb ));var _fefdfc *templateNode ;for {_adgdb ,_cafa :=_dedfab .Token ();if _cafa !=nil {if _cafa ==_bg .EOF {return nil ;};return _cafa ;};if _adgdb ==nil {break ;
};_gbefda ,_baaaa :=_fbaed (_dedfab );_dafb :=_dedfab .InputOffset ();switch _dbfe :=_adgdb .(type ){case _gd .StartElement :_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_dbfe .Name .Local );
_aafed ,_afbg :=_abadg [_dbfe .Name .Local ];if !_afbg {if _cbgadc ._cgcdc ==""{if _gbefda !=0{_fge .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_dbfe .Name .Local ,_gbefda ,_baaaa );
}else {_fge .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_dbfe .Name .Local ,_dafb );
};}else {if _gbefda !=0{_fge .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_dbfe .Name .Local ,_cbgadc ._cgcdc ,_gbefda ,_baaaa );
}else {_fge .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_dbfe .Name .Local ,_cbgadc ._cgcdc ,_dafb );
};};continue ;};_fefdfc =&templateNode {_bcaga :_dbfe ,_fbddd :_fefdfc ,_aggca :_gbefda ,_bbffb :_baaaa ,_fedb :_dafb };if _adegf :=_aafed ._dfag ;_adegf !=nil {_fefdfc ._bcacc ,_cafa =_adegf (_cbgadc ,_fefdfc );if _cafa !=nil {return _cafa ;};};case _gd .EndElement :_fge .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_dbfe .Name .Local );
if _fefdfc !=nil {if _fefdfc ._bcacc !=nil {if _edaaa :=_cbgadc .renderNode (_fefdfc );_edaaa !=nil {return _edaaa ;};};_fefdfc =_fefdfc ._fbddd ;};case _gd .CharData :if _fefdfc !=nil &&_fefdfc ._bcacc !=nil {if _cggc :=_cbgadc .addNodeText (_fefdfc ,string (_dbfe ));
_cggc !=nil {return _cggc ;};};case _gd .Comment :_fge .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_dbfe ));
};};return nil ;};func _bdfac (_abacbg *_cd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_abacbg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetBackgroundColor sets the cell's background color.
func (_gacea *GridCell )SetBackgroundColor (col Color ){_gacea ._adfc =col };

// SetShowLinks sets visibility of links for the TOC lines.
func (_edbdc *TOC )SetShowLinks (showLinks bool ){_edbdc ._accgc =showLinks };

// SetAnnotation sets an annotation on a TextChunk,
// this will replace any existing annotation that has been set.
// Supplying a nil value as parameter would clear all the annotations.
func (_gbgad *TextChunk )SetAnnotation (annotation *_cd .PdfAnnotation ){if annotation ==nil {_gbgad .ClearAnnotations ();}else {_gbgad ._badce =[]*_cd .PdfAnnotation {annotation };};};

// This method is not supported by Chapter component and exists solely to satisfy the Drawable interface.
func (_cca *Chapter )SetStructPageNumber (pageNumber *int64 ){};func _fdade (_ccbae string )([]string ,error ){if !_g .ValidString (_ccbae ){return []string {_ccbae },_fab .New ("\u0069n\u0070\u0075\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020v\u0061\u006c\u0069\u0064\u0020\u0055\u0054\u0046\u002d\u0038");
};var (_afeff []string ;_aabfd []rune ;);for _ ,_feaae :=range _ccbae {if _feaae =='\u000A'{if len (_aabfd )> 0{_afeff =append (_afeff ,string (_aabfd ));};_afeff =append (_afeff ,string (_feaae ));_aabfd =nil ;continue ;};_aabfd =append (_aabfd ,_feaae );
};if len (_aabfd )> 0{_afeff =append (_afeff ,string (_aabfd ));};var _eaaba []string ;for _ ,_gafaf :=range _afeff {_acdbf :=[]rune (_gafaf );_cdde :=_ed .NewScanner (_acdbf );var _eaedg []rune ;for _eddgdd :=0;_eddgdd < len (_acdbf );_eddgdd ++{_ ,_agdbf ,_becac :=_cdde .Next ();
if _becac !=nil {return nil ,_becac ;};if _agdbf ==_ed .BreakProhibited ||_gaf .IsSpace (_acdbf [_eddgdd ]){_eaedg =append (_eaedg ,_acdbf [_eddgdd ]);if _gaf .IsSpace (_acdbf [_eddgdd ]){_eaaba =append (_eaaba ,string (_eaedg ));_eaedg =[]rune {};};continue ;
}else {if len (_eaedg )> 0{_eaaba =append (_eaaba ,string (_eaedg ));};_eaedg =[]rune {_acdbf [_eddgdd ]};};};if len (_eaedg )> 0{_eaaba =append (_eaaba ,string (_eaedg ));};};return _eaaba ,nil ;};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;func (_fbce *Command )compare (_cfadb *Command )bool {if _fbce .Symbol !=_cfadb .Symbol {return false ;};for _cfff ,_cggff :=range _fbce .Params {if _cggff !=_cfadb .Params [_cfff ]{return false ;};};return true ;};

// SkipOver skips over a specified number of rows and cols.
func (_adccf *Table )SkipOver (rows ,cols int ){_afag :=rows *_adccf ._ccabb +cols -1;if _afag < 0{_fge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _gcfe :=0;_gcfe < _afag ;_gcfe ++{_adccf .NewCell ();};};

// ParseFromSVGString creates a GraphicSVG instance from string SVG.
func ParseFromSVGString (svgStr string )(*GraphicSVGElement ,error ){return ParseFromSVGStream (_gg .NewReader (svgStr ));};

// BorderWidth returns the border width of the rectangle.
func (_afcdg *Rectangle )BorderWidth ()float64 {return _afcdg ._effb };

// SetOpacity sets the cell's opacity in the range 0-1.
func (_ddgb *GridCell )SetOpacity (opacity float64 ){_ddgb ._gfafe =opacity };const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func (_gadf *GraphicSVGElement )getGradientAngle ()float64 {_gbce ,_deee :=_gadf .Attributes ["\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0054\u0072\u0061\u006es\u0066\u006f\u0072\u006d"];
if _deee {_babab :=_gg .Fields (_gbce );for _ ,_caef :=range _babab {_cdec :=_gg .FieldsFunc (_caef ,_dffed );if len (_cdec )< 2{continue ;};if _cdec [0]=="\u0072\u006f\u0074\u0061\u0074\u0065"{_bbcg ,_eddbd :=_dede (_cdec [1]);if _eddbd !=nil {_fge .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gbce );
return 0.0;};return _bbcg ;};};};return 0.0;};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// NewCurvePolygon creates a new curve polygon.
func (_bfd *Creator )NewCurvePolygon (rings [][]_ggb .CubicBezierCurve )*CurvePolygon {return _baag (rings );};func (_bf *Block )duplicate ()*Block {_fac :=&Block {};*_fac =*_bf ;_cdg :=_fgc .ContentStreamOperations {};_cdg =append (_cdg ,*_bf ._fc ...);
_fac ._fc =&_cdg ;return _fac ;};type token struct{_dgade string ;_aeeeg bool ;};func (_fagbee *RadialShading )shadingModel ()*_cd .PdfShadingType3 {_bcade ,_bege ,_afdfb :=_fagbee ._ggbe ._dcfb .ToRGB ();var _aeaecc _ggb .Point ;switch _fagbee ._ccbcd {case AnchorBottomLeft :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Llx ,Y :_fagbee ._decgc .Lly };
case AnchorBottomRight :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Urx ,Y :_fagbee ._decgc .Ury -_fagbee ._decgc .Height ()};case AnchorTopLeft :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Llx ,Y :_fagbee ._decgc .Lly +_fagbee ._decgc .Height ()};case AnchorTopRight :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Urx ,Y :_fagbee ._decgc .Ury };
case AnchorLeft :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Llx ,Y :_fagbee ._decgc .Lly +_fagbee ._decgc .Height ()/2};case AnchorTop :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Llx +_fagbee ._decgc .Width ()/2,Y :_fagbee ._decgc .Ury };case AnchorRight :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Urx ,Y :_fagbee ._decgc .Lly +_fagbee ._decgc .Height ()/2};
case AnchorBottom :_aeaecc =_ggb .Point {X :_fagbee ._decgc .Urx +_fagbee ._decgc .Width ()/2,Y :_fagbee ._decgc .Lly };default:_aeaecc =_ggb .NewPoint (_fagbee ._decgc .Llx +_fagbee ._decgc .Width ()/2,_fagbee ._decgc .Lly +_fagbee ._decgc .Height ()/2);
};_bgdb :=_fagbee ._gaad ;_gegaa :=_fagbee ._febda ;_dfgg :=_aeaecc .X +_fagbee ._cfde ;_ffeg :=_aeaecc .Y +_fagbee ._afgb ;if _bgdb ==-1.0{_bgdb =0.0;};if _gegaa ==-1.0{var _feddd []float64 ;_gcaag :=_bd .Pow (_dfgg -_fagbee ._decgc .Llx ,2)+_bd .Pow (_ffeg -_fagbee ._decgc .Lly ,2);
_feddd =append (_feddd ,_bd .Abs (_gcaag ));_fgbb :=_bd .Pow (_dfgg -_fagbee ._decgc .Llx ,2)+_bd .Pow (_fagbee ._decgc .Lly +_fagbee ._decgc .Height ()-_ffeg ,2);_feddd =append (_feddd ,_bd .Abs (_fgbb ));_cfcb :=_bd .Pow (_fagbee ._decgc .Urx -_dfgg ,2)+_bd .Pow (_ffeg -_fagbee ._decgc .Ury -_fagbee ._decgc .Height (),2);
_feddd =append (_feddd ,_bd .Abs (_cfcb ));_cbgee :=_bd .Pow (_fagbee ._decgc .Urx -_dfgg ,2)+_bd .Pow (_fagbee ._decgc .Ury -_ffeg ,2);_feddd =append (_feddd ,_bd .Abs (_cbgee ));_fa .Slice (_feddd ,func (_feba ,_gefbd int )bool {return _feba > _gefbd });
_gegaa =_bd .Sqrt (_feddd [0]);};_eegef :=&_cd .PdfRectangle {Llx :_dfgg -_gegaa ,Lly :_ffeg -_gegaa ,Urx :_dfgg +_gegaa ,Ury :_ffeg +_gegaa };_dgbf :=_cd .NewPdfShadingType3 ();_dgbf .ShadingType =_cdf .MakeInteger (3);_dgbf .ColorSpace =_cd .NewPdfColorspaceDeviceRGB ();
_dgbf .Background =_cdf .MakeArrayFromFloats ([]float64 {_bcade ,_bege ,_afdfb });_dgbf .BBox =_eegef ;_dgbf .AntiAlias =_cdf .MakeBool (_fagbee ._ggbe ._ggfe );_dgbf .Coords =_cdf .MakeArrayFromFloats ([]float64 {_dfgg ,_ffeg ,_bgdb ,_dfgg ,_ffeg ,_gegaa });
_dgbf .Domain =_cdf .MakeArrayFromFloats ([]float64 {0.0,1.0});_dgbf .Extend =_cdf .MakeArray (_cdf .MakeBool (_fagbee ._ggbe ._fcce [0]),_cdf .MakeBool (_fagbee ._ggbe ._fcce [1]));_dgbf .Function =_fagbee ._ggbe .generatePdfFunctions ();return _dgbf ;
};func (_bfeae *templateProcessor )processGradientColorPair (_acffb []string )(_efgefd []Color ,_bgad []float64 ){for _ ,_fddgf :=range _acffb {var (_cgeda =_gg .Fields (_fddgf );_gcgfec =len (_cgeda ););if _gcgfec ==0{continue ;};_aegcc :="";if _gcgfec > 1{_aegcc =_gg .TrimSpace (_cgeda [1]);
};_faefb :=-1.0;if _gg .HasSuffix (_aegcc ,"\u0025"){_fbbcg ,_cecf :=_c .ParseFloat (_aegcc [:len (_aegcc )-1],64);if _cecf !=nil {_fge .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_cecf );
};_faefb =_fbbcg /100.0;};_dbdef :=_bfeae .parseColor (_gg .TrimSpace (_cgeda [0]));if _dbdef !=nil {_efgefd =append (_efgefd ,_dbdef );_bgad =append (_bgad ,_faefb );};};if len (_efgefd )!=len (_bgad ){_fge .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_beggc :=-1;_bdacg :=0.0;for _bebbb ,_fgfce :=range _bgad {if _fgfce ==-1.0{if _bebbb ==0{_fgfce =0.0;_bgad [_bebbb ]=0.0;continue ;};_beggc ++;if _bebbb < len (_bgad )-1{continue ;}else {_fgfce =1.0;_bgad [_bebbb ]=1.0;};};_febad :=_beggc +1;
for _eddef :=_bebbb -_beggc ;_eddef < _bebbb ;_eddef ++{_bgad [_eddef ]=_bdacg +(float64 (_eddef )*(_fgfce -_bdacg )/float64 (_febad ));};_bdacg =_fgfce ;_beggc =-1;};return _efgefd ,_bgad ;};

// SetOpacity sets the cell's opacity in the range 0-1.
func (_edbcb *TableCell )SetOpacity (opacity float64 ){_edbcb ._eecec =opacity };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aagbf *Creator )NewStyledParagraph ()*StyledParagraph {return _dgdda (_aagbf .NewTextStyle ())};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_ddbd *Invoice )SetAddressStyle (style TextStyle ){_ddbd ._fdcd =style };func _dcba (_adce string )(*Image ,error ){_dddbc ,_dffa :=_ac .Open (_adce );if _dffa !=nil {return nil ,_dffa ;};defer _dddbc .Close ();_gcae ,_dffa :=_cd .ImageHandling .Read (_dddbc );
if _dffa !=nil {_fge .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dffa );return nil ,_dffa ;};return _bgfa (_gcae );};func (_gcee *Creator )setActivePage (_edec *_cd .PdfPage ){_gcee ._feda =_edec };
func (_efde *Block )drawToPage (_gca *_cd .PdfPage )error {_fcc :=&_fgc .ContentStreamOperations {};if _gca .Resources ==nil {_gca .Resources =_cd .NewPdfPageResources ();};_aeg :=_ddd (_fcc ,_gca .Resources ,_efde ._fc ,_efde ._gaa );if _aeg !=nil {return _aeg ;
};if _aeg =_bab (_efde ._gaa ,_gca .Resources );_aeg !=nil {return _aeg ;};if _aeg =_gca .AppendContentBytes (_fcc .Bytes (),true );_aeg !=nil {return _aeg ;};for _ ,_eec :=range _efde ._ffa {_gca .AddAnnotation (_eec );};return nil ;};

// SetFillColor sets the fill color.
func (_gbgc *PolyBezierCurve )SetFillColor (color Color ){_gbgc ._bfae =color ;_gbgc ._fbac .FillColor =_acac (color );};func _dffed (_ggabd rune )bool {return _ggabd =='('||_ggabd ==','||_ggabd ==')'};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_gbbaf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_ecece float64 ;_feacc uint ;_fdgca float64 ;_dfgbe Positioning ;_fbbd float64 ;_bbefa float64 ;_abcc int64 ;};func _bacfg (_aeagg string )[]token {var (_aega []token ;_edbeee string ;);for _ ,_dfegf :=range _aeagg {_dffdg :=string (_dfegf );
switch {case _abea .isCommand (_dffdg ):_aega ,_edbeee =_gbcc (_aega ,_edbeee );_aega =append (_aega ,token {_dffdg ,true });case _dffdg =="\u002e":if _edbeee ==""{_edbeee ="\u0030";};if _gg .Contains (_edbeee ,_dffdg ){_aega =append (_aega ,token {_edbeee ,false });
_edbeee ="\u0030";};fallthrough;case _dffdg >="\u0030"&&_dffdg <="\u0039"||_dffdg =="\u0065":_edbeee +=_dffdg ;case _dffdg =="\u002d":if _gg .HasSuffix (_edbeee ,"\u0065"){_edbeee +=_dffdg ;}else {_aega ,_ =_gbcc (_aega ,_edbeee );_edbeee =_dffdg ;};default:_aega ,_edbeee =_gbcc (_aega ,_edbeee );
};};_aega ,_ =_gbcc (_aega ,_edbeee );return _aega ;};

// SetMarkedContentID sets marked content ID.
func (_ecac *taggedDrawable )SetMarkedContentID (mcid int64 ){if _ecac ._aefb ==nil {_ecac ._aefb =_cd .NewStructureTagInfo ();_ecac ._aefb .StructureType =_ecac ._efgb ;};_ecac ._aefb .Mcid =mcid ;};

// SetStyleLeft sets border style for left side.
func (_eeg *border )SetStyleLeft (style CellBorderStyle ){_eeg ._bffb =style };func (_ebbdb *TableCell )height (_gbdf float64 )float64 {var _gfbbe float64 ;switch _dbadd :=_ebbdb ._effe .(type ){case *Paragraph :if _dbadd ._fabc {_dbadd .SetWidth (_gbdf -_ebbdb ._bdgg -_dbadd ._dcfd .Left -_dbadd ._dcfd .Right );
};_gfbbe =_dbadd .Height ()+_dbadd ._dcfd .Top +_dbadd ._dcfd .Bottom ;if !_ebbdb ._acgc ._dedfd {_gfbbe +=(0.5*_dbadd ._dgdde *_dbadd ._fbdcb );};case *StyledParagraph :if _dbadd ._bccfb {_dbadd .SetWidth (_gbdf -_ebbdb ._bdgg -_dbadd ._acgdg .Left -_dbadd ._acgdg .Right );
};_gfbbe =_dbadd .Height ()+_dbadd ._acgdg .Top +_dbadd ._acgdg .Bottom ;if !_ebbdb ._acgc ._dedfd {_gfbbe +=(0.5*_dbadd .getTextHeight ());};case *Image :_dbadd .applyFitMode (_gbdf -_ebbdb ._bdgg );_gfbbe =_dbadd .Height ()+_dbadd ._begc .Top +_dbadd ._begc .Bottom ;
case *Table :_dbadd .updateRowHeights (_gbdf -_ebbdb ._bdgg -_dbadd ._ffegb .Left -_dbadd ._ffegb .Right );_gfbbe =_dbadd .Height ()+_dbadd ._ffegb .Top +_dbadd ._ffegb .Bottom ;case *List :_gfbbe =_dbadd .ctxHeight (_gbdf -_ebbdb ._bdgg )+_dbadd ._bcefc .Top +_dbadd ._bcefc .Bottom ;
case *Division :_gfbbe =_dbadd .ctxHeight (_gbdf -_ebbdb ._bdgg )+_dbadd ._gadc .Top +_dbadd ._gadc .Bottom +_dbadd ._egcf .Top +_dbadd ._egcf .Bottom ;case *Chart :_gfbbe =_dbadd .Height ()+_dbadd ._cfad .Top +_dbadd ._cfad .Bottom ;case *Rectangle :_dbadd .applyFitMode (_gbdf -_ebbdb ._bdgg );
_gfbbe =_dbadd .Height ()+_dbadd ._fcfgf .Top +_dbadd ._fcfgf .Bottom +_dbadd ._effb ;case *Ellipse :_dbadd .applyFitMode (_gbdf -_ebbdb ._bdgg );_gfbbe =_dbadd .Height ()+_dbadd ._ffdg .Top +_dbadd ._ffdg .Bottom ;case *Line :_gfbbe =_dbadd .Height ()+_dbadd ._adac .Top +_dbadd ._adac .Bottom ;
};return _gfbbe ;};func (_dceed *templateProcessor )parsePageBreak (_cgcb *templateNode )(interface{},error ){return _acga (),nil ;};func (_cfca *Invoice )drawSection (_gccd ,_cdcd string )[]*StyledParagraph {var _edgb []*StyledParagraph ;if _gccd !=""{_fbfgc :=_dgdda (_cfca ._gebdb );
_fbfgc .SetMargins (0,0,0,5);_fbfgc .Append (_gccd );_edgb =append (_edgb ,_fbfgc );};if _cdcd !=""{_cced :=_dgdda (_cfca ._acef );_cced .Append (_cdcd );_edgb =append (_edgb ,_cced );};return _edgb ;};func _bggcc (_ceabc *templateProcessor ,_cceff *templateNode )(interface{},error ){return _ceabc .parseImage (_cceff );
};

// AddLine adds a new line with the provided style to the table of contents.
func (_ddcaa *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_ddcaa ._affbb =append (_ddcaa ._affbb ,line );return line ;};func (_aedd *templateProcessor )parseColor (_edef string )Color {if _edef ==""{return nil ;};_abcad ,_afaf :=_aedd ._ccdf .ColorMap [_edef ];
if _afaf {return _abcad ;};if _edef [0]=='#'{return ColorRGBFromHex (_edef );};return nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func (_eadeea *templateProcessor )parseParagraph (_cdbcg *templateNode ,_caba *StyledParagraph )(interface{},error ){if _caba ==nil {_caba =_eadeea .creator .NewStyledParagraph ();};for _ ,_bbcde :=range _cdbcg ._bcaga .Attr {_dfebc :=_bbcde .Value ;
switch _baagf :=_bbcde .Name .Local ;_baagf {case "\u0066\u006f\u006e\u0074":_caba .SetFont (_eadeea .parseFontAttr (_baagf ,_dfebc ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_caba .SetFontSize (_eadeea .parseFloatAttr (_baagf ,_dfebc ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_caba .SetTextAlignment (_eadeea .parseTextAlignmentAttr (_baagf ,_dfebc ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_caba .SetLineHeight (_eadeea .parseFloatAttr (_baagf ,_dfebc ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_caba .SetEnableWrap (_eadeea .parseBoolAttr (_baagf ,_dfebc ));
case "\u0063\u006f\u006co\u0072":_caba .SetFontColor (_eadeea .parseColorAttr (_baagf ,_dfebc ));case "\u0078":_caba .SetPos (_eadeea .parseFloatAttr (_baagf ,_dfebc ),_caba ._decdca );case "\u0079":_caba .SetPos (_caba ._beacb ,_eadeea .parseFloatAttr (_baagf ,_dfebc ));
case "\u0061\u006e\u0067l\u0065":_caba .SetAngle (_eadeea .parseFloatAttr (_baagf ,_dfebc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_adgcb :=_eadeea .parseMarginAttr (_baagf ,_dfebc );_caba .SetMargins (_adgcb .Left ,_adgcb .Right ,_adgcb .Top ,_adgcb .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_caba .SetMaxLines (int (_eadeea .parseInt64Attr (_baagf ,_dfebc )));default:_eadeea .nodeLogDebug (_cdbcg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_baagf );
};};return _caba ,nil ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_degg *LinearShading )AddPatternResource (block *Block )(_bgddg _cdf .PdfObjectName ,_eccd error ){_afef :=1;_cgcd :=_cdf .PdfObjectName ("\u0050"+_c .Itoa (_afef ));for block ._gaa .HasPatternByName (_cgcd ){_afef ++;_cgcd =_cdf .PdfObjectName ("\u0050"+_c .Itoa (_afef ));
};if _bbee :=block ._gaa .SetPatternByName (_cgcd ,_degg .ToPdfShadingPattern ().ToPdfObject ());_bbee !=nil {return "",_bbee ;};return _cgcd ,nil ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_edba *Chapter )SetIncludeInTOC (includeInTOC bool ){_edba ._agfe =includeInTOC };

// SetMargins sets the Grid's left, right, top, bottom margins.
func (_ffge *Grid )SetMargins (left ,right ,top ,bottom float64 ){_ffge ._eacc .Left =left ;_ffge ._eacc .Right =right ;_ffge ._eacc .Top =top ;_ffge ._eacc .Bottom =bottom ;};func (_egggb pathParserError )Error ()string {return _egggb ._ccafg };

// AssociateAnnotationWithStructure associates the given annotation with the text chunk's structure element.
// This is necessary for proper tag structure when using annotations in tagged PDFs.
func (_cadea *TextChunk )AssociateAnnotationWithStructure (annotation *_cd .PdfAnnotation ){if _cadea ._aefb ==nil {_cadea ._aefb =_cd .NewStructureTagInfo ();_cadea ._aefb .StructureType =_cd .StructureTypeSpan ;};_gbbb :=annotation .GetContainingPdfObject ();
_cadea ._aefb .SetObjAttrib (_gbbb );if _bdfb ,_cebgg :=_cdf .GetDict (_gbbb );_cebgg {_bdfb .Set ("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074",_cdf .MakeInteger (_cadea ._aefb .Mcid ));};};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_ggbe *shading ;_decgc *_cd .PdfRectangle ;_ccbcd AnchorPoint ;_cfde float64 ;_afgb float64 ;_gaad float64 ;_febda float64 ;};

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_faf *border )SetStructureType (structureType _cd .StructureType ){};

// NewSubchapter creates a new child chapter with the specified title.
func (_fegdb *Chapter )NewSubchapter (title string )*Chapter {_eab :=_bdfac (_fegdb ._bebf ._bcebd [0].Style .Font );_eab .FontSize =14;_fegdb ._acd ++;_ceg :=_ageb (_fegdb ,_fegdb ._fbfg ,_fegdb ._dbb ,title ,_fegdb ._acd ,_eab );_fegdb .Add (_ceg );return _ceg ;
};func (_ccba *templateProcessor )parseFloatArray (_ggafa ,_eaegb string )[]float64 {_fge .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ggafa ,_eaegb );
_fegbbe :=_gg .Fields (_eaegb );_fbfab :=make ([]float64 ,0,len (_fegbbe ));for _ ,_afggg :=range _fegbbe {_gdbfe ,_ :=_c .ParseFloat (_afggg ,64);_fbfab =append (_fbfab ,_gdbfe );};return _fbfab ;};

// SetNumber sets the number of the invoice.
func (_cdga *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_cdga ._dcfg [1].Value =number ;return _cdga ._dcfg [0],_cdga ._dcfg [1];};func _gbcc (_edgcg []token ,_ffdee string )([]token ,string ){if _ffdee !=""{_edgcg =append (_edgcg ,token {_ffdee ,false });
_ffdee ="";};return _edgcg ,_ffdee ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_fc *_fgc .ContentStreamOperations ;_gaa *_cd .PdfPageResources ;_edf Positioning ;_fd ,_be float64 ;_ce float64 ;_ff float64 ;_gc float64 ;_ef Margins ;_ffa []*_cd .PdfAnnotation ;};

// SetAltText sets the alternative text for the text chunk.
func (_bdgba *TextChunk )SetAltText (text string ){_bdgba ._dgeff =&text };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_begde *TOCLine )SetLink (page int64 ,x ,y float64 ){_begde ._fbbd =x ;_begde ._bbefa =y ;_begde ._abcc =page ;_gdcga :=_begde ._gbbaf ._adfa .Color ;_begde .Number .Style .Color =_gdcga ;_begde .Title .Style .Color =_gdcga ;_begde .Separator .Style .Color =_gdcga ;
_begde .Page .Style .Color =_gdcga ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_daee :_bd .Min (float64 (c ),100)/100.0,_faab :_bd .Min (float64 (m ),100)/100.0,_afde :_bd .Min (float64 (y ),100)/100.0,_daeec :_bd .Min (float64 (k ),100)/100.0};};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_egdd *Image )SetFitMode (fitMode FitMode ){_egdd ._ebdf =fitMode };

// Width returns the Block's width.
func (_aag *Block )Width ()float64 {return _aag ._ce };

// SetAnchor set gradient position anchor.
// Default to center.
func (_gaebg *RadialShading )SetAnchor (anchor AnchorPoint ){_gaebg ._ccbcd =anchor };func (_dbd *Block )translate (_dgd ,_aeb float64 ){_cg :=_fgc .NewContentCreator ().Translate (_dgd ,-_aeb ).Operations ();*_dbd ._fc =append (*_cg ,*_dbd ._fc ...);_dbd ._fc .WrapIfNeeded ();
};

// GetMargins returns the left, right, top, bottom Margins.
func (_aceac *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aceac ._ffegb .Left ,_aceac ._ffegb .Right ,_aceac ._ffegb .Top ,_aceac ._ffegb .Bottom ;};func _efga (_afagd *templateProcessor ,_fbfcc *templateNode )(interface{},error ){return _afagd .parseStyledParagraph (_fbfcc );
};

// Add adds a new line with the default style to the table of contents.
func (_dgdce *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_ebafcg :=_dgdce .AddLine (_gabfd (TextChunk {Text :number ,Style :_dgdce ._cbgg },TextChunk {Text :title ,Style :_dgdce ._ecacc },TextChunk {Text :page ,Style :_dgdce ._accg },level ,_dgdce ._cagc ));
if _ebafcg ==nil {return nil ;};_bcccg :=&_dgdce ._fabff ;_ebafcg .SetMargins (_bcccg .Left ,_bcccg .Right ,_bcccg .Top ,_bcccg .Bottom );_ebafcg .SetLevelOffset (_dgdce ._fbaf );_ebafcg .Separator .Text =_dgdce ._cgaeg ;_ebafcg .Separator .Style =_dgdce ._acbdd ;
return _ebafcg ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_caeac *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_caeac ._eccfd =textOverflow ;};func (_cefag *Image )makeXObject ()error {_dacbc ,_fafa :=_cd .NewXObjectImageFromImageLazy (_cefag ._dbfc ,nil ,_cefag ._gdcgc ,_cefag ._dbgf );
if _fafa !=nil {_fge .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fafa );return _fafa ;};_cefag ._ecggf =_dacbc ;
return nil ;};func (_dbfed *templateProcessor )parseTextRenderingModeAttr (_cadec ,_ebage string )TextRenderingMode {_fge .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cadec ,_ebage );
_abgdd :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_ebage ];
return _abgdd ;};func (_efcda *Table )moveToNextAvailableCell ()int {_cfcbd :=(_efcda ._gecgc -1)%(_efcda ._ccabb )+1;for {if _cfcbd -1>=len (_efcda ._fgff ){if _efcda ._fgff [0]==0{return _cfcbd ;};_cfcbd =1;}else if _efcda ._fgff [_cfcbd -1]==0{return _cfcbd ;
};_efcda ._gecgc ++;_efcda ._fgff [_cfcbd -1]--;_cfcbd ++;};};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_fgbge *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_fgbge ._bcag =valign };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_adee *StyledParagraph )Insert (index uint ,text string )*TextChunk {_adadc :=uint (len (_adee ._bcebd ));if index > _adadc {index =_adadc ;};_ebcf :=NewTextChunk (text ,_adee ._eeac );_adee ._bcebd =append (_adee ._bcebd [:index ],append ([]*TextChunk {_ebcf },_adee ._bcebd [index :]...)...);
_adee .wrapText ();return _ebcf ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_aeffgf *TOC )SetLineTitleStyle (style TextStyle ){_aeffgf ._ecacc =style };

// SetStructureType sets the structure type for the table.
func (_dadf *Table )SetStructureType (structureType _cd .StructureType ){if _dadf ._aefb ==nil {_dadf ._aefb =_cd .NewStructureTagInfo ();};_dadf ._aefb .StructureType =structureType ;if _dadf ._aefb .ComponentKObj !=nil {if _dadf ._aefb .ParentKObj !=nil {_dadf ._aefb .ParentKObj .RemoveKChild (_dadf ._aefb .ComponentKObj );
};_dadf ._aefb .ComponentKObj =_cd .NewKDictionary ();_dadf ._aefb .ComponentKObj .S =_cdf .MakeName (string (structureType ));_dadf ._aefb .ParentKObj .AddKChild (_dadf ._aefb .ComponentKObj );};};

// Height returns the current page height.
func (_fafd *Creator )Height ()float64 {return _fafd ._bda };

// NewPolygon creates a new polygon.
func (_eada *Creator )NewPolygon (points [][]_ggb .Point )*Polygon {return _cdbe (points )};func (_edfdd *templateProcessor )parseList (_cacca *templateNode )(interface{},error ){_beedb :=_edfdd .creator .NewList ();for _ ,_dgcfb :=range _cacca ._bcaga .Attr {_agae :=_dgcfb .Value ;
switch _agbdaf :=_dgcfb .Name .Local ;_agbdaf {case "\u0069\u006e\u0064\u0065\u006e\u0074":_beedb .SetIndent (_edfdd .parseFloatAttr (_agbdaf ,_agae ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_abge :=_edfdd .parseMarginAttr (_agbdaf ,_agae );_beedb .SetMargins (_abge .Left ,_abge .Right ,_abge .Top ,_abge .Bottom );
default:_edfdd .nodeLogDebug (_cacca ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_agbdaf );
};};return _beedb ,nil ;};func (_eecg *pageTransformations )transformPage (_feff *_cd .PdfPage )error {if _faba :=_eecg .applyFlip (_feff );_faba !=nil {return _faba ;};return nil ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_gbge *Division )Height ()float64 {var _edde float64 ;for _ ,_cgeg :=range _gbge ._decb {switch _bbcd :=_cgeg .(type ){case marginDrawable :_ ,_ ,_dbad ,_gee :=_bbcd .GetMargins ();_edde +=_bbcd .Height ()+_dbad +_gee ;default:_edde +=_bbcd .Height ();
};};return _edde ;};func _cdee (_adgb map[string ]string ,_cfgef float64 )(*GraphicSVGStyle ,error ){_egdcb :=_cgfa ();_gdeff ,_deafg :=_adgb ["\u0066\u0069\u006c\u006c"];if _deafg {_egdcb .FillColor =_gdeff ;if _gdeff =="\u006e\u006f\u006e\u0065"{_egdcb .FillColor ="";
};};_gefg ,_dggdc :=_adgb ["\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079"];if _dggdc {_gdfgba ,_ggdge :=_fgdd (_gefg );if _ggdge !=nil {return nil ,_ggdge ;};_egdcb .FillOpacity =_gdfgba ;};_cfdf ,_eceb :=_adgb ["\u0073\u0074\u0072\u006f\u006b\u0065"];
if _eceb {_egdcb .StrokeColor =_cfdf ;if _cfdf =="\u006e\u006f\u006e\u0065"{_egdcb .StrokeColor ="";};};_dcdd ,_badf :=_adgb ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];if _badf {_eageg ,_baabe :=_gfgbeb (_dcdd ,64);if _baabe !=nil {return nil ,_baabe ;
};_egdcb .StrokeWidth =_eageg *_cfgef ;};return _egdcb ,nil ;};

// AddInternalLinkWithTag adds a new internal link to the paragraph with proper tagging for accessibility.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y coordinates.
// Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom parameter (0 keeps current zoom).
// The options parameter contains accessibility properties like tooltip, altText, and mcid.
func (_dffae *StyledParagraph )AddInternalLinkWithTag (text string ,page int64 ,x ,y ,zoom float64 ,options LinkTagOptions )(*TextChunk ,*_cd .KDict ){_aaffb :=_aegef (page -1,x ,y ,zoom ,options .Tooltip );_cbac ,_gedg ,_dcdf :=_dffae .createAccessibleLinkChunk (text ,_aaffb ,options );
if _dcdf !=nil {_fge .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0069\u006e\u0074\u0065\u0072n\u0061\u006c\u0020\u006c\u0069\u006e\u006b\u0020\u0077\u0069th\u0020\u0074\u0061g\u003a \u0025\u0076",_dcdf );
return nil ,nil ;};return _cbac ,_gedg ;};type Grid struct{taggedDrawable ;_abgd int ;_gded []float64 ;_ffgb float64 ;_dgda Positioning ;_cfade ,_bdef float64 ;_eacc Margins ;_gafbe []*GridRow ;};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_bace *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _fddb (x ,y ,width ,height );};

// SetIndent sets the cell's left indent.
func (_dddb *GridCell )SetIndent (indent float64 ){_dddb ._dedf =indent };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_ceede *Table )Width ()float64 {return 0};

// SetInline sets the inline mode of the division.
func (_gfc *Division )SetInline (inline bool ){_gfc ._abdc =inline };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_bbadb *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aadb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fedcg ,_gedbf :=_aadb .setOpacity (_bbadb ._cfab ,_bbadb ._fdbe );if _gedbf !=nil {return nil ,ctx ,_gedbf ;
};_geccf :=_bbadb ._agaga ;_geccf .FillEnabled =_geccf .FillColor !=nil ;_geccf .BorderEnabled =_geccf .BorderColor !=nil &&_geccf .BorderWidth > 0;_dadbd :=_geccf .Points ;_ffgag :=_cd .PdfRectangle {};_beac :=false ;for _ddgad :=range _dadbd {for _cbaf :=range _dadbd [_ddgad ]{_bgead :=&_dadbd [_ddgad ][_cbaf ];
_bgead .Y =ctx .PageHeight -_bgead .Y ;if !_beac {_ffgag .Llx =_bgead .X ;_ffgag .Lly =_bgead .Y ;_ffgag .Urx =_bgead .X ;_ffgag .Ury =_bgead .Y ;_beac =true ;}else {_ffgag .Llx =_bd .Min (_ffgag .Llx ,_bgead .X );_ffgag .Lly =_bd .Min (_ffgag .Lly ,_bgead .Y );
_ffgag .Urx =_bd .Max (_ffgag .Urx ,_bgead .X );_ffgag .Ury =_bd .Max (_ffgag .Ury ,_bgead .Y );};};};if _geccf .FillEnabled {_abdf :=_dbdga (_aadb ,_bbadb ._agaga .FillColor ,_bbadb ._fcfd ,func ()Rectangle {return Rectangle {_bdcc :_ffgag .Llx ,_dbgd :_ffgag .Lly ,_bfed :_ffgag .Width (),_abdcf :_ffgag .Height ()};
});if _abdf !=nil {return nil ,ctx ,_abdf ;};};_edcfe ,_ ,_gedbf :=_geccf .MarkedDraw (_fedcg ,_bbadb ._aefb );if _gedbf !=nil {return nil ,ctx ,_gedbf ;};if _gedbf =_aadb .addContentsByString (string (_edcfe ));_gedbf !=nil {return nil ,ctx ,_gedbf ;};
return []*Block {_aadb },ctx ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fdbda *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fdbda ._acgdg .Left ,_fdbda ._acgdg .Right ,_fdbda ._acgdg .Top ,_fdbda ._acgdg .Bottom ;};

// This method is not supported by Border component and exists solely to satisfy the Drawable interface.
func (_bcc *border )GenerateKDict ()(*_cd .KDict ,error ){return nil ,nil };func (_eafec *GraphicSVGElement )drawEllipse (_dbcdd *_fgc .ContentCreator ,_egbcg *_cd .PdfPageResources ){_dbcdd .Add_q ();_eafec .Style .toContentStream (_dbcdd ,_egbcg ,_eafec );
_befbc ,_acafe :=_gfgbeb (_eafec .Attributes ["\u0063\u0078"],64);if _acafe !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_acafe .Error ());
};_eafba ,_acafe :=_gfgbeb (_eafec .Attributes ["\u0063\u0079"],64);if _acafe !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_acafe .Error ());
};_agea ,_acafe :=_gfgbeb (_eafec .Attributes ["\u0072\u0078"],64);if _acafe !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_acafe .Error ());
};_gggc ,_acafe :=_gfgbeb (_eafec .Attributes ["\u0072\u0079"],64);if _acafe !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_acafe .Error ());
};_fbadd :=_agea *_eafec ._fgdg ;_aaafa :=_gggc *_eafec ._fgdg ;_cdfc :=_befbc *_eafec ._fgdg ;_fcfee :=_eafba *_eafec ._fgdg ;_cdgad :=_fbadd *_dddf ;_ecfgd :=_aaafa *_dddf ;_fecfa :=_ggb .NewCubicBezierPath ();_fecfa =_fecfa .AppendCurve (_ggb .NewCubicBezierCurve (-_fbadd ,0,-_fbadd ,_ecfgd ,-_cdgad ,_aaafa ,0,_aaafa ));
_fecfa =_fecfa .AppendCurve (_ggb .NewCubicBezierCurve (0,_aaafa ,_cdgad ,_aaafa ,_fbadd ,_ecfgd ,_fbadd ,0));_fecfa =_fecfa .AppendCurve (_ggb .NewCubicBezierCurve (_fbadd ,0,_fbadd ,-_ecfgd ,_cdgad ,-_aaafa ,0,-_aaafa ));_fecfa =_fecfa .AppendCurve (_ggb .NewCubicBezierCurve (0,-_aaafa ,-_cdgad ,-_aaafa ,-_fbadd ,-_ecfgd ,-_fbadd ,0));
_fecfa =_fecfa .Offset (_cdfc ,_fcfee );if _eafec .Style .StrokeWidth > 0{_fecfa =_fecfa .Offset (_eafec .Style .StrokeWidth /2,_eafec .Style .StrokeWidth /2);};_ggb .DrawBezierPathWithCreator (_fecfa ,_dbcdd );_eafec .Style .fillStroke (_dbcdd );_dbcdd .Add_h ();
_dbcdd .Add_Q ();};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_dff *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dc :=_cf .IdentityMatrix ();_efb ,_ebe :=_dff .Width (),_dff .Height ();if _dff ._edf .IsRelative (){_dc =_dc .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_ebe );}else {_dc =_dc .Translate (_dff ._fd ,ctx .PageHeight -_dff ._be -_ebe );
};_edd :=_ebe ;if _dff ._gc !=0{_dc =_dc .Translate (_efb /2,_ebe /2).Rotate (_dff ._gc *_bd .Pi /180.0).Translate (-_efb /2,-_ebe /2);_ ,_edd =_dff .RotatedSize ();};if _dff ._edf .IsRelative (){ctx .Y +=_edd ;};_bce :=_fgc .NewContentCreator ();_bce .Add_cm (_dc [0],_dc [1],_dc [3],_dc [4],_dc [6],_dc [7]);
_aae :=_dff .duplicate ();_cfe :=append (*_bce .Operations (),*_aae ._fc ...);_cfe .WrapIfNeeded ();_aae ._fc =&_cfe ;for _ ,_dca :=range _dff ._ffa {_fbg ,_cea :=_cdf .GetArray (_dca .Rect );if !_cea ||_fbg .Len ()!=4{_fge .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_dca .Rect );
continue ;};_cda ,_dgef :=_cd .NewPdfRectangle (*_fbg );if _dgef !=nil {_fge .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_dgef );
continue ;};_cda .Transform (_dc );_dca .Rect =_cda .ToPdfObject ();};return []*Block {_aae },ctx ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_ced *Block )AddAnnotation (annotation *_cd .PdfAnnotation ){for _ ,_ffb :=range _ced ._ffa {if _ffb ==annotation {return ;};};_ced ._ffa =append (_ced ._ffa ,annotation );};

// AddExternalLinkWithTag adds a new external link to the paragraph with proper tagging for accessibility.
// The text parameter represents the text that is displayed and the url parameter sets the destination.
// The options parameter contains accessibility properties like tooltip, altText, and mcid.
func (_ecbbf *StyledParagraph )AddExternalLinkWithTag (text ,url string ,options LinkTagOptions )(*TextChunk ,*_cd .KDict ){_deffb :=_egce (url ,options .Tooltip );_dfdfa ,_edgc ,_aeag :=_ecbbf .createAccessibleLinkChunk (text ,_deffb ,options );if _aeag !=nil {_fge .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0065\u0078\u0074\u0065\u0072n\u0061\u006c\u0020\u006c\u0069\u006e\u006b\u0020\u0077\u0069th\u0020\u0074\u0061g\u003a \u0025\u0076",_aeag );
return nil ,nil ;};return _dfdfa ,_edgc ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{taggedDrawable ;_ggab _ea .ChartRenderable ;_cgde Positioning ;_cceb float64 ;_cfa float64 ;_cfad Margins ;};func _cgega (_bbfd []*ColorPoint )*LinearShading {return &LinearShading {_bedba :&shading {_dcfb :ColorWhite ,_ggfe :false ,_fcce :[]bool {false ,false },_ecgf :_bbfd },_gbgeb :&_cd .PdfRectangle {}};
};

// SetLineColor sets the line color.
func (_gdada *Polyline )SetLineColor (color Color ){_gdada ._gbgg .LineColor =_acac (color )};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_cdfd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_cdfd ._gege =toc ;};

// GetCoords returns coordinates of border.
func (_eed *border )GetCoords ()(float64 ,float64 ){return _eed ._gae ,_eed ._acc };var PPMM =float64 (72*1.0/25.4);

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_adgf *Creator )SetForms (form *_cd .PdfAcroForm )error {_adgf ._aegc =form ;return nil };

// IsRelative checks if the positioning is relative.
func (_dbe Positioning )IsRelative ()bool {return _dbe ==PositionRelative };type cmykColor struct{_daee ,_faab ,_afde ,_daeec float64 };

// SetFillColor sets the fill color of the rectangle.
func (_cgabd *Rectangle )SetFillColor (col Color ){_cgabd ._bfcd =col };

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_acff *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_acff ._eeea =halign };

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_bdaaa *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_bdaaa ._fcfgf .Left =left ;_bdaaa ._fcfgf .Right =right ;_bdaaa ._fcfgf .Top =top ;_bdaaa ._fcfgf .Bottom =bottom ;};

// EnableWordWrap sets the paragraph word wrap flag.
func (_ggfcb *StyledParagraph )EnableWordWrap (val bool ){_ggfcb ._bgeb =val };

// NewPageBreak create a new page break.
func (_gbfb *Creator )NewPageBreak ()*PageBreak {return _acga ()};

// NewList creates a new list.
func (_bcaa *Creator )NewList ()*List {return _abfg (_bcaa .NewTextStyle ())};func (_cgf *Chapter )headingText ()string {_aada :=_cgf ._dfd ;if _cbd :=_cgf .headingNumber ();_cbd !=""{_aada =_a .Sprintf ("\u0025\u0073\u0020%\u0073",_cbd ,_aada );};return _aada ;
};func (_bcfc *templateProcessor )parseRadialGradientAttr (creator *Creator ,_ggbag string )Color {_aeefd :=ColorBlack ;if _ggbag ==""{return _aeefd ;};var (_cefb error ;_eaddc =0.0;_babfb =0.0;_adfg =-1.0;_bcbg =_gg .Split (_ggbag [16:len (_ggbag )-1],"\u002c");
);_ddgadg :=_gg .Fields (_bcbg [0]);if len (_ddgadg )==2&&_gg .TrimSpace (_ddgadg [0])[0]!='#'{_eaddc ,_cefb =_c .ParseFloat (_ddgadg [0],64);if _cefb !=nil {_fge .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_cefb );
};_babfb ,_cefb =_c .ParseFloat (_ddgadg [1],64);if _cefb !=nil {_fge .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_cefb );
};_bcbg =_bcbg [1:];};_facfa :=_gg .TrimSpace (_bcbg [0]);if _facfa [0]!='#'{_adfg ,_cefb =_c .ParseFloat (_facfa ,64);if _cefb !=nil {_fge .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_cefb );
};_bcbg =_bcbg [1:];};_cgee ,_bfga :=_bcfc .processGradientColorPair (_bcbg );if _cgee ==nil ||_bfga ==nil {return _aeefd ;};_aaed :=creator .NewRadialGradientColor (_eaddc ,_babfb ,0,_adfg ,[]*ColorPoint {});for _gacg :=0;_gacg < len (_cgee );_gacg ++{_aaed .AddColorStop (_cgee [_gacg ],_bfga [_gacg ]);
};return _aaed ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_aede *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_gfac :=range subtable ._dfcec {_bgcf :=&TableCell {};*_bgcf =*_gfac ;_bgcf ._acgc =_aede ;_bgcf ._ebgdb +=col -1;if _ffged :=_aede ._ccabb -(_bgcf ._ebgdb -1);_ffged < _bgcf ._gfeff {_aede ._ccabb +=_bgcf ._gfeff -_ffged ;
_aede .resetColumnWidths ();_fge .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_aede ._ccabb );
};_bgcf ._cfdga +=row -1;_gdgca :=subtable ._fgege [_gfac ._cfdga -1];if _bgcf ._cfdga > _aede ._ecga {for _bgcf ._cfdga > _aede ._ecga {_aede ._ecga ++;_aede ._fgege =append (_aede ._fgege ,_aede ._eecff );};_aede ._fgege [_bgcf ._cfdga -1]=_gdgca ;}else {_aede ._fgege [_bgcf ._cfdga -1]=_bd .Max (_aede ._fgege [_bgcf ._cfdga -1],_gdgca );
};_aede ._dfcec =append (_aede ._dfcec ,_bgcf );};_aede .sortCells ();};

// SetPos sets absolute positioning with specified coordinates.
func (_dgag *Paragraph )SetPos (x ,y float64 ){_dgag ._bgcg =PositionAbsolute ;_dgag ._dbed =x ;_dgag ._bdgeg =y ;};

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_facc *StyledParagraph )SetLanguageIdentifier (id string ){if _facc ._aefb ==nil {_facc ._aefb =_cd .NewStructureTagInfo ();_facc ._aefb .StructureType =_cd .StructureTypeParagraph ;};_facc ._cdeb =id ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_eege *Creator )NewTextStyle ()TextStyle {return _bdfac (_eege ._ccbd )};

// WriteToFile writes the Creator output to file specified by path.
func (_gged *Creator )WriteToFile (outputPath string )error {_ageff ,_ebaba :=_ac .Create (outputPath );if _ebaba !=nil {return _ebaba ;};defer _ageff .Close ();return _gged .Write (_ageff );};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{taggedDrawable ;_bdcc float64 ;_dbgd float64 ;_bfed float64 ;_abdcf float64 ;_afbe Positioning ;_bfcd Color ;_abbd float64 ;_feedc Color ;_effb float64 ;_cbfae float64 ;_cedf float64 ;_ebaa float64 ;_bdgee float64 ;_geeg float64 ;
_fcfgf Margins ;_cdgbe FitMode ;};

// Cols returns the total number of columns the table has.
func (_fgdae *Table )Cols ()int {return _fgdae ._ccabb };

// SetOpacity sets opacity for border in range 0-1.
func (_bad *border )SetOpacity (opacity float64 ){_bad ._fccfa =opacity };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{taggedDrawable ;_bacec float64 ;_cbcf float64 ;_bfdg float64 ;_ebgdf float64 ;_bgec Color ;_fdcg _ggb .LineStyle ;_accf float64 ;_egaeg []int64 ;_cbce int64 ;_ebee float64 ;_gdef Positioning ;_bded FitMode ;_adac Margins ;};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_ebde *Rectangle )Height ()float64 {return _ebde ._abdcf };

// SetBackground sets the background properties of the component.
func (_abed *Division )SetBackground (background *Background ){_abed ._aebdf =background };

// NewMultiCell makes a new cell with given colspan and rowspan and inserts it into the row at the current position.
func (_acab *GridRow )NewMultiCell (colspan ,rowspan int )(*GridCell ,error ){_acdb :=&GridCell {_gebd :len (_acab ._adgg ),_affb :_acab ._bfeeg ,_cdfdb :colspan ,_fdca :rowspan };_acdb ._affb =_acab ._bfeeg ;_acdb ._gebd =0;for _ ,_gffeb :=range _acab ._adgg {_acdb ._gebd +=_gffeb ._cdfdb ;
};for _bddf ,_bdcae :=range _acab ._cbgd ._gafbe {if _bddf ==_acab ._bfeeg +1{break ;};for _ ,_beec :=range _bdcae ._adgg {if _beec ._affb +_beec ._fdca > _acdb ._affb {if _beec ._gebd +_beec ._cdfdb > _acdb ._gebd {_acdb ._gebd =_beec ._gebd +_beec ._cdfdb ;
};};};};if _acdb ._gebd >=_acab ._cbgd ._abgd {return nil ,_fab .New ("\u0063\u0061n'\u0074\u0020\u0061d\u0064\u0020\u0061\u006ey m\u006fre\u0020\u0063\u0065\u006c\u006c\u0073\u0020to\u0020\u0074\u0068\u0069\u0073\u0020\u0072o\u0077");};_acdb ._dedf =5;
_acdb ._bbbb =CellBorderStyleNone ;_acdb ._adfcb =_ggb .LineStyleSolid ;_acdb ._bbga =CellHorizontalAlignmentLeft ;_acdb ._efdb =CellVerticalAlignmentTop ;_acdb ._bfaa =0;_acdb ._efbfef =0;_acdb ._edadde =0;_acdb ._bbdaf =0;_ebff :=ColorBlack ;_acdb ._bbcda =_ebff ;
_acdb ._feaeg =_ebff ;_acdb ._cfbg =_ebff ;_acdb ._eeada =_ebff ;_acdb ._gfafe =1.0;_acab ._adgg =append (_acab ._adgg ,_acdb );_acdb ._efgb =_cd .StructureTypeTableData ;return _acdb ,nil ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bgde *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _bgde ._fdfe [0],_bgde ._fdfe [1]};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_gbbf *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_gbbf ._ffdg .Left =left ;_gbbf ._ffdg .Right =right ;_gbbf ._ffdg .Top =top ;_gbbf ._ffdg .Bottom =bottom ;};

// SetColorRight sets border color for right.
func (_fgd *border )SetColorRight (col Color ){_fgd ._gfef =col };func _fdccb (_gecag *_cd .PdfAnnotation )*_cd .PdfAnnotation {if _gecag ==nil {return nil ;};var _gbac *_cd .PdfAnnotation ;switch _bdaga :=_gecag .GetContext ().(type ){case *_cd .PdfAnnotationLink :if _faefc :=_cafdb (_bdaga );
_faefc !=nil {_gbac =_faefc .PdfAnnotation ;};case *_cd .PdfAnnotationHighlight :if _ccdfb :=_effba (_bdaga );_ccdfb !=nil {_gbac =_ccdfb .PdfAnnotation ;};};return _gbac ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fedcf *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_edge :=_dgdda (_fedcf ._cedde );_edge .Append (text );_bbfeg ,_gaeb :=_fedcf .Add (_edge );return _edge ,_bbfeg ,_gaeb ;};

// AddTag adds the table tag for Grid to the root K object.
func (_gdfd *Grid )AddTag (rootKObj *_cd .KDict ){if rootKObj ==nil {_fge .Log .Debug ("\u0054\u0061\u0062\u006ce\u003a\u0020\u0041\u0064\u0064\u0054\u0061\u0067\u0020c\u0061\u006c\u006c\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u0069\u006c\u0020\u0072\u006f\u006ft\u004b\u004f\u0062\u006a\u002c \u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0074\u0061\u0067\u0067\u0069\u006e\u0067\u002e");
return ;};if _gdfd ._aefb ==nil {_gdfd ._aefb =_cd .NewStructureTagInfo ();_gdfd ._aefb .StructureType =_cd .StructureTypeTable ;};_gdfd ._aefb .ApplyTag =true ;_gdfd ._aefb .ParentKObj =rootKObj ;_gdfd ._aefb .ComponentKObj =_cd .NewKDictionary ();_gdfd ._aefb .ComponentKObj .S =_cdf .MakeName (string (_gdfd ._aefb .StructureType ));
_gdfd ._aefb .ParentKObj .AddKChild (_gdfd ._aefb .ComponentKObj );};

// SetFontSize sets the font size for the paragraph.
func (_aacb *StyledParagraph )SetFontSize (fontSize float64 ){_aacb ._eeac .FontSize =fontSize ;for _ ,_bfgef :=range _aacb ._bcebd {_bfgef .Style .FontSize =fontSize ;};};

// NewPolyline creates a new polyline.
func (_babd *Creator )NewPolyline (points []_ggb .Point )*Polyline {return _fbcb (points )};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_gfba *GridCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_gfba ._bbga =halign };func (_ebcb *StyledParagraph )getTextLineWidth (_dbag []*TextChunk )float64 {var _ggge float64 ;_cbda :=len (_dbag );for _fgcc ,_adbag :=range _dbag {_cdeada :=&_adbag .Style ;
_bedg :=len (_adbag .Text );for _ecfed ,_daaca :=range _adbag .Text {if _daaca =='\u000A'{continue ;};_dgfdb ,_egbcf :=_cdeada .Font .GetRuneMetrics (_daaca );if !_egbcf {_fge .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_daaca );
return -1;};_ggge +=_cdeada .FontSize *_dgfdb .Wx *_cdeada .horizontalScale ();if _daaca !=' '&&(_fgcc !=_cbda -1||_ecfed !=_bedg -1){_ggge +=_cdeada .CharSpacing *1000.0;};};};return _ggge ;};

// Horizontal returns total horizontal (left + right) margin.
func (_cdcf *Margins )Horizontal ()float64 {return _cdcf .Left +_cdcf .Right };

// Columns returns all the columns in the invoice line items table.
func (_gdfa *Invoice )Columns ()[]*InvoiceCell {return _gdfa ._bdfec };func (_cgade *TemplateOptions )init (){if _cgade .SubtemplateMap ==nil {_cgade .SubtemplateMap =map[string ]_bg .Reader {};};if _cgade .FontMap ==nil {_cgade .FontMap =map[string ]*_cd .PdfFont {};
};if _cgade .ImageMap ==nil {_cgade .ImageMap =map[string ]*_cd .Image {};};if _cgade .ColorMap ==nil {_cgade .ColorMap =map[string ]Color {};};if _cgade .ChartMap ==nil {_cgade .ChartMap =map[string ]_ea .ChartRenderable {};};};

// SetLazy sets the lazy mode for the image.
func (_faeef *Image )SetLazy (lazy bool ){_faeef ._dbgf =lazy };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_agbb *Creator )SetOutlineTree (outlineTree *_cd .PdfOutlineTreeNode ){_agbb ._ddccc =outlineTree };func _aecdb (_bccda *templateProcessor ,_bfffe *templateNode )(interface{},error ){return _bccda .parseTable (_bfffe );};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_gccfe *Image )ScaleToHeight (h float64 ){_cafg :=_gccfe ._dbdfea /_gccfe ._eafg ;_gccfe ._eafg =h ;_gccfe ._dbdfea =h *_cafg ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_dbbg *RadialShading )AddShadingResource (block *Block )(_aeedd _cdf .PdfObjectName ,_dgagf error ){_cdad :=1;_aeedd =_cdf .PdfObjectName ("\u0053\u0068"+_c .Itoa (_cdad ));for block ._gaa .HasShadingByName (_aeedd ){_cdad ++;_aeedd =_cdf .PdfObjectName ("\u0053\u0068"+_c .Itoa (_cdad ));
};if _faaag :=block ._gaa .SetShadingByName (_aeedd ,_dbbg .shadingModel ().ToPdfObject ());_faaag !=nil {return "",_faaag ;};return _aeedd ,nil ;};func _fdbg (_ebeca *Block ){_geccdg :=_fgc .NewContentCreator ();_geccdg .Add_EMC ();_ebeca .addContents (_geccdg .Operations ());
};func _bcbd (_acec Color ,_cabb float64 )*ColorPoint {return &ColorPoint {_efddc :_acec ,_feag :_cabb }};func (_aebe cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_cag :=_aebe ._daeec ;return 1-(_aebe ._daee *(1-_cag )+_cag ),1-(_aebe ._faab *(1-_cag )+_cag ),1-(_aebe ._afde *(1-_cag )+_cag );
};

// Positioning returns the type of positioning the ellipse is set to use.
func (_eddd *Ellipse )Positioning ()Positioning {return _eddd ._dgc };type taggedDrawable struct{_efgb _cd .StructureType ;_aefb *_cd .StructureTagInfo ;};

// ClearAnnotations clears any existing annotations.
func (_efcdc *TextChunk )ClearAnnotations (){_efcdc ._badce =[]*_cd .PdfAnnotation {}};

// SetLogo sets the logo of the invoice.
func (_gfffc *Invoice )SetLogo (logo *Image ){_gfffc ._eddeg =logo };func _bdee (_bedcb *templateProcessor ,_gfddg *templateNode )(interface{},error ){return _bedcb .parseLine (_gfddg );};

// TagComponents instructs Creator whether or not to tag any component added after calling this function.
func (_aeab *Creator )TagComponents (enableTagging bool ){_aeab ._afdg =enableTagging ;if enableTagging {_aeab ._cfc =_cd .NewKDictionary ();_aeab ._cfc .S =_cdf .MakeName (string (_cd .StructureTypeDocument ));_aeab ._cfc .ID =_cdf .MakeString (_aeab ._cfc .GenerateRandomID ());
if _aeab ._gaaeb ==nil {_aeab ._gaaeb =_cd .NewStructTreeRoot ();};_aeab ._gaaeb .AddKDict (_aeab ._cfc );};};func _baag (_cbdd [][]_ggb .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_cgbfg :&_ggb .CurvePolygon {Rings :_cbdd },_ddca :1.0,_add :1.0};
};

// DrawHeader sets a function to draw a header on created output pages.
func (_dafe *Creator )DrawHeader (drawHeaderFunc func (_daec *Block ,_ecdcd HeaderFunctionArgs )){_dafe ._abdb =drawHeaderFunc ;};

// Length calculates and returns the length of the line.
func (_dcad *Line )Length ()float64 {return _bd .Sqrt (_bd .Pow (_dcad ._bfdg -_dcad ._bacec ,2.0)+_bd .Pow (_dcad ._ebgdf -_dcad ._cbcf ,2.0));};func _effba (_bccfe *_cd .PdfAnnotationHighlight )*_cd .PdfAnnotationHighlight {if _bccfe ==nil {return nil ;
};_badgf :=_cd .NewPdfAnnotationHighlight ();_badgf .CopyFrom (_bccfe .PdfAnnotation );_badgf .CA =_bccfe .CA ;_badgf .QuadPoints =_bccfe .QuadPoints ;return _badgf ;};

// DashPattern returns the dash pattern of the line.
func (_gbfc *Line )DashPattern ()(_fceee []int64 ,_agdf int64 ){return _gbfc ._egaeg ,_gbfc ._cbce };func (_bgdg *Invoice )generateHeaderBlocks (_gecc DrawContext )([]*Block ,DrawContext ,error ){_fbgdb :=_dgdda (_bgdg ._gbgee );_fbgdb .SetEnableWrap (true );
_fbgdb .Append (_bgdg ._egcc );_becg :=_gecca (2);if _bgdg ._eddeg !=nil {_dbbc :=_becg .NewCell ();_dbbc .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_dbbc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_dbbc .SetIndent (0);_dbbc .SetContent (_bgdg ._eddeg );
_bgdg ._eddeg .ScaleToHeight (_fbgdb .Height ()+20);}else {_becg .SkipCells (1);};_ceddb :=_becg .NewCell ();_ceddb .SetHorizontalAlignment (CellHorizontalAlignmentRight );_ceddb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ceddb .SetContent (_fbgdb );
return _becg .GeneratePageBlocks (_gecc );};func (_cdadc *StyledParagraph )split (_dbea DrawContext )(_eaefe ,_ebca *StyledParagraph ,_fgab error ){if _fgab =_cdadc .wrapChunks (false );_fgab !=nil {return nil ,nil ,_fgab ;};if len (_cdadc ._adcf )==1&&_cdadc ._dgbeg > _dbea .Height {return _cdadc ,nil ,nil ;
};_egdc :=func (_ccbb []*TextChunk ,_ccff []*TextChunk )[]*TextChunk {if len (_ccff )==0{return _ccbb ;};_cbbf :=len (_ccbb );if _cbbf ==0{return append (_ccbb ,_ccff ...);};if _ccbb [_cbbf -1].Style ==_ccff [0].Style {_ccbb [_cbbf -1].Text +=_ccff [0].Text ;
}else {_ccbb =append (_ccbb ,_ccff [0]);};return append (_ccbb ,_ccff [1:]...);};_ebdc :=func (_fcggc *StyledParagraph ,_ebeaf []*TextChunk )*StyledParagraph {if len (_ebeaf )==0{return nil ;};_feede :=*_fcggc ;_feede ._bcebd =_ebeaf ;return &_feede ;};
var (_cfggb float64 ;_feedg []*TextChunk ;_cffag []*TextChunk ;);for _ ,_bggef :=range _cdadc ._adcf {var _fedec float64 ;_fbbc :=make ([]*TextChunk ,0,len (_bggef ));for _ ,_bcee :=range _bggef {if _aaggb :=_bcee .Style .FontSize ;_aaggb > _fedec {_fedec =_aaggb ;
};_fbbc =append (_fbbc ,_bcee .clone ());};_fedec *=_cdadc ._dgbeg ;if _cdadc ._cdaea .IsRelative (){if _cfggb +_fedec > _dbea .Height {_cffag =_egdc (_cffag ,_fbbc );}else {_feedg =_egdc (_feedg ,_fbbc );};};_cfggb +=_fedec ;};_cdadc ._adcf =nil ;if len (_cffag )==0{return _cdadc ,nil ,nil ;
};return _ebdc (_cdadc ,_feedg ),_ebdc (_cdadc ,_cffag ),nil ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// AddLine appends a new line to the invoice line items table.
func (_fabe *Invoice )AddLine (values ...string )[]*InvoiceCell {_gfgbc :=len (_fabe ._bdfec );var _fagbe []*InvoiceCell ;for _ffbb ,_debgb :=range values {_afbd :=_fabe .newCell (_debgb ,_fabe ._fabdg );if _ffbb < _gfgbc {_afbd .Alignment =_fabe ._bdfec [_ffbb ].Alignment ;
};_fagbe =append (_fagbe ,_afbd );};_fabe ._abff =append (_fabe ._abff ,_fagbe );return _fagbe ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_geb *Creator )Finalize ()error {if _geb ._gabg {return nil ;};_cfg :=len (_geb ._agdb );_gdee :=0;if _geb ._gcd !=nil {_fbfge :=*_geb ;_geb ._agdb =nil ;_geb ._feda =nil ;_geb .initContext ();_aged :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cfg };
_geb ._gcd (_aged );_gdee +=len (_geb ._agdb );_geb ._agdb =_fbfge ._agdb ;_geb ._feda =_fbfge ._feda ;};if _geb .AddTOC {_geb .initContext ();_geb ._fga .Page =_gdee +1;if _geb .CustomTOC &&_geb ._aacf !=nil {_edc :=*_geb ;_geb ._agdb =nil ;_geb ._feda =nil ;
if _fbbf :=_geb ._aacf (_geb ._gege );_fbbf !=nil {return _fbbf ;};_gdee +=len (_geb ._agdb );_geb ._agdb =_edc ._agdb ;_geb ._feda =_edc ._feda ;}else {if _geb ._aacf !=nil {if _cbf :=_geb ._aacf (_geb ._gege );_cbf !=nil {return _cbf ;};};_ccd ,_ ,_fefg :=_geb ._gege .GeneratePageBlocks (_geb ._fga );
if _fefg !=nil {_fge .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_fefg );return _fefg ;};_gdee +=len (_ccd );};_bedc :=_geb ._gege .Lines ();
for _ ,_dbg :=range _bedc {_gdd ,_eafad :=_c .Atoi (_dbg .Page .Text );if _eafad !=nil {continue ;};_dbg .Page .Text =_c .Itoa (_gdd +_gdee );_dbg ._abcc +=int64 (_gdee );};};_bbdf :=false ;var _dbc []*_cd .PdfPage ;if _geb ._gcd !=nil {_abga :=*_geb ;
_geb ._agdb =nil ;_geb ._feda =nil ;_dgb :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cfg };_geb ._gcd (_dgb );_cfg +=len (_geb ._agdb );_dbc =_geb ._agdb ;_geb ._agdb =append (_geb ._agdb ,_abga ._agdb ...);_geb ._feda =_abga ._feda ;_bbdf =true ;
};var _egba []*_cd .PdfPage ;if _geb .AddTOC {_geb .initContext ();if _geb .CustomTOC &&_geb ._aacf !=nil {_adgfe :=*_geb ;_geb ._agdb =nil ;_geb ._feda =nil ;if _efe :=_geb ._aacf (_geb ._gege );_efe !=nil {_fge .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_efe );
return _efe ;};_egba =_geb ._agdb ;_cfg +=len (_egba );_geb ._agdb =_adgfe ._agdb ;_geb ._feda =_adgfe ._feda ;}else {if _geb ._aacf !=nil {if _agaa :=_geb ._aacf (_geb ._gege );_agaa !=nil {_fge .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_agaa );
return _agaa ;};};_gdbg ,_ ,_ :=_geb ._gege .GeneratePageBlocks (_geb ._fga );for _ ,_bca :=range _gdbg {_bca .SetPos (0,0);_cfg ++;_ecee :=_geb .newPage ();_egba =append (_egba ,_ecee );_geb .setActivePage (_ecee );_geb .Draw (_bca );};};if _bbdf {_bebe :=_dbc ;
_feee :=_geb ._agdb [len (_dbc ):];_geb ._agdb =append ([]*_cd .PdfPage {},_bebe ...);_geb ._agdb =append (_geb ._agdb ,_egba ...);_geb ._agdb =append (_geb ._agdb ,_feee ...);}else {_geb ._agdb =append (_egba ,_geb ._agdb ...);};};if _geb ._fff !=nil &&_geb .AddOutlines {var _aacg func (_cfadc *_cd .OutlineItem );
_aacg =func (_bgf *_cd .OutlineItem ){_bgf .Dest .Page +=int64 (_gdee );if _fdec :=int (_bgf .Dest .Page );_fdec >=0&&_fdec < len (_geb ._agdb ){_bgf .Dest .PageObj =_geb ._agdb [_fdec ].GetPageAsIndirectObject ();}else {_fge .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_fdec );
};_bgf .Dest .Y =_fag .RoundDefault (_geb ._bda -_bgf .Dest .Y );_bada :=_bgf .Items ();for _ ,_afca :=range _bada {_aacg (_afca );};};_gge :=_geb ._fff .Items ();for _ ,_gdbb :=range _gge {_aacg (_gdbb );};if _geb .AddTOC {var _fgec int ;if _bbdf {_fgec =len (_dbc );
};_gcaa :=_cd .NewOutlineDest (int64 (_fgec ),0,_geb ._bda );if _fgec >=0&&_fgec < len (_geb ._agdb ){_gcaa .PageObj =_geb ._agdb [_fgec ].GetPageAsIndirectObject ();}else {_fge .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_fgec );
};_geb ._fff .Insert (0,_cd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_gcaa ));};};for _ccef ,_ecbc :=range _geb ._agdb {_geb .setActivePage (_ecbc );if _geb ._gfg !=nil {_gecgg ,_aadda ,_ffef :=_ecbc .Size ();
if _ffef !=nil {return _ffef ;};_egaa :=PageFinalizeFunctionArgs {PageNum :_ccef +1,PageWidth :_gecgg ,PageHeight :_aadda ,TOCPages :len (_egba ),TotalPages :_cfg };if _agac :=_geb ._gfg (_egaa );_agac !=nil {_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_agac );
return _agac ;};};if _geb ._abdb !=nil {_fbfc :=NewBlock (_geb ._ebgd ,_geb ._ecba .Top );_fade :=HeaderFunctionArgs {PageNum :_ccef +1,TotalPages :_cfg };_geb ._abdb (_fbfc ,_fade );_fbfc .SetPos (0,0);if _cfee :=_geb .Draw (_fbfc );_cfee !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_cfee );
return _cfee ;};};if _geb ._gdb !=nil {_cgda :=NewBlock (_geb ._ebgd ,_geb ._ecba .Bottom );_eabc :=FooterFunctionArgs {PageNum :_ccef +1,TotalPages :_cfg };_geb ._gdb (_cgda ,_eabc );_cgda .SetPos (0,_geb ._bda -_cgda ._ff );if _eage :=_geb .Draw (_cgda );
_eage !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_eage );return _eage ;};};_bcedg ,_feeec :=_geb ._bdb [_ecbc ];if _fgfb ,_afba :=_geb ._dfdg [_ecbc ];
_afba {if _feeec {_bcedg .transformBlock (_fgfb );};if _dgfd :=_fgfb .drawToPage (_ecbc );_dgfd !=nil {_fge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_ccef +1,_dgfd );
return _dgfd ;};};if _feeec {if _ffg :=_bcedg .transformPage (_ecbc );_ffg !=nil {_fge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_ffg );
return _ffg ;};};};_geb ._gabg =true ;return nil ;};func _faaaf (_cbdc string ,_egbab ,_acaef TextStyle )*TOC {_ccade :=_acaef ;_ccade .FontSize =14;_fdbde :=_dgdda (_ccade );_fdbde .SetEnableWrap (true );_fdbde .SetTextAlignment (TextAlignmentLeft );_fdbde .SetMargins (0,0,0,5);
_cggee :=_fdbde .Append (_cbdc );_cggee .Style =_ccade ;return &TOC {_bbgfb :_fdbde ,_affbb :[]*TOCLine {},_cbgg :_egbab ,_ecacc :_egbab ,_acbdd :_egbab ,_accg :_egbab ,_cgaeg :"\u002e",_fbaf :10,_fabff :Margins {0,0,2,2},_cgeec :PositionRelative ,_cagc :_egbab ,_accgc :true ,taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeTOC }};
};

// SetWidth sets the width of the ellipse.
func (_gfb *Ellipse )SetWidth (width float64 ){_gfb ._bgfbe =width };

// NewFilledCurve returns a instance of filled curve.
func (_ggdg *Creator )NewFilledCurve ()*FilledCurve {return _babc ()};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };
);

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_effa *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_efbf *_cd .PdfWriter )error ){_effa ._bfad =pdfWriterAccessFunc ;};

// RemoveArtifact removes the artifact associated with the image, if any.
func (_gacbe *Image )RemoveArtifact (){_gacbe ._bgge =nil };

// CurCol returns the currently active cell's column number.
func (_fcge *Table )CurCol ()int {_eeee :=(_fcge ._gecgc -1)%(_fcge ._ccabb )+1;return _eeee };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_gdfg *Creator )NewImageFromGoImage (goimg _ga .Image )(*Image ,error ){return _abcaa (goimg )};func (_ffgfe *templateProcessor )parseDivision (_aeaca *templateNode )(interface{},error ){_deebd :=_ffgfe .creator .NewDivision ();for _ ,_begcf :=range _aeaca ._bcaga .Attr {_aaeb :=_begcf .Value ;
switch _fcbf :=_begcf .Name .Local ;_fcbf {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_deebd .EnablePageWrap (_ffgfe .parseBoolAttr (_fcbf ,_aaeb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_daaae :=_ffgfe .parseMarginAttr (_fcbf ,_aaeb );
_deebd .SetMargins (_daaae .Left ,_daaae .Right ,_daaae .Top ,_daaae .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_cfaa :=_ffgfe .parseMarginAttr (_fcbf ,_aaeb );_deebd .SetPadding (_cfaa .Left ,_cfaa .Right ,_cfaa .Top ,_cfaa .Bottom );default:_ffgfe .nodeLogDebug (_aeaca ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fcbf );
};};return _deebd ,nil ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_gbef *Division )SetPadding (left ,right ,top ,bottom float64 ){_gbef ._egcf .Left =left ;_gbef ._egcf .Right =right ;_gbef ._egcf .Top =top ;_gbef ._egcf .Bottom =bottom ;};

// ToContentCreator convert SVG and add elements contentstream then returns `contentstream.ContentCreator`.
func (_gggd *GraphicSVGElement )ToContentCreator (cc *_fgc .ContentCreator ,res *_cd .PdfPageResources ,scaleX ,scaleY ,translateX ,translateY float64 )*_fgc .ContentCreator {if _gggd .Name =="\u0073\u0076\u0067"{_gggd .SetScaling (scaleX ,scaleY );cc .Add_cm (1,0,0,1,translateX ,translateY );
_gggd .setDefaultScaling (_gggd ._fgdg );cc .Add_q ();_fged :=_bd .Max (scaleX ,scaleY );cc .Add_re (_gggd .ViewBox .X *_fged ,_gggd .ViewBox .Y *_fged ,_gggd .ViewBox .W *_fged ,_gggd .ViewBox .H *_fged );cc .Add_W ();cc .Add_n ();_gggd .processDefs ();
for _ ,_agda :=range _gggd .Children {_agda .ViewBox =_gggd .ViewBox ;_agda ._aeea =_gggd ._aeea ;_agda ._edbee =_gggd ._edbee ;_agda .toContentStream (cc ,res );};cc .Add_Q ();return cc ;};return nil ;};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_cbbb *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ebbaf []*Block ;_cgfe =NewBlock (ctx .PageWidth ,ctx .PageHeight );_ceagd =ctx ;_befd ,_eefag =_cbbb ._bacec ,ctx .PageHeight -_cbbb ._cbcf ;_dace ,_bdfae =_cbbb ._bfdg ,ctx .PageHeight -_cbbb ._ebgdf ;
);_bbgd :=_cbbb ._gdef .IsRelative ();if _bbgd {ctx .X +=_cbbb ._adac .Left ;ctx .Y +=_cbbb ._adac .Top ;ctx .Width -=_cbbb ._adac .Left +_cbbb ._adac .Right ;ctx .Height -=_cbbb ._adac .Top +_cbbb ._adac .Bottom ;_befd ,_eefag ,_dace ,_bdfae =_cbbb .computeCoords (ctx );
if _cbbb .Height ()> ctx .Height {_ebbaf =append (_ebbaf ,_cgfe );_cgfe =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cgce :=ctx ;_cgce .Y =ctx .Margins .Top +_cbbb ._adac .Top ;_cgce .X =ctx .Margins .Left +_cbbb ._adac .Left ;_cgce .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cbbb ._adac .Top -_cbbb ._adac .Bottom ;
_cgce .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cbbb ._adac .Left -_cbbb ._adac .Right ;ctx =_cgce ;_befd ,_eefag ,_dace ,_bdfae =_cbbb .computeCoords (ctx );};};_bcccb :=_ggb .BasicLine {X1 :_befd ,Y1 :_eefag ,X2 :_dace ,Y2 :_bdfae ,LineColor :_acac (_cbbb ._bgec ),Opacity :_cbbb ._accf ,LineWidth :_cbbb ._ebee ,LineStyle :_cbbb ._fdcg ,DashArray :_cbbb ._egaeg ,DashPhase :_cbbb ._cbce };
_fccdd ,_babdb :=_cgfe .setOpacity (1.0,_cbbb ._accf );if _babdb !=nil {return nil ,ctx ,_babdb ;};_eefc ,_ ,_babdb :=_bcccb .MarkedDraw (_fccdd ,_cbbb ._aefb );if _babdb !=nil {return nil ,ctx ,_babdb ;};if _babdb =_cgfe .addContentsByString (string (_eefc ));
_babdb !=nil {return nil ,ctx ,_babdb ;};if _bbgd {ctx .X =_ceagd .X ;ctx .Width =_ceagd .Width ;_beecb :=_cbbb .Height ();ctx .Y +=_beecb +_cbbb ._adac .Bottom ;ctx .Height -=_beecb ;}else {ctx =_ceagd ;};_ebbaf =append (_ebbaf ,_cgfe );return _ebbaf ,ctx ,nil ;
};

// Lines returns all the rows of the invoice line items table.
func (_gggdg *Invoice )Lines ()[][]*InvoiceCell {return _gggdg ._abff };func _feed (_cgga int )*Grid {_bccc :=&Grid {_abgd :_cgga ,_ffgb :10.0,_gded :[]float64 {}};_bccc ._efgb =_cd .StructureTypeTable ;_bccc .resetColumnWidths ();return _bccc ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_cd .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_cd .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};func (_ecbaec *templateProcessor )addNodeText (_eefgb *templateNode ,_bbcbd string )error {_gabce :=_eefgb ._bcacc ;if _gabce ==nil {return nil ;};switch _cabae :=_gabce .(type ){case *TextChunk :_cabae .Text =_bbcbd ;case *StyledParagraph :switch _eefgb ._bcaga .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _eefgb ._fbddd !=nil {if _gade ,_deebe :=_eefgb ._fbddd ._bcacc .(*Chapter );
_deebe {_gade ._dfd =_bbcbd ;_cabae .SetText (_gade .headingText ());};};};};return nil ;};func _efgd (_dggb ,_gdcg ,_aaef ,_ebeg float64 )*Ellipse {return &Ellipse {_adbf :_dggb ,_gggg :_gdcg ,_bgfbe :_aaef ,_ffaee :_ebeg ,_dgc :PositionAbsolute ,_aadae :1.0,_ddfb :ColorBlack ,_dffd :1.0,_bdfd :1.0};
};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
//
// Deprecated: Use NewStyledParagraph instead for better styling options.
func (_cece *Creator )NewParagraph (text string )*Paragraph {return _cccf (text ,_cece .NewTextStyle ())};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_gefd *Ellipse )SetFillOpacity (opacity float64 ){_gefd ._aadae =opacity };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_bgag *Invoice )NoteStyle ()TextStyle {return _bgag ._acef };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline ,_badce :[]*_cd .PdfAnnotation {},_dgefd :[]bool {},taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeSpan }};
};func (_abca *GraphicSVGElement )parseColorPoints ()[]*ColorPoint {var _cgbc []*ColorPoint ;var _cgebd error ;for _ ,_gdfgb :=range _abca .Children {if _gdfgb .Name =="\u0073\u0074\u006f\u0070"{_bcab :=ColorBlack ;_cbff :=0.0;for _dafc ,_dbcc :=range _gdfgb .Attributes {if _dafc =="\u006f\u0066\u0066\u0073\u0065\u0074"{if _gg .HasSuffix (_dbcc ,"\u0025"){_aeaab ,_gedb :=_c .ParseFloat (_gg .TrimSuffix (_dbcc ,"\u0025"),64);
if _gedb !=nil {continue ;};_cbff =_aeaab /100;}else {_cbff ,_cgebd =_c .ParseFloat (_dbcc ,64);if _cgebd !=nil {continue ;};};}else if _dafc =="\u0073\u0074\u006f\u0070\u002d\u0063\u006f\u006c\u006f\u0072"{if _dbcc [0]=='#'{_bcab =ColorRGBFromHex (_dbcc );
}else {_caee ,_bggg :=_ag .ColorMap [_dbcc ];if _bggg {_bcab =ColorRGBFrom8bit (_caee .R ,_caee .G ,_caee .B );};};};};_cgbc =append (_cgbc ,NewColorPoint (_bcab ,_cbff ));};};return _cgbc ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_fbege *LinearShading )ToPdfShadingPattern ()*_cd .PdfShadingPatternType2 {_gbcga ,_ebbab ,_dcfe :=_fbege ._bedba ._dcfb .ToRGB ();_bebfc :=_fbege .shadingModel ();_bebfc .Background =_cdf .MakeArrayFromFloats ([]float64 {_gbcga ,_ebbab ,_dcfe });
_babdd :=_cd .NewPdfShadingPatternType2 ();_babdd .Shading =_bebfc ;return _babdd ;};func _gegc (_bdaac string )(*GraphicSVG ,error ){_gfafa ,_babf :=ParseFromSVGFile (_bdaac );if _babf !=nil {return nil ,_babf ;};return _dfad (_gfafa );};func _aaf (_gce ,_cacd ,_cdea ,_cafb float64 )*border {_accd :=&border {};
_accd ._gae =_gce ;_accd ._acc =_cacd ;_accd ._degf =_cdea ;_accd ._ddf =_cafb ;_accd ._afd =ColorBlack ;_accd ._aagb =ColorBlack ;_accd ._dfc =ColorBlack ;_accd ._gfef =ColorBlack ;_accd ._beb =0;_accd ._bbf =0;_accd ._gbdg =0;_accd ._bbff =0;_accd ._fccfa =1.0;
_accd .LineStyle =_ggb .LineStyleSolid ;return _accd ;};func _facge (_beff ,_acefb ,_gfga int )[]int {_gagb :=[]int {};for _gdedf :=_beff ;_gdedf <=_gfga ;_gdedf +=_acefb {_gagb =append (_gagb ,_gdedf );};return _gagb ;};

// SetWidthLeft sets border width for left.
func (_cgdg *border )SetWidthLeft (bw float64 ){_cgdg ._gbdg =bw };

// SetHeight sets the Image's document height to specified h.
func (_fbc *Image )SetHeight (h float64 ){_fbc ._eafg =h };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_ead *Block )SetMargins (left ,right ,top ,bottom float64 ){_ead ._ef .Left =left ;_ead ._ef .Right =right ;_ead ._ef .Top =top ;_ead ._ef .Bottom =bottom ;};

// NewDivision returns a new Division container component.
func (_adag *Creator )NewDivision ()*Division {return _ecg ()};

// AddColorStop add color stop information for rendering gradient.
func (_facfb *shading )AddColorStop (color Color ,point float64 ){_facfb ._ecgf =append (_facfb ._ecgf ,_bcbd (color ,point ));};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_afea *GraphicSVG )ScaleToWidth (w float64 ){_ccdb :=_afea ._dcdb .Height /_afea ._dcdb .Width ;_afea ._dcdb .Width =w ;_afea ._dcdb .Height =w *_ccdb ;_afea ._dcdb .SetScaling (_ccdb ,_ccdb );};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Decode decodes the child elements of element.
func (_fegeb *GraphicSVGElement )Decode (decoder *_gd .Decoder )error {for {_aacfe ,_adeg :=decoder .Token ();if _aacfe ==nil &&_adeg ==_bg .EOF {break ;};if _adeg !=nil {return _adeg ;};switch _fccb :=_aacfe .(type ){case _gd .StartElement :_cafc :=_bdac (_fccb );
_ecfb :=_cafc .Decode (decoder );if _ecfb !=nil {return _ecfb ;};_fegeb .Children =append (_fegeb .Children ,_cafc );case _gd .CharData :_gccf :=_gg .TrimSpace (string (_fccb ));if _gccf !=""{_fegeb .Content =string (_fccb );};case _gd .EndElement :if _fccb .Name .Local ==_fegeb .Name {return nil ;
};};};return nil ;};

// SetStyle sets paragraph style for all chunks.
func (_cbcda *StyledParagraph )SetStyle (style TextStyle ){_cbcda ._eeac =style ;for _ ,_cbae :=range _cbcda ._bcebd {_cbae .Style =style ;};};

// Height returns the height of the ellipse.
func (_aaff *Ellipse )Height ()float64 {return _aaff ._ffaee };

// SetLineWidth sets the line width.
func (_ecbd *Polyline )SetLineWidth (lineWidth float64 ){_ecbd ._gbgg .LineWidth =lineWidth };

// SetDate sets the date of the invoice.
func (_dacc *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_dacc ._gega [1].Value =date ;return _dacc ._gega [0],_dacc ._gega [1];};

// SetBorderOpacity sets the border opacity of the ellipse.
func (_ggga *Ellipse )SetBorderOpacity (opacity float64 ){_ggga ._bdfd =opacity };func (_gbga *StyledParagraph )getMaxLineWidth ()float64 {if _gbga ._adcf ==nil ||(_gbga ._adcf !=nil &&len (_gbga ._adcf )==0){_gbga .wrapText ();};var _cccfd float64 ;for _ ,_ccbeg :=range _gbga ._adcf {_decgb :=_gbga .getTextLineWidth (_ccbeg );
if _decgb > _cccfd {_cccfd =_decgb ;};};return _cccfd ;};

// FillColor returns the fill color of the rectangle.
func (_cfgge *Rectangle )FillColor ()Color {return _cfgge ._bfcd };

// SetAngle sets the rotation angle in degrees.
func (_bge *Block )SetAngle (angleDeg float64 ){_bge ._gc =angleDeg };

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_cdbcb *Rectangle )ScaleToHeight (h float64 ){_eacbd :=_cdbcb ._bfed /_cdbcb ._abdcf ;_cdbcb ._abdcf =h ;_cdbcb ._bfed =h *_eacbd ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bdgcf *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bdgcf ._dcfd .Left ,_bdgcf ._dcfd .Right ,_bdgcf ._dcfd .Top ,_bdgcf ._dcfd .Bottom ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetMargins sets the margins TOC line.
func (_abcf *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_abcf ._ecece =left ;_bgcc :=&_abcf ._gbbaf ._acgdg ;_bgcc .Left =_abcf ._ecece +float64 (_abcf ._feacc -1)*_abcf ._fdgca ;_bgcc .Right =right ;_bgcc .Top =top ;_bgcc .Bottom =bottom ;
};func (_cgcfe *templateProcessor )parseAttrPropList (_egde string )map[string ]string {_bgbac :=_gg .Fields (_egde );if len (_bgbac )==0{return nil ;};_gbaa :=map[string ]string {};for _ ,_eccc :=range _bgbac {_cegae :=_afaad .FindStringSubmatch (_eccc );
if len (_cegae )< 3{continue ;};_fcbaaa ,_bgfec :=_gg .TrimSpace (_cegae [1]),_cegae [2];if _fcbaaa ==""{continue ;};_gbaa [_fcbaaa ]=_bgfec ;};return _gbaa ;};func (_dbdg *Creator )wrapPageIfNeeded (_edac *_cd .PdfPage )(*_cd .PdfPage ,error ){_fegb ,_gef :=_edac .GetAllContentStreams ();
if _gef !=nil {return nil ,_gef ;};_abde :=_fgc .NewContentStreamParser (_fegb );_effg ,_gef :=_abde .Parse ();if _gef !=nil {return nil ,_gef ;};if !_effg .HasUnclosedQ (){return nil ,nil ;};_effg .WrapIfNeeded ();_aegf ,_gef :=_cdf .MakeStream (_effg .Bytes (),_cdf .NewFlateEncoder ());
if _gef !=nil {return nil ,_gef ;};_edac .Contents =_cdf .MakeArray (_aegf );return _edac ,nil ;};

// IsAbsolute checks if the positioning is absolute.
func (_eaee Positioning )IsAbsolute ()bool {return _eaee ==PositionAbsolute };

// String implements error interface.
func (_befe UnsupportedRuneError )Error ()string {return _befe .Message };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_ggae *Block )DrawTemplate (c *Creator ,r _bg .Reader ,data interface{},options *TemplateOptions )error {return _dgcd (c ,r ,data ,options ,_ggae );};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{taggedDrawable ;_gecb []*listItem ;_bcefc Margins ;_fccc TextChunk ;_bdge float64 ;_efab bool ;_bdeg Positioning ;_cedde TextStyle ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_dece *Paragraph )Height ()float64 {_dece .wrapText ();return _fag .RoundDefault (float64 (len (_dece ._dcfdd ))*_dece ._fbdcb *_dece ._dgdde );};

// NewImageFromFile creates an Image from a file.
func (_gagf *Creator )NewImageFromFile (path string )(*Image ,error ){return _dcba (path )};

// Invoice represents a configurable invoice template.
type Invoice struct{_egcc string ;_eddeg *Image ;_cabc *InvoiceAddress ;_cfccb *InvoiceAddress ;_fgagg string ;_dcfg [2]*InvoiceCell ;_gega [2]*InvoiceCell ;_bbbc [2]*InvoiceCell ;_bdgbg [][2]*InvoiceCell ;_bdfec []*InvoiceCell ;_abff [][]*InvoiceCell ;
_fdfe [2]*InvoiceCell ;_eacee [2]*InvoiceCell ;_fbece [][2]*InvoiceCell ;_eeadg [2]string ;_bcggc [2]string ;_begf [][2]string ;_dfeb TextStyle ;_ebfd TextStyle ;_gbgee TextStyle ;_fdcd TextStyle ;_cabf TextStyle ;_acef TextStyle ;_gebdb TextStyle ;_ebgc InvoiceCellProps ;
_fdcdb InvoiceCellProps ;_fabdg InvoiceCellProps ;_gaagg InvoiceCellProps ;_dcgc Positioning ;};

// SetAngle sets the rotation angle of the text.
func (_aaaed *Paragraph )SetAngle (angle float64 ){_aaaed ._ebfdg =angle };const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// GeneratePageBlocks draws the curve onto page blocks.
func (_cfbd *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcee :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_deac :=_fgc .NewContentCreator ();if _cfbd ._aefb !=nil {_deac .Add_BDC (*_cdf .MakeName (string (_cfbd ._aefb .StructureType )),map[string ]_cdf .PdfObject {"\u004d\u0043\u0049\u0044":_cdf .MakeInteger (_cfbd ._aefb .Mcid )});
};_deac .Add_q ().Add_w (_cfbd ._dbec ).SetStrokingColor (_acac (_cfbd ._agbd )).Add_m (_cfbd ._eee ,ctx .PageHeight -_cfbd ._fbdg ).Add_v (_cfbd ._bae ,ctx .PageHeight -_cfbd ._gdac ,_cfbd ._cddf ,ctx .PageHeight -_cfbd ._aaec ).Add_S ().Add_Q ();if _cfbd ._aefb !=nil {_deac .Add_EMC ();
};_edcf :=_fcee .addContentsByString (_deac .String ());if _edcf !=nil {return nil ,ctx ,_edcf ;};return []*Block {_fcee },ctx ,nil ;};

// SetPos set position of the element on PDF page
func (_bbde *GraphicSVGElement )SetPos (x ,y float64 ){_bbde ._dgaa =x ;_bbde ._gcgd =y };func (_ggfga *Paragraph )getTextLineWidth (_aeeb string )float64 {var _fgda float64 ;for _ ,_agdbac :=range _aeeb {if _agdbac =='\u000A'{continue ;};_cdgdd ,_cgbcf :=_ggfga ._gcfa .GetRuneMetrics (_agdbac );
if !_cgbcf {_fge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_agdbac ,_agdbac );
return -1;};_fgda +=_ggfga ._dgdde *_cdgdd .Wx ;};return _fgda ;};

// Vertical returns total vertical (top + bottom) margin.
func (_cfd *Margins )Vertical ()float64 {return _cfd .Bottom +_cfd .Top };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_ecdff *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_addg :=ctx ;var _abdcd []*Block ;_bcaec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ecdff ._bgcg .IsRelative (){ctx .X +=_fag .RoundDefault (_ecdff ._dcfd .Left );
ctx .Y +=_fag .RoundDefault (_ecdff ._dcfd .Top );ctx .Width -=_fag .RoundDefault (_ecdff ._dcfd .Left +_ecdff ._dcfd .Right );ctx .Height -=_fag .RoundDefault (_ecdff ._dcfd .Top );_ecdff .SetWidth (ctx .Width );if _ecdff .Height ()> ctx .Height {_abdcd =append (_abdcd ,_bcaec );
_bcaec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gcadb :=ctx ;_gcadb .Y =_fag .RoundDefault (ctx .Margins .Top );_gcadb .X =_fag .RoundDefault (ctx .Margins .Left +_ecdff ._dcfd .Left );_gcadb .Height =_fag .RoundDefault (ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom );
_gcadb .Width =_fag .RoundDefault (ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ecdff ._dcfd .Left -_ecdff ._dcfd .Right );ctx =_gcadb ;};}else {if int (_ecdff ._efbe )<=0{_ecdff .SetWidth (_ecdff .getTextWidth ());};ctx .X =_ecdff ._dbed ;
ctx .Y =_ecdff ._bdgeg ;};ctx ,_baga :=_gcfd (_bcaec ,_ecdff ,ctx );if _baga !=nil {_fge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_baga );return nil ,ctx ,_baga ;};_abdcd =append (_abdcd ,_bcaec );if _ecdff ._bgcg .IsRelative (){ctx .Y +=_fag .RoundDefault (_ecdff ._dcfd .Bottom );
ctx .Height -=_fag .RoundDefault (_ecdff ._dcfd .Bottom );if !ctx .Inline {ctx .X =_addg .X ;ctx .Width =_addg .Width ;};return _abdcd ,ctx ,nil ;};return _abdcd ,_addg ,nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;
TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// Margins returns the margins of the component.
func (_gbb *Division )Margins ()(_adbd ,_gcda ,_gaca ,_eece float64 ){return _gbb ._gadc .Left ,_gbb ._gadc .Right ,_gbb ._gadc .Top ,_gbb ._gadc .Bottom ;};

// SetLineHeight sets the line height (1.0 default).
func (_dcfa *StyledParagraph )SetLineHeight (lineheight float64 ){_dcfa ._dgbeg =lineheight };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_ceab *Invoice )SetColumns (cols []*InvoiceCell ){_ceab ._bdfec =cols };func _cccd ()*listItem {return &listItem {}};

// GetArtifact returns the artifact associated with the paragraph, if any.
func (_ccbg *StyledParagraph )GetArtifact ()*_cd .Artifact {return _ccbg ._deafc };

// GeneratePageBlocks generates a page break block.
func (_bdbb *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbefd :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_cdcff :=ctx ;_cdcff .Y =ctx .Margins .Top ;
_cdcff .X =ctx .Margins .Left ;_cdcff .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_cdcff .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_cdcff ;return _gbefd ,ctx ,nil ;};func _aecb (_bdcg ,_face ,_ffde ,_deffg float64 )*Line {return &Line {_bacec :_bdcg ,_cbcf :_face ,_bfdg :_ffde ,_ebgdf :_deffg ,_bgec :ColorBlack ,_accf :1.0,_ebee :1.0,_egaeg :[]int64 {1,1},_gdef :PositionAbsolute };
};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_aeagb *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_bgba :=NewTextChunk (text ,_aeagb ._adfa );_bgba .AddAnnotation (_aegef (page -1,x ,y ,zoom ,""));return _aeagb .appendChunk (_bgba );};

// GetOptimizer returns current PDF optimizer.
func (_gdga *Creator )GetOptimizer ()_cd .Optimizer {return _gdga ._ecaf };func _faefe (_facgd *Block ,_gcgec *_cd .StructureTagInfo ){_ggfea :=_fgc .NewContentCreator ();_ggdfd :=map[string ]_cdf .PdfObject {};if _gcgec !=nil {_ggdfd ["\u004d\u0043\u0049\u0044"]=_cdf .MakeInteger (_gcgec .Mcid );
};_ggfea .Add_BDC (*_cdf .MakeName (string (_gcgec .StructureType )),_ggdfd );_facgd .addContents (_ggfea .Operations ());};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_ccegb *Creator )PageFinalize (pageFinalizeFunc func (_cad PageFinalizeFunctionArgs )error ){_ccegb ._gfg =pageFinalizeFunc ;};func _fbdf (_acccd *Block ,_gdcac *StyledParagraph ,_acdca [][]*TextChunk ,_abce DrawContext )(DrawContext ,[][]*TextChunk ,error ){_abbdg :=1;
_gdeabc :=_cdf .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abbdg ));for _acccd ._gaa .HasFontByName (_gdeabc ){_abbdg ++;_gdeabc =_cdf .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abbdg ));};_abacb :=_acccd ._gaa .SetFontByName (_gdeabc ,_gdcac ._eeac .Font .ToPdfObject ());
if _abacb !=nil {return _abce ,nil ,_abacb ;};_abbdg ++;_egef :=_gdeabc ;_agfgd :=_gdcac ._eeac .FontSize ;_ggbff :=_gdcac ._cdaea .IsRelative ();var _defff [][]_cdf .PdfObjectName ;var _adfdg [][]*TextChunk ;var _ccaf float64 ;for _begd ,_eecfb :=range _acdca {var _adff []_cdf .PdfObjectName ;
var _ccacg float64 ;if len (_eecfb )> 0{_ccacg =_eecfb [0].Style .FontSize ;};for _ ,_gacca :=range _eecfb {_gddcd :=_gacca .Style ;if _gacca .Text !=""&&_gddcd .FontSize > _ccacg {_ccacg =_gddcd .FontSize ;};if _ccacg > _abce .PageHeight {return _abce ,nil ,_fab .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_gdeabc =_cdf .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abbdg ));_bdbdd :=_acccd ._gaa .SetFontByName (_gdeabc ,_gddcd .Font .ToPdfObject ());if _bdbdd !=nil {return _abce ,nil ,_bdbdd ;};_adff =append (_adff ,_gdeabc );_abbdg ++;
};_ccacg *=_gdcac ._dgbeg ;if _ggbff &&_ccaf +_ccacg > _abce .Height {_adfdg =_acdca [_begd :];_acdca =_acdca [:_begd ];break ;};_ccaf +=_ccacg ;_defff =append (_defff ,_adff );};_egegb ,_dgefc ,_gdgc :=_gdcac .getLineMetrics (0);_cgddc ,_eeeg :=_egegb *_gdcac ._dgbeg ,_dgefc *_gdcac ._dgbeg ;
if len (_acdca )==0{return _abce ,_adfdg ,nil ;};_aaece :=_fgc .NewContentCreator ();_aaece .Add_q ();_fgea :=_eeeg ;if _gdcac ._fcdg ==TextVerticalAlignmentCenter {_fgea =_dgefc +(_egegb +_gdgc -_dgefc )/2+(_eeeg -_dgefc )/2;};_acea :=_abce .PageHeight -_abce .Y -_fgea ;
_aaece .Translate (_abce .X ,_acea );_ddff :=_acea ;if _gdcac ._cebgb !=0{_aaece .RotateDeg (_gdcac ._cebgb );};if _gdcac ._eccfd ==TextOverflowHidden {_aaece .Add_re (0,-_ccaf +_cgddc +1,_gdcac ._fcced ,_ccaf ).Add_W ().Add_n ();};_aaece .Add_BT ();_efbbe :=map[string ]_cdf .PdfObject {};
if _gdcac ._deafc ==nil {if _gdcac ._aefb !=nil {_efbbe ["\u004d\u0043\u0049\u0044"]=_cdf .MakeInteger (_gdcac ._aefb .Mcid );};if _gdcac ._cdeb !=""{_efbbe ["\u004c\u0061\u006e\u0067"]=_cdf .MakeString (_gdcac ._cdeb );};if len (_efbbe )> 0{_aaece .Add_BDC (*_cdf .MakeName (string (_gdcac ._aefb .StructureType )),_efbbe );
};}else {_efbbe =_gdcac ._deafc .GenerateMap ();if len (_efbbe )> 0{_aaece .Add_BDC (*_cdf .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")),_efbbe );}else {_aaece .Add_BMC (*_cdf .MakeName (string ("\u0041\u0072\u0074\u0069\u0066\u0061\u0063\u0074")));
};};var _gfbde []*_ggb .BasicLine ;for _cdddb ,_caec :=range _acdca {_fgabg :=_abce .X ;var _cfcd float64 ;if len (_caec )> 0{_cfcd =_caec [0].Style .FontSize ;};_egegb ,_ ,_gdgc =_gdcac .getLineMetrics (_cdddb );_eeeg =(_egegb +_gdgc );for _ ,_defe :=range _caec {_fbee :=&_defe .Style ;
if _defe .Text !=""&&_fbee .FontSize > _cfcd {_cfcd =_fbee .FontSize ;};if _eeeg > _cfcd {_cfcd =_eeeg ;};};if _cdddb !=0{_aaece .Add_TD (0,-_cfcd *_gdcac ._dgbeg );_ddff -=_cfcd *_gdcac ._dgbeg ;};_caeb :=_cdddb ==len (_acdca )-1;var (_effbd float64 ;
_gagec float64 ;_caece *fontMetrics ;_egfea float64 ;_gagc uint ;);var _fbdgb []float64 ;for _ ,_eded :=range _caec {_ffdc :=&_eded .Style ;if _ffdc .FontSize > _gagec {_gagec =_ffdc .FontSize ;_caece =_fded (_eded .Style .Font ,_ffdc .FontSize );};if _eeeg > _gagec {_gagec =_eeeg ;
};_aegff ,_caeaa :=_ffdc .Font .GetRuneMetrics (' ');if _aegff .Wx ==0&&_ffdc .MultiFont !=nil {_aegff ,_caeaa =_ffdc .MultiFont .GetRuneMetrics (' ');_ffdc .MultiFont .Reset ();};if !_caeaa {return _abce ,nil ,_fab .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _egag uint ;var _aafeg float64 ;_gbbdc :=len (_eded .Text );for _gdgg ,_egga :=range _eded .Text {if _egga ==' '{_egag ++;continue ;};if _egga =='\u000A'{continue ;};_efgef ,_bagdd :=_ffdc .Font .GetRuneMetrics (_egga );if _efgef .Wx ==0&&_ffdc .MultiFont !=nil {_efgef ,_bagdd =_ffdc .MultiFont .GetRuneMetrics (' ');
_ffdc .MultiFont .Reset ();};if !_bagdd {_fge .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_egga );return _abce ,nil ,_fab .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_aafeg +=_ffdc .FontSize *_efgef .Wx *_ffdc .horizontalScale ();if _gdgg !=_gbbdc -1{_aafeg +=_ffdc .CharSpacing *1000.0;};};_fbdgb =append (_fbdgb ,_aafeg );_effbd +=_aafeg ;_egfea +=float64 (_egag )*_aegff .Wx *_ffdc .FontSize *_ffdc .horizontalScale ();
_gagc +=_egag ;};_gagec *=_gdcac ._dgbeg ;var _fggd []_cdf .PdfObject ;_gbbgf :=_gdcac ._fcced *1000.0;switch _gdcac ._dffe {case TextAlignmentJustify :if _gagc > 0&&!_caeb {_egfea =(_gbbgf -_effbd )/float64 (_gagc )/_agfgd ;};case TextAlignmentCenter :_dagcb :=(_gbbgf -_effbd -_egfea )/2;
_bddca :=_dagcb /_agfgd ;_fggd =append (_fggd ,_cdf .MakeFloat (-_bddca ));_fgabg +=_dagcb /1000.0;case TextAlignmentRight :_afae :=(_gbbgf -_effbd -_egfea );_baac :=_afae /_agfgd ;_fggd =append (_fggd ,_cdf .MakeFloat (-_baac ));_fgabg +=_afae /1000.0;
};if len (_fggd )> 0{_aaece .Add_Tf (_egef ,_agfgd ).Add_TL (_agfgd *_gdcac ._dgbeg ).Add_TJ (_fggd ...);};_beee :=0.0;for _efgdd ,_bcgb :=range _caec {_acccc :=&_bcgb .Style ;_dgagb :=_egef ;_gbdcc :=_agfgd ;_afgf :=_acccc .OutlineColor !=nil ;_baddd :=_acccc .HorizontalScaling !=DefaultHorizontalScaling ;
_bfgdg :=_acccc .OutlineSize !=1;if _bfgdg {_aaece .Add_w (_acccc .OutlineSize );};_ddba :=_acccc .RenderingMode !=TextRenderingModeFill ;if _ddba {_aaece .Add_Tr (int64 (_acccc .RenderingMode ));};_adcdb :=_acccc .CharSpacing !=0;if _adcdb {_aaece .Add_Tc (_acccc .CharSpacing );
};_cbgad :=_acccc .TextRise !=0;if _cbgad {_aaece .Add_Ts (_acccc .TextRise );};if _bcgb .VerticalAlignment !=TextVerticalAlignmentBaseline {_egea :=_fded (_bcgb .Style .Font ,_acccc .FontSize );switch _bcgb .VerticalAlignment {case TextVerticalAlignmentCenter :_beee =_caece ._fgcaf /2-_egea ._fgcaf /2;
case TextVerticalAlignmentBottom :_beee =_caece ._aebfd -_egea ._aebfd ;case TextVerticalAlignmentTop :_beee =_dgefc -_acccc .FontSize ;};if _beee !=0.0{_aaece .Translate (0,_beee );};};if _gdcac ._dffe !=TextAlignmentJustify ||_caeb {_ebdfa ,_cdgfa :=_acccc .Font .GetRuneMetrics (' ');
if !_cdgfa {return _abce ,nil ,_fab .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_dgagb =_defff [_cdddb ][_efgdd ];_gbdcc =_acccc .FontSize ;
_egfea =_ebdfa .Wx *_acccc .horizontalScale ();};_adffc :=_acccc .Font .Encoder ();var _afcc []byte ;var _fagf bool ;_edafd :=_acccc .Font ;_affg :=map[string ]_cdf .PdfObject {};if _bcgb ._gdaff !=nil {_affg ["\u0045"]=_cdf .MakeString (*_bcgb ._gdaff );
};if _bcgb ._eegdf !=nil {_affg ["\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074"]=_cdf .MakeString (*_bcgb ._eegdf );};if _bcgb ._dgeff !=nil {_affg ["\u0041\u006c\u0074"]=_cdf .MakeString (*_bcgb ._dgeff );};if _bcgb ._aefb !=nil {_affg ["\u004d\u0043\u0049\u0044"]=_cdf .MakeInteger (_bcgb ._aefb .Mcid );
};if len (_affg )> 0{if _bcgb ._aefb !=nil &&_bcgb ._aefb .StructureType !=_cd .StructureTypeUnknown {_aaece .Add_BDC (*_cdf .MakeName (string (_bcgb ._aefb .StructureType )),_affg );}else {_aaece .Add_BDC (*_cdf .MakeName (string (_cd .StructureTypeSpan )),_affg );
};};for _ ,_bead :=range _bcgb .Text {if _bead =='\u000A'{continue ;};if _bead ==' '{if len (_afcc )> 0{if _afgf {_aaece .SetStrokingColor (_acac (_acccc .OutlineColor ));};if _baddd {_aaece .Add_Tz (_acccc .HorizontalScaling );};_bcaaa :=_defff [_cdddb ][_efgdd ];
if _fagf {_bcaaa =_cdf .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abbdg ));_baeae :=_acccd ._gaa .SetFontByName (_bcaaa ,_edafd .ToPdfObject ());if _baeae !=nil {return _abce ,nil ,_baeae ;};_abbdg ++;_fagf =false ;_adffc =_acccc .Font .Encoder ();
};_aaece .SetNonStrokingColor (_acac (_acccc .Color )).Add_Tf (_bcaaa ,_acccc .FontSize ).Add_TJ ([]_cdf .PdfObject {_cdf .MakeStringFromBytes (_afcc )}...);_afcc =nil ;};if _baddd {_aaece .Add_Tz (DefaultHorizontalScaling );};_aaece .Add_Tf (_dgagb ,_gbdcc ).Add_TJ ([]_cdf .PdfObject {_cdf .MakeFloat (-_egfea )}...);
_fbdgb [_efgdd ]+=_egfea *_gbdcc ;}else {if _ ,_fddad :=_adffc .RuneToCharcode (_bead );!_fddad {if _acccc .MultiFont !=nil {_ebcbg ,_gacd :=_acccc .MultiFont .Encoder (_bead );if _gacd {if len (_afcc )!=0{_gdfc :=_cdf .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abbdg ));
_dffeg :=_acccd ._gaa .SetFontByName (_dgagb ,_edafd .ToPdfObject ());if _dffeg !=nil {return _abce ,nil ,_dffeg ;};_aaece .SetNonStrokingColor (_acac (_acccc .Color )).Add_Tf (_gdfc ,_acccc .FontSize ).Add_TJ ([]_cdf .PdfObject {_cdf .MakeStringFromBytes (_afcc )}...);
_abbdg ++;_afcc =nil ;};_adffc =_ebcbg ;_fagf =true ;_edafd =_acccc .MultiFont .CurrentFont ;};}else {_abacb =UnsupportedRuneError {Message :_a .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bead ,_bead ),Rune :_bead };
_abce ._cedd =append (_abce ._cedd ,_abacb );_fge .Log .Debug (_abacb .Error ());if _abce ._ddfg <=0{continue ;};_bead =_abce ._ddfg ;};};_ebafcc :=_adffc .Encode (string (_bead ));_afcc =append (_afcc ,_ebafcc ...);};if _acccc .MultiFont !=nil {_acccc .MultiFont .Reset ();
};};if len (_afcc )> 0{if _afgf {_aaece .SetStrokingColor (_acac (_acccc .OutlineColor ));};if _baddd {_aaece .Add_Tz (_acccc .HorizontalScaling );};_dgbag :=_defff [_cdddb ][_efgdd ];if _fagf {_dgbag =_cdf .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_abbdg ));
_dgga :=_acccd ._gaa .SetFontByName (_dgbag ,_edafd .ToPdfObject ());if _dgga !=nil {return _abce ,nil ,_dgga ;};_abbdg ++;_fagf =false ;};_aaece .SetNonStrokingColor (_acac (_acccc .Color )).Add_Tf (_dgbag ,_acccc .FontSize ).Add_TJ ([]_cdf .PdfObject {_cdf .MakeStringFromBytes (_afcc )}...);
};if len (_affg )> 0{_aaece .Add_EMC ();};_abacg :=_fbdgb [_efgdd ]/1000.0;if _acccc .Underline {_gaaef :=_acccc .UnderlineStyle .Color ;if _gaaef ==nil {_gaaef =_bcgb .Style .Color ;};_begfg ,_gabff ,_edbf :=_gaaef .ToRGB ();_cbdfe :=_fgabg -_abce .X ;
_beggb :=_ddff -_acea +_acccc .TextRise -_acccc .UnderlineStyle .Offset ;_gfbde =append (_gfbde ,&_ggb .BasicLine {X1 :_cbdfe ,Y1 :_beggb ,X2 :_cbdfe +_abacg ,Y2 :_beggb ,LineWidth :_bcgb .Style .UnderlineStyle .Thickness ,LineColor :_cd .NewPdfColorDeviceRGB (_begfg ,_gabff ,_edbf )});
};for _bbgaf ,_fafeg :=range _bcgb ._badce {var _fffef *_cdf .PdfObjectArray ;if len (_bcgb ._dgefd )==_bbgaf {switch _gdeb :=_fafeg .GetContext ().(type ){case *_cd .PdfAnnotationLink :_fffef =_cdf .MakeArray ();_gdeb .Rect =_fffef ;_agcb ,_feec :=_gdeb .Dest .(*_cdf .PdfObjectArray );
if _feec &&_agcb .Len ()==5{_aafg ,_ffaaf :=_agcb .Get (1).(*_cdf .PdfObjectName );if _ffaaf &&_aafg .String ()=="\u0058\u0059\u005a"{_abadd ,_cdcb :=_cdf .GetNumberAsFloat (_agcb .Get (3));if _cdcb ==nil {_agcb .Set (3,_cdf .MakeFloat (_abce .PageHeight -_abadd ));
};};};case *_cd .PdfAnnotationHighlight :_fffef =_cdf .MakeArray ();_gdeb .Rect =_fffef ;_fgfe :=_fgabg ;_bgfe :=_ddff +_acccc .TextRise ;_gcga :=_eecdf (&_cd .PdfRectangle {Llx :_fgfe ,Lly :_bgfe ,Urx :_fgfe +_abacg ,Ury :_bgfe +_gagec },_gdcac ._cebgb );
_gdeb .QuadPoints =_cdf .MakeArrayFromFloats ([]float64 {_gcga [0].X ,_gcga [0].Y ,_gcga [1].X ,_gcga [1].Y ,_gcga [3].X ,_gcga [3].Y ,_gcga [2].X ,_gcga [2].Y });};_bcgb ._dgefd =append (_bcgb ._dgefd ,true );};if _fffef !=nil {_eefgc :=_ggb .NewPoint (_fgabg -_abce .X ,_ddff +_acccc .TextRise -_acea ).Rotate (_gdcac ._cebgb );
_eefgc .X +=_abce .X ;_eefgc .Y +=_acea ;_ebed ,_ebcd ,_gffge ,_gddf :=_faagd (_abacg ,_gagec ,_gdcac ._cebgb );_eefgc .X +=_ebed ;_eefgc .Y +=_ebcd ;_fffef .Clear ();_fffef .Append (_cdf .MakeFloat (_eefgc .X ));_fffef .Append (_cdf .MakeFloat (_eefgc .Y ));
_fffef .Append (_cdf .MakeFloat (_eefgc .X +_gffge ));_fffef .Append (_cdf .MakeFloat (_eefgc .Y +_gddf ));};_acccd .AddAnnotation (_fafeg );};_fgabg +=_abacg ;if _bfgdg {_aaece .Add_w (1.0);};if _afgf {_aaece .Add_RG (0.0,0.0,0.0);};if _ddba {_aaece .Add_Tr (int64 (TextRenderingModeFill ));
};if _adcdb {_aaece .Add_Tc (0);};if _cbgad {_aaece .Add_Ts (0);};if _baddd {_aaece .Add_Tz (DefaultHorizontalScaling );};if _beee !=0.0{_aaece .Translate (0,-_beee );_beee =0.0;};};};if len (_efbbe )> 0{_aaece .Add_EMC ();};_aaece .Add_ET ();for _ ,_babbc :=range _gfbde {_aaece .SetStrokingColor (_babbc .LineColor ).Add_w (_babbc .LineWidth ).Add_m (_babbc .X1 ,_babbc .Y1 ).Add_l (_babbc .X2 ,_babbc .Y2 ).Add_s ();
};_aaece .Add_Q ();_bdab :=_aaece .Operations ();_bdab .WrapIfNeeded ();_acccd .addWrappedContents (_bdab );if _ggbff {_dggg :=_ccaf ;_abce .Y +=_dggg ;_abce .Height -=_dggg ;if _abce .Inline {_abce .X +=_gdcac .Width ()+_gdcac ._acgdg .Right ;};};return _abce ,_adfdg ,nil ;
};func (_ffba *List )markerWidth ()float64 {var _ffeb float64 ;for _ ,_eeef :=range _ffba ._gecb {_cegf :=_dgdda (_ffba ._cedde );_cegf .SetEnableWrap (false );_cegf .SetTextAlignment (TextAlignmentRight );_cegf .Append (_eeef ._ceaga .Text ).Style =_eeef ._ceaga .Style ;
_cbgaf :=_cegf .getTextWidth ()/1000.0;if _ffeb < _cbgaf {_ffeb =_cbgaf ;};};return _ffeb ;};

// NewCellProps returns the default properties of an invoice cell.
func (_dabe *Invoice )NewCellProps ()InvoiceCellProps {_cbfa :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_dabe ._dfeb ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_cbfa ,BorderColor :_cbfa ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};func _eecdf (_cdcdg *_cd .PdfRectangle ,_edacba float64 )[4]_ggb .Point {_dadd :=_edacba *_bd .Pi /180.0;_edcfa :=_cdcdg .Width ();_egbcgg :=_cdcdg .Height ();_efaf :=_bd .Sin (_dadd );_fdbaa :=_bd .Cos (_dadd );_dabce :=[4]_ggb .Point {{X :_fag .RoundFloat (_cdcdg .Llx ,3),Y :_fag .RoundFloat (_cdcdg .Lly ,3)},{X :_fag .RoundFloat (_cdcdg .Llx +_edcfa *_fdbaa ,3),Y :_fag .RoundFloat (_cdcdg .Lly +_edcfa *_efaf ,3)},{X :_fag .RoundFloat (_cdcdg .Llx +_edcfa *_fdbaa -_egbcgg *_efaf ,3),Y :_fag .RoundFloat (_cdcdg .Lly +_edcfa *_efaf +_egbcgg *_fdbaa ,3)},{X :_fag .RoundFloat (_cdcdg .Llx -_egbcgg *_efaf ,3),Y :_fag .RoundFloat (_cdcdg .Lly +_egbcgg *_fdbaa ,3)}};
return _dabce ;};func _fbab (_feece map[string ]interface{},_cgdfed ...interface{})(map[string ]interface{},error ){_dbfcf :=len (_cgdfed );if _dbfcf %2!=0{return nil ,_cdf .ErrRangeError ;};for _fadd :=0;_fadd < _dbfcf ;_fadd +=2{_ceecc ,_acadag :=_cgdfed [_fadd ].(string );
if !_acadag {return nil ,_cdf .ErrTypeError ;};_feece [_ceecc ]=_cgdfed [_fadd +1];};return _feece ,nil ;};

// Logo returns the logo of the invoice.
func (_egcbc *Invoice )Logo ()*Image {return _egcbc ._eddeg };func (_fedag *Invoice )newCell (_eggg string ,_adfcf InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_adfcf ,_eggg };};

// SetLineWidth sets the line width.
func (_ecade *Line )SetLineWidth (width float64 ){_ecade ._ebee =width };

// SetRowPosition sets cell row position.
func (_acagf *TableCell )SetRowPosition (row int ){_acagf ._cfdga =row };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_fdcbaf *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeedg :=_fdcbaf ;if _fdcbaf ._gefgf {_aeedg =_fdcbaf .clone ();};return _abddf (_aeedg ,ctx );};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_dbgce *GridCell )SetVerticalAlignment (valign CellVerticalAlignment ){_dbgce ._efdb =valign };

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_bdgfb *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _bdgfb ._bacec ,_bdgfb ._cbcf ,_bdgfb ._bfdg ,_bdgfb ._ebgdf ;};

// SetSideBorderColor sets the cell's side border color.
func (_bgeg *GridCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_bgeg ._eeada =col ;_bgeg ._feaeg =col ;_bgeg ._bbcda =col ;_bgeg ._cfbg =col ;case CellBorderSideTop :_bgeg ._eeada =col ;case CellBorderSideBottom :_bgeg ._feaeg =col ;
case CellBorderSideLeft :_bgeg ._bbcda =col ;case CellBorderSideRight :_bgeg ._cfbg =col ;};};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_dgbd Drawable )(Drawable ,error );};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_efgefc *Table )MultiColCell (colspan int )*TableCell {return _efgefc .MultiCell (1,colspan )};

// SetMaxLines sets the maximum number of lines to be drawn.
func (_bgecf *StyledParagraph )SetMaxLines (maxLines int ){_bgecf ._befa =maxLines };var _eaec =map[GridRowSection ]_cd .StructureType {GridRowSectionBody :_cd .StructureTypeTableBody ,GridRowSectionHeader :_cd .StructureTypeTableHead ,GridRowSectionFooter :_cd .StructureTypeTableFooter ,GridRowSectionUnknown :_cd .StructureTypeUnknown };
func (_gagea *Rectangle )applyFitMode (_fccg float64 ){_fccg -=_gagea ._fcfgf .Left +_gagea ._fcfgf .Right +_gagea ._effb ;switch _gagea ._cdgbe {case FitModeFillWidth :_gagea .ScaleToWidth (_fccg );};};

// SetSubtotal sets the subtotal of the invoice.
func (_ebfe *Invoice )SetSubtotal (value string ){_ebfe ._fdfe [1].Value =value };

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_cceg *Chart )SetPos (x ,y float64 ){_cceg ._cgde =PositionAbsolute ;_cceg ._cceb =x ;_cceg ._cfa =y ;};

// Width returns the current page width.
func (_agba *Creator )Width ()float64 {return _agba ._ebgd };

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_caedg *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _caedg ._adac .Left ,_caedg ._adac .Right ,_caedg ._adac .Top ,_caedg ._adac .Bottom ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetIndent sets the cell's left indent.
func (_cgfcd *TableCell )SetIndent (indent float64 ){_cgfcd ._bdgg =indent };func (_fbdbd *TextChunk )clone ()*TextChunk {_dfge :=*_fbdbd ;_dfge ._badce =_faecg (_fbdbd ._badce );return &_dfge ;};

// Lazy gets the lazy mode for the image.
func (_fgaf *Image )Lazy ()bool {return _fgaf ._dbgf };

// SetMargins sets the Paragraph's margins.
func (_bfab *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_bfab ._acgdg .Left =left ;_bfab ._acgdg .Right =right ;_bfab ._acgdg .Top =top ;_bfab ._acgdg .Bottom =bottom ;};func (_cgc *pageTransformations )applyFlip (_gdg *_cd .PdfPage )error {_gcg ,_egd :=_cgc ._cgbf ,_cgc ._ccac ;
if !_gcg &&!_egd {return nil ;};if _gdg ==nil {return _fab .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_aeed ,_afff :=_gdg .GetMediaBox ();if _afff !=nil {return _afff ;};_eabb ,_aga :=_aeed .Width (),_aeed .Height ();
_afb ,_afff :=_gdg .GetRotate ();if _afff !=nil {_fge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_afff .Error ());
};if _cebb :=_afb %360!=0&&_afb %90==0;_cebb {if _adad :=(360+_afb %360)%360;_adad ==90||_adad ==270{_gcg ,_egd =_egd ,_gcg ;};};_aeca ,_fccd :=1.0,0.0;if _gcg {_aeca ,_fccd =-1.0,-_eabb ;};_gacb ,_ddga :=1.0,0.0;if _egd {_gacb ,_ddga =-1.0,-_aga ;};_dee :=_fgc .NewContentCreator ().Scale (_aeca ,_gacb ).Translate (_fccd ,_ddga );
_bagb ,_afff :=_cdf .MakeStream (_dee .Bytes (),_cdf .NewFlateEncoder ());if _afff !=nil {return _afff ;};_dfea :=_cdf .MakeArray (_bagb );_dfea .Append (_gdg .GetContentStreamObjs ()...);_gdg .Contents =_dfea ;return nil ;};func (_gageab *templateProcessor )nodeLogError (_gefdf *templateNode ,_eefacg string ,_cffg ...interface{}){_fge .Log .Error (_gageab .getNodeErrorLocation (_gefdf ,_eefacg ,_cffg ...));
};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_fabfde *RadialShading )ToPdfShadingPattern ()*_cd .PdfShadingPatternType3 {_bccac ,_ffec ,_acgb :=_fabfde ._ggbe ._dcfb .ToRGB ();_bddc :=_fabfde .shadingModel ();_bddc .Background =_cdf .MakeArrayFromFloats ([]float64 {_bccac ,_ffec ,_acgb });_bgegc :=_cd .NewPdfShadingPatternType3 ();
_bgegc .Shading =_bddc ;return _bgegc ;};func (_bcdg *Image )rotatedSize ()(float64 ,float64 ){_fdbabf :=_bcdg ._dbdfea ;_dgdd :=_bcdg ._eafg ;_dcca :=_bcdg ._bgbef ;if _dcca ==0{return _fdbabf ,_dgdd ;};_bfff :=_ggb .Path {Points :[]_ggb .Point {_ggb .NewPoint (0,0).Rotate (_dcca ),_ggb .NewPoint (_fdbabf ,0).Rotate (_dcca ),_ggb .NewPoint (0,_dgdd ).Rotate (_dcca ),_ggb .NewPoint (_fdbabf ,_dgdd ).Rotate (_dcca )}}.GetBoundingBox ();
return _bfff .Width ,_bfff .Height ;};

// GetRowHeight returns the height of the specified row.
func (_abee *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_abee ._fgege ){return 0,_fab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _abee ._fgege [row -1],nil ;
};

// SetRowHeight sets the height for a specified row.
func (_fefdf *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_fefdf ._fgege ){return _fab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fefdf ._fgege [row -1]=h ;return nil ;
};func (_cgcf *Table )wrapContent (_fdgc DrawContext )error {if _cgcf ._gefgf {return nil ;};_cgcf .sortCells ();_cefad :=func (_gfde *TableCell ,_cbdgf int ,_cgabcb int ,_gdbgb int )(_beadb int ){if _gdbgb < 1{return -1;};_dedbea :=0;for _baefa :=_cgabcb +1;
_baefa < len (_cgcf ._dfcec )-1;_baefa ++{_fgefc :=_cgcf ._dfcec [_baefa ];if _fgefc ._cfdga ==_gdbgb &&_dedbea !=_cgabcb {_dedbea =_baefa ;if (_fgefc ._ebgdb < _gfde ._ebgdb &&_cgcf ._ccabb > _fgefc ._ebgdb )||_gfde ._ebgdb < _cgcf ._ccabb {continue ;
};break ;};};_cafda :=float64 (0.0);for _bbfbe :=0;_bbfbe < _gfde ._aecg ;_bbfbe ++{_cafda +=_cgcf ._fgege [_gfde ._cfdga +_bbfbe -1];};_dfdc :=_gfde .width (_cgcf ._fefea ,_fdgc .Width );var (_eaddga VectorDrawable ;_acgbb =false ;);switch _gegcf :=_gfde ._effe .(type ){case *StyledParagraph :_dbegf :=_fdgc ;
_dbegf .Height =_bd .Floor (_cafda -_gegcf ._acgdg .Top -_gegcf ._acgdg .Bottom -0.5*_gegcf .getTextHeight ());_dbegf .Width =_dfdc ;_dcadf ,_bggca ,_gefgff :=_gegcf .split (_dbegf );if _gefgff !=nil {_fge .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_gefgff .Error ());
};if _dcadf !=nil &&_bggca !=nil {_cgcf ._dfcec [_cgabcb ]._effe =_dcadf ;_eaddga =_bggca ;_acgbb =true ;};};_cgcf ._dfcec [_cgabcb ]._aecg =_gfde ._aecg ;_fdgc .Height =_fdgc .PageHeight -_fdgc .Margins .Top -_fdgc .Margins .Bottom ;_aeec :=_gfde .cloneProps (nil );
if _acgbb {_aeec ._effe =_eaddga ;};_aeec ._aecg =_cbdgf ;_aeec ._cfdga =_gdbgb +1;_aeec ._ebgdb =_gfde ._ebgdb ;if _aeec ._cfdga +_aeec ._aecg -1> _cgcf ._ecga {for _bgddd :=_cgcf ._ecga ;_bgddd < _aeec ._cfdga +_aeec ._aecg -1;_bgddd ++{_cgcf ._ecga ++;
_cgcf ._fgege =append (_cgcf ._fgege ,_cgcf ._eecff );};};_cgcf ._dfcec =append (_cgcf ._dfcec [:_dedbea +1],append ([]*TableCell {_aeec },_cgcf ._dfcec [_dedbea +1:]...)...);return _dedbea +1;};_ffca :=func (_bgffc *TableCell ,_eaeab int ,_gfefa int ,_dbdcc float64 )(_gfcg int ){_cdfe :=_bgffc .width (_cgcf ._fefea ,_fdgc .Width );
_bdaea :=_dbdcc ;_ecaa :=1;_aabcb :=_fdgc .Height ;if _aabcb > 0{for _bdaea > _aabcb {_bdaea -=_fdgc .Height ;_aabcb =_fdgc .PageHeight -_fdgc .Margins .Top -_fdgc .Margins .Bottom ;_ecaa ++;};};var (_edbb VectorDrawable ;_abaf =false ;);switch _bgfaf :=_bgffc ._effe .(type ){case *StyledParagraph :_afgfg :=_fdgc ;
_afgfg .Height =_bd .Floor (_fdgc .Height -_bgfaf ._acgdg .Top -_bgfaf ._acgdg .Bottom -0.5*_bgfaf .getTextHeight ());_afgfg .Width =_cdfe ;_fadee ,_dfgbb ,_gbfcb :=_bgfaf .split (_afgfg );if _gbfcb !=nil {_fge .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_gbfcb .Error ());
};if _fadee !=nil &&_dfgbb !=nil {_cgcf ._dfcec [_eaeab ]._effe =_fadee ;_edbb =_dfgbb ;_abaf =true ;};};if _ecaa < 2{return -1;};if _cgcf ._dfcec [_eaeab ]._cfdga +_ecaa -1> _cgcf ._ecga {for _agcc :=0;_agcc < _ecaa ;_agcc ++{_cgcf ._ecga ++;_cgcf ._fgege =append (_cgcf ._fgege ,_cgcf ._eecff );
};};_eceee :=_dbdcc /float64 (_ecaa );for _cgfd :=0;_cgfd < _ecaa ;_cgfd ++{_cgcf ._fgege [_gfefa +_cgfd -1]=_eceee ;};_fdgc .Height =_fdgc .PageHeight -_fdgc .Margins .Top -_fdgc .Margins .Bottom ;_adcg :=_bgffc .cloneProps (nil );if _abaf {_adcg ._effe =_edbb ;
};_adcg ._aecg =1;_adcg ._cfdga =_gfefa +_ecaa -1;_adcg ._ebgdb =_bgffc ._ebgdb ;_cgcf ._dfcec =append (_cgcf ._dfcec ,_adcg );return len (_cgcf ._dfcec );};_fefdg :=1;_bbbf :=-1;for _edcba :=0;_edcba < len (_cgcf ._dfcec );_edcba ++{_gbbc :=_cgcf ._dfcec [_edcba ];
if _bbbf ==_edcba {_fefdg =_gbbc ._cfdga ;};if _gbbc ._aecg < 2{if _ddfge :=_cgcf ._fgege [_gbbc ._cfdga -1];_ddfge > _fdgc .Height {_bbbf =_ffca (_gbbc ,_edcba ,_gbbc ._cfdga ,_ddfge );continue ;};continue ;};_aeffg :=float64 (0);for _cfcgd :=0;_cfcgd < _gbbc ._aecg ;
_cfcgd ++{_aeffg +=_cgcf ._fgege [_gbbc ._cfdga +_cfcgd -1];};_cfbde :=float64 (0);for _dbccb :=_fefdg -1;_dbccb < _gbbc ._cfdga -1;_dbccb ++{_cfbde +=_cgcf ._fgege [_dbccb ];};if _aeffg <=(_fdgc .Height -_cfbde ){continue ;};_bdagc :=float64 (0.0);_bdfge :=_gbbc ._aecg ;
_cfgbe :=-1;_bfdd :=1;for _baceab :=1;_baceab <=_gbbc ._aecg ;_baceab ++{if (_bdagc +_cgcf ._fgege [_gbbc ._cfdga +_baceab -2])> (_fdgc .Height -_cfbde ){_bfdd --;break ;};_cfgbe =_gbbc ._cfdga +_baceab -1;_bdfge =_gbbc ._aecg -_baceab ;_bdagc +=_cgcf ._fgege [_gbbc ._cfdga +_baceab -2];
_bfdd ++;};if _gbbc ._aecg ==_bdfge {_fdgc .Height =_fdgc .PageHeight -_fdgc .Margins .Top -_fdgc .Margins .Bottom ;_fefdg =_gbbc ._cfdga ;_edcba --;continue ;};if _bdfge > 0&&_gbbc ._aecg > _bfdd {_gbbc ._aecg =_bfdd ;_bbbf =_cefad (_gbbc ,_bdfge ,_edcba ,_cfgbe );
if _edcba +1==_bbbf {_edcba --;};};_fefdg =_gbbc ._cfdga ;};_cgcf .sortCells ();return nil ;};func (_cbcea *commands )isCommand (_ccbgg string )bool {for _ ,_eacg :=range _cbcea ._bbcdd {if _gg .ToLower (_ccbgg )==_eacg {return true ;};};return false ;
};func _ecg ()*Division {return &Division {_agaad :true ,taggedDrawable :taggedDrawable {_efgb :_cd .StructureTypeDivision }};};

// SetBorderWidth sets the border width of the ellipse.
func (_fgde *Ellipse )SetBorderWidth (bw float64 ){_fgde ._dffd =bw };func (_gbfa *GraphicSVGElement )processDefs (){_gbfa ._aeea =make (map[string ]*LinearShading );_gbfa ._edbee =make (map[string ]*RadialShading );for _ ,_bdced :=range _gbfa .Children {if _bdced .Name =="\u0064\u0065\u0066\u0073"{for _ ,_gfeg :=range _bdced .Children {if _gfeg .Name =="\u006c\u0069\u006e\u0065\u0061\u0072\u0047\u0072\u0061d\u0069\u0065\u006e\u0074"{_caffd :=_gfeg .Attributes ["\u0069\u0064"];
_dfaa :=_gfeg .parseColorPoints ();_cgbe :=_cgega (_dfaa );_gfaa :=_gfeg .getGradientAngle ();_cgbe .SetAngle (-_gfaa );_cgbe .SetExtends (true ,true );_cgbe .SetBoundingBox (0,0,_gbfa .Width ,_gbfa .Height );_gbfa ._aeea [_caffd ]=_cgbe ;}else if _gfeg .Name =="\u0072\u0061\u0064\u0069\u0061\u006c\u0047\u0072\u0061d\u0069\u0065\u006e\u0074"{_dbgc :=_gfeg .Attributes ["\u0069\u0064"];
_abc :=_gfeg .parseColorPoints ();_ggfd :=_bbaf (_gbfa ._dgaa ,_gbfa .ViewBox .H ,0,_bd .Min (_gbfa .Width ,_gbfa .Height )/2,_abc );_ggfd .SetExtends (true ,true );_ggfd .SetBoundingBox (0,0,_gbfa .Width ,_gbfa .Height );_gbfa ._edbee [_dbgc ]=_ggfd ;
};};};};};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_fdea *Image )ScaleToWidth (w float64 ){_gccgb :=_fdea ._eafg /_fdea ._dbdfea ;_fdea ._dbdfea =w ;_fdea ._eafg =w *_gccgb ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_dfgf *Creator )MoveTo (x ,y float64 ){_dfgf ._fga .X =x ;_dfgf ._fga .Y =y };type templateProcessor struct{creator *Creator ;_facb []byte ;_ccdf *TemplateOptions ;_bgdf componentRenderer ;_cgcdc string ;};func _gecca (_cbdde int )*Table {_bdgca :=&Table {_ccabb :_cbdde ,_eecff :10.0,_fefea :[]float64 {},_fgege :[]float64 {},_dfcec :[]*TableCell {},_fgff :make ([]int ,_cbdde ),_ddcg :true };
_bdgca ._efgb =_cd .StructureTypeTable ;_bdgca .resetColumnWidths ();return _bdgca ;};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_cfgd *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cfgd ._cded .Left ,_cfgd ._cded .Right ,_cfgd ._cded .Top ,_cfgd ._cded .Bottom ;};func (_aeabfg *templateProcessor )parseColorAttr (_geef ,_aaega string )Color {_fge .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_geef ,_aaega );
_aaega =_gg .TrimSpace (_aaega );if _gg .HasPrefix (_aaega ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_gg .HasSuffix (_aaega ,"\u0029")&&len (_aaega )> 17{return _aeabfg .parseLinearGradientAttr (_aeabfg .creator ,_aaega );
};if _gg .HasPrefix (_aaega ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_gg .HasSuffix (_aaega ,"\u0029")&&len (_aaega )> 17{return _aeabfg .parseRadialGradientAttr (_aeabfg .creator ,_aaega );};if _bdad :=_aeabfg .parseColor (_aaega );
_bdad !=nil {return _bdad ;};return ColorBlack ;};

// Link returns link information for this line.
func (_fceg *TOCLine )Link ()(_gcfgc int64 ,_fefff ,_debgg float64 ){return _fceg ._abcc ,_fceg ._fbbd ,_fceg ._bbefa ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_bbaa *Table )SetMargins (left ,right ,top ,bottom float64 ){_bbaa ._ffegb .Left =left ;_bbaa ._ffegb .Right =right ;_bbaa ._ffegb .Top =top ;_bbaa ._ffegb .Bottom =bottom ;};

// SetAngle sets the rotation angle of the text.
func (_bdfef *StyledParagraph )SetAngle (angle float64 ){_bdfef ._cebgb =angle };func (_ccgd *listItem )ctxHeight (_ddde float64 )float64 {var _ecdbf float64 ;switch _gdeab :=_ccgd ._gdcgce .(type ){case *Paragraph :if _gdeab ._fabc {_gdeab .SetWidth (_ddde -_gdeab ._dcfd .Horizontal ());
};_ecdbf =_gdeab .Height ()+_gdeab ._dcfd .Vertical ();_ecdbf +=0.5*_gdeab ._dgdde *_gdeab ._fbdcb ;case *StyledParagraph :if _gdeab ._bccfb {_gdeab .SetWidth (_ddde -_gdeab ._acgdg .Horizontal ());};_ecdbf =_gdeab .Height ()+_gdeab ._acgdg .Vertical ();
_ecdbf +=0.5*_gdeab .getTextHeight ();case *List :_ccfa :=_ddde -_ccgd ._ceaga .Width ()-_gdeab ._bcefc .Horizontal ()-_gdeab ._bdge ;_ecdbf =_gdeab .ctxHeight (_ccfa )+_gdeab ._bcefc .Vertical ();case *Image :_ecdbf =_gdeab .Height ()+_gdeab ._begc .Vertical ();
case *Division :_egaaf :=_ddde -_ccgd ._ceaga .Width ()-_gdeab ._gadc .Horizontal ();_ecdbf =_gdeab .ctxHeight (_egaaf )+_gdeab ._gadc .Vertical ();case *Table :_gbdb :=_ddde -_ccgd ._ceaga .Width ()-_gdeab ._ffegb .Horizontal ();_gdeab .updateRowHeights (_gbdb );
_ecdbf =_gdeab .Height ()+_gdeab ._ffegb .Vertical ();default:_ecdbf =_ccgd ._gdcgce .Height ();};return _ecdbf ;};

// AppendColumn appends a column to the line items table.
func (_fgecd *Invoice )AppendColumn (description string )*InvoiceCell {_bbcag :=_fgecd .NewColumn (description );_fgecd ._bdfec =append (_fgecd ._bdfec ,_bbcag );return _bbcag ;};func (_dcedg *StyledParagraph )wrapText ()error {return _dcedg .wrapChunks (true )};


// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_bccdaf *TOC )SetLinePageStyle (style TextStyle ){_bccdaf ._accg =style };func (_bcacf *GraphicSVGElement )drawLine (_cadef *_fgc .ContentCreator ,_egcbb *_cd .PdfPageResources ){_cadef .Add_q ();_bcacf .Style .toContentStream (_cadef ,_egcbb ,_bcacf );
_afgff ,_gcabd :=_gfgbeb (_bcacf .Attributes ["\u0078\u0031"],64);if _gcabd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcabd .Error ());
};_ggbg ,_gcabd :=_gfgbeb (_bcacf .Attributes ["\u0079\u0031"],64);if _gcabd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcabd .Error ());
};_fbef ,_gcabd :=_gfgbeb (_bcacf .Attributes ["\u0078\u0032"],64);if _gcabd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcabd .Error ());
};_efba ,_gcabd :=_gfgbeb (_bcacf .Attributes ["\u0079\u0032"],64);if _gcabd !=nil {_fge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcabd .Error ());
};_cadef .Add_m (_afgff *_bcacf ._fgdg ,_ggbg *_bcacf ._fgdg );_cadef .Add_l (_fbef *_bcacf ._fgdg ,_efba *_bcacf ._fgdg );_bcacf .Style .fillStroke (_cadef );_cadef .Add_h ();_cadef .Add_Q ();};type pageTransformations struct{_aafa *_cf .Matrix ;_cgbf bool ;
_ccac bool ;};func _gabfd (_fgccb ,_efdbec ,_egbcfa TextChunk ,_degfc uint ,_gegd TextStyle )*TOCLine {_caga :=_dgdda (_gegd );_caga .SetEnableWrap (true );_caga .SetTextAlignment (TextAlignmentLeft );_caga .SetMargins (0,0,2,2);_dcdcd :=&TOCLine {_gbbaf :_caga ,Number :_fgccb ,Title :_efdbec ,Page :_egbcfa ,Separator :TextChunk {Text :"\u002e",Style :_gegd },_ecece :0,_feacc :_degfc ,_fdgca :10,_dfgbe :PositionRelative };
_caga ._acgdg .Left =_dcdcd ._ecece +float64 (_dcdcd ._feacc -1)*_dcdcd ._fdgca ;_caga ._beab =_dcdcd .prepareParagraph ;return _dcdcd ;};func (_acabg *templateProcessor )parseTextOverflowAttr (_bdcaa ,_afbdc string )TextOverflow {_fge .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_bdcaa ,_afbdc );
_fdfeg :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_afbdc ];return _fdfeg ;};

// Height returns the height of the list.
func (_ccfb *List )Height ()float64 {var _aacff float64 ;for _ ,_begg :=range _ccfb ._gecb {_aacff +=_begg .ctxHeight (_ccfb .Width ());};return _aacff ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_bcda *Table )SetPos (x ,y float64 ){_bcda ._acbec =PositionAbsolute ;_bcda ._cgdfe =x ;_bcda ._aabg =y ;};func (_bdcdgd *templateProcessor )parseChapterHeading (_fgecc *templateNode )(interface{},error ){if _fgecc ._fbddd ==nil {_bdcdgd .nodeLogError (_fgecc ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_egfg ;};_bdfefc ,_deadg :=_fgecc ._fbddd ._bcacc .(*Chapter );if !_deadg {_bdcdgd .nodeLogError (_fgecc ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_fgecc ._fbddd ._bcacc );
return nil ,_egfg ;};_aebbc :=_bdfefc .GetHeading ();if _ ,_dcda :=_bdcdgd .parseParagraph (_fgecc ,_aebbc );_dcda !=nil {return nil ,_dcda ;};return _aebbc ,nil ;};func _egce (_fggfe ,_aeaeg string )*_cd .PdfAnnotation {_ededf :=_cd .NewPdfAnnotationLink ();
_gbgb :=_cd .NewBorderStyle ();_gbgb .SetBorderWidth (0);_ededf .BS =_gbgb .ToPdfObject ();_gccgca :=_cd .NewPdfActionURI ();_gccgca .URI =_cdf .MakeString (_fggfe );_ededf .SetAction (_gccgca .PdfAction );if _aeaeg !=""{_ededf .Contents =_cdf .MakeString (_aeaeg );
};return _ededf .PdfAnnotation ;};