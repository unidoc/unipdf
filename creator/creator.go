//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_b "bytes";_a "errors";_fg "fmt";_cf "github.com/unidoc/unipdf/v3/common";_ee "github.com/unidoc/unipdf/v3/contentstream";_ba "github.com/unidoc/unipdf/v3/contentstream/draw";_db "github.com/unidoc/unipdf/v3/core";_ag "github.com/unidoc/unipdf/v3/model";_d "image";_c "io";_bb "math";_e "os";_f "sort";_ea "strconv";_ed "strings";_ef "unicode";);

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_cfab []VectorDrawable ;_ggef positioning ;_dcg margins ;_ggag bool ;};

// SetStyleBottom sets border style for bottom side.
func (_ffd *border )SetStyleBottom (style CellBorderStyle ){_ffd ._bfcf =style };

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_befaf *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbgb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aacbd :=_ba .Rectangle {Opacity :1.0,X :_befaf ._dfedb ,Y :ctx .PageHeight -_befaf ._bdc -_befaf ._abaf ,Height :_befaf ._abaf ,Width :_befaf ._fffb };if _befaf ._dgfc !=nil {_aacbd .FillEnabled =true ;_aacbd .FillColor =_befaf ._dgfc ;};if _befaf ._bbdd !=nil &&_befaf ._afcd > 0{_aacbd .BorderEnabled =true ;_aacbd .BorderColor =_befaf ._bbdd ;_aacbd .BorderWidth =_befaf ._afcd ;};_ecdc ,_ ,_eefc :=_aacbd .Draw ("");if _eefc !=nil {return nil ,ctx ,_eefc ;};_eefc =_dbgb .addContentsByString (string (_ecdc ));if _eefc !=nil {return nil ,ctx ,_eefc ;};return []*Block {_dbgb },ctx ,nil ;};

// TOC returns the table of contents component of the creator.
func (_bdef *Creator )TOC ()*TOC {return _bdef ._bgg };

// NewInvoice returns an instance of an empty invoice.
func (_fgadg *Creator )NewInvoice ()*Invoice {_eefef :=_fgadg .NewTextStyle ();_eefef .Font =_fgadg ._fcca ;return _ebcgg (_fgadg .NewTextStyle (),_eefef );};

// SetIndent sets the left offset of the list when nested into another list.
func (_bgaa *List )SetIndent (indent float64 ){_bgaa ._deabg =indent ;_bgaa ._gbca =false };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_bcf *Block )SetPos (x ,y float64 ){_bcf ._bc =_aabc ;_bcf ._ga =x ;_bcf ._ad =y };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gafe *TOCLine )SetStyle (style TextStyle ){_gafe .Number .Style =style ;_gafe .Title .Style =style ;_gafe .Separator .Style =style ;_gafe .Page .Style =style ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_cbcb *Chapter )SetIncludeInTOC (includeInTOC bool ){_cbcb ._ecdg =includeInTOC };

// Title returns the title of the invoice.
func (_bgdc *Invoice )Title ()string {return _bgdc ._dfed };

// GetMargins returns the left, right, top, bottom Margins.
func (_afge *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _afge ._gdccd ._eeaf ,_afge ._gdccd ._edc ,_afge ._gdccd ._gdd ,_afge ._gdccd ._fged ;};func (_aaabe *Paragraph )getTextWidth ()float64 {_bebef :=0.0;for _ ,_beae :=range _aaabe ._agae {if _beae =='\u000A'{continue ;};_gba ,_aegd :=_aaabe ._gbgeb .GetRuneMetrics (_beae );if !_aegd {_cf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_beae ,_beae );return -1;};_bebef +=_aaabe ._gcbgg *_gba .Wx ;};return _bebef ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_ebfb *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _ebfb ._ebg ==nil {if _aegc :=_ebfb .makeXObject ();_aegc !=nil {return nil ,ctx ,_aegc ;};};var _bfffe []*Block ;_eeed :=ctx ;_fgec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ebfb ._cag .isRelative (){if _ebfb ._efdd > ctx .Height {_bfffe =append (_bfffe ,_fgec );_fgec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ffcb :=ctx ;_ffcb .Y =ctx .Margins ._gdd ;_ffcb .X =ctx .Margins ._eeaf +_ebfb ._cbe ._eeaf ;_ffcb .Height =ctx .PageHeight -ctx .Margins ._gdd -ctx .Margins ._fged -_ebfb ._cbe ._fged ;_ffcb .Width =ctx .PageWidth -ctx .Margins ._eeaf -ctx .Margins ._edc -_ebfb ._cbe ._eeaf -_ebfb ._cbe ._edc ;ctx =_ffcb ;}else {ctx .Y +=_ebfb ._cbe ._gdd ;ctx .Height -=_ebfb ._cbe ._gdd +_ebfb ._cbe ._fged ;ctx .X +=_ebfb ._cbe ._eeaf ;ctx .Width -=_ebfb ._cbe ._eeaf +_ebfb ._cbe ._edc ;};}else {ctx .X =_ebfb ._deg ;ctx .Y =_ebfb ._fbed ;};ctx ,_aggg :=_aca (_fgec ,_ebfb ,ctx );if _aggg !=nil {return nil ,ctx ,_aggg ;};_bfffe =append (_bfffe ,_fgec );if _ebfb ._cag .isAbsolute (){ctx =_eeed ;}else {ctx .Y +=_ebfb ._cbe ._fged ;ctx .Height -=_ebfb ._cbe ._fged ;};return _bfffe ,ctx ,nil ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_bba *Chapter )NewSubchapter (title string )*Chapter {_egba :=_cdge (_bba ._ceb ._gbgeb );_egba .FontSize =14;_bba ._bgff ++;_dfbf :=_geg (_bba ,_bba ._gga ,_bba ._fcgf ,title ,_bba ._bgff ,_egba );_bba .Add (_dfbf );return _dfbf ;};

// SetBorderColor sets the border color for the path.
func (_gegd *FilledCurve )SetBorderColor (color Color ){_gegd ._bbceb =_ag .NewPdfColorDeviceRGB (color .ToRGB ());};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_abdc *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _abdc ._ccf ,_abdc ._ceeg ,_abdc ._fega ,_abdc ._agge ;};

// Context returns the current drawing context.
func (_bgfg *Creator )Context ()DrawContext {return _bgfg ._dbf };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_bfcg *Invoice )AddressHeadingStyle ()TextStyle {return _bfcg ._ccgf };func (_bbcd *Block )addContentsByString (_bfc string )error {_geb :=_ee .NewContentStreamParser (_bfc );_dc ,_aac :=_geb .Parse ();if _aac !=nil {return _aac ;};_bbcd ._ca .WrapIfNeeded ();_dc .WrapIfNeeded ();*_bbcd ._ca =append (*_bbcd ._ca ,*_dc ...);return nil ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ebf :=&Block {};_ebf ._ca =&_ee .ContentStreamOperations {};_ebf ._af =_ag .NewPdfPageResources ();_ebf ._dbc =width ;_ebf ._fd =height ;return _ebf ;};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_dgfd *Division )Width ()float64 {return 0};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_bfafc *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbefb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_efae :=_ba .Line {LineWidth :_bfafc ._aedee ,Opacity :1.0,LineColor :_bfafc ._cdfc ,LineEndingStyle1 :_ba .LineEndingStyleNone ,LineEndingStyle2 :_ba .LineEndingStyleNone ,X1 :_bfafc ._ccf ,Y1 :ctx .PageHeight -_bfafc ._ceeg ,X2 :_bfafc ._fega ,Y2 :ctx .PageHeight -_bfafc ._agge };_ffgd ,_ ,_eebc :=_efae .Draw ("");if _eebc !=nil {return nil ,ctx ,_eebc ;};_eebc =_gbefb .addContentsByString (string (_ffgd ));if _eebc !=nil {return nil ,ctx ,_eebc ;};return []*Block {_gbefb },ctx ,nil ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;func _aca (_cbfae *Block ,_dgdgdd *Image ,_gdcc DrawContext )(DrawContext ,error ){_agbg :=_gdcc ;_cbef :=1;_fgfgf :=_db .PdfObjectName (_fg .Sprintf ("\u0049\u006d\u0067%\u0064",_cbef ));for _cbfae ._af .HasXObjectByName (_fgfgf ){_cbef ++;_fgfgf =_db .PdfObjectName (_fg .Sprintf ("\u0049\u006d\u0067%\u0064",_cbef ));};_fffa :=_cbfae ._af .SetXObjectImageByName (_fgfgf ,_dgdgdd ._ebg );if _fffa !=nil {return _gdcc ,_fffa ;};_cedb :=0;_faga :=_db .PdfObjectName (_fg .Sprintf ("\u0047\u0053\u0025\u0064",_cedb ));for _cbfae ._af .HasExtGState (_faga ){_cedb ++;_faga =_db .PdfObjectName (_fg .Sprintf ("\u0047\u0053\u0025\u0064",_cedb ));};_dcda :=_db .MakeDict ();_dcda .Set ("\u0042\u004d",_db .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _dgdgdd ._eddg < 1.0{_dcda .Set ("\u0043\u0041",_db .MakeFloat (_dgdgdd ._eddg ));_dcda .Set ("\u0063\u0061",_db .MakeFloat (_dgdgdd ._eddg ));};_fffa =_cbfae ._af .AddExtGState (_faga ,_db .MakeIndirectObject (_dcda ));if _fffa !=nil {return _gdcc ,_fffa ;};_cbad :=_dgdgdd .Width ();_dfd :=_dgdgdd .Height ();_ ,_beba :=_dgdgdd .rotatedSize ();_dgeg :=_gdcc .X ;_gaeab :=_gdcc .PageHeight -_gdcc .Y -_dfd ;if _dgdgdd ._cag .isRelative (){_gaeab -=(_beba -_dfd )/2;switch _dgdgdd ._edca {case HorizontalAlignmentCenter :_dgeg +=(_gdcc .Width -_cbad )/2;case HorizontalAlignmentRight :_dgeg =_gdcc .PageWidth -_gdcc .Margins ._edc -_dgdgdd ._cbe ._edc -_cbad ;};};_adbf :=_dgdgdd ._edfe ;_ebfbf :=_ee .NewContentCreator ();_ebfbf .Add_gs (_faga );_ebfbf .Translate (_dgeg ,_gaeab );if _adbf !=0{_ebfbf .Translate (_cbad /2,_dfd /2);_ebfbf .RotateDeg (_adbf );_ebfbf .Translate (-_cbad /2,-_dfd /2);};_ebfbf .Scale (_cbad ,_dfd ).Add_Do (_fgfgf );_bcbf :=_ebfbf .Operations ();_bcbf .WrapIfNeeded ();_cbfae .addContents (_bcbf );if _dgdgdd ._cag .isRelative (){_gdcc .Y +=_beba ;_gdcc .Height -=_beba ;return _gdcc ,nil ;};return _agbg ,nil ;};

// NewFilledCurve returns a instance of filled curve.
func (_edaf *Creator )NewFilledCurve ()*FilledCurve {return _acdd ()};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_bceb *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_ggge :=_fcfc (_bceb ._cbee );_ggge .Append (text );_afgc ,_gfff :=_bceb .Add (_ggge );return _ggge ,_afgc ,_gfff ;};func (_eacfg *Invoice )newColumn (_daga string ,_abdg CellHorizontalAlignment )*InvoiceCell {_ebcf :=&InvoiceCell {_eacfg ._aeda ,_daga };_ebcf .Alignment =_abdg ;return _ebcf ;};func _fbce (_dfgb ,_efag ,_ccba ,_beb ,_egbb ,_eage float64 )*Curve {_ccca :=&Curve {};_ccca ._ccge =_dfgb ;_ccca ._gcbg =_efag ;_ccca ._ddge =_ccba ;_ccca ._ddgd =_beb ;_ccca ._edfg =_egbb ;_ccca ._cbff =_eage ;_ccca ._cgba =_ag .NewPdfColorDeviceRGB (0,0,0);_ccca ._dggc =1.0;return _ccca ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_eaddb *_ag .PdfAnnotation ;_faad bool ;};

// SetColorBottom sets border color for bottom.
func (_eafe *border )SetColorBottom (col Color ){_eafe ._bdfa =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_aede *Invoice )SetNoteStyle (style TextStyle ){_aede ._cagc =style };

// Width returns Image's document width.
func (_eec *Image )Width ()float64 {return _eec ._cbaaa };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_debe *Creator )SetOptimizer (optimizer _ag .Optimizer ){_debe ._fgfg =optimizer };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cdcd *Invoice )NoteHeadingStyle ()TextStyle {return _cdcd ._aaeef };func _ddgc (_cebd *_e .File )([]*_ag .PdfPage ,error ){_dbfd ,_dcab :=_ag .NewPdfReader (_cebd );if _dcab !=nil {return nil ,_dcab ;};_gggf ,_dcab :=_dbfd .GetNumPages ();if _dcab !=nil {return nil ,_dcab ;};var _bbcdaf []*_ag .PdfPage ;for _dcdab :=0;_dcdab < _gggf ;_dcdab ++{_gafgb ,_agbbe :=_dbfd .GetPage (_dcdab +1);if _agbbe !=nil {return nil ,_agbbe ;};_bbcdaf =append (_bbcdaf ,_gafgb );};return _bbcdaf ,nil ;};

// SetColor sets the line color.
func (_egce *Curve )SetColor (col Color ){_egce ._cgba =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_bedg *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _fbce (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fgae *Creator )MoveDown (dy float64 ){_fgae ._dbf .Y +=dy };

// NewImageFromFile creates an Image from a file.
func (_cee *Creator )NewImageFromFile (path string )(*Image ,error ){return _gbbc (path )};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_agfc *Creator )MoveRight (dx float64 ){_agfc ._dbf .X +=dx };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_ccd *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ccd ._ede ._eeaf ,_ccd ._ede ._edc ,_ccd ._ede ._gdd ,_ccd ._ede ._fged ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_efdf *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _efdf ._ggde [0],_efdf ._ggde [1]};

// TitleStyle returns the style properties used to render the invoice title.
func (_fgaeb *Invoice )TitleStyle ()TextStyle {return _fgaeb ._dafc };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_defb *Table )Width ()float64 {return 0};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_ggefe *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_ggefe ._edca =alignment };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_ccge float64 ;_gcbg float64 ;_ddge float64 ;_ddgd float64 ;_edfg float64 ;_cbff float64 ;_cgba *_ag .PdfColorDeviceRGB ;_dggc float64 ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_effb *Creator )NewParagraph (text string )*Paragraph {return _bcff (text ,_effb .NewTextStyle ())};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_gadfe *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_bebf ,_aecfc :=_gadfe .Wrap (width );if _aecfc !=nil {return nil ,_aecfc ;};_aedaf :=int (height /_gadfe .Style .FontSize );if _aedaf >=len (_bebf ){return nil ,nil ;};_afab :="\u000a";_gadfe .Text =_ed .Replace (_ed .Join (_bebf [:_aedaf ],"\u0020"),_afab +"\u0020",_afab ,-1);_bbfc :=_ed .Replace (_ed .Join (_bebf [_aedaf :],"\u0020"),_afab +"\u0020",_afab ,-1);return NewTextChunk (_bbfc ,_gadfe .Style ),nil ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {_fef :=&Creator {};_fef ._bafe =[]*_ag .PdfPage {};_fef ._eea =map[*_ag .PdfPage ]*Block {};_fef .SetPageSize (PageSizeLetter );_gbga :=0.1*_fef ._efa ;_fef ._cffe ._eeaf =_gbga ;_fef ._cffe ._edc =_gbga ;_fef ._cffe ._gdd =_gbga ;_fef ._cffe ._fged =_gbga ;var _cae error ;_fef ._geee ,_cae =_ag .NewStandard14Font (_ag .HelveticaName );if _cae !=nil {_fef ._geee =_ag .DefaultFont ();};_fef ._fcca ,_cae =_ag .NewStandard14Font (_ag .HelveticaBoldName );if _cae !=nil {_fef ._geee =_ag .DefaultFont ();};_fef ._bgg =_fef .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_fef .AddOutlines =true ;_fef ._bbef =_ag .NewOutline ();return _fef ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ecae *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _ecae ._gaed [0],_ecae ._gaed [1]};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_fbf *Block )SetMargins (left ,right ,top ,bottom float64 ){_fbf ._fda ._eeaf =left ;_fbf ._fda ._edc =right ;_fbf ._fda ._gdd =top ;_fbf ._fda ._fged =bottom ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_abeb []_ba .CubicBezierCurve ;FillEnabled bool ;_daf *_ag .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_bbceb *_ag .PdfColorDeviceRGB ;};func (_cg *Block )addContents (_cd *_ee .ContentStreamOperations ){_cg ._ca .WrapIfNeeded ();_cd .WrapIfNeeded ();*_cg ._ca =append (*_cg ._ca ,*_cd ...);};

// NewTOC creates a new table of contents.
func (_dcbe *Creator )NewTOC (title string )*TOC {_cccba :=_dcbe .NewTextStyle ();_cccba .Font =_dcbe ._fcca ;return _dedg (title ,_dcbe .NewTextStyle (),_cccba );};func (_caea *Invoice )drawInformation ()*Table {_dggce :=_afae (2);_bcgd :=append ([][2]*InvoiceCell {_caea ._ecagd ,_caea ._gaed ,_caea ._ggde },_caea ._fgag ...);for _ ,_fdce :=range _bcgd {_cbd ,_facd :=_fdce [0],_fdce [1];if _facd .Value ==""{continue ;};_egbae :=_dggce .NewCell ();_egbae .SetBackgroundColor (_cbd .BackgroundColor );_caea .setCellBorder (_egbae ,_cbd );_eeb :=_fcfc (_cbd .TextStyle );_eeb .Append (_cbd .Value );_eeb .SetMargins (0,0,2,1);_egbae .SetContent (_eeb );_egbae =_dggce .NewCell ();_egbae .SetBackgroundColor (_facd .BackgroundColor );_caea .setCellBorder (_egbae ,_facd );_eeb =_fcfc (_facd .TextStyle );_eeb .Append (_facd .Value );_eeb .SetMargins (0,0,2,1);_egbae .SetContent (_eeb );};return _dggce ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ca *_ee .ContentStreamOperations ;_af *_ag .PdfPageResources ;_bc positioning ;_ga ,_ad float64 ;_dbc float64 ;_fd float64 ;_dd float64 ;_fda margins ;_eb []*_ag .PdfAnnotation ;};

// Write output of creator to io.Writer interface.
func (_dcbf *Creator )Write (ws _c .Writer )error {if _fgebb :=_dcbf .Finalize ();_fgebb !=nil {return _fgebb ;};_debef :=_ag .NewPdfWriter ();_debef .SetOptimizer (_dcbf ._fgfg );if _dcbf ._dddb !=nil {_ebab :=_debef .SetForms (_dcbf ._dddb );if _ebab !=nil {_cf .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_ebab );return _ebab ;};};if _dcbf ._eaad !=nil {_debef .AddOutlineTree (_dcbf ._eaad );}else if _dcbf ._bbef !=nil &&_dcbf .AddOutlines {_debef .AddOutlineTree (&_dcbf ._bbef .ToPdfOutline ().PdfOutlineTreeNode );};if _dcbf ._adgb !=nil {if _aefe :=_debef .SetPageLabels (_dcbf ._adgb );_aefe !=nil {_cf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_aefe );return _aefe ;};};if _dcbf ._ddf !=nil {for _ ,_bafde :=range _dcbf ._ddf {_fdfb :=_bafde .SubsetRegistered ();if _fdfb !=nil {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_fdfb );return _fdfb ;};};};if _dcbf ._aea !=nil {_acec :=_dcbf ._aea (&_debef );if _acec !=nil {_cf .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_acec );return _acec ;};};for _ ,_dbge :=range _dcbf ._bafe {_bfaf :=_debef .AddPage (_dbge );if _bfaf !=nil {_cf .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_bfaf );return _bfaf ;};};_facb :=_debef .Write (ws );if _facb !=nil {return _facb ;};return nil ;};func _ecbe (_gbgc *_ag .Image )(*Image ,error ){_dffe :=float64 (_gbgc .Width );_gfd :=float64 (_gbgc .Height );return &Image {_ffccc :_gbgc ,_aggd :_dffe ,_bgfd :_gfd ,_cbaaa :_dffe ,_efdd :_gfd ,_edfe :0,_eddg :1.0,_cag :_ecfc },nil ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_bage *_ag .PdfColorDeviceRGB ;_acfa _ba .LineStyle ;_gdgaf CellBorderStyle ;_deeeg *_ag .PdfColorDeviceRGB ;_defag float64 ;_ebde CellBorderStyle ;_fafe *_ag .PdfColorDeviceRGB ;_efaf float64 ;_cbgcf CellBorderStyle ;_afdb *_ag .PdfColorDeviceRGB ;_bdfga float64 ;_fdaf CellBorderStyle ;_baegb *_ag .PdfColorDeviceRGB ;_fdgc float64 ;_befg ,_caga int ;_ecagc int ;_eeaa int ;_egac VectorDrawable ;_eecdc CellHorizontalAlignment ;_beggb CellVerticalAlignment ;_cbed float64 ;_bcagd *Table ;};

// SetFillColor sets the fill color for the path.
func (_cfbf *FilledCurve )SetFillColor (color Color ){_cfbf ._daf =_ag .NewPdfColorDeviceRGB (color .ToRGB ());};func (_fc *Block )translate (_fge ,_cfg float64 ){_fa :=_ee .NewContentCreator ().Translate (_fge ,-_cfg ).Operations ();*_fc ._ca =append (*_fa ,*_fc ._ca ...);_fc ._ca .WrapIfNeeded ();};

// Heading returns the heading component of the table of contents.
func (_acca *TOC )Heading ()*StyledParagraph {return _acca ._aefff };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_agfe *Image )ConvertToBinary ()error {return _agfe ._ffccc .ConvertToBinary ()};func (_acbd *StyledParagraph )wrapText ()error {if !_acbd ._fdfd ||int (_acbd ._bbbb )<=0{_acbd ._gabf =[][]*TextChunk {_acbd ._bdee };return nil ;};_acbd ._gabf =[][]*TextChunk {};var _degcg []*TextChunk ;var _gddb float64 ;_cebf :=func (_afgfa *_ag .PdfAnnotation )*_ag .PdfAnnotation {if _afgfa ==nil {return nil ;};var _edae *_ag .PdfAnnotation ;switch _gbeb :=_afgfa .GetContext ().(type ){case *_ag .PdfAnnotationLink :if _cecc :=_cbeb (_gbeb );_cecc !=nil {_edae =_cecc .PdfAnnotation ;};};return _edae ;};for _ ,_bgga :=range _acbd ._bdee {_cgfd :=_bgga .Style ;_cgaa :=_bgga ._eaddb ;var (_caaf []rune ;_dbbe []float64 ;);for _ ,_ddag :=range _bgga .Text {if _ddag =='\u000A'{_degcg =append (_degcg ,&TextChunk {Text :_ed .TrimRightFunc (string (_caaf ),_ef .IsSpace ),Style :_cgfd ,_eaddb :_cebf (_cgaa )});_acbd ._gabf =append (_acbd ._gabf ,_degcg );_degcg =nil ;_gddb =0;_caaf =nil ;_dbbe =nil ;continue ;};_ggfgc :=_ddag ==' ';_bgcef ,_facf :=_cgfd .Font .GetRuneMetrics (_ddag );if !_facf {_cf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ddag );return _a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_eacc :=_cgfd .FontSize *_bgcef .Wx ;_afgd :=_eacc ;if !_ggfgc {_afgd =_eacc +_cgfd .CharSpacing *1000.0;};if _gddb +_eacc > _acbd ._bbbb *1000.0{_dbdb :=-1;if !_ggfgc {for _aage :=len (_caaf )-1;_aage >=0;_aage --{if _caaf [_aage ]==' '{_dbdb =_aage ;break ;};};};_ffad :=string (_caaf );if _dbdb >=0{_ffad =string (_caaf [0:_dbdb +1]);_caaf =_caaf [_dbdb +1:];_caaf =append (_caaf ,_ddag );_dbbe =_dbbe [_dbdb +1:];_dbbe =append (_dbbe ,_afgd );_gddb =0;for _ ,_gdbe :=range _dbbe {_gddb +=_gdbe ;};}else {if _ggfgc {_gddb =0;_caaf =[]rune {};_dbbe =[]float64 {};}else {_gddb =_afgd ;_caaf =[]rune {_ddag };_dbbe =[]float64 {_afgd };};};_degcg =append (_degcg ,&TextChunk {Text :_ed .TrimRightFunc (string (_ffad ),_ef .IsSpace ),Style :_cgfd ,_eaddb :_cebf (_cgaa )});_acbd ._gabf =append (_acbd ._gabf ,_degcg );_degcg =[]*TextChunk {};}else {_gddb +=_afgd ;_caaf =append (_caaf ,_ddag );_dbbe =append (_dbbe ,_afgd );};};if len (_caaf )> 0{_degcg =append (_degcg ,&TextChunk {Text :string (_caaf ),Style :_cgfd ,_eaddb :_cebf (_cgaa )});};};if len (_degcg )> 0{_acbd ._gabf =append (_acbd ._gabf ,_degcg );};return nil ;};

// GetOptimizer returns current PDF optimizer.
func (_dgdg *Creator )GetOptimizer ()_ag .Optimizer {return _dgdg ._fgfg };

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_cebaf *Rectangle )GetCoords ()(float64 ,float64 ){return _cebaf ._dfedb ,_cebaf ._bdc };func (_dbcgc *StyledParagraph )getTextWidth ()float64 {var _bdcbg float64 ;_aadb :=len (_dbcgc ._bdee );for _dddfd ,_eecf :=range _dbcgc ._bdee {_cdfce :=&_eecf .Style ;_dbe :=len (_eecf .Text );for _bfaca ,_faac :=range _eecf .Text {if _faac =='\u000A'{continue ;};_geed ,_ceeb :=_cdfce .Font .GetRuneMetrics (_faac );if !_ceeb {_cf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_faac );return -1;};_bdcbg +=_cdfce .FontSize *_geed .Wx ;if _faac !=' '&&(_dddfd !=_aadb -1||_bfaca !=_dbe -1){_bdcbg +=_cdfce .CharSpacing *1000.0;};};};return _bdcbg ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func (_gccb positioning )isAbsolute ()bool {return _gccb ==_aabc };func (_bfeb *StyledParagraph )appendChunk (_cffg *TextChunk )*TextChunk {_bfeb ._bdee =append (_bfeb ._bdee ,_cffg );_bfeb .wrapText ();return _cffg ;};type positioning int ;

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_gagf *Table )SetPos (x ,y float64 ){_gagf ._ccfd =_aabc ;_gagf ._dbbed =x ;_gagf ._ecdb =y };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fdgeb *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fdgeb ._cddd ._eeaf ,_fdgeb ._cddd ._edc ,_fdgeb ._cddd ._gdd ,_fdgeb ._cddd ._fged ;};

// Width returns the width of the Paragraph.
func (_ddga *Paragraph )Width ()float64 {if _ddga ._acbfa &&int (_ddga ._edfd )> 0{return _ddga ._edfd ;};return _ddga .getTextWidth ()/1000.0;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bgcf *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adaab :=ctx ;_feae ,ctx ,_ecdae :=_bgcf ._aefff .GeneratePageBlocks (ctx );if _ecdae !=nil {return _feae ,ctx ,_ecdae ;};for _ ,_aefba :=range _bgcf ._gegc {_adgd :=_aefba ._gecf ;if !_bgcf ._efced {_aefba ._gecf =0;};_cafg ,_gdfd ,_adda :=_aefba .GeneratePageBlocks (ctx );_aefba ._gecf =_adgd ;if _adda !=nil {return _feae ,ctx ,_adda ;};if len (_cafg )< 1{continue ;};_feae [len (_feae )-1].mergeBlocks (_cafg [0]);_feae =append (_feae ,_cafg [1:]...);ctx =_gdfd ;};if _bgcf ._bdfca .isRelative (){ctx .X =_adaab .X ;};if _bgcf ._bdfca .isAbsolute (){return _feae ,_adaab ,nil ;};return _feae ,ctx ,nil ;};func _ggd (_dgfac ,_dgcc ,_dee ,_fbad float64 )*Ellipse {_dfbaa :=&Ellipse {};_dfbaa ._aaee =_dgfac ;_dfbaa ._ecdf =_dgcc ;_dfbaa ._agec =_dee ;_dfbaa ._dge =_fbad ;_dfbaa ._ggga =_ag .NewPdfColorDeviceRGB (0,0,0);_dfbaa ._faef =1.0;return _dfbaa ;};

// SetSellerAddress sets the seller address of the invoice.
func (_eaca *Invoice )SetSellerAddress (address *InvoiceAddress ){_eaca ._fadf =address };

// SetFillColor sets background color for border.
func (_dddf *border )SetFillColor (col Color ){_dddf ._gef =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// Invoice represents a configurable invoice template.
type Invoice struct{_dfed string ;_geff *Image ;_ece *InvoiceAddress ;_fadf *InvoiceAddress ;_egbf string ;_ecagd [2]*InvoiceCell ;_gaed [2]*InvoiceCell ;_ggde [2]*InvoiceCell ;_fgag [][2]*InvoiceCell ;_gfaf []*InvoiceCell ;_gff [][]*InvoiceCell ;_ffff [2]*InvoiceCell ;_fadd [2]*InvoiceCell ;_cdfd [][2]*InvoiceCell ;_bddd [2]string ;_abcc [2]string ;_cbbc [][2]string ;_ddebd TextStyle ;_ccgf TextStyle ;_dafc TextStyle ;_ffbe TextStyle ;_ddc TextStyle ;_cagc TextStyle ;_aaeef TextStyle ;_eaedc InvoiceCellProps ;_aeda InvoiceCellProps ;_faed InvoiceCellProps ;_dbfg InvoiceCellProps ;_dfeg positioning ;};func _bcff (_ebee string ,_ecfe TextStyle )*Paragraph {_bfeg :=&Paragraph {_agae :_ebee ,_gbgeb :_ecfe .Font ,_gcbgg :_ecfe .FontSize ,_abcd :1.0,_acbfa :true ,_fbgea :true ,_bcef :TextAlignmentLeft ,_adga :0,_cfadb :1,_ebag :1,_ddef :_ecfc };_bfeg .SetColor (_ecfe .Color );return _bfeg ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_gggee *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_fde :=NewTextChunk (text ,_gggee ._abed );_fde ._eaddb =_aefea (url );return _gggee .appendChunk (_fde );};func _acdd ()*FilledCurve {_eccf :=FilledCurve {};_eccf ._abeb =[]_ba .CubicBezierCurve {};return &_eccf ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_acbg *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _acbg ._fadd [0],_acbg ._fadd [1]};

// Height returns the current page height.
func (_aee *Creator )Height ()float64 {return _aee ._ddbb };

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_gad *Block )AddAnnotation (annotation *_ag .PdfAnnotation ){for _ ,_cb :=range _gad ._eb {if _cb ==annotation {return ;};};_gad ._eb =append (_gad ._eb ,annotation );};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_cdec *Creator )Finalize ()error {if _cdec ._ggb {return nil ;};_eafb :=len (_cdec ._bafe );_defg :=0;if _cdec ._fed !=nil {_defg ++;};if _cdec .AddTOC {_cdec .initContext ();_cdec ._dbf .Page =_defg +1;if _cdec ._ecag !=nil {if _gbee :=_cdec ._ecag (_cdec ._bgg );_gbee !=nil {return _gbee ;};};_egeg ,_ ,_afbdb :=_cdec ._bgg .GeneratePageBlocks (_cdec ._dbf );if _afbdb !=nil {_cf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_afbdb );return _afbdb ;};_defg +=len (_egeg );_fbfd :=_cdec ._bgg .Lines ();for _ ,_agaf :=range _fbfd {_cbb ,_gdff :=_ea .Atoi (_agaf .Page .Text );if _gdff !=nil {continue ;};_agaf .Page .Text =_ea .Itoa (_cbb +_defg );};};_baa :=false ;if _cdec ._fed !=nil {_eafb ++;_eae :=_cdec .newPage ();_cdec ._bafe =append ([]*_ag .PdfPage {_eae },_cdec ._bafe ...);_cdec .setActivePage (_eae );_fgef :=FrontpageFunctionArgs {PageNum :1,TotalPages :_eafb };_cdec ._fed (_fgef );_baa =true ;};if _cdec .AddTOC {_cdec .initContext ();if _cdec ._ecag !=nil {if _cfdg :=_cdec ._ecag (_cdec ._bgg );_cfdg !=nil {_cf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_cfdg );return _cfdg ;};};_afbf :=_cdec ._bgg .Lines ();for _ ,_fbgd :=range _afbf {_fbgd ._gecf +=int64 (_defg );};var _caa []*_ag .PdfPage ;_fgdf ,_ ,_ :=_cdec ._bgg .GeneratePageBlocks (_cdec ._dbf );for _ ,_abb :=range _fgdf {_abb .SetPos (0,0);_eafb ++;_aed :=_cdec .newPage ();_caa =append (_caa ,_aed );_cdec .setActivePage (_aed );_cdec .Draw (_abb );};if _baa {_efd :=_cdec ._bafe [0];_ageg :=_cdec ._bafe [1:];_cdec ._bafe =append ([]*_ag .PdfPage {_efd },_caa ...);_cdec ._bafe =append (_cdec ._bafe ,_ageg ...);}else {_cdec ._bafe =append (_caa ,_cdec ._bafe ...);};};if _cdec ._bbef !=nil &&_cdec .AddOutlines {var _fbga func (_gcdb *_ag .OutlineItem );_fbga =func (_bcab *_ag .OutlineItem ){_bcab .Dest .Page +=int64 (_defg );if _acd :=int (_bcab .Dest .Page );_acd >=0&&_acd < len (_cdec ._bafe ){_bcab .Dest .PageObj =_cdec ._bafe [_acd ].GetPageAsIndirectObject ();}else {_cf .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_acd );};_bcab .Dest .Y =_cdec ._ddbb -_bcab .Dest .Y ;_gbbd :=_bcab .Items ();for _ ,_gcgb :=range _gbbd {_fbga (_gcgb );};};_gfcg :=_cdec ._bbef .Items ();for _ ,_eaed :=range _gfcg {_fbga (_eaed );};if _cdec .AddTOC {var _gde int ;if _baa {_gde =1;};_gdg :=_ag .NewOutlineDest (int64 (_gde ),0,_cdec ._ddbb );if _gde >=0&&_gde < len (_cdec ._bafe ){_gdg .PageObj =_cdec ._bafe [_gde ].GetPageAsIndirectObject ();}else {_cf .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gde );};_cdec ._bbef .Insert (0,_ag .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_gdg ));};};for _aaaef ,_gbf :=range _cdec ._bafe {_cdec .setActivePage (_gbf );if _cdec ._cdcc !=nil {_cgdb :=NewBlock (_cdec ._efa ,_cdec ._cffe ._gdd );_cccb :=HeaderFunctionArgs {PageNum :_aaaef +1,TotalPages :_eafb };_cdec ._cdcc (_cgdb ,_cccb );_cgdb .SetPos (0,0);if _bfgc :=_cdec .Draw (_cgdb );_bfgc !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_bfgc );return _bfgc ;};};if _cdec ._eeg !=nil {_bfgg :=NewBlock (_cdec ._efa ,_cdec ._cffe ._fged );_fgeb :=FooterFunctionArgs {PageNum :_aaaef +1,TotalPages :_eafb };_cdec ._eeg (_bfgg ,_fgeb );_bfgg .SetPos (0,_cdec ._ddbb -_bfgg ._fd );if _dbgc :=_cdec .Draw (_bfgg );_dbgc !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_dbgc );return _dbgc ;};};_ggaf ,_edde :=_cdec ._eea [_gbf ];if !_edde {continue ;};if _aag :=_ggaf .drawToPage (_gbf );_aag !=nil {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_aaaef +1,_aag );return _aag ;};};_cdec ._ggb =true ;return nil ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bbbc *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_eegd :=NewTextChunk (text ,_bbbc ._abed );_eegd ._eaddb =_ddfd (page -1,x ,y ,zoom );return _bbbc .appendChunk (_eegd );};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_bedd *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _abdf (x ,y ,width ,height );};

// NewTOCLine creates a new table of contents line with the default style.
func (_bfgce *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _ebfca (number ,title ,page ,level ,_bfgce .NewTextStyle ());};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_ccf float64 ;_ceeg float64 ;_fega float64 ;_agge float64 ;_cdfc *_ag .PdfColorDeviceRGB ;_aedee float64 ;};func _ggcc (_cgbcd TextStyle )*List {return &List {_bag :TextChunk {Text :"\u2022\u0020",Style :_cgbcd },_deabg :0,_gbca :true ,_dbac :_ecfc ,_cbee :_cgbcd };};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_gbea *TOC )SetLinePageStyle (style TextStyle ){_gbea ._deecb =style };

// DrawHeader sets a function to draw a header on created output pages.
func (_aabcc *Creator )DrawHeader (drawHeaderFunc func (_age *Block ,_bege HeaderFunctionArgs )){_aabcc ._cdcc =drawHeaderFunc ;};

// SetTitle sets the title of the invoice.
func (_daff *Invoice )SetTitle (title string ){_daff ._dfed =title };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_cfgag *Creator )NewPage ()*_ag .PdfPage {_dbd :=_cfgag .newPage ();_cfgag ._bafe =append (_cfgag ._bafe ,_dbd );_cfgag ._dbf .Page ++;return _dbd ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_fbfcb *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_fcef :=&_fbfcb ._degg ;_fcef ._eeaf =left ;_fcef ._edc =right ;_fcef ._gdd =top ;_fcef ._fged =bottom ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_dadg *Table )NewCell ()*TableCell {return _dadg .newCell (1)};

// SetAnnotation sets a annotation on a TextChunk.
func (_ddefc *TextChunk )SetAnnotation (annotation *_ag .PdfAnnotation ){_ddefc ._eaddb =annotation };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_bbfa *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_bbfa ._ede ._eeaf =left ;_bbfa ._ede ._edc =right ;_bbfa ._ede ._gdd =top ;_bbfa ._ede ._fged =bottom ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_bfac *Creator )SetPageLabels (pageLabels _db .PdfObject ){_bfac ._adgb =pageLabels };

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_cfbd *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _abe []*Block ;_bcag :=ctx ;if _cfbd ._ggef .isRelative (){ctx .X +=_cfbd ._dcg ._eeaf ;ctx .Y +=_cfbd ._dcg ._gdd ;ctx .Width -=_cfbd ._dcg ._eeaf +_cfbd ._dcg ._edc ;ctx .Height -=_cfbd ._dcg ._gdd +_cfbd ._dcg ._fged ;};ctx .Inline =_cfbd ._ggag ;_fbgb :=ctx ;_bebc :=ctx ;var _bef float64 ;for _ ,_cbge :=range _cfbd ._cfab {if ctx .Inline {if (ctx .X -_fbgb .X )+_cbge .Width ()<=ctx .Width {ctx .Y =_bebc .Y ;ctx .Height =_bebc .Height ;}else {ctx .X =_fbgb .X ;ctx .Width =_fbgb .Width ;_bebc .Y +=_bef ;_bebc .Height -=_bef ;_bef =0;};};_bga ,_agdf ,_bbead :=_cbge .GeneratePageBlocks (ctx );if _bbead !=nil {_cf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_bbead );return nil ,ctx ,_bbead ;};if len (_bga )< 1{continue ;};if len (_abe )> 0{_abe [len (_abe )-1].mergeBlocks (_bga [0]);_abe =append (_abe ,_bga [1:]...);}else {_abe =append (_abe ,_bga [0:]...);};if ctx .Inline {if ctx .Page !=_agdf .Page {_fbgb .Y =ctx .Margins ._gdd ;_fbgb .Height =ctx .PageHeight -ctx .Margins ._gdd ;_bebc .Y =_fbgb .Y ;_bebc .Height =_fbgb .Height ;_bef =_agdf .Height -_fbgb .Height ;}else {if _gfca :=ctx .Height -_agdf .Height ;_gfca > _bef {_bef =_gfca ;};};}else {_agdf .X =ctx .X ;};ctx =_agdf ;};ctx .Inline =_bcag .Inline ;if _cfbd ._ggef .isRelative (){ctx .X =_bcag .X ;};if _cfbd ._ggef .isAbsolute (){return _abe ,_bcag ,nil ;};return _abe ,ctx ,nil ;};

// Level returns the indentation level of the TOC line.
func (_bdgca *TOCLine )Level ()uint {return _bdgca ._bced };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_eac *Block )ScaleToHeight (h float64 ){_egc :=h /_eac ._fd ;_eac .Scale (_egc ,_egc )};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_dgfa *Creator )EnableFontSubsetting (font *_ag .PdfFont ){_dgfa ._ddf =append (_dgfa ._ddf ,font )};

// SetEnableWrap sets the line wrapping enabled flag.
func (_egad *Paragraph )SetEnableWrap (enableWrap bool ){_egad ._acbfa =enableWrap ;_egad ._fbgea =false ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_dggeg *TOCLine )SetLevelOffset (levelOffset float64 ){_dggeg ._cdbfa =levelOffset ;_dggeg ._ebbg ._cddd ._eeaf =_dggeg ._geaa +float64 (_dggeg ._bced -1)*_dggeg ._cdbfa ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_ecfd *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_ecfd ._eecdc =halign };

// Angle returns the block rotation angle in degrees.
func (_ff *Block )Angle ()float64 {return _ff ._dd };func (_bfa rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _bfa ._fced ,_bfa ._ecca ,_bfa ._gea };

// AddLine appends a new line to the invoice line items table.
func (_gcbde *Invoice )AddLine (values ...string )[]*InvoiceCell {_bbdb :=len (_gcbde ._gfaf );var _ceba []*InvoiceCell ;for _defa ,_ebef :=range values {_gcdd :=_gcbde .newCell (_ebef ,_gcbde ._faed );if _defa < _bbdb {_gcdd .Alignment =_gcbde ._gfaf [_defa ].Alignment ;};_ceba =append (_ceba ,_gcdd );};_gcbde ._gff =append (_gcbde ._gff ,_ceba );return _ceba ;};

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_aeg *Division )Height ()float64 {_efde :=0.0;_fbe :=0.0;for _ ,_fcad :=range _aeg ._cfab {_fabe ,_ebba :=_fcad .Width (),_fcad .Height ();switch _eegf :=_fcad .(type ){case *Paragraph :_fbcf :=_eegf ;_fabe +=_fbcf ._adag ._eeaf +_fbcf ._adag ._edc ;_ebba +=_fbcf ._adag ._gdd +_fbcf ._adag ._fged ;case *StyledParagraph :_abd :=_eegf ;_fabe +=_abd ._cddd ._eeaf +_abd ._cddd ._edc ;_ebba +=_abd ._cddd ._gdd +_abd ._cddd ._fged ;};_efde +=_ebba ;_fbe =_efde ;};return _fbe ;};

// NewCellProps returns the default properties of an invoice cell.
func (_bcg *Invoice )NewCellProps ()InvoiceCellProps {_bcfa :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_bcg ._ddebd ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_bcfa ,BorderColor :_bcfa ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_eade *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _cbfd (x1 ,y1 ,x2 ,y2 )};

// SetBorder sets the cell's border style.
func (_fceb *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_fceb ._gdgaf =CellBorderStyleSingle ;_fceb ._defag =width ;_fceb ._ebde =CellBorderStyleSingle ;_fceb ._efaf =width ;_fceb ._cbgcf =CellBorderStyleSingle ;_fceb ._bdfga =width ;_fceb ._fdaf =CellBorderStyleSingle ;_fceb ._fdgc =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_fceb ._gdgaf =CellBorderStyleDouble ;_fceb ._defag =width ;_fceb ._ebde =CellBorderStyleDouble ;_fceb ._efaf =width ;_fceb ._cbgcf =CellBorderStyleDouble ;_fceb ._bdfga =width ;_fceb ._fdaf =CellBorderStyleDouble ;_fceb ._fdgc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_fceb ._gdgaf =style ;_fceb ._defag =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_fceb ._ebde =style ;_fceb ._efaf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_fceb ._cbgcf =style ;_fceb ._bdfga =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_fceb ._fdaf =style ;_fceb ._fdgc =width ;};};

// SetBorderColor sets the border color.
func (_ggdf *Ellipse )SetBorderColor (col Color ){_ggdf ._ggga =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetFontSize sets the font size in document units (points).
func (_fgg *Paragraph )SetFontSize (fontSize float64 ){_fgg ._gcbgg =fontSize };func _ebfca (_fabaf ,_bagg ,_aaeb string ,_cebbe uint ,_fcfg TextStyle )*TOCLine {return _cefbf (TextChunk {Text :_fabaf ,Style :_fcfg },TextChunk {Text :_bagg ,Style :_fcfg },TextChunk {Text :_aaeb ,Style :_fcfg },_cebbe ,_fcfg );};

// SetWidthBottom sets border width for bottom.
func (_afg *border )SetWidthBottom (bw float64 ){_afg ._bce =bw };

// CreateFrontPage sets a function to generate a front Page.
func (_eefe *Creator )CreateFrontPage (genFrontPageFunc func (_fcac FrontpageFunctionArgs )){_eefe ._fed =genFrontPageFunc ;};

// SetMargins sets the Paragraph's margins.
func (_fbbf *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_fbbf ._cddd ._eeaf =left ;_fbbf ._cddd ._edc =right ;_fbbf ._cddd ._gdd =top ;_fbbf ._cddd ._fged =bottom ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_bea *Division )Add (d VectorDrawable )error {_gfg :=false ;switch d .(type ){case *Paragraph :_gfg =true ;case *StyledParagraph :_gfg =true ;case *Image :_gfg =true ;};if !_gfg {return _a .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_bea ._cfab =append (_bea ._cfab ,d );return nil ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_cbca *Creator )DrawFooter (drawFooterFunc func (_bfff *Block ,_daec FooterFunctionArgs )){_cbca ._eeg =drawFooterFunc ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cfgc *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _cfgc ._ecagd [0],_cfgc ._ecagd [1]};func _ebcgg (_cec ,_fadge TextStyle )*Invoice {_fbfag :=&Invoice {_dfed :"\u0049N\u0056\u004f\u0049\u0043\u0045",_egbf :"\u002c\u0020",_ddebd :_cec ,_ccgf :_fadge };_fbfag ._fadf =&InvoiceAddress {Separator :_fbfag ._egbf };_fbfag ._ece =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_fbfag ._egbf };_fbfb :=ColorRGBFrom8bit (245,245,245);_ccbe :=ColorRGBFrom8bit (155,155,155);_fbfag ._dafc =_fadge ;_fbfag ._dafc .Color =_ccbe ;_fbfag ._dafc .FontSize =20;_fbfag ._ffbe =_cec ;_fbfag ._ddc =_fadge ;_fbfag ._cagc =_cec ;_fbfag ._aaeef =_fadge ;_fbfag ._eaedc =_fbfag .NewCellProps ();_fbfag ._eaedc .BackgroundColor =_fbfb ;_fbfag ._eaedc .TextStyle =_fadge ;_fbfag ._aeda =_fbfag .NewCellProps ();_fbfag ._aeda .TextStyle =_fadge ;_fbfag ._aeda .BackgroundColor =_fbfb ;_fbfag ._aeda .BorderColor =_fbfb ;_fbfag ._faed =_fbfag .NewCellProps ();_fbfag ._faed .BorderColor =_fbfb ;_fbfag ._faed .BorderSides =[]CellBorderSide {CellBorderSideBottom };_fbfag ._faed .Alignment =CellHorizontalAlignmentRight ;_fbfag ._dbfg =_fbfag .NewCellProps ();_fbfag ._dbfg .Alignment =CellHorizontalAlignmentRight ;_fbfag ._ecagd =[2]*InvoiceCell {_fbfag .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_fbfag ._eaedc ),_fbfag .newCell ("",_fbfag ._eaedc )};_fbfag ._gaed =[2]*InvoiceCell {_fbfag .newCell ("\u0044\u0061\u0074\u0065",_fbfag ._eaedc ),_fbfag .newCell ("",_fbfag ._eaedc )};_fbfag ._ggde =[2]*InvoiceCell {_fbfag .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_fbfag ._eaedc ),_fbfag .newCell ("",_fbfag ._eaedc )};_fbfag ._ffff =[2]*InvoiceCell {_fbfag .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_fbfag ._dbfg ),_fbfag .newCell ("",_fbfag ._dbfg )};_adgg :=_fbfag ._dbfg ;_adgg .TextStyle =_fadge ;_adgg .BackgroundColor =_fbfb ;_adgg .BorderColor =_fbfb ;_fbfag ._fadd =[2]*InvoiceCell {_fbfag .newCell ("\u0054\u006f\u0074a\u006c",_adgg ),_fbfag .newCell ("",_adgg )};_fbfag ._bddd =[2]string {"\u004e\u006f\u0074e\u0073",""};_fbfag ._abcc =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_fbfag ._gfaf =[]*InvoiceCell {_fbfag .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_fbfag .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_fbfag .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_fbfag .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _fbfag ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_eggdb *StyledParagraph )SetTextAlignment (align TextAlignment ){_eggdb ._ade =align };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// Height returns Image's document height.
func (_gcba *Image )Height ()float64 {return _gcba ._efdd };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_dbfe *Invoice )SetColumns (cols []*InvoiceCell ){_dbfe ._gfaf =cols };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_fdff *Image )SetEncoder (encoder _db .StreamEncoder ){_fdff ._dfe =encoder };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_ggfa *TOC )SetHeading (text string ,style TextStyle ){_gbac :=_ggfa .Heading ();_gbac .Reset ();_dddbg :=_gbac .Append (text );_dddbg .Style =style ;};func (_ffg *Image )makeXObject ()error {_daee :=_ffg ._dfe ;if _daee ==nil {_daee =_db .NewFlateEncoder ();};_fdad ,_edfgd :=_ag .NewXObjectImageFromImage (_ffg ._ffccc ,nil ,_daee );if _edfgd !=nil {_cf .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_edfgd );return _edfgd ;};_ffg ._ebg =_fdad ;return nil ;};func (_ggdc *Invoice )drawAddress (_caeg *InvoiceAddress )[]*StyledParagraph {var _bgaf []*StyledParagraph ;if _caeg .Heading !=""{_cfea :=_fcfc (_ggdc ._ddc );_cfea .SetMargins (0,0,0,7);_cfea .Append (_caeg .Heading );_bgaf =append (_bgaf ,_cfea );};_cefb :=_fcfc (_ggdc ._ffbe );_cefb .SetLineHeight (1.2);_gacea :=_caeg .Separator ;if _gacea ==""{_gacea =_ggdc ._egbf ;};_cfdce :=_caeg .City ;if _caeg .State !=""{if _cfdce !=""{_cfdce +=_gacea ;};_cfdce +=_caeg .State ;};if _caeg .Zip !=""{if _cfdce !=""{_cfdce +=_gacea ;};_cfdce +=_caeg .Zip ;};if _caeg .Name !=""{_cefb .Append (_caeg .Name +"\u000a");};if _caeg .Street !=""{_cefb .Append (_caeg .Street +"\u000a");};if _caeg .Street2 !=""{_cefb .Append (_caeg .Street2 +"\u000a");};if _cfdce !=""{_cefb .Append (_cfdce +"\u000a");};if _caeg .Country !=""{_cefb .Append (_caeg .Country +"\u000a");};_aaaf :=_fcfc (_ggdc ._ffbe );_aaaf .SetLineHeight (1.2);_aaaf .SetMargins (0,0,7,0);if _caeg .Phone !=""{_aaaf .Append (_fg .Sprintf ("\u0050\u0068\u006f\u006e\u0065\u003a\u0020\u0025\u0073\u000a",_caeg .Phone ));};if _caeg .Email !=""{_aaaf .Append (_fg .Sprintf ("\u0045\u006d\u0061\u0069\u006c\u003a\u0020\u0025\u0073\u000a",_caeg .Email ));};_bgaf =append (_bgaf ,_cefb ,_aaaf );return _bgaf ;};func _afef (_baec ,_bfcff ,_egbda float64 )(_gfe ,_gfcd ,_adeb ,_badb float64 ){if _egbda ==0{return 0,0,_baec ,_bfcff ;};_gagb :=_ba .Path {Points :[]_ba .Point {_ba .NewPoint (0,0).Rotate (_egbda ),_ba .NewPoint (_baec ,0).Rotate (_egbda ),_ba .NewPoint (0,_bfcff ).Rotate (_egbda ),_ba .NewPoint (_baec ,_bfcff ).Rotate (_egbda )}}.GetBoundingBox ();return _gagb .X ,_gagb .Y ,_gagb .Width ,_gagb .Height ;};

// Logo returns the logo of the invoice.
func (_dbcgg *Invoice )Logo ()*Image {return _dbcgg ._geff };

// NewList creates a new list.
func (_fbag *Creator )NewList ()*List {return _ggcc (_fbag .NewTextStyle ())};

// RotatedSize returns the width and height of the rotated block.
func (_dgf *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_fe ,_df :=_afef (_dgf ._dbc ,_dgf ._fd ,_dgf ._dd );return _fe ,_df ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_gefdec *TOC )SetLineSeparatorStyle (style TextStyle ){_gefdec ._eaaa =style };func _bgec (_dgdb []byte )(*Image ,error ){_efac :=_b .NewReader (_dgdb );_defgf ,_bbae :=_ag .ImageHandling .Read (_efac );if _bbae !=nil {_cf .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bbae );return nil ,_bbae ;};return _ecbe (_defgf );};

// NewImage create a new image from a unidoc image (model.Image).
func (_bgbb *Creator )NewImage (img *_ag .Image )(*Image ,error ){return _ecbe (img )};

// SetInline sets the inline mode of the division.
func (_gefg *Division )SetInline (inline bool ){_gefg ._ggag =inline };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_bbba *Creator )MoveTo (x ,y float64 ){_bbba ._dbf .X =x ;_bbba ._dbf .Y =y };

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_adge *Invoice )SetAddressStyle (style TextStyle ){_adge ._ffbe =style };type margins struct{_eeaf float64 ;_edc float64 ;_gdd float64 ;_fged float64 ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_fgf *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fgf ._fda ._eeaf ,_fgf ._fda ._edc ,_fgf ._fda ._gdd ,_fgf ._fda ._fged ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_aaad *Invoice )TotalLines ()[][2]*InvoiceCell {_bgce :=[][2]*InvoiceCell {_aaad ._ffff };_bgce =append (_bgce ,_aaad ._cdfd ...);return append (_bgce ,_aaad ._fadd );};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_bafe []*_ag .PdfPage ;_eea map[*_ag .PdfPage ]*Block ;_cdc *_ag .PdfPage ;_afbd PageSize ;_dbf DrawContext ;_cffe margins ;_efa ,_ddbb float64 ;_baeg int ;_fed func (_cdbc FrontpageFunctionArgs );_ecag func (_fcc *TOC )error ;_cdcc func (_cfcc *Block ,_ggec HeaderFunctionArgs );_eeg func (_ffcc *Block ,_dgff FooterFunctionArgs );_aea func (_afgf *_ag .PdfWriter )error ;_ggb bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_bgg *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_bbef *_ag .Outline ;_eaad *_ag .PdfOutlineTreeNode ;_dddb *_ag .PdfAcroForm ;_adgb _db .PdfObject ;_fgfg _ag .Optimizer ;_ddf []*_ag .PdfFont ;_geee *_ag .PdfFont ;_fcca *_ag .PdfFont ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_dde *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _cefbf (number ,title ,page ,level ,style );};

// NewTable create a new Table with a specified number of columns.
func (_bafea *Creator )NewTable (cols int )*Table {return _afae (cols )};func _cdge (_gefb *_ag .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_gefb ,FontSize :10};};

// NewColumn returns a new column for the line items invoice table.
func (_cccg *Invoice )NewColumn (description string )*InvoiceCell {return _cccg .newColumn (description ,CellHorizontalAlignmentLeft );};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_aadfc *Invoice )Sections ()[][2]string {return _aadfc ._cbbc };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_cacb *StyledParagraph )SetWidth (width float64 ){_cacb ._bbbb =width ;_cacb .wrapText ()};func _gcce (_beeb *Block ,_cfggb *StyledParagraph ,_cfag [][]*TextChunk ,_bgad DrawContext )(DrawContext ,[][]*TextChunk ,error ){_ffbee :=1;_edfa :=_db .PdfObjectName (_fg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ffbee ));for _beeb ._af .HasFontByName (_edfa ){_ffbee ++;_edfa =_db .PdfObjectName (_fg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ffbee ));};_bbgf :=_beeb ._af .SetFontByName (_edfa ,_cfggb ._dbgcb .Font .ToPdfObject ());if _bbgf !=nil {return _bgad ,nil ,_bbgf ;};_ffbee ++;_eefb :=_edfa ;_gdab :=_cfggb ._dbgcb .FontSize ;_beebe :=_cfggb ._agbgd .isRelative ();var _bfad [][]_db .PdfObjectName ;var _ebefa float64 ;var _gffe [][]*TextChunk ;var _fgdec float64 ;for _ebbe ,_egca :=range _cfag {var _adfeg []_db .PdfObjectName ;var _edba float64 ;for _ ,_eeee :=range _egca {_fcgfc :=_eeee .Style ;if _ebbe ==0&&_fcgfc .FontSize > _ebefa {_ebefa =_fcgfc .FontSize ;};if _fcgfc .FontSize > _edba {_edba =_fcgfc .FontSize ;};_edfa =_db .PdfObjectName (_fg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ffbee ));_fbgc :=_beeb ._af .SetFontByName (_edfa ,_fcgfc .Font .ToPdfObject ());if _fbgc !=nil {return _bgad ,nil ,_fbgc ;};_adfeg =append (_adfeg ,_edfa );_ffbee ++;};_edba *=_cfggb ._dcde ;if _beebe &&_fgdec +_edba > _bgad .Height {_gffe =_cfag [_ebbe :];_cfag =_cfag [:_ebbe ];break ;};_fgdec +=_edba ;_bfad =append (_bfad ,_adfeg );};_caafb :=_ee .NewContentCreator ();_caafb .Add_q ();_gbfa :=_bgad .PageHeight -_bgad .Y -_ebefa *_cfggb ._dcde ;_caafb .Translate (_bgad .X ,_gbfa );if _cfggb ._dfega !=0{_caafb .RotateDeg (_cfggb ._dfega );};_caafb .Add_BT ();_ffcfg :=_gbfa ;for _cgdd ,_cedd :=range _cfag {_daaba :=_bgad .X ;if _cgdd !=0{_caafb .Add_Tstar ();};_fbeb :=_cgdd ==len (_cfag )-1;var (_cgfac float64 ;_abcdd float64 ;_bgccd float64 ;_cbda uint ;);var _cbdb []float64 ;for _ ,_ebed :=range _cedd {_edcb :=&_ebed .Style ;if _edcb .FontSize > _abcdd {_abcdd =_edcb .FontSize ;};_fcee ,_efda :=_edcb .Font .GetRuneMetrics (' ');if !_efda {return _bgad ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _acdea uint ;var _efdag float64 ;_fcb :=len (_ebed .Text );for _gbcg ,_gadc :=range _ebed .Text {if _gadc ==' '{_acdea ++;continue ;};if _gadc =='\u000A'{continue ;};_bedgb ,_ecge :=_edcb .Font .GetRuneMetrics (_gadc );if !_ecge {_cf .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_gadc );return _bgad ,nil ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_efdag +=_edcb .FontSize *_bedgb .Wx ;if _gbcg !=_fcb -1{_efdag +=_edcb .CharSpacing *1000.0;};};_cbdb =append (_cbdb ,_efdag );_cgfac +=_efdag ;_bgccd +=float64 (_acdea )*_fcee .Wx *_edcb .FontSize ;_cbda +=_acdea ;};_abcdd *=_cfggb ._dcde ;var _fbbb []_db .PdfObject ;_ebbd :=_cfggb ._bbbb *1000.0;if _cfggb ._ade ==TextAlignmentJustify {if _cbda > 0&&!_fbeb {_bgccd =(_ebbd -_cgfac )/float64 (_cbda )/_gdab ;};}else if _cfggb ._ade ==TextAlignmentCenter {_gdga :=(_ebbd -_cgfac -_bgccd )/2;_fgebc :=_gdga /_gdab ;_fbbb =append (_fbbb ,_db .MakeFloat (-_fgebc ));_daaba +=_gdga /1000.0;}else if _cfggb ._ade ==TextAlignmentRight {_aggeg :=(_ebbd -_cgfac -_bgccd );_cadf :=_aggeg /_gdab ;_fbbb =append (_fbbb ,_db .MakeFloat (-_cadf ));_daaba +=_aggeg /1000.0;};if len (_fbbb )> 0{_caafb .Add_Tf (_eefb ,_gdab ).Add_TL (_gdab *_cfggb ._dcde ).Add_TJ (_fbbb ...);};for _dgfe ,_gaag :=range _cedd {_dbeg :=&_gaag .Style ;_fagb ,_cdde ,_gfcge :=_dbeg .Color .ToRGB ();_gbfb :=_eefb ;_ccbgd :=_gdab ;_caafb .Add_Tr (int64 (_dbeg .RenderingMode ));_caafb .Add_Tc (_dbeg .CharSpacing );if _cfggb ._ade !=TextAlignmentJustify ||_fbeb {_bbdga ,_egdc :=_dbeg .Font .GetRuneMetrics (' ');if !_egdc {return _bgad ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_gbfb =_bfad [_cgdd ][_dgfe ];_ccbgd =_dbeg .FontSize ;_bgccd =_bbdga .Wx ;};_bbgb :=_dbeg .Font .Encoder ();var _bcea []byte ;for _ ,_dddcf :=range _gaag .Text {if _fagb =='\u000A'{continue ;};if _dddcf ==' '{if len (_bcea )> 0{_caafb .Add_rg (_fagb ,_cdde ,_gfcge ).Add_Tf (_bfad [_cgdd ][_dgfe ],_dbeg .FontSize ).Add_TL (_dbeg .FontSize *_cfggb ._dcde ).Add_TJ ([]_db .PdfObject {_db .MakeStringFromBytes (_bcea )}...);_bcea =nil ;};_caafb .Add_Tf (_gbfb ,_ccbgd ).Add_TL (_ccbgd *_cfggb ._dcde ).Add_TJ ([]_db .PdfObject {_db .MakeFloat (-_bgccd )}...);_cbdb [_dgfe ]+=_bgccd *_ccbgd ;}else {if _ ,_bgbf :=_bbgb .RuneToCharcode (_dddcf );!_bgbf {_cf .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_dddcf ,_dddcf );continue ;};_bcea =append (_bcea ,_bbgb .Encode (string (_dddcf ))...);};};if len (_bcea )> 0{_caafb .Add_rg (_fagb ,_cdde ,_gfcge ).Add_Tf (_bfad [_cgdd ][_dgfe ],_dbeg .FontSize ).Add_TL (_dbeg .FontSize *_cfggb ._dcde ).Add_TJ ([]_db .PdfObject {_db .MakeStringFromBytes (_bcea )}...);};_deeb :=_cbdb [_dgfe ]/1000.0;if _gaag ._eaddb !=nil {var _fefa *_db .PdfObjectArray ;if !_gaag ._faad {switch _dfcb :=_gaag ._eaddb .GetContext ().(type ){case *_ag .PdfAnnotationLink :_fefa =_db .MakeArray ();_dfcb .Rect =_fefa ;_dfgde ,_daffe :=_dfcb .Dest .(*_db .PdfObjectArray );if _daffe &&_dfgde .Len ()==5{_bdgg ,_ecaga :=_dfgde .Get (1).(*_db .PdfObjectName );if _ecaga &&_bdgg .String ()=="\u0058\u0059\u005a"{_agde ,_ffde :=_db .GetNumberAsFloat (_dfgde .Get (3));if _ffde ==nil {_dfgde .Set (3,_db .MakeFloat (_bgad .PageHeight -_agde ));};};};};_gaag ._faad =true ;};if _fefa !=nil {_fefag :=_ba .NewPoint (_daaba -_bgad .X ,_ffcfg -_gbfa ).Rotate (_cfggb ._dfega );_fefag .X +=_bgad .X ;_fefag .Y +=_gbfa ;_eddc ,_aeac ,_begg ,_dbbg :=_afef (_deeb ,_abcdd ,_cfggb ._dfega );_fefag .X +=_eddc ;_fefag .Y +=_aeac ;_fefa .Clear ();_fefa .Append (_db .MakeFloat (_fefag .X ));_fefa .Append (_db .MakeFloat (_fefag .Y ));_fefa .Append (_db .MakeFloat (_fefag .X +_begg ));_fefa .Append (_db .MakeFloat (_fefag .Y +_dbbg ));};_beeb .AddAnnotation (_gaag ._eaddb );};_daaba +=_deeb ;_caafb .Add_Tr (int64 (TextRenderingModeFill ));_caafb .Add_Tc (0);};_ffcfg -=_abcdd ;};_caafb .Add_ET ();_caafb .Add_Q ();_gafg :=_caafb .Operations ();_gafg .WrapIfNeeded ();_beeb .addContents (_gafg );if _beebe {_eacd :=_fgdec +_cfggb ._cddd ._fged ;_bgad .Y +=_eacd ;_bgad .Height -=_eacd ;if _bgad .Inline {_bgad .X +=_cfggb .Width ()+_cfggb ._cddd ._edc ;};};return _bgad ,_gffe ,nil ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_gfb *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aa :=_ee .NewContentCreator ();_cc ,_bbc :=_gfb .Width (),_gfb .Height ();if _gfb ._bc .isRelative (){_aa .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_bbc );}else {_aa .Translate (_gfb ._ga ,ctx .PageHeight -_gfb ._ad -_bbc );};_dbcc :=_bbc ;if _gfb ._dd !=0{_aa .Translate (_cc /2,_bbc /2);_aa .RotateDeg (_gfb ._dd );_aa .Translate (-_cc /2,-_bbc /2);_ ,_dbcc =_gfb .RotatedSize ();};if _gfb ._bc .isRelative (){ctx .Y +=_dbcc ;};_bbe :=_gfb .duplicate ();_gfba :=append (*_aa .Operations (),*_bbe ._ca ...);_gfba .WrapIfNeeded ();_bbe ._ca =&_gfba ;return []*Block {_bbe },ctx ,nil ;};func (_acde *Invoice )generateTotalBlocks (_gaa DrawContext )([]*Block ,DrawContext ,error ){_dcaf :=_afae (4);_dcaf .SetMargins (0,0,10,10);_efdb :=[][2]*InvoiceCell {_acde ._ffff };_efdb =append (_efdb ,_acde ._cdfd ...);_efdb =append (_efdb ,_acde ._fadd );for _ ,_adce :=range _efdb {_ggbfe ,_fcf :=_adce [0],_adce [1];if _fcf .Value ==""{continue ;};_dcaf .SkipCells (2);_egfg :=_dcaf .NewCell ();_egfg .SetBackgroundColor (_ggbfe .BackgroundColor );_egfg .SetHorizontalAlignment (_fcf .Alignment );_acde .setCellBorder (_egfg ,_ggbfe );_cfcf :=_fcfc (_ggbfe .TextStyle );_cfcf .SetMargins (0,0,2,1);_cfcf .Append (_ggbfe .Value );_egfg .SetContent (_cfcf );_egfg =_dcaf .NewCell ();_egfg .SetBackgroundColor (_fcf .BackgroundColor );_egfg .SetHorizontalAlignment (_fcf .Alignment );_acde .setCellBorder (_egfg ,_ggbfe );_cfcf =_fcfc (_fcf .TextStyle );_cfcf .SetMargins (0,0,2,1);_cfcf .Append (_fcf .Value );_egfg .SetContent (_cfcf );};return _dcaf .GeneratePageBlocks (_gaa );};

// GetRowHeight returns the height of the specified row.
func (_bgcda *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_bgcda ._deaf ){return 0,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _bgcda ._deaf [row -1],nil ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_fdgd *StyledParagraph )Insert (index uint ,text string )*TextChunk {_cfef :=uint (len (_fdgd ._bdee ));if index > _cfef {index =_cfef ;};_ecee :=NewTextChunk (text ,_fdgd ._dbgcb );_fdgd ._bdee =append (_fdgd ._bdee [:index ],append ([]*TextChunk {_ecee },_fdgd ._bdee [index :]...)...);_fdgd .wrapText ();return _ecee ;};func (_bdeg *StyledParagraph )getTextLineWidth (_eacfa []*TextChunk )float64 {var _ecfa float64 ;_gaaa :=len (_eacfa );for _ccdbb ,_cdbf :=range _eacfa {_bbdge :=&_cdbf .Style ;_cdgc :=len (_cdbf .Text );for _fbcd ,_daab :=range _cdbf .Text {if _daab =='\u000A'{continue ;};_fea ,_ggca :=_bbdge .Font .GetRuneMetrics (_daab );if !_ggca {_cf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_daab );return -1;};_ecfa +=_bbdge .FontSize *_fea .Wx ;if _daab !=' '&&(_ccdbb !=_gaaa -1||_fbcd !=_cdgc -1){_ecfa +=_bbdge .CharSpacing *1000.0;};};};return _ecfa ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_bfgb *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_bfgb ._bgg =toc ;};

// NewCell returns a new invoice table cell.
func (_aff *Invoice )NewCell (value string )*InvoiceCell {return _aff .newCell (value ,_aff .NewCellProps ());};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_bbeca *Image )SetWidth (w float64 ){_bbeca ._cbaaa =w };func (_bffb *Image )rotatedSize ()(float64 ,float64 ){_babb :=_bffb ._cbaaa ;_fbge :=_bffb ._efdd ;_cdcb :=_bffb ._edfe ;if _cdcb ==0{return _babb ,_fbge ;};_ggff :=_ba .Path {Points :[]_ba .Point {_ba .NewPoint (0,0).Rotate (_cdcb ),_ba .NewPoint (_babb ,0).Rotate (_cdcb ),_ba .NewPoint (0,_fbge ).Rotate (_cdcb ),_ba .NewPoint (_babb ,_fbge ).Rotate (_cdcb )}}.GetBoundingBox ();return _ggff .Width ,_ggff .Height ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_gagg int ;_cdfb int ;_fgaeg int ;_fgddf []float64 ;_deaf []float64 ;_aadd float64 ;_effba []*TableCell ;_ccfd positioning ;_dbbed ,_ecdb float64 ;_gdccd margins ;_abce bool ;_aefd int ;_fead int ;};

// NewPageBreak create a new page break.
func (_caad *Creator )NewPageBreak ()*PageBreak {return _ffbc ()};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SkipCells skips over a specified number of cells in the table.
func (_fgabc *Table )SkipCells (num int ){if num < 0{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_fgabc ._fgaeg +=num ;};func _aagg (_eaff *Block ,_afba *Paragraph ,_bbdbg DrawContext )(DrawContext ,error ){_fdaag :=1;_fccc :=_db .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ea .Itoa (_fdaag ));for _eaff ._af .HasFontByName (_fccc ){_fdaag ++;_fccc =_db .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ea .Itoa (_fdaag ));};_dgcad :=_eaff ._af .SetFontByName (_fccc ,_afba ._gbgeb .ToPdfObject ());if _dgcad !=nil {return _bbdbg ,_dgcad ;};_afba .wrapText ();_bfcb :=_ee .NewContentCreator ();_bfcb .Add_q ();_bggd :=_bbdbg .PageHeight -_bbdbg .Y -_afba ._gcbgg *_afba ._abcd ;_bfcb .Translate (_bbdbg .X ,_bggd );if _afba ._adga !=0{_bfcb .RotateDeg (_afba ._adga );};_bfcb .Add_BT ().Add_rg (_afba ._acg .R (),_afba ._acg .G (),_afba ._acg .B ()).Add_Tf (_fccc ,_afba ._gcbgg ).Add_TL (_afba ._gcbgg *_afba ._abcd );for _aebf ,_bebee :=range _afba ._cafe {if _aebf !=0{_bfcb .Add_Tstar ();};_cbce :=[]rune (_bebee );_aggc :=0.0;_eaec :=0;for _cbde ,_cfbc :=range _cbce {if _cfbc ==' '{_eaec ++;continue ;};if _cfbc =='\u000A'{continue ;};_gcef ,_afde :=_afba ._gbgeb .GetRuneMetrics (_cfbc );if !_afde {_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_cbde ,_cfbc ,_cfbc ,_afba ._gbgeb .BaseFont (),_afba ._gbgeb .Subtype ());return _bbdbg ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_aggc +=_afba ._gcbgg *_gcef .Wx ;};var _cddg []_db .PdfObject ;_afca ,_ffba :=_afba ._gbgeb .GetRuneMetrics (' ');if !_ffba {return _bbdbg ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_bgcd :=_afca .Wx ;switch _afba ._bcef {case TextAlignmentJustify :if _eaec > 0&&_aebf < len (_afba ._cafe )-1{_bgcd =(_afba ._edfd *1000.0-_aggc )/float64 (_eaec )/_afba ._gcbgg ;};case TextAlignmentCenter :_bcbc :=_aggc +float64 (_eaec )*_bgcd *_afba ._gcbgg ;_cdefb :=(_afba ._edfd *1000.0-_bcbc )/2/_afba ._gcbgg ;_cddg =append (_cddg ,_db .MakeFloat (-_cdefb ));case TextAlignmentRight :_beea :=_aggc +float64 (_eaec )*_bgcd *_afba ._gcbgg ;_dcefd :=(_afba ._edfd *1000.0-_beea )/_afba ._gcbgg ;_cddg =append (_cddg ,_db .MakeFloat (-_dcefd ));};_dcge :=_afba ._gbgeb .Encoder ();var _bgffg []byte ;for _ ,_egfdd :=range _cbce {if _egfdd =='\u000A'{continue ;};if _egfdd ==' '{if len (_bgffg )> 0{_cddg =append (_cddg ,_db .MakeStringFromBytes (_bgffg ));_bgffg =nil ;};_cddg =append (_cddg ,_db .MakeFloat (-_bgcd ));}else {if _ ,_aegde :=_dcge .RuneToCharcode (_egfdd );!_aegde {_cf .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_egfdd ,_egfdd );continue ;};_bgffg =append (_bgffg ,_dcge .Encode (string (_egfdd ))...);};};if len (_bgffg )> 0{_cddg =append (_cddg ,_db .MakeStringFromBytes (_bgffg ));};_bfcb .Add_TJ (_cddg ...);};_bfcb .Add_ET ();_bfcb .Add_Q ();_baea :=_bfcb .Operations ();_baea .WrapIfNeeded ();_eaff .addContents (_baea );if _afba ._ddef .isRelative (){_bagf :=_afba .Height ()+_afba ._adag ._fged ;_bbdbg .Y +=_bagf ;_bbdbg .Height -=_bagf ;if _bbdbg .Inline {_bbdbg .X +=_afba .Width ()+_afba ._adag ._edc ;};};return _bbdbg ,nil ;};

// SetWidthLeft sets border width for left.
func (_ffc *border )SetWidthLeft (bw float64 ){_ffc ._dda =bw };

// SetMargins sets the Paragraph's margins.
func (_afbb *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_afbb ._adag ._eeaf =left ;_afbb ._adag ._edc =right ;_afbb ._adag ._gdd =top ;_afbb ._adag ._fged =bottom ;};func (_ccda *Invoice )setCellBorder (_eaadc *TableCell ,_gbc *InvoiceCell ){for _ ,_gfcab :=range _gbc .BorderSides {_eaadc .SetBorder (_gfcab ,CellBorderStyleSingle ,_gbc .BorderWidth );};_eaadc .SetBorderColor (_gbc .BorderColor );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fccb *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _cffec float64 ;var _ffca []*StyledParagraph ;for _ ,_dec :=range _fccb ._bbdg {_aada :=_fcfc (_fccb ._cbee );_aada .SetEnableWrap (false );_aada .SetTextAlignment (TextAlignmentRight );_aada .Append (_dec ._gbff .Text ).Style =_dec ._gbff .Style ;_cdef :=_aada .getTextWidth ()/1000.0/ctx .Width ;if _cffec < _cdef {_cffec =_cdef ;};_ffca =append (_ffca ,_aada );};_abdca :=_afae (2);_abdca .SetColumnWidths (_cffec ,1-_cffec );_abdca .SetMargins (_fccb ._deabg ,0,0,0);for _agbe ,_ceab :=range _fccb ._bbdg {_dgfdc :=_abdca .NewCell ();_dgfdc .SetIndent (0);_dgfdc .SetContent (_ffca [_agbe ]);_dgfdc =_abdca .NewCell ();_dgfdc .SetIndent (0);_dgfdc .SetContent (_ceab ._cdfe );};return _abdca .GeneratePageBlocks (ctx );};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_fffg *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_fffg .Text },nil ;};var _bacc []string ;var _fgcb []rune ;var _ebdee float64 ;var _dedd []float64 ;_gbeg :=_fffg .Style ;_cfcg :=[]rune (_fffg .Text );for _ ,_fbfe :=range _cfcg {if _fbfe =='\u000A'{_bacc =append (_bacc ,_ed .TrimRightFunc (string (_fgcb ),_ef .IsSpace )+string (_fbfe ));_fgcb =nil ;_ebdee =0;_dedd =nil ;continue ;};_ffdb :=_fbfe ==' ';_gaabc ,_ddbc :=_gbeg .Font .GetRuneMetrics (_fbfe );if !_ddbc {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_fbfe ,_fbfe ,_gbeg .Font .BaseFont (),_gbeg .Font .Subtype ());_cf .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_gbeg .Font );_cf .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_gbeg .Font .Encoder ());return nil ,_a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_fcfca :=_gbeg .FontSize *_gaabc .Wx ;_ffac :=_fcfca ;if !_ffdb {_ffac =_fcfca +_gbeg .CharSpacing *1000.0;};if _ebdee +_fcfca > width *1000.0{_cgccd :=-1;if !_ffdb {for _fbbba :=len (_fgcb )-1;_fbbba >=0;_fbbba --{if _fgcb [_fbbba ]==' '{_cgccd =_fbbba ;break ;};};};_dcac :=string (_fgcb );if _cgccd > 0{_dcac =string (_fgcb [0:_cgccd +1]);_fgcb =append (_fgcb [_cgccd +1:],_fbfe );_dedd =append (_dedd [_cgccd +1:],_ffac );_ebdee =0;for _ ,_ddcce :=range _dedd {_ebdee +=_ddcce ;};}else {if _ffdb {_fgcb =[]rune {};_dedd =[]float64 {};_ebdee =0;}else {_fgcb =[]rune {_fbfe };_dedd =[]float64 {_ffac };_ebdee =_ffac ;};};_bacc =append (_bacc ,_ed .TrimRightFunc (_dcac ,_ef .IsSpace ));}else {_fgcb =append (_fgcb ,_fbfe );_ebdee +=_ffac ;_dedd =append (_dedd ,_ffac );};};if len (_fgcb )> 0{_bacc =append (_bacc ,string (_fgcb ));};return _bacc ,nil ;};

// Width returns the Block's width.
func (_fb *Block )Width ()float64 {return _fb ._dbc };

// DrawWithContext draws the Block using the specified drawing context.
func (_cgae *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_gag ,_ ,_bec :=d .GeneratePageBlocks (ctx );if _bec !=nil {return _bec ;};if len (_gag )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_bde :=range _gag {if _ce :=_cgae .mergeBlocks (_bde );_ce !=nil {return _ce ;};};return nil ;};

// Add adds a new line with the default style to the table of contents.
func (_dedf *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_abee :=_dedf .AddLine (_cefbf (TextChunk {Text :number ,Style :_dedf ._fade },TextChunk {Text :title ,Style :_dedf ._ccbec },TextChunk {Text :page ,Style :_dedf ._deecb },level ,_dedf ._acfaf ));if _abee ==nil {return nil ;};_fdeb :=&_dedf ._degg ;_abee .SetMargins (_fdeb ._eeaf ,_fdeb ._edc ,_fdeb ._gdd ,_fdeb ._fged );_abee .SetLevelOffset (_dedf ._bcagf );_abee .Separator .Text =_dedf ._gbbg ;_abee .Separator .Style =_dedf ._eaaa ;return _abee ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cgdf *Creator )Draw (d Drawable )error {if _cgdf .getActivePage ()==nil {_cgdf .NewPage ();};_cfe ,_egef ,_fgb :=d .GeneratePageBlocks (_cgdf ._dbf );if _fgb !=nil {return _fgb ;};for _efdg ,_edaa :=range _cfe {if _efdg > 0{_cgdf .NewPage ();};_eafaf :=_cgdf .getActivePage ();if _cfca ,_cafa :=_cgdf ._eea [_eafaf ];_cafa {if _bcad :=_cfca .mergeBlocks (_edaa );_bcad !=nil {return _bcad ;};if _egge :=_ebff (_edaa ._af ,_cfca ._af );_egge !=nil {return _egge ;};}else {_cgdf ._eea [_eafaf ]=_edaa ;};};_cgdf ._dbf .X =_egef .X ;_cgdf ._dbf .Y =_egef .Y ;_cgdf ._dbf .Height =_egef .PageHeight -_egef .Y -_egef .Margins ._fged ;return nil ;};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_gbe :=rgbColor {};_gbe ._fced =float64 (r )/255.0;_gbe ._ecca =float64 (g )/255.0;_gbe ._gea =float64 (b )/255.0;return _gbe ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_bfag *TOC )SetShowLinks (showLinks bool ){_bfag ._efced =showLinks };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_cfga *Creator )SetForms (form *_ag .PdfAcroForm )error {_cfga ._dddb =form ;return nil };func _cbfd (_cgac ,_ceea ,_fgeg ,_cac float64 )*Line {_ggab :=&Line {};_ggab ._ccf =_cgac ;_ggab ._ceeg =_ceea ;_ggab ._fega =_fgeg ;_ggab ._agge =_cac ;_ggab ._cdfc =_ag .NewPdfColorDeviceRGB (0,0,0);_ggab ._aedee =1.0;return _ggab ;};

// SetLineHeight sets the line height (1.0 default).
func (_ddaa *Paragraph )SetLineHeight (lineheight float64 ){_ddaa ._abcd =lineheight };func (_fgaf *List )tableHeight (_dcef float64 )float64 {var _ggfda float64 ;for _ ,_geeee :=range _fgaf ._bbdg {switch _ceeaa :=_geeee ._cdfe .(type ){case *Paragraph :_bbcb :=_ceeaa ;if _bbcb ._acbfa {_bbcb .SetWidth (_dcef );};_ggfda +=_bbcb .Height ()+_bbcb ._adag ._fged +_bbcb ._adag ._fged ;_ggfda +=0.5*_bbcb ._gcbgg *_bbcb ._abcd ;case *StyledParagraph :_gcdbb :=_ceeaa ;if _gcdbb ._fdfd {_gcdbb .SetWidth (_dcef );};_ggfda +=_gcdbb .Height ()+_gcdbb ._cddd ._gdd +_gcdbb ._cddd ._fged ;_ggfda +=0.5*_gcdbb .getTextHeight ();default:_ggfda +=_geeee ._cdfe .Height ();};};return _ggfda ;};func (_dbfgc *Invoice )drawSection (_befa ,_dcfg string )[]*StyledParagraph {var _aedb []*StyledParagraph ;if _befa !=""{_ddba :=_fcfc (_dbfgc ._aaeef );_ddba .SetMargins (0,0,0,5);_ddba .Append (_befa );_aedb =append (_aedb ,_ddba );};if _dcfg !=""{_dafa :=_fcfc (_dbfgc ._cagc );_dafa .Append (_dcfg );_aedb =append (_aedb ,_dafa );};return _aedb ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_agd *Creator )RotateDeg (angleDeg int64 )error {_dfgd :=_agd .getActivePage ();if _dfgd ==nil {_cf .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _a .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_cf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _agg int64 ;if _dfgd .Rotate !=nil {_agg =*(_dfgd .Rotate );};_agg +=angleDeg ;_dfgd .Rotate =&_agg ;return nil ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_ebg *_ag .XObjectImage ;_ffccc *_ag .Image ;_edfe float64 ;_cbaaa ,_efdd float64 ;_aggd ,_bgfd float64 ;_cag positioning ;_edca HorizontalAlignment ;_deg float64 ;_fbed float64 ;_eddg float64 ;_cbe margins ;_adb ,_eadc float64 ;_dfe _db .StreamEncoder ;};func (_edcd *StyledParagraph )getTextHeight ()float64 {var _defae float64 ;for _ ,_aebe :=range _edcd ._bdee {_cadd :=_aebe .Style .FontSize *_edcd ._dcde ;if _cadd > _defae {_defae =_cadd ;};};return _defae ;};

// MoveY moves the drawing context to absolute position y.
func (_fddd *Creator )MoveY (y float64 ){_fddd ._dbf .Y =y };

// SetDate sets the date of the invoice.
func (_afbge *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_afbge ._gaed [1].Value =date ;return _afbge ._gaed [0],_afbge ._gaed [1];};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_eee DrawContext )([]*Block ,DrawContext ,error );};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);func (_dfea *TOCLine )prepareParagraph (_cfagf *StyledParagraph ,_aefdg DrawContext ){_gcaag :=_dfea .Title .Text ;if _dfea .Number .Text !=""{_gcaag ="\u0020"+_gcaag ;};_gcaag +="\u0020";_gaaf :=_dfea .Page .Text ;if _gaaf !=""{_gaaf ="\u0020"+_gaaf ;};_cfagf ._bdee =[]*TextChunk {{Text :_dfea .Number .Text ,Style :_dfea .Number .Style ,_eaddb :_dfea .getLineLink ()},{Text :_gcaag ,Style :_dfea .Title .Style ,_eaddb :_dfea .getLineLink ()},{Text :_gaaf ,Style :_dfea .Page .Style ,_eaddb :_dfea .getLineLink ()}};_cfagf .wrapText ();_cfbe :=len (_cfagf ._gabf );if _cfbe ==0{return ;};_gbbe :=_aefdg .Width *1000-_cfagf .getTextLineWidth (_cfagf ._gabf [_cfbe -1]);_geab :=_cfagf .getTextLineWidth ([]*TextChunk {&_dfea .Separator });_eeaag :=int (_gbbe /_geab );_bead :=_ed .Repeat (_dfea .Separator .Text ,_eeaag );_cgcd :=_dfea .Separator .Style ;_bagec :=_cfagf .Insert (2,_bead );_bagec .Style =_cgcd ;_bagec ._eaddb =_dfea .getLineLink ();_gbbe =_gbbe -float64 (_eeaag )*_geab ;if _gbbe > 500{_aggf ,_fbbgg :=_cgcd .Font .GetRuneMetrics (' ');if _fbbgg &&_gbbe > _aggf .Wx {_eegc :=int (_gbbe /_aggf .Wx );if _eegc > 0{_bgdg :=_cgcd ;_bgdg .FontSize =1;_bagec =_cfagf .Insert (2,_ed .Repeat ("\u0020",_eegc ));_bagec .Style =_bgdg ;_bagec ._eaddb =_dfea .getLineLink ();};};};};

// Lines returns all the lines the table of contents has.
func (_adaed *TOC )Lines ()[]*TOCLine {return _adaed ._gegc };

// MoveX moves the drawing context to absolute position x.
func (_agb *Creator )MoveX (x float64 ){_agb ._dbf .X =x };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_efage *List )Add (item VectorDrawable )(*TextChunk ,error ){_cafd :=&listItem {_cdfe :item ,_gbff :_efage ._bag };switch _fdda :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _fdda ._gbca {_fdda ._deabg =15;};default:return nil ,_a .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_efage ._bbdg =append (_efage ._bbdg ,_cafd );return &_cafd ._gbff ,nil ;};func _dedg (_ddeda string ,_fbbg ,_fbbe TextStyle )*TOC {_cbgbf :=_fbbe ;_cbgbf .FontSize =14;_dffb :=_fcfc (_cbgbf );_dffb .SetEnableWrap (true );_dffb .SetTextAlignment (TextAlignmentLeft );_dffb .SetMargins (0,0,0,5);_gabff :=_dffb .Append (_ddeda );_gabff .Style =_cbgbf ;return &TOC {_aefff :_dffb ,_gegc :[]*TOCLine {},_fade :_fbbg ,_ccbec :_fbbg ,_eaaa :_fbbg ,_deecb :_fbbg ,_gbbg :"\u002e",_bcagf :10,_degg :margins {0,0,2,2},_bdfca :_ecfc ,_acfaf :_fbbg ,_efced :true };};func _ddfd (_cbgb int64 ,_fefg ,_ddedb ,_ddgb float64 )*_ag .PdfAnnotation {_bcbe :=_ag .NewPdfAnnotationLink ();_ggdcg :=_ag .NewBorderStyle ();_ggdcg .SetBorderWidth (0);_bcbe .BS =_ggdcg .ToPdfObject ();if _cbgb < 0{_cbgb =0;};_bcbe .Dest =_db .MakeArray (_db .MakeInteger (_cbgb ),_db .MakeName ("\u0058\u0059\u005a"),_db .MakeFloat (_fefg ),_db .MakeFloat (_ddedb ),_db .MakeFloat (_ddgb ));return _bcbe .PdfAnnotation ;};func _aefea (_fgcbe string )*_ag .PdfAnnotation {_fedf :=_ag .NewPdfAnnotationLink ();_caab :=_ag .NewBorderStyle ();_caab .SetBorderWidth (0);_fedf .BS =_caab .ToPdfObject ();_bafb :=_ag .NewPdfActionURI ();_bafb .URI =_db .MakeString (_fgcbe );_fedf .SetAction (_bafb .PdfAction );return _fedf .PdfAnnotation ;};

// SetColorRight sets border color for right.
func (_gcbd *border )SetColorRight (col Color ){_gcbd ._egb =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetPos sets absolute positioning with specified coordinates.
func (_efdc *StyledParagraph )SetPos (x ,y float64 ){_efdc ._agbgd =_aabc ;_efdc ._dacg =x ;_efdc ._abae =y ;};

// Append adds a new text chunk to the paragraph.
func (_gcf *StyledParagraph )Append (text string )*TextChunk {_fgdd :=NewTextChunk (text ,_gcf ._dbgcb );return _gcf .appendChunk (_fgdd );};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_bbdg []*listItem ;_fabf margins ;_bag TextChunk ;_deabg float64 ;_gbca bool ;_dbac positioning ;_cbee TextStyle ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// SetStyleTop sets border style for top side.
func (_eagg *border )SetStyleTop (style CellBorderStyle ){_eagg ._daac =style };func (_ae *Block )duplicate ()*Block {_fdg :=&Block {};*_fdg =*_ae ;_bff :=_ee .ContentStreamOperations {};for _ ,_ec :=range *_ae ._ca {_bff =append (_bff ,_ec );};_fdg ._ca =&_bff ;return _fdg ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_dagg *List )Marker ()*TextChunk {return &_dagg ._bag };

// SetBorderColor sets border color.
func (_dcgec *Rectangle )SetBorderColor (col Color ){_dcgec ._bbdd =_ag .NewPdfColorDeviceRGB (col .ToRGB ());};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_gggd *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_gggd ._beggb =valign };

// SetAngle sets the rotation angle in degrees.
func (_dg *Block )SetAngle (angleDeg float64 ){_dg ._dd =angleDeg };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_aaee float64 ;_ecdf float64 ;_agec float64 ;_dge float64 ;_dbgd *_ag .PdfColorDeviceRGB ;_ggga *_ag .PdfColorDeviceRGB ;_faef float64 ;};func _agdff (_ggbf _d .Image )(*Image ,error ){_aggb ,_eacb :=_ag .ImageHandling .NewImageFromGoImage (_ggbf );if _eacb !=nil {return nil ,_eacb ;};return _ecbe (_aggb );};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_dfedb float64 ;_bdc float64 ;_fffb float64 ;_abaf float64 ;_dgfc *_ag .PdfColorDeviceRGB ;_bbdd *_ag .PdfColorDeviceRGB ;_afcd float64 ;};type rgbColor struct{_fced ,_ecca ,_gea float64 };

// SetText sets the text content of the Paragraph.
func (_fbgef *Paragraph )SetText (text string ){_fbgef ._agae =text };

// SetMargins sets the Table's left, right, top, bottom margins.
func (_cabb *Table )SetMargins (left ,right ,top ,bottom float64 ){_cabb ._gdccd ._eeaf =left ;_cabb ._gdccd ._edc =right ;_cabb ._gdccd ._gdd =top ;_cabb ._gdccd ._fged =bottom ;};

// Indent returns the left offset of the list when nested into another list.
func (_cbaag *List )Indent ()float64 {return _cbaag ._deabg };func (_eggd positioning )isRelative ()bool {return _eggd ==_ecfc };func (_ecde *Paragraph )getMaxLineWidth ()float64 {if _ecde ._cafe ==nil ||len (_ecde ._cafe )==0{_ecde .wrapText ();};var _cgcf float64 ;for _ ,_eebcb :=range _ecde ._cafe {_gaf :=_ecde .getTextLineWidth (_eebcb );if _gaf > _cgcf {_cgcf =_gaf ;};};return _cgcf ;};func _ffbc ()*PageBreak {return &PageBreak {}};const (_ecfc positioning =iota ;_aabc ;);

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_efe *Image )ScaleToWidth (w float64 ){_accg :=_efe ._efdd /_efe ._cbaaa ;_efe ._cbaaa =w ;_efe ._efdd =w *_accg ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;var PPMM =float64 (72*1.0/25.4);

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_egbd *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _a .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_egbd ._abce =true ;_egbd ._aefd =startRow ;_egbd ._fead =endRow ;return nil ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_agbgc *Invoice )BuyerAddress ()*InvoiceAddress {return _agbgc ._ece };

// SetLogo sets the logo of the invoice.
func (_gfad *Invoice )SetLogo (logo *Image ){_gfad ._geff =logo };func _afae (_adff int )*Table {_fbeg :=&Table {_cdfb :_adff ,_aadd :10.0,_fgddf :[]float64 {},_deaf :[]float64 {},_effba :[]*TableCell {}};_fbeg .resetColumnWidths ();return _fbeg ;};

// CurCol returns the currently active cell's column number.
func (_eebg *Table )CurCol ()int {_dacbe :=(_eebg ._fgaeg -1)%(_eebg ._cdfb )+1;return _dacbe };type listItem struct{_cdfe VectorDrawable ;_gbff TextChunk ;};

// SetDueDate sets the due date of the invoice.
func (_eace *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_eace ._ggde [1].Value =dueDate ;return _eace ._ggde [0],_eace ._ggde [1];};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_bdee []*TextChunk ;_dbgcb TextStyle ;_abed TextStyle ;_ade TextAlignment ;_dcde float64 ;_fdfd bool ;_bbbb float64 ;_agbfc bool ;_dfega float64 ;_cddd margins ;_agbgd positioning ;_dacg float64 ;_abae float64 ;_adae float64 ;_ffae float64 ;_gabf [][]*TextChunk ;_aacf func (_edbe *StyledParagraph ,_becdf DrawContext );};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_eafbd *Paragraph )Height ()float64 {_eafbd .wrapText ();return float64 (len (_eafbd ._cafe ))*_eafbd ._abcd *_eafbd ._gcbgg ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_ebdfe *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _ggd (xc ,yc ,width ,height );};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_fgab *Creator )NewImageFromGoImage (goimg _d .Image )(*Image ,error ){return _agdff (goimg )};func (_fgd *Creator )getActivePage ()*_ag .PdfPage {if _fgd ._cdc ==nil {if len (_fgd ._bafe )==0{return nil ;};return _fgd ._bafe [len (_fgd ._bafe )-1];};return _fgd ._cdc ;};

// Width returns the cell's width based on the input draw context.
func (_fccg *TableCell )Width (ctx DrawContext )float64 {_ecce :=float64 (0.0);for _eaeg :=0;_eaeg < _fccg ._eeaa ;_eaeg ++{_ecce +=_fccg ._bcagd ._fgddf [_fccg ._caga +_eaeg -1];};_cbgce :=ctx .Width *_ecce ;return _cbgce ;};type border struct{_gcg float64 ;_dcf float64 ;_eabc float64 ;_aaa float64 ;_gef *_ag .PdfColorDeviceRGB ;_adfb *_ag .PdfColorDeviceRGB ;_dda float64 ;_bdfa *_ag .PdfColorDeviceRGB ;_bce float64 ;_egb *_ag .PdfColorDeviceRGB ;_ffbg float64 ;_cbaa *_ag .PdfColorDeviceRGB ;_ffe float64 ;LineStyle _ba .LineStyle ;_eafa CellBorderStyle ;_gaef CellBorderStyle ;_daac CellBorderStyle ;_bfcf CellBorderStyle ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetText replaces all the text of the paragraph with the specified one.
func (_gaab *StyledParagraph )SetText (text string )*TextChunk {_gaab .Reset ();return _gaab .Append (text );};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_becf *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffea :=ctx ;var _fagd []*Block ;_faba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _becf ._agbgd .isRelative (){ctx .X +=_becf ._cddd ._eeaf ;ctx .Y +=_becf ._cddd ._gdd ;ctx .Width -=_becf ._cddd ._eeaf +_becf ._cddd ._edc ;ctx .Height -=_becf ._cddd ._gdd +_becf ._cddd ._fged ;_becf .SetWidth (ctx .Width );}else {if int (_becf ._bbbb )<=0{_becf .SetWidth (_becf .getTextWidth ());};ctx .X =_becf ._dacg ;ctx .Y =_becf ._abae ;};if _becf ._aacf !=nil {_becf ._aacf (_becf ,ctx );};if _abcb :=_becf .wrapText ();_abcb !=nil {return nil ,ctx ,_abcb ;};_efef :=_becf ._gabf ;for {_gacb ,_cfgd ,_gafd :=_gcce (_faba ,_becf ,_efef ,ctx );if _gafd !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gafd );return nil ,ctx ,_gafd ;};ctx =_gacb ;_fagd =append (_fagd ,_faba );if _efef =_cfgd ;len (_cfgd )==0{break ;};_faba =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gacb =ctx ;_gacb .Y =ctx .Margins ._gdd ;_gacb .X =ctx .Margins ._eeaf +_becf ._cddd ._eeaf ;_gacb .Height =ctx .PageHeight -ctx .Margins ._gdd -ctx .Margins ._fged -_becf ._cddd ._fged ;_gacb .Width =ctx .PageWidth -ctx .Margins ._eeaf -ctx .Margins ._edc -_becf ._cddd ._eeaf -_becf ._cddd ._edc ;ctx =_gacb ;};if _becf ._agbgd .isRelative (){ctx .X -=_becf ._cddd ._eeaf ;ctx .Width =_ffea .Width ;return _fagd ,ctx ,nil ;};return _fagd ,_ffea ,nil ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_gcbb *TOC )SetLineTitleStyle (style TextStyle ){_gcbb ._ccbec =style };

// SetColorLeft sets border color for left.
func (_edf *border )SetColorLeft (col Color ){_edf ._adfb =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};func _ddg (_gac *_ee .ContentStreamOperations ,_eff *_ag .PdfPageResources ,_cfc *_ee .ContentStreamOperations ,_ecd *_ag .PdfPageResources )error {_babc :=map[_db .PdfObjectName ]_db .PdfObjectName {};_fag :=map[_db .PdfObjectName ]_db .PdfObjectName {};_de :=map[_db .PdfObjectName ]_db .PdfObjectName {};_dea :=map[_db .PdfObjectName ]_db .PdfObjectName {};_dcb :=map[_db .PdfObjectName ]_db .PdfObjectName {};_ac :=map[_db .PdfObjectName ]_db .PdfObjectName {};for _ ,_gae :=range *_cfc {switch _gae .Operand {case "\u0044\u006f":if len (_gae .Params )==1{if _ebc ,_cgd :=_gae .Params [0].(*_db .PdfObjectName );_cgd {if _ ,_efc :=_babc [*_ebc ];!_efc {var _fbfc _db .PdfObjectName ;_gfa ,_ :=_ecd .GetXObjectByName (*_ebc );if _gfa !=nil {_fbfc =*_ebc ;for {_cgb ,_ :=_eff .GetXObjectByName (_fbfc );if _cgb ==nil ||_cgb ==_gfa {break ;};_fbfc =_fbfc +"\u0030";};};_eff .SetXObjectByName (_fbfc ,_gfa );_babc [*_ebc ]=_fbfc ;};_cba :=_babc [*_ebc ];_gae .Params [0]=&_cba ;};};case "\u0054\u0066":if len (_gae .Params )==2{if _eeff ,_fad :=_gae .Params [0].(*_db .PdfObjectName );_fad {if _ ,_eaga :=_fag [*_eeff ];!_eaga {_dbb ,_dgg :=_ecd .GetFontByName (*_eeff );_cgg :=*_eeff ;if _dgg &&_dbb !=nil {_cgg =_bgb (_eeff .String (),_dbb ,_eff );};_eff .SetFontByName (_cgg ,_dbb );_fag [*_eeff ]=_cgg ;};_eaf :=_fag [*_eeff ];_gae .Params [0]=&_eaf ;};};case "\u0043\u0053","\u0063\u0073":if len (_gae .Params )==1{if _bfce ,_dfc :=_gae .Params [0].(*_db .PdfObjectName );_dfc {if _ ,_fca :=_de [*_bfce ];!_fca {var _daa _db .PdfObjectName ;_ecb ,_deab :=_ecd .GetColorspaceByName (*_bfce );if _deab {_daa =*_bfce ;for {_fga ,_dff :=_eff .GetColorspaceByName (_daa );if !_dff ||_ecb ==_fga {break ;};_daa =_daa +"\u0030";};_eff .SetColorspaceByName (_daa ,_ecb );_de [*_bfce ]=_daa ;}else {_cf .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _dgd ,_bbge :=_de [*_bfce ];_bbge {_gae .Params [0]=&_dgd ;}else {_cf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_bfce );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gae .Params )==1{if _gg ,_fcd :=_gae .Params [0].(*_db .PdfObjectName );_fcd {if _ ,_fdc :=_dea [*_gg ];!_fdc {var _dfg _db .PdfObjectName ;_bfb ,_aad :=_ecd .GetPatternByName (*_gg );if _aad {_dfg =*_gg ;for {_fgad ,_aga :=_eff .GetPatternByName (_dfg );if !_aga ||_fgad ==_bfb {break ;};_dfg =_dfg +"\u0030";};_abg :=_eff .SetPatternByName (_dfg ,_bfb .ToPdfObject ());if _abg !=nil {return _abg ;};_dea [*_gg ]=_dfg ;};};if _fdcg ,_aec :=_dea [*_gg ];_aec {_gae .Params [0]=&_fdcg ;};};};case "\u0073\u0068":if len (_gae .Params )==1{if _gbg ,_bdg :=_gae .Params [0].(*_db .PdfObjectName );_bdg {if _ ,_fbd :=_dcb [*_gbg ];!_fbd {var _gcc _db .PdfObjectName ;_dgc ,_acb :=_ecd .GetShadingByName (*_gbg );if _acb {_gcc =*_gbg ;for {_cdb ,_bbb :=_eff .GetShadingByName (_gcc );if !_bbb ||_dgc ==_cdb {break ;};_gcc =_gcc +"\u0030";};_fdf :=_eff .SetShadingByName (_gcc ,_dgc .ToPdfObject ());if _fdf !=nil {_cf .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_fdf );return _fdf ;};_dcb [*_gbg ]=_gcc ;}else {_cf .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _gadf ,_bfee :=_dcb [*_gbg ];_bfee {_gae .Params [0]=&_gadf ;}else {_cf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_gbg );};};};case "\u0067\u0073":if len (_gae .Params )==1{if _bafc ,_ecdd :=_gae .Params [0].(*_db .PdfObjectName );_ecdd {if _ ,_ccc :=_ac [*_bafc ];!_ccc {var _fac _db .PdfObjectName ;_fcab ,_aeff :=_ecd .GetExtGState (*_bafc );if _aeff {_fac =*_bafc ;_gab :=1;for {_afe ,_feb :=_eff .GetExtGState (_fac );if !_feb ||_fcab ==_afe {break ;};_fac =_db .PdfObjectName (_fg .Sprintf ("\u0047\u0053\u0025\u0064",_gab ));_gab ++;};};_eff .AddExtGState (_fac ,_fcab );_ac [*_bafc ]=_fac ;};_cdd :=_ac [*_bafc ];_gae .Params [0]=&_cdd ;};};};*_gac =append (*_gac ,_gae );};return nil ;};func (_efab *Creator )setActivePage (_acc *_ag .PdfPage ){_efab ._cdc =_acc };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_adc :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_cf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adc ;};var _fcdd ,_edd ,_aefb int ;if len (hexStr )==4{var _gbbf ,_ceac ,_eafdb int ;_dgcae ,_eba :=_fg .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_gbbf ,&_ceac ,&_eafdb );if _eba !=nil {_cf .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_eba );return _adc ;};if _dgcae !=3{_cf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adc ;};_fcdd =_gbbf *16+_gbbf ;_edd =_ceac *16+_ceac ;_aefb =_eafdb *16+_eafdb ;}else {_cge ,_bffd :=_fg .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fcdd ,&_edd ,&_aefb );if _bffd !=nil {_cf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adc ;};if _cge !=3{_cf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_cge );return _adc ;};};_bad :=float64 (_fcdd )/255.0;_cgea :=float64 (_edd )/255.0;_fff :=float64 (_aefb )/255.0;_adc ._fced =_bad ;_adc ._ecca =_cgea ;_adc ._gea =_fff ;return _adc ;};func (_ffa *Chapter )headingNumber ()string {var _aaab string ;if _ffa ._bbec {if _ffa ._bfca !=0{_aaab =_ea .Itoa (_ffa ._bfca )+"\u002e";};if _ffa ._dag !=nil {_cef :=_ffa ._dag .headingNumber ();if _cef !=""{_aaab =_cef +_aaab ;};};};return _aaab ;};

// NewImageFromData creates an Image from image data.
func (_adcd *Creator )NewImageFromData (data []byte )(*Image ,error ){return _bgec (data )};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_ag .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_acdf *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_acdf ._gegc =append (_acdf ._gegc ,line );return line ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_acead *Paragraph )SetColor (col Color ){_aeabc :=_ag .NewPdfColorDeviceRGB (col .ToRGB ());_acead ._acg =*_aeabc ;};

// Rows returns the total number of rows the table has.
func (_fbdg *Table )Rows ()int {return _fbdg ._gagg };

// Reset removes all the text chunks the paragraph contains.
func (_cdbg *StyledParagraph )Reset (){_cdbg ._bdee =[]*TextChunk {}};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_agae string ;_gbgeb *_ag .PdfFont ;_gcbgg float64 ;_abcd float64 ;_acg _ag .PdfColorDeviceRGB ;_bcef TextAlignment ;_acbfa bool ;_edfd float64 ;_fbgea bool ;_adga float64 ;_adag margins ;_ddef positioning ;_dged float64 ;_dbccb float64 ;_cfadb ,_ebag float64 ;_cafe []string ;};func (_cgde *StyledParagraph )getLineHeight (_cfdgd int )(_gbad ,_dgga float64 ){if _cgde ._gabf ==nil ||len (_cgde ._gabf )==0{_cgde .wrapText ();};if _cfdgd < 0||_cfdgd > len (_cgde ._gabf )-1{_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_cfdgd );return 0,0;};_dccg :=_cgde ._gabf [_cfdgd ];for _ ,_cdebd :=range _dccg {_fcfa ,_gdbb :=_cdebd .Style .Font .GetFontDescriptor ();if _gdbb !=nil {_cf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _cfcfd float64 ;if _fcfa !=nil {if _cfcfd ,_gdbb =_fcfa .GetCapHeight ();_gdbb !=nil {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_gdbb );};};if int (_cfcfd )<=0{_cf .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_cfcfd =1000;};_ded :=_cfcfd /1000.0*_cdebd .Style .FontSize *_cgde ._dcde ;if _ded > _gbad {_gbad =_ded ;};_ded =_cgde ._dcde *_cdebd .Style .FontSize ;if _ded > _dgga {_dgga =_ded ;};};return _gbad ,_dgga ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_aeab *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _aeab ._ffff [0],_aeab ._ffff [1]};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_fdac *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_daacg :=ctx ;if _fdac ._bbea .isRelative (){ctx .X +=_fdac ._ede ._eeaf ;ctx .Y +=_fdac ._ede ._gdd ;ctx .Width -=_fdac ._ede ._eeaf +_fdac ._ede ._edc ;ctx .Height -=_fdac ._ede ._gdd ;};_dab ,_cce ,_agf :=_fdac ._ceb .GeneratePageBlocks (ctx );if _agf !=nil {return _dab ,ctx ,_agf ;};ctx =_cce ;_bae :=ctx .X ;_ggfd :=ctx .Y -_fdac ._ceb .Height ();_cfb :=int64 (ctx .Page );_eda :=_fdac .headingNumber ();_feca :=_fdac .headingText ();if _fdac ._ecdg {_ecc :=_fdac ._gga .Add (_eda ,_fdac ._cff ,_ea .FormatInt (_cfb ,10),_fdac ._effc );if _fdac ._gga ._efced {_ecc .SetLink (_cfb ,_bae ,_ggfd );};};if _fdac ._bca ==nil {_fdac ._bca =_ag .NewOutlineItem (_feca ,_ag .NewOutlineDest (_cfb -1,_bae ,_ggfd ));if _fdac ._dag !=nil {_fdac ._dag ._bca .Add (_fdac ._bca );}else {_fdac ._fcgf .Add (_fdac ._bca );};}else {_gda :=&_fdac ._bca .Dest ;_gda .Page =_cfb -1;_gda .X =_bae ;_gda .Y =_ggfd ;};for _ ,_dabd :=range _fdac ._gec {_cfgg ,_eafd ,_dcca :=_dabd .GeneratePageBlocks (ctx );if _dcca !=nil {return _dab ,ctx ,_dcca ;};if len (_cfgg )< 1{continue ;};_dab [len (_dab )-1].mergeBlocks (_cfgg [0]);_dab =append (_dab ,_cfgg [1:]...);ctx =_eafd ;};if _fdac ._bbea .isRelative (){ctx .X =_daacg .X ;};if _fdac ._bbea .isAbsolute (){return _dab ,_daacg ,nil ;};return _dab ,ctx ,nil ;};func (_bgef *TOCLine )getLineLink ()*_ag .PdfAnnotation {if _bgef ._gecf <=0{return nil ;};return _ddfd (_bgef ._gecf -1,_bgef ._aefc ,_bgef ._gaeb ,0);};

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_bb .Max (_bb .Min (r ,1.0),0.0);g =_bb .Max (_bb .Min (g ,1.0),0.0);b =_bb .Max (_bb .Min (b ,1.0),0.0);_defc :=rgbColor {};_defc ._fced =r ;_defc ._ecca =g ;_defc ._gea =b ;return _defc ;};func (_cfa *Creator )newPage ()*_ag .PdfPage {_bbeaa :=_ag .NewPdfPage ();_bfacd :=_cfa ._afbd [0];_fdaa :=_cfa ._afbd [1];_eacf :=_ag .PdfRectangle {Llx :0,Lly :0,Urx :_bfacd ,Ury :_fdaa };_bbeaa .MediaBox =&_eacf ;_cfa ._efa =_bfacd ;_cfa ._ddbb =_fdaa ;_cfa .initContext ();return _bbeaa ;};

// AddPage adds the specified page to the creator.
func (_gcd *Creator )AddPage (page *_ag .PdfPage )error {_ced ,_cedf :=page .GetMediaBox ();if _cedf !=nil {_cf .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_cedf );return _cedf ;};_gcd ._dbf .X =_ced .Llx +_gcd ._cffe ._eeaf ;_gcd ._dbf .Y =_gcd ._cffe ._gdd ;_gcd ._dbf .PageHeight =_ced .Ury -_ced .Lly ;_gcd ._dbf .PageWidth =_ced .Urx -_ced .Llx ;_gcd ._bafe =append (_gcd ._bafe ,page );_gcd ._dbf .Page ++;return nil ;};func _fcfc (_eefg TextStyle )*StyledParagraph {return &StyledParagraph {_bdee :[]*TextChunk {},_dbgcb :_eefg ,_abed :_daad (_eefg .Font ),_dcde :1.0,_ade :TextAlignmentLeft ,_fdfd :true ,_agbfc :true ,_dfega :0,_adae :1,_ffae :1,_agbgd :_ecfc };};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_cead *Chapter )GetHeading ()*Paragraph {return _cead ._ceb };

// SetAngle sets the rotation angle of the text.
func (_egcd *StyledParagraph )SetAngle (angle float64 ){_egcd ._dfega =angle };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_degc *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _degc ._adag ._eeaf ,_degc ._adag ._edc ,_degc ._adag ._gdd ,_degc ._adag ._fged ;};

// SetBorderWidth sets the border width.
func (_bebg *Ellipse )SetBorderWidth (bw float64 ){_bebg ._faef =bw };func (_ega *Invoice )generateInformationBlocks (_dbce DrawContext )([]*Block ,DrawContext ,error ){_dafac :=_fcfc (_ega ._ddebd );_dafac .SetMargins (0,0,0,20);_ccef :=_ega .drawAddress (_ega ._fadf );_ccef =append (_ccef ,_dafac );_ccef =append (_ccef ,_ega .drawAddress (_ega ._ece )...);_eecd :=_gddf ();for _ ,_eeba :=range _ccef {_eecd .Add (_eeba );};_abad :=_ega .drawInformation ();_bdfe :=_afae (2);_bdfe .SetMargins (0,0,25,0);_dccd :=_bdfe .NewCell ();_dccd .SetIndent (0);_dccd .SetContent (_eecd );_dccd =_bdfe .NewCell ();_dccd .SetContent (_abad );return _bdfe .GeneratePageBlocks (_dbce );};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_cbcc *Invoice )SetAddressHeadingStyle (style TextStyle ){_cbcc ._ddc =style };

// SetLevel sets the indentation level of the TOC line.
func (_ebfcag *TOCLine )SetLevel (level uint ){_ebfcag ._bced =level ;_ebfcag ._ebbg ._cddd ._eeaf =_ebfcag ._geaa +float64 (_ebfcag ._bced -1)*_ebfcag ._cdbfa ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_ggg *Creator )CreateTableOfContents (genTOCFunc func (_fbdc *TOC )error ){_ggg ._ecag =genTOCFunc ;};func (_cbcd *Chapter )headingText ()string {_ggc :=_cbcd ._cff ;if _bfg :=_cbcd .headingNumber ();_bfg !=""{_ggc =_fg .Sprintf ("\u0025\u0073\u0020%\u0073",_bfg ,_ggc );};return _ggc ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_bgeg *Paragraph )SetTextAlignment (align TextAlignment ){_bgeg ._bcef =align };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_bcdb *Creator )NewTextStyle ()TextStyle {return _cdge (_bcdb ._geee )};

// LevelOffset returns the amount of space an indentation level occupies.
func (_cbaf *TOCLine )LevelOffset ()float64 {return _cbaf ._cdbfa };

// SetIndent sets the cell's left indent.
func (_ffbgg *TableCell )SetIndent (indent float64 ){_ffbgg ._cbed =indent };

// SetHeight sets the Image's document height to specified h.
func (_fgc *Image )SetHeight (h float64 ){_fgc ._efdd =h };

// SetAngle sets Image rotation angle in degrees.
func (_cddc *Image )SetAngle (angle float64 ){_cddc ._edfe =angle };func (_afadc *Table )newCell (_ccagc int )*TableCell {_afadc ._fgaeg ++;_ffbad :=(_afadc ._fgaeg -1)/_afadc ._cdfb +1;for _ffbad > _afadc ._gagg {_afadc ._gagg ++;_afadc ._deaf =append (_afadc ._deaf ,_afadc ._aadd );};_bcdbd :=(_afadc ._fgaeg -1)%(_afadc ._cdfb )+1;_bbgea :=&TableCell {};_bbgea ._befg =_ffbad ;_bbgea ._caga =_bcdbd ;_bbgea ._ecagc =1;_bbgea ._cbed =5;_bbgea ._gdgaf =CellBorderStyleNone ;_bbgea ._acfa =_ba .LineStyleSolid ;_bbgea ._eecdc =CellHorizontalAlignmentLeft ;_bbgea ._beggb =CellVerticalAlignmentTop ;_bbgea ._defag =0;_bbgea ._efaf =0;_bbgea ._bdfga =0;_bbgea ._fdgc =0;_aadfe :=ColorBlack ;_bbgea ._deeeg =_ag .NewPdfColorDeviceRGB (_aadfe .ToRGB ());_bbgea ._fafe =_ag .NewPdfColorDeviceRGB (_aadfe .ToRGB ());_bbgea ._afdb =_ag .NewPdfColorDeviceRGB (_aadfe .ToRGB ());_bbgea ._baegb =_ag .NewPdfColorDeviceRGB (_aadfe .ToRGB ());if _ccagc < 1{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_ccagc );_ccagc =1;};_dgfeb :=_afadc ._cdfb -(_bbgea ._caga -1);if _ccagc > _dgfeb {_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_ccagc ,_dgfeb );_ccagc =_dgfeb ;};_bbgea ._eeaa =_ccagc ;_afadc ._fgaeg +=_ccagc -1;_afadc ._effba =append (_afadc ._effba ,_bbgea );_bbgea ._bcagd =_afadc ;return _bbgea ;};

// NewDivision returns a new Division container component.
func (_bdd *Creator )NewDivision ()*Division {return _gddf ()};

// SetTotal sets the total of the invoice.
func (_debefd *Invoice )SetTotal (value string ){_debefd ._fadd [1].Value =value };

// GetCoords returns coordinates of border.
func (_dba *border )GetCoords ()(float64 ,float64 ){return _dba ._gcg ,_dba ._dcf };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_ged *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ged ._cbe ._eeaf ,_ged ._cbe ._edc ,_ged ._cbe ._gdd ,_ged ._cbe ._fged ;};func _gddf ()*Division {return &Division {_cfab :[]VectorDrawable {}}};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_gefd *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _efad []*Block ;_eadd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dgce :=ctx ;if _gefd ._ccfd .isAbsolute (){ctx .X =_gefd ._dbbed ;ctx .Y =_gefd ._ecdb ;}else {ctx .X +=_gefd ._gdccd ._eeaf ;ctx .Y +=_gefd ._gdccd ._gdd ;ctx .Width -=_gefd ._gdccd ._eeaf +_gefd ._gdccd ._edc ;ctx .Height -=_gefd ._gdccd ._fged +_gefd ._gdccd ._gdd ;};_aebeg :=ctx .Width ;_gcgd :=ctx .X ;_dffa :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._fged ;_acbfb :=ctx .Height ;_aadc :=0;_ccad :=-1;_cabg :=-1;for _baef ,_dbaa :=range _gefd ._effba {_bddb :=float64 (0.0);for _dcce :=0;_dcce < _dbaa ._eeaa ;_dcce ++{_bddb +=_gefd ._fgddf [_dbaa ._caga +_dcce -1];};_bdfc :=float64 (0.0);for _ddab :=0;_ddab < _dbaa ._caga -1;_ddab ++{_bdfc +=_gefd ._fgddf [_ddab ]*_aebeg ;};_afbc :=float64 (0.0);for _abba :=_aadc ;_abba < _dbaa ._befg -1;_abba ++{_afbc +=_gefd ._deaf [_abba ];};_ccgg :=_bddb *_aebeg ;_fdea :=float64 (0.0);for _eggad :=0;_eggad < _dbaa ._ecagc ;_eggad ++{_fdea +=_gefd ._deaf [_dbaa ._befg +_eggad -1];};if _gefd ._abce {if _dbaa ._befg >=_gefd ._aefd &&_dbaa ._befg <=_gefd ._fead {if _ccad < 0{_ccad =_baef ;};_cabg =_baef ;};};switch _dded :=_dbaa ._egac .(type ){case *Paragraph :_gadb :=_dded ;if _gadb ._acbfa {_gadb .SetWidth (_ccgg -_dbaa ._cbed );};_dafe :=_gadb .Height ()+_gadb ._adag ._fged +_gadb ._adag ._fged ;_dafe +=0.5*_gadb ._gcbgg *_gadb ._abcd ;if _dafe > _fdea {_fecg :=_dafe -_fdea ;_gefd ._deaf [_dbaa ._befg +_dbaa ._ecagc -2]+=_fecg ;};case *StyledParagraph :_gggc :=_dded ;if _gggc ._fdfd {_gggc .SetWidth (_ccgg -_dbaa ._cbed );};_bcda :=_gggc .Height ()+_gggc ._cddd ._gdd +_gggc ._cddd ._fged ;_bcda +=0.5*_gggc .getTextHeight ();if _bcda > _fdea {_ebfc :=_bcda -_fdea ;_gefd ._deaf [_dbaa ._befg +_dbaa ._ecagc -2]+=_ebfc ;};case *Image :_baaf :=_dded ;_dedc :=_baaf .Height ()+_baaf ._cbe ._gdd +_baaf ._cbe ._fged ;if _dedc > _fdea {_cbdg :=_dedc -_fdea ;_gefd ._deaf [_dbaa ._befg +_dbaa ._ecagc -2]+=_cbdg ;};case *Table :_adaa :=_dded ;_ffaf :=_adaa .Height ()+_adaa ._gdccd ._gdd +_adaa ._gdccd ._fged ;if _ffaf > _fdea {_gbfac :=_ffaf -_fdea ;_gefd ._deaf [_dbaa ._befg +_dbaa ._ecagc -2]+=_gbfac ;};case *List :_fabc :=_dded ;_fdadd :=_fabc .tableHeight (_ccgg -_dbaa ._cbed )+_fabc ._fabf ._gdd +_fabc ._fabf ._fged ;if _fdadd > _fdea {_fgddb :=_fdadd -_fdea ;_gefd ._deaf [_dbaa ._befg +_dbaa ._ecagc -2]+=_fgddb ;};case *Division :_gefde :=_dded ;_fece :=ctx ;_fece .X =_bdfc ;_fece .Y =_afbc ;_fece .Width =_ccgg ;_bcfaa ,_ ,_adgaf :=_gefde .GeneratePageBlocks (_fece );if _adgaf !=nil {return nil ,ctx ,_adgaf ;};if len (_bcfaa )> 1{_cfdb :=_fece .Height -_fdea ;if _cfdb > _fdea {_ffce :=_cfdb -_fdea ;_gefd ._deaf [_dbaa ._befg +_dbaa ._ecagc -2]+=_ffce ;};};_fgbe :=_gefde .Height ()+_gefde ._dcg ._gdd +_gefde ._dcg ._fged ;if _fgbe > _fdea {_efadg :=_fgbe -_fdea ;_gefd ._deaf [_dbaa ._befg +_dbaa ._ecagc -2]+=_efadg ;};};};var _cdbeb bool ;var _gfbe ,_ccag int ;for _cfbb :=0;_cfbb < len (_gefd ._effba );_cfbb ++{_bagb :=_gefd ._effba [_cfbb ];_gdgag :=float64 (0.0);for _cgcc :=0;_cgcc < _bagb ._eeaa ;_cgcc ++{_gdgag +=_gefd ._fgddf [_bagb ._caga +_cgcc -1];};_dddfb :=float64 (0.0);for _adbfc :=0;_adbfc < _bagb ._caga -1;_adbfc ++{_dddfb +=_gefd ._fgddf [_adbfc ]*_aebeg ;};_bfbf :=float64 (0.0);for _bedgf :=_aadc ;_bedgf < _bagb ._befg -1;_bedgf ++{_bfbf +=_gefd ._deaf [_bedgf ];};_deac :=_gdgag *_aebeg ;_gcea :=float64 (0.0);for _eeaeb :=0;_eeaeb < _bagb ._ecagc ;_eeaeb ++{_gcea +=_gefd ._deaf [_bagb ._befg +_eeaeb -1];};ctx .Height =_acbfb -_bfbf ;if _gcea > ctx .Height {_efad =append (_efad ,_eadd );_eadd =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gcgd =ctx .Margins ._eeaf ;_dffa =ctx .Margins ._gdd ;ctx .Height =ctx .PageHeight -ctx .Margins ._gdd -ctx .Margins ._fged ;ctx .Page ++;_acbfb =ctx .Height ;_aadc =_bagb ._befg -1;_bfbf =0;if _gefd ._abce &&_ccad >=0{_gfbe =_cfbb ;_cfbb =_ccad -1;_ccag =_aadc ;_aadc =_gefd ._aefd -1;_cdbeb =true ;continue ;};};ctx .Width =_deac ;ctx .X =_gcgd +_dddfb ;ctx .Y =_dffa +_bfbf ;_fdffc :=_fbg (ctx .X ,ctx .Y ,_deac ,_gcea );if _bagb ._bage !=nil {_ffcccf :=_bagb ._bage .R ();_fcddf :=_bagb ._bage .G ();_gcfc :=_bagb ._bage .B ();_fdffc .SetFillColor (ColorRGBFromArithmetic (_ffcccf ,_fcddf ,_gcfc ));};_fdffc .LineStyle =_bagb ._acfa ;_fdffc ._eafa =_bagb ._gdgaf ;_fdffc ._gaef =_bagb ._cbgcf ;_fdffc ._daac =_bagb ._fdaf ;_fdffc ._bfcf =_bagb ._ebde ;if _bagb ._deeeg !=nil {_fdffc .SetColorLeft (ColorRGBFromArithmetic (_bagb ._deeeg .R (),_bagb ._deeeg .G (),_bagb ._deeeg .B ()));};if _bagb ._fafe !=nil {_fdffc .SetColorBottom (ColorRGBFromArithmetic (_bagb ._fafe .R (),_bagb ._fafe .G (),_bagb ._fafe .B ()));};if _bagb ._afdb !=nil {_fdffc .SetColorRight (ColorRGBFromArithmetic (_bagb ._afdb .R (),_bagb ._afdb .G (),_bagb ._afdb .B ()));};if _bagb ._baegb !=nil {_fdffc .SetColorTop (ColorRGBFromArithmetic (_bagb ._baegb .R (),_bagb ._baegb .G (),_bagb ._baegb .B ()));};_fdffc .SetWidthBottom (_bagb ._efaf );_fdffc .SetWidthLeft (_bagb ._defag );_fdffc .SetWidthRight (_bagb ._bdfga );_fdffc .SetWidthTop (_bagb ._fdgc );_edbb :=_eadd .Draw (_fdffc );if _edbb !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_edbb );};if _bagb ._egac !=nil {_gcdg :=_bagb ._egac .Width ();_gbgea :=_bagb ._egac .Height ();_bfacda :=0.0;switch _eefaf :=_bagb ._egac .(type ){case *Paragraph :if _eefaf ._acbfa {_gcdg =_eefaf .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _eefaf ._fdfd {_gcdg =_eefaf .getMaxLineWidth ()/1000.0;};_gbade ,_bcee :=_eefaf .getLineHeight (0);if len (_eefaf ._gabf )==1{_gbgea =_gbade ;}else {_gbgea =_gbgea -_bcee +_gbade ;};_bfacda =_gbade -_bcee ;switch _bagb ._beggb {case CellVerticalAlignmentTop :_bfacda +=_gbade *0.5;case CellVerticalAlignmentBottom :_bfacda -=_gbade *0.5;};case *Table :_gcdg =_deac ;case *List :_gcdg =_deac ;};switch _bagb ._eecdc {case CellHorizontalAlignmentLeft :ctx .X +=_bagb ._cbed ;ctx .Width -=_bagb ._cbed ;case CellHorizontalAlignmentCenter :_ccfa :=_deac -_gcdg ;if _ccfa > 0{ctx .X +=_ccfa /2;ctx .Width -=_ccfa /2;};case CellHorizontalAlignmentRight :if _deac > _gcdg {ctx .X =ctx .X +_deac -_gcdg -_bagb ._cbed ;ctx .Width -=_bagb ._cbed ;};};ctx .Y +=_bfacda ;switch _bagb ._beggb {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_cfcd :=_gcea -_gbgea ;if _cfcd > 0{ctx .Y +=_cfcd /2;ctx .Height -=_cfcd /2;};case CellVerticalAlignmentBottom :if _gcea > _gbgea {ctx .Y =ctx .Y +_gcea -_gbgea ;ctx .Height =_gcea ;};};_aaaa :=_eadd .DrawWithContext (_bagb ._egac ,ctx );if _aaaa !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_aaaa );};ctx .Y -=_bfacda ;};ctx .Y +=_gcea ;ctx .Height -=_gcea ;if _cdbeb &&_cfbb +1> _cabg {_dffa +=_bfbf +_gcea ;_acbfb -=_gcea +_bfbf ;_aadc =_ccag ;_cfbb =_gfbe -1;_cdbeb =false ;};};_efad =append (_efad ,_eadd );if _gefd ._ccfd .isAbsolute (){return _efad ,_dgce ,nil ;};ctx .X =_dgce .X ;ctx .Width =_dgce .Width ;ctx .Y +=_gefd ._gdccd ._fged ;ctx .Height -=_gefd ._gdccd ._fged ;return _efad ,ctx ,nil ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetLineHeight sets the line height (1.0 default).
func (_eacba *StyledParagraph )SetLineHeight (lineheight float64 ){_eacba ._dcde =lineheight };

// Length calculates and returns the line length.
func (_ecddd *Line )Length ()float64 {return _bb .Sqrt (_bb .Pow (_ecddd ._fega -_ecddd ._ccf ,2.0)+_bb .Pow (_ecddd ._agge -_ecddd ._ceeg ,2.0));};

// Add adds a new Drawable to the chapter.
func (_dac *Chapter )Add (d Drawable )error {if Drawable (_dac )==d {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_dac ._gec =append (_dac ._gec ,d );default:_cf .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _a .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_eeea *TableCell )SetContent (vd VectorDrawable )error {switch _bbecf :=vd .(type ){case *Paragraph :if _bbecf ._fbgea {_bbecf ._acbfa =true ;};_eeea ._egac =vd ;case *StyledParagraph :if _bbecf ._agbfc {_bbecf ._fdfd =true ;};_eeea ._egac =vd ;case *Image :_eeea ._egac =vd ;case *Table :_eeea ._egac =vd ;case *List :_eeea ._egac =vd ;case *Division :_eeea ._egac =vd ;default:_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _db .ErrTypeError ;};return nil ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_cebb *Image )GetHorizontalAlignment ()HorizontalAlignment {return _cebb ._edca };

// SetAngle sets the rotation angle of the text.
func (_bbad *Paragraph )SetAngle (angle float64 ){_bbad ._adga =angle };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_dagb *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_aged :=&_dagb ._ebbg ._cddd ;return _dagb ._geaa ,_aged ._edc ,_aged ._gdd ,_aged ._fged ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bbcda *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adcb :=ctx ;_bbda :=[]func (_abbe DrawContext )([]*Block ,DrawContext ,error ){_bbcda .generateHeaderBlocks ,_bbcda .generateInformationBlocks ,_bbcda .generateLineBlocks ,_bbcda .generateTotalBlocks ,_bbcda .generateNoteBlocks };var _dafcc []*Block ;for _ ,_bebe :=range _bbda {_aaabf ,_afead ,_acea :=_bebe (ctx );if _acea !=nil {return _dafcc ,ctx ,_acea ;};if len (_dafcc )==0{_dafcc =_aaabf ;}else if len (_aaabf )> 0{_dafcc [len (_dafcc )-1].mergeBlocks (_aaabf [0]);_dafcc =append (_dafcc ,_aaabf [1:]...);};ctx =_afead ;};if _bbcda ._dfeg .isRelative (){ctx .X =_adcb .X ;};if _bbcda ._dfeg .isAbsolute (){return _dafcc ,_adcb ,nil ;};return _dafcc ,ctx ,nil ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_gbdd *Line )SetColor (col Color ){_gbdd ._cdfc =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetBuyerAddress sets the buyer address of the invoice.
func (_aadf *Invoice )SetBuyerAddress (address *InvoiceAddress ){_aadf ._ece =address };

// Width returns the width of the Paragraph.
func (_caeb *StyledParagraph )Width ()float64 {if _caeb ._fdfd &&int (_caeb ._bbbb )> 0{return _caeb ._bbbb ;};return _caeb .getTextWidth ()/1000.0;};

// SetBorderWidth sets the border width.
func (_dbde *Rectangle )SetBorderWidth (bw float64 ){_dbde ._afcd =bw };

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_egga *Invoice )SetNoteHeadingStyle (style TextStyle ){_egga ._aaeef =style };

// Notes returns the notes section of the invoice as a title-content pair.
func (_babbg *Invoice )Notes ()(string ,string ){return _babbg ._bddd [0],_babbg ._bddd [1]};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetEnableWrap sets the line wrapping enabled flag.
func (_gfcf *StyledParagraph )SetEnableWrap (enableWrap bool ){_gfcf ._fdfd =enableWrap ;_gfcf ._agbfc =false ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_gfbf *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_gfbf ._cdfb {_cf .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gfbf ._fgddf =widths ;return nil ;};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_afc *Ellipse )GetCoords ()(float64 ,float64 ){return _afc ._aaee ,_afc ._ecdf };func _abdf (_febad ,_cadb ,_faag ,_caag float64 )*Rectangle {_gdgf :=&Rectangle {};_gdgf ._dfedb =_febad ;_gdgf ._bdc =_cadb ;_gdgf ._fffb =_faag ;_gdgf ._abaf =_caag ;_gdgf ._bbdd =_ag .NewPdfColorDeviceRGB (0,0,0);_gdgf ._afcd =1.0;return _gdgf ;};

// SetPos sets absolute positioning with specified coordinates.
func (_eeae *Paragraph )SetPos (x ,y float64 ){_eeae ._ddef =_aabc ;_eeae ._dged =x ;_eeae ._dbccb =y };

// SetWidthTop sets border width for top.
func (_efb *border )SetWidthTop (bw float64 ){_efb ._ffe =bw };func (_da *Block )drawToPage (_bab *_ag .PdfPage )error {_cde ,_eed :=_bab .GetAllContentStreams ();if _eed !=nil {return _eed ;};_gca :=_ee .NewContentStreamParser (_cde );_add ,_eed :=_gca .Parse ();if _eed !=nil {return _eed ;};_add .WrapIfNeeded ();if _bab .Resources ==nil {_bab .Resources =_ag .NewPdfPageResources ();};_eed =_ddg (_add ,_bab .Resources ,_da ._ca ,_da ._af );if _eed !=nil {return _eed ;};if _eed =_ebff (_da ._af ,_bab .Resources );_eed !=nil {return _eed ;};_eed =_bab .SetContentStreams ([]string {string (_add .Bytes ())},_db .NewFlateEncoder ());if _eed !=nil {return _eed ;};for _ ,_dbcg :=range _da ._eb {_bab .AddAnnotation (_dbcg );};return nil ;};

// Height returns the total height of all rows.
func (_aeace *Table )Height ()float64 {_dccac :=float64 (0.0);for _ ,_dccdf :=range _aeace ._deaf {_dccac +=_dccdf ;};return _dccac ;};func (_fgfd *Table )resetColumnWidths (){_fgfd ._fgddf =[]float64 {};_feda :=float64 (1.0)/float64 (_fgfd ._cdfb );for _bafg :=0;_bafg < _fgfd ._cdfb ;_bafg ++{_fgfd ._fgddf =append (_fgfd ._fgddf ,_feda );};};

// SetNotes sets the notes section of the invoice.
func (_caed *Invoice )SetNotes (title ,content string ){_caed ._bddd =[2]string {title ,content }};func _geg (_bbd *Chapter ,_fae *TOC ,_fdge *_ag .Outline ,_dcd string ,_dada int ,_cdg TextStyle )*Chapter {var _aaae uint =1;if _bbd !=nil {_aaae =_bbd ._effc +1;};_ebdf :=&Chapter {_bfca :_dada ,_cff :_dcd ,_bbec :true ,_ecdg :true ,_dag :_bbd ,_gga :_fae ,_fcgf :_fdge ,_gec :[]Drawable {},_effc :_aaae };_ggac :=_bcff (_ebdf .headingText (),_cdg );_ggac .SetFont (_cdg .Font );_ggac .SetFontSize (_cdg .FontSize );_ebdf ._ceb =_ggac ;return _ebdf ;};func (_fada *Creator )initContext (){_fada ._dbf .X =_fada ._cffe ._eeaf ;_fada ._dbf .Y =_fada ._cffe ._gdd ;_fada ._dbf .Width =_fada ._efa -_fada ._cffe ._edc -_fada ._cffe ._eeaf ;_fada ._dbf .Height =_fada ._ddbb -_fada ._cffe ._fged -_fada ._cffe ._gdd ;_fada ._dbf .PageHeight =_fada ._ddbb ;_fada ._dbf .PageWidth =_fada ._efa ;_fada ._dbf .Margins =_fada ._cffe ;};

// SkipOver skips over a specified number of rows and cols.
func (_dcba *Table )SkipOver (rows ,cols int ){_eebae :=rows *_dcba ._cdfb +cols -1;if _eebae < 0{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_dcba ._fgaeg +=_eebae ;};

// SetFont sets the Paragraph's font.
func (_eeec *Paragraph )SetFont (font *_ag .PdfFont ){_eeec ._gbgeb =font };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_aefff *StyledParagraph ;_gegc []*TOCLine ;_fade TextStyle ;_ccbec TextStyle ;_eaaa TextStyle ;_deecb TextStyle ;_gbbg string ;_bcagf float64 ;_degg margins ;_bdfca positioning ;_acfaf TextStyle ;_efced bool ;};

// SetBorderColor sets the cell's border color.
func (_ebgc *TableCell )SetBorderColor (col Color ){_ebgc ._deeeg =_ag .NewPdfColorDeviceRGB (col .ToRGB ());_ebgc ._fafe =_ag .NewPdfColorDeviceRGB (col .ToRGB ());_ebgc ._afdb =_ag .NewPdfColorDeviceRGB (col .ToRGB ());_ebgc ._baegb =_ag .NewPdfColorDeviceRGB (col .ToRGB ());};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_cca *Block )Draw (d Drawable )error {_cga :=DrawContext {};_cga .Width =_cca ._dbc ;_cga .Height =_cca ._fd ;_cga .PageWidth =_cca ._dbc ;_cga .PageHeight =_cca ._fd ;_cga .X =0;_cga .Y =0;_bac ,_ ,_fdd :=d .GeneratePageBlocks (_cga );if _fdd !=nil {return _fdd ;};if len (_bac )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_gdf :=range _bac {if _ebd :=_cca .mergeBlocks (_gdf );_ebd !=nil {return _ebd ;};};return nil ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_eeac *Table )MultiColCell (colspan int )*TableCell {return _eeac .newCell (colspan )};

// SetStyleRight sets border style for right side.
func (_efce *border )SetStyleRight (style CellBorderStyle ){_efce ._gaef =style };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_bfca int ;_cff string ;_ceb *Paragraph ;_gec []Drawable ;_bgff int ;_bbec bool ;_ecdg bool ;_bbea positioning ;_beg ,_aba float64 ;_ede margins ;_dag *Chapter ;_gga *TOC ;_fcgf *_ag .Outline ;_bca *_ag .OutlineItem ;_effc uint ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_ebe *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_cffd :=uint (len (_ebe ._gfaf ));if index > _cffd {index =_cffd ;};_becc :=_ebe .NewColumn (description );_ebe ._gfaf =append (_ebe ._gfaf [:index ],append ([]*InvoiceCell {_becc },_ebe ._gfaf [index :]...)...);return _becc ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_cgaf *TOC )SetLineNumberStyle (style TextStyle ){_cgaf ._fade =style };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_dacf *Invoice )Terms ()(string ,string ){return _dacf ._abcc [0],_dacf ._abcc [1]};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_cgdg *Creator )SetPageSize (size PageSize ){_cgdg ._afbd =size ;_cgdg ._efa =size [0];_cgdg ._ddbb =size [1];_cfd :=0.1*_cgdg ._efa ;_cgdg ._cffe ._eeaf =_cfd ;_cgdg ._cffe ._edc =_cfd ;_cgdg ._cffe ._gdd =_cfd ;_cgdg ._cffe ._fged =_cfd ;};

// SetWidth sets line width.
func (_bbce *Curve )SetWidth (width float64 ){_bbce ._dggc =width };

// NewChapter creates a new chapter with the specified title as the heading.
func (_bgd *Creator )NewChapter (title string )*Chapter {_bgd ._baeg ++;_afea :=_bgd .NewTextStyle ();_afea .FontSize =16;return _geg (nil ,_bgd ._bgg ,_bgd ._bbef ,title ,_bgd ._baeg ,_afea );};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_ebbg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_geaa float64 ;_bced uint ;_cdbfa float64 ;_ggbb positioning ;_aefc float64 ;_gaeb float64 ;_gecf int64 ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_ggbe *Invoice )SetTerms (title ,content string ){_ggbe ._abcc =[2]string {title ,content }};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_cded *Invoice )InfoLines ()[][2]*InvoiceCell {_fdacb :=[][2]*InvoiceCell {_cded ._ecagd ,_cded ._gaed ,_cded ._ggde };return append (_fdacb ,_cded ._fgag ...);};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_eagb *Chapter )SetShowNumbering (show bool ){_eagb ._bbec =show ;_eagb ._ceb .SetText (_eagb .headingText ());};

// Cols returns the total number of columns the table has.
func (_bdeeb *Table )Cols ()int {return _bdeeb ._cdfb };func _fbg (_adg ,_fce ,_ccb ,_bbbd float64 )*border {_abf :=&border {};_abf ._gcg =_adg ;_abf ._dcf =_fce ;_abf ._eabc =_ccb ;_abf ._aaa =_bbbd ;_abf ._cbaa =_ag .NewPdfColorDeviceRGB (0,0,0);_abf ._bdfa =_ag .NewPdfColorDeviceRGB (0,0,0);_abf ._adfb =_ag .NewPdfColorDeviceRGB (0,0,0);_abf ._egb =_ag .NewPdfColorDeviceRGB (0,0,0);_abf ._ffe =0;_abf ._bce =0;_abf ._dda =0;_abf ._ffbg =0;_abf .LineStyle =_ba .LineStyleSolid ;return _abf ;};

// SetBackgroundColor sets the cell's background color.
func (_aebb *TableCell )SetBackgroundColor (col Color ){_aebb ._bage =_ag .NewPdfColorDeviceRGB (col .ToRGB ());};

// Text sets the text content of the Paragraph.
func (_dgge *Paragraph )Text ()string {return _dgge ._agae };

// SetStyleLeft sets border style for left side.
func (_edg *border )SetStyleLeft (style CellBorderStyle ){_edg ._eafa =style };

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetOpacity sets opacity for Image.
func (_ebfe *Image )SetOpacity (opacity float64 ){_ebfe ._eddg =opacity };

// SkipRows skips over a specified number of rows in the table.
func (_ffdc *Table )SkipRows (num int ){_febe :=num *_ffdc ._cdfb -1;if _febe < 0{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ffdc ._fgaeg +=_febe ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_gdbbg *TableCell )SetBorderLineStyle (style _ba .LineStyle ){_gdbbg ._acfa =style };func _cbeb (_adgae *_ag .PdfAnnotationLink )*_ag .PdfAnnotationLink {if _adgae ==nil {return nil ;};_aced :=_ag .NewPdfAnnotationLink ();_aced .BS =_adgae .BS ;_aced .A =_adgae .A ;if _dbca ,_bcadf :=_adgae .GetAction ();_bcadf ==nil &&_dbca !=nil {_aced .SetAction (_dbca );};if _gfdf ,_ecdaa :=_adgae .Dest .(*_db .PdfObjectArray );_ecdaa {_aced .Dest =_db .MakeArray (_gfdf .Elements ()...);};return _aced ;};

// SetWidthRight sets border width for right.
func (_dgca *border )SetWidthRight (bw float64 ){_dgca ._ffbg =bw };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_ceda *Image )ScaleToHeight (h float64 ){_cdeb :=_ceda ._cbaaa /_ceda ._efdd ;_ceda ._efdd =h ;_ceda ._cbaaa =h *_cdeb ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gddd *Creator )NewStyledParagraph ()*StyledParagraph {return _fcfc (_gddd .NewTextStyle ())};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);func _daad (_gedc *_ag .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_gedc ,FontSize :10};};

// SetMargins sets the margins TOC line.
func (_bgge *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_bgge ._geaa =left ;_ggdb :=&_bgge ._ebbg ._cddd ;_ggdb ._eeaf =_bgge ._geaa +float64 (_bgge ._bced -1)*_bgge ._cdbfa ;_ggdb ._edc =right ;_ggdb ._gdd =top ;_ggdb ._fged =bottom ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_cdf *Creator )SetOutlineTree (outlineTree *_ag .PdfOutlineTreeNode ){_cdf ._eaad =outlineTree };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_ddbba *TOCLine )SetLink (page int64 ,x ,y float64 ){_ddbba ._aefc =x ;_ddbba ._gaeb =y ;_ddbba ._gecf =page ;_abebd :=_ddbba ._ebbg ._abed .Color ;_ddbba .Number .Style .Color =_abebd ;_ddbba .Title .Style .Color =_abebd ;_ddbba .Separator .Style .Color =_abebd ;_ddbba .Page .Style .Color =_abebd ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_ccdb *Image )SetMargins (left ,right ,top ,bottom float64 ){_ccdb ._cbe ._eeaf =left ;_ccdb ._cbe ._edc =right ;_ccdb ._cbe ._gdd =top ;_ccdb ._cbe ._fged =bottom ;};

// Height returns the Block's height.
func (_gd *Block )Height ()float64 {return _gd ._fd };

// Inline returns whether the inline mode of the division is active.
func (_ggbg *Division )Inline ()bool {return _ggbg ._ggag };

// AddTotalLine adds a new line in the invoice totals table.
func (_cadc *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_edff :=&InvoiceCell {_cadc ._dbfg ,desc };_cfad :=&InvoiceCell {_cadc ._dbfg ,value };_cadc ._cdfd =append (_cadc ._cdfd ,[2]*InvoiceCell {_edff ,_cfad });return _edff ,_cfad ;};func _bgb (_dad string ,_adf _db .PdfObject ,_dgcf *_ag .PdfPageResources )_db .PdfObjectName {_ffb :=_ed .TrimRightFunc (_ed .TrimSpace (_dad ),func (_deb rune )bool {return _ef .IsNumber (_deb )});if _ffb ==""{_ffb ="\u0046\u006f\u006e\u0074";};_dfgc :=0;_dca :=_db .PdfObjectName (_dad );for {_gaea ,_ebda :=_dgcf .GetFontByName (_dca );if !_ebda ||_gaea ==_adf {break ;};_dfgc ++;_dca =_db .PdfObjectName (_fg .Sprintf ("\u0025\u0073\u0025\u0064",_ffb ,_dfgc ));};return _dca ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_egf *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_dgege :=[2]*InvoiceCell {_egf .newCell (description ,_egf ._eaedc ),_egf .newCell (value ,_egf ._eaedc )};_egf ._fgag =append (_egf ._fgag ,_dgege );return _dgege [0],_dgege [1];};

// Scale block by specified factors in the x and y directions.
func (_gc *Block )Scale (sx ,sy float64 ){_cbc :=_ee .NewContentCreator ().Scale (sx ,sy ).Operations ();*_gc ._ca =append (*_cbc ,*_gc ._ca ...);_gc ._ca .WrapIfNeeded ();_gc ._dbc *=sx ;_gc ._fd *=sy ;};var PPI float64 =72;

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dfba *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dfba ._cffe ._eeaf =left ;_dfba ._cffe ._edc =right ;_dfba ._cffe ._gdd =top ;_dfba ._cffe ._fged =bottom ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_bfaa *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_cgf *_ag .PdfWriter )error ){_bfaa ._aea =pdfWriterAccessFunc ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// Lines returns all the rows of the invoice line items table.
func (_cgfa *Invoice )Lines ()[][]*InvoiceCell {return _cgfa ._gff };

// WriteToFile writes the Creator output to file specified by path.
func (_afd *Creator )WriteToFile (outputPath string )error {_afbg ,_abac :=_e .Create (outputPath );if _abac !=nil {return _abac ;};defer _afbg .Close ();return _afd .Write (_afbg );};

// Width returns the current page width.
func (_bda *Creator )Width ()float64 {return _bda ._efa };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_fcda *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_gdgad :=range subtable ._effba {_fbged :=&TableCell {};*_fbged =*_gdgad ;_fbged ._bcagd =_fcda ;_fbged ._caga +=col -1;if _cbfc :=_fcda ._cdfb -(_fbged ._caga -1);_cbfc < _fbged ._eeaa {_fcda ._cdfb +=_fbged ._eeaa -_cbfc ;_fcda .resetColumnWidths ();_cf .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_fcda ._cdfb );};_fbged ._befg +=row -1;_gead :=subtable ._deaf [_gdgad ._befg -1];if _fbged ._befg > _fcda ._gagg {for _fbged ._befg > _fcda ._gagg {_fcda ._gagg ++;_fcda ._deaf =append (_fcda ._deaf ,_fcda ._aadd );};_fcda ._deaf [_fbged ._befg -1]=_gead ;}else {_fcda ._deaf [_fbged ._befg -1]=_bb .Max (_fcda ._deaf [_fbged ._befg -1],_gead );};_fcda ._effba =append (_fcda ._effba ,_fbged );};_f .Slice (_fcda ._effba ,func (_acce ,_fbfbf int )bool {_cfefa :=_fcda ._effba [_acce ]._befg ;_aceb :=_fcda ._effba [_fbfbf ]._befg ;if _cfefa < _aceb {return true ;};if _cfefa > _aceb {return false ;};return _fcda ._effba [_acce ]._caga < _fcda ._effba [_fbfbf ]._caga ;});};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_gcaa *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_adgc :=_ba .Circle {X :_gcaa ._aaee -_gcaa ._agec /2,Y :ctx .PageHeight -_gcaa ._ecdf -_gcaa ._dge /2,Width :_gcaa ._agec ,Height :_gcaa ._dge ,Opacity :1.0,BorderWidth :_gcaa ._faef };if _gcaa ._dbgd !=nil {_adgc .FillEnabled =true ;_adgc .FillColor =_gcaa ._dbgd ;};if _gcaa ._ggga !=nil {_adgc .BorderEnabled =true ;_adgc .BorderColor =_gcaa ._ggga ;_adgc .BorderWidth =_gcaa ._faef ;};_fgde ,_ ,_dfgdf :=_adgc .Draw ("");if _dfgdf !=nil {return nil ,ctx ,_dfgdf ;};_dfgdf =_cdeg .addContentsByString (string (_fgde ));if _dfgdf !=nil {return nil ,ctx ,_dfgdf ;};return []*Block {_cdeg },ctx ,nil ;};func (_fecf *Paragraph )wrapText ()error {if !_fecf ._acbfa ||int (_fecf ._edfd )<=0{_fecf ._cafe =[]string {_fecf ._agae };return nil ;};_dece :=NewTextChunk (_fecf ._agae ,TextStyle {Font :_fecf ._gbgeb ,FontSize :_fecf ._gcbgg });_faf ,_cgbcdf :=_dece .Wrap (_fecf ._edfd );if _cgbcdf !=nil {return _cgbcdf ;};_fecf ._cafe =_faf ;return nil ;};

// SetFillColor sets the fill color.
func (_fdb *Ellipse )SetFillColor (col Color ){_fdb ._dbgd =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// AppendCurve appends a Bezier curve to the filled curve.
func (_fbef *FilledCurve )AppendCurve (curve _ba .CubicBezierCurve )*FilledCurve {_fbef ._abeb =append (_fbef ._abeb ,curve );return _fbef ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_deee *Invoice )AddressStyle ()TextStyle {return _deee ._ffbe };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_ccdc *Paragraph )SetWidth (width float64 ){_ccdc ._edfd =width ;_ccdc .wrapText ()};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_cgdgb *TOC )SetLineSeparator (separator string ){_cgdgb ._gbbg =separator };func (_fffc *Paragraph )getTextLineWidth (_agbb string )float64 {var _dga float64 ;for _ ,_egfd :=range _agbb {if _egfd =='\u000A'{continue ;};_fbdf ,_fadac :=_fffc ._gbgeb .GetRuneMetrics (_egfd );if !_fadac {_cf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_egfd ,_egfd );return -1;};_dga +=_fffc ._gcbgg *_fbdf .Wx ;};return _dga ;};

// CurRow returns the currently active cell's row number.
func (_fdbb *Table )CurRow ()int {_ffccf :=(_fdbb ._fgaeg -1)/_fdbb ._cdfb +1;return _ffccf };

// GeneratePageBlocks implements drawable interface.
func (_eaag *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cddb :=_eaag ._gcg ;_aae :=ctx .PageHeight -_eaag ._dcf ;if _eaag ._gef !=nil {_abgb :=_ba .Rectangle {Opacity :1.0,X :_eaag ._gcg ,Y :ctx .PageHeight -_eaag ._dcf -_eaag ._aaa ,Height :_eaag ._aaa ,Width :_eaag ._eabc };_abgb .FillEnabled =true ;_abgb .FillColor =_eaag ._gef ;_abgb .BorderEnabled =false ;_cbg ,_ ,_ace :=_abgb .Draw ("");if _ace !=nil {return nil ,ctx ,_ace ;};_ace =_fbc .addContentsByString (string (_cbg ));if _ace !=nil {return nil ,ctx ,_ace ;};};_egd :=_eaag ._ffe ;_faa :=_eaag ._bce ;_caf :=_eaag ._dda ;_fadg :=_eaag ._ffbg ;_gade :=_eaag ._ffe ;if _eaag ._daac ==CellBorderStyleDouble {_gade +=2*_egd ;};_babe :=_eaag ._bce ;if _eaag ._bfcf ==CellBorderStyleDouble {_babe +=2*_faa ;};_efg :=_eaag ._dda ;if _eaag ._eafa ==CellBorderStyleDouble {_efg +=2*_caf ;};_bcd :=_eaag ._ffbg ;if _eaag ._gaef ==CellBorderStyleDouble {_bcd +=2*_fadg ;};if _eaag ._ffe !=0{_eaac :=_cddb ;_def :=_aae ;if _eaag ._daac ==CellBorderStyleDouble {_def -=_egd ;_gfc :=_ba .BasicLine {};_gfc .X1 =_eaac -_gade /2;_gfc .Y1 =_def +2*_egd ;_gfc .X2 =_eaac +_eaag ._eabc +_gade /2;_gfc .Y2 =_def +2*_egd ;_gfc .LineColor =_eaag ._cbaa ;_gfc .LineWidth =_eaag ._ffe ;_gfc .LineStyle =_eaag .LineStyle ;_afb ,_ ,_ebcg :=_gfc .Draw ("");if _ebcg !=nil {return nil ,ctx ,_ebcg ;};_ebcg =_fbc .addContentsByString (string (_afb ));if _ebcg !=nil {return nil ,ctx ,_ebcg ;};};_gee :=_ba .BasicLine {LineWidth :_eaag ._ffe ,Opacity :1.0,LineColor :_eaag ._cbaa ,X1 :_eaac -_gade /2+(_efg -_eaag ._dda ),Y1 :_def ,X2 :_eaac +_eaag ._eabc +_gade /2-(_bcd -_eaag ._ffbg ),Y2 :_def ,LineStyle :_eaag .LineStyle };_aeb ,_ ,_bbca :=_gee .Draw ("");if _bbca !=nil {return nil ,ctx ,_bbca ;};_bbca =_fbc .addContentsByString (string (_aeb ));if _bbca !=nil {return nil ,ctx ,_bbca ;};};if _eaag ._bce !=0{_edfc :=_cddb ;_dgde :=_aae -_eaag ._aaa ;if _eaag ._bfcf ==CellBorderStyleDouble {_dgde +=_faa ;_bgf :=_ba .BasicLine {LineWidth :_eaag ._bce ,Opacity :1.0,LineColor :_eaag ._bdfa ,X1 :_edfc -_babe /2,Y1 :_dgde -2*_faa ,X2 :_edfc +_eaag ._eabc +_babe /2,Y2 :_dgde -2*_faa ,LineStyle :_eaag .LineStyle };_eca ,_ ,_gdc :=_bgf .Draw ("");if _gdc !=nil {return nil ,ctx ,_gdc ;};_gdc =_fbc .addContentsByString (string (_eca ));if _gdc !=nil {return nil ,ctx ,_gdc ;};};_gdcg :=_ba .BasicLine {LineWidth :_eaag ._bce ,Opacity :1.0,LineColor :_eaag ._bdfa ,X1 :_edfc -_babe /2+(_efg -_eaag ._dda ),Y1 :_dgde ,X2 :_edfc +_eaag ._eabc +_babe /2-(_bcd -_eaag ._ffbg ),Y2 :_dgde ,LineStyle :_eaag .LineStyle };_dcc ,_ ,_ecg :=_gdcg .Draw ("");if _ecg !=nil {return nil ,ctx ,_ecg ;};_ecg =_fbc .addContentsByString (string (_dcc ));if _ecg !=nil {return nil ,ctx ,_ecg ;};};if _eaag ._dda !=0{_fdga :=_cddb ;_feg :=_aae ;if _eaag ._eafa ==CellBorderStyleDouble {_fdga +=_caf ;_egdb :=_ba .BasicLine {LineWidth :_eaag ._dda ,Opacity :1.0,LineColor :_eaag ._adfb ,X1 :_fdga -2*_caf ,Y1 :_feg +_efg /2,X2 :_fdga -2*_caf ,Y2 :_feg -_eaag ._aaa -_efg /2,LineStyle :_eaag .LineStyle };_ebb ,_ ,_fee :=_egdb .Draw ("");if _fee !=nil {return nil ,ctx ,_fee ;};_fee =_fbc .addContentsByString (string (_ebb ));if _fee !=nil {return nil ,ctx ,_fee ;};};_gfbd :=_ba .BasicLine {LineWidth :_eaag ._dda ,Opacity :1.0,LineColor :_eaag ._adfb ,X1 :_fdga ,Y1 :_feg +_efg /2-(_gade -_eaag ._ffe ),X2 :_fdga ,Y2 :_feg -_eaag ._aaa -_efg /2+(_babe -_eaag ._bce ),LineStyle :_eaag .LineStyle };_egg ,_ ,_ead :=_gfbd .Draw ("");if _ead !=nil {return nil ,ctx ,_ead ;};_ead =_fbc .addContentsByString (string (_egg ));if _ead !=nil {return nil ,ctx ,_ead ;};};if _eaag ._ffbg !=0{_ddb :=_cddb +_eaag ._eabc ;_edgd :=_aae ;if _eaag ._gaef ==CellBorderStyleDouble {_ddb -=_fadg ;_aab :=_ba .BasicLine {LineWidth :_eaag ._ffbg ,Opacity :1.0,LineColor :_eaag ._egb ,X1 :_ddb +2*_fadg ,Y1 :_edgd +_bcd /2,X2 :_ddb +2*_fadg ,Y2 :_edgd -_eaag ._aaa -_bcd /2,LineStyle :_eaag .LineStyle };_cad ,_ ,_cgc :=_aab .Draw ("");if _cgc !=nil {return nil ,ctx ,_cgc ;};_cgc =_fbc .addContentsByString (string (_cad ));if _cgc !=nil {return nil ,ctx ,_cgc ;};};_cea :=_ba .BasicLine {LineWidth :_eaag ._ffbg ,Opacity :1.0,LineColor :_eaag ._egb ,X1 :_ddb ,Y1 :_edgd +_bcd /2-(_gade -_eaag ._ffe ),X2 :_ddb ,Y2 :_edgd -_eaag ._aaa -_bcd /2+(_babe -_eaag ._bce ),LineStyle :_eaag .LineStyle };_gge ,_ ,_dddc :=_cea .Draw ("");if _dddc !=nil {return nil ,ctx ,_dddc ;};_dddc =_fbc .addContentsByString (string (_gge ));if _dddc !=nil {return nil ,ctx ,_dddc ;};};return []*Block {_fbc },ctx ,nil ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_bdcb *StyledParagraph )Height ()float64 {_bdcb .wrapText ();var _bdge float64 ;for _ ,_degb :=range _bdcb ._gabf {var _ffed float64 ;for _ ,_ffcf :=range _degb {_bcfff :=_bdcb ._dcde *_ffcf .Style .FontSize ;if _bcfff > _ffed {_ffed =_bcfff ;};};_bdge +=_ffed ;};return _bdge ;};

// SetLineWidth sets the line width.
func (_gfdg *Line )SetLineWidth (lw float64 ){_gfdg ._aedee =lw };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_ggfg *Image )SetPos (x ,y float64 ){_ggfg ._cag =_aabc ;_ggfg ._deg =x ;_ggfg ._fbed =y };

// GeneratePageBlocks draws the filled curve on page blocks.
func (_gbd *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeag :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_afa ,_ ,_cbfa :=_gbd .draw ("");_cbfa =_aeag .addContentsByString (string (_afa ));if _cbfa !=nil {return nil ,ctx ,_cbfa ;};return []*Block {_aeag },ctx ,nil ;};

// SetRowHeight sets the height for a specified row.
func (_ggece *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_ggece ._deaf ){return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ggece ._deaf [row -1]=h ;return nil ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_dcfe *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _dcfe ._fabf ._eeaf ,_dcfe ._fabf ._edc ,_dcfe ._fabf ._gdd ,_dcfe ._fabf ._fged ;};

// Scale scales Image by a constant factor, both width and height.
func (_dced *Image )Scale (xFactor ,yFactor float64 ){_dced ._cbaaa =xFactor *_dced ._cbaaa ;_dced ._efdd =yFactor *_dced ._efdd ;};

// SellerAddress returns the seller address used in the invoice template.
func (_addc *Invoice )SellerAddress ()*InvoiceAddress {return _addc ._fadf };func (_cfdc *Invoice )newCell (_gdgg string ,_fcddg InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_fcddg ,_gdgg };};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_eef *Block )ScaleToWidth (w float64 ){_ecf :=w /_eef ._dbc ;_eef .Scale (_ecf ,_ecf )};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_cgda *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcdd :=ctx ;var _eabcb []*Block ;_fcce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cgda ._ddef .isRelative (){ctx .X +=_cgda ._adag ._eeaf ;ctx .Y +=_cgda ._adag ._gdd ;ctx .Width -=_cgda ._adag ._eeaf +_cgda ._adag ._edc ;ctx .Height -=_cgda ._adag ._gdd +_cgda ._adag ._fged ;_cgda .SetWidth (ctx .Width );if _cgda .Height ()> ctx .Height {_eabcb =append (_eabcb ,_fcce );_fcce =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ddgec :=ctx ;_ddgec .Y =ctx .Margins ._gdd ;_ddgec .X =ctx .Margins ._eeaf +_cgda ._adag ._eeaf ;_ddgec .Height =ctx .PageHeight -ctx .Margins ._gdd -ctx .Margins ._fged -_cgda ._adag ._fged ;_ddgec .Width =ctx .PageWidth -ctx .Margins ._eeaf -ctx .Margins ._edc -_cgda ._adag ._eeaf -_cgda ._adag ._edc ;ctx =_ddgec ;};}else {if int (_cgda ._edfd )<=0{_cgda .SetWidth (_cgda .getTextWidth ());};ctx .X =_cgda ._dged ;ctx .Y =_cgda ._dbccb ;};ctx ,_agfb :=_aagg (_fcce ,_cgda ,ctx );if _agfb !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_agfb );return nil ,ctx ,_agfb ;};_eabcb =append (_eabcb ,_fcce );if _cgda ._ddef .isRelative (){ctx .X -=_cgda ._adag ._eeaf ;ctx .Width =_bcdd .Width ;return _eabcb ,ctx ,nil ;};return _eabcb ,_bcdd ,nil ;};func (_fedc *StyledParagraph )getMaxLineWidth ()float64 {if _fedc ._gabf ==nil ||len (_fedc ._gabf )==0{_fedc .wrapText ();};var _cecg float64 ;for _ ,_ecda :=range _fedc ._gabf {_eefa :=_fedc .getTextLineWidth (_ecda );if _eefa > _cecg {_cecg =_eefa ;};};return _cecg ;};

// Height returns the height of the list.
func (_agbf *List )Height ()float64 {var _cdba float64 ;for _ ,_egag :=range _agbf ._bbdg {_cdba +=_egag ._cdfe .Height ();};return _cdba ;};

// AddSection adds a new content section at the end of the invoice.
func (_ecgdf *Invoice )AddSection (title ,content string ){_ecgdf ._cbbc =append (_ecgdf ._cbbc ,[2]string {title ,content });};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// SetSubtotal sets the subtotal of the invoice.
func (_afad *Invoice )SetSubtotal (value string ){_afad ._ffff [1].Value =value };

// Columns returns all the columns in the invoice line items table.
func (_gbeee *Invoice )Columns ()[]*InvoiceCell {return _gbeee ._gfaf };func (_bfd *Block )mergeBlocks (_bg *Block )error {_ab :=_ddg (_bfd ._ca ,_bfd ._af ,_bg ._ca ,_bg ._af );if _ab !=nil {return _ab ;};for _ ,_aef :=range _bg ._eb {_bfd .AddAnnotation (_aef );};return nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// GeneratePageBlocks draws the curve onto page blocks.
func (_badf *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _aebg []string ;_aebg =append (_aebg ,_fg .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_badf ._dggc ));_aebg =append (_aebg ,_fg .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_badf ._cgba [0],_badf ._cgba [1],_badf ._cgba [2]));_aebg =append (_aebg ,_fg .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_badf ._ccge ,ctx .PageHeight -_badf ._gcbg ));_aebg =append (_aebg ,_fg .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_badf ._ddge ,ctx .PageHeight -_badf ._ddgd ,_badf ._edfg ,ctx .PageHeight -_badf ._cbff ));_bgfb :=_ggbd .addContentsByString (_ed .Join (_aebg ,"\u000a"));if _bgfb !=nil {return nil ,ctx ,_bgfb ;};return []*Block {_ggbd },ctx ,nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetNumber sets the number of the invoice.
func (_ggacf *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_ggacf ._ecagd [1].Value =number ;return _ggacf ._ecagd [0],_ggacf ._ecagd [1];};

// SetColorTop sets border color for top.
func (_dcaa *border )SetColorTop (col Color ){_dcaa ._cbaa =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ag .PdfPage )(*Block ,error ){_eaa :=&Block {};_dbg ,_bbg :=page .GetAllContentStreams ();if _bbg !=nil {return nil ,_bbg ;};_gf :=_ee .NewContentStreamParser (_dbg );_bf ,_bbg :=_gf .Parse ();if _bbg !=nil {return nil ,_bbg ;};_bf .WrapIfNeeded ();_eaa ._ca =_bf ;if page .Resources !=nil {_eaa ._af =page .Resources ;}else {_eaa ._af =_ag .NewPdfPageResources ();};_eg ,_bbg :=page .GetMediaBox ();if _bbg !=nil {return nil ,_bbg ;};if _eg .Llx !=0||_eg .Lly !=0{_eaa .translate (-_eg .Llx ,_eg .Lly );};_eaa ._dbc =_eg .Urx -_eg .Llx ;_eaa ._fd =_eg .Ury -_eg .Lly ;if page .Rotate !=nil {_eaa ._dd =-float64 (*page .Rotate );};return _eaa ,nil ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_feba *Invoice )NoteStyle ()TextStyle {return _feba ._cagc };func _cefbf (_fcfe ,_ebgf ,_ddec TextChunk ,_gdfg uint ,_geaf TextStyle )*TOCLine {_ebdc :=_fcfc (_geaf );_ebdc .SetEnableWrap (true );_ebdc .SetTextAlignment (TextAlignmentLeft );_ebdc .SetMargins (0,0,2,2);_gdfe :=&TOCLine {_ebbg :_ebdc ,Number :_fcfe ,Title :_ebgf ,Page :_ddec ,Separator :TextChunk {Text :"\u002e",Style :_geaf },_geaa :0,_bced :_gdfg ,_cdbfa :10,_ggbb :_ecfc };_ebdc ._cddd ._eeaf =_gdfe ._geaa +float64 (_gdfe ._bced -1)*_gdfe ._cdbfa ;_ebdc ._aacf =_gdfe .prepareParagraph ;return _gdfe ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_abced *TOC )SetLineStyle (style TextStyle ){_abced .SetLineNumberStyle (style );_abced .SetLineTitleStyle (style );_abced .SetLineSeparatorStyle (style );_abced .SetLinePageStyle (style );};

// TextAlignment options for paragraph.
type TextAlignment int ;func _gbbc (_dccc string )(*Image ,error ){_ddeb ,_dega :=_e .Open (_dccc );if _dega !=nil {return nil ,_dega ;};defer _ddeb .Close ();_dgdgd ,_dega :=_ag .ImageHandling .Read (_ddeb );if _dega !=nil {_cf .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dega );return nil ,_dega ;};return _ecbe (_dgdgd );};func (_fdada *Invoice )generateHeaderBlocks (_cgbaf DrawContext )([]*Block ,DrawContext ,error ){_dcfgg :=_fcfc (_fdada ._dafc );_dcfgg .SetEnableWrap (true );_dcfgg .Append (_fdada ._dfed );_cdbe :=_afae (2);if _fdada ._geff !=nil {_begb :=_cdbe .NewCell ();_begb .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_begb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_begb .SetIndent (0);_begb .SetContent (_fdada ._geff );_fdada ._geff .ScaleToHeight (_dcfgg .Height ()+20);}else {_cdbe .SkipCells (1);};_ffab :=_cdbe .NewCell ();_ffab .SetHorizontalAlignment (CellHorizontalAlignmentRight );_ffab .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ffab .SetContent (_dcfgg );return _cdbe .GeneratePageBlocks (_cgbaf );};

// SetMargins sets the margins of the paragraph.
func (_afbe *List )SetMargins (left ,right ,top ,bottom float64 ){_afbe ._fabf ._eeaf =left ;_afbe ._fabf ._edc =right ;_afbe ._fabf ._gdd =top ;_afbe ._fabf ._fged =bottom ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_fdee *TOC )SetLineLevelOffset (levelOffset float64 ){_fdee ._bcagf =levelOffset };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cgbd *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcabd :=ctx ;_daaga ,ctx ,_afcc :=_cgbd ._ebbg .GeneratePageBlocks (ctx );if _afcc !=nil {return _daaga ,ctx ,_afcc ;};if _cgbd ._ggbb .isRelative (){ctx .X =_bcabd .X ;};if _cgbd ._ggbb .isAbsolute (){return _daaga ,_bcabd ,nil ;};return _daaga ,ctx ,nil ;};

// SetFillColor sets the fill color.
func (_ccce *Rectangle )SetFillColor (col Color ){_ccce ._dgfc =_ag .NewPdfColorDeviceRGB (col .ToRGB ())};func _ebff (_becd ,_abc *_ag .PdfPageResources )error {_gbb ,_ :=_becd .GetColorspaces ();if _gbb !=nil &&len (_gbb .Colorspaces )> 0{for _gdb ,_fcag :=range _gbb .Colorspaces {_bdf :=*_db .MakeName (_gdb );if _abc .HasColorspaceByName (_bdf ){continue ;};_ggf :=_abc .SetColorspaceByName (_bdf ,_fcag );if _ggf !=nil {return _ggf ;};};};return nil ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_gbef *Invoice )SetTitleStyle (style TextStyle ){_gbef ._dafc =style };func (_begea *Invoice )generateLineBlocks (_adcc DrawContext )([]*Block ,DrawContext ,error ){_ebfa :=_afae (len (_begea ._gfaf ));_ebfa .SetMargins (0,0,25,0);for _ ,_acf :=range _begea ._gfaf {_eded :=_fcfc (_acf .TextStyle );_eded .SetMargins (0,0,1,0);_eded .Append (_acf .Value );_cgbc :=_ebfa .NewCell ();_cgbc .SetHorizontalAlignment (_acf .Alignment );_cgbc .SetBackgroundColor (_acf .BackgroundColor );_begea .setCellBorder (_cgbc ,_acf );_cgbc .SetContent (_eded );};for _ ,_fbee :=range _begea ._gff {for _ ,_eggc :=range _fbee {_babcc :=_fcfc (_eggc .TextStyle );_babcc .SetMargins (0,0,3,2);_babcc .Append (_eggc .Value );_eacec :=_ebfa .NewCell ();_eacec .SetHorizontalAlignment (_eggc .Alignment );_eacec .SetBackgroundColor (_eggc .BackgroundColor );_begea .setCellBorder (_eacec ,_eggc );_eacec .SetContent (_babcc );};};return _ebfa .GeneratePageBlocks (_adcc );};

// GeneratePageBlocks generates a page break block.
func (_dddd *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgfg :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_cafad :=ctx ;_cafad .Y =ctx .Margins ._gdd ;_cafad .X =ctx .Margins ._eeaf ;_cafad .Height =ctx .PageHeight -ctx .Margins ._gdd -ctx .Margins ._fged ;_cafad .Width =ctx .PageWidth -ctx .Margins ._eeaf -ctx .Margins ._edc ;ctx =_cafad ;return _dgfg ,ctx ,nil ;};

// AppendColumn appends a column to the line items table.
func (_bcaba *Invoice )AppendColumn (description string )*InvoiceCell {_gaede :=_bcaba .NewColumn (description );_bcaba ._gfaf =append (_bcaba ._gfaf ,_gaede );return _gaede ;};func (_cdbb *Invoice )generateNoteBlocks (_dbgdf DrawContext )([]*Block ,DrawContext ,error ){_eggf :=_gddf ();_bdfg :=append ([][2]string {_cdbb ._bddd ,_cdbb ._abcc },_cdbb ._cbbc ...);for _ ,_fdfc :=range _bdfg {if _fdfc [1]!=""{_dfee :=_cdbb .drawSection (_fdfc [0],_fdfc [1]);for _ ,_eccab :=range _dfee {_eggf .Add (_eccab );};_gbfe :=_fcfc (_cdbb ._ddebd );_gbfe .SetMargins (0,0,10,0);_eggf .Add (_gbfe );};};return _eggf .GeneratePageBlocks (_dbgdf );};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_gbge *List )Width ()float64 {return 0};func (_bbbf *FilledCurve )draw (_deec string )([]byte ,*_ag .PdfRectangle ,error ){_egcg :=_ba .NewCubicBezierPath ();for _ ,_adfe :=range _bbbf ._abeb {_egcg =_egcg .AppendCurve (_adfe );};creator :=_ee .NewContentCreator ();creator .Add_q ();if _bbbf .FillEnabled {creator .Add_rg (_bbbf ._daf .R (),_bbbf ._daf .G (),_bbbf ._daf .B ());};if _bbbf .BorderEnabled {creator .Add_RG (_bbbf ._bbceb .R (),_bbbf ._bbceb .G (),_bbbf ._bbceb .B ());creator .Add_w (_bbbf .BorderWidth );};if len (_deec )> 1{creator .Add_gs (_db .PdfObjectName (_deec ));};_ba .DrawBezierPathWithCreator (_egcg ,creator );creator .Add_h ();if _bbbf .FillEnabled &&_bbbf .BorderEnabled {creator .Add_B ();}else if _bbbf .FillEnabled {creator .Add_f ();}else if _bbbf .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_ceadb :=_egcg .GetBoundingBox ();if _bbbf .BorderEnabled {_ceadb .Height +=_bbbf .BorderWidth ;_ceadb .Width +=_bbbf .BorderWidth ;_ceadb .X -=_bbbf .BorderWidth /2;_ceadb .Y -=_bbbf .BorderWidth /2;};_fbb :=&_ag .PdfRectangle {};_fbb .Llx =_ceadb .X ;_fbb .Lly =_ceadb .Y ;_fbb .Urx =_ceadb .X +_ceadb .Width ;_fbb .Ury =_ceadb .Y +_ceadb .Height ;return creator .Bytes (),_fbb ,nil ;};