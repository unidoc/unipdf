//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_g "bytes";_c "errors";_a "fmt";_bge "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/contentstream";_bf "github.com/unidoc/unipdf/v3/contentstream/draw";_ffg "github.com/unidoc/unipdf/v3/core";_aa "github.com/unidoc/unipdf/v3/internal/transform";_bc "github.com/unidoc/unipdf/v3/model";_ga "image";_b "io";_bg "math";_e "os";_ff "sort";_gg "strconv";_bd "strings";_gf "unicode";);

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_bgg float64 ;_aac float64 ;_fegf float64 ;_ffabb float64 ;_bfeg float64 ;_cdg float64 ;_afg *_bc .PdfColorDeviceRGB ;_aadb float64 ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_gfd *Block )SetPos (x ,y float64 ){_gfd ._gb =_bgaf ;_gfd ._fa =x ;_gfd ._ad =y };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);func (_bcccc *Invoice )drawAddress (_bdeg *InvoiceAddress )[]*StyledParagraph {var _bgad []*StyledParagraph ;if _bdeg .Heading !=""{_edeg :=_ebge (_bcccc ._gffea );_edeg .SetMargins (0,0,0,7);_edeg .Append (_bdeg .Heading );_bgad =append (_bgad ,_edeg );};_dfbd :=_ebge (_bcccc ._abace );_dfbd .SetLineHeight (1.2);_eddc :=_bdeg .Separator ;if _eddc ==""{_eddc =_bcccc ._fagae ;};_cdded :=_bdeg .City ;if _bdeg .State !=""{if _cdded !=""{_cdded +=_eddc ;};_cdded +=_bdeg .State ;};if _bdeg .Zip !=""{if _cdded !=""{_cdded +=_eddc ;};_cdded +=_bdeg .Zip ;};if _bdeg .Name !=""{_dfbd .Append (_bdeg .Name +"\u000a");};if _bdeg .Street !=""{_dfbd .Append (_bdeg .Street +"\u000a");};if _bdeg .Street2 !=""{_dfbd .Append (_bdeg .Street2 +"\u000a");};if _cdded !=""{_dfbd .Append (_cdded +"\u000a");};if _bdeg .Country !=""{_dfbd .Append (_bdeg .Country +"\u000a");};_affa :=_ebge (_bcccc ._abace );_affa .SetLineHeight (1.2);_affa .SetMargins (0,0,7,0);if _bdeg .Phone !=""{_affa .Append (_bdeg .fmtLine (_bdeg .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_bdeg .HidePhoneLabel ));};if _bdeg .Email !=""{_affa .Append (_bdeg .fmtLine (_bdeg .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_bdeg .HideEmailLabel ));};_bgad =append (_bgad ,_dfbd ,_affa );return _bgad ;};

// SetSubtotal sets the subtotal of the invoice.
func (_dbc *Invoice )SetSubtotal (value string ){_dbc ._cbea [1].Value =value };func _edg (_bafed int )*Table {_acbe :=&Table {_gccf :_bafed ,_abbg :10.0,_gbea :[]float64 {},_gbcf :[]float64 {},_gggbg :[]*TableCell {}};_acbe .resetColumnWidths ();return _acbe ;};func (_gce *Creator )initContext (){_gce ._bbed .X =_gce ._fgbg ._eagb ;_gce ._bbed .Y =_gce ._fgbg ._egdb ;_gce ._bbed .Width =_gce ._gacc -_gce ._fgbg ._ggbd -_gce ._fgbg ._eagb ;_gce ._bbed .Height =_gce ._afdg -_gce ._fgbg ._daeg -_gce ._fgbg ._egdb ;_gce ._bbed .PageHeight =_gce ._afdg ;_gce ._bbed .PageWidth =_gce ._gacc ;_gce ._bbed .Margins =_gce ._fgbg ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetRowHeight sets the height for a specified row.
func (_adcce *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_adcce ._gbcf ){return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adcce ._gbcf [row -1]=h ;return nil ;};

// NewList creates a new list.
func (_fdea *Creator )NewList ()*List {return _ecffg (_fdea .NewTextStyle ())};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_fafb *List )Width ()float64 {return 0};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_debf *Table )Width ()float64 {return 0};

// Width returns the Block's width.
func (_ffe *Block )Width ()float64 {return _ffe ._ee };

// DrawHeader sets a function to draw a header on created output pages.
func (_fcdg *Creator )DrawHeader (drawHeaderFunc func (_ccbd *Block ,_dcde HeaderFunctionArgs )){_fcdg ._cbbb =drawHeaderFunc ;};func (_gcedb *TOCLine )getLineLink ()*_bc .PdfAnnotation {if _gcedb ._edbce <=0{return nil ;};return _ecda (_gcedb ._edbce -1,_gcedb ._aggc ,_gcedb ._abeff ,0);};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_beaff *Paragraph )Height ()float64 {_beaff .wrapText ();return float64 (len (_beaff ._dced ))*_beaff ._eded *_beaff ._bgebc ;};

// NewCell returns a new invoice table cell.
func (_bfda *Invoice )NewCell (value string )*InvoiceCell {return _bfda .newCell (value ,_bfda .NewCellProps ());};func (_fge *Creator )setActivePage (_afb *_bc .PdfPage ){_fge ._dae =_afb };

// SetBorderColor sets the border color.
func (_geedb *PolyBezierCurve )SetBorderColor (color Color ){_geedb ._efeec .BorderColor =_bc .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetWidthRight sets border width for right.
func (_bgc *border )SetWidthRight (bw float64 ){_bgc ._dgg =bw };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_ebgg *Paragraph )SetWidth (width float64 ){_ebgg ._faeg =width ;_ebgg .wrapText ()};

// Inline returns whether the inline mode of the division is active.
func (_bcbg *Division )Inline ()bool {return _bcbg ._cgga };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_fgded *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgbed :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_efcb ,_eaaa :=_cgbed .setOpacity (_fgded ._fagab ,_fgded ._fagab );if _eaaa !=nil {return nil ,ctx ,_eaaa ;};_adba :=_fgded ._aefd .Points ;for _efab :=range _adba {_adda :=&_adba [_efab ];_adda .Y =ctx .PageHeight -_adda .Y ;};_deff ,_ ,_eaaa :=_fgded ._aefd .Draw (_efcb );if _eaaa !=nil {return nil ,ctx ,_eaaa ;};if _eaaa =_cgbed .addContentsByString (string (_deff ));_eaaa !=nil {return nil ,ctx ,_eaaa ;};return []*Block {_cgbed },ctx ,nil ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_gbc *Line )SetColor (col Color ){_gbc ._afdb =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetBackgroundColor sets the cell's background color.
func (_bbdcd *TableCell )SetBackgroundColor (col Color ){_bbdcd ._dcdfb =_bc .NewPdfColorDeviceRGB (col .ToRGB ());};

// NewTOCLine creates a new table of contents line with the default style.
func (_efcff *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _bdea (number ,title ,page ,level ,_efcff .NewTextStyle ());};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_dag *Creator )MoveRight (dx float64 ){_dag ._bbed .X +=dx };func _abg (_bgda []byte )(*Image ,error ){_bedd :=_g .NewReader (_bgda );_egca ,_deeg :=_bc .ImageHandling .Read (_bedd );if _deeg !=nil {_bge .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_deeg );return nil ,_deeg ;};return _bgec (_egca );};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_ddfdb *Invoice )SetAddressStyle (style TextStyle ){_ddfdb ._abace =style };

// Invoice represents a configurable invoice template.
type Invoice struct{_fbab string ;_aabf *Image ;_eefe *InvoiceAddress ;_effe *InvoiceAddress ;_fagae string ;_gedf [2]*InvoiceCell ;_degb [2]*InvoiceCell ;_bega [2]*InvoiceCell ;_abdf [][2]*InvoiceCell ;_cadd []*InvoiceCell ;_bagg [][]*InvoiceCell ;_cbea [2]*InvoiceCell ;_ddbc [2]*InvoiceCell ;_cbcdg [][2]*InvoiceCell ;_aea [2]string ;_bgcd [2]string ;_dbag [][2]string ;_fffd TextStyle ;_efda TextStyle ;_afeg TextStyle ;_abace TextStyle ;_gffea TextStyle ;_dcb TextStyle ;_ecae TextStyle ;_afae InvoiceCellProps ;_cccf InvoiceCellProps ;_eggd InvoiceCellProps ;_dccd InvoiceCellProps ;_ggdc positioning ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_gefb *StyledParagraph )SetWidth (width float64 ){_gefb ._faa =width ;_gefb .wrapText ()};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_dca *Image )ScaleToHeight (h float64 ){_fggd :=_dca ._bea /_dca ._bebbc ;_dca ._bebbc =h ;_dca ._bea =h *_fggd ;};func (_cdbe *Image )rotatedSize ()(float64 ,float64 ){_cdab :=_cdbe ._bea ;_dbfd :=_cdbe ._bebbc ;_gdfb :=_cdbe ._bggc ;if _gdfb ==0{return _cdab ,_dbfd ;};_cfggce :=_bf .Path {Points :[]_bf .Point {_bf .NewPoint (0,0).Rotate (_gdfb ),_bf .NewPoint (_cdab ,0).Rotate (_gdfb ),_bf .NewPoint (0,_dbfd ).Rotate (_gdfb ),_bf .NewPoint (_cdab ,_dbfd ).Rotate (_gdfb )}}.GetBoundingBox ();return _cfggce .Width ,_cfggce .Height ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_ecfa []*_bc .PdfPage ;_acg map[*_bc .PdfPage ]*Block ;_cgd map[*_bc .PdfPage ]_aa .Matrix ;_dae *_bc .PdfPage ;_dddcb PageSize ;_bbed DrawContext ;_fgbg margins ;_gacc ,_afdg float64 ;_eff int ;_effc func (_bdb FrontpageFunctionArgs );_ggd func (_gffe *TOC )error ;_cbbb func (_fgdg *Block ,_ecca HeaderFunctionArgs );_dbg func (_fcc *Block ,_bfg FooterFunctionArgs );_gdea func (_edf *_bc .PdfWriter )error ;_eccab bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_cgde *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_fae *_bc .Outline ;_bfaf *_bc .PdfOutlineTreeNode ;_daca *_bc .PdfAcroForm ;_abac _ffg .PdfObject ;_ccce _bc .Optimizer ;_efd []*_bc .PdfFont ;_fage *_bc .PdfFont ;_eee *_bc .PdfFont ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_gbead *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_gbead ._fecfb =append (_gbead ._fecfb ,line );return line ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_cb *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fag :=_d .NewContentCreator ();_gbg ,_baa :=_cb .Width (),_cb .Height ();if _cb ._gb .isRelative (){_fag .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_baa );}else {_fag .Translate (_cb ._fa ,ctx .PageHeight -_cb ._ad -_baa );};_cfc :=_baa ;if _cb ._fe !=0{_fag .Translate (_gbg /2,_baa /2);_fag .RotateDeg (_cb ._fe );_fag .Translate (-_gbg /2,-_baa /2);_ ,_cfc =_cb .RotatedSize ();};if _cb ._gb .isRelative (){ctx .Y +=_cfc ;};_eea :=_cb .duplicate ();_ge :=append (*_fag .Operations (),*_eea ._ae ...);_ge .WrapIfNeeded ();_eea ._ae =&_ge ;return []*Block {_eea },ctx ,nil ;};

// SetAngle sets the rotation angle of the text.
func (_geac *Paragraph )SetAngle (angle float64 ){_geac ._ggfa =angle };type listItem struct{_acdfc VectorDrawable ;_baeb TextChunk ;};func (_fba rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _fba ._aaeg ,_fba ._bad ,_fba ._dddc };

// Width returns the width of the Paragraph.
func (_gbbc *Paragraph )Width ()float64 {if _gbbc ._dgf &&int (_gbbc ._faeg )> 0{return _gbbc ._faeg ;};return _gbbc .getTextWidth ()/1000.0;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_cfggb *TOCLine )LevelOffset ()float64 {return _cfggb ._ggfe };

// AddLine appends a new line to the invoice line items table.
func (_effeg *Invoice )AddLine (values ...string )[]*InvoiceCell {_adca :=len (_effeg ._cadd );var _gcgc []*InvoiceCell ;for _gdfbg ,_dbbb :=range values {_effb :=_effeg .newCell (_dbbb ,_effeg ._eggd );if _gdfbg < _adca {_effb .Alignment =_effeg ._cadd [_gdfbg ].Alignment ;};_gcgc =append (_gcgc ,_effb );};_effeg ._bagg =append (_effeg ._bagg ,_gcgc );return _gcgc ;};

// NewDivision returns a new Division container component.
func (_bdff *Creator )NewDivision ()*Division {return _dafd ()};type positioning int ;func (_afa *Block )mergeBlocks (_aeca *Block )error {_dde :=_gdd (_afa ._ae ,_afa ._fd ,_aeca ._ae ,_aeca ._fd );if _dde !=nil {return _dde ;};for _ ,_egb :=range _aeca ._fg {_afa .AddAnnotation (_egb );};return nil ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_baf *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _baf ._gadg ==nil {if _dgdf :=_baf .makeXObject ();_dgdf !=nil {return nil ,ctx ,_dgdf ;};};var _ccda []*Block ;_caff :=ctx ;_ede :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _baf ._bcfa .isRelative (){if _baf ._bebbc > ctx .Height {_ccda =append (_ccda ,_ede );_ede =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_defd :=ctx ;_defd .Y =ctx .Margins ._egdb ;_defd .X =ctx .Margins ._eagb +_baf ._eaga ._eagb ;_defd .Height =ctx .PageHeight -ctx .Margins ._egdb -ctx .Margins ._daeg -_baf ._eaga ._daeg ;_defd .Width =ctx .PageWidth -ctx .Margins ._eagb -ctx .Margins ._ggbd -_baf ._eaga ._eagb -_baf ._eaga ._ggbd ;ctx =_defd ;}else {ctx .Y +=_baf ._eaga ._egdb ;ctx .Height -=_baf ._eaga ._egdb +_baf ._eaga ._daeg ;ctx .X +=_baf ._eaga ._eagb ;ctx .Width -=_baf ._eaga ._eagb +_baf ._eaga ._ggbd ;};}else {ctx .X =_baf ._feb ;ctx .Y =_baf ._fagg ;};ctx ,_bfbe :=_efdg (_ede ,_baf ,ctx );if _bfbe !=nil {return nil ,ctx ,_bfbe ;};_ccda =append (_ccda ,_ede );if _baf ._bcfa .isAbsolute (){ctx =_caff ;}else {ctx .Y +=_baf ._eaga ._daeg ;ctx .Height -=_baf ._eaga ._daeg ;};return _ccda ,ctx ,nil ;};func _efdg (_cffga *Block ,_dceaf *Image ,_cbabb DrawContext )(DrawContext ,error ){_fef :=_cbabb ;_bafa :=1;_gdagg :=_ffg .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_bafa ));for _cffga ._fd .HasXObjectByName (_gdagg ){_bafa ++;_gdagg =_ffg .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_bafa ));};_dbac :=_cffga ._fd .SetXObjectImageByName (_gdagg ,_dceaf ._gadg );if _dbac !=nil {return _cbabb ,_dbac ;};_eef :=0;_fdddd :=_ffg .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_eef ));for _cffga ._fd .HasExtGState (_fdddd ){_eef ++;_fdddd =_ffg .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_eef ));};_gcea :=_ffg .MakeDict ();_gcea .Set ("\u0042\u004d",_ffg .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _dceaf ._gffb < 1.0{_gcea .Set ("\u0043\u0041",_ffg .MakeFloat (_dceaf ._gffb ));_gcea .Set ("\u0063\u0061",_ffg .MakeFloat (_dceaf ._gffb ));};_dbac =_cffga ._fd .AddExtGState (_fdddd ,_ffg .MakeIndirectObject (_gcea ));if _dbac !=nil {return _cbabb ,_dbac ;};_gfff :=_dceaf .Width ();_efag :=_dceaf .Height ();_ ,_bfeb :=_dceaf .rotatedSize ();_cbcd :=_cbabb .X ;_ffgad :=_cbabb .PageHeight -_cbabb .Y -_efag ;if _dceaf ._bcfa .isRelative (){_ffgad -=(_bfeb -_efag )/2;switch _dceaf ._fcdf {case HorizontalAlignmentCenter :_cbcd +=(_cbabb .Width -_gfff )/2;case HorizontalAlignmentRight :_cbcd =_cbabb .PageWidth -_cbabb .Margins ._ggbd -_dceaf ._eaga ._ggbd -_gfff ;};};_dgega :=_dceaf ._bggc ;_bef :=_d .NewContentCreator ();_bef .Add_gs (_fdddd );_bef .Translate (_cbcd ,_ffgad );if _dgega !=0{_bef .Translate (_gfff /2,_efag /2);_bef .RotateDeg (_dgega );_bef .Translate (-_gfff /2,-_efag /2);};_bef .Scale (_gfff ,_efag ).Add_Do (_gdagg );_cadc :=_bef .Operations ();_cadc .WrapIfNeeded ();_cffga .addContents (_cadc );if _dceaf ._bcfa .isRelative (){_cbabb .Y +=_bfeb ;_cbabb .Height -=_bfeb ;return _cbabb ,nil ;};return _fef ,nil ;};

// CurCol returns the currently active cell's column number.
func (_dbdf *Table )CurCol ()int {_aege :=(_dbdf ._gcbb -1)%(_dbdf ._gccf )+1;return _aege };

// NewTable create a new Table with a specified number of columns.
func (_fce *Creator )NewTable (cols int )*Table {return _edg (cols )};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_defab *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_eddef :=&_defab ._agba ;_eddef ._eagb =left ;_eddef ._ggbd =right ;_eddef ._egdb =top ;_eddef ._daeg =bottom ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_bbefb *Invoice )SetTitleStyle (style TextStyle ){_bbefb ._afeg =style };

// SetLineHeight sets the line height (1.0 default).
func (_eefd *StyledParagraph )SetLineHeight (lineheight float64 ){_eefd ._eadg =lineheight };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_cgb *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cgb ._acb ._eagb ,_cgb ._acb ._ggbd ,_cgb ._acb ._egdb ,_cgb ._acb ._daeg ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_fbg *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _ffga (xc ,yc ,width ,height );};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_baeeb *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_baeeb ._fdab =halign ;};func _ecffg (_fggg TextStyle )*List {return &List {_acbd :TextChunk {Text :"\u2022\u0020",Style :_fggg },_dgag :0,_gdde :true ,_gcffb :_feeg ,_bdbg :_fggg };};func _adga (_cbc ,_cgf ,_adgf ,_aag float64 )*border {_gdc :=&border {};_gdc ._ecg =_cbc ;_gdc ._bfdd =_cgf ;_gdc ._ebd =_adgf ;_gdc ._gaa =_aag ;_gdc ._gbec =_bc .NewPdfColorDeviceRGB (0,0,0);_gdc ._dgb =_bc .NewPdfColorDeviceRGB (0,0,0);_gdc ._bbd =_bc .NewPdfColorDeviceRGB (0,0,0);_gdc ._bca =_bc .NewPdfColorDeviceRGB (0,0,0);_gdc ._fdgf =0;_gdc ._ded =0;_gdc ._ade =0;_gdc ._dgg =0;_gdc .LineStyle =_bf .LineStyleSolid ;return _gdc ;};func (_ac *Block )translate (_ec ,_afe float64 ){_cc :=_d .NewContentCreator ().Translate (_ec ,-_afe ).Operations ();*_ac ._ae =append (*_cc ,*_ac ._ae ...);_ac ._ae .WrapIfNeeded ();};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func _dceafa (_adac []_bf .Point )*Polyline {return &Polyline {_aefd :&_bf .Polyline {Points :_adac ,LineColor :_bc .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_fagab :1.0};};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// SetNumber sets the number of the invoice.
func (_fdfg *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_fdfg ._gedf [1].Value =number ;return _fdfg ._gedf [0],_fdfg ._gedf [1];};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_fgde float64 ;_cede float64 ;_ecce float64 ;_bddc float64 ;_afdb *_bc .PdfColorDeviceRGB ;_gdfc float64 ;};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_eebd *Rectangle )GetCoords ()(float64 ,float64 ){return _eebd ._ccfe ,_eebd ._egde };

// SetBorderOpacity sets the border opacity.
func (_ddff *Rectangle )SetBorderOpacity (opacity float64 ){_ddff ._aabd =opacity };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_ddg :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_bge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ddg ;};var _gaf ,_eeag ,_aeee int ;if len (hexStr )==4{var _dfe ,_dcec ,_fbd int ;_ebga ,_dgc :=_a .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_dfe ,&_dcec ,&_fbd );if _dgc !=nil {_bge .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_dgc );return _ddg ;};if _ebga !=3{_bge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ddg ;};_gaf =_dfe *16+_dfe ;_eeag =_dcec *16+_dcec ;_aeee =_fbd *16+_fbd ;}else {_cccd ,_degc :=_a .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_gaf ,&_eeag ,&_aeee );if _degc !=nil {_bge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ddg ;};if _cccd !=3{_bge .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_cccd );return _ddg ;};};_egfg :=float64 (_gaf )/255.0;_cga :=float64 (_eeag )/255.0;_dccb :=float64 (_aeee )/255.0;_ddg ._aaeg =_egfg ;_ddg ._bad =_cga ;_ddg ._dddc =_dccb ;return _ddg ;};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_geag *Creator )SetForms (form *_bc .PdfAcroForm )error {_geag ._daca =form ;return nil };

// SetFillColor sets the fill color for the path.
func (_dcecd *FilledCurve )SetFillColor (color Color ){_dcecd ._badb =_bc .NewPdfColorDeviceRGB (color .ToRGB ());};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_ece *Division )Add (d VectorDrawable )error {_ccgg :=false ;switch d .(type ){case *Paragraph :_ccgg =true ;case *StyledParagraph :_ccgg =true ;case *Image :_ccgg =true ;};if !_ccgg {return _c .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_ece ._eeegc =append (_ece ._eeegc ,d );return nil ;};

// CreateFrontPage sets a function to generate a front Page.
func (_bgcf *Creator )CreateFrontPage (genFrontPageFunc func (_ccdfc FrontpageFunctionArgs )){_bgcf ._effc =genFrontPageFunc ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_eeeg *Creator )DrawFooter (drawFooterFunc func (_edde *Block ,_bccc FooterFunctionArgs )){_eeeg ._dbg =drawFooterFunc ;};

// SetSellerAddress sets the seller address of the invoice.
func (_gebd *Invoice )SetSellerAddress (address *InvoiceAddress ){_gebd ._effe =address };

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_eafa *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_afgd :=_bf .Line {LineWidth :_eafa ._gdfc ,Opacity :1.0,LineColor :_eafa ._afdb ,LineEndingStyle1 :_bf .LineEndingStyleNone ,LineEndingStyle2 :_bf .LineEndingStyleNone ,X1 :_eafa ._fgde ,Y1 :ctx .PageHeight -_eafa ._cede ,X2 :_eafa ._ecce ,Y2 :ctx .PageHeight -_eafa ._bddc };_bfae ,_ ,_fgfg :=_afgd .Draw ("");if _fgfg !=nil {return nil ,ctx ,_fgfg ;};_fgfg =_fbc .addContentsByString (string (_bfae ));if _fgfg !=nil {return nil ,ctx ,_fgfg ;};return []*Block {_fbc },ctx ,nil ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_fbde *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_fbde ._gccf {_bge .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fbde ._gbea =widths ;return nil ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ae *_d .ContentStreamOperations ;_fd *_bc .PdfPageResources ;_gb positioning ;_fa ,_ad float64 ;_ee float64 ;_gfc float64 ;_fe float64 ;_aae margins ;_fg []*_bc .PdfAnnotation ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_eaec *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _geaa (x1 ,y1 ,x2 ,y2 )};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_gdee *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bddf *_bc .PdfWriter )error ){_gdee ._gdea =pdfWriterAccessFunc ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bbea *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bbea ._ecccb ._eagb ,_bbea ._ecccb ._ggbd ,_bbea ._ecccb ._egdb ,_bbea ._ecccb ._daeg ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_ebfc *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _gddb []*Block ;_bebbe :=ctx ;if _ebfc ._efgg .isRelative (){ctx .X +=_ebfc ._edda ._eagb ;ctx .Y +=_ebfc ._edda ._egdb ;ctx .Width -=_ebfc ._edda ._eagb +_ebfc ._edda ._ggbd ;ctx .Height -=_ebfc ._edda ._egdb +_ebfc ._edda ._daeg ;};ctx .Inline =_ebfc ._cgga ;_gfga :=ctx ;_ccbf :=ctx ;var _bdgf float64 ;for _ ,_bfgd :=range _ebfc ._eeegc {if ctx .Inline {if (ctx .X -_gfga .X )+_bfgd .Width ()<=ctx .Width {ctx .Y =_ccbf .Y ;ctx .Height =_ccbf .Height ;}else {ctx .X =_gfga .X ;ctx .Width =_gfga .Width ;_ccbf .Y +=_bdgf ;_ccbf .Height -=_bdgf ;_bdgf =0;};};_bbg ,_fdgfg ,_bdab :=_bfgd .GeneratePageBlocks (ctx );if _bdab !=nil {_bge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_bdab );return nil ,ctx ,_bdab ;};if len (_bbg )< 1{continue ;};if len (_gddb )> 0{_gddb [len (_gddb )-1].mergeBlocks (_bbg [0]);_gddb =append (_gddb ,_bbg [1:]...);}else {_gddb =append (_gddb ,_bbg [0:]...);};if ctx .Inline {if ctx .Page !=_fdgfg .Page {_gfga .Y =ctx .Margins ._egdb ;_gfga .Height =ctx .PageHeight -ctx .Margins ._egdb ;_ccbf .Y =_gfga .Y ;_ccbf .Height =_gfga .Height ;_bdgf =_fdgfg .Height -_gfga .Height ;}else {if _bbga :=ctx .Height -_fdgfg .Height ;_bbga > _bdgf {_bdgf =_bbga ;};};}else {_fdgfg .X =ctx .X ;};ctx =_fdgfg ;};ctx .Inline =_bebbe .Inline ;if _ebfc ._efgg .isRelative (){ctx .X =_bebbe .X ;};if _ebfc ._efgg .isAbsolute (){return _gddb ,_bebbe ,nil ;};return _gddb ,ctx ,nil ;};func _fbcb (_defg *_bc .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_defg ,FontSize :10};};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_bacb *Ellipse )GetCoords ()(float64 ,float64 ){return _bacb ._abeg ,_bacb ._eace };

// NewInvoice returns an instance of an empty invoice.
func (_edbd *Creator )NewInvoice ()*Invoice {_gaaa :=_edbd .NewTextStyle ();_gaaa .Font =_edbd ._eee ;return _eccc (_edbd .NewTextStyle (),_gaaa );};

// Height returns the height of the list.
func (_cbd *List )Height ()float64 {var _gcga float64 ;for _ ,_dbbgag :=range _cbd ._aaaf {_gcga +=_dbbgag ._acdfc .Height ();};return _gcga ;};func (_ggdf *StyledParagraph )appendChunk (_cceb *TextChunk )*TextChunk {_ggdf ._dcfef =append (_ggdf ._dcfef ,_cceb );_ggdf .wrapText ();return _cceb ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_bbge *Image )SetWidth (w float64 ){_bbge ._bea =w };

// Rows returns the total number of rows the table has.
func (_cccc *Table )Rows ()int {return _cccc ._dgfbg };func (_fageb *StyledParagraph )getTextWidth ()float64 {var _adgd float64 ;_fedf :=len (_fageb ._dcfef );for _bcac ,_addd :=range _fageb ._dcfef {_adccg :=&_addd .Style ;_ebced :=len (_addd .Text );for _defc ,_ceaab :=range _addd .Text {if _ceaab =='\u000A'{continue ;};_egea ,_abda :=_adccg .Font .GetRuneMetrics (_ceaab );if !_abda {_bge .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ceaab );return -1;};_adgd +=_adccg .FontSize *_egea .Wx ;if _ceaab !=' '&&(_bcac !=_fedf -1||_defc !=_ebced -1){_adgd +=_adccg .CharSpacing *1000.0;};};};return _adgd ;};

// Height returns the current page height.
func (_bgedf *Creator )Height ()float64 {return _bgedf ._afdg };

// Indent returns the left offset of the list when nested into another list.
func (_cefg *List )Indent ()float64 {return _cefg ._dgag };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_ebbg *Creator )NewStyledParagraph ()*StyledParagraph {return _ebge (_ebbg .NewTextStyle ())};

// BuyerAddress returns the buyer address used in the invoice template.
func (_aagd *Invoice )BuyerAddress ()*InvoiceAddress {return _aagd ._eefe };func _aaab (_deac *_bc .PdfAnnotationLink )*_bc .PdfAnnotationLink {if _deac ==nil {return nil ;};_bgedg :=_bc .NewPdfAnnotationLink ();_bgedg .BS =_deac .BS ;_bgedg .A =_deac .A ;if _egacd ,_dgefe :=_deac .GetAction ();_dgefe ==nil &&_egacd !=nil {_bgedg .SetAction (_egacd );};if _bcag ,_befa :=_deac .Dest .(*_ffg .PdfObjectArray );_befa {_bgedg .Dest =_ffg .MakeArray (_bcag .Elements ()...);};return _bgedg ;};func (_cdfb *Paragraph )getTextLineWidth (_fdgd string )float64 {var _dcgga float64 ;for _ ,_fgggc :=range _fdgd {if _fgggc =='\u000A'{continue ;};_defbb ,_dcee :=_cdfb ._abcd .GetRuneMetrics (_fgggc );if !_dcee {_bge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_fgggc ,_fgggc );return -1;};_dcgga +=_cdfb ._bgebc *_defbb .Wx ;};return _dcgga ;};

// SetStyleTop sets border style for top side.
func (_edd *border )SetStyleTop (style CellBorderStyle ){_edd ._aeb =style };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_ebfb *Invoice )Sections ()[][2]string {return _ebfb ._dbag };

// SetColorLeft sets border color for left.
func (_bcb *border )SetColorLeft (col Color ){_bcb ._bbd =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};func (_dade *Table )newCell (_agfe int )*TableCell {_dade ._gcbb ++;_agac :=(_dade ._gcbb -1)/_dade ._gccf +1;for _agac > _dade ._dgfbg {_dade ._dgfbg ++;_dade ._gbcf =append (_dade ._gbcf ,_dade ._abbg );};_gddgf :=(_dade ._gcbb -1)%(_dade ._gccf )+1;_fdacd :=&TableCell {};_fdacd ._aefe =_agac ;_fdacd ._efcbc =_gddgf ;_fdacd ._gbbbd =1;_fdacd ._fbbd =5;_fdacd ._caged =CellBorderStyleNone ;_fdacd ._agaa =_bf .LineStyleSolid ;_fdacd ._fdab =CellHorizontalAlignmentLeft ;_fdacd ._faad =CellVerticalAlignmentTop ;_fdacd ._bfce =0;_fdacd ._baggc =0;_fdacd ._efba =0;_fdacd ._aaed =0;_bdgg :=ColorBlack ;_fdacd ._gdbg =_bc .NewPdfColorDeviceRGB (_bdgg .ToRGB ());_fdacd ._bgag =_bc .NewPdfColorDeviceRGB (_bdgg .ToRGB ());_fdacd ._fegcg =_bc .NewPdfColorDeviceRGB (_bdgg .ToRGB ());_fdacd ._abaceg =_bc .NewPdfColorDeviceRGB (_bdgg .ToRGB ());if _agfe < 1{_bge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_agfe );_agfe =1;};_bfcc :=_dade ._gccf -(_fdacd ._efcbc -1);if _agfe > _bfcc {_bge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_agfe ,_bfcc );_agfe =_bfcc ;};_fdacd ._dgdef =_agfe ;_dade ._gcbb +=_agfe -1;_dade ._gggbg =append (_dade ._gggbg ,_fdacd );_fdacd ._egcceb =_dade ;return _fdacd ;};func _accd (_ggde ,_fdeafb ,_eacc TextChunk ,_caae uint ,_gagfd TextStyle )*TOCLine {_ffee :=_ebge (_gagfd );_ffee .SetEnableWrap (true );_ffee .SetTextAlignment (TextAlignmentLeft );_ffee .SetMargins (0,0,2,2);_bdffd :=&TOCLine {_gccaf :_ffee ,Number :_ggde ,Title :_fdeafb ,Page :_eacc ,Separator :TextChunk {Text :"\u002e",Style :_gagfd },_gfcf :0,_egecc :_caae ,_ggfe :10,_dacf :_feeg };_ffee ._bbcf ._eagb =_bdffd ._gfcf +float64 (_bdffd ._egecc -1)*_bdffd ._ggfe ;_ffee ._gefc =_bdffd .prepareParagraph ;return _bdffd ;};

// MoveY moves the drawing context to absolute position y.
func (_bag *Creator )MoveY (y float64 ){_bag ._bbed .Y =y };func (_efagd *Invoice )drawInformation ()*Table {_bbgf :=_edg (2);_dbgc :=append ([][2]*InvoiceCell {_efagd ._gedf ,_efagd ._degb ,_efagd ._bega },_efagd ._abdf ...);for _ ,_ggeg :=range _dbgc {_dbcg ,_fdgfa :=_ggeg [0],_ggeg [1];if _fdgfa .Value ==""{continue ;};_degbg :=_bbgf .NewCell ();_degbg .SetBackgroundColor (_dbcg .BackgroundColor );_efagd .setCellBorder (_degbg ,_dbcg );_beaf :=_ebge (_dbcg .TextStyle );_beaf .Append (_dbcg .Value );_beaf .SetMargins (0,0,2,1);_degbg .SetContent (_beaf );_degbg =_bbgf .NewCell ();_degbg .SetBackgroundColor (_fdgfa .BackgroundColor );_efagd .setCellBorder (_degbg ,_fdgfa );_beaf =_ebge (_fdgfa .TextStyle );_beaf .Append (_fdgfa .Value );_beaf .SetMargins (0,0,2,1);_degbg .SetContent (_beaf );};return _bbgf ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_edff *Invoice )SetColumns (cols []*InvoiceCell ){_edff ._cadd =cols };

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_eeegc []VectorDrawable ;_efgg positioning ;_edda margins ;_cgga bool ;};

// NewPolygon creates a new polygon.
func (_cec *Creator )NewPolygon (points [][]_bf .Point )*Polygon {return _ddbca (points )};

// NewImageFromData creates an Image from image data.
func (_bgfa *Creator )NewImageFromData (data []byte )(*Image ,error ){return _abg (data )};

// SetAngle sets Image rotation angle in degrees.
func (_aefg *Image )SetAngle (angle float64 ){_aefg ._bggc =angle };func _gffg (_gcgb ,_dceef ,_bedf ,_acbf float64 )*Rectangle {return &Rectangle {_ccfe :_gcgb ,_egde :_dceef ,_egbf :_bedf ,_bfdf :_acbf ,_gabf :_bc .NewPdfColorDeviceRGB (0,0,0),_fdee :1.0,_dgcf :1.0,_aabd :1.0};};

// SetBorderColor sets the border color.
func (_bfea *Polygon )SetBorderColor (color Color ){_bfea ._ggca .BorderColor =_bc .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_ceaa *Paragraph )SetTextAlignment (align TextAlignment ){_ceaa ._eceb =align };

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_bdec *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gcde :=_bf .Circle {X :_bdec ._abeg -_bdec ._aaff /2,Y :ctx .PageHeight -_bdec ._eace -_bdec ._aabg /2,Width :_bdec ._aaff ,Height :_bdec ._aabg ,Opacity :1.0,BorderWidth :_bdec ._cdcd };if _bdec ._ffdd !=nil {_gcde .FillEnabled =true ;_gcde .FillColor =_bdec ._ffdd ;};if _bdec ._gfdfe !=nil {_gcde .BorderEnabled =true ;_gcde .BorderColor =_bdec ._gfdfe ;_gcde .BorderWidth =_bdec ._cdcd ;};_dgbc ,_ ,_gadb :=_gcde .Draw ("");if _gadb !=nil {return nil ,ctx ,_gadb ;};_gadb =_ggae .addContentsByString (string (_dgbc ));if _gadb !=nil {return nil ,ctx ,_gadb ;};return []*Block {_ggae },ctx ,nil ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_fcdgd *Table )SetMargins (left ,right ,top ,bottom float64 ){_fcdgd ._dbcbe ._eagb =left ;_fcdgd ._dbcbe ._ggbd =right ;_fcdgd ._dbcbe ._egdb =top ;_fcdgd ._dbcbe ._daeg =bottom ;};func _ffdgb (_bcdg string ,_fdac TextStyle )*Paragraph {_fdeab :=&Paragraph {_fccag :_bcdg ,_abcd :_fdac .Font ,_bgebc :_fdac .FontSize ,_eded :1.0,_dgf :true ,_gfgaf :true ,_eceb :TextAlignmentLeft ,_ggfa :0,_fegb :1,_gdbd :1,_efcfe :_feeg };_fdeab .SetColor (_fdac .Color );return _fdeab ;};

// SetFillColor sets the fill color.
func (_ccca *Polygon )SetFillColor (color Color ){_ccca ._ggca .FillColor =_bc .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetLineColor sets the line color.
func (_cbdc *Polyline )SetLineColor (color Color ){_cbdc ._aefd .LineColor =_bc .NewPdfColorDeviceRGB (color .ToRGB ());};

// Scale scales Image by a constant factor, both width and height.
func (_bffc *Image )Scale (xFactor ,yFactor float64 ){_bffc ._bea =xFactor *_bffc ._bea ;_bffc ._bebbc =yFactor *_bffc ._bebbc ;};

// SetTitle sets the title of the invoice.
func (_ebce *Invoice )SetTitle (title string ){_ebce ._fbab =title };

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_bcdf *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_ggef :=NewTextChunk (text ,_bcdf ._bgbf );_ggef ._abdd =_dffd (url );return _bcdf .appendChunk (_ggef );};

// SetBorderOpacity sets the border opacity.
func (_agff *Polygon )SetBorderOpacity (opacity float64 ){_agff ._cddf =opacity };

// Cols returns the total number of columns the table has.
func (_edfc *Table )Cols ()int {return _edfc ._gccf };func _bbdc (_bdfb ,_fddd ,_edagb ,_fcbcg ,_bebb ,_ecfc float64 )*Curve {_ddfd :=&Curve {};_ddfd ._bgg =_bdfb ;_ddfd ._aac =_fddd ;_ddfd ._fegf =_edagb ;_ddfd ._ffabb =_fcbcg ;_ddfd ._bfeg =_bebb ;_ddfd ._cdg =_ecfc ;_ddfd ._afg =_bc .NewPdfColorDeviceRGB (0,0,0);_ddfd ._aadb =1.0;return _ddfd ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fgfe *StyledParagraph )SetTextAlignment (align TextAlignment ){_fgfe ._fec =align };

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_fgab *Invoice )SetAddressHeadingStyle (style TextStyle ){_fgab ._gffea =style };

// Width returns the width of the Paragraph.
func (_degbc *StyledParagraph )Width ()float64 {if _degbc ._eab &&int (_degbc ._faa )> 0{return _degbc ._faa ;};return _degbc .getTextWidth ()/1000.0;};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_bc .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};func (_fdde *Image )makeXObject ()error {_gfacc :=_fdde ._babc ;if _gfacc ==nil {_gfacc =_ffg .NewFlateEncoder ();};_bfdc ,_bcfc :=_bc .NewXObjectImageFromImage (_fdde ._aeef ,nil ,_gfacc );if _bcfc !=nil {_bge .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bcfc );return _bcfc ;};_fdde ._gadg =_bfdc ;return nil ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_fefb *Invoice )TotalLines ()[][2]*InvoiceCell {_fdfa :=[][2]*InvoiceCell {_fefb ._cbea };_fdfa =append (_fdfa ,_fefb ._cbcdg ...);return append (_fdfa ,_fefb ._ddbc );};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_adc *Image )ConvertToBinary ()error {return _adc ._aeef .ConvertToBinary ()};

// SetLogo sets the logo of the invoice.
func (_dcad *Invoice )SetLogo (logo *Image ){_dcad ._aabf =logo };

// SetBorderColor sets the border color for the path.
func (_fcaa *FilledCurve )SetBorderColor (color Color ){_fcaa ._bgfb =_bc .NewPdfColorDeviceRGB (color .ToRGB ());};func _efdgf ()*PageBreak {return &PageBreak {}};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// Add adds a new Drawable to the chapter.
func (_gcdc *Chapter )Add (d Drawable )error {if Drawable (_gcdc )==d {_bge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_gcdc ._aee =append (_gcdc ._aee ,d );default:_bge .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};func _eccc (_gedc ,_ggcd TextStyle )*Invoice {_bfac :=&Invoice {_fbab :"\u0049N\u0056\u004f\u0049\u0043\u0045",_fagae :"\u002c\u0020",_fffd :_gedc ,_efda :_ggcd };_bfac ._effe =&InvoiceAddress {Separator :_bfac ._fagae };_bfac ._eefe =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_bfac ._fagae };_eecg :=ColorRGBFrom8bit (245,245,245);_gcag :=ColorRGBFrom8bit (155,155,155);_bfac ._afeg =_ggcd ;_bfac ._afeg .Color =_gcag ;_bfac ._afeg .FontSize =20;_bfac ._abace =_gedc ;_bfac ._gffea =_ggcd ;_bfac ._dcb =_gedc ;_bfac ._ecae =_ggcd ;_bfac ._afae =_bfac .NewCellProps ();_bfac ._afae .BackgroundColor =_eecg ;_bfac ._afae .TextStyle =_ggcd ;_bfac ._cccf =_bfac .NewCellProps ();_bfac ._cccf .TextStyle =_ggcd ;_bfac ._cccf .BackgroundColor =_eecg ;_bfac ._cccf .BorderColor =_eecg ;_bfac ._eggd =_bfac .NewCellProps ();_bfac ._eggd .BorderColor =_eecg ;_bfac ._eggd .BorderSides =[]CellBorderSide {CellBorderSideBottom };_bfac ._eggd .Alignment =CellHorizontalAlignmentRight ;_bfac ._dccd =_bfac .NewCellProps ();_bfac ._dccd .Alignment =CellHorizontalAlignmentRight ;_bfac ._gedf =[2]*InvoiceCell {_bfac .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_bfac ._afae ),_bfac .newCell ("",_bfac ._afae )};_bfac ._degb =[2]*InvoiceCell {_bfac .newCell ("\u0044\u0061\u0074\u0065",_bfac ._afae ),_bfac .newCell ("",_bfac ._afae )};_bfac ._bega =[2]*InvoiceCell {_bfac .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_bfac ._afae ),_bfac .newCell ("",_bfac ._afae )};_bfac ._cbea =[2]*InvoiceCell {_bfac .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_bfac ._dccd ),_bfac .newCell ("",_bfac ._dccd )};_egfbc :=_bfac ._dccd ;_egfbc .TextStyle =_ggcd ;_egfbc .BackgroundColor =_eecg ;_egfbc .BorderColor =_eecg ;_bfac ._ddbc =[2]*InvoiceCell {_bfac .newCell ("\u0054\u006f\u0074a\u006c",_egfbc ),_bfac .newCell ("",_egfbc )};_bfac ._aea =[2]string {"\u004e\u006f\u0074e\u0073",""};_bfac ._bgcd =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_bfac ._cadd =[]*InvoiceCell {_bfac .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_bfac .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_bfac .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_bfac .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _bfac ;};func (_gfdc *TOCLine )prepareParagraph (_fgea *StyledParagraph ,_daee DrawContext ){_dffb :=_gfdc .Title .Text ;if _gfdc .Number .Text !=""{_dffb ="\u0020"+_dffb ;};_dffb +="\u0020";_egeb :=_gfdc .Page .Text ;if _egeb !=""{_egeb ="\u0020"+_egeb ;};_fgea ._dcfef =[]*TextChunk {{Text :_gfdc .Number .Text ,Style :_gfdc .Number .Style ,_abdd :_gfdc .getLineLink ()},{Text :_dffb ,Style :_gfdc .Title .Style ,_abdd :_gfdc .getLineLink ()},{Text :_egeb ,Style :_gfdc .Page .Style ,_abdd :_gfdc .getLineLink ()}};_fgea .wrapText ();_dcba :=len (_fgea ._gcded );if _dcba ==0{return ;};_efdd :=_daee .Width *1000-_fgea .getTextLineWidth (_fgea ._gcded [_dcba -1]);_egeaf :=_fgea .getTextLineWidth ([]*TextChunk {&_gfdc .Separator });_ceaeb :=int (_efdd /_egeaf );_feed :=_bd .Repeat (_gfdc .Separator .Text ,_ceaeb );_eece :=_gfdc .Separator .Style ;_cafae :=_fgea .Insert (2,_feed );_cafae .Style =_eece ;_cafae ._abdd =_gfdc .getLineLink ();_efdd =_efdd -float64 (_ceaeb )*_egeaf ;if _efdd > 500{_eegc ,_eba :=_eece .Font .GetRuneMetrics (' ');if _eba &&_efdd > _eegc .Wx {_dbeb :=int (_efdd /_eegc .Wx );if _dbeb > 0{_ccde :=_eece ;_ccde .FontSize =1;_cafae =_fgea .Insert (2,_bd .Repeat ("\u0020",_dbeb ));_cafae .Style =_ccde ;_cafae ._abdd =_gfdc .getLineLink ();};};};};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_acgg *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _acgg ._bega [0],_acgg ._bega [1]};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_fcgd *Chapter )SetIncludeInTOC (includeInTOC bool ){_fcgd ._bgd =includeInTOC };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_fda *Creator )Finalize ()error {if _fda ._eccab {return nil ;};_afcb :=len (_fda ._ecfa );_efdf :=0;if _fda ._effc !=nil {_efdf ++;};if _fda .AddTOC {_fda .initContext ();_fda ._bbed .Page =_efdf +1;if _fda ._ggd !=nil {if _aaga :=_fda ._ggd (_fda ._cgde );_aaga !=nil {return _aaga ;};};_deb ,_ ,_bgdb :=_fda ._cgde .GeneratePageBlocks (_fda ._bbed );if _bgdb !=nil {_bge .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_bgdb );return _bgdb ;};_efdf +=len (_deb );_ecge :=_fda ._cgde .Lines ();for _ ,_bfbc :=range _ecge {_efg ,_dcfe :=_gg .Atoi (_bfbc .Page .Text );if _dcfe !=nil {continue ;};_bfbc .Page .Text =_gg .Itoa (_efg +_efdf );};};_afbb :=false ;if _fda ._effc !=nil {_afcb ++;_ffdg :=_fda .newPage ();_fda ._ecfa =append ([]*_bc .PdfPage {_ffdg },_fda ._ecfa ...);_fda .setActivePage (_ffdg );_cggd :=FrontpageFunctionArgs {PageNum :1,TotalPages :_afcb };_fda ._effc (_cggd );_afbb =true ;};if _fda .AddTOC {_fda .initContext ();if _fda ._ggd !=nil {if _eda :=_fda ._ggd (_fda ._cgde );_eda !=nil {_bge .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_eda );return _eda ;};};_gfda :=_fda ._cgde .Lines ();for _ ,_gbbb :=range _gfda {_gbbb ._edbce +=int64 (_efdf );};var _fdf []*_bc .PdfPage ;_eagf ,_ ,_ :=_fda ._cgde .GeneratePageBlocks (_fda ._bbed );for _ ,_cbcb :=range _eagf {_cbcb .SetPos (0,0);_afcb ++;_dfde :=_fda .newPage ();_fdf =append (_fdf ,_dfde );_fda .setActivePage (_dfde );_fda .Draw (_cbcb );};if _afbb {_afaf :=_fda ._ecfa [0];_bfgc :=_fda ._ecfa [1:];_fda ._ecfa =append ([]*_bc .PdfPage {_afaf },_fdf ...);_fda ._ecfa =append (_fda ._ecfa ,_bfgc ...);}else {_fda ._ecfa =append (_fdf ,_fda ._ecfa ...);};};if _fda ._fae !=nil &&_fda .AddOutlines {var _efcf func (_cfb *_bc .OutlineItem );_efcf =func (_dgef *_bc .OutlineItem ){_dgef .Dest .Page +=int64 (_efdf );if _ddf :=int (_dgef .Dest .Page );_ddf >=0&&_ddf < len (_fda ._ecfa ){_dgef .Dest .PageObj =_fda ._ecfa [_ddf ].GetPageAsIndirectObject ();}else {_bge .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ddf );};_dgef .Dest .Y =_fda ._afdg -_dgef .Dest .Y ;_cfga :=_dgef .Items ();for _ ,_cefd :=range _cfga {_efcf (_cefd );};};_dcea :=_fda ._fae .Items ();for _ ,_gdaa :=range _dcea {_efcf (_gdaa );};if _fda .AddTOC {var _ceae int ;if _afbb {_ceae =1;};_dfg :=_bc .NewOutlineDest (int64 (_ceae ),0,_fda ._afdg );if _ceae >=0&&_ceae < len (_fda ._ecfa ){_dfg .PageObj =_fda ._ecfa [_ceae ].GetPageAsIndirectObject ();}else {_bge .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ceae );};_fda ._fae .Insert (0,_bc .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_dfg ));};};for _gad ,_cfa :=range _fda ._ecfa {_fda .setActivePage (_cfa );if _fda ._cbbb !=nil {_bdge :=NewBlock (_fda ._gacc ,_fda ._fgbg ._egdb );_abdg :=HeaderFunctionArgs {PageNum :_gad +1,TotalPages :_afcb };_fda ._cbbb (_bdge ,_abdg );_bdge .SetPos (0,0);if _gdag :=_fda .Draw (_bdge );_gdag !=nil {_bge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_gdag );return _gdag ;};};if _fda ._dbg !=nil {_adf :=NewBlock (_fda ._gacc ,_fda ._fgbg ._daeg );_gfcd :=FooterFunctionArgs {PageNum :_gad +1,TotalPages :_afcb };_fda ._dbg (_adf ,_gfcd );_adf .SetPos (0,_fda ._afdg -_adf ._gfc );if _cceda :=_fda .Draw (_adf );_cceda !=nil {_bge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_cceda );return _cceda ;};};_age ,_fedbf :=_fda ._acg [_cfa ];if !_fedbf {continue ;};if _eebf ,_gdgd :=_fda ._cgd [_cfa ];_gdgd {_age .transform (_eebf );};if _acdf :=_age .drawToPage (_cfa );_acdf !=nil {_bge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_gad +1,_acdf );return _acdf ;};};_fda ._eccab =true ;return nil ;};func _cggf (_ccgf *Block ,_fbcec *StyledParagraph ,_dabcb [][]*TextChunk ,_bfad DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bcbga :=1;_bbfg :=_ffg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bcbga ));for _ccgf ._fd .HasFontByName (_bbfg ){_bcbga ++;_bbfg =_ffg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bcbga ));};_dcdf :=_ccgf ._fd .SetFontByName (_bbfg ,_fbcec ._cged .Font .ToPdfObject ());if _dcdf !=nil {return _bfad ,nil ,_dcdf ;};_bcbga ++;_cgdcf :=_bbfg ;_fdbe :=_fbcec ._cged .FontSize ;_aafg :=_fbcec ._bddfc .isRelative ();var _gadc [][]_ffg .PdfObjectName ;var _feca float64 ;var _aacb [][]*TextChunk ;var _bcaa float64 ;for _fecf ,_afbee :=range _dabcb {var _ceab []_ffg .PdfObjectName ;var _acda float64 ;for _ ,_bgcde :=range _afbee {_gaed :=_bgcde .Style ;if _fecf ==0&&_gaed .FontSize > _feca {_feca =_gaed .FontSize ;};if _gaed .FontSize > _acda {_acda =_gaed .FontSize ;};_bbfg =_ffg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bcbga ));_dbace :=_ccgf ._fd .SetFontByName (_bbfg ,_gaed .Font .ToPdfObject ());if _dbace !=nil {return _bfad ,nil ,_dbace ;};_ceab =append (_ceab ,_bbfg );_bcbga ++;};_acda *=_fbcec ._eadg ;if _aafg &&_bcaa +_acda > _bfad .Height {_aacb =_dabcb [_fecf :];_dabcb =_dabcb [:_fecf ];break ;};_bcaa +=_acda ;_gadc =append (_gadc ,_ceab );};_cagg :=_d .NewContentCreator ();_cagg .Add_q ();_fecd :=_bfad .PageHeight -_bfad .Y -_feca *_fbcec ._eadg ;_cagg .Translate (_bfad .X ,_fecd );if _fbcec ._bbfa !=0{_cagg .RotateDeg (_fbcec ._bbfa );};_cagg .Add_BT ();_fgaa :=_fecd ;for _bdcd ,_cca :=range _dabcb {_ddgc :=_bfad .X ;if _bdcd !=0{_cagg .Add_Tstar ();};_aed :=_bdcd ==len (_dabcb )-1;var (_baee float64 ;_bfbef float64 ;_gfcbf float64 ;_aabc uint ;);var _gcgaf []float64 ;for _ ,_gceac :=range _cca {_eccg :=&_gceac .Style ;if _eccg .FontSize > _bfbef {_bfbef =_eccg .FontSize ;};_aaccg ,_ceca :=_eccg .Font .GetRuneMetrics (' ');if !_ceca {return _bfad ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _agef uint ;var _afec float64 ;_bfbaf :=len (_gceac .Text );for _cbae ,_feebc :=range _gceac .Text {if _feebc ==' '{_agef ++;continue ;};if _feebc =='\u000A'{continue ;};_baaf ,_fgbcd :=_eccg .Font .GetRuneMetrics (_feebc );if !_fgbcd {_bge .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_feebc );return _bfad ,nil ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_afec +=_eccg .FontSize *_baaf .Wx ;if _cbae !=_bfbaf -1{_afec +=_eccg .CharSpacing *1000.0;};};_gcgaf =append (_gcgaf ,_afec );_baee +=_afec ;_gfcbf +=float64 (_agef )*_aaccg .Wx *_eccg .FontSize ;_aabc +=_agef ;};_bfbef *=_fbcec ._eadg ;var _geda []_ffg .PdfObject ;_caee :=_fbcec ._faa *1000.0;if _fbcec ._fec ==TextAlignmentJustify {if _aabc > 0&&!_aed {_gfcbf =(_caee -_baee )/float64 (_aabc )/_fdbe ;};}else if _fbcec ._fec ==TextAlignmentCenter {_gbdc :=(_caee -_baee -_gfcbf )/2;_cacg :=_gbdc /_fdbe ;_geda =append (_geda ,_ffg .MakeFloat (-_cacg ));_ddgc +=_gbdc /1000.0;}else if _fbcec ._fec ==TextAlignmentRight {_aafd :=(_caee -_baee -_gfcbf );_fbbab :=_aafd /_fdbe ;_geda =append (_geda ,_ffg .MakeFloat (-_fbbab ));_ddgc +=_aafd /1000.0;};if len (_geda )> 0{_cagg .Add_Tf (_cgdcf ,_fdbe ).Add_TL (_fdbe *_fbcec ._eadg ).Add_TJ (_geda ...);};for _gbege ,_bdae :=range _cca {_aabbc :=&_bdae .Style ;_egfd ,_dabf ,_gbda :=_aabbc .Color .ToRGB ();_ebec :=_cgdcf ;_bdgb :=_fdbe ;_cagg .Add_Tr (int64 (_aabbc .RenderingMode ));_cagg .Add_Tc (_aabbc .CharSpacing );if _fbcec ._fec !=TextAlignmentJustify ||_aed {_efbc ,_cfaf :=_aabbc .Font .GetRuneMetrics (' ');if !_cfaf {return _bfad ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ebec =_gadc [_bdcd ][_gbege ];_bdgb =_aabbc .FontSize ;_gfcbf =_efbc .Wx ;};_ceddg :=_aabbc .Font .Encoder ();var _dgae []byte ;for _ ,_ebgad :=range _bdae .Text {if _egfd =='\u000A'{continue ;};if _ebgad ==' '{if len (_dgae )> 0{_cagg .Add_rg (_egfd ,_dabf ,_gbda ).Add_Tf (_gadc [_bdcd ][_gbege ],_aabbc .FontSize ).Add_TL (_aabbc .FontSize *_fbcec ._eadg ).Add_TJ ([]_ffg .PdfObject {_ffg .MakeStringFromBytes (_dgae )}...);_dgae =nil ;};_cagg .Add_Tf (_ebec ,_bdgb ).Add_TL (_bdgb *_fbcec ._eadg ).Add_TJ ([]_ffg .PdfObject {_ffg .MakeFloat (-_gfcbf )}...);_gcgaf [_gbege ]+=_gfcbf *_bdgb ;}else {if _ ,_ecefd :=_ceddg .RuneToCharcode (_ebgad );!_ecefd {_bge .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ebgad ,_ebgad );continue ;};_dgae =append (_dgae ,_ceddg .Encode (string (_ebgad ))...);};};if len (_dgae )> 0{_cagg .Add_rg (_egfd ,_dabf ,_gbda ).Add_Tf (_gadc [_bdcd ][_gbege ],_aabbc .FontSize ).Add_TL (_aabbc .FontSize *_fbcec ._eadg ).Add_TJ ([]_ffg .PdfObject {_ffg .MakeStringFromBytes (_dgae )}...);};_gfffd :=_gcgaf [_gbege ]/1000.0;if _bdae ._abdd !=nil {var _cbaf *_ffg .PdfObjectArray ;if !_bdae ._aggb {switch _adgc :=_bdae ._abdd .GetContext ().(type ){case *_bc .PdfAnnotationLink :_cbaf =_ffg .MakeArray ();_adgc .Rect =_cbaf ;_dgefa ,_addea :=_adgc .Dest .(*_ffg .PdfObjectArray );if _addea &&_dgefa .Len ()==5{_eecb ,_bffd :=_dgefa .Get (1).(*_ffg .PdfObjectName );if _bffd &&_eecb .String ()=="\u0058\u0059\u005a"{_bdcdg ,_ddae :=_ffg .GetNumberAsFloat (_dgefa .Get (3));if _ddae ==nil {_dgefa .Set (3,_ffg .MakeFloat (_bfad .PageHeight -_bdcdg ));};};};};_bdae ._aggb =true ;};if _cbaf !=nil {_dfdc :=_bf .NewPoint (_ddgc -_bfad .X ,_fgaa -_fecd ).Rotate (_fbcec ._bbfa );_dfdc .X +=_bfad .X ;_dfdc .Y +=_fecd ;_cbgdf ,_dcagg ,_eafg ,_dfce :=_begc (_gfffd ,_bfbef ,_fbcec ._bbfa );_dfdc .X +=_cbgdf ;_dfdc .Y +=_dcagg ;_cbaf .Clear ();_cbaf .Append (_ffg .MakeFloat (_dfdc .X ));_cbaf .Append (_ffg .MakeFloat (_dfdc .Y ));_cbaf .Append (_ffg .MakeFloat (_dfdc .X +_eafg ));_cbaf .Append (_ffg .MakeFloat (_dfdc .Y +_dfce ));};_ccgf .AddAnnotation (_bdae ._abdd );};_ddgc +=_gfffd ;_cagg .Add_Tr (int64 (TextRenderingModeFill ));_cagg .Add_Tc (0);};_fgaa -=_bfbef ;};_cagg .Add_ET ();_cagg .Add_Q ();_cebdb :=_cagg .Operations ();_cebdb .WrapIfNeeded ();_ccgf .addContents (_cebdb );if _aafg {_babeg :=_bcaa +_fbcec ._bbcf ._daeg ;_bfad .Y +=_babeg ;_bfad .Height -=_babeg ;if _bfad .Inline {_bfad .X +=_fbcec .Width ()+_fbcec ._bbcf ._ggbd ;};};return _bfad ,_aacb ,nil ;};func (_gfeg *Invoice )generateLineBlocks (_dbcf DrawContext )([]*Block ,DrawContext ,error ){_agae :=_edg (len (_gfeg ._cadd ));_agae .SetMargins (0,0,25,0);for _ ,_fcbd :=range _gfeg ._cadd {_gfegb :=_ebge (_fcbd .TextStyle );_gfegb .SetMargins (0,0,1,0);_gfegb .Append (_fcbd .Value );_gadbf :=_agae .NewCell ();_gadbf .SetHorizontalAlignment (_fcbd .Alignment );_gadbf .SetBackgroundColor (_fcbd .BackgroundColor );_gfeg .setCellBorder (_gadbf ,_fcbd );_gadbf .SetContent (_gfegb );};for _ ,_fabdf :=range _gfeg ._bagg {for _ ,_gagb :=range _fabdf {_dfa :=_ebge (_gagb .TextStyle );_dfa .SetMargins (0,0,3,2);_dfa .Append (_gagb .Value );_eaeb :=_agae .NewCell ();_eaeb .SetHorizontalAlignment (_gagb .Alignment );_eaeb .SetBackgroundColor (_gagb .BackgroundColor );_gfeg .setCellBorder (_eaeb ,_gagb );_eaeb .SetContent (_dfa );};};return _agae .GeneratePageBlocks (_dbcf );};

// Heading returns the heading component of the table of contents.
func (_gbcg *TOC )Heading ()*StyledParagraph {return _gbcg ._dfbb };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_afdf *List )Add (item VectorDrawable )(*TextChunk ,error ){_eaa :=&listItem {_acdfc :item ,_baeb :_afdf ._acbd };switch _aeeg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _aeeg ._gdde {_aeeg ._dgag =15;};default:return nil ,_c .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_afdf ._aaaf =append (_afdf ._aaaf ,_eaa );return &_eaa ._baeb ,nil ;};

// GeneratePageBlocks generates a page break block.
func (_ecbf *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fccb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_begfe :=ctx ;_begfe .Y =ctx .Margins ._egdb ;_begfe .X =ctx .Margins ._eagb ;_begfe .Height =ctx .PageHeight -ctx .Margins ._egdb -ctx .Margins ._daeg ;_begfe .Width =ctx .PageWidth -ctx .Margins ._eagb -ctx .Margins ._ggbd ;ctx =_begfe ;return _fccb ,ctx ,nil ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_dccfc *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _dccfc ._ecab ._eagb ,_dccfc ._ecab ._ggbd ,_dccfc ._ecab ._egdb ,_dccfc ._ecab ._daeg ;};

// Length calculates and returns the line length.
func (_ffcb *Line )Length ()float64 {return _bg .Sqrt (_bg .Pow (_ffcb ._ecce -_ffcb ._fgde ,2.0)+_bg .Pow (_ffcb ._bddc -_ffcb ._cede ,2.0));};func (_cgded *Invoice )setCellBorder (_ddfe *TableCell ,_bec *InvoiceCell ){for _ ,_fddf :=range _bec .BorderSides {_ddfe .SetBorder (_fddf ,CellBorderStyleSingle ,_bec .BorderWidth );};_ddfe .SetBorderColor (_bec .BorderColor );};

// Height returns Image's document height.
func (_gcaf *Image )Height ()float64 {return _gcaf ._bebbc };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dadc *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _dadc ._cbea [0],_dadc ._cbea [1]};func _bfa (_fcd string ,_gff _ffg .PdfObject ,_gegd *_bc .PdfPageResources )_ffg .PdfObjectName {_agb :=_bd .TrimRightFunc (_bd .TrimSpace (_fcd ),func (_gae rune )bool {return _gf .IsNumber (_gae )});if _agb ==""{_agb ="\u0046\u006f\u006e\u0074";};_eac :=0;_ccc :=_ffg .PdfObjectName (_fcd );for {_fcbg ,_cgg :=_gegd .GetFontByName (_ccc );if !_cgg ||_fcbg ==_gff {break ;};_eac ++;_ccc =_ffg .PdfObjectName (_a .Sprintf ("\u0025\u0073\u0025\u0064",_agb ,_eac ));};return _ccc ;};

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_cac *Division )Height ()float64 {_gdege :=0.0;_beg :=0.0;for _ ,_bacf :=range _cac ._eeegc {_ccbe ,_bbef :=_bacf .Width (),_bacf .Height ();switch _gcad :=_bacf .(type ){case *Paragraph :_dec :=_gcad ;_ccbe +=_dec ._ecccb ._eagb +_dec ._ecccb ._ggbd ;_bbef +=_dec ._ecccb ._egdb +_dec ._ecccb ._daeg ;case *StyledParagraph :_egfga :=_gcad ;_ccbe +=_egfga ._bbcf ._eagb +_egfga ._bbcf ._ggbd ;_bbef +=_egfga ._bbcf ._egdb +_egfga ._bbcf ._daeg ;};_gdege +=_bbef ;_beg =_gdege ;};return _beg ;};

// SetAngle sets the rotation angle of the text.
func (_eagag *StyledParagraph )SetAngle (angle float64 ){_eagag ._bbfa =angle };

// SetMargins sets the Paragraph's margins.
func (_dcbg *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_dcbg ._bbcf ._eagb =left ;_dcbg ._bbcf ._ggbd =right ;_dcbg ._bbcf ._egdb =top ;_dcbg ._bbcf ._daeg =bottom ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_fafba *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_fffc :=range subtable ._gggbg {_daae :=&TableCell {};*_daae =*_fffc ;_daae ._egcceb =_fafba ;_daae ._efcbc +=col -1;if _agg :=_fafba ._gccf -(_daae ._efcbc -1);_agg < _daae ._dgdef {_fafba ._gccf +=_daae ._dgdef -_agg ;_fafba .resetColumnWidths ();_bge .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_fafba ._gccf );};_daae ._aefe +=row -1;_dbbf :=subtable ._gbcf [_fffc ._aefe -1];if _daae ._aefe > _fafba ._dgfbg {for _daae ._aefe > _fafba ._dgfbg {_fafba ._dgfbg ++;_fafba ._gbcf =append (_fafba ._gbcf ,_fafba ._abbg );};_fafba ._gbcf [_daae ._aefe -1]=_dbbf ;}else {_fafba ._gbcf [_daae ._aefe -1]=_bg .Max (_fafba ._gbcf [_daae ._aefe -1],_dbbf );};_fafba ._gggbg =append (_fafba ._gggbg ,_daae );};_ff .Slice (_fafba ._gggbg ,func (_cfcf ,_debg int )bool {_cdaf :=_fafba ._gggbg [_cfcf ]._aefe ;_cbge :=_fafba ._gggbg [_debg ]._aefe ;if _cdaf < _cbge {return true ;};if _cdaf > _cbge {return false ;};return _fafba ._gggbg [_cfcf ]._efcbc < _fafba ._gggbg [_debg ]._efcbc ;});};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;func (_agda *Invoice )generateNoteBlocks (_gfb DrawContext )([]*Block ,DrawContext ,error ){_bggd :=_dafd ();_gfge :=append ([][2]string {_agda ._aea ,_agda ._bgcd },_agda ._dbag ...);for _ ,_fcbdc :=range _gfge {if _fcbdc [1]!=""{_fbge :=_agda .drawSection (_fcbdc [0],_fcbdc [1]);for _ ,_afbbc :=range _fbge {_bggd .Add (_afbbc );};_cafb :=_ebge (_agda ._fffd );_cafb .SetMargins (0,0,10,0);_bggd .Add (_cafb );};};return _bggd .GeneratePageBlocks (_gfb );};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_fbdg *List )Marker ()*TextChunk {return &_fbdg ._acbd };

// GetMargins returns the left, right, top, bottom Margins.
func (_bbfe *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bbfe ._dbcbe ._eagb ,_bbfe ._dbcbe ._ggbd ,_bbfe ._dbcbe ._egdb ,_bbfe ._dbcbe ._daeg ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_gfdf int ;_eag string ;_afd *Paragraph ;_aee []Drawable ;_cda int ;_ggad bool ;_bgd bool ;_bdg positioning ;_ccg ,_ggf float64 ;_acb margins ;_egdd *Chapter ;_fffa *TOC ;_acc *_bc .Outline ;_gea *_bc .OutlineItem ;_gag uint ;};func _geaa (_edef ,_dabc ,_dabb ,_aecg float64 )*Line {_eafc :=&Line {};_eafc ._fgde =_edef ;_eafc ._cede =_dabc ;_eafc ._ecce =_dabb ;_eafc ._bddc =_aecg ;_eafc ._afdb =_bc .NewPdfColorDeviceRGB (0,0,0);_eafc ._gdfc =1.0;return _eafc ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_gaae *Creator )RotateDeg (angleDeg int64 )error {_ged :=_gaae .getActivePage ();if _ged ==nil {_bge .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_bge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _bgff int64 ;if _ged .Rotate !=nil {_bgff =*(_ged .Rotate );};_bgff +=angleDeg ;_ged .Rotate =&_bgff ;return nil ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_cab *Image )ScaleToWidth (w float64 ){_edagf :=_cab ._bebbc /_cab ._bea ;_cab ._bea =w ;_cab ._bebbc =w *_edagf ;};func (_aeefa *Invoice )newColumn (_agf string ,_dacdc CellHorizontalAlignment )*InvoiceCell {_efeg :=&InvoiceCell {_aeefa ._cccf ,_agf };_efeg .Alignment =_dacdc ;return _efeg ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_ggaa *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ccdf :=ctx ;if _ggaa ._bdg .isRelative (){ctx .X +=_ggaa ._acb ._eagb ;ctx .Y +=_ggaa ._acb ._egdb ;ctx .Width -=_ggaa ._acb ._eagb +_ggaa ._acb ._ggbd ;ctx .Height -=_ggaa ._acb ._egdb ;};_def ,_bbf ,_gcdd :=_ggaa ._afd .GeneratePageBlocks (ctx );if _gcdd !=nil {return _def ,ctx ,_gcdd ;};ctx =_bbf ;_dge :=ctx .X ;_gabd :=ctx .Y -_ggaa ._afd .Height ();_cfggc :=int64 (ctx .Page );_cfdc :=_ggaa .headingNumber ();_dccf :=_ggaa .headingText ();if _ggaa ._bgd {_dcgg :=_ggaa ._fffa .Add (_cfdc ,_ggaa ._eag ,_gg .FormatInt (_cfggc ,10),_ggaa ._gag );if _ggaa ._fffa ._fadec {_dcgg .SetLink (_cfggc ,_dge ,_gabd );};};if _ggaa ._gea ==nil {_ggaa ._gea =_bc .NewOutlineItem (_dccf ,_bc .NewOutlineDest (_cfggc -1,_dge ,_gabd ));if _ggaa ._egdd !=nil {_ggaa ._egdd ._gea .Add (_ggaa ._gea );}else {_ggaa ._acc .Add (_ggaa ._gea );};}else {_ddbg :=&_ggaa ._gea .Dest ;_ddbg .Page =_cfggc -1;_ddbg .X =_dge ;_ddbg .Y =_gabd ;};for _ ,_dcef :=range _ggaa ._aee {_fedb ,_cdb ,_agd :=_dcef .GeneratePageBlocks (ctx );if _agd !=nil {return _def ,ctx ,_agd ;};if len (_fedb )< 1{continue ;};_def [len (_def )-1].mergeBlocks (_fedb [0]);_def =append (_def ,_fedb [1:]...);ctx =_cdb ;};if _ggaa ._bdg .isRelative (){ctx .X =_ccdf .X ;};if _ggaa ._bdg .isAbsolute (){return _def ,_ccdf ,nil ;};return _def ,ctx ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_edaa *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dccge :=ctx ;_fagad ,ctx ,_edacg :=_edaa ._gccaf .GeneratePageBlocks (ctx );if _edacg !=nil {return _fagad ,ctx ,_edacg ;};if _edaa ._dacf .isRelative (){ctx .X =_dccge .X ;};if _edaa ._dacf .isAbsolute (){return _fagad ,_dccge ,nil ;};return _fagad ,ctx ,nil ;};

// SetStyleRight sets border style for right side.
func (_fee *border )SetStyleRight (style CellBorderStyle ){_fee ._aafe =style };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_ggca *_bf .Polygon ;_gefdc float64 ;_cddf float64 ;};func _bgec (_ccbda *_bc .Image )(*Image ,error ){_ecbd :=float64 (_ccbda .Width );_gdac :=float64 (_ccbda .Height );return &Image {_aeef :_ccbda ,_aaca :_ecbd ,_cff :_gdac ,_bea :_ecbd ,_bebbc :_gdac ,_bggc :0,_gffb :1.0,_bcfa :_feeg },nil ;};func (_ceec *Table )resetColumnWidths (){_ceec ._gbea =[]float64 {};_cgbec :=float64 (1.0)/float64 (_ceec ._gccf );for _feff :=0;_feff < _ceec ._gccf ;_feff ++{_ceec ._gbea =append (_ceec ._gbea ,_cgbec );};};func (_ace *Invoice )generateInformationBlocks (_fgfd DrawContext )([]*Block ,DrawContext ,error ){_ecef :=_ebge (_ace ._fffd );_ecef .SetMargins (0,0,0,20);_gcef :=_ace .drawAddress (_ace ._effe );_gcef =append (_gcef ,_ecef );_gcef =append (_gcef ,_ace .drawAddress (_ace ._eefe )...);_bdcga :=_dafd ();for _ ,_adgae :=range _gcef {_bdcga .Add (_adgae );};_fdggg :=_ace .drawInformation ();_bedaf :=_edg (2);_bedaf .SetMargins (0,0,25,0);_begaa :=_bedaf .NewCell ();_begaa .SetIndent (0);_begaa .SetContent (_bdcga );_begaa =_bedaf .NewCell ();_begaa .SetContent (_fdggg );return _bedaf .GeneratePageBlocks (_fgfd );};

// AddTotalLine adds a new line in the invoice totals table.
func (_dacd *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_dbce :=&InvoiceCell {_dacd ._dccd ,desc };_gcff :=&InvoiceCell {_dacd ._dccd ,value };_dacd ._cbcdg =append (_dacd ._cbcdg ,[2]*InvoiceCell {_dbce ,_gcff });return _dbce ,_gcff ;};

// Lines returns all the rows of the invoice line items table.
func (_fgaf *Invoice )Lines ()[][]*InvoiceCell {return _fgaf ._bagg };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_fdg :=&Block {};_fdg ._ae =&_d .ContentStreamOperations {};_fdg ._fd =_bc .NewPdfPageResources ();_fdg ._ee =width ;_fdg ._gfc =height ;return _fdg ;};func (_cfgd positioning )isRelative ()bool {return _cfgd ==_feeg };

// SetInline sets the inline mode of the division.
func (_aacc *Division )SetInline (inline bool ){_aacc ._cgga =inline };func _bda (_dfc *Chapter ,_dgde *TOC ,_addb *_bc .Outline ,_ecf string ,_bab int ,_deg TextStyle )*Chapter {var _cgge uint =1;if _dfc !=nil {_cgge =_dfc ._gag +1;};_cdd :=&Chapter {_gfdf :_bab ,_eag :_ecf ,_ggad :true ,_bgd :true ,_egdd :_dfc ,_fffa :_dgde ,_acc :_addb ,_aee :[]Drawable {},_gag :_cgge };_afacc :=_ffdgb (_cdd .headingText (),_deg );_afacc .SetFont (_deg .Font );_afacc .SetFontSize (_deg .FontSize );_cdd ._afd =_afacc ;return _cdd ;};

// Angle returns the block rotation angle in degrees.
func (_da *Block )Angle ()float64 {return _da ._fe };func _ffef (_deag *_bc .PdfRectangle ,_degbce _aa .Matrix )*_bc .PdfRectangle {var _cacb _bc .PdfRectangle ;_cacb .Llx ,_cacb .Lly =_degbce .Transform (_deag .Llx ,_deag .Lly );_cacb .Urx ,_cacb .Ury =_degbce .Transform (_deag .Urx ,_deag .Ury );_cacb .Normalize ();return &_cacb ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_dcdfb *_bc .PdfColorDeviceRGB ;_agaa _bf .LineStyle ;_caged CellBorderStyle ;_gdbg *_bc .PdfColorDeviceRGB ;_bfce float64 ;_gaeb CellBorderStyle ;_bgag *_bc .PdfColorDeviceRGB ;_baggc float64 ;_dgecf CellBorderStyle ;_fegcg *_bc .PdfColorDeviceRGB ;_efba float64 ;_ecaa CellBorderStyle ;_abaceg *_bc .PdfColorDeviceRGB ;_aaed float64 ;_aefe ,_efcbc int ;_gbbbd int ;_dgdef int ;_bcdac VectorDrawable ;_fdab CellHorizontalAlignment ;_faad CellVerticalAlignment ;_fbbd float64 ;_egcceb *Table ;};func _fac (_adfd string )(*Image ,error ){_eeaeb ,_cdde :=_e .Open (_adfd );if _cdde !=nil {return nil ,_cdde ;};defer _eeaeb .Close ();_ceg ,_cdde :=_bc .ImageHandling .Read (_eeaeb );if _cdde !=nil {_bge .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cdde );return nil ,_cdde ;};return _bgec (_ceg );};

// SetStyleLeft sets border style for left side.
func (_gabe *border )SetStyleLeft (style CellBorderStyle ){_gabe ._dded =style };

// SetDate sets the date of the invoice.
func (_fgge *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_fgge ._degb [1].Value =date ;return _fgge ._degb [0],_fgge ._degb [1];};

// NewImage create a new image from a unidoc image (model.Image).
func (_fbgd *Creator )NewImage (img *_bc .Image )(*Image ,error ){return _bgec (img )};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_cfgc *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aagce :=ctx ;var _defa []*Block ;_beca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cfgc ._bddfc .isRelative (){ctx .X +=_cfgc ._bbcf ._eagb ;ctx .Y +=_cfgc ._bbcf ._egdb ;ctx .Width -=_cfgc ._bbcf ._eagb +_cfgc ._bbcf ._ggbd ;ctx .Height -=_cfgc ._bbcf ._egdb +_cfgc ._bbcf ._daeg ;_cfgc .SetWidth (ctx .Width );}else {if int (_cfgc ._faa )<=0{_cfgc .SetWidth (_cfgc .getTextWidth ());};ctx .X =_cfgc ._fbgc ;ctx .Y =_cfgc ._gfcc ;};if _cfgc ._gefc !=nil {_cfgc ._gefc (_cfgc ,ctx );};if _gfcb :=_cfgc .wrapText ();_gfcb !=nil {return nil ,ctx ,_gfcb ;};_fbce :=_cfgc ._gcded ;for {_afcbc ,_cffa ,_fegc :=_cggf (_beca ,_cfgc ,_fbce ,ctx );if _fegc !=nil {_bge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fegc );return nil ,ctx ,_fegc ;};ctx =_afcbc ;_defa =append (_defa ,_beca );if _fbce =_cffa ;len (_cffa )==0{break ;};_beca =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_afcbc =ctx ;_afcbc .Y =ctx .Margins ._egdb ;_afcbc .X =ctx .Margins ._eagb +_cfgc ._bbcf ._eagb ;_afcbc .Height =ctx .PageHeight -ctx .Margins ._egdb -ctx .Margins ._daeg -_cfgc ._bbcf ._daeg ;_afcbc .Width =ctx .PageWidth -ctx .Margins ._eagb -ctx .Margins ._ggbd -_cfgc ._bbcf ._eagb -_cfgc ._bbcf ._ggbd ;ctx =_afcbc ;};if _cfgc ._bddfc .isRelative (){ctx .X -=_cfgc ._bbcf ._eagb ;ctx .Width =_aagce .Width ;return _defa ,ctx ,nil ;};return _defa ,_aagce ,nil ;};

// Columns returns all the columns in the invoice line items table.
func (_eccb *Invoice )Columns ()[]*InvoiceCell {return _eccb ._cadd };

// SetColorRight sets border color for right.
func (_ebc *border )SetColorRight (col Color ){_ebc ._bca =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_defb *Creator )NewPage ()*_bc .PdfPage {_bdf :=_defb .newPage ();_defb ._ecfa =append (_defb ._ecfa ,_bdf );_defb ._bbed .Page ++;return _bdf ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_fgddd *Invoice )InfoLines ()[][2]*InvoiceCell {_cggad :=[][2]*InvoiceCell {_fgddd ._gedf ,_fgddd ._degb ,_fgddd ._bega };return append (_cggad ,_fgddd ._abdf ...);};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_adde *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_cfcb :=[2]*InvoiceCell {_adde .newCell (description ,_adde ._afae ),_adde .newCell (value ,_adde ._afae )};_adde ._abdf =append (_adde ._abdf ,_cfcb );return _cfcb [0],_cfcb [1];};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_fede *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_fede ._cgde =toc ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_fffg *StyledParagraph )SetEnableWrap (enableWrap bool ){_fffg ._eab =enableWrap ;_fffg ._cecg =false ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_bcbd *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bcbd ._eaga ._eagb ,_bcbd ._eaga ._ggbd ,_bcbd ._eaga ._egdb ,_bcbd ._eaga ._daeg ;};

// SetFillOpacity sets the fill opacity.
func (_cgbe *Polygon )SetFillOpacity (opacity float64 ){_cgbe ._gefdc =opacity };func _ecda (_dbec int64 ,_aabe ,_eaab ,_ebfe float64 )*_bc .PdfAnnotation {_ffaa :=_bc .NewPdfAnnotationLink ();_bfgg :=_bc .NewBorderStyle ();_bfgg .SetBorderWidth (0);_ffaa .BS =_bfgg .ToPdfObject ();if _dbec < 0{_dbec =0;};_ffaa .Dest =_ffg .MakeArray (_ffg .MakeInteger (_dbec ),_ffg .MakeName ("\u0058\u0059\u005a"),_ffg .MakeFloat (_aabe ),_ffg .MakeFloat (_eaab ),_ffg .MakeFloat (_ebfe ));return _ffaa .PdfAnnotation ;};func (_dfgb *StyledParagraph )getTextLineWidth (_dcae []*TextChunk )float64 {var _dccgc float64 ;_gdgc :=len (_dcae );for _dbcb ,_fega :=range _dcae {_gfef :=&_fega .Style ;_fdfb :=len (_fega .Text );for _geaf ,_fdcb :=range _fega .Text {if _fdcb =='\u000A'{continue ;};_ccceb ,_geafb :=_gfef .Font .GetRuneMetrics (_fdcb );if !_geafb {_bge .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fdcb );return -1;};_dccgc +=_gfef .FontSize *_ccceb .Wx ;if _fdcb !=' '&&(_dbcb !=_gdgc -1||_geaf !=_fdfb -1){_dccgc +=_gfef .CharSpacing *1000.0;};};};return _dccgc ;};

// Context returns the current drawing context.
func (_eeed *Creator )Context ()DrawContext {return _eeed ._bbed };

// NewTOC creates a new table of contents.
func (_dbgd *Creator )NewTOC (title string )*TOC {_aff :=_dbgd .NewTextStyle ();_aff .Font =_dbgd ._eee ;return _abdfg (title ,_dbgd .NewTextStyle (),_aff );};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_cgc *TOC )SetLineNumberStyle (style TextStyle ){_cgc ._fgeg =style };func (_bged *Block )setOpacity (_aec float64 ,_af float64 )(string ,error ){if (_aec < 0||_aec >=1.0)&&(_af < 0||_af >=1.0){return "",nil ;};_de :=0;_bfb :=_a .Sprintf ("\u0047\u0053\u0025\u0064",_de );for _bged ._fd .HasExtGState (_ffg .PdfObjectName (_bfb )){_de ++;_bfb =_a .Sprintf ("\u0047\u0053\u0025\u0064",_de );};_ega :=_ffg .MakeDict ();if _aec >=0&&_aec < 1.0{_ega .Set ("\u0063\u0061",_ffg .MakeFloat (_aec ));};if _af >=0&&_af < 1.0{_ega .Set ("\u0043\u0041",_ffg .MakeFloat (_af ));};_bfbf :=_bged ._fd .AddExtGState (_ffg .PdfObjectName (_bfb ),_ega );if _bfbf !=nil {return "",_bfbf ;};return _bfb ,nil ;};

// AppendColumn appends a column to the line items table.
func (_gffc *Invoice )AppendColumn (description string )*InvoiceCell {_dgcb :=_gffc .NewColumn (description );_gffc ._cadd =append (_gffc ._cadd ,_dgcb );return _dgcb ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// Width returns the current page width.
func (_gdg *Creator )Width ()float64 {return _gdg ._gacc };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_efc *Creator )SetOptimizer (optimizer _bc .Optimizer ){_efc ._ccce =optimizer };

// TOC returns the table of contents component of the creator.
func (_cbf *Creator )TOC ()*TOC {return _cbf ._cgde };func (_cfda *Chapter )headingNumber ()string {var _ebg string ;if _cfda ._ggad {if _cfda ._gfdf !=0{_ebg =_gg .Itoa (_cfda ._gfdf )+"\u002e";};if _cfda ._egdd !=nil {_dgdg :=_cfda ._egdd .headingNumber ();if _dgdg !=""{_ebg =_dgdg +_ebg ;};};};return _ebg ;};func (_gaad *Invoice )generateTotalBlocks (_dcbc DrawContext )([]*Block ,DrawContext ,error ){_aafa :=_edg (4);_aafa .SetMargins (0,0,10,10);_dceb :=[][2]*InvoiceCell {_gaad ._cbea };_dceb =append (_dceb ,_gaad ._cbcdg ...);_dceb =append (_dceb ,_gaad ._ddbc );for _ ,_dcgd :=range _dceb {_bead ,_befe :=_dcgd [0],_dcgd [1];if _befe .Value ==""{continue ;};_aafa .SkipCells (2);_aagc :=_aafa .NewCell ();_aagc .SetBackgroundColor (_bead .BackgroundColor );_aagc .SetHorizontalAlignment (_befe .Alignment );_gaad .setCellBorder (_aagc ,_bead );_gddf :=_ebge (_bead .TextStyle );_gddf .SetMargins (0,0,2,1);_gddf .Append (_bead .Value );_aagc .SetContent (_gddf );_aagc =_aafa .NewCell ();_aagc .SetBackgroundColor (_befe .BackgroundColor );_aagc .SetHorizontalAlignment (_befe .Alignment );_gaad .setCellBorder (_aagc ,_bead );_gddf =_ebge (_befe .TextStyle );_gddf .SetMargins (0,0,2,1);_gddf .Append (_befe .Value );_aagc .SetContent (_gddf );};return _aafa .GeneratePageBlocks (_dcbc );};

// SetPos sets absolute positioning with specified coordinates.
func (_cgdc *Paragraph )SetPos (x ,y float64 ){_cgdc ._efcfe =_bgaf ;_cgdc ._gcca =x ;_cgdc ._ccgd =y };func (_cdf *FilledCurve )draw (_agec string )([]byte ,*_bc .PdfRectangle ,error ){_fcgdf :=_bf .NewCubicBezierPath ();for _ ,_efcd :=range _cdf ._bcf {_fcgdf =_fcgdf .AppendCurve (_efcd );};creator :=_d .NewContentCreator ();creator .Add_q ();if _cdf .FillEnabled {creator .Add_rg (_cdf ._badb .R (),_cdf ._badb .G (),_cdf ._badb .B ());};if _cdf .BorderEnabled {creator .Add_RG (_cdf ._bgfb .R (),_cdf ._bgfb .G (),_cdf ._bgfb .B ());creator .Add_w (_cdf .BorderWidth );};if len (_agec )> 1{creator .Add_gs (_ffg .PdfObjectName (_agec ));};_bf .DrawBezierPathWithCreator (_fcgdf ,creator );creator .Add_h ();if _cdf .FillEnabled &&_cdf .BorderEnabled {creator .Add_B ();}else if _cdf .FillEnabled {creator .Add_f ();}else if _cdf .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_fcca :=_fcgdf .GetBoundingBox ();if _cdf .BorderEnabled {_fcca .Height +=_cdf .BorderWidth ;_fcca .Width +=_cdf .BorderWidth ;_fcca .X -=_cdf .BorderWidth /2;_fcca .Y -=_cdf .BorderWidth /2;};_ccga :=&_bc .PdfRectangle {};_ccga .Llx =_fcca .X ;_ccga .Lly =_fcca .Y ;_ccga .Urx =_fcca .X +_fcca .Width ;_ccga .Ury =_fcca .Y +_fcca .Height ;return creator .Bytes (),_ccga ,nil ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_efeec *_bf .PolyBezierCurve ;_ebbb float64 ;_fccf float64 ;};func (_afde *Invoice )newCell (_bdda string ,_affe InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_affe ,_bdda };};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_gcb *Creator )SetOutlineTree (outlineTree *_bc .PdfOutlineTreeNode ){_gcb ._bfaf =outlineTree };

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_bg .Max (_bg .Min (r ,1.0),0.0);g =_bg .Max (_bg .Min (g ,1.0),0.0);b =_bg .Max (_bg .Min (b ,1.0),0.0);_gdbb :=rgbColor {};_gdbb ._aaeg =r ;_gdbb ._bad =g ;_gdbb ._dddc =b ;return _gdbb ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_ccfe float64 ;_egde float64 ;_egbf float64 ;_bfdf float64 ;_gabg *_bc .PdfColorDeviceRGB ;_dgcf float64 ;_gabf *_bc .PdfColorDeviceRGB ;_fdee float64 ;_aabd float64 ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {_gdad :=&Creator {};_gdad ._ecfa =[]*_bc .PdfPage {};_gdad ._acg =map[*_bc .PdfPage ]*Block {};_gdad .SetPageSize (PageSizeLetter );_dgeg :=0.1*_gdad ._gacc ;_gdad ._fgbg ._eagb =_dgeg ;_gdad ._fgbg ._ggbd =_dgeg ;_gdad ._fgbg ._egdb =_dgeg ;_gdad ._fgbg ._daeg =_dgeg ;var _gbf error ;_gdad ._fage ,_gbf =_bc .NewStandard14Font (_bc .HelveticaName );if _gbf !=nil {_gdad ._fage =_bc .DefaultFont ();};_gdad ._eee ,_gbf =_bc .NewStandard14Font (_bc .HelveticaBoldName );if _gbf !=nil {_gdad ._fage =_bc .DefaultFont ();};_gdad ._cgde =_gdad .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_gdad .AddOutlines =true ;_gdad ._fae =_bc .NewOutline ();return _gdad ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ffab *Creator )SetPageLabels (pageLabels _ffg .PdfObject ){_ffab ._abac =pageLabels };

// WriteToFile writes the Creator output to file specified by path.
func (_ddgb *Creator )WriteToFile (outputPath string )error {_dccc ,_feg :=_e .Create (outputPath );if _feg !=nil {return _feg ;};defer _dccc .Close ();return _ddgb .Write (_dccc );};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// Width returns Image's document width.
func (_cfaa *Image )Width ()float64 {return _cfaa ._bea };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ebbbc *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggdg :=ctx ;_fffag ,ctx ,_caab :=_ebbbc ._dfbb .GeneratePageBlocks (ctx );if _caab !=nil {return _fffag ,ctx ,_caab ;};for _ ,_gcaa :=range _ebbbc ._fecfb {_cfag :=_gcaa ._edbce ;if !_ebbbc ._fadec {_gcaa ._edbce =0;};_ccbag ,_gced ,_eagfb :=_gcaa .GeneratePageBlocks (ctx );_gcaa ._edbce =_cfag ;if _eagfb !=nil {return _fffag ,ctx ,_eagfb ;};if len (_ccbag )< 1{continue ;};_fffag [len (_fffag )-1].mergeBlocks (_ccbag [0]);_fffag =append (_fffag ,_ccbag [1:]...);ctx =_gced ;};if _ebbbc ._gcab .isRelative (){ctx .X =_ggdg .X ;};if _ebbbc ._gcab .isAbsolute (){return _fffag ,_ggdg ,nil ;};return _fffag ,ctx ,nil ;};

// SetMargins sets the Paragraph's margins.
func (_abef *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_abef ._ecccb ._eagb =left ;_abef ._ecccb ._ggbd =right ;_abef ._ecccb ._egdb =top ;_abef ._ecccb ._daeg =bottom ;};

// Width returns the cell's width based on the input draw context.
func (_gbef *TableCell )Width (ctx DrawContext )float64 {_becgb :=float64 (0.0);for _aaffb :=0;_aaffb < _gbef ._dgdef ;_aaffb ++{_becgb +=_gbef ._egcceb ._gbea [_gbef ._efcbc +_aaffb -1];};_bfaea :=ctx .Width *_becgb ;return _bfaea ;};func _ddbca (_gbgd [][]_bf .Point )*Polygon {return &Polygon {_ggca :&_bf .Polygon {Points :_gbgd },_gefdc :1.0,_cddf :1.0};};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_cffe *StyledParagraph )Insert (index uint ,text string )*TextChunk {_bgab :=uint (len (_cffe ._dcfef ));if index > _bgab {index =_bgab ;};_egdfb :=NewTextChunk (text ,_cffe ._cged );_cffe ._dcfef =append (_cffe ._dcfef [:index ],append ([]*TextChunk {_egdfb },_cffe ._dcfef [index :]...)...);_cffe .wrapText ();return _egdfb ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_adb *Block )AddAnnotation (annotation *_bc .PdfAnnotation ){for _ ,_aaef :=range _adb ._fg {if _aaef ==annotation {return ;};};_adb ._fg =append (_adb ._fg ,annotation );};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_face *TOC )SetLineTitleStyle (style TextStyle ){_face ._ceeda =style };

// SetBorderColor sets border color.
func (_ddbb *Rectangle )SetBorderColor (col Color ){_ddbb ._gabf =_bc .NewPdfColorDeviceRGB (col .ToRGB ());};

// SetBorderWidth sets the border width.
func (_cbab *Ellipse )SetBorderWidth (bw float64 ){_cbab ._cdcd =bw };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_fbe *TOC )SetHeading (text string ,style TextStyle ){_addce :=_fbe .Heading ();_addce .Reset ();_adag :=_addce .Append (text );_adag .Style =style ;};

// Reset removes all the text chunks the paragraph contains.
func (_ccee *StyledParagraph )Reset (){_ccee ._dcfef =[]*TextChunk {}};func _debd (_adgag *_e .File )([]*_bc .PdfPage ,error ){_agefe ,_gddea :=_bc .NewPdfReader (_adgag );if _gddea !=nil {return nil ,_gddea ;};_dgdga ,_gddea :=_agefe .GetNumPages ();if _gddea !=nil {return nil ,_gddea ;};var _cccg []*_bc .PdfPage ;for _fadee :=0;_fadee < _dgdga ;_fadee ++{_eecf ,_aecf :=_agefe .GetPage (_fadee +1);if _aecf !=nil {return nil ,_aecf ;};_cccg =append (_cccg ,_eecf );};return _cccg ,nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_cage *StyledParagraph )SetPos (x ,y float64 ){_cage ._bddfc =_bgaf ;_cage ._fbgc =x ;_cage ._gfcc =y ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gfab *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _edc float64 ;var _gdgdf []*StyledParagraph ;for _ ,_gcfd :=range _gfab ._aaaf {_cbac :=_ebge (_gfab ._bdbg );_cbac .SetEnableWrap (false );_cbac .SetTextAlignment (TextAlignmentRight );_cbac .Append (_gcfd ._baeb .Text ).Style =_gcfd ._baeb .Style ;_cgeg :=_cbac .getTextWidth ()/1000.0/ctx .Width ;if _edc < _cgeg {_edc =_cgeg ;};_gdgdf =append (_gdgdf ,_cbac );};_ddad :=_edg (2);_ddad .SetColumnWidths (_edc ,1-_edc );_ddad .SetMargins (_gfab ._dgag ,0,0,0);for _fceg ,_cffb :=range _gfab ._aaaf {_aefb :=_ddad .NewCell ();_aefb .SetIndent (0);_aefb .SetContent (_gdgdf [_fceg ]);_aefb =_ddad .NewCell ();_aefb .SetIndent (0);_aefb .SetContent (_cffb ._acdfc );};return _ddad .GeneratePageBlocks (ctx );};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_bcc *Block )ScaleToHeight (h float64 ){_gba :=h /_bcc ._gfc ;_bcc .Scale (_gba ,_gba )};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_fdbcf *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_fdbcf ._fcdf =alignment };

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_dafb *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcdcb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbge :=_bf .Rectangle {Opacity :1.0,X :_dafb ._ccfe ,Y :ctx .PageHeight -_dafb ._egde -_dafb ._bfdf ,Height :_dafb ._bfdf ,Width :_dafb ._egbf };if _dafb ._gabg !=nil {_gbge .FillEnabled =true ;_gbge .FillColor =_dafb ._gabg ;};if _dafb ._gabf !=nil &&_dafb ._fdee > 0{_gbge .BorderEnabled =true ;_gbge .BorderColor =_dafb ._gabf ;_gbge .BorderWidth =_dafb ._fdee ;};_eccbc ,_cddfc :=_gcdcb .setOpacity (_dafb ._dgcf ,_dafb ._aabd );if _cddfc !=nil {return nil ,ctx ,_cddfc ;};_efga ,_ ,_cddfc :=_gbge .Draw (_eccbc );if _cddfc !=nil {return nil ,ctx ,_cddfc ;};if _cddfc =_gcdcb .addContentsByString (string (_efga ));_cddfc !=nil {return nil ,ctx ,_cddfc ;};return []*Block {_gcdcb },ctx ,nil ;};

// SetFillColor sets background color for border.
func (_ggg *border )SetFillColor (col Color ){_ggg ._efa =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};func (_fdfaa *Paragraph )wrapText ()error {if !_fdfaa ._dgf ||int (_fdfaa ._faeg )<=0{_fdfaa ._dced =[]string {_fdfaa ._fccag };return nil ;};_gdgf :=NewTextChunk (_fdfaa ._fccag ,TextStyle {Font :_fdfaa ._abcd ,FontSize :_fdfaa ._bgebc });_fcab ,_fagga :=_gdgf .Wrap (_fdfaa ._faeg );if _fagga !=nil {return _fagga ;};if _fdfaa ._cgba > 0&&len (_fcab )> _fdfaa ._cgba {_fcab =_fcab [:_fdfaa ._cgba ];};_fdfaa ._dced =_fcab ;return nil ;};

// Append adds a new text chunk to the paragraph.
func (_fgbcg *StyledParagraph )Append (text string )*TextChunk {_fbcd :=NewTextChunk (text ,_fgbcg ._cged );return _fgbcg .appendChunk (_fbcd );};var PPI float64 =72;

// Height returns the total height of all rows.
func (_dagg *Table )Height ()float64 {_afbbe :=float64 (0.0);for _ ,_aebe :=range _dagg ._gbcf {_afbbe +=_aebe ;};return _afbbe ;};

// SetFillOpacity sets the fill opacity.
func (_abee *Rectangle )SetFillOpacity (opacity float64 ){_abee ._dgcf =opacity };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ggbc *Block )Draw (d Drawable )error {_ea :=DrawContext {};_ea .Width =_ggbc ._ee ;_ea .Height =_ggbc ._gfc ;_ea .PageWidth =_ggbc ._ee ;_ea .PageHeight =_ggbc ._gfc ;_ea .X =0;_ea .Y =0;_cfdf ,_ ,_fb :=d .GeneratePageBlocks (_ea );if _fb !=nil {return _fb ;};if len (_cfdf )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ecb :=range _cfdf {if _cd :=_ggbc .mergeBlocks (_ecb );_cd !=nil {return _cd ;};};return nil ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_dacc *Table )SetPos (x ,y float64 ){_dacc ._bafe =_bgaf ;_dacc ._dagc =x ;_dacc ._degba =y };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_dbe *Block )ScaleToWidth (w float64 ){_cg :=w /_dbe ._ee ;_dbe .Scale (_cg ,_cg )};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_dddcg *TOC )SetLineSeparatorStyle (style TextStyle ){_dddcg ._cbed =style };func _bgbd (_dcefd []_bf .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_efeec :&_bf .PolyBezierCurve {Curves :_dcefd ,BorderColor :_bc .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_ebbb :1.0,_fccf :1.0};};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// Notes returns the notes section of the invoice as a title-content pair.
func (_ecfcf *Invoice )Notes ()(string ,string ){return _ecfcf ._aea [0],_ecfcf ._aea [1]};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_fccag string ;_abcd *_bc .PdfFont ;_bgebc float64 ;_eded float64 ;_bcbbb _bc .PdfColorDeviceRGB ;_eceb TextAlignment ;_dgf bool ;_faeg float64 ;_cgba int ;_gfgaf bool ;_ggfa float64 ;_ecccb margins ;_efcfe positioning ;_gcca float64 ;_ccgd float64 ;_fegb ,_gdbd float64 ;_dced []string ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_edbc *Creator )EnableFontSubsetting (font *_bc .PdfFont ){_edbc ._efd =append (_edbc ._efd ,font )};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gcg *Creator )NewParagraph (text string )*Paragraph {return _ffdgb (text ,_gcg .NewTextStyle ())};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_fgbgg *Creator )AddPage (page *_bc .PdfPage )error {_aca ,_eae :=page .GetMediaBox ();if _eae !=nil {_bge .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_eae );return _eae ;};_aca .Normalize ();_ebf ,_cgfd :=_aca .Llx ,_aca .Lly ;_cceg :=_aa .IdentityMatrix ();_aad :=page .Rotate ;_cad :=_aad !=nil &&*_aad %360!=0&&*_aad %90==0;if _cad {_fcgda :=float64 ((360+*page .Rotate %360)%360);_cceg =_aa .RotationMatrix (_fcgda *_bg .Pi /180);if _fcgda ==90{_cceg =_cceg .Translate (_aca .Width (),0);}else if _fcgda ==180{_cceg =_cceg .Translate (_aca .Width (),_aca .Height ());}else if _fcgda ==270{_cceg =_cceg .Translate (0,_aca .Height ());};_cceg =_cceg .Round (0.000001);_dbbga :=_ffef (_aca ,_cceg );_aca =_dbbga ;_aca .Normalize ();};if _ebf !=0||_cgfd !=0{_cceg =_cceg .Translate (_ebf ,_cgfd );};if !_cceg .Identity (){if _fgbgg ._cgd ==nil {_fgbgg ._cgd =map[*_bc .PdfPage ]_aa .Matrix {};};_cceg =_cceg .Round (0.000001);_fgbgg ._cgd [page ]=_cceg ;};_fgbgg ._gacc =_aca .Width ();_fgbgg ._afdg =_aca .Height ();_fgbgg .initContext ();_fgbgg ._ecfa =append (_fgbgg ._ecfa ,page );_fgbgg ._bbed .Page ++;return nil ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_aaaf []*listItem ;_ecab margins ;_acbd TextChunk ;_dgag float64 ;_gdde bool ;_gcffb positioning ;_bdbg TextStyle ;};func (_cedb *Invoice )drawSection (_afcc ,_baab string )[]*StyledParagraph {var _dfeb []*StyledParagraph ;if _afcc !=""{_feeb :=_ebge (_cedb ._ecae );_feeb .SetMargins (0,0,0,5);_feeb .Append (_afcc );_dfeb =append (_dfeb ,_feeb );};if _baab !=""{_ecbdc :=_ebge (_cedb ._dcb );_ecbdc .Append (_baab );_dfeb =append (_dfeb ,_ecbdc );};return _dfeb ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_add *Block )SetMargins (left ,right ,top ,bottom float64 ){_add ._aae ._eagb =left ;_add ._aae ._ggbd =right ;_add ._aae ._egdb =top ;_add ._aae ._daeg =bottom ;};func _ebge (_baggb TextStyle )*StyledParagraph {return &StyledParagraph {_dcfef :[]*TextChunk {},_cged :_baggb ,_bgbf :_cebb (_baggb .Font ),_eadg :1.0,_fec :TextAlignmentLeft ,_eab :true ,_cecg :true ,_bbfa :0,_cfac :1,_dcag :1,_bddfc :_feeg };};func (_eed *Creator )newPage ()*_bc .PdfPage {_bdd :=_bc .NewPdfPage ();_eeae :=_eed ._dddcb [0];_badg :=_eed ._dddcb [1];_cdbb :=_bc .PdfRectangle {Llx :0,Lly :0,Urx :_eeae ,Ury :_badg };_bdd .MediaBox =&_cdbb ;_eed ._gacc =_eeae ;_eed ._afdg =_badg ;_eed .initContext ();return _bdd ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_afbe *Creator )NewImageFromGoImage (goimg _ga .Image )(*Image ,error ){return _dgbg (goimg )};

// SetFontSize sets the font size in document units (points).
func (_caacb *Paragraph )SetFontSize (fontSize float64 ){_caacb ._bgebc =fontSize };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_bccfg *Creator )MoveDown (dy float64 ){_bccfg ._bbed .Y +=dy };func (_gde *Block )addContents (_bb *_d .ContentStreamOperations ){_gde ._ae .WrapIfNeeded ();_bb .WrapIfNeeded ();*_gde ._ae =append (*_gde ._ae ,*_bb ...);};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_facc *TOC )SetShowLinks (showLinks bool ){_facc ._fadec =showLinks };

// SetText replaces all the text of the paragraph with the specified one.
func (_bace *StyledParagraph )SetText (text string )*TextChunk {_bace .Reset ();return _bace .Append (text );};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_dacg *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egcf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fcef ,_beec :=_egcf .setOpacity (_dacg ._gefdc ,_dacg ._cddf );if _beec !=nil {return nil ,ctx ,_beec ;};_dgee :=_dacg ._ggca ;_dgee .FillEnabled =_dgee .FillColor !=nil ;_dgee .BorderEnabled =_dgee .BorderColor !=nil &&_dgee .BorderWidth > 0;_feea :=_dgee .Points ;for _gdff :=range _feea {for _bcea :=range _feea [_gdff ]{_bgfc :=&_feea [_gdff ][_bcea ];_bgfc .Y =ctx .PageHeight -_bgfc .Y ;};};_ebbc ,_ ,_beec :=_dgee .Draw (_fcef );if _beec !=nil {return nil ,ctx ,_beec ;};if _beec =_egcf .addContentsByString (string (_ebbc ));_beec !=nil {return nil ,ctx ,_beec ;};return []*Block {_egcf },ctx ,nil ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// SetBorder sets the cell's border style.
func (_gadf *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_gadf ._caged =CellBorderStyleSingle ;_gadf ._bfce =width ;_gadf ._gaeb =CellBorderStyleSingle ;_gadf ._baggc =width ;_gadf ._dgecf =CellBorderStyleSingle ;_gadf ._efba =width ;_gadf ._ecaa =CellBorderStyleSingle ;_gadf ._aaed =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_gadf ._caged =CellBorderStyleDouble ;_gadf ._bfce =width ;_gadf ._gaeb =CellBorderStyleDouble ;_gadf ._baggc =width ;_gadf ._dgecf =CellBorderStyleDouble ;_gadf ._efba =width ;_gadf ._ecaa =CellBorderStyleDouble ;_gadf ._aaed =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_gadf ._caged =style ;_gadf ._bfce =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_gadf ._gaeb =style ;_gadf ._baggc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_gadf ._dgecf =style ;_gadf ._efba =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_gadf ._ecaa =style ;_gadf ._aaed =width ;};};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_bgf :=rgbColor {};_bgf ._aaeg =float64 (r )/255.0;_bgf ._bad =float64 (g )/255.0;_bgf ._dddc =float64 (b )/255.0;return _bgf ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_cffg *Image )GetHorizontalAlignment ()HorizontalAlignment {return _cffg ._fcdf };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bcbb *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _bcbb ._gedf [0],_bcbb ._gedf [1]};

// SetTerms sets the terms and conditions section of the invoice.
func (_dfeg *Invoice )SetTerms (title ,content string ){_dfeg ._bgcd =[2]string {title ,content }};

// GetCoords returns coordinates of border.
func (_fca *border )GetCoords ()(float64 ,float64 ){return _fca ._ecg ,_fca ._bfdd };func _dffd (_gcgca string )*_bc .PdfAnnotation {_cadeg :=_bc .NewPdfAnnotationLink ();_cbag :=_bc .NewBorderStyle ();_cbag .SetBorderWidth (0);_cadeg .BS =_cbag .ToPdfObject ();_bcdb :=_bc .NewPdfActionURI ();_bcdb .URI =_ffg .MakeString (_gcgca );_cadeg .SetAction (_bcdb .PdfAction );return _cadeg .PdfAnnotation ;};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_fbba *Division )Width ()float64 {return 0};

// GetOptimizer returns current PDF optimizer.
func (_bbeb *Creator )GetOptimizer ()_bc .Optimizer {return _bbeb ._ccce };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_dagb *Creator )NewPolyBezierCurve (curves []_bf .CubicBezierCurve )*PolyBezierCurve {return _bgbd (curves );};

// NewPageBreak create a new page break.
func (_abaa *Creator )NewPageBreak ()*PageBreak {return _efdgf ()};

// SetOpacity sets opacity for Image.
func (_begf *Image )SetOpacity (opacity float64 ){_begf ._gffb =opacity };const (_feeg positioning =iota ;_bgaf ;);

// CurRow returns the currently active cell's row number.
func (_efed *Table )CurRow ()int {_afcg :=(_efed ._gcbb -1)/_efed ._gccf +1;return _afcg };

// DrawWithContext draws the Block using the specified drawing context.
func (_fdb *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_gec ,_ ,_ed :=d .GeneratePageBlocks (ctx );if _ed !=nil {return _ed ;};if len (_gec )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_fdbc :=range _gec {if _egc :=_fdb .mergeBlocks (_fdbc );_egc !=nil {return _egc ;};};return nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_abeg float64 ;_eace float64 ;_aaff float64 ;_aabg float64 ;_ffdd *_bc .PdfColorDeviceRGB ;_gfdfe *_bc .PdfColorDeviceRGB ;_cdcd float64 ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_cdbbf *TOCLine )SetLevelOffset (levelOffset float64 ){_cdbbf ._ggfe =levelOffset ;_cdbbf ._gccaf ._bbcf ._eagb =_cdbbf ._gfcf +float64 (_cdbbf ._egecc -1)*_cdbbf ._ggfe ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_cfad *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _bfdgg []string ;_bfdgg =append (_bfdgg ,_a .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_cfad ._aadb ));_bfdgg =append (_bfdgg ,_a .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_cfad ._afg [0],_cfad ._afg [1],_cfad ._afg [2]));_bfdgg =append (_bfdgg ,_a .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_cfad ._bgg ,ctx .PageHeight -_cfad ._aac ));_bfdgg =append (_bfdgg ,_a .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_cfad ._fegf ,ctx .PageHeight -_cfad ._ffabb ,_cfad ._bfeg ,ctx .PageHeight -_cfad ._cdg ));_dea :=_abad .addContentsByString (_bd .Join (_bfdgg ,"\u000a"));if _dea !=nil {return nil ,ctx ,_dea ;};return []*Block {_abad },ctx ,nil ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_fgd *Chapter )NewSubchapter (title string )*Chapter {_ccb :=_fbcb (_fgd ._afd ._abcd );_ccb .FontSize =14;_fgd ._cda ++;_dda :=_bda (_fgd ,_fgd ._fffa ,_fgd ._acc ,title ,_fgd ._cda ,_ccb );_fgd .Add (_dda );return _dda ;};type border struct{_ecg float64 ;_bfdd float64 ;_ebd float64 ;_gaa float64 ;_efa *_bc .PdfColorDeviceRGB ;_bbd *_bc .PdfColorDeviceRGB ;_ade float64 ;_dgb *_bc .PdfColorDeviceRGB ;_ded float64 ;_bca *_bc .PdfColorDeviceRGB ;_dgg float64 ;_gbec *_bc .PdfColorDeviceRGB ;_fdgf float64 ;LineStyle _bf .LineStyle ;_dded CellBorderStyle ;_aafe CellBorderStyle ;_aeb CellBorderStyle ;_gee CellBorderStyle ;};

// SetAngle sets the rotation angle in degrees.
func (_ca *Block )SetAngle (angleDeg float64 ){_ca ._fe =angleDeg };func (_ddab *Invoice )generateHeaderBlocks (_bggb DrawContext )([]*Block ,DrawContext ,error ){_bgbc :=_ebge (_ddab ._afeg );_bgbc .SetEnableWrap (true );_bgbc .Append (_ddab ._fbab );_gaff :=_edg (2);if _ddab ._aabf !=nil {_cfab :=_gaff .NewCell ();_cfab .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_cfab .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cfab .SetIndent (0);_cfab .SetContent (_ddab ._aabf );_ddab ._aabf .ScaleToHeight (_bgbc .Height ()+20);}else {_gaff .SkipCells (1);};_afca :=_gaff .NewCell ();_afca .SetHorizontalAlignment (CellHorizontalAlignmentRight );_afca .SetVerticalAlignment (CellVerticalAlignmentMiddle );_afca .SetContent (_bgbc );return _gaff .GeneratePageBlocks (_bggb );};func (_caagb *StyledParagraph )getLineHeight (_ggbg int )(_dddb ,_bbdea float64 ){if _caagb ._gcded ==nil ||len (_caagb ._gcded )==0{_caagb .wrapText ();};if _ggbg < 0||_ggbg > len (_caagb ._gcded )-1{_bge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_ggbg );return 0,0;};_bdbd :=_caagb ._gcded [_ggbg ];for _ ,_eafb :=range _bdbd {_bedg ,_agfc :=_eafb .Style .Font .GetFontDescriptor ();if _agfc !=nil {_bge .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _ededd float64 ;if _bedg !=nil {if _ededd ,_agfc =_bedg .GetCapHeight ();_agfc !=nil {_bge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_agfc );};};if int (_ededd )<=0{_bge .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_ededd =1000;};_fedg :=_ededd /1000.0*_eafb .Style .FontSize *_caagb ._eadg ;if _fedg > _dddb {_dddb =_fedg ;};_fedg =_caagb ._eadg *_eafb .Style .FontSize ;if _fedg > _bbdea {_bbdea =_fedg ;};};return _dddb ,_bbdea ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_bbaf *Creator )MoveTo (x ,y float64 ){_bbaf ._bbed .X =x ;_bbaf ._bbed .Y =y };func _dfbg ()*FilledCurve {_dgdc :=FilledCurve {};_dgdc ._bcf =[]_bf .CubicBezierCurve {};return &_dgdc ;};func _dgbg (_deae _ga .Image )(*Image ,error ){_fgbc ,_cfe :=_bc .ImageHandling .NewImageFromGoImage (_deae );if _cfe !=nil {return nil ,_cfe ;};return _bgec (_fgbc );};func _dafd ()*Division {return &Division {_eeegc :[]VectorDrawable {}}};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_eagaga *TableCell )SetBorderLineStyle (style _bf .LineStyle ){_eagaga ._agaa =style };

// Write output of creator to io.Writer interface.
func (_fdbb *Creator )Write (ws _b .Writer )error {if _aef :=_fdbb .Finalize ();_aef !=nil {return _aef ;};_dga :=_bc .NewPdfWriter ();_dga .SetOptimizer (_fdbb ._ccce );if _fdbb ._daca !=nil {_aebf :=_dga .SetForms (_fdbb ._daca );if _aebf !=nil {_bge .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_aebf );return _aebf ;};};if _fdbb ._bfaf !=nil {_dga .AddOutlineTree (_fdbb ._bfaf );}else if _fdbb ._fae !=nil &&_fdbb .AddOutlines {_dga .AddOutlineTree (&_fdbb ._fae .ToPdfOutline ().PdfOutlineTreeNode );};if _fdbb ._abac !=nil {if _dbfg :=_dga .SetPageLabels (_fdbb ._abac );_dbfg !=nil {_bge .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_dbfg );return _dbfg ;};};if _fdbb ._efd !=nil {for _ ,_edag :=range _fdbb ._efd {_cdeb :=_edag .SubsetRegistered ();if _cdeb !=nil {_bge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_cdeb );return _cdeb ;};};};if _fdbb ._gdea !=nil {_gdcd :=_fdbb ._gdea (&_dga );if _gdcd !=nil {_bge .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_gdcd );return _gdcd ;};};for _ ,_gbfb :=range _fdbb ._ecfa {_cbfe :=_dga .AddPage (_gbfb );if _cbfe !=nil {_bge .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_cbfe );return _cbfe ;};};_fcbc :=_dga .Write (ws );if _fcbc !=nil {return _fcbc ;};return nil ;};func _bdea (_fcdgb ,_addf ,_ddgd string ,_egcfc uint ,_addcf TextStyle )*TOCLine {return _accd (TextChunk {Text :_fcdgb ,Style :_addcf },TextChunk {Text :_addf ,Style :_addcf },TextChunk {Text :_ddgd ,Style :_addcf },_egcfc ,_addcf );};

// AppendCurve appends a Bezier curve to the filled curve.
func (_egce *FilledCurve )AppendCurve (curve _bf .CubicBezierCurve )*FilledCurve {_egce ._bcf =append (_egce ._bcf ,curve );return _egce ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_dadeb *TOCLine )SetLink (page int64 ,x ,y float64 ){_dadeb ._aggc =x ;_dadeb ._abeff =y ;_dadeb ._edbce =page ;_abfg :=_dadeb ._gccaf ._bgbf .Color ;_dadeb .Number .Style .Color =_abfg ;_dadeb .Title .Style .Color =_abfg ;_dadeb .Separator .Style .Color =_abfg ;_dadeb .Page .Style .Color =_abfg ;};func (_ab *Block )duplicate ()*Block {_ef :=&Block {};*_ef =*_ab ;_fgg :=_d .ContentStreamOperations {};_fgg =append (_fgg ,*_ab ._ae ...);_ef ._ae =&_fgg ;return _ef ;};type margins struct{_eagb float64 ;_ggbd float64 ;_egdb float64 ;_daeg float64 ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fdga *TOC )SetLineSeparator (separator string ){_fdga ._fbf =separator };func (_cedg *Chapter )headingText ()string {_dbbg :=_cedg ._eag ;if _eeb :=_cedg .headingNumber ();_eeb !=""{_dbbg =_a .Sprintf ("\u0025\u0073\u0020%\u0073",_eeb ,_dbbg );};return _dbbg ;};

// NewCellProps returns the default properties of an invoice cell.
func (_cedd *Invoice )NewCellProps ()InvoiceCellProps {_gcbc :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_cedd ._fffd ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_gcbc ,BorderColor :_gcbc ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_fcaaa *Table )NewCell ()*TableCell {return _fcaaa .newCell (1)};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_bfffc *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _c .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_bfffc ._fbda =true ;_bfffc ._bdfbd =startRow ;_bfffc ._cfcc =endRow ;return nil ;};func (_gdeb *StyledParagraph )wrapText ()error {if !_gdeb ._eab ||int (_gdeb ._faa )<=0{_gdeb ._gcded =[][]*TextChunk {_gdeb ._dcfef };return nil ;};_gdeb ._gcded =[][]*TextChunk {};var _dfcdce []*TextChunk ;var _ffgaf float64 ;_fgac :=func (_fcgg *_bc .PdfAnnotation )*_bc .PdfAnnotation {if _fcgg ==nil {return nil ;};var _fcbcgg *_bc .PdfAnnotation ;switch _bceag :=_fcgg .GetContext ().(type ){case *_bc .PdfAnnotationLink :if _egfc :=_aaab (_bceag );_egfc !=nil {_fcbcgg =_egfc .PdfAnnotation ;};};return _fcbcgg ;};for _ ,_dcedc :=range _gdeb ._dcfef {_eccd :=_dcedc .Style ;_dbcfg :=_dcedc ._abdd ;var (_fcec []rune ;_ebcg []float64 ;);for _ ,_dgfb :=range _dcedc .Text {if _dgfb =='\u000A'{_dfcdce =append (_dfcdce ,&TextChunk {Text :_bd .TrimRightFunc (string (_fcec ),_gf .IsSpace ),Style :_eccd ,_abdd :_fgac (_dbcfg )});_gdeb ._gcded =append (_gdeb ._gcded ,_dfcdce );_dfcdce =nil ;_ffgaf =0;_fcec =nil ;_ebcg =nil ;continue ;};_fdddb :=_dgfb ==' ';_cdeg ,_eegg :=_eccd .Font .GetRuneMetrics (_dgfb );if !_eegg {_bge .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dgfb );return _c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_eaaf :=_eccd .FontSize *_cdeg .Wx ;_egec :=_eaaf ;if !_fdddb {_egec =_eaaf +_eccd .CharSpacing *1000.0;};if _ffgaf +_eaaf > _gdeb ._faa *1000.0{_bdac :=-1;if !_fdddb {for _ggfag :=len (_fcec )-1;_ggfag >=0;_ggfag --{if _fcec [_ggfag ]==' '{_bdac =_ggfag ;break ;};};};_bcae :=string (_fcec );if _bdac >=0{_bcae =string (_fcec [0:_bdac +1]);_fcec =_fcec [_bdac +1:];_fcec =append (_fcec ,_dgfb );_ebcg =_ebcg [_bdac +1:];_ebcg =append (_ebcg ,_egec );_ffgaf =0;for _ ,_dfdee :=range _ebcg {_ffgaf +=_dfdee ;};}else {if _fdddb {_ffgaf =0;_fcec =[]rune {};_ebcg =[]float64 {};}else {_ffgaf =_egec ;_fcec =[]rune {_dgfb };_ebcg =[]float64 {_egec };};};_dfcdce =append (_dfcdce ,&TextChunk {Text :_bd .TrimRightFunc (_bcae ,_gf .IsSpace ),Style :_eccd ,_abdd :_fgac (_dbcfg )});_gdeb ._gcded =append (_gdeb ._gcded ,_dfcdce );_dfcdce =[]*TextChunk {};}else {_ffgaf +=_egec ;_fcec =append (_fcec ,_dgfb );_ebcg =append (_ebcg ,_egec );};};if len (_fcec )> 0{_dfcdce =append (_dfcdce ,&TextChunk {Text :string (_fcec ),Style :_eccd ,_abdd :_fgac (_dbcfg )});};};if len (_dfcdce )> 0{_gdeb ._gcded =append (_gdeb ._gcded ,_dfcdce );};return nil ;};

// SetBorderOpacity sets the border opacity.
func (_ead *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_ead ._fccf =opacity };

// Lines returns all the lines the table of contents has.
func (_dgaec *TOC )Lines ()[]*TOCLine {return _dgaec ._fecfb };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_aaefg *Table )MultiColCell (colspan int )*TableCell {return _aaefg .newCell (colspan )};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// SetWidthLeft sets border width for left.
func (_dac *border )SetWidthLeft (bw float64 ){_dac ._ade =bw };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ffb *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ffb ._aae ._eagb ,_ffb ._aae ._ggbd ,_ffb ._aae ._egdb ,_ffb ._aae ._daeg ;};

// Add adds a new line with the default style to the table of contents.
func (_caec *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_edac :=_caec .AddLine (_accd (TextChunk {Text :number ,Style :_caec ._fgeg },TextChunk {Text :title ,Style :_caec ._ceeda },TextChunk {Text :page ,Style :_caec ._bbaa },level ,_caec ._aegd ));if _edac ==nil {return nil ;};_bgfbc :=&_caec ._agba ;_edac .SetMargins (_bgfbc ._eagb ,_bgfbc ._ggbd ,_bgfbc ._egdb ,_bgfbc ._daeg );_edac .SetLevelOffset (_caec ._fdag );_edac .Separator .Text =_caec ._fbf ;_edac .Separator .Style =_caec ._cbed ;return _edac ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_ecee *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_dfge :=_ebge (_ecee ._bdbg );_dfge .Append (text );_bfec ,_caaf :=_ecee .Add (_dfge );return _dfge ,_bfec ,_caaf ;};

// SetDueDate sets the due date of the invoice.
func (_ebcc *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_ebcc ._bega [1].Value =dueDate ;return _ebcc ._bega [0],_ebcc ._bega [1];};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_fadb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_fadb ._faad =valign };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_cddea *Paragraph )SetMaxLines (maxLines int ){_cddea ._cgba =maxLines ;_cddea .wrapText ()};

// NewFilledCurve returns a instance of filled curve.
func (_egcce *Creator )NewFilledCurve ()*FilledCurve {return _dfbg ()};

// SkipCells skips over a specified number of cells in the table.
func (_ecba *Table )SkipCells (num int ){if num < 0{_bge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ecba ._gcbb +=num ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_dcfef []*TextChunk ;_cged TextStyle ;_bgbf TextStyle ;_fec TextAlignment ;_eadg float64 ;_eab bool ;_faa float64 ;_cecg bool ;_bbfa float64 ;_bbcf margins ;_bddfc positioning ;_fbgc float64 ;_gfcc float64 ;_cfac float64 ;_dcag float64 ;_gcded [][]*TextChunk ;_gefc func (_gcbd *StyledParagraph ,_ebbf DrawContext );};

// SetBorderWidth sets the border width.
func (_dedgf *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_dedgf ._efeec .BorderWidth =borderWidth ;};

// GeneratePageBlocks implements drawable interface.
func (_faf *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ddd :=_faf ._ecg ;_gggb :=ctx .PageHeight -_faf ._bfdd ;if _faf ._efa !=nil {_cfcg :=_bf .Rectangle {Opacity :1.0,X :_faf ._ecg ,Y :ctx .PageHeight -_faf ._bfdd -_faf ._gaa ,Height :_faf ._gaa ,Width :_faf ._ebd };_cfcg .FillEnabled =true ;_cfcg .FillColor =_faf ._efa ;_cfcg .BorderEnabled =false ;_bccb ,_ ,_afac :=_cfcg .Draw ("");if _afac !=nil {return nil ,ctx ,_afac ;};_afac =_ddb .addContentsByString (string (_bccb ));if _afac !=nil {return nil ,ctx ,_afac ;};};_bfab :=_faf ._fdgf ;_dcg :=_faf ._ded ;_gebb :=_faf ._ade ;_adgb :=_faf ._dgg ;_gaea :=_faf ._fdgf ;if _faf ._aeb ==CellBorderStyleDouble {_gaea +=2*_bfab ;};_ddbe :=_faf ._ded ;if _faf ._gee ==CellBorderStyleDouble {_ddbe +=2*_dcg ;};_cbb :=_faf ._ade ;if _faf ._dded ==CellBorderStyleDouble {_cbb +=2*_gebb ;};_edb :=_faf ._dgg ;if _faf ._aafe ==CellBorderStyleDouble {_edb +=2*_adgb ;};if _faf ._fdgf !=0{_cefc :=_ddd ;_bbe :=_gggb ;if _faf ._aeb ==CellBorderStyleDouble {_bbe -=_bfab ;_eeg :=_bf .BasicLine {};_eeg .X1 =_cefc -_gaea /2;_eeg .Y1 =_bbe +2*_bfab ;_eeg .X2 =_cefc +_faf ._ebd +_gaea /2;_eeg .Y2 =_bbe +2*_bfab ;_eeg .LineColor =_faf ._gbec ;_eeg .LineWidth =_faf ._fdgf ;_eeg .LineStyle =_faf .LineStyle ;_gdcc ,_ ,_bbc :=_eeg .Draw ("");if _bbc !=nil {return nil ,ctx ,_bbc ;};_bbc =_ddb .addContentsByString (string (_gdcc ));if _bbc !=nil {return nil ,ctx ,_bbc ;};};_dedb :=_bf .BasicLine {LineWidth :_faf ._fdgf ,Opacity :1.0,LineColor :_faf ._gbec ,X1 :_cefc -_gaea /2+(_cbb -_faf ._ade ),Y1 :_bbe ,X2 :_cefc +_faf ._ebd +_gaea /2-(_edb -_faf ._dgg ),Y2 :_bbe ,LineStyle :_faf .LineStyle };_geba ,_ ,_abd :=_dedb .Draw ("");if _abd !=nil {return nil ,ctx ,_abd ;};_abd =_ddb .addContentsByString (string (_geba ));if _abd !=nil {return nil ,ctx ,_abd ;};};if _faf ._ded !=0{_egbb :=_ddd ;_bff :=_gggb -_faf ._gaa ;if _faf ._gee ==CellBorderStyleDouble {_bff +=_dcg ;_bbde :=_bf .BasicLine {LineWidth :_faf ._ded ,Opacity :1.0,LineColor :_faf ._dgb ,X1 :_egbb -_ddbe /2,Y1 :_bff -2*_dcg ,X2 :_egbb +_faf ._ebd +_ddbe /2,Y2 :_bff -2*_dcg ,LineStyle :_faf .LineStyle };_afag ,_ ,_fde :=_bbde .Draw ("");if _fde !=nil {return nil ,ctx ,_fde ;};_fde =_ddb .addContentsByString (string (_afag ));if _fde !=nil {return nil ,ctx ,_fde ;};};_gdca :=_bf .BasicLine {LineWidth :_faf ._ded ,Opacity :1.0,LineColor :_faf ._dgb ,X1 :_egbb -_ddbe /2+(_cbb -_faf ._ade ),Y1 :_bff ,X2 :_egbb +_faf ._ebd +_ddbe /2-(_edb -_faf ._dgg ),Y2 :_bff ,LineStyle :_faf .LineStyle };_egd ,_ ,_fabd :=_gdca .Draw ("");if _fabd !=nil {return nil ,ctx ,_fabd ;};_fabd =_ddb .addContentsByString (string (_egd ));if _fabd !=nil {return nil ,ctx ,_fabd ;};};if _faf ._ade !=0{_gbb :=_ddd ;_bdc :=_gggb ;if _faf ._dded ==CellBorderStyleDouble {_gbb +=_gebb ;_bfc :=_bf .BasicLine {LineWidth :_faf ._ade ,Opacity :1.0,LineColor :_faf ._bbd ,X1 :_gbb -2*_gebb ,Y1 :_bdc +_cbb /2,X2 :_gbb -2*_gebb ,Y2 :_bdc -_faf ._gaa -_cbb /2,LineStyle :_faf .LineStyle };_cdc ,_ ,_eeca :=_bfc .Draw ("");if _eeca !=nil {return nil ,ctx ,_eeca ;};_eeca =_ddb .addContentsByString (string (_cdc ));if _eeca !=nil {return nil ,ctx ,_eeca ;};};_fgb :=_bf .BasicLine {LineWidth :_faf ._ade ,Opacity :1.0,LineColor :_faf ._bbd ,X1 :_gbb ,Y1 :_bdc +_cbb /2-(_gaea -_faf ._fdgf ),X2 :_gbb ,Y2 :_bdc -_faf ._gaa -_cbb /2+(_ddbe -_faf ._ded ),LineStyle :_faf .LineStyle };_cgff ,_ ,_bfe :=_fgb .Draw ("");if _bfe !=nil {return nil ,ctx ,_bfe ;};_bfe =_ddb .addContentsByString (string (_cgff ));if _bfe !=nil {return nil ,ctx ,_bfe ;};};if _faf ._dgg !=0{_addc :=_ddd +_faf ._ebd ;_gfac :=_gggb ;if _faf ._aafe ==CellBorderStyleDouble {_addc -=_adgb ;_bacgb :=_bf .BasicLine {LineWidth :_faf ._dgg ,Opacity :1.0,LineColor :_faf ._bca ,X1 :_addc +2*_adgb ,Y1 :_gfac +_edb /2,X2 :_addc +2*_adgb ,Y2 :_gfac -_faf ._gaa -_edb /2,LineStyle :_faf .LineStyle };_gggbf ,_ ,_dab :=_bacgb .Draw ("");if _dab !=nil {return nil ,ctx ,_dab ;};_dab =_ddb .addContentsByString (string (_gggbf ));if _dab !=nil {return nil ,ctx ,_dab ;};};_dfd :=_bf .BasicLine {LineWidth :_faf ._dgg ,Opacity :1.0,LineColor :_faf ._bca ,X1 :_addc ,Y1 :_gfac +_edb /2-(_gaea -_faf ._fdgf ),X2 :_addc ,Y2 :_gfac -_faf ._gaa -_edb /2+(_ddbe -_faf ._ded ),LineStyle :_faf .LineStyle };_ccdc ,_ ,_cbcf :=_dfd .Draw ("");if _cbcf !=nil {return nil ,ctx ,_cbcf ;};_cbcf =_ddb .addContentsByString (string (_ccdc ));if _cbcf !=nil {return nil ,ctx ,_cbcf ;};};return []*Block {_ddb },ctx ,nil ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_gage *TOC )SetLinePageStyle (style TextStyle ){_gage ._bbaa =style };

// SetFillOpacity sets the fill opacity.
func (_bdabf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_bdabf ._ebbb =opacity };

// SetColor sets the line color.
func (_gdeg *Curve )SetColor (col Color ){_gdeg ._afg =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};

// GetRowHeight returns the height of the specified row.
func (_bgbg *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_bgbg ._gbcf ){return 0,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _bgbg ._gbcf [row -1],nil ;};

// AddSection adds a new content section at the end of the invoice.
func (_acac *Invoice )AddSection (title ,content string ){_acac ._dbag =append (_acac ._dbag ,[2]string {title ,content });};

// SetTotal sets the total of the invoice.
func (_dgaf *Invoice )SetTotal (value string ){_dgaf ._ddbc [1].Value =value };

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_cdea *Creator )SetPageSize (size PageSize ){_cdea ._dddcb =size ;_cdea ._gacc =size [0];_cdea ._afdg =size [1];_bdaf :=0.1*_cdea ._gacc ;_cdea ._fgbg ._eagb =_bdaf ;_cdea ._fgbg ._ggbd =_bdaf ;_cdea ._fgbg ._egdb =_bdaf ;_cdea ._fgbg ._daeg =_bdaf ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_aecb *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_beff :=NewTextChunk (text ,_aecb ._bgbf );_beff ._abdd =_ecda (page -1,x ,y ,zoom );return _aecb .appendChunk (_beff );};

// SetStyleBottom sets border style for bottom side.
func (_gga *border )SetStyleBottom (style CellBorderStyle ){_gga ._gee =style };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_fdef *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_badd :=&_fdef ._gccaf ._bbcf ;return _fdef ._gfcf ,_badd ._ggbd ,_badd ._egdb ,_badd ._daeg ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_gcdea *TOC )SetLineStyle (style TextStyle ){_gcdea .SetLineNumberStyle (style );_gcdea .SetLineTitleStyle (style );_gcdea .SetLineSeparatorStyle (style );_gcdea .SetLinePageStyle (style );};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};func _bcff (_fgfc *Block ,_fabc *Paragraph ,_bgecg DrawContext )(DrawContext ,error ){_cfbc :=1;_cabd :=_ffg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gg .Itoa (_cfbc ));for _fgfc ._fd .HasFontByName (_cabd ){_cfbc ++;_cabd =_ffg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gg .Itoa (_cfbc ));};_begd :=_fgfc ._fd .SetFontByName (_cabd ,_fabc ._abcd .ToPdfObject ());if _begd !=nil {return _bgecg ,_begd ;};_fabc .wrapText ();_cbce :=_d .NewContentCreator ();_cbce .Add_q ();_ecaec :=_bgecg .PageHeight -_bgecg .Y -_fabc ._bgebc *_fabc ._eded ;_cbce .Translate (_bgecg .X ,_ecaec );if _fabc ._ggfa !=0{_cbce .RotateDeg (_fabc ._ggfa );};_cbce .Add_BT ().Add_rg (_fabc ._bcbbb .R (),_fabc ._bcbbb .G (),_fabc ._bcbbb .B ()).Add_Tf (_cabd ,_fabc ._bgebc ).Add_TL (_fabc ._bgebc *_fabc ._eded );for _bfece ,_cefgb :=range _fabc ._dced {if _bfece !=0{_cbce .Add_Tstar ();};_aged :=[]rune (_cefgb );_bbfb :=0.0;_dddcf :=0;for _dgea ,_aecag :=range _aged {if _aecag ==' '{_dddcf ++;continue ;};if _aecag =='\u000A'{continue ;};_cdcb ,_dccg :=_fabc ._abcd .GetRuneMetrics (_aecag );if !_dccg {_bge .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_dgea ,_aecag ,_aecag ,_fabc ._abcd .BaseFont (),_fabc ._abcd .Subtype ());return _bgecg ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bbfb +=_fabc ._bgebc *_cdcb .Wx ;};var _efce []_ffg .PdfObject ;_bgecga ,_gceb :=_fabc ._abcd .GetRuneMetrics (' ');if !_gceb {return _bgecg ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_babe :=_bgecga .Wx ;switch _fabc ._eceb {case TextAlignmentJustify :if _dddcf > 0&&_bfece < len (_fabc ._dced )-1{_babe =(_fabc ._faeg *1000.0-_bbfb )/float64 (_dddcf )/_fabc ._bgebc ;};case TextAlignmentCenter :_efee :=_bbfb +float64 (_dddcf )*_babe *_fabc ._bgebc ;_bgea :=(_fabc ._faeg *1000.0-_efee )/2/_fabc ._bgebc ;_efce =append (_efce ,_ffg .MakeFloat (-_bgea ));case TextAlignmentRight :_geeb :=_bbfb +float64 (_dddcf )*_babe *_fabc ._bgebc ;_fad :=(_fabc ._faeg *1000.0-_geeb )/_fabc ._bgebc ;_efce =append (_efce ,_ffg .MakeFloat (-_fad ));};_fdeaf :=_fabc ._abcd .Encoder ();var _fea []byte ;for _ ,_cee :=range _aged {if _cee =='\u000A'{continue ;};if _cee ==' '{if len (_fea )> 0{_efce =append (_efce ,_ffg .MakeStringFromBytes (_fea ));_fea =nil ;};_efce =append (_efce ,_ffg .MakeFloat (-_babe ));}else {if _ ,_dfff :=_fdeaf .RuneToCharcode (_cee );!_dfff {_bge .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cee ,_cee );continue ;};_fea =append (_fea ,_fdeaf .Encode (string (_cee ))...);};};if len (_fea )> 0{_efce =append (_efce ,_ffg .MakeStringFromBytes (_fea ));};_cbce .Add_TJ (_efce ...);};_cbce .Add_ET ();_cbce .Add_Q ();_geed :=_cbce .Operations ();_geed .WrapIfNeeded ();_fgfc .addContents (_geed );if _fabc ._efcfe .isRelative (){_fded :=_fabc .Height ()+_fabc ._ecccb ._daeg ;_bgecg .Y +=_fded ;_bgecg .Height -=_fded ;if _bgecg .Inline {_bgecg .X +=_fabc .Width ()+_fabc ._ecccb ._ggbd ;};};return _bgecg ,nil ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_dfcdc *Invoice )TitleStyle ()TextStyle {return _dfcdc ._afeg };

// SetIndent sets the cell's left indent.
func (_fade *TableCell )SetIndent (indent float64 ){_fade ._fbbd =indent };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_dddf *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _accd (number ,title ,page ,level ,style );};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_cagd *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _abf []*Block ;_ceaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfge :=ctx ;if _cagd ._bafe .isAbsolute (){ctx .X =_cagd ._dagc ;ctx .Y =_cagd ._degba ;}else {ctx .X +=_cagd ._dbcbe ._eagb ;ctx .Y +=_cagd ._dbcbe ._egdb ;ctx .Width -=_cagd ._dbcbe ._eagb +_cagd ._dbcbe ._ggbd ;ctx .Height -=_cagd ._dbcbe ._daeg +_cagd ._dbcbe ._egdb ;};_dfdca :=ctx .Width ;_gace :=ctx .X ;_febb :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._daeg ;_fbac :=ctx .Height ;_bgef :=0;_egecg :=-1;_fgae :=-1;for _ffce ,_dbfc :=range _cagd ._gggbg {_gcefg :=float64 (0.0);for _gfgafb :=0;_gfgafb < _dbfc ._dgdef ;_gfgafb ++{_gcefg +=_cagd ._gbea [_dbfc ._efcbc +_gfgafb -1];};_egfbcb :=float64 (0.0);for _cgfc :=0;_cgfc < _dbfc ._efcbc -1;_cgfc ++{_egfbcb +=_cagd ._gbea [_cgfc ]*_dfdca ;};_cedf :=float64 (0.0);for _bdecf :=_bgef ;_bdecf < _dbfc ._aefe -1;_bdecf ++{_cedf +=_cagd ._gbcf [_bdecf ];};_fdgb :=_gcefg *_dfdca ;_acdd :=float64 (0.0);for _gfae :=0;_gfae < _dbfc ._gbbbd ;_gfae ++{_acdd +=_cagd ._gbcf [_dbfc ._aefe +_gfae -1];};if _cagd ._fbda {if _dbfc ._aefe >=_cagd ._bdfbd &&_dbfc ._aefe <=_cagd ._cfcc {if _egecg < 0{_egecg =_ffce ;};_fgae =_ffce ;};};switch _gfbe :=_dbfc ._bcdac .(type ){case *Paragraph :_gffd :=_gfbe ;if _gffd ._dgf {_gffd .SetWidth (_fdgb -_dbfc ._fbbd );};_edbb :=_gffd .Height ()+_gffd ._ecccb ._daeg +_gffd ._ecccb ._daeg ;_edbb +=0.5*_gffd ._bgebc *_gffd ._eded ;if _edbb > _acdd {_deegg :=_edbb -_acdd ;_cagd ._gbcf [_dbfc ._aefe +_dbfc ._gbbbd -2]+=_deegg ;};case *StyledParagraph :_baed :=_gfbe ;if _baed ._eab {_baed .SetWidth (_fdgb -_dbfc ._fbbd );};_dbdb :=_baed .Height ()+_baed ._bbcf ._egdb +_baed ._bbcf ._daeg ;_dbdb +=0.5*_baed .getTextHeight ();if _dbdb > _acdd {_ccba :=_dbdb -_acdd ;_cagd ._gbcf [_dbfc ._aefe +_dbfc ._gbbbd -2]+=_ccba ;};case *Image :_fagcc :=_gfbe ;_cddg :=_fagcc .Height ()+_fagcc ._eaga ._egdb +_fagcc ._eaga ._daeg ;if _cddg > _acdd {_badc :=_cddg -_acdd ;_cagd ._gbcf [_dbfc ._aefe +_dbfc ._gbbbd -2]+=_badc ;};case *Table :_fecdf :=_gfbe ;_babb :=_fecdf .Height ()+_fecdf ._dbcbe ._egdb +_fecdf ._dbcbe ._daeg ;if _babb > _acdd {_eddb :=_babb -_acdd ;_cagd ._gbcf [_dbfc ._aefe +_dbfc ._gbbbd -2]+=_eddb ;};case *List :_agea :=_gfbe ;_cgdea :=_agea .tableHeight (_fdgb -_dbfc ._fbbd )+_agea ._ecab ._egdb +_agea ._ecab ._daeg ;if _cgdea > _acdd {_ecec :=_cgdea -_acdd ;_cagd ._gbcf [_dbfc ._aefe +_dbfc ._gbbbd -2]+=_ecec ;};case *Division :_gede :=_gfbe ;_abacc :=ctx ;_abacc .X =_egfbcb ;_abacc .Y =_cedf ;_abacc .Width =_fdgb ;_cdabc ,_ ,_fdaa :=_gede .GeneratePageBlocks (_abacc );if _fdaa !=nil {return nil ,ctx ,_fdaa ;};if len (_cdabc )> 1{_dacdd :=_abacc .Height -_acdd ;if _dacdd > _acdd {_adge :=_dacdd -_acdd ;_cagd ._gbcf [_dbfc ._aefe +_dbfc ._gbbbd -2]+=_adge ;};};_cdebb :=_gede .Height ()+_gede ._edda ._egdb +_gede ._edda ._daeg ;if _cdebb > _acdd {_eccbf :=_cdebb -_acdd ;_cagd ._gbcf [_dbfc ._aefe +_dbfc ._gbbbd -2]+=_eccbf ;};};};var _gdfa bool ;var _cadde ,_bebba int ;for _ddbfa :=0;_ddbfa < len (_cagd ._gggbg );_ddbfa ++{_bgce :=_cagd ._gggbg [_ddbfa ];_bdege :=float64 (0.0);for _bcaee :=0;_bcaee < _bgce ._dgdef ;_bcaee ++{_bdege +=_cagd ._gbea [_bgce ._efcbc +_bcaee -1];};_ceed :=float64 (0.0);for _bbede :=0;_bbede < _bgce ._efcbc -1;_bbede ++{_ceed +=_cagd ._gbea [_bbede ]*_dfdca ;};_agdab :=float64 (0.0);for _eaag :=_bgef ;_eaag < _bgce ._aefe -1;_eaag ++{_agdab +=_cagd ._gbcf [_eaag ];};_cegd :=_bdege *_dfdca ;_decdg :=float64 (0.0);for _bedff :=0;_bedff < _bgce ._gbbbd ;_bedff ++{_decdg +=_cagd ._gbcf [_bgce ._aefe +_bedff -1];};ctx .Height =_fbac -_agdab ;if _decdg > ctx .Height {_abf =append (_abf ,_ceaf );_ceaf =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gace =ctx .Margins ._eagb ;_febb =ctx .Margins ._egdb ;ctx .Height =ctx .PageHeight -ctx .Margins ._egdb -ctx .Margins ._daeg ;ctx .Page ++;_fbac =ctx .Height ;_bgef =_bgce ._aefe -1;_agdab =0;if _cagd ._fbda &&_egecg >=0{_cadde =_ddbfa ;_ddbfa =_egecg -1;_bebba =_bgef ;_bgef =_cagd ._bdfbd -1;_gdfa =true ;continue ;};};ctx .Width =_cegd ;ctx .X =_gace +_ceed ;ctx .Y =_febb +_agdab ;_dadf :=_adga (ctx .X ,ctx .Y ,_cegd ,_decdg );if _bgce ._dcdfb !=nil {_ccfee :=_bgce ._dcdfb .R ();_bbdf :=_bgce ._dcdfb .G ();_fgafb :=_bgce ._dcdfb .B ();_dadf .SetFillColor (ColorRGBFromArithmetic (_ccfee ,_bbdf ,_fgafb ));};_dadf .LineStyle =_bgce ._agaa ;_dadf ._dded =_bgce ._caged ;_dadf ._aafe =_bgce ._dgecf ;_dadf ._aeb =_bgce ._ecaa ;_dadf ._gee =_bgce ._gaeb ;if _bgce ._gdbg !=nil {_dadf .SetColorLeft (ColorRGBFromArithmetic (_bgce ._gdbg .R (),_bgce ._gdbg .G (),_bgce ._gdbg .B ()));};if _bgce ._bgag !=nil {_dadf .SetColorBottom (ColorRGBFromArithmetic (_bgce ._bgag .R (),_bgce ._bgag .G (),_bgce ._bgag .B ()));};if _bgce ._fegcg !=nil {_dadf .SetColorRight (ColorRGBFromArithmetic (_bgce ._fegcg .R (),_bgce ._fegcg .G (),_bgce ._fegcg .B ()));};if _bgce ._abaceg !=nil {_dadf .SetColorTop (ColorRGBFromArithmetic (_bgce ._abaceg .R (),_bgce ._abaceg .G (),_bgce ._abaceg .B ()));};_dadf .SetWidthBottom (_bgce ._baggc );_dadf .SetWidthLeft (_bgce ._bfce );_dadf .SetWidthRight (_bgce ._efba );_dadf .SetWidthTop (_bgce ._aaed );_bdbe :=_ceaf .Draw (_dadf );if _bdbe !=nil {_bge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bdbe );};if _bgce ._bcdac !=nil {_adacg :=_bgce ._bcdac .Width ();_gaab :=_bgce ._bcdac .Height ();_cggfa :=0.0;switch _bdaab :=_bgce ._bcdac .(type ){case *Paragraph :if _bdaab ._dgf {_adacg =_bdaab .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _bdaab ._eab {_adacg =_bdaab .getMaxLineWidth ()/1000.0;};_cbabc ,_bdcc :=_bdaab .getLineHeight (0);if len (_bdaab ._gcded )==1{_gaab =_cbabc ;}else {_gaab =_gaab -_bdcc +_cbabc ;};_cggfa =_cbabc -_bdcc ;switch _bgce ._faad {case CellVerticalAlignmentTop :_cggfa +=_cbabc *0.5;case CellVerticalAlignmentBottom :_cggfa -=_cbabc *0.5;};case *Table :_adacg =_cegd ;case *List :_adacg =_cegd ;};switch _bgce ._fdab {case CellHorizontalAlignmentLeft :ctx .X +=_bgce ._fbbd ;ctx .Width -=_bgce ._fbbd ;case CellHorizontalAlignmentCenter :_aedd :=_cegd -_adacg ;if _aedd > 0{ctx .X +=_aedd /2;ctx .Width -=_aedd /2;};case CellHorizontalAlignmentRight :if _cegd > _adacg {ctx .X =ctx .X +_cegd -_adacg -_bgce ._fbbd ;ctx .Width -=_bgce ._fbbd ;};};ctx .Y +=_cggfa ;switch _bgce ._faad {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_dede :=_decdg -_gaab ;if _dede > 0{ctx .Y +=_dede /2;ctx .Height -=_dede /2;};case CellVerticalAlignmentBottom :if _decdg > _gaab {ctx .Y =ctx .Y +_decdg -_gaab ;ctx .Height =_decdg ;};};_cafe :=_ceaf .DrawWithContext (_bgce ._bcdac ,ctx );if _cafe !=nil {_bge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cafe );};ctx .Y -=_cggfa ;};ctx .Y +=_decdg ;ctx .Height -=_decdg ;if _gdfa &&_ddbfa +1> _fgae {_febb +=_agdab +_decdg ;_fbac -=_decdg +_agdab ;_bgef =_bebba ;_ddbfa =_cadde -1;_gdfa =false ;};};_abf =append (_abf ,_ceaf );if _cagd ._bafe .isAbsolute (){return _abf ,_bfge ,nil ;};ctx .X =_bfge .X ;ctx .Width =_bfge .Width ;ctx .Y +=_cagd ._dbcbe ._daeg ;ctx .Height -=_cagd ._dbcbe ._daeg ;return _abf ,ctx ,nil ;};

// SetLevel sets the indentation level of the TOC line.
func (_fcee *TOCLine )SetLevel (level uint ){_fcee ._egecc =level ;_fcee ._gccaf ._bbcf ._eagb =_fcee ._gfcf +float64 (_fcee ._egecc -1)*_fcee ._ggfe ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_dbga *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _bbdc (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_aaee DrawContext )([]*Block ,DrawContext ,error );};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dace *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dace ._fgbg ._eagb =left ;_dace ._fgbg ._ggbd =right ;_dace ._fgbg ._egdb =top ;_dace ._fgbg ._daeg =bottom ;};func (_fccc *InvoiceAddress )fmtLine (_fafg ,_dedg string ,_dfdb bool )string {if _dfdb {_dedg ="";};return _a .Sprintf ("\u0025\u0073\u0025s\u000a",_dedg ,_fafg );};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;func _gdd (_ceb *_d .ContentStreamOperations ,_fab *_bc .PdfPageResources ,_adg *_d .ContentStreamOperations ,_gbe *_bc .PdfPageResources )error {_gab :=map[_ffg .PdfObjectName ]_ffg .PdfObjectName {};_df :=map[_ffg .PdfObjectName ]_ffg .PdfObjectName {};_aeg :=map[_ffg .PdfObjectName ]_ffg .PdfObjectName {};_fc :=map[_ffg .PdfObjectName ]_ffg .PdfObjectName {};_gbed :=map[_ffg .PdfObjectName ]_ffg .PdfObjectName {};_fcb :=map[_ffg .PdfObjectName ]_ffg .PdfObjectName {};for _ ,_gcf :=range *_adg {switch _gcf .Operand {case "\u0044\u006f":if len (_gcf .Params )==1{if _ccd ,_dadg :=_gcf .Params [0].(*_ffg .PdfObjectName );_dadg {if _ ,_cfg :=_gab [*_ccd ];!_cfg {var _egcd _ffg .PdfObjectName ;_ecc ,_ :=_gbe .GetXObjectByName (*_ccd );if _ecc !=nil {_egcd =*_ccd ;for {_dc ,_ :=_fab .GetXObjectByName (_egcd );if _dc ==nil ||_dc ==_ecc {break ;};_egcd =_egcd +"\u0030";};};_fab .SetXObjectByName (_egcd ,_ecc );_gab [*_ccd ]=_egcd ;};_eec :=_gab [*_ccd ];_gcf .Params [0]=&_eec ;};};case "\u0054\u0066":if len (_gcf .Params )==2{if _dee ,_bfd :=_gcf .Params [0].(*_ffg .PdfObjectName );_bfd {if _ ,_gfe :=_df [*_dee ];!_gfe {_gda ,_gddg :=_gbe .GetFontByName (*_dee );_fcg :=*_dee ;if _gddg &&_gda !=nil {_fcg =_bfa (_dee .String (),_gda ,_fab );};_fab .SetFontByName (_fcg ,_gda );_df [*_dee ]=_fcg ;};_dcf :=_df [*_dee ];_gcf .Params [0]=&_dcf ;};};case "\u0043\u0053","\u0063\u0073":if len (_gcf .Params )==1{if _cbe ,_cba :=_gcf .Params [0].(*_ffg .PdfObjectName );_cba {if _ ,_gfdb :=_aeg [*_cbe ];!_gfdb {var _agc _ffg .PdfObjectName ;_caa ,_bccf :=_gbe .GetColorspaceByName (*_cbe );if _bccf {_agc =*_cbe ;for {_gcd ,_ffa :=_fab .GetColorspaceByName (_agc );if !_ffa ||_caa ==_gcd {break ;};_agc =_agc +"\u0030";};_fab .SetColorspaceByName (_agc ,_caa );_aeg [*_cbe ]=_agc ;}else {_bge .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _eaf ,_bfdg :=_aeg [*_cbe ];_bfdg {_gcf .Params [0]=&_eaf ;}else {_bge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_cbe );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gcf .Params )==1{if _dbd ,_ced :=_gcf .Params [0].(*_ffg .PdfObjectName );_ced {if _ ,_abc :=_fc [*_dbd ];!_abc {var _gge _ffg .PdfObjectName ;_cae ,_gca :=_gbe .GetPatternByName (*_dbd );if _gca {_gge =*_dbd ;for {_geg ,_fdbg :=_fab .GetPatternByName (_gge );if !_fdbg ||_geg ==_cae {break ;};_gge =_gge +"\u0030";};_cfgg :=_fab .SetPatternByName (_gge ,_cae .ToPdfObject ());if _cfgg !=nil {return _cfgg ;};_fc [*_dbd ]=_gge ;};};if _bacg ,_ebe :=_fc [*_dbd ];_ebe {_gcf .Params [0]=&_bacg ;};};};case "\u0073\u0068":if len (_gcf .Params )==1{if _cde ,_dce :=_gcf .Params [0].(*_ffg .PdfObjectName );_dce {if _ ,_cce :=_gbed [*_cde ];!_cce {var _gac _ffg .PdfObjectName ;_fga ,_aaf :=_gbe .GetShadingByName (*_cde );if _aaf {_gac =*_cde ;for {_gcc ,_beb :=_fab .GetShadingByName (_gac );if !_beb ||_fga ==_gcc {break ;};_gac =_gac +"\u0030";};_gef :=_fab .SetShadingByName (_gac ,_fga .ToPdfObject ());if _gef !=nil {_bge .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_gef );return _gef ;};_gbed [*_cde ]=_gac ;}else {_bge .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _ege ,_dcc :=_gbed [*_cde ];_dcc {_gcf .Params [0]=&_ege ;}else {_bge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_cde );};};};case "\u0067\u0073":if len (_gcf .Params )==1{if _gega ,_daf :=_gcf .Params [0].(*_ffg .PdfObjectName );_daf {if _ ,_aab :=_fcb [*_gega ];!_aab {var _fdd _ffg .PdfObjectName ;_fgf ,_dba :=_gbe .GetExtGState (*_gega );if _dba {_fdd =*_gega ;_aaa :=1;for {_bgb ,_gecb :=_fab .GetExtGState (_fdd );if !_gecb ||_fgf ==_bgb {break ;};_fdd =_ffg .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_aaa ));_aaa ++;};};_fab .AddExtGState (_fdd ,_fgf );_fcb [*_gega ]=_fdd ;};_dfb :=_fcb [*_gega ];_gcf .Params [0]=&_dfb ;};};};*_ceb =append (*_ceb ,_gcf );};return nil ;};func (_baabb *StyledParagraph )getMaxLineWidth ()float64 {if _baabb ._gcded ==nil ||len (_baabb ._gcded )==0{_baabb .wrapText ();};var _aegag float64 ;for _ ,_ccec :=range _baabb ._gcded {_eccad :=_baabb .getTextLineWidth (_ccec );if _eccad > _aegag {_aegag =_eccad ;};};return _aegag ;};func (_gagf *StyledParagraph )getTextHeight ()float64 {var _dfdf float64 ;for _ ,_agfg :=range _gagf ._dcfef {_eagg :=_agfg .Style .FontSize *_gagf ._eadg ;if _eagg > _dfdf {_dfdf =_eagg ;};};return _dfdf ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_fgbd *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_dcgc :=uint (len (_fgbd ._cadd ));if index > _dcgc {index =_dcgc ;};_abb :=_fgbd .NewColumn (description );_fgbd ._cadd =append (_fgbd ._cadd [:index ],append ([]*InvoiceCell {_abb },_fgbd ._cadd [index :]...)...);return _abb ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_dfbb *StyledParagraph ;_fecfb []*TOCLine ;_fgeg TextStyle ;_ceeda TextStyle ;_cbed TextStyle ;_bbaa TextStyle ;_fbf string ;_fdag float64 ;_agba margins ;_gcab positioning ;_aegd TextStyle ;_fadec bool ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_gcce *Invoice )SetNoteHeadingStyle (style TextStyle ){_gcce ._ecae =style };

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eaed *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _eaed ._ddbc [0],_eaed ._ddbc [1]};

// Title returns the title of the invoice.
func (_daa *Invoice )Title ()string {return _daa ._fbab };

// SkipOver skips over a specified number of rows and cols.
func (_bcfe *Table )SkipOver (rows ,cols int ){_ddbga :=rows *_bcfe ._gccf +cols -1;if _ddbga < 0{_bge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_bcfe ._gcbb +=_ddbga ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_bddbe *Invoice )Terms ()(string ,string ){return _bddbe ._bgcd [0],_bddbe ._bgcd [1]};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_ecff *Creator )NewTextStyle ()TextStyle {return _fbcb (_ecff ._fage )};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_bddb *Creator )Draw (d Drawable )error {if _bddb .getActivePage ()==nil {_bddb .NewPage ();};_cddd ,_fbb ,_fbdc :=d .GeneratePageBlocks (_bddb ._bbed );if _fbdc !=nil {return _fbdc ;};for _cade ,_bdafc :=range _cddd {if _cade > 0{_bddb .NewPage ();};_bed :=_bddb .getActivePage ();if _bada ,_gbag :=_bddb ._acg [_bed ];_gbag {if _beda :=_bada .mergeBlocks (_bdafc );_beda !=nil {return _beda ;};if _bcde :=_afc (_bdafc ._fd ,_bada ._fd );_bcde !=nil {return _bcde ;};}else {_bddb ._acg [_bed ]=_bdafc ;};};_bddb ._bbed .X =_fbb .X ;_bddb ._bbed .Y =_fbb .Y ;_bddb ._bbed .Height =_fbb .PageHeight -_fbb .Y -_fbb .Margins ._daeg ;return nil ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_afff *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bffa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ada ,_ ,_gfde :=_afff .draw ("");if _gfde !=nil {return nil ,ctx ,_gfde ;};_gfde =_bffa .addContentsByString (string (_ada ));if _gfde !=nil {return nil ,ctx ,_gfde ;};return []*Block {_bffa },ctx ,nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func (_dedd *Paragraph )getMaxLineWidth ()float64 {if _dedd ._dced ==nil ||len (_dedd ._dced )==0{_dedd .wrapText ();};var _ggcg float64 ;for _ ,_dgec :=range _dedd ._dced {_bcg :=_dedd .getTextLineWidth (_dgec );if _bcg > _ggcg {_ggcg =_bcg ;};};return _ggcg ;};

// SetText sets the text content of the Paragraph.
func (_gfee *Paragraph )SetText (text string ){_gfee ._fccag =text };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_gedd *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aabb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbdf ,_afdfg :=_aabb .setOpacity (_gedd ._ebbb ,_gedd ._fccf );if _afdfg !=nil {return nil ,ctx ,_afdfg ;};_bedb :=_gedd ._efeec ;_bedb .FillEnabled =_bedb .FillColor !=nil ;_bfee :=_bedb .Curves ;_fdff :=ctx .PageHeight ;for _fcbdb :=range _bfee {_gbbf :=&_bfee [_fcbdb ];_gbbf .P0 .Y =_fdff -_gbbf .P0 .Y ;_gbbf .P1 .Y =_fdff -_gbbf .P1 .Y ;_gbbf .P2 .Y =_fdff -_gbbf .P2 .Y ;_gbbf .P3 .Y =_fdff -_gbbf .P3 .Y ;};_ddba ,_ ,_afdfg :=_bedb .Draw (_gbdf );if _afdfg !=nil {return nil ,ctx ,_afdfg ;};if _afdfg =_aabb .addContentsByString (string (_ddba ));_afdfg !=nil {return nil ,ctx ,_afdfg ;};return []*Block {_aabb },ctx ,nil ;};

// SetWidthTop sets border width for top.
func (_caef *border )SetWidthTop (bw float64 ){_caef ._fdgf =bw };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_fdad *Invoice )NoteStyle ()TextStyle {return _fdad ._dcb };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ccbb *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_facd :=ctx ;_dfgf :=[]func (_gcgcc DrawContext )([]*Block ,DrawContext ,error ){_ccbb .generateHeaderBlocks ,_ccbb .generateInformationBlocks ,_ccbb .generateLineBlocks ,_ccbb .generateTotalBlocks ,_ccbb .generateNoteBlocks };var _dcab []*Block ;for _ ,_ddfg :=range _dfgf {_eggg ,_abea ,_cfaae :=_ddfg (ctx );if _cfaae !=nil {return _dcab ,ctx ,_cfaae ;};if len (_dcab )==0{_dcab =_eggg ;}else if len (_eggg )> 0{_dcab [len (_dcab )-1].mergeBlocks (_eggg [0]);_dcab =append (_dcab ,_eggg [1:]...);};ctx =_abea ;};if _ccbb ._ggdc .isRelative (){ctx .X =_facd .X ;};if _ccbb ._ggdc .isAbsolute (){return _dcab ,_facd ,nil ;};return _dcab ,ctx ,nil ;};func (_gbeg *Creator )getActivePage ()*_bc .PdfPage {if _gbeg ._dae ==nil {if len (_gbeg ._ecfa )==0{return nil ;};return _gbeg ._ecfa [len (_gbeg ._ecfa )-1];};return _gbeg ._dae ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetBorderColor sets the border color.
func (_cfggg *Ellipse )SetBorderColor (col Color ){_cfggg ._gfdfe =_bc .NewPdfColorDeviceRGB (col .ToRGB ());};

// The Image type is used to draw an image onto PDF.
type Image struct{_gadg *_bc .XObjectImage ;_aeef *_bc .Image ;_bggc float64 ;_bea ,_bebbc float64 ;_aaca ,_cff float64 ;_bcfa positioning ;_fcdf HorizontalAlignment ;_feb float64 ;_fagg float64 ;_gffb float64 ;_eaga margins ;_fcgc ,_adaa float64 ;_babc _ffg .StreamEncoder ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_efdb *Image )SetEncoder (encoder _ffg .StreamEncoder ){_efdb ._babc =encoder };

// NewPolyline creates a new polyline.
func (_bgcb *Creator )NewPolyline (points []_bf .Point )*Polyline {return _dceafa (points )};

// SetEnableWrap sets the line wrapping enabled flag.
func (_egac *Paragraph )SetEnableWrap (enableWrap bool ){_egac ._dgf =enableWrap ;_egac ._gfgaf =false };func (_be *Block )transform (_bcd _aa .Matrix ){_dgd :=_d .NewContentCreator ().Add_cm (_bcd [0],_bcd [1],_bcd [3],_bcd [4],_bcd [6],_bcd [7]).Operations ();*_be ._ae =append (*_dgd ,*_be ._ae ...);_be ._ae .WrapIfNeeded ();};func _begc (_ffaab ,_bfgdd ,_ffag float64 )(_ccdd ,_dcbca ,_acbce ,_afcec float64 ){if _ffag ==0{return 0,0,_ffaab ,_bfgdd ;};_gafd :=_bf .Path {Points :[]_bf .Point {_bf .NewPoint (0,0).Rotate (_ffag ),_bf .NewPoint (_ffaab ,0).Rotate (_ffag ),_bf .NewPoint (0,_bfgdd ).Rotate (_ffag ),_bf .NewPoint (_ffaab ,_bfgdd ).Rotate (_ffag )}}.GetBoundingBox ();return _gafd .X ,_gafd .Y ,_gafd .Width ,_gafd .Height ;};func _abdfg (_edgd string ,_gfed ,_dccbc TextStyle )*TOC {_aabdg :=_dccbc ;_aabdg .FontSize =14;_ccdcb :=_ebge (_aabdg );_ccdcb .SetEnableWrap (true );_ccdcb .SetTextAlignment (TextAlignmentLeft );_ccdcb .SetMargins (0,0,0,5);_ccad :=_ccdcb .Append (_edgd );_ccad .Style =_aabdg ;return &TOC {_dfbb :_ccdcb ,_fecfb :[]*TOCLine {},_fgeg :_gfed ,_ceeda :_gfed ,_cbed :_gfed ,_bbaa :_gfed ,_fbf :"\u002e",_fdag :10,_agba :margins {0,0,2,2},_gcab :_feeg ,_aegd :_gfed ,_fadec :true };};func (_ce *Block )drawToPage (_abed *_bc .PdfPage )error {_cag :=&_d .ContentStreamOperations {};if _abed .Resources ==nil {_abed .Resources =_bc .NewPdfPageResources ();};_ecd :=_gdd (_cag ,_abed .Resources ,_ce ._ae ,_ce ._fd );if _ecd !=nil {return _ecd ;};if _ecd =_afc (_ce ._fd ,_abed .Resources );_ecd !=nil {return _ecd ;};if _ecd =_abed .AppendContentBytes (_cag .Bytes (),true );_ecd !=nil {return _ecd ;};for _ ,_ag :=range _ce ._fg {_abed .AddAnnotation (_ag );};return nil ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bgeb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bgeb ._eefe =address };

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_efe *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _gffg (x ,y ,width ,height );};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gddc *TOCLine )SetStyle (style TextStyle ){_gddc .Number .Style =style ;_gddc .Title .Style =style ;_gddc .Separator .Style =style ;_gddc .Page .Style =style ;};

// SetBorderWidth sets the border width.
func (_aabfc *Rectangle )SetBorderWidth (bw float64 ){_aabfc ._fdee =bw };

// SetWidthBottom sets border width for bottom.
func (_ecga *border )SetWidthBottom (bw float64 ){_ecga ._ded =bw };

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_ebb *Chapter )GetHeading ()*Paragraph {return _ebb ._afd };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_gdbde *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_dgab ,_gece :=_gdbde .Wrap (width );if _gece !=nil {return nil ,_gece ;};_adbe :=int (height /_gdbde .Style .FontSize );if _adbe >=len (_dgab ){return nil ,nil ;};_ccggf :="\u000a";_gdbde .Text =_bd .Replace (_bd .Join (_dgab [:_adbe ],"\u0020"),_ccggf +"\u0020",_ccggf ,-1);_aceg :=_bd .Replace (_bd .Join (_dgab [_adbe :],"\u0020"),_ccggf +"\u0020",_ccggf ,-1);return NewTextChunk (_aceg ,_gdbde .Style ),nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_cfgga *Paragraph )SetLineHeight (lineheight float64 ){_cfgga ._eded =lineheight };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_faef *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcbb :=ctx ;var _caffc []*Block ;_bce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _faef ._efcfe .isRelative (){ctx .X +=_faef ._ecccb ._eagb ;ctx .Y +=_faef ._ecccb ._egdb ;ctx .Width -=_faef ._ecccb ._eagb +_faef ._ecccb ._ggbd ;ctx .Height -=_faef ._ecccb ._egdb +_faef ._ecccb ._daeg ;_faef .SetWidth (ctx .Width );if _faef .Height ()> ctx .Height {_caffc =append (_caffc ,_bce );_bce =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fcbe :=ctx ;_fcbe .Y =ctx .Margins ._egdb ;_fcbe .X =ctx .Margins ._eagb +_faef ._ecccb ._eagb ;_fcbe .Height =ctx .PageHeight -ctx .Margins ._egdb -ctx .Margins ._daeg -_faef ._ecccb ._daeg ;_fcbe .Width =ctx .PageWidth -ctx .Margins ._eagb -ctx .Margins ._ggbd -_faef ._ecccb ._eagb -_faef ._ecccb ._ggbd ;ctx =_fcbe ;};}else {if int (_faef ._faeg )<=0{_faef .SetWidth (_faef .getTextWidth ());};ctx .X =_faef ._gcca ;ctx .Y =_faef ._ccgd ;};ctx ,_dfae :=_bcff (_bce ,_faef ,ctx );if _dfae !=nil {_bge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dfae );return nil ,ctx ,_dfae ;};_caffc =append (_caffc ,_bce );if _faef ._efcfe .isRelative (){ctx .X -=_faef ._ecccb ._eagb ;ctx .Width =_dcbb .Width ;return _caffc ,ctx ,nil ;};return _caffc ,_dcbb ,nil ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_abdd *_bc .PdfAnnotation ;_aggb bool ;};

// Logo returns the logo of the invoice.
func (_bffcg *Invoice )Logo ()*Image {return _bffcg ._aabf };func _afc (_ecdg ,_cge *_bc .PdfPageResources )error {_fff ,_ :=_ecdg .GetColorspaces ();if _fff !=nil &&len (_fff .Colorspaces )> 0{for _dbf ,_gfa :=range _fff .Colorspaces {_bbb :=*_ffg .MakeName (_dbf );if _cge .HasColorspaceByName (_bbb ){continue ;};_cfdd :=_cge .SetColorspaceByName (_bbb ,_gfa );if _cfdd !=nil {return _cfdd ;};};};return nil ;};

// RotatedSize returns the width and height of the rotated block.
func (_abe *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_dd ,_bac :=_begc (_abe ._ee ,_abe ._gfc ,_abe ._fe );return _dd ,_bac ;};

// SetLineOpacity sets the line opacity.
func (_acgb *Polyline )SetLineOpacity (opacity float64 ){_acgb ._fagab =opacity };

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_bece *TableCell )SetContent (vd VectorDrawable )error {switch _cgeb :=vd .(type ){case *Paragraph :if _cgeb ._gfgaf {_cgeb ._dgf =true ;};_bece ._bcdac =vd ;case *StyledParagraph :if _cgeb ._cecg {_cgeb ._eab =true ;};_bece ._bcdac =vd ;case *Image :_bece ._bcdac =vd ;case *Table :_bece ._bcdac =vd ;case *List :_bece ._bcdac =vd ;case *Division :_bece ._bcdac =vd ;default:_bge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _ffg .ErrTypeError ;};return nil ;};

// SetNotes sets the notes section of the invoice.
func (_dbfgf *Invoice )SetNotes (title ,content string ){_dbfgf ._aea =[2]string {title ,content }};

// Level returns the indentation level of the TOC line.
func (_bfdff *TOCLine )Level ()uint {return _bfdff ._egecc };

// SetWidth sets line width.
func (_dfcd *Curve )SetWidth (width float64 ){_dfcd ._aadb =width };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_ebfa *Invoice )SetNoteStyle (style TextStyle ){_ebfa ._dcb =style };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_bc .PdfPage )(*Block ,error ){_db :=&Block {};_fed ,_eg :=page .GetAllContentStreams ();if _eg !=nil {return nil ,_eg ;};_cf :=_d .NewContentStreamParser (_fed );_gd ,_eg :=_cf .Parse ();if _eg !=nil {return nil ,_eg ;};_gd .WrapIfNeeded ();_db ._ae =_gd ;if page .Resources !=nil {_db ._fd =page .Resources ;}else {_db ._fd =_bc .NewPdfPageResources ();};_ba ,_eg :=page .GetMediaBox ();if _eg !=nil {return nil ,_eg ;};if _ba .Llx !=0||_ba .Lly !=0{_db .translate (-_ba .Llx ,_ba .Lly );};_db ._ee =_ba .Urx -_ba .Llx ;_db ._gfc =_ba .Ury -_ba .Lly ;if page .Rotate !=nil {_db ._fe =-float64 (*page .Rotate );};return _db ,nil ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_gccaf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gfcf float64 ;_egecc uint ;_ggfe float64 ;_dacf positioning ;_aggc float64 ;_abeff float64 ;_edbce int64 ;};

// SetLineWidth sets the line width.
func (_bafd *Line )SetLineWidth (lw float64 ){_bafd ._gdfc =lw };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// Scale block by specified factors in the x and y directions.
func (_dg *Block )Scale (sx ,sy float64 ){_ffd :=_d .NewContentCreator ().Scale (sx ,sy ).Operations ();*_dg ._ae =append (*_ffd ,*_dg ._ae ...);_dg ._ae .WrapIfNeeded ();_dg ._ee *=sx ;_dg ._gfc *=sy ;};func _cebb (_eebe *_bc .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_eebe ,FontSize :10};};func _ffga (_deec ,_egg ,_bdcg ,_gdf float64 )*Ellipse {_edfb :=&Ellipse {};_edfb ._abeg =_deec ;_edfb ._eace =_egg ;_edfb ._aaff =_bdcg ;_edfb ._aabg =_gdf ;_edfb ._gfdfe =_bc .NewPdfColorDeviceRGB (0,0,0);_edfb ._cdcd =1.0;return _edfb ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_bcf []_bf .CubicBezierCurve ;FillEnabled bool ;_badb *_bc .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_bgfb *_bc .PdfColorDeviceRGB ;};type rgbColor struct{_aaeg ,_bad ,_dddc float64 };

// CreateTableOfContents sets a function to generate table of contents.
func (_gdbbe *Creator )CreateTableOfContents (genTOCFunc func (_caag *TOC )error ){_gdbbe ._ggd =genTOCFunc ;};

// SetMargins sets the margins of the paragraph.
func (_bfff *List )SetMargins (left ,right ,top ,bottom float64 ){_bfff ._ecab ._eagb =left ;_bfff ._ecab ._ggbd =right ;_bfff ._ecab ._egdb =top ;_bfff ._ecab ._daeg =bottom ;};

// SetColorTop sets border color for top.
func (_egfe *border )SetColorTop (col Color ){_egfe ._gbec =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetFont sets the Paragraph's font.
func (_gbd *Paragraph )SetFont (font *_bc .PdfFont ){_gbd ._abcd =font };

// Height returns the Block's height.
func (_egf *Block )Height ()float64 {return _egf ._gfc };

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_dgdd *Paragraph )SetColor (col Color ){_efgb :=_bc .NewPdfColorDeviceRGB (col .ToRGB ());_dgdd ._bcbbb =*_efgb ;};

// SetMargins sets the margins TOC line.
func (_fedd *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_fedd ._gfcf =left ;_aefgb :=&_fedd ._gccaf ._bbcf ;_aefgb ._eagb =_fedd ._gfcf +float64 (_fedd ._egecc -1)*_fedd ._ggfe ;_aefgb ._ggbd =right ;_aefgb ._egdb =top ;_aefgb ._daeg =bottom ;};

// SetLineWidth sets the line width.
func (_edab *Polyline )SetLineWidth (lineWidth float64 ){_edab ._aefd .LineWidth =lineWidth };

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bdaa *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _bdaa ._degb [0],_bdaa ._degb [1]};

// MoveX moves the drawing context to absolute position x.
func (_aga *Creator )MoveX (x float64 ){_aga ._bbed .X =x };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_cdce *TOC )SetLineLevelOffset (levelOffset float64 ){_cdce ._fdag =levelOffset };

// SetBorderColor sets the cell's border color.
func (_bdgfc *TableCell )SetBorderColor (col Color ){_bdgfc ._gdbg =_bc .NewPdfColorDeviceRGB (col .ToRGB ());_bdgfc ._bgag =_bc .NewPdfColorDeviceRGB (col .ToRGB ());_bdgfc ._fegcg =_bc .NewPdfColorDeviceRGB (col .ToRGB ());_bdgfc ._abaceg =_bc .NewPdfColorDeviceRGB (col .ToRGB ());};

// NewImageFromFile creates an Image from a file.
func (_cbcg *Creator )NewImageFromFile (path string )(*Image ,error ){return _fac (path )};var PPMM =float64 (72*1.0/25.4);

// SkipRows skips over a specified number of rows in the table.
func (_efdfb *Table )SkipRows (num int ){_fdbbg :=num *_efdfb ._gccf -1;if _fdbbg < 0{_bge .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_efdfb ._gcbb +=_fdbbg ;};

// SetFillColor sets the fill color.
func (_cafa *Rectangle )SetFillColor (col Color ){_cafa ._gabg =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetAnnotation sets a annotation on a TextChunk.
func (_fecc *TextChunk )SetAnnotation (annotation *_bc .PdfAnnotation ){_fecc ._abdd =annotation };func (_cced positioning )isAbsolute ()bool {return _cced ==_bgaf };

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_dbae *Invoice )AddressStyle ()TextStyle {return _dbae ._abace };

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_cbgd *Image )SetMargins (left ,right ,top ,bottom float64 ){_cbgd ._eaga ._eagb =left ;_cbgd ._eaga ._ggbd =right ;_cbgd ._eaga ._egdb =top ;_cbgd ._eaga ._daeg =bottom ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_ebdb *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _ebdb ._fgde ,_ebdb ._cede ,_ebdb ._ecce ,_ebdb ._bddc ;};

// SetFillColor sets the fill color.
func (_bfba *Ellipse )SetFillColor (col Color ){_bfba ._ffdd =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_cdbc *Image )SetPos (x ,y float64 ){_cdbc ._bcfa =_bgaf ;_cdbc ._feb =x ;_cdbc ._fagg =y };

// SetIndent sets the left offset of the list when nested into another list.
func (_cadeb *List )SetIndent (indent float64 ){_cadeb ._dgag =indent ;_cadeb ._gdde =false };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_abcg *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_abcg .Text },nil ;};var _aeea []string ;var _geab []rune ;var _acgbe float64 ;var _afbfe []float64 ;_ggfae :=_abcg .Style ;for _ ,_cfcgb :=range _abcg .Text {if _cfcgb =='\u000A'{_aeea =append (_aeea ,_bd .TrimRightFunc (string (_geab ),_gf .IsSpace )+string (_cfcgb ));_geab =nil ;_acgbe =0;_afbfe =nil ;continue ;};_bced :=_cfcgb ==' ';_fbabc ,_ecbb :=_ggfae .Font .GetRuneMetrics (_cfcgb );if !_ecbb {_bge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_cfcgb ,_cfcgb ,_ggfae .Font .BaseFont (),_ggfae .Font .Subtype ());_bge .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ggfae .Font );_bge .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ggfae .Font .Encoder ());return nil ,_c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_becc :=_ggfae .FontSize *_fbabc .Wx ;_dgaed :=_becc ;if !_bced {_dgaed =_becc +_ggfae .CharSpacing *1000.0;};if _acgbe +_becc > width *1000.0{_dedeb :=-1;if !_bced {for _cfbe :=len (_geab )-1;_cfbe >=0;_cfbe --{if _geab [_cfbe ]==' '{_dedeb =_cfbe ;break ;};};};_ecfb :=string (_geab );if _dedeb > 0{_ecfb =string (_geab [0:_dedeb +1]);_geab =append (_geab [_dedeb +1:],_cfcgb );_afbfe =append (_afbfe [_dedeb +1:],_dgaed );_acgbe =0;for _ ,_bcdeg :=range _afbfe {_acgbe +=_bcdeg ;};}else {if _bced {_geab =[]rune {};_afbfe =[]float64 {};_acgbe =0;}else {_geab =[]rune {_cfcgb };_afbfe =[]float64 {_dgaed };_acgbe =_dgaed ;};};_aeea =append (_aeea ,_bd .TrimRightFunc (_ecfb ,_gf .IsSpace ));}else {_geab =append (_geab ,_cfcgb );_acgbe +=_dgaed ;_afbfe =append (_afbfe ,_dgaed );};};if len (_geab )> 0{_aeea =append (_aeea ,string (_geab ));};return _aeea ,nil ;};

// SetBorderWidth sets the border width.
func (_ceea *Polygon )SetBorderWidth (borderWidth float64 ){_ceea ._ggca .BorderWidth =borderWidth };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_gebe *StyledParagraph )Height ()float64 {_gebe .wrapText ();var _feeba float64 ;for _ ,_ebgf :=range _gebe ._gcded {var _dage float64 ;for _ ,_ffdb :=range _ebgf {_dbcgd :=_gebe ._eadg *_ffdb .Style .FontSize ;if _dbcgd > _dage {_dage =_dbcgd ;};};_feeba +=_dage ;};return _feeba ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_fdgg *Invoice )AddressHeadingStyle ()TextStyle {return _fdgg ._efda };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_ecdf *Chapter )SetShowNumbering (show bool ){_ecdf ._ggad =show ;_ecdf ._afd .SetText (_ecdf .headingText ());};

// NewChapter creates a new chapter with the specified title as the heading.
func (_fced *Creator )NewChapter (title string )*Chapter {_fced ._eff ++;_gfg :=_fced .NewTextStyle ();_gfg .FontSize =16;return _bda (nil ,_fced ._cgde ,_fced ._fae ,title ,_fced ._eff ,_gfg );};func (_gegae *List )tableHeight (_caac float64 )float64 {var _adcc float64 ;for _ ,_acbb :=range _gegae ._aaaf {switch _cecd :=_acbb ._acdfc .(type ){case *Paragraph :_efdaa :=_cecd ;if _efdaa ._dgf {_efdaa .SetWidth (_caac );};_adcc +=_efdaa .Height ()+_efdaa ._ecccb ._daeg +_efdaa ._ecccb ._daeg ;_adcc +=0.5*_efdaa ._bgebc *_efdaa ._eded ;case *StyledParagraph :_gfdfa :=_cecd ;if _gfdfa ._eab {_gfdfa .SetWidth (_caac );};_adcc +=_gfdfa .Height ()+_gfdfa ._bbcf ._egdb +_gfdfa ._bbcf ._daeg ;_adcc +=0.5*_gfdfa .getTextHeight ();default:_adcc +=_acbb ._acdfc .Height ();};};return _adcc ;};

// Text sets the text content of the Paragraph.
func (_abgd *Paragraph )Text ()string {return _abgd ._fccag };

// SetColorBottom sets border color for bottom.
func (_ddc *border )SetColorBottom (col Color ){_ddc ._dgb =_bc .NewPdfColorDeviceRGB (col .ToRGB ())};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_dgfbg int ;_gccf int ;_gcbb int ;_gbea []float64 ;_gbcf []float64 ;_abbg float64 ;_gggbg []*TableCell ;_bafe positioning ;_dagc ,_degba float64 ;_dbcbe margins ;_fbda bool ;_bdfbd int ;_cfcc int ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_dbfdc *Invoice )NoteHeadingStyle ()TextStyle {return _dbfdc ._ecae };func (_eccea *Paragraph )getTextWidth ()float64 {_fdfc :=0.0;for _ ,_eceba :=range _eccea ._fccag {if _eceba =='\u000A'{continue ;};_gcae ,_bcfae :=_eccea ._abcd .GetRuneMetrics (_eceba );if !_bcfae {_bge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_eceba ,_eceba );return -1;};_fdfc +=_eccea ._bgebc *_gcae .Wx ;};return _fdfc ;};

// SellerAddress returns the seller address used in the invoice template.
func (_egdf *Invoice )SellerAddress ()*InvoiceAddress {return _egdf ._effe };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bggce *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bggce ._bbcf ._eagb ,_bggce ._bbcf ._ggbd ,_bggce ._bbcf ._egdb ,_bggce ._bbcf ._daeg ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_aefd *_bf .Polyline ;_fagab float64 ;};func (_dad *Block )addContentsByString (_gc string )error {_ggb :=_d .NewContentStreamParser (_gc );_bgaa ,_egae :=_ggb .Parse ();if _egae !=nil {return _egae ;};_dad ._ae .WrapIfNeeded ();_bgaa .WrapIfNeeded ();*_dad ._ae =append (*_dad ._ae ,*_bgaa ...);return nil ;};

// SetFillColor sets the fill color.
func (_cdba *PolyBezierCurve )SetFillColor (color Color ){_cdba ._efeec .FillColor =_bc .NewPdfColorDeviceRGB (color .ToRGB ());};

// NewColumn returns a new column for the line items invoice table.
func (_cgdb *Invoice )NewColumn (description string )*InvoiceCell {return _cgdb .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_eafe *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_eafe ._acb ._eagb =left ;_eafe ._acb ._ggbd =right ;_eafe ._acb ._egdb =top ;_eafe ._acb ._daeg =bottom ;};

// SetHeight sets the Image's document height to specified h.
func (_bebf *Image )SetHeight (h float64 ){_bebf ._bebbc =h };