//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_ge "bytes";_gb "errors";_gd "fmt";_f "github.com/unidoc/unipdf/v3/common";_cd "github.com/unidoc/unipdf/v3/contentstream";_a "github.com/unidoc/unipdf/v3/contentstream/draw";_ga "github.com/unidoc/unipdf/v3/core";_be "github.com/unidoc/unipdf/v3/internal/license";
_gf "github.com/unidoc/unipdf/v3/internal/transform";_df "github.com/unidoc/unipdf/v3/model";_d "image";_gbc "io";_b "math";_gcf "os";_gc "sort";_c "strconv";_dc "strings";_bb "unicode";);

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_ecega *TOC )SetLineNumberStyle (style TextStyle ){_ecega ._fagee =style };func (_dgca *Invoice )generateNoteBlocks (_egcg DrawContext )([]*Block ,DrawContext ,error ){_gdbe :=_ddf ();_efeg :=append ([][2]string {_dgca ._fgge ,_dgca ._edfda },_dgca ._bcgd ...);
for _ ,_dbeac :=range _efeg {if _dbeac [1]!=""{_ebfc :=_dgca .drawSection (_dbeac [0],_dbeac [1]);for _ ,_fagb :=range _ebfc {_gdbe .Add (_fagb );};_aacc :=_cabf (_dgca ._dfaef );_aacc .SetMargins (0,0,10,0);_gdbe .Add (_aacc );};};return _gdbe .GeneratePageBlocks (_egcg );
};

// SetLevel sets the indentation level of the TOC line.
func (_gfgg *TOCLine )SetLevel (level uint ){_gfgg ._afdb =level ;_gfgg ._feaf ._gaaa .Left =_gfgg ._cddcg +float64 (_gfgg ._afdb -1)*_gfgg ._bada ;};

// SetTitle sets the title of the invoice.
func (_ebag *Invoice )SetTitle (title string ){_ebag ._eaaf =title };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_fecb *TOCLine )SetStyle (style TextStyle ){_fecb .Number .Style =style ;_fecb .Title .Style =style ;_fecb .Separator .Style =style ;_fecb .Page .Style =style ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_gbffd *Paragraph )SetEnableWrap (enableWrap bool ){_gbffd ._bbdf =enableWrap ;_gbffd ._daga =false ;};func _cefc (_fgc _d .Image )(*Image ,error ){_gcbbb ,_edadd :=_df .ImageHandling .NewImageFromGoImage (_fgc );if _edadd !=nil {return nil ,_edadd ;
};return _fcba (_gcbbb );};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_gfaa *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_accg :=_cabf (_gfaa ._cddda );_accg .Append (text );_deca ,_ddgbe :=_gfaa .Add (_accg );return _accg ,_deca ,_ddgbe ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_cdcb *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fedd ,_ebceg :=_cdef .setOpacity (_cdcb ._dacg ,_cdcb ._dacg );if _ebceg !=nil {return nil ,ctx ,_ebceg ;};
_cgff :=_cdcb ._begc .Points ;for _bgfcb :=range _cgff {_bgag :=&_cgff [_bgfcb ];_bgag .Y =ctx .PageHeight -_bgag .Y ;};_acdab ,_ ,_ebceg :=_cdcb ._begc .Draw (_fedd );if _ebceg !=nil {return nil ,ctx ,_ebceg ;};if _ebceg =_cdef .addContentsByString (string (_acdab ));
_ebceg !=nil {return nil ,ctx ,_ebceg ;};return []*Block {_cdef },ctx ,nil ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_fcgd *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _geeea (xc ,yc ,width ,height );};

// SetSideBorderColor sets the cell's side border color.
func (_fegg *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_fegg ._agef =col ;case CellBorderSideBottom :_fegg ._fadc =col ;case CellBorderSideLeft :_fegg ._gcfa =col ;case CellBorderSideRight :_fegg ._aafc =col ;
};};func (_fgefc *StyledParagraph )getMaxLineWidth ()float64 {if _fgefc ._fbdf ==nil ||len (_fgefc ._fbdf )==0{_fgefc .wrapText ();};var _eeaa float64 ;for _ ,_egge :=range _fgefc ._fbdf {_degg :=_fgefc .getTextLineWidth (_egge );if _degg > _eeaa {_eeaa =_degg ;
};};return _eeaa ;};type listItem struct{_cfec VectorDrawable ;_aegc TextChunk ;};

// AddSection adds a new content section at the end of the invoice.
func (_aafg *Invoice )AddSection (title ,content string ){_aafg ._bcgd =append (_aafg ._bcgd ,[2]string {title ,content });};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_cdad *TableCell )SetContent (vd VectorDrawable )error {switch _fdfc :=vd .(type ){case *Paragraph :if _fdfc ._daga {_fdfc ._bbdf =true ;};_cdad ._aabaf =vd ;case *StyledParagraph :if _fdfc ._gbeb {_fdfc ._gafc =true ;};_cdad ._aabaf =vd ;case *Image :_cdad ._aabaf =vd ;
case *Table :_cdad ._aabaf =vd ;case *List :_cdad ._aabaf =vd ;case *Division :_cdad ._aabaf =vd ;default:_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _ga .ErrTypeError ;};return nil ;};func (_faed *TableCell )height (_gceef float64 )float64 {var _bagdb float64 ;switch _cgeee :=_faed ._aabaf .(type ){case *Paragraph :if _cgeee ._bbdf {_cgeee .SetWidth (_gceef -_faed ._dddg -_cgeee ._aaec .Left -_cgeee ._aaec .Right );
};_bagdb =_cgeee .Height ()+_cgeee ._aaec .Top +_cgeee ._aaec .Bottom +0.5*_cgeee ._dgda *_cgeee ._ffg ;case *StyledParagraph :if _cgeee ._gafc {_cgeee .SetWidth (_gceef -_faed ._dddg -_cgeee ._gaaa .Left -_cgeee ._gaaa .Right );};_bagdb =_cgeee .Height ()+_cgeee ._gaaa .Top +_cgeee ._gaaa .Bottom +0.5*_cgeee .getTextHeight ();
case *Image :_bagdb =_cgeee .Height ()+_cgeee ._afgb .Top +_cgeee ._afgb .Bottom ;case *Table :_bagdb =_cgeee .Height ()+_cgeee ._gbcf .Top +_cgeee ._gbcf .Bottom ;case *List :_bagdb =_cgeee .tableHeight (_gceef -_faed ._dddg )+_cgeee ._caee .Top +_cgeee ._caee .Bottom ;
case *Division :_bagdb =_cgeee .ctxHeight (_gceef -_faed ._dddg )+_cgeee ._ccbe .Top +_cgeee ._ccbe .Bottom ;};return _bagdb ;};

// Rows returns the total number of rows the table has.
func (_eeee *Table )Rows ()int {return _eeee ._cead };const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// SetWidthLeft sets border width for left.
func (_bed *border )SetWidthLeft (bw float64 ){_bed ._eda =bw };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_bcfb float64 ;_bfcd float64 ;_aage float64 ;_ddeg float64 ;_abcf Color ;_ddfa float64 ;_baee Color ;_edfac float64 ;_gaac float64 ;};

// SetIndent sets the cell's left indent.
func (_dfee *TableCell )SetIndent (indent float64 ){_dfee ._dddg =indent };

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_adfa *Invoice )AddressStyle ()TextStyle {return _adfa ._cgdc };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_efegg *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_afbdc :=&_efegg ._eebef ;_afbdc .Left =left ;_afbdc .Right =right ;_afbdc .Top =top ;_afbdc .Bottom =bottom ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_eaee *Chapter )SetIncludeInTOC (includeInTOC bool ){_eaee ._dcad =includeInTOC };

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_fgef *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aadb :=ctx ;if _fgef ._cbc .IsRelative (){ctx .X +=_fgef ._bdbd .Left ;ctx .Y +=_fgef ._bdbd .Top ;ctx .Width -=_fgef ._bdbd .Left +_fgef ._bdbd .Right ;ctx .Height -=_fgef ._bdbd .Top ;
};_abcc ,_ggae ,_fcf :=_fgef ._bbf .GeneratePageBlocks (ctx );if _fcf !=nil {return _abcc ,ctx ,_fcf ;};ctx =_ggae ;_bab :=ctx .X ;_ggg :=ctx .Y -_fgef ._bbf .Height ();_fbd :=int64 (ctx .Page );_abcd :=_fgef .headingNumber ();_ggga :=_fgef .headingText ();
if _fgef ._dcad {_gef :=_fgef ._daee .Add (_abcd ,_fgef ._dccb ,_c .FormatInt (_fbd ,10),_fgef ._egcd );if _fgef ._daee ._becc {_gef .SetLink (_fbd ,_bab ,_ggg );};};if _fgef ._dgb ==nil {_fgef ._dgb =_df .NewOutlineItem (_ggga ,_df .NewOutlineDest (_fbd -1,_bab ,_ggg ));
if _fgef ._gbca !=nil {_fgef ._gbca ._dgb .Add (_fgef ._dgb );}else {_fgef ._fgf .Add (_fgef ._dgb );};}else {_dagf :=&_fgef ._dgb .Dest ;_dagf .Page =_fbd -1;_dagf .X =_bab ;_dagf .Y =_ggg ;};for _ ,_fgdg :=range _fgef ._eef {_adbc ,_cab ,_dfea :=_fgdg .GeneratePageBlocks (ctx );
if _dfea !=nil {return _abcc ,ctx ,_dfea ;};if len (_adbc )< 1{continue ;};_abcc [len (_abcc )-1].mergeBlocks (_adbc [0]);_abcc =append (_abcc ,_adbc [1:]...);ctx =_cab ;};if _fgef ._cbc .IsRelative (){ctx .X =_aadb .X ;};if _fgef ._cbc .IsAbsolute (){return _abcc ,_aadb ,nil ;
};return _abcc ,ctx ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_cg *Block )AddAnnotation (annotation *_df .PdfAnnotation ){for _ ,_ce :=range _cg ._dd {if _ce ==annotation {return ;};};_cg ._dd =append (_cg ._dd ,annotation );};func (_caaf *Invoice )newCell (_egfc string ,_cabc InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_cabc ,_egfc };
};

// SetFontSize sets the font size in document units (points).
func (_adee *Paragraph )SetFontSize (fontSize float64 ){_adee ._dgda =fontSize };

// AddLine adds a new line with the provided style to the table of contents.
func (_dcef *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_dcef ._agcg =append (_dcef ._agcg ,line );return line ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_bdg *Creator )SetPageSize (size PageSize ){_bdg ._fgee =size ;_bdg ._fdad =size [0];_bdg ._bea =size [1];_bbfa :=0.1*_bdg ._fdad ;_bdg ._dcea .Left =_bbfa ;_bdg ._dcea .Right =_bbfa ;_bdg ._dcea .Top =_bbfa ;_bdg ._dcea .Bottom =_bbfa ;};func (_ceacd *Table )moveToNextAvailableCell ()int {_babcg :=(_ceacd ._agdbb -1)%(_ceacd ._bdgf )+1;
for {if _babcg -1>=len (_ceacd ._cbfc ){return _babcg ;}else if _ceacd ._cbfc [_babcg -1]==0{return _babcg ;}else {_ceacd ._agdbb ++;_ceacd ._cbfc [_babcg -1]--;};_babcg ++;};};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// GeneratePageBlocks generates a page break block.
func (_adca *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agac :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_ddcd :=ctx ;_ddcd .Y =ctx .Margins .Top ;
_ddcd .X =ctx .Margins .Left ;_ddcd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_ddcd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_ddcd ;return _agac ,ctx ,nil ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_cgca *TOCLine )SetLink (page int64 ,x ,y float64 ){_cgca ._cabec =x ;_cgca ._begf =y ;_cgca ._babaa =page ;_dbbg :=_cgca ._feaf ._fgffa .Color ;_cgca .Number .Style .Color =_dbbg ;_cgca .Title .Style .Color =_dbbg ;_cgca .Separator .Style .Color =_dbbg ;
_cgca .Page .Style .Color =_dbbg ;};

// NewPolyline creates a new polyline.
func (_bdaa *Creator )NewPolyline (points []_a .Point )*Polyline {return _bcbfb (points )};

// SetColorLeft sets border color for left.
func (_dceg *border )SetColorLeft (col Color ){_dceg ._abgf =col };

// Columns returns all the columns in the invoice line items table.
func (_cdfb *Invoice )Columns ()[]*InvoiceCell {return _cdfb ._bgdg };func (_fbffc *StyledParagraph )wrapText ()error {return _fbffc .wrapChunks (true )};var PPI float64 =72;func (_dad *Block )addContentsByString (_bdb string )error {_gde :=_cd .NewContentStreamParser (_bdb );
_eb ,_aad :=_gde .Parse ();if _aad !=nil {return _aad ;};_dad ._gea .WrapIfNeeded ();_eb .WrapIfNeeded ();*_dad ._gea =append (*_dad ._gea ,*_eb ...);return nil ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_dgga *StyledParagraph )SetTextAlignment (align TextAlignment ){_dgga ._ggbd =align };

// SetBorderOpacity sets the border opacity.
func (_deeg *Polygon )SetBorderOpacity (opacity float64 ){_deeg ._bggc =opacity };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_effg *TOC )SetLineSeparatorStyle (style TextStyle ){_effg ._fbga =style };

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_bgbdd *Table )MultiRowCell (rowspan int )*TableCell {return _bgbdd .MultiCell (rowspan ,1)};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _dcfb ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_efac :=&Creator {};_efac ._aeg =[]*_df .PdfPage {};_efac ._dcaf =map[*_df .PdfPage ]*Block {};_efac .SetPageSize (PageSizeLetter );_cagf :=0.1*_efac ._fdad ;
_efac ._dcea .Left =_cagf ;_efac ._dcea .Right =_cagf ;_efac ._dcea .Top =_cagf ;_efac ._dcea .Bottom =_cagf ;var _bcfc error ;_efac ._cgd ,_bcfc =_df .NewStandard14Font (_df .HelveticaName );if _bcfc !=nil {_efac ._cgd =_df .DefaultFont ();};_efac ._bfb ,_bcfc =_df .NewStandard14Font (_df .HelveticaBoldName );
if _bcfc !=nil {_efac ._cgd =_df .DefaultFont ();};_efac ._ccff =_efac .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_efac .AddOutlines =true ;_efac ._ggbe =_df .NewOutline ();_be .TrackUse (_dcfb );
return _efac ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_cadd *Image )SetMargins (left ,right ,top ,bottom float64 ){_cadd ._afgb .Left =left ;_cadd ._afgb .Right =right ;_cadd ._afgb .Top =top ;_cadd ._afgb .Bottom =bottom ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_gfg *_a .CurvePolygon ;_eddg float64 ;_gcec float64 ;};

// NewTOC creates a new table of contents.
func (_aef *Creator )NewTOC (title string )*TOC {_cagde :=_aef .NewTextStyle ();_cagde .Font =_aef ._bfb ;return _dedd (title ,_aef .NewTextStyle (),_cagde );};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_bdgb *Creator )Finalize ()error {if _bdgb ._egcda {return nil ;};_egfg :=len (_bdgb ._aeg );_daef :=0;if _bdgb ._bgfe !=nil {_bafe :=*_bdgb ;_bdgb ._aeg =nil ;_bdgb ._baf =nil ;_bdgb .initContext ();_cegb :=FrontpageFunctionArgs {PageNum :1,TotalPages :_egfg };
_bdgb ._bgfe (_cegb );_daef +=len (_bdgb ._aeg );_bdgb ._aeg =_bafe ._aeg ;_bdgb ._baf =_bafe ._baf ;};if _bdgb .AddTOC {_bdgb .initContext ();_bdgb ._gfbg .Page =_daef +1;if _bdgb ._eab !=nil {if _fde :=_bdgb ._eab (_bdgb ._ccff );_fde !=nil {return _fde ;
};};_caf ,_ ,_faag :=_bdgb ._ccff .GeneratePageBlocks (_bdgb ._gfbg );if _faag !=nil {_f .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_faag );
return _faag ;};_daef +=len (_caf );_cfcc :=_bdgb ._ccff .Lines ();for _ ,_aca :=range _cfcc {_dgg ,_adcc :=_c .Atoi (_aca .Page .Text );if _adcc !=nil {continue ;};_aca .Page .Text =_c .Itoa (_dgg +_daef );};};_bced :=false ;var _cagd []*_df .PdfPage ;
if _bdgb ._bgfe !=nil {_bbcb :=*_bdgb ;_bdgb ._aeg =nil ;_bdgb ._baf =nil ;_cfd :=FrontpageFunctionArgs {PageNum :1,TotalPages :_egfg };_bdgb ._bgfe (_cfd );_egfg +=len (_bdgb ._aeg );_cagd =_bdgb ._aeg ;_bdgb ._aeg =append (_bdgb ._aeg ,_bbcb ._aeg ...);
_bdgb ._baf =_bbcb ._baf ;_bced =true ;};var _bfgc []*_df .PdfPage ;if _bdgb .AddTOC {_bdgb .initContext ();if _bdgb ._eab !=nil {if _edag :=_bdgb ._eab (_bdgb ._ccff );_edag !=nil {_f .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_edag );
return _edag ;};};_gbcb :=_bdgb ._ccff .Lines ();for _ ,_ebcc :=range _gbcb {_ebcc ._babaa +=int64 (_daef );};_efbb ,_ ,_ :=_bdgb ._ccff .GeneratePageBlocks (_bdgb ._gfbg );for _ ,_abccd :=range _efbb {_abccd .SetPos (0,0);_egfg ++;_aeab :=_bdgb .newPage ();
_bfgc =append (_bfgc ,_aeab );_bdgb .setActivePage (_aeab );_bdgb .Draw (_abccd );};if _bced {_facf :=_cagd ;_ccda :=_bdgb ._aeg [len (_cagd ):];_bdgb ._aeg =append ([]*_df .PdfPage {},_facf ...);_bdgb ._aeg =append (_bdgb ._aeg ,_bfgc ...);_bdgb ._aeg =append (_bdgb ._aeg ,_ccda ...);
}else {_bdgb ._aeg =append (_bfgc ,_bdgb ._aeg ...);};};if _bdgb ._ggbe !=nil &&_bdgb .AddOutlines {var _accc func (_decd *_df .OutlineItem );_accc =func (_afbe *_df .OutlineItem ){_afbe .Dest .Page +=int64 (_daef );if _gdf :=int (_afbe .Dest .Page );_gdf >=0&&_gdf < len (_bdgb ._aeg ){_afbe .Dest .PageObj =_bdgb ._aeg [_gdf ].GetPageAsIndirectObject ();
}else {_f .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gdf );
};_afbe .Dest .Y =_bdgb ._bea -_afbe .Dest .Y ;_gedf :=_afbe .Items ();for _ ,_aega :=range _gedf {_accc (_aega );};};_gcbb :=_bdgb ._ggbe .Items ();for _ ,_ega :=range _gcbb {_accc (_ega );};if _bdgb .AddTOC {var _fbgd int ;if _bced {_fbgd =len (_cagd );
};_gcba :=_df .NewOutlineDest (int64 (_fbgd ),0,_bdgb ._bea );if _fbgd >=0&&_fbgd < len (_bdgb ._aeg ){_gcba .PageObj =_bdgb ._aeg [_fbgd ].GetPageAsIndirectObject ();}else {_f .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_fbgd );
};_bdgb ._ggbe .Insert (0,_df .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_gcba ));};};for _gcbg ,_bcfe :=range _bdgb ._aeg {_bdgb .setActivePage (_bcfe );if _bdgb ._cfbde !=nil {_geec ,_cac ,_cfeb :=_bcfe .Size ();
if _cfeb !=nil {return _cfeb ;};_bgfc :=PageFinalizeFunctionArgs {PageNum :_gcbg +1,PageWidth :_geec ,PageHeight :_cac ,TOCPages :len (_bfgc ),TotalPages :_egfg };if _fgfg :=_bdgb ._cfbde (_bgfc );_fgfg !=nil {_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_fgfg );
return _fgfg ;};};if _bdgb ._ggc !=nil {_fcff :=NewBlock (_bdgb ._fdad ,_bdgb ._dcea .Top );_cggc :=HeaderFunctionArgs {PageNum :_gcbg +1,TotalPages :_egfg };_bdgb ._ggc (_fcff ,_cggc );_fcff .SetPos (0,0);if _gcde :=_bdgb .Draw (_fcff );_gcde !=nil {_f .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_gcde );
return _gcde ;};};if _bdgb ._fdfd !=nil {_edb :=NewBlock (_bdgb ._fdad ,_bdgb ._dcea .Bottom );_bec :=FooterFunctionArgs {PageNum :_gcbg +1,TotalPages :_egfg };_bdgb ._fdfd (_edb ,_bec );_edb .SetPos (0,_bdgb ._bea -_edb ._gca );if _badcg :=_bdgb .Draw (_edb );
_badcg !=nil {_f .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_badcg );return _badcg ;};};_aaf ,_faceb :=_bdgb ._dcaf [_bcfe ];if !_faceb {continue ;};if _aff ,_aada :=_bdgb ._fbef [_bcfe ];
_aada {_aaf .transform (_aff );};if _abd :=_aaf .drawToPage (_bcfe );_abd !=nil {_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_gcbg +1,_abd );
return _abd ;};};_bdgb ._egcda =true ;return nil ;};

// SetBackgroundColor sets the cell's background color.
func (_dfab *TableCell )SetBackgroundColor (col Color ){_dfab ._bcgcg =col };

// IsAbsolute checks if the positioning is absolute.
func (_ageg Positioning )IsAbsolute ()bool {return _ageg ==PositionAbsolute };

// SetMargins sets the margins TOC line.
func (_eccea *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_eccea ._cddcg =left ;_afagd :=&_eccea ._feaf ._gaaa ;_afagd .Left =_eccea ._cddcg +float64 (_eccea ._afdb -1)*_eccea ._bada ;_afagd .Right =right ;_afagd .Top =top ;_afagd .Bottom =bottom ;
};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        â€¢ This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_eaga []*listItem ;_caee Margins ;_edab TextChunk ;_dfgb float64 ;_fecfb bool ;_gfcb Positioning ;_cddda TextStyle ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// SetFillOpacity sets the fill opacity.
func (_bcfcf *Polygon )SetFillOpacity (opacity float64 ){_bcfcf ._ffgf =opacity };const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_bdgd *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_bdgd ._babff =halign };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_dbgg *Creator )NewTextStyle ()TextStyle {return _adfd (_dbgg ._cgd )};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_dbea *Invoice )InfoLines ()[][2]*InvoiceCell {_gbgb :=[][2]*InvoiceCell {_dbea ._gfea ,_dbea ._aee ,_dbea ._beefc };return append (_gbgb ,_dbea ._efgcg ...);};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_eggf *Image )SetWidth (w float64 ){_eggf ._ggfg =w };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cegf *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_accd :=ctx ;_bdge :=[]func (_afgf DrawContext )([]*Block ,DrawContext ,error ){_cegf .generateHeaderBlocks ,_cegf .generateInformationBlocks ,_cegf .generateLineBlocks ,_cegf .generateTotalBlocks ,_cegf .generateNoteBlocks };
var _add []*Block ;for _ ,_addd :=range _bdge {_fcab ,_fdgd ,_dged :=_addd (ctx );if _dged !=nil {return _add ,ctx ,_dged ;};if len (_add )==0{_add =_fcab ;}else if len (_fcab )> 0{_add [len (_add )-1].mergeBlocks (_fcab [0]);_add =append (_add ,_fcab [1:]...);
};ctx =_fdgd ;};if _cegf ._ecgeb .IsRelative (){ctx .X =_accd .X ;};if _cegf ._ecgeb .IsAbsolute (){return _add ,_accd ,nil ;};return _add ,ctx ,nil ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_dgef *Table )SetMargins (left ,right ,top ,bottom float64 ){_dgef ._gbcf .Left =left ;_dgef ._gbcf .Right =right ;_dgef ._gbcf .Top =top ;_dgef ._gbcf .Bottom =bottom ;};

// CurCol returns the currently active cell's column number.
func (_defe *Table )CurCol ()int {_cefee :=(_defe ._agdbb -1)%(_defe ._bdgf )+1;return _cefee };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_gdd *Block )ScaleToHeight (h float64 ){_cfb :=h /_gdd ._gca ;_gdd .Scale (_cfb ,_cfb )};func (_ffff *StyledParagraph )split (_cfad DrawContext )(_dfcc ,_ffee *StyledParagraph ,_cagfe error ){if _cagfe =_ffff .wrapChunks (false );_cagfe !=nil {return nil ,nil ,_cagfe ;
};_cdeb :=func (_agdg []*TextChunk ,_bgfcf []*TextChunk )[]*TextChunk {if len (_bgfcf )==0{return _agdg ;};_fdfe :=len (_agdg );if _fdfe ==0{return append (_agdg ,_bgfcf ...);};_agdg [_fdfe -1].Text +=_bgfcf [0].Text ;return append (_agdg ,_bgfcf [1:]...);
};_bafef :=func (_bcgfa *StyledParagraph ,_egeb []*TextChunk )*StyledParagraph {if len (_egeb )==0{return nil ;};_cddf :=*_bcgfa ;_cddf ._cccac =_egeb ;return &_cddf ;};var (_badga float64 ;_fbcb []*TextChunk ;_gedg []*TextChunk ;);for _ ,_gddd :=range _ffff ._fbdf {var _cddb float64 ;
_cddgb :=make ([]*TextChunk ,0,len (_gddd ));for _ ,_bbce :=range _gddd {if _aeeaf :=_bbce .Style .FontSize ;_aeeaf > _cddb {_cddb =_aeeaf ;};_cddgb =append (_cddgb ,_bbce .clone ());};_cddb *=_ffff ._gccd ;if _ffff ._becgb .IsRelative (){if _badga +_cddb > _cfad .Height {_gedg =_cdeb (_gedg ,_cddgb );
}else {_fbcb =_cdeb (_fbcb ,_cddgb );};};_badga +=_cddb ;};_ffff ._fbdf =nil ;if len (_gedg )==0{return _ffff ,nil ,nil ;};return _bafef (_ffff ,_fbcb ),_bafef (_ffff ,_gedg ),nil ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// NewDivision returns a new Division container component.
func (_dgbd *Creator )NewDivision ()*Division {return _ddf ()};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// Length calculates and returns the line length.
func (_dbab *Line )Length ()float64 {return _b .Sqrt (_b .Pow (_dbab ._ceac -_dbab ._eccf ,2.0)+_b .Pow (_dbab ._bgda -_dbab ._acbbf ,2.0));};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cbgf *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gffe :=ctx ;_beeg ,ctx ,_beb :=_cbgf ._feaf .GeneratePageBlocks (ctx );if _beb !=nil {return _beeg ,ctx ,_beb ;};if _cbgf ._cedfd .IsRelative (){ctx .X =_gffe .X ;
};if _cbgf ._cedfd .IsAbsolute (){return _beeg ,_gffe ,nil ;};return _beeg ,ctx ,nil ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_bcdd *Creator )RotateDeg (angleDeg int64 )error {_efe :=_bcdd .getActivePage ();if _efe ==nil {_f .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _gb .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_f .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _gb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _fcag int64 ;if _efe .Rotate !=nil {_fcag =*(_efe .Rotate );};_fcag +=angleDeg ;_efe .Rotate =&_fcag ;return nil ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_cbfa :_b .Max (_b .Min (c ,1.0),0.0),_bbc :_b .Max (_b .Min (m ,1.0),0.0),_fcg :_b .Max (_b .Min (y ,1.0),0.0),_aedf :_b .Max (_b .Min (k ,1.0),0.0)};};

// AppendCurve appends a Bezier curve to the filled curve.
func (_bccg *FilledCurve )AppendCurve (curve _a .CubicBezierCurve )*FilledCurve {_bccg ._cddd =append (_bccg ._cddd ,curve );return _bccg ;};func _gfb (_bggd ,_eeb *_df .PdfPageResources )error {_deg ,_ :=_bggd .GetColorspaces ();if _deg !=nil &&len (_deg .Colorspaces )> 0{for _fbb ,_abg :=range _deg .Colorspaces {_cfaf :=*_ga .MakeName (_fbb );
if _eeb .HasColorspaceByName (_cfaf ){continue ;};_ebc :=_eeb .SetColorspaceByName (_cfaf ,_abg );if _ebc !=nil {return _ebc ;};};};return nil ;};

// NewCurvePolygon creates a new curve polygon.
func (_gdc *Creator )NewCurvePolygon (rings [][]_a .CubicBezierCurve )*CurvePolygon {return _cgaaa (rings );};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_ecaf *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_ecaf ._acbe =textOverflow };

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_gbcg *Table )SetPos (x ,y float64 ){_gbcg ._cbgc =PositionAbsolute ;_gbcg ._begd =x ;_gbcg ._fcfg =y ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_ccbd *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_ccbd ._fae =alignment };

// Add adds a new line with the default style to the table of contents.
func (_afgg *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_cadc :=_afgg .AddLine (_fefaa (TextChunk {Text :number ,Style :_afgg ._fagee },TextChunk {Text :title ,Style :_afgg ._befac },TextChunk {Text :page ,Style :_afgg ._afaa },level ,_afgg ._eagead ));
if _cadc ==nil {return nil ;};_bfba :=&_afgg ._eebef ;_cadc .SetMargins (_bfba .Left ,_bfba .Right ,_bfba .Top ,_bfba .Bottom );_cadc .SetLevelOffset (_afgg ._egfb );_cadc .Separator .Text =_afgg ._acdeg ;_cadc .Separator .Style =_afgg ._fbga ;return _cadc ;
};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_bcdc *Creator )SetPageLabels (pageLabels _ga .PdfObject ){_bcdc ._fdca =pageLabels };

// Notes returns the notes section of the invoice as a title-content pair.
func (_bafc *Invoice )Notes ()(string ,string ){return _bafc ._fgge [0],_bafc ._fgge [1]};

// SetStyleRight sets border style for right side.
func (_deb *border )SetStyleRight (style CellBorderStyle ){_deb ._gdge =style };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// Invoice represents a configurable invoice template.
type Invoice struct{_eaaf string ;_dggb *Image ;_gdeg *InvoiceAddress ;_beef *InvoiceAddress ;_bbga string ;_gfea [2]*InvoiceCell ;_aee [2]*InvoiceCell ;_beefc [2]*InvoiceCell ;_efgcg [][2]*InvoiceCell ;_bgdg []*InvoiceCell ;_cbad [][]*InvoiceCell ;_agegec [2]*InvoiceCell ;
_cdb [2]*InvoiceCell ;_edfd [][2]*InvoiceCell ;_fgge [2]string ;_edfda [2]string ;_bcgd [][2]string ;_dfaef TextStyle ;_beab TextStyle ;_fdea TextStyle ;_cgdc TextStyle ;_bdacg TextStyle ;_abag TextStyle ;_afce TextStyle ;_gggb InvoiceCellProps ;_gaffd InvoiceCellProps ;
_aegde InvoiceCellProps ;_dfgf InvoiceCellProps ;_ecgeb Positioning ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_aefa *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aefd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fgbg ,_cbge :=_aefd .setOpacity (_aefa ._gcbf ,_aefa ._fgb );if _cbge !=nil {return nil ,ctx ,_cbge ;
};_agcbb :=_aefa ._gcff ;_agcbb .FillEnabled =_agcbb .FillColor !=nil ;var (_fagf =ctx .PageHeight ;_fea =_agcbb .Curves ;_ecga =make ([]_a .CubicBezierCurve ,0,len (_agcbb .Curves )););for _bcgdb :=range _agcbb .Curves {_faea :=_fea [_bcgdb ];_faea .P0 .Y =_fagf -_faea .P0 .Y ;
_faea .P1 .Y =_fagf -_faea .P1 .Y ;_faea .P2 .Y =_fagf -_faea .P2 .Y ;_faea .P3 .Y =_fagf -_faea .P3 .Y ;_ecga =append (_ecga ,_faea );};_agcbb .Curves =_ecga ;defer func (){_agcbb .Curves =_fea }();_dadae ,_ ,_cbge :=_agcbb .Draw (_fgbg );if _cbge !=nil {return nil ,ctx ,_cbge ;
};if _cbge =_aefd .addContentsByString (string (_dadae ));_cbge !=nil {return nil ,ctx ,_cbge ;};return []*Block {_aefd },ctx ,nil ;};

// Width returns the current page width.
func (_edae *Creator )Width ()float64 {return _edae ._fdad };func _ebaf (_daag Color )_df .PdfColor {if _daag ==nil {_daag =ColorBlack ;};switch _cbcf :=_daag .(type ){case cmykColor :return _df .NewPdfColorDeviceCMYK (_cbcf ._cbfa ,_cbcf ._bbc ,_cbcf ._fcg ,_cbcf ._aedf );
};return _df .NewPdfColorDeviceRGB (_daag .ToRGB ());};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_adff *Invoice )Terms ()(string ,string ){return _adff ._edfda [0],_adff ._edfda [1]};

// Height returns the current page height.
func (_bdbde *Creator )Height ()float64 {return _bdbde ._bea };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_ecea *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abccc ,_cda :=_bfeg .setOpacity (_ecea ._eddg ,_ecea ._gcec );if _cda !=nil {return nil ,ctx ,_cda ;};_gbeg :=_ecea ._gfg ;
_gbeg .FillEnabled =_gbeg .FillColor !=nil ;_gbeg .BorderEnabled =_gbeg .BorderColor !=nil &&_gbeg .BorderWidth > 0;var (_agcb =ctx .PageHeight ;_efaga =_gbeg .Rings ;_ggbb =make ([][]_a .CubicBezierCurve ,0,len (_gbeg .Rings )););for _ ,_fbff :=range _efaga {_bcgc :=make ([]_a .CubicBezierCurve ,0,len (_fbff ));
for _ ,_afeg :=range _fbff {_ddgf :=_afeg ;_ddgf .P0 .Y =_agcb -_ddgf .P0 .Y ;_ddgf .P1 .Y =_agcb -_ddgf .P1 .Y ;_ddgf .P2 .Y =_agcb -_ddgf .P2 .Y ;_ddgf .P3 .Y =_agcb -_ddgf .P3 .Y ;_bcgc =append (_bcgc ,_ddgf );};_ggbb =append (_ggbb ,_bcgc );};_gbeg .Rings =_ggbb ;
defer func (){_gbeg .Rings =_efaga }();_geea ,_ ,_cda :=_gbeg .Draw (_abccc );if _cda !=nil {return nil ,ctx ,_cda ;};if _cda =_bfeg .addContentsByString (string (_geea ));_cda !=nil {return nil ,ctx ,_cda ;};return []*Block {_bfeg },ctx ,nil ;};

// SetBorderColor sets the border color.
func (_dbeb *CurvePolygon )SetBorderColor (color Color ){_dbeb ._gfg .BorderColor =_ebaf (color )};

// SetAnnotation sets a annotation on a TextChunk.
func (_gfcbf *TextChunk )SetAnnotation (annotation *_df .PdfAnnotation ){_gfcbf ._gadd =annotation };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_cbcde *Table )MultiColCell (colspan int )*TableCell {return _cbcde .MultiCell (1,colspan )};func _eabc (_agga ,_adagg TextStyle )*Invoice {_gcab :=&Invoice {_eaaf :"\u0049N\u0056\u004f\u0049\u0043\u0045",_bbga :"\u002c\u0020",_dfaef :_agga ,_beab :_adagg };
_gcab ._beef =&InvoiceAddress {Separator :_gcab ._bbga };_gcab ._gdeg =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gcab ._bbga };_fff :=ColorRGBFrom8bit (245,245,245);_fdbd :=ColorRGBFrom8bit (155,155,155);_gcab ._fdea =_adagg ;
_gcab ._fdea .Color =_fdbd ;_gcab ._fdea .FontSize =20;_gcab ._cgdc =_agga ;_gcab ._bdacg =_adagg ;_gcab ._abag =_agga ;_gcab ._afce =_adagg ;_gcab ._gggb =_gcab .NewCellProps ();_gcab ._gggb .BackgroundColor =_fff ;_gcab ._gggb .TextStyle =_adagg ;_gcab ._gaffd =_gcab .NewCellProps ();
_gcab ._gaffd .TextStyle =_adagg ;_gcab ._gaffd .BackgroundColor =_fff ;_gcab ._gaffd .BorderColor =_fff ;_gcab ._aegde =_gcab .NewCellProps ();_gcab ._aegde .BorderColor =_fff ;_gcab ._aegde .BorderSides =[]CellBorderSide {CellBorderSideBottom };_gcab ._aegde .Alignment =CellHorizontalAlignmentRight ;
_gcab ._dfgf =_gcab .NewCellProps ();_gcab ._dfgf .Alignment =CellHorizontalAlignmentRight ;_gcab ._gfea =[2]*InvoiceCell {_gcab .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gcab ._gggb ),_gcab .newCell ("",_gcab ._gggb )};
_gcab ._aee =[2]*InvoiceCell {_gcab .newCell ("\u0044\u0061\u0074\u0065",_gcab ._gggb ),_gcab .newCell ("",_gcab ._gggb )};_gcab ._beefc =[2]*InvoiceCell {_gcab .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gcab ._gggb ),_gcab .newCell ("",_gcab ._gggb )};
_gcab ._agegec =[2]*InvoiceCell {_gcab .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gcab ._dfgf ),_gcab .newCell ("",_gcab ._dfgf )};_acge :=_gcab ._dfgf ;_acge .TextStyle =_adagg ;_acge .BackgroundColor =_fff ;_acge .BorderColor =_fff ;
_gcab ._cdb =[2]*InvoiceCell {_gcab .newCell ("\u0054\u006f\u0074a\u006c",_acge ),_gcab .newCell ("",_acge )};_gcab ._fgge =[2]string {"\u004e\u006f\u0074e\u0073",""};_gcab ._edfda =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_gcab ._bgdg =[]*InvoiceCell {_gcab .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gcab .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gcab .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gcab .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gcab ;};func (_gcecd *Invoice )generateInformationBlocks (_fffg DrawContext )([]*Block ,DrawContext ,error ){_gafff :=_cabf (_gcecd ._dfaef );_gafff .SetMargins (0,0,0,20);_ebda :=_gcecd .drawAddress (_gcecd ._beef );_ebda =append (_ebda ,_gafff );
_ebda =append (_ebda ,_gcecd .drawAddress (_gcecd ._gdeg )...);_dcaee :=_ddf ();for _ ,_def :=range _ebda {_dcaee .Add (_def );};_efaf :=_gcecd .drawInformation ();_dgdcfb :=_gaca (2);_dgdcfb .SetMargins (0,0,25,0);_ccdd :=_dgdcfb .NewCell ();_ccdd .SetIndent (0);
_ccdd .SetContent (_dcaee );_ccdd =_dgdcfb .NewCell ();_ccdd .SetContent (_efaf );return _dgdcfb .GeneratePageBlocks (_fffg );};

// SetBorderWidth sets the border width.
func (_ecbc *Polygon )SetBorderWidth (borderWidth float64 ){_ecbc ._bagc .BorderWidth =borderWidth };

// SetLineHeight sets the line height (1.0 default).
func (_ded *Paragraph )SetLineHeight (lineheight float64 ){_ded ._ffg =lineheight };

// SetSubtotal sets the subtotal of the invoice.
func (_ggdg *Invoice )SetSubtotal (value string ){_ggdg ._agegec [1].Value =value };

// Inline returns whether the inline mode of the division is active.
func (_fbgb *Division )Inline ()bool {return _fbgb ._cbdd };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_edfc *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbbc :=_edfc ;if _edfc ._ggafc {_gbbc =_edfc .clone ();};return _eecb (_gbbc ,ctx );};

// NewInvoice returns an instance of an empty invoice.
func (_geee *Creator )NewInvoice ()*Invoice {_dbdba :=_geee .NewTextStyle ();_dbdba .Font =_geee ._bfb ;return _eabc (_geee .NewTextStyle (),_dbdba );};func (_efcaf *List )tableHeight (_abdbc float64 )float64 {var _edfe float64 ;for _ ,_fbgdb :=range _efcaf ._eaga {switch _caea :=_fbgdb ._cfec .(type ){case *Paragraph :_dddc :=_caea ;
if _dddc ._bbdf {_dddc .SetWidth (_abdbc );};_edfe +=_dddc .Height ()+_dddc ._aaec .Bottom +_dddc ._aaec .Bottom ;_edfe +=0.5*_dddc ._dgda *_dddc ._ffg ;case *StyledParagraph :_gggbb :=_caea ;if _gggbb ._gafc {_gggbb .SetWidth (_abdbc );};_edfe +=_gggbb .Height ()+_gggbb ._gaaa .Top +_gggbb ._gaaa .Bottom ;
_edfe +=0.5*_gggbb .getTextHeight ();default:_edfe +=_fbgdb ._cfec .Height ();};};return _edfe ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_ffaf *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ffaf ._bdbd .Left ,_ffaf ._bdbd .Right ,_ffaf ._bdbd .Top ,_ffaf ._bdbd .Bottom ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_begc *_a .Polyline ;_dacg float64 ;};

// SetDueDate sets the due date of the invoice.
func (_bbge *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_bbge ._beefc [1].Value =dueDate ;return _bbge ._beefc [0],_bbge ._beefc [1];};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_cfbce *Paragraph )SetMaxLines (maxLines int ){_cfbce ._eecf =maxLines ;_cfbce .wrapText ()};

// Level returns the indentation level of the TOC line.
func (_daefb *TOCLine )Level ()uint {return _daefb ._afdb };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_bfbg *Invoice )NoteStyle ()TextStyle {return _bfbg ._abag };

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_gcca :_b .Max (_b .Min (r ,1.0),0.0),_adab :_b .Max (_b .Min (g ,1.0),0.0),_ccfe :_b .Max (_b .Min (b ,1.0),0.0)};};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_cccac []*TextChunk ;_fee TextStyle ;_fgffa TextStyle ;_ggbd TextAlignment ;_bgdc TextVerticalAlignment ;_gccd float64 ;_gafc bool ;_cgfgd float64 ;_gbeb bool ;_acbe TextOverflow ;_gcbgd float64 ;_gaaa Margins ;_becgb Positioning ;
_bbgg float64 ;_gfcd float64 ;_cgee float64 ;_cabcf float64 ;_fbdf [][]*TextChunk ;_gfbfg func (_ggcb *StyledParagraph ,_bagd DrawContext );};

// Width returns the width of the Paragraph.
func (_cbfgb *Paragraph )Width ()float64 {if _cbfgb ._bbdf &&int (_cbfgb ._adgge )> 0{return _cbfgb ._adgge ;};return _cbfgb .getTextWidth ()/1000.0;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_fgfa *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_badg ,_ ,_dfd :=_fgfa .draw ("");if _dfd !=nil {return nil ,ctx ,_dfd ;};_dfd =_fcb .addContentsByString (string (_badg ));
if _dfd !=nil {return nil ,ctx ,_dfd ;};return []*Block {_fcb },ctx ,nil ;};func _bcbfb (_cagbfc []_a .Point )*Polyline {return &Polyline {_begc :&_a .Polyline {Points :_cagbfc ,LineColor :_df .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_dacg :1.0};};


// SetLineHeight sets the line height (1.0 default).
func (_gbebd *StyledParagraph )SetLineHeight (lineheight float64 ){_gbebd ._gccd =lineheight };func _aaaag (_dgac *_df .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_dgac ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_ead rune ;_ggag []error ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_gedfa *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fefe []*Block ;_bge :=ctx ;if _gedfa ._ecfb .IsRelative (){ctx .X +=_gedfa ._ccbe .Left ;ctx .Y +=_gedfa ._ccbe .Top ;ctx .Width -=_gedfa ._ccbe .Left +_gedfa ._ccbe .Right ;
ctx .Height -=_gedfa ._ccbe .Top +_gedfa ._ccbe .Bottom ;};ctx .Inline =_gedfa ._cbdd ;_bfce :=ctx ;_cbeg :=ctx ;var _gcee float64 ;for _ ,_babf :=range _gedfa ._eaag {if ctx .Inline {if (ctx .X -_bfce .X )+_babf .Width ()<=ctx .Width {ctx .Y =_cbeg .Y ;
ctx .Height =_cbeg .Height ;}else {ctx .X =_bfce .X ;ctx .Width =_bfce .Width ;_cbeg .Y +=_gcee ;_cbeg .Height -=_gcee ;_gcee =0;};};_cadad ,_ecgf ,_affa :=_babf .GeneratePageBlocks (ctx );if _affa !=nil {_f .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_affa );
return nil ,ctx ,_affa ;};if len (_cadad )< 1{continue ;};if len (_fefe )> 0{_fefe [len (_fefe )-1].mergeBlocks (_cadad [0]);_fefe =append (_fefe ,_cadad [1:]...);}else {_fefe =append (_fefe ,_cadad [0:]...);};if ctx .Inline {if ctx .Page !=_ecgf .Page {_bfce .Y =ctx .Margins .Top ;
_bfce .Height =ctx .PageHeight -ctx .Margins .Top ;_cbeg .Y =_bfce .Y ;_cbeg .Height =_bfce .Height ;_gcee =_ecgf .Height -_bfce .Height ;}else {if _cdac :=ctx .Height -_ecgf .Height ;_cdac > _gcee {_gcee =_cdac ;};};}else {_ecgf .X =ctx .X ;};ctx =_ecgf ;
};ctx .Inline =_bge .Inline ;if _gedfa ._ecfb .IsRelative (){ctx .X =_bge .X ;};if _gedfa ._ecfb .IsAbsolute (){return _fefe ,_bge ,nil ;};return _fefe ,ctx ,nil ;};

// Reset removes all the text chunks the paragraph contains.
func (_dgfb *StyledParagraph )Reset (){_dgfb ._cccac =[]*TextChunk {}};func _befd (_gaed ,_ecaa ,_gagb float64 )(_cgge ,_bdga ,_dcgc ,_ebg float64 ){if _gagb ==0{return 0,0,_gaed ,_ecaa ;};_bcebc :=_a .Path {Points :[]_a .Point {_a .NewPoint (0,0).Rotate (_gagb ),_a .NewPoint (_gaed ,0).Rotate (_gagb ),_a .NewPoint (0,_ecaa ).Rotate (_gagb ),_a .NewPoint (_gaed ,_ecaa ).Rotate (_gagb )}}.GetBoundingBox ();
return _bcebc .X ,_bcebc .Y ,_bcebc .Width ,_bcebc .Height ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// NewList creates a new list.
func (_dge *Creator )NewList ()*List {return _aedfb (_dge .NewTextStyle ())};func _dedd (_gcge string ,_gbgfg ,_egcce TextStyle )*TOC {_defbg :=_egcce ;_defbg .FontSize =14;_cede :=_cabf (_defbg );_cede .SetEnableWrap (true );_cede .SetTextAlignment (TextAlignmentLeft );
_cede .SetMargins (0,0,0,5);_bdebb :=_cede .Append (_gcge );_bdebb .Style =_defbg ;return &TOC {_fcda :_cede ,_agcg :[]*TOCLine {},_fagee :_gbgfg ,_befac :_gbgfg ,_fbga :_gbgfg ,_afaa :_gbgfg ,_acdeg :"\u002e",_egfb :10,_eebef :Margins {0,0,2,2},_ccgc :PositionRelative ,_eagead :_gbgfg ,_becc :true };
};func _fccf (_beec ,_eefg ,_geff string ,_geeae uint ,_aadca TextStyle )*TOCLine {return _fefaa (TextChunk {Text :_beec ,Style :_aadca },TextChunk {Text :_eefg ,Style :_aadca },TextChunk {Text :_geff ,Style :_aadca },_geeae ,_aadca );};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_dbge *Division )Add (d VectorDrawable )error {switch _cacc :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image :case containerDrawable :_baff ,_babd :=_cacc .ContainerComponent (_dbge );if _babd !=nil {return _babd ;};_fced ,_feda :=_baff .(VectorDrawable );
if !_feda {return _gd .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_baff );
};d =_fced ;default:return _gb .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_dbge ._eaag =append (_dbge ._eaag ,d );return nil ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_dcaed *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_caba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eega :=_a .Circle {X :_dcaed ._aggf -_dcaed ._cfag /2,Y :ctx .PageHeight -_dcaed ._gbd -_dcaed ._aegf /2,Width :_dcaed ._cfag ,Height :_dcaed ._aegf ,Opacity :1.0,BorderWidth :_dcaed ._efcd };
if _dcaed ._fcdb !=nil {_eega .FillEnabled =true ;_eega .FillColor =_ebaf (_dcaed ._fcdb );};if _dcaed ._ggdc !=nil {_eega .BorderEnabled =true ;_eega .BorderColor =_ebaf (_dcaed ._ggdc );_eega .BorderWidth =_dcaed ._efcd ;};_geef ,_ ,_fdce :=_eega .Draw ("");
if _fdce !=nil {return nil ,ctx ,_fdce ;};_fdce =_caba .addContentsByString (string (_geef ));if _fdce !=nil {return nil ,ctx ,_fdce ;};return []*Block {_caba },ctx ,nil ;};

// Add adds a new Drawable to the chapter.
func (_afb *Chapter )Add (d Drawable )error {if Drawable (_afb )==d {_f .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _gb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _ccf :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_afb ._eef =append (_afb ._eef ,d );case containerDrawable :_degf ,_eaae :=_ccf .ContainerComponent (_afb );if _eaae !=nil {return _eaae ;};_afb ._eef =append (_afb ._eef ,_degf );
default:_f .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _gb .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_efff *Invoice )SetTitleStyle (style TextStyle ){_efff ._fdea =style };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_agbed *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_bgcg ,_fgcfd :=_agbed .Wrap (width );if _fgcfd !=nil {return nil ,_fgcfd ;};_decab :=int (height /_agbed .Style .FontSize );if _decab >=len (_bgcg ){return nil ,nil ;};_ddge :="\u000a";
_agbed .Text =_dc .Replace (_dc .Join (_bgcg [:_decab ],"\u0020"),_ddge +"\u0020",_ddge ,-1);_dfaa :=_dc .Replace (_dc .Join (_bgcg [_decab :],"\u0020"),_ddge +"\u0020",_ddge ,-1);return NewTextChunk (_dfaa ,_agbed .Style ),nil ;};

// SetStyleTop sets border style for top side.
func (_cefe *border )SetStyleTop (style CellBorderStyle ){_cefe ._edf =style };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_afba :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_f .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _afba ;
};var _fecd ,_fcgg ,_ffec int ;if len (hexStr )==4{var _feg ,_bfag ,_ggd int ;_eddd ,_dcac :=_gd .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_feg ,&_bfag ,&_ggd );if _dcac !=nil {_f .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_dcac );
return _afba ;};if _eddd !=3{_f .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _afba ;};_fecd =_feg *16+_feg ;_fcgg =_bfag *16+_bfag ;_ffec =_ggd *16+_ggd ;}else {_bgf ,_cgc :=_gd .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fecd ,&_fcgg ,&_ffec );
if _cgc !=nil {_f .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _afba ;};if _bgf !=3{_f .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bgf );
return _afba ;};};_bag :=float64 (_fecd )/255.0;_ecae :=float64 (_fcgg )/255.0;_cdg :=float64 (_ffec )/255.0;_afba ._gcca =_bag ;_afba ._adab =_ecae ;_afba ._ccfe =_cdg ;return _afba ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_adf *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_egb ,_ ,_ca :=d .GeneratePageBlocks (ctx );if _ca !=nil {return _ca ;};if len (_egb )!=1{return _gb .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_gbf :=range _egb {if _acd :=_adf .mergeBlocks (_gbf );_acd !=nil {return _acd ;};};return nil ;};func _fcba (_ddgb *_df .Image )(*Image ,error ){_baffe :=float64 (_ddgb .Width );_bbbb :=float64 (_ddgb .Height );return &Image {_ffdb :_ddgb ,_afca :_baffe ,_gcgg :_bbbb ,_ggfg :_baffe ,_cbce :_bbbb ,_abdb :0,_dcade :1.0,_fgfe :PositionRelative },nil ;
};

// NewImage create a new image from a unidoc image (model.Image).
func (_acfa *Creator )NewImage (img *_df .Image )(*Image ,error ){return _fcba (img )};

// NewFilledCurve returns a instance of filled curve.
func (_dagc *Creator )NewFilledCurve ()*FilledCurve {return _cbbe ()};func (_gaf *Creator )setActivePage (_badc *_df .PdfPage ){_gaf ._baf =_badc };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_cecf *Invoice )SetNoteStyle (style TextStyle ){_cecf ._abag =style };

// SetAngle sets Image rotation angle in degrees.
func (_fcgb *Image )SetAngle (angle float64 ){_fcgb ._abdb =angle };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ccceg *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fafb :=ctx ;_adggg ,ctx ,_efgac :=_ccceg ._fcda .GeneratePageBlocks (ctx );if _efgac !=nil {return _adggg ,ctx ,_efgac ;};for _ ,_dedg :=range _ccceg ._agcg {_bfgd :=_dedg ._babaa ;
if !_ccceg ._becc {_dedg ._babaa =0;};_abda ,_ceefe ,_fegb :=_dedg .GeneratePageBlocks (ctx );_dedg ._babaa =_bfgd ;if _fegb !=nil {return _adggg ,ctx ,_fegb ;};if len (_abda )< 1{continue ;};_adggg [len (_adggg )-1].mergeBlocks (_abda [0]);_adggg =append (_adggg ,_abda [1:]...);
ctx =_ceefe ;};if _ccceg ._ccgc .IsRelative (){ctx .X =_fafb .X ;};if _ccceg ._ccgc .IsAbsolute (){return _adggg ,_fafb ,nil ;};return _adggg ,ctx ,nil ;};

// SetLogo sets the logo of the invoice.
func (_fceg *Invoice )SetLogo (logo *Image ){_fceg ._dggb =logo };

// SetLineWidth sets the line width.
func (_fefca *Polyline )SetLineWidth (lineWidth float64 ){_fefca ._begc .LineWidth =lineWidth };

// SetBorder sets the cell's border style.
func (_bdc *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_bdc ._agbe =CellBorderStyleSingle ;_bdc ._egfce =width ;_bdc ._geag =CellBorderStyleSingle ;_bdc ._gcdd =width ;
_bdc ._becde =CellBorderStyleSingle ;_bdc ._ccbea =width ;_bdc ._fada =CellBorderStyleSingle ;_bdc ._cfaac =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_bdc ._agbe =CellBorderStyleDouble ;_bdc ._egfce =width ;_bdc ._geag =CellBorderStyleDouble ;
_bdc ._gcdd =width ;_bdc ._becde =CellBorderStyleDouble ;_bdc ._ccbea =width ;_bdc ._fada =CellBorderStyleDouble ;_bdc ._cfaac =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_bdc ._agbe =style ;
_bdc ._egfce =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_bdc ._geag =style ;_bdc ._gcdd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_bdc ._becde =style ;
_bdc ._ccbea =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_bdc ._fada =style ;_bdc ._cfaac =width ;};};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_efee *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfge :=ctx ;var _bbfd []*Block ;_ecce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _efee ._eeea .IsRelative (){ctx .X +=_efee ._aaec .Left ;ctx .Y +=_efee ._aaec .Top ;
ctx .Width -=_efee ._aaec .Left +_efee ._aaec .Right ;ctx .Height -=_efee ._aaec .Top +_efee ._aaec .Bottom ;_efee .SetWidth (ctx .Width );if _efee .Height ()> ctx .Height {_bbfd =append (_bbfd ,_ecce );_ecce =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_efga :=ctx ;_efga .Y =ctx .Margins .Top ;_efga .X =ctx .Margins .Left +_efee ._aaec .Left ;_efga .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_efee ._aaec .Bottom ;_efga .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_efee ._aaec .Left -_efee ._aaec .Right ;
ctx =_efga ;};}else {if int (_efee ._adgge )<=0{_efee .SetWidth (_efee .getTextWidth ());};ctx .X =_efee ._eege ;ctx .Y =_efee ._facc ;};ctx ,_ddeee :=_ccbda (_ecce ,_efee ,ctx );if _ddeee !=nil {_f .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ddeee );
return nil ,ctx ,_ddeee ;};_bbfd =append (_bbfd ,_ecce );if _efee ._eeea .IsRelative (){ctx .X -=_efee ._aaec .Left ;ctx .Width =_cfge .Width ;return _bbfd ,ctx ,nil ;};return _bbfd ,_cfge ,nil ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_df .PdfPage )(*Block ,error ){_e :=&Block {};_db ,_gce :=page .GetAllContentStreams ();if _gce !=nil {return nil ,_gce ;};_ab :=_cd .NewContentStreamParser (_db );_ff ,_gce :=_ab .Parse ();if _gce !=nil {return nil ,_gce ;
};_ff .WrapIfNeeded ();_e ._gea =_ff ;if page .Resources !=nil {_e ._da =page .Resources ;}else {_e ._da =_df .NewPdfPageResources ();};_dba ,_gce :=page .GetMediaBox ();if _gce !=nil {return nil ,_gce ;};if _dba .Llx !=0||_dba .Lly !=0{_e .translate (-_dba .Llx ,_dba .Lly );
};_e ._fc =_dba .Urx -_dba .Llx ;_e ._gca =_dba .Ury -_dba .Lly ;if page .Rotate !=nil {_e ._cb =-float64 (*page .Rotate );};return _e ,nil ;};func (_bdef *Invoice )generateLineBlocks (_ecgc DrawContext )([]*Block ,DrawContext ,error ){_adgg :=_gaca (len (_bdef ._bgdg ));
_adgg .SetMargins (0,0,25,0);for _ ,_fefa :=range _bdef ._bgdg {_dbegb :=_cabf (_fefa .TextStyle );_dbegb .SetMargins (0,0,1,0);_dbegb .Append (_fefa .Value );_adbf :=_adgg .NewCell ();_adbf .SetHorizontalAlignment (_fefa .Alignment );_adbf .SetBackgroundColor (_fefa .BackgroundColor );
_bdef .setCellBorder (_adbf ,_fefa );_adbf .SetContent (_dbegb );};for _ ,_aac :=range _bdef ._cbad {for _ ,_fbec :=range _aac {_cccde :=_cabf (_fbec .TextStyle );_cccde .SetMargins (0,0,3,2);_cccde .Append (_fbec .Value );_bdeg :=_adgg .NewCell ();_bdeg .SetHorizontalAlignment (_fbec .Alignment );
_bdeg .SetBackgroundColor (_fbec .BackgroundColor );_bdef .setCellBorder (_bdeg ,_fbec );_bdeg .SetContent (_cccde );};};return _adgg .GeneratePageBlocks (_ecgc );};

// SetBorderWidth sets the border width.
func (_bga *CurvePolygon )SetBorderWidth (borderWidth float64 ){_bga ._gfg .BorderWidth =borderWidth };func (_abga *FilledCurve )draw (_ffbg string )([]byte ,*_df .PdfRectangle ,error ){_agdb :=_a .NewCubicBezierPath ();for _ ,_gcg :=range _abga ._cddd {_agdb =_agdb .AppendCurve (_gcg );
};creator :=_cd .NewContentCreator ();creator .Add_q ();if _abga .FillEnabled &&_abga ._ecge !=nil {creator .SetNonStrokingColor (_ebaf (_abga ._ecge ));};if _abga .BorderEnabled {if _abga ._faf !=nil {creator .SetStrokingColor (_ebaf (_abga ._faf ));};
creator .Add_w (_abga .BorderWidth );};if len (_ffbg )> 1{creator .Add_gs (_ga .PdfObjectName (_ffbg ));};_a .DrawBezierPathWithCreator (_agdb ,creator );creator .Add_h ();if _abga .FillEnabled &&_abga .BorderEnabled {creator .Add_B ();}else if _abga .FillEnabled {creator .Add_f ();
}else if _abga .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_bagf :=_agdb .GetBoundingBox ();if _abga .BorderEnabled {_bagf .Height +=_abga .BorderWidth ;_bagf .Width +=_abga .BorderWidth ;_bagf .X -=_abga .BorderWidth /2;_bagf .Y -=_abga .BorderWidth /2;
};_edad :=&_df .PdfRectangle {};_edad .Llx =_bagf .X ;_edad .Lly =_bagf .Y ;_edad .Urx =_bagf .X +_bagf .Width ;_edad .Ury =_bagf .Y +_bagf .Height ;return creator .Bytes (),_edad ,nil ;};

// Angle returns the block rotation angle in degrees.
func (_ec *Block )Angle ()float64 {return _ec ._cb };func _gff (_bcfa []byte )(*Image ,error ){_edcb :=_ge .NewReader (_bcfa );_bcca ,_fedac :=_df .ImageHandling .Read (_edcb );if _fedac !=nil {_f .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fedac );
return nil ,_fedac ;};return _fcba (_bcca );};

// SetBorderColor sets the border color.
func (_gdce *Ellipse )SetBorderColor (col Color ){_gdce ._ggdc =col };

// Lines returns all the lines the table of contents has.
func (_gfdbe *TOC )Lines ()[]*TOCLine {return _gfdbe ._agcg };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_gede *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_ffab *_df .PdfWriter )error ){_gede ._beff =pdfWriterAccessFunc ;};

// SetLineColor sets the line color.
func (_efdc *Polyline )SetLineColor (color Color ){_efdc ._begc .LineColor =_ebaf (color )};

// NewSubchapter creates a new child chapter with the specified title.
func (_dgf *Chapter )NewSubchapter (title string )*Chapter {_caec :=_adfd (_dgf ._bbf ._cdga );_caec .FontSize =14;_dgf ._cfe ++;_ddgd :=_bde (_dgf ,_dgf ._daee ,_dgf ._fgf ,title ,_dgf ._cfe ,_caec );_dgf .Add (_ddgd );return _ddgd ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_aggf float64 ;_gbd float64 ;_cfag float64 ;_aegf float64 ;_fcdb Color ;_ggdc Color ;_efcd float64 ;};

// SetBorderWidth sets the border width.
func (_cabd *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_cabd ._gcff .BorderWidth =borderWidth ;};

// SetRowHeight sets the height for a specified row.
func (_fgbd *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_fgbd ._gbec ){return _gb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fgbd ._gbec [row -1]=h ;return nil ;
};func _aedfb (_fdda TextStyle )*List {return &List {_edab :TextChunk {Text :"\u2022\u0020",Style :_fdda },_dfgb :0,_fecfb :true ,_gfcb :PositionRelative ,_cddda :_fdda };};

// Width returns the cell's width based on the input draw context.
func (_gfdb *TableCell )Width (ctx DrawContext )float64 {_bgbbg :=float64 (0.0);for _gbagc :=0;_gbagc < _gfdb ._fcgce ;_gbagc ++{_bgbbg +=_gfdb ._gccda ._gegf [_gfdb ._bbdb +_gbagc -1];};_aedgg :=ctx .Width *_bgbbg ;return _aedgg ;};

// Width returns Image's document width.
func (_bfff *Image )Width ()float64 {return _bfff ._ggfg };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_cddd []_a .CubicBezierCurve ;FillEnabled bool ;_ecge Color ;BorderEnabled bool ;BorderWidth float64 ;_faf Color ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_fdeb *TOCLine )LevelOffset ()float64 {return _fdeb ._bada };

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_afab *List )Width ()float64 {return 0};var PPMM =float64 (72*1.0/25.4);

// SetNumber sets the number of the invoice.
func (_bged *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_bged ._gfea [1].Value =number ;return _bged ._gfea [0],_bged ._gfea [1];};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetHeading sets the text and the style of the heading of the TOC component.
func (_bgge *TOC )SetHeading (text string ,style TextStyle ){_ggeb :=_bgge .Heading ();_ggeb .Reset ();_fagd :=_ggeb .Append (text );_fagd .Style =style ;};func (_acbb *Image )makeXObject ()error {_acdf :=_acbb ._cbfab ;if _acdf ==nil {_acdf =_ga .NewFlateEncoder ();
};_daff ,_gfbc :=_df .NewXObjectImageFromImage (_acbb ._ffdb ,nil ,_acdf );if _gfbc !=nil {_f .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gfbc );
return _gfbc ;};_acbb ._gcgc =_daff ;return nil ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_fgce *Image )SetPos (x ,y float64 ){_fgce ._fgfe =PositionAbsolute ;_fgce ._gaabg =x ;_fgce ._edac =y ;};func _dbce (_aegd VectorDrawable ,_dfed float64 )float64 {switch _fecf :=_aegd .(type ){case *Paragraph :if _fecf ._bbdf {_fecf .SetWidth (_dfed );
};return _fecf .Height ()+_fecf ._aaec .Top +_fecf ._aaec .Bottom ;case *StyledParagraph :if _fecf ._gafc {_fecf .SetWidth (_dfed );};return _fecf .Height ()+_fecf ._gaaa .Top +_fecf ._gaaa .Bottom ;case marginDrawable :_ ,_ ,_cfab ,_aefc :=_fecf .GetMargins ();
return _fecf .Height ()+_cfab +_aefc ;default:return _fecf .Height ();};};

// GeneratePageBlocks implements drawable interface.
func (_ceee *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ffa :=_ceee ._cbab ;_cga :=ctx .PageHeight -_ceee ._adcb ;if _ceee ._gga !=nil {_fecc :=_a .Rectangle {Opacity :1.0,X :_ceee ._cbab ,Y :ctx .PageHeight -_ceee ._adcb -_ceee ._gbg ,Height :_ceee ._gbg ,Width :_ceee ._egg };
_fecc .FillEnabled =true ;_fecc .FillColor =_ebaf (_ceee ._gga );_fecc .BorderEnabled =false ;_adaa ,_ ,_gac :=_fecc .Draw ("");if _gac !=nil {return nil ,ctx ,_gac ;};_gac =_aeb .addContentsByString (string (_adaa ));if _gac !=nil {return nil ,ctx ,_gac ;
};};_fdf :=_ceee ._bcbad ;_dcc :=_ceee ._gdg ;_ebf :=_ceee ._eda ;_agaa :=_ceee ._ageb ;_gge :=_ceee ._bcbad ;if _ceee ._edf ==CellBorderStyleDouble {_gge +=2*_fdf ;};_bgcc :=_ceee ._gdg ;if _ceee ._fbba ==CellBorderStyleDouble {_bgcc +=2*_dcc ;};_dfe :=_ceee ._eda ;
if _ceee ._ccd ==CellBorderStyleDouble {_dfe +=2*_ebf ;};_dbg :=_ceee ._ageb ;if _ceee ._gdge ==CellBorderStyleDouble {_dbg +=2*_agaa ;};if _ceee ._bcbad !=0{_ecc :=_ffa ;_ced :=_cga ;if _ceee ._edf ==CellBorderStyleDouble {_ced -=_fdf ;_gfa :=_a .BasicLine {};
_gfa .X1 =_ecc -_gge /2;_gfa .Y1 =_ced +2*_fdf ;_gfa .X2 =_ecc +_ceee ._egg +_gge /2;_gfa .Y2 =_ced +2*_fdf ;_gfa .LineColor =_ebaf (_ceee ._cdf );_gfa .LineWidth =_ceee ._bcbad ;_gfa .LineStyle =_ceee .LineStyle ;_ffdd ,_ ,_egcf :=_gfa .Draw ("");if _egcf !=nil {return nil ,ctx ,_egcf ;
};_egcf =_aeb .addContentsByString (string (_ffdd ));if _egcf !=nil {return nil ,ctx ,_egcf ;};};_dec :=_a .BasicLine {LineWidth :_ceee ._bcbad ,Opacity :1.0,LineColor :_ebaf (_ceee ._cdf ),X1 :_ecc -_gge /2+(_dfe -_ceee ._eda ),Y1 :_ced ,X2 :_ecc +_ceee ._egg +_gge /2-(_dbg -_ceee ._ageb ),Y2 :_ced ,LineStyle :_ceee .LineStyle };
_dab ,_ ,_fdc :=_dec .Draw ("");if _fdc !=nil {return nil ,ctx ,_fdc ;};_fdc =_aeb .addContentsByString (string (_dab ));if _fdc !=nil {return nil ,ctx ,_fdc ;};};if _ceee ._gdg !=0{_bedg :=_ffa ;_abc :=_cga -_ceee ._gbg ;if _ceee ._fbba ==CellBorderStyleDouble {_abc +=_dcc ;
_gaad :=_a .BasicLine {LineWidth :_ceee ._gdg ,Opacity :1.0,LineColor :_ebaf (_ceee ._abfc ),X1 :_bedg -_bgcc /2,Y1 :_abc -2*_dcc ,X2 :_bedg +_ceee ._egg +_bgcc /2,Y2 :_abc -2*_dcc ,LineStyle :_ceee .LineStyle };_bdbe ,_ ,_fag :=_gaad .Draw ("");if _fag !=nil {return nil ,ctx ,_fag ;
};_fag =_aeb .addContentsByString (string (_bdbe ));if _fag !=nil {return nil ,ctx ,_fag ;};};_abbf :=_a .BasicLine {LineWidth :_ceee ._gdg ,Opacity :1.0,LineColor :_ebaf (_ceee ._abfc ),X1 :_bedg -_bgcc /2+(_dfe -_ceee ._eda ),Y1 :_abc ,X2 :_bedg +_ceee ._egg +_bgcc /2-(_dbg -_ceee ._ageb ),Y2 :_abc ,LineStyle :_ceee .LineStyle };
_cdec ,_ ,_adb :=_abbf .Draw ("");if _adb !=nil {return nil ,ctx ,_adb ;};_adb =_aeb .addContentsByString (string (_cdec ));if _adb !=nil {return nil ,ctx ,_adb ;};};if _ceee ._eda !=0{_adad :=_ffa ;_bce :=_cga ;if _ceee ._ccd ==CellBorderStyleDouble {_adad +=_ebf ;
_cfc :=_a .BasicLine {LineWidth :_ceee ._eda ,Opacity :1.0,LineColor :_ebaf (_ceee ._abgf ),X1 :_adad -2*_ebf ,Y1 :_bce +_dfe /2,X2 :_adad -2*_ebf ,Y2 :_bce -_ceee ._gbg -_dfe /2,LineStyle :_ceee .LineStyle };_cfgb ,_ ,_gbff :=_cfc .Draw ("");if _gbff !=nil {return nil ,ctx ,_gbff ;
};_gbff =_aeb .addContentsByString (string (_cfgb ));if _gbff !=nil {return nil ,ctx ,_gbff ;};};_dbfd :=_a .BasicLine {LineWidth :_ceee ._eda ,Opacity :1.0,LineColor :_ebaf (_ceee ._abgf ),X1 :_adad ,Y1 :_bce +_dfe /2-(_gge -_ceee ._bcbad ),X2 :_adad ,Y2 :_bce -_ceee ._gbg -_dfe /2+(_bgcc -_ceee ._gdg ),LineStyle :_ceee .LineStyle };
_dabd ,_ ,_dabc :=_dbfd .Draw ("");if _dabc !=nil {return nil ,ctx ,_dabc ;};_dabc =_aeb .addContentsByString (string (_dabd ));if _dabc !=nil {return nil ,ctx ,_dabc ;};};if _ceee ._ageb !=0{_dadd :=_ffa +_ceee ._egg ;_fefg :=_cga ;if _ceee ._gdge ==CellBorderStyleDouble {_dadd -=_agaa ;
_ceb :=_a .BasicLine {LineWidth :_ceee ._ageb ,Opacity :1.0,LineColor :_ebaf (_ceee ._gfc ),X1 :_dadd +2*_agaa ,Y1 :_fefg +_dbg /2,X2 :_dadd +2*_agaa ,Y2 :_fefg -_ceee ._gbg -_dbg /2,LineStyle :_ceee .LineStyle };_gbfg ,_ ,_ddee :=_ceb .Draw ("");if _ddee !=nil {return nil ,ctx ,_ddee ;
};_ddee =_aeb .addContentsByString (string (_gbfg ));if _ddee !=nil {return nil ,ctx ,_ddee ;};};_egf :=_a .BasicLine {LineWidth :_ceee ._ageb ,Opacity :1.0,LineColor :_ebaf (_ceee ._gfc ),X1 :_dadd ,Y1 :_fefg +_dbg /2-(_gge -_ceee ._bcbad ),X2 :_dadd ,Y2 :_fefg -_ceee ._gbg -_dbg /2+(_bgcc -_ceee ._gdg ),LineStyle :_ceee .LineStyle };
_fgg ,_ ,_cbf :=_egf .Draw ("");if _cbf !=nil {return nil ,ctx ,_cbf ;};_cbf =_aeb .addContentsByString (string (_fgg ));if _cbf !=nil {return nil ,ctx ,_cbf ;};};return []*Block {_aeb },ctx ,nil ;};func _bgfg (_baba string )(*Image ,error ){_gec ,_cfbe :=_gcf .Open (_baba );
if _cfbe !=nil {return nil ,_cfbe ;};defer _gec .Close ();_gdae ,_cfbe :=_df .ImageHandling .Read (_gec );if _cfbe !=nil {_f .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cfbe );
return nil ,_cfbe ;};return _fcba (_gdae );};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_cefg *List )Add (item VectorDrawable )(*TextChunk ,error ){_dcbf :=&listItem {_cfec :item ,_aegc :_cefg ._edab };switch _bgde :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _bgde ._fecfb {_bgde ._dfgb =15;};default:return nil ,_gb .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_cefg ._eaga =append (_cefg ._eaga ,_dcbf );return &_dcbf ._aegc ,nil ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_gfeg *Invoice )SetColumns (cols []*InvoiceCell ){_gfeg ._bgdg =cols };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_gcdf *StyledParagraph )Insert (index uint ,text string )*TextChunk {_afbg :=uint (len (_gcdf ._cccac ));if index > _afbg {index =_afbg ;};_bbcbb :=NewTextChunk (text ,_gcdf ._fee );_gcdf ._cccac =append (_gcdf ._cccac [:index ],append ([]*TextChunk {_bbcbb },_gcdf ._cccac [index :]...)...);
_gcdf .wrapText ();return _bbcbb ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_df .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// GetOptimizer returns current PDF optimizer.
func (_cccg *Creator )GetOptimizer ()_df .Optimizer {return _cccg ._cbfb };

// Scale scales Image by a constant factor, both width and height.
func (_dded *Image )Scale (xFactor ,yFactor float64 ){_dded ._ggfg =xFactor *_dded ._ggfg ;_dded ._cbce =yFactor *_dded ._cbce ;};func (_bcfdc *StyledParagraph )appendChunk (_fafa *TextChunk )*TextChunk {_bcfdc ._cccac =append (_bcfdc ._cccac ,_fafa );
_bcfdc .wrapText ();return _fafa ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_gfca *Creator )NewImageFromGoImage (goimg _d .Image )(*Image ,error ){return _cefc (goimg )};type rgbColor struct{_gcca ,_adab ,_ccfe float64 };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_eadb *Image )SetEncoder (encoder _ga .StreamEncoder ){_eadb ._cbfab =encoder };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_feca *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _feca ._beefc [0],_feca ._beefc [1]};func (_eag *Block )mergeBlocks (_de *Block )error {_efa :=_bcba (_eag ._gea ,_eag ._da ,_de ._gea ,_de ._da );if _efa !=nil {return _efa ;};for _ ,_aae :=range _de ._dd {_eag .AddAnnotation (_aae );
};return nil ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_edce *Creator )DrawFooter (drawFooterFunc func (_dda *Block ,_ccg FooterFunctionArgs )){_edce ._fdfd =drawFooterFunc ;};

// SetMargins sets the Paragraph's margins.
func (_bffb *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_bffb ._aaec .Left =left ;_bffb ._aaec .Right =right ;_bffb ._aaec .Top =top ;_bffb ._aaec .Bottom =bottom ;};

// Scale block by specified factors in the x and y directions.
func (_dgd *Block )Scale (sx ,sy float64 ){_cf :=_cd .NewContentCreator ().Scale (sx ,sy ).Operations ();*_dgd ._gea =append (*_cf ,*_dgd ._gea ...);_dgd ._gea .WrapIfNeeded ();_dgd ._fc *=sx ;_dgd ._gca *=sy ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_ggfge *Invoice )SetNoteHeadingStyle (style TextStyle ){_ggfge ._afce =style };

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};func _cabf (_faeab TextStyle )*StyledParagraph {return &StyledParagraph {_cccac :[]*TextChunk {},_fee :_faeab ,_fgffa :_aaaag (_faeab .Font ),_gccd :1.0,_ggbd :TextAlignmentLeft ,_gafc :true ,_gbeb :true ,_gcbgd :0,_cgee :1,_cabcf :1,_becgb :PositionRelative };
};func (_deggg *Table )clone ()*Table {_fdgf :=*_deggg ;_fdgf ._gbec =make ([]float64 ,len (_deggg ._gbec ));copy (_fdgf ._gbec ,_deggg ._gbec );_fdgf ._gegf =make ([]float64 ,len (_deggg ._gegf ));copy (_fdgf ._gegf ,_deggg ._gegf );_fdgf ._deba =make ([]*TableCell ,0,len (_deggg ._deba ));
for _ ,_dbaa :=range _deggg ._deba {_ggfa :=*_dbaa ;_ggfa ._gccda =&_fdgf ;_fdgf ._deba =append (_fdgf ._deba ,&_ggfa );};return &_fdgf ;};

// SetBorderWidth sets the border width.
func (_afgc *Ellipse )SetBorderWidth (bw float64 ){_afgc ._efcd =bw };func (_ggb *Block )drawToPage (_ace *_df .PdfPage )error {_fbf :=&_cd .ContentStreamOperations {};if _ace .Resources ==nil {_ace .Resources =_df .NewPdfPageResources ();};_dcf :=_bcba (_fbf ,_ace .Resources ,_ggb ._gea ,_ggb ._da );
if _dcf !=nil {return _dcf ;};if _dcf =_gfb (_ggb ._da ,_ace .Resources );_dcf !=nil {return _dcf ;};if _dcf =_ace .AppendContentBytes (_fbf .Bytes (),true );_dcf !=nil {return _dcf ;};for _ ,_bgg :=range _ggb ._dd {_ace .AddAnnotation (_bgg );};return nil ;
};

// SetColorRight sets border color for right.
func (_fdb *border )SetColorRight (col Color ){_fdb ._gfc =col };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_afda *Creator )SetForms (form *_df .PdfAcroForm )error {_afda ._gcb =form ;return nil };

// SetBorderColor sets the border color.
func (_baaa *Polygon )SetBorderColor (color Color ){_baaa ._bagc .BorderColor =_ebaf (color )};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_bacd *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bacd ._afgb .Left ,_bacd ._afgb .Right ,_bacd ._afgb .Top ,_bacd ._afgb .Bottom ;};

// SetStyleLeft sets border style for left side.
func (_eceg *border )SetStyleLeft (style CellBorderStyle ){_eceg ._ccd =style };func (_eged *Creator )newPage ()*_df .PdfPage {_aggd :=_df .NewPdfPage ();_afcf :=_eged ._fgee [0];_abbg :=_eged ._fgee [1];_babc :=_df .PdfRectangle {Llx :0,Lly :0,Urx :_afcf ,Ury :_abbg };
_aggd .MediaBox =&_babc ;_eged ._fdad =_afcf ;_eged ._bea =_abbg ;_eged .initContext ();return _aggd ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_acac *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_dfbg :=uint (len (_acac ._bgdg ));if index > _dfbg {index =_dfbg ;};_cdag :=_acac .NewColumn (description );_acac ._bgdg =append (_acac ._bgdg [:index ],append ([]*InvoiceCell {_cdag },_acac ._bgdg [index :]...)...);
return _cdag ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_eggfe *TableCell )SetBorderLineStyle (style _a .LineStyle ){_eggfe ._ccaed =style };

// Height returns the height of the list.
func (_gdaeg *List )Height ()float64 {var _cff float64 ;for _ ,_aedbe :=range _gdaeg ._eaga {_cff +=_aedbe ._cfec .Height ();};return _cff ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gadd *_df .PdfAnnotation ;_egdc bool ;};func (_bg *Block )setOpacity (_bd float64 ,_dca float64 )(string ,error ){if (_bd < 0||_bd >=1.0)&&(_dca < 0||_dca >=1.0){return "",nil ;};_aa :=0;_gae :=_gd .Sprintf ("\u0047\u0053\u0025\u0064",_aa );
for _bg ._da .HasExtGState (_ga .PdfObjectName (_gae )){_aa ++;_gae =_gd .Sprintf ("\u0047\u0053\u0025\u0064",_aa );};_gg :=_ga .MakeDict ();if _bd >=0&&_bd < 1.0{_gg .Set ("\u0063\u0061",_ga .MakeFloat (_bd ));};if _dca >=0&&_dca < 1.0{_gg .Set ("\u0043\u0041",_ga .MakeFloat (_dca ));
};_dg :=_bg ._da .AddExtGState (_ga .PdfObjectName (_gae ),_gg );if _dg !=nil {return "",_dg ;};return _gae ,nil ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_af *Block )SetPos (x ,y float64 ){_af ._ag =PositionAbsolute ;_af ._ged =x ;_af ._bc =y };

// IsRelative checks if the positioning is relative.
func (_cbg Positioning )IsRelative ()bool {return _cbg ==PositionRelative };

// SetBorderColor sets the cell's border color.
func (_daggg *TableCell )SetBorderColor (col Color ){_daggg ._gcfa =col ;_daggg ._fadc =col ;_daggg ._aafc =col ;_daggg ._agef =col ;};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// Heading returns the heading component of the table of contents.
func (_aefe *TOC )Heading ()*StyledParagraph {return _aefe ._fcda };func (_ffe *Block )transform (_edd _gf .Matrix ){_ac :=_cd .NewContentCreator ().Add_cm (_edd [0],_edd [1],_edd [3],_edd [4],_edd [6],_edd [7]).Operations ();*_ffe ._gea =append (*_ac ,*_ffe ._gea ...);
_ffe ._gea .WrapIfNeeded ();};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_gcca :float64 (r )/255.0,_adab :float64 (g )/255.0,_ccfe :float64 (b )/255.0};};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cafc *Invoice )NoteHeadingStyle ()TextStyle {return _cafc ._afce };

// SellerAddress returns the seller address used in the invoice template.
func (_aebf *Invoice )SellerAddress ()*InvoiceAddress {return _aebf ._beef };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// RotatedSize returns the width and height of the rotated block.
func (_fb *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_eca ,_gee :=_befd (_fb ._fc ,_fb ._gca ,_fb ._cb );return _eca ,_gee ;};

// TOC returns the table of contents component of the creator.
func (_dbdb *Creator )TOC ()*TOC {return _dbdb ._ccff };func (_edabc *StyledParagraph )getTextHeight ()float64 {var _ggcab float64 ;for _ ,_fffe :=range _edabc ._cccac {_dgeg :=_fffe .Style .FontSize *_edabc ._gccd ;if _dgeg > _ggcab {_ggcab =_dgeg ;};
};return _ggcab ;};func (_gcd *Chapter )headingNumber ()string {var _cgaa string ;if _gcd ._baec {if _gcd ._ccb !=0{_cgaa =_c .Itoa (_gcd ._ccb )+"\u002e";};if _gcd ._gbca !=nil {_eggb :=_gcd ._gbca .headingNumber ();if _eggb !=""{_cgaa =_eggb +_cgaa ;
};};};return _cgaa ;};

// SetHeight sets the Image's document height to specified h.
func (_ccdg *Image )SetHeight (h float64 ){_ccdg ._cbce =h };

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_adada *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_adada ._ccff =toc ;};func (_agfa *TOCLine )prepareParagraph (_edeg *StyledParagraph ,_fdag DrawContext ){_ggafg :=_agfa .Title .Text ;if _agfa .Number .Text !=""{_ggafg ="\u0020"+_ggafg ;
};_ggafg +="\u0020";_abaf :=_agfa .Page .Text ;if _abaf !=""{_abaf ="\u0020"+_abaf ;};_edeg ._cccac =[]*TextChunk {{Text :_agfa .Number .Text ,Style :_agfa .Number .Style ,_gadd :_agfa .getLineLink ()},{Text :_ggafg ,Style :_agfa .Title .Style ,_gadd :_agfa .getLineLink ()},{Text :_abaf ,Style :_agfa .Page .Style ,_gadd :_agfa .getLineLink ()}};
_edeg .wrapText ();_cccbf :=len (_edeg ._fbdf );if _cccbf ==0{return ;};_ccfc :=_fdag .Width *1000-_edeg .getTextLineWidth (_edeg ._fbdf [_cccbf -1]);_gdad :=_edeg .getTextLineWidth ([]*TextChunk {&_agfa .Separator });_adfc :=int (_ccfc /_gdad );_dfaed :=_dc .Repeat (_agfa .Separator .Text ,_adfc );
_ffbe :=_agfa .Separator .Style ;_efgd :=_edeg .Insert (2,_dfaed );_efgd .Style =_ffbe ;_efgd ._gadd =_agfa .getLineLink ();_ccfc =_ccfc -float64 (_adfc )*_gdad ;if _ccfc > 500{_cabfd ,_gcae :=_ffbe .Font .GetRuneMetrics (' ');if _gcae &&_ccfc > _cabfd .Wx {_eacb :=int (_ccfc /_cabfd .Wx );
if _eacb > 0{_caac :=_ffbe ;_caac .FontSize =1;_efgd =_edeg .Insert (2,_dc .Repeat ("\u0020",_eacb ));_efgd .Style =_caac ;_efgd ._gadd =_agfa .getLineLink ();};};};};

// SetFillColor sets background color for border.
func (_acbf *border )SetFillColor (col Color ){_acbf ._gga =col };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_dag :=&Block {};_dag ._gea =&_cd .ContentStreamOperations {};_dag ._da =_df .NewPdfPageResources ();_dag ._fc =width ;_dag ._gca =height ;return _dag ;};

// SetColorTop sets border color for top.
func (_ecff *border )SetColorTop (col Color ){_ecff ._cdf =col };func _degc ()*PageBreak {return &PageBreak {}};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fdfde *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fdfde ._gaaa .Left ,_fdfde ._gaaa .Right ,_fdfde ._gaaa .Top ,_fdfde ._gaaa .Bottom ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fdcg *TOC )SetLineSeparator (separator string ){_fdcg ._acdeg =separator };func _gaca (_eccb int )*Table {_gcbd :=&Table {_bdgf :_eccb ,_gabeb :10.0,_gegf :[]float64 {},_gbec :[]float64 {},_deba :[]*TableCell {},_cbfc :make ([]int ,_eccb )};_gcbd .resetColumnWidths ();
return _gcbd ;};func (_cccga *TOCLine )getLineLink ()*_df .PdfAnnotation {if _cccga ._babaa <=0{return nil ;};return _cfcg (_cccga ._babaa -1,_cccga ._cabec ,_cccga ._begf ,0);};

// SetBuyerAddress sets the buyer address of the invoice.
func (_dfeg *Invoice )SetBuyerAddress (address *InvoiceAddress ){_dfeg ._gdeg =address };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_gacd *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_ceed :=range subtable ._deba {_acef :=&TableCell {};*_acef =*_ceed ;_acef ._gccda =_gacd ;_acef ._bbdb +=col -1;if _deeb :=_gacd ._bdgf -(_acef ._bbdb -1);_deeb < _acef ._fcgce {_gacd ._bdgf +=_acef ._fcgce -_deeb ;
_gacd .resetColumnWidths ();_f .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_gacd ._bdgf );
};_acef ._cddc +=row -1;_caddb :=subtable ._gbec [_ceed ._cddc -1];if _acef ._cddc > _gacd ._cead {for _acef ._cddc > _gacd ._cead {_gacd ._cead ++;_gacd ._gbec =append (_gacd ._gbec ,_gacd ._gabeb );};_gacd ._gbec [_acef ._cddc -1]=_caddb ;}else {_gacd ._gbec [_acef ._cddc -1]=_b .Max (_gacd ._gbec [_acef ._cddc -1],_caddb );
};_gacd ._deba =append (_gacd ._deba ,_acef );};_gc .Slice (_gacd ._deba ,func (_aaaf ,_eabea int )bool {_abdff :=_gacd ._deba [_aaaf ]._cddc ;_edebf :=_gacd ._deba [_eabea ]._cddc ;if _abdff < _edebf {return true ;};if _abdff > _edebf {return false ;};
return _gacd ._deba [_aaaf ]._bbdb < _gacd ._deba [_eabea ]._bbdb ;});};

// CurRow returns the currently active cell's row number.
func (_fcbfc *Table )CurRow ()int {_ffba :=(_fcbfc ._agdbb -1)/_fcbfc ._bdgf +1;return _ffba };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_dbeg *Creator )SetOptimizer (optimizer _df .Optimizer ){_dbeg ._cbfb =optimizer };const (DefaultHorizontalScaling =100;);

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_aedb DrawContext )([]*Block ,DrawContext ,error );};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// SetLineWidth sets the line width.
func (_cbeb *Line )SetLineWidth (lw float64 ){_cbeb ._cgag =lw };func _abb (_dcag ,_fdd ,_adae ,_ggf float64 )*border {_cfbd :=&border {};_cfbd ._cbab =_dcag ;_cfbd ._adcb =_fdd ;_cfbd ._egg =_adae ;_cfbd ._gbg =_ggf ;_cfbd ._cdf =ColorBlack ;_cfbd ._abfc =ColorBlack ;
_cfbd ._abgf =ColorBlack ;_cfbd ._gfc =ColorBlack ;_cfbd ._bcbad =0;_cfbd ._gdg =0;_cfbd ._eda =0;_cfbd ._ageb =0;_cfbd .LineStyle =_a .LineStyleSolid ;return _cfbd ;};

// NewImageFromData creates an Image from image data.
func (_agea *Creator )NewImageFromData (data []byte )(*Image ,error ){return _gff (data )};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_fabe *Creator )MoveRight (dx float64 ){_fabe ._gfbg .X +=dx };

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_adcbe *Invoice )SetAddressStyle (style TextStyle ){_adcbe ._cgdc =style };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_bcgcg Color ;_ccaed _a .LineStyle ;_agbe CellBorderStyle ;_gcfa Color ;_egfce float64 ;_geag CellBorderStyle ;_fadc Color ;_gcdd float64 ;_becde CellBorderStyle ;_aafc Color ;_ccbea float64 ;_fada CellBorderStyle ;_agef Color ;_cfaac float64 ;
_cddc ,_bbdb int ;_eddgb int ;_fcgce int ;_aabaf VectorDrawable ;_babff CellHorizontalAlignment ;_ecabe CellVerticalAlignment ;_dddg float64 ;_gccda *Table ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_eead *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eead ._aaec .Left ,_eead ._aaec .Right ,_eead ._aaec .Top ,_eead ._aaec .Bottom ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;
TextAlignmentJustify ;);

// Width returns the width of the Paragraph.
func (_cdgf *StyledParagraph )Width ()float64 {if _cdgf ._gafc &&int (_cdgf ._cgfgd )> 0{return _cdgf ._cgfgd ;};return _cdgf .getTextWidth ()/1000.0;};func (_dgaa *Creator )getActivePage ()*_df .PdfPage {if _dgaa ._baf ==nil {if len (_dgaa ._aeg )==0{return nil ;
};return _dgaa ._aeg [len (_dgaa ._aeg )-1];};return _dgaa ._baf ;};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// AddLine appends a new line to the invoice line items table.
func (_gcag *Invoice )AddLine (values ...string )[]*InvoiceCell {_cage :=len (_gcag ._bgdg );var _aadac []*InvoiceCell ;for _cebb ,_eee :=range values {_bbgb :=_gcag .newCell (_eee ,_gcag ._aegde );if _cebb < _cage {_bbgb .Alignment =_gcag ._bgdg [_cebb ].Alignment ;
};_aadac =append (_aadac ,_bbgb );};_gcag ._cbad =append (_gcag ._cbad ,_aadac );return _aadac ;};

// SetWidthRight sets border width for right.
func (_fgd *border )SetWidthRight (bw float64 ){_fgd ._ageb =bw };func _edca (_edaf *Block ,_abca *StyledParagraph ,_cddbe [][]*TextChunk ,_fbaf DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bgfa :=1;_gege :=_ga .PdfObjectName (_gd .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bgfa ));
for _edaf ._da .HasFontByName (_gege ){_bgfa ++;_gege =_ga .PdfObjectName (_gd .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bgfa ));};_geb :=_edaf ._da .SetFontByName (_gege ,_abca ._fee .Font .ToPdfObject ());if _geb !=nil {return _fbaf ,nil ,_geb ;
};_bgfa ++;_gafd :=_gege ;_dfba :=_abca ._fee .FontSize ;_bbff :=_abca ._becgb .IsRelative ();var _eeeb [][]_ga .PdfObjectName ;var _abadf [][]*TextChunk ;var _gaee float64 ;for _cagfc ,_feec :=range _cddbe {var _fcgdc []_ga .PdfObjectName ;var _gdeba float64 ;
if len (_feec )> 0{_gdeba =_feec [0].Style .FontSize ;};for _ ,_decf :=range _feec {_gddg :=_decf .Style ;if _decf .Text !=""&&_gddg .FontSize > _gdeba {_gdeba =_gddg .FontSize ;};_gege =_ga .PdfObjectName (_gd .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bgfa ));
_fadg :=_edaf ._da .SetFontByName (_gege ,_gddg .Font .ToPdfObject ());if _fadg !=nil {return _fbaf ,nil ,_fadg ;};_fcgdc =append (_fcgdc ,_gege );_bgfa ++;};_gdeba *=_abca ._gccd ;if _bbff &&_gaee +_gdeba > _fbaf .Height {_abadf =_cddbe [_cagfc :];_cddbe =_cddbe [:_cagfc ];
break ;};_gaee +=_gdeba ;_eeeb =append (_eeeb ,_fcgdc );};_bggf ,_becb ,_gfgf :=_abca .getLineMetrics (0);_cdgd ,_cacd :=_bggf *_abca ._gccd ,_becb *_abca ._gccd ;_dgcfc :=_cd .NewContentCreator ();_dgcfc .Add_q ();_cbcd :=_cacd ;if _abca ._bgdc ==TextVerticalAlignmentCenter {_cbcd =_becb +(_bggf +_gfgf -_becb )/2+(_cacd -_becb )/2;
};_dedf :=_fbaf .PageHeight -_fbaf .Y -_cbcd ;_dgcfc .Translate (_fbaf .X ,_dedf );_gbdag :=_dedf ;if _abca ._gcbgd !=0{_dgcfc .RotateDeg (_abca ._gcbgd );};if _abca ._acbe ==TextOverflowHidden {_dgcfc .Add_re (0,-_gaee +_cdgd +1,_abca ._cgfgd ,_gaee ).Add_W ().Add_n ();
};_dgcfc .Add_BT ();var _ffcf []*_a .BasicLine ;for _gecde ,_ffge :=range _cddbe {_abaa :=_fbaf .X ;var _fgea float64 ;if len (_ffge )> 0{_fgea =_ffge [0].Style .FontSize ;};for _ ,_fcgeb :=range _ffge {_cdfe :=&_fcgeb .Style ;if _fcgeb .Text !=""&&_cdfe .FontSize > _fgea {_fgea =_cdfe .FontSize ;
};};if _gecde !=0{_dgcfc .Add_TD (0,-_fgea *_abca ._gccd );_gbdag -=_fgea *_abca ._gccd ;};_gead :=_gecde ==len (_cddbe )-1;var (_decc float64 ;_defb float64 ;_gfcc float64 ;_acea uint ;);var _gdcc []float64 ;for _ ,_bbcbe :=range _ffge {_bfgcd :=&_bbcbe .Style ;
if _bfgcd .FontSize > _defb {_defb =_bfgcd .FontSize ;};_fbcbf ,_gdafg :=_bfgcd .Font .GetRuneMetrics (' ');if !_gdafg {return _fbaf ,nil ,_gb .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _gfbbc uint ;var _faeb float64 ;_cecb :=len (_bbcbe .Text );for _bace ,_dbaf :=range _bbcbe .Text {if _dbaf ==' '{_gfbbc ++;continue ;};if _dbaf =='\u000A'{continue ;};_eafad ,_ccdb :=_bfgcd .Font .GetRuneMetrics (_dbaf );if !_ccdb {_f .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_dbaf );
return _fbaf ,nil ,_gb .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_faeb +=_bfgcd .FontSize *_eafad .Wx *_bfgcd .horizontalScale ();if _bace !=_cecb -1{_faeb +=_bfgcd .CharSpacing *1000.0;
};};_gdcc =append (_gdcc ,_faeb );_decc +=_faeb ;_gfcc +=float64 (_gfbbc )*_fbcbf .Wx *_bfgcd .FontSize *_bfgcd .horizontalScale ();_acea +=_gfbbc ;};_defb *=_abca ._gccd ;var _ccae []_ga .PdfObject ;_fddd :=_abca ._cgfgd *1000.0;if _abca ._ggbd ==TextAlignmentJustify {if _acea > 0&&!_gead {_gfcc =(_fddd -_decc )/float64 (_acea )/_dfba ;
};}else if _abca ._ggbd ==TextAlignmentCenter {_ccbg :=(_fddd -_decc -_gfcc )/2;_aggac :=_ccbg /_dfba ;_ccae =append (_ccae ,_ga .MakeFloat (-_aggac ));_abaa +=_ccbg /1000.0;}else if _abca ._ggbd ==TextAlignmentRight {_dccg :=(_fddd -_decc -_gfcc );_adfff :=_dccg /_dfba ;
_ccae =append (_ccae ,_ga .MakeFloat (-_adfff ));_abaa +=_dccg /1000.0;};if len (_ccae )> 0{_dgcfc .Add_Tf (_gafd ,_dfba ).Add_TL (_dfba *_abca ._gccd ).Add_TJ (_ccae ...);};for _agge ,_cddgc :=range _ffge {_agb :=&_cddgc .Style ;_eedd :=_gafd ;_ddgde :=_dfba ;
_aadc :=_agb .OutlineColor !=nil ;_egbf :=_agb .HorizontalScaling !=DefaultHorizontalScaling ;_gabe :=_agb .OutlineSize !=1;if _gabe {_dgcfc .Add_w (_agb .OutlineSize );};_befa :=_agb .RenderingMode !=TextRenderingModeFill ;if _befa {_dgcfc .Add_Tr (int64 (_agb .RenderingMode ));
};_fgcf :=_agb .CharSpacing !=0;if _fgcf {_dgcfc .Add_Tc (_agb .CharSpacing );};_ggaf :=_agb .TextRise !=0;if _ggaf {_dgcfc .Add_Ts (_agb .TextRise );};if _abca ._ggbd !=TextAlignmentJustify ||_gead {_dbbc ,_aeff :=_agb .Font .GetRuneMetrics (' ');if !_aeff {return _fbaf ,nil ,_gb .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_eedd =_eeeb [_gecde ][_agge ];_ddgde =_agb .FontSize ;_gfcc =_dbbc .Wx *_agb .horizontalScale ();};_ggea :=_agb .Font .Encoder ();var _ecdd []byte ;for _ ,_eegag :=range _cddgc .Text {if _eegag =='\u000A'{continue ;};if _eegag ==' '{if len (_ecdd )> 0{if _aadc {_dgcfc .SetStrokingColor (_ebaf (_agb .OutlineColor ));
};if _egbf {_dgcfc .Add_Tz (_agb .HorizontalScaling );};_dgcfc .SetNonStrokingColor (_ebaf (_agb .Color )).Add_Tf (_eeeb [_gecde ][_agge ],_agb .FontSize ).Add_TJ ([]_ga .PdfObject {_ga .MakeStringFromBytes (_ecdd )}...);_ecdd =nil ;};if _egbf {_dgcfc .Add_Tz (DefaultHorizontalScaling );
};_dgcfc .Add_Tf (_eedd ,_ddgde ).Add_TJ ([]_ga .PdfObject {_ga .MakeFloat (-_gfcc )}...);_gdcc [_agge ]+=_gfcc *_ddgde ;}else {if _ ,_dcfbf :=_ggea .RuneToCharcode (_eegag );!_dcfbf {_geb =UnsupportedRuneError {Message :_gd .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_eegag ,_eegag ),Rune :_eegag };
_fbaf ._ggag =append (_fbaf ._ggag ,_geb );_f .Log .Debug (_geb .Error ());if _fbaf ._ead <=0{continue ;};_eegag =_fbaf ._ead ;};_ecdd =append (_ecdd ,_ggea .Encode (string (_eegag ))...);};};if len (_ecdd )> 0{if _aadc {_dgcfc .SetStrokingColor (_ebaf (_agb .OutlineColor ));
};if _egbf {_dgcfc .Add_Tz (_agb .HorizontalScaling );};_dgcfc .SetNonStrokingColor (_ebaf (_agb .Color )).Add_Tf (_eeeb [_gecde ][_agge ],_agb .FontSize ).Add_TJ ([]_ga .PdfObject {_ga .MakeStringFromBytes (_ecdd )}...);};_fdgdb :=_gdcc [_agge ]/1000.0;
if _agb .Underline {_bffa :=_agb .UnderlineStyle .Color ;if _bffa ==nil {_bffa =_cddgc .Style .Color ;};_gdga ,_bdfg ,_cbdf :=_bffa .ToRGB ();_dcff :=_abaa -_fbaf .X ;_dggc :=_gbdag -_dedf +_agb .TextRise -_agb .UnderlineStyle .Offset ;_ffcf =append (_ffcf ,&_a .BasicLine {X1 :_dcff ,Y1 :_dggc ,X2 :_dcff +_fdgdb ,Y2 :_dggc ,LineWidth :_cddgc .Style .UnderlineStyle .Thickness ,LineColor :_df .NewPdfColorDeviceRGB (_gdga ,_bdfg ,_cbdf )});
};if _cddgc ._gadd !=nil {var _gcaf *_ga .PdfObjectArray ;if !_cddgc ._egdc {switch _daab :=_cddgc ._gadd .GetContext ().(type ){case *_df .PdfAnnotationLink :_gcaf =_ga .MakeArray ();_daab .Rect =_gcaf ;_daabf ,_eaagf :=_daab .Dest .(*_ga .PdfObjectArray );
if _eaagf &&_daabf .Len ()==5{_ggce ,_gggf :=_daabf .Get (1).(*_ga .PdfObjectName );if _gggf &&_ggce .String ()=="\u0058\u0059\u005a"{_fcdd ,_faba :=_ga .GetNumberAsFloat (_daabf .Get (3));if _faba ==nil {_daabf .Set (3,_ga .MakeFloat (_fbaf .PageHeight -_fcdd ));
};};};};_cddgc ._egdc =true ;};if _gcaf !=nil {_fcede :=_a .NewPoint (_abaa -_fbaf .X ,_gbdag +_agb .TextRise -_dedf ).Rotate (_abca ._gcbgd );_fcede .X +=_fbaf .X ;_fcede .Y +=_dedf ;_ecddc ,_beed ,_acfb ,_dcd :=_befd (_fdgdb ,_defb ,_abca ._gcbgd );_fcede .X +=_ecddc ;
_fcede .Y +=_beed ;_gcaf .Clear ();_gcaf .Append (_ga .MakeFloat (_fcede .X ));_gcaf .Append (_ga .MakeFloat (_fcede .Y ));_gcaf .Append (_ga .MakeFloat (_fcede .X +_acfb ));_gcaf .Append (_ga .MakeFloat (_fcede .Y +_dcd ));};_edaf .AddAnnotation (_cddgc ._gadd );
};_abaa +=_fdgdb ;if _gabe {_dgcfc .Add_w (1.0);};if _aadc {_dgcfc .Add_RG (0.0,0.0,0.0);};if _befa {_dgcfc .Add_Tr (int64 (TextRenderingModeFill ));};if _fgcf {_dgcfc .Add_Tc (0);};if _ggaf {_dgcfc .Add_Ts (0);};if _egbf {_dgcfc .Add_Tz (DefaultHorizontalScaling );
};};};_dgcfc .Add_ET ();for _ ,_cfea :=range _ffcf {_dgcfc .SetStrokingColor (_cfea .LineColor ).Add_w (_cfea .LineWidth ).Add_m (_cfea .X1 ,_cfea .Y1 ).Add_l (_cfea .X2 ,_cfea .Y2 ).Add_s ();};_dgcfc .Add_Q ();_bdae :=_dgcfc .Operations ();_bdae .WrapIfNeeded ();
_edaf .addContents (_bdae );if _bbff {_addb :=_gaee +_abca ._gaaa .Bottom ;_fbaf .Y +=_addb ;_fbaf .Height -=_addb ;if _fbaf .Inline {_fbaf .X +=_abca .Width ()+_abca ._gaaa .Right ;};};return _fbaf ,_abadf ,nil ;};func (_gecb *Paragraph )getMaxLineWidth ()float64 {if _gecb ._bcbfc ==nil ||len (_gecb ._bcbfc )==0{_gecb .wrapText ();
};var _ffac float64 ;for _ ,_edgc :=range _gecb ._bcbfc {_egag :=_gecb .getTextLineWidth (_edgc );if _egag > _ffac {_ffac =_egag ;};};return _ffac ;};

// Logo returns the logo of the invoice.
func (_cbff *Invoice )Logo ()*Image {return _cbff ._dggb };

// SetDate sets the date of the invoice.
func (_eaf *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_eaf ._aee [1].Value =date ;return _eaf ._aee [0],_eaf ._aee [1];};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func _afdf (_gddb string ,_bgbg TextStyle )*Paragraph {_gdcb :=&Paragraph {_fagc :_gddb ,_cdga :_bgbg .Font ,_dgda :_bgbg .FontSize ,_ffg :1.0,_bbdf :true ,_daga :true ,_beaa :TextAlignmentLeft ,_dfeag :0,_dbfg :1,_abeg :1,_eeea :PositionRelative };
_gdcb .SetColor (_bgbg .Color );return _gdcb ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_ddd Drawable )(Drawable ,error );};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_cead int ;_bdgf int ;_agdbb int ;_gegf []float64 ;_gbec []float64 ;_gabeb float64 ;_deba []*TableCell ;_cbfc []int ;_cbgc Positioning ;_begd ,_fcfg float64 ;_gbcf Margins ;_bgfac bool ;_fbbg int ;_dbca int ;_ggafc bool ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cdecf *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _cdecf ._cdb [0],_cdecf ._cdb [1]};func _adba (_bgcfd [][]_a .Point )*Polygon {return &Polygon {_bagc :&_a .Polygon {Points :_bgcfd },_ffgf :1.0,_bggc :1.0};};func (_edagf *Invoice )drawInformation ()*Table {_efbg :=_gaca (2);
_cgdcg :=append ([][2]*InvoiceCell {_edagf ._gfea ,_edagf ._aee ,_edagf ._beefc },_edagf ._efgcg ...);for _ ,_ddab :=range _cgdcg {_edbbb ,_aabca :=_ddab [0],_ddab [1];if _aabca .Value ==""{continue ;};_cgfg :=_efbg .NewCell ();_cgfg .SetBackgroundColor (_edbbb .BackgroundColor );
_edagf .setCellBorder (_cgfg ,_edbbb );_fabf :=_cabf (_edbbb .TextStyle );_fabf .Append (_edbbb .Value );_fabf .SetMargins (0,0,2,1);_cgfg .SetContent (_fabf );_cgfg =_efbg .NewCell ();_cgfg .SetBackgroundColor (_aabca .BackgroundColor );_edagf .setCellBorder (_cgfg ,_aabca );
_fabf =_cabf (_aabca .TextStyle );_fabf .Append (_aabca .Value );_fabf .SetMargins (0,0,2,1);_cgfg .SetContent (_fabf );};return _efbg ;};func _geeea (_ebe ,_bdab ,_gccfa ,_abdd float64 )*Ellipse {_bdgg :=&Ellipse {};_bdgg ._aggf =_ebe ;_bdgg ._gbd =_bdab ;
_bdgg ._cfag =_gccfa ;_bdgg ._aegf =_abdd ;_bdgg ._ggdc =ColorBlack ;_bdgg ._efcd =1.0;return _bdgg ;};func (_cba *Block )translate (_agg ,_bdd float64 ){_eaa :=_cd .NewContentCreator ().Translate (_agg ,-_bdd ).Operations ();*_cba ._gea =append (*_eaa ,*_cba ._gea ...);
_cba ._gea .WrapIfNeeded ();};

// TitleStyle returns the style properties used to render the invoice title.
func (_befe *Invoice )TitleStyle ()TextStyle {return _befe ._fdea };

// Width returns the Block's width.
func (_bee *Block )Width ()float64 {return _bee ._fc };

// GetCoords returns coordinates of border.
func (_baa *border )GetCoords ()(float64 ,float64 ){return _baa ._cbab ,_baa ._adcb };

// SetTotal sets the total of the invoice.
func (_dfgc *Invoice )SetTotal (value string ){_dfgc ._cdb [1].Value =value };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_eaafg *TOC )SetLineTitleStyle (style TextStyle ){_eaafg ._befac =style };

// NewPageBreak create a new page break.
func (_bcfed *Creator )NewPageBreak ()*PageBreak {return _degc ()};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_fabc *StyledParagraph )Height ()float64 {_fabc .wrapText ();var _eeedb float64 ;for _ ,_fdfff :=range _fabc ._fbdf {var _dgea float64 ;for _ ,_debe :=range _fdfff {_dbac :=_fabc ._gccd *_debe .Style .FontSize ;if _dbac > _dgea {_dgea =_dbac ;};};
_eeedb +=_dgea ;};return _eeedb ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_eeda *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _eeda ._gcgc ==nil {if _ffc :=_eeda .makeXObject ();_ffc !=nil {return nil ,ctx ,_ffc ;};};var _gfda []*Block ;_bgbb :=ctx ;_agege :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _eeda ._fgfe .IsRelative (){ctx .X +=_eeda ._afgb .Left ;ctx .Y +=_eeda ._afgb .Top ;ctx .Width -=_eeda ._afgb .Left +_eeda ._afgb .Right ;ctx .Height -=_eeda ._afgb .Top +_eeda ._afgb .Bottom ;if _eeda ._cbce > ctx .Height {_gfda =append (_gfda ,_agege );
_agege =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ccfg :=ctx ;_ccfg .Y =ctx .Margins .Top +_eeda ._afgb .Top ;_ccfg .X =ctx .Margins .Left +_eeda ._afgb .Left ;_ccfg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_eeda ._afgb .Top -_eeda ._afgb .Bottom ;
_ccfg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_eeda ._afgb .Left -_eeda ._afgb .Right ;ctx =_ccfg ;_bgbb .X =ctx .Margins .Left ;_bgbb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_eeda ._gaabg ;
ctx .Y =_eeda ._edac ;};ctx ,_fcad :=_cabg (_agege ,_eeda ,ctx );if _fcad !=nil {return nil ,ctx ,_fcad ;};_gfda =append (_gfda ,_agege );if _eeda ._fgfe .IsAbsolute (){ctx =_bgbb ;}else {ctx .X =_bgbb .X ;ctx .Y +=_eeda ._afgb .Bottom ;ctx .Width =_bgbb .Width ;
};return _gfda ,ctx ,nil ;};

// SetFillColor sets the fill color.
func (_bbda *Ellipse )SetFillColor (col Color ){_bbda ._fcdb =col };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_bedb *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _fegd (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetPos sets absolute positioning with specified coordinates.
func (_eeed *Paragraph )SetPos (x ,y float64 ){_eeed ._eeea =PositionAbsolute ;_eeed ._eege =x ;_eeed ._facc =y ;};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_beda *Rectangle )GetCoords ()(float64 ,float64 ){return _beda ._bcfb ,_beda ._bfcd };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_fgced *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_cdbd :=NewTextChunk (text ,_fgced ._fgffa );_cdbd ._gadd =_cfcg (page -1,x ,y ,zoom );return _fgced .appendChunk (_cdbd );};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_abfe *Image )GetHorizontalAlignment ()HorizontalAlignment {return _abfe ._fae };func _fec (_fge string ,_dbc _ga .PdfObject ,_ecec *_df .PdfPageResources )_ga .PdfObjectName {_egbc :=_dc .TrimRightFunc (_dc .TrimSpace (_fge ),func (_cee rune )bool {return _bb .IsNumber (_cee )});
if _egbc ==""{_egbc ="\u0046\u006f\u006e\u0074";};_eebf :=0;_bfecg :=_ga .PdfObjectName (_fge );for {_cca ,_gbce :=_ecec .GetFontByName (_bfecg );if !_gbce ||_cca ==_dbc {break ;};_eebf ++;_bfecg =_ga .PdfObjectName (_gd .Sprintf ("\u0025\u0073\u0025\u0064",_egbc ,_eebf ));
};return _bfecg ;};

// NewCell returns a new invoice table cell.
func (_gfcg *Invoice )NewCell (value string )*InvoiceCell {return _gfcg .newCell (value ,_gfcg .NewCellProps ());};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetLineOpacity sets the line opacity.
func (_ceae *Polyline )SetLineOpacity (opacity float64 ){_ceae ._dacg =opacity };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gdaf *Paragraph )SetTextAlignment (align TextAlignment ){_gdaf ._beaa =align };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_ddc *Creator )NewPage ()*_df .PdfPage {_beg :=_ddc .newPage ();_ddc ._aeg =append (_ddc ._aeg ,_beg );_ddc ._gfbg .Page ++;return _beg ;};

// SetBorderColor sets the border color for the path.
func (_dade *FilledCurve )SetBorderColor (color Color ){_dade ._faf =color };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_afbd *Image )ConvertToBinary ()error {return _afbd ._ffdb .ConvertToBinary ()};

// NewColumn returns a new column for the line items invoice table.
func (_bfcb *Invoice )NewColumn (description string )*InvoiceCell {return _bfcb .newColumn (description ,CellHorizontalAlignmentLeft );};

// The Image type is used to draw an image onto PDF.
type Image struct{_gcgc *_df .XObjectImage ;_ffdb *_df .Image ;_abdb float64 ;_ggfg ,_cbce float64 ;_afca ,_gcgg float64 ;_fgfe Positioning ;_fae HorizontalAlignment ;_gaabg float64 ;_edac float64 ;_dcade float64 ;_afgb Margins ;_edee ,_geg float64 ;_cbfab _ga .StreamEncoder ;
};

// SetFillColor sets the fill color.
func (_ebba *Rectangle )SetFillColor (col Color ){_ebba ._abcf =col };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ee *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ee ._bcb .Left ,_ee ._bcb .Right ,_ee ._bcb .Top ,_ee ._bcb .Bottom ;};

// SetWidthTop sets border width for top.
func (_efc *border )SetWidthTop (bw float64 ){_efc ._bcbad =bw };func (_cad cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_acf :=_cad ._aedf ;return 1-(_cad ._cbfa *(1-_acf )+_acf ),1-(_cad ._bbc *(1-_acf )+_acf ),1-(_cad ._fcg *(1-_acf )+_acf );};

// MoveY moves the drawing context to absolute position y.
func (_bda *Creator )MoveY (y float64 ){_bda ._gfbg .Y =y };func (_bbg *InvoiceAddress )fmtLine (_aaba ,_egbea string ,_fad bool )string {if _fad {_egbea ="";};return _gd .Sprintf ("\u0025\u0073\u0025s\u000a",_egbea ,_aaba );};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_eage *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bbe :=_a .Rectangle {Opacity :1.0,X :_eage ._bcfb ,Y :ctx .PageHeight -_eage ._bfcd -_eage ._ddeg ,Height :_eage ._ddeg ,Width :_eage ._aage };
if _eage ._abcf !=nil {_bbe .FillEnabled =true ;_bbe .FillColor =_ebaf (_eage ._abcf );};if _eage ._baee !=nil &&_eage ._edfac > 0{_bbe .BorderEnabled =true ;_bbe .BorderColor =_ebaf (_eage ._baee );_bbe .BorderWidth =_eage ._edfac ;};_agce ,_abcb :=_agae .setOpacity (_eage ._ddfa ,_eage ._gaac );
if _abcb !=nil {return nil ,ctx ,_abcb ;};_abba ,_ ,_abcb :=_bbe .Draw (_agce );if _abcb !=nil {return nil ,ctx ,_abcb ;};if _abcb =_agae .addContentsByString (string (_abba ));_abcb !=nil {return nil ,ctx ,_abcb ;};return []*Block {_agae },ctx ,nil ;};
func _ddf ()*Division {return &Division {_eaag :[]VectorDrawable {}}};

// CreateTableOfContents sets a function to generate table of contents.
func (_afa *Creator )CreateTableOfContents (genTOCFunc func (_afc *TOC )error ){_afa ._eab =genTOCFunc };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_afegg *Image )ScaleToWidth (w float64 ){_gecd :=_afegg ._cbce /_afegg ._ggfg ;_afegg ._ggfg =w ;_afegg ._cbce =w *_gecd ;};

// Lines returns all the rows of the invoice line items table.
func (_cegc *Invoice )Lines ()[][]*InvoiceCell {return _cegc ._cbad };

// Cols returns the total number of columns the table has.
func (_ebbef *Table )Cols ()int {return _ebbef ._bdgf };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_ggac *Creator )MoveTo (x ,y float64 ){_ggac ._gfbg .X =x ;_ggac ._gfbg .Y =y };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetWidthBottom sets border width for bottom.
func (_ecee *border )SetWidthBottom (bw float64 ){_ecee ._gdg =bw };func (_cbfe *StyledParagraph )getLineMetrics (_cfdg int )(_cfed ,_efge ,_gafa float64 ){if _cbfe ._fbdf ==nil ||len (_cbfe ._fbdf )==0{_cbfe .wrapText ();};if _cfdg < 0||_cfdg > len (_cbfe ._fbdf )-1{_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_cfdg );
return 0,0,0;};_gaga :=_cbfe ._fbdf [_cfdg ];for _ ,_gfbfa :=range _gaga {_aeeb ,_effcg :=_gfbfa .Style .Font .GetFontDescriptor ();if _effcg !=nil {_f .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _afag ,_ccab float64 ;if _aeeb !=nil {if _afag ,_effcg =_aeeb .GetCapHeight ();_effcg !=nil {_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_effcg );
};if _ccab ,_effcg =_aeeb .GetDescent ();_effcg !=nil {_f .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_effcg );
};};if int (_afag )<=0{_f .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_afag =1000;};if _gcffd :=_afag /1000.0*_gfbfa .Style .FontSize ;_gcffd > _cfed {_cfed =_gcffd ;};if _ebfg :=_gfbfa .Style .FontSize ;_ebfg > _efge {_efge =_ebfg ;};if _acbg :=_ccab /1000.0*_gfbfa .Style .FontSize ;_acbg < _gafa {_gafa =_acbg ;};};return _cfed ,_efge ,_gafa ;
};func _ccbda (_abadb *Block ,_gafb *Paragraph ,_gdcd DrawContext )(DrawContext ,error ){_ggge :=1;_degfg :=_ga .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_ggge ));for _abadb ._da .HasFontByName (_degfg ){_ggge ++;_degfg =_ga .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_ggge ));
};_eegd :=_abadb ._da .SetFontByName (_degfg ,_gafb ._cdga .ToPdfObject ());if _eegd !=nil {return _gdcd ,_eegd ;};_gafb .wrapText ();_aaad :=_cd .NewContentCreator ();_aaad .Add_q ();_dff :=_gdcd .PageHeight -_gdcd .Y -_gafb ._dgda *_gafb ._ffg ;_aaad .Translate (_gdcd .X ,_dff );
if _gafb ._dfeag !=0{_aaad .RotateDeg (_gafb ._dfeag );};_aaad .Add_BT ().SetNonStrokingColor (_ebaf (_gafb ._ggbf )).Add_Tf (_degfg ,_gafb ._dgda ).Add_TL (_gafb ._dgda *_gafb ._ffg );for _faec ,_adaba :=range _gafb ._bcbfc {if _faec !=0{_aaad .Add_Tstar ();
};_cecff :=[]rune (_adaba );_bgbd :=0.0;_badea :=0;for _gbbb ,_aaaab :=range _cecff {if _aaaab ==' '{_badea ++;continue ;};if _aaaab =='\u000A'{continue ;};_gadb ,_gfbf :=_gafb ._cdga .GetRuneMetrics (_aaaab );if !_gfbf {_f .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_gbbb ,_aaaab ,_aaaab ,_gafb ._cdga .BaseFont (),_gafb ._cdga .Subtype ());
return _gdcd ,_gb .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bgbd +=_gafb ._dgda *_gadb .Wx ;};var _fbde []_ga .PdfObject ;_afcc ,_cggd :=_gafb ._cdga .GetRuneMetrics (' ');
if !_cggd {return _gdcd ,_gb .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_cfbeb :=_afcc .Wx ;switch _gafb ._beaa {case TextAlignmentJustify :if _badea > 0&&_faec < len (_gafb ._bcbfc )-1{_cfbeb =(_gafb ._adgge *1000.0-_bgbd )/float64 (_badea )/_gafb ._dgda ;
};case TextAlignmentCenter :_cebd :=_bgbd +float64 (_badea )*_cfbeb *_gafb ._dgda ;_cgfa :=(_gafb ._adgge *1000.0-_cebd )/2/_gafb ._dgda ;_fbde =append (_fbde ,_ga .MakeFloat (-_cgfa ));case TextAlignmentRight :_eaff :=_bgbd +float64 (_badea )*_cfbeb *_gafb ._dgda ;
_gfcbc :=(_gafb ._adgge *1000.0-_eaff )/_gafb ._dgda ;_fbde =append (_fbde ,_ga .MakeFloat (-_gfcbc ));};_bgdge :=_gafb ._cdga .Encoder ();var _dbcea []byte ;for _ ,_gcgf :=range _cecff {if _gcgf =='\u000A'{continue ;};if _gcgf ==' '{if len (_dbcea )> 0{_fbde =append (_fbde ,_ga .MakeStringFromBytes (_dbcea ));
_dbcea =nil ;};_fbde =append (_fbde ,_ga .MakeFloat (-_cfbeb ));}else {if _ ,_bdea :=_bgdge .RuneToCharcode (_gcgf );!_bdea {_eegd =UnsupportedRuneError {Message :_gd .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_gcgf ,_gcgf ),Rune :_gcgf };
_gdcd ._ggag =append (_gdcd ._ggag ,_eegd );_f .Log .Debug (_eegd .Error ());if _gdcd ._ead <=0{continue ;};_gcgf =_gdcd ._ead ;};_dbcea =append (_dbcea ,_bgdge .Encode (string (_gcgf ))...);};};if len (_dbcea )> 0{_fbde =append (_fbde ,_ga .MakeStringFromBytes (_dbcea ));
};_aaad .Add_TJ (_fbde ...);};_aaad .Add_ET ();_aaad .Add_Q ();_dcce :=_aaad .Operations ();_dcce .WrapIfNeeded ();_abadb .addContents (_dcce );if _gafb ._eeea .IsRelative (){_bbbg :=_gafb .Height ()+_gafb ._aaec .Bottom ;_gdcd .Y +=_bbbg ;_gdcd .Height -=_bbbg ;
if _gdcd .Inline {_gdcd .X +=_gafb .Width ()+_gafb ._aaec .Right ;};};return _gdcd ,nil ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_dcb *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_dbdbad :=[2]*InvoiceCell {_dcb .newCell (description ,_dcb ._gggb ),_dcb .newCell (value ,_dcb ._gggb )};_dcb ._efgcg =append (_dcb ._efgcg ,_dbdbad );return _dbdbad [0],_dbdbad [1];
};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_feaf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_cddcg float64 ;_afdb uint ;_bada float64 ;_cedfd Positioning ;_cabec float64 ;_begf float64 ;_babaa int64 ;};

// SetBorderOpacity sets the border opacity.
func (_dbda *Rectangle )SetBorderOpacity (opacity float64 ){_dbda ._gaac =opacity };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// NewCellProps returns the default properties of an invoice cell.
func (_cgab *Invoice )NewCellProps ()InvoiceCellProps {_egab :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_cgab ._dfaef ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_egab ,BorderColor :_egab ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// NewPolygon creates a new polygon.
func (_edfa *Creator )NewPolygon (points [][]_a .Point )*Polygon {return _adba (points )};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_aeg []*_df .PdfPage ;_dcaf map[*_df .PdfPage ]*Block ;_fbef map[*_df .PdfPage ]_gf .Matrix ;_baf *_df .PdfPage ;_fgee PageSize ;_gfbg DrawContext ;_dcea Margins ;_fdad ,_bea float64 ;_baef int ;_bgfe func (_dfec FrontpageFunctionArgs );
_eab func (_dagg *TOC )error ;_ggc func (_fac *Block ,_cgg HeaderFunctionArgs );_fdfd func (_gdeb *Block ,_dada FooterFunctionArgs );_cfbde func (_cgba PageFinalizeFunctionArgs )error ;_beff func (_afg *_df .PdfWriter )error ;_egcda bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_ccff *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_ggbe *_df .Outline ;_bcfd *_df .PdfOutlineTreeNode ;_gcb *_df .PdfAcroForm ;_fdca _ga .PdfObject ;_cbfb _df .Optimizer ;_aabcc []*_df .PdfFont ;_cgd *_df .PdfFont ;_bfb *_df .PdfFont ;};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_edbb *Division )Width ()float64 {return 0};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_caa *Chapter )GetHeading ()*Paragraph {return _caa ._bbf };

// GetRowHeight returns the height of the specified row.
func (_caeb *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_caeb ._gbec ){return 0,_gb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _caeb ._gbec [row -1],nil ;
};

// SetColorBottom sets border color for bottom.
func (_dde *border )SetColorBottom (col Color ){_dde ._abfc =col };

// SetFont sets the Paragraph's font.
func (_bfda *Paragraph )SetFont (font *_df .PdfFont ){_bfda ._cdga =font };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_aec *Creator )AddPage (page *_df .PdfPage )error {_bdeb ,_cgdd :=page .GetMediaBox ();if _cgdd !=nil {_f .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_cgdd );
return _cgdd ;};_bdeb .Normalize ();_cecg ,_agaf :=_bdeb .Llx ,_bdeb .Lly ;_gcfg :=_gf .IdentityMatrix ();_ffb ,_cgdd :=page .GetRotate ();if _cgdd !=nil {_f .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_cgdd .Error ());
};_cagc :=_ffb %360!=0&&_ffb %90==0;if _cagc {_fcge :=float64 ((360+_ffb %360)%360);if _fcge ==90{_gcfg =_gcfg .Translate (_bdeb .Width (),0);}else if _fcge ==180{_gcfg =_gcfg .Translate (_bdeb .Width (),_bdeb .Height ());}else if _fcge ==270{_gcfg =_gcfg .Translate (0,_bdeb .Height ());
};_gcfg =_gcfg .Mult (_gf .RotationMatrix (_fcge *_b .Pi /180));_gcfg =_gcfg .Round (0.000001);_fed :=_gdfgc (_bdeb ,_gcfg );_bdeb =_fed ;_bdeb .Normalize ();};if _cecg !=0||_agaf !=0{_gcfg =_gf .TranslationMatrix (_cecg ,_agaf ).Mult (_gcfg );};if !_gcfg .Identity (){if _aec ._fbef ==nil {_aec ._fbef =map[*_df .PdfPage ]_gf .Matrix {};
};_gcfg =_gcfg .Round (0.000001);_aec ._fbef [page ]=_gcfg ;};_aec ._fdad =_bdeb .Width ();_aec ._bea =_bdeb .Height ();_aec .initContext ();_aec ._aeg =append (_aec ._aeg ,page );_aec ._gfbg .Page ++;return nil ;};

// Height returns the total height of all rows.
func (_cbffc *Table )Height ()float64 {_cabb :=float64 (0.0);for _ ,_affb :=range _cbffc ._gbec {_cabb +=_affb ;};return _cabb ;};func _eecb (_cbcfd *Table ,_abedb DrawContext )([]*Block ,DrawContext ,error ){var _dddb []*Block ;_cgeb :=NewBlock (_abedb .PageWidth ,_abedb .PageHeight );
_eacg :=_abedb ;if _cbcfd ._cbgc .IsAbsolute (){_abedb .X =_cbcfd ._begd ;_abedb .Y =_cbcfd ._fcfg ;}else {_abedb .X +=_cbcfd ._gbcf .Left ;_abedb .Y +=_cbcfd ._gbcf .Top ;_abedb .Width -=_cbcfd ._gbcf .Left +_cbcfd ._gbcf .Right ;_abedb .Height -=_cbcfd ._gbcf .Bottom +_cbcfd ._gbcf .Top ;
};_adcg :=_abedb .Width ;_bbee :=_abedb .X ;_cege :=_abedb .Y ;_abedb .Height =_abedb .PageHeight -_abedb .Y -_abedb .Margins .Bottom ;_cdfd :=_abedb .Height ;_acfac :=0;_adbff ,_aacg :=-1,-1;for _efdeb ,_ddda :=range _cbcfd ._deba {_caca :=_ddda .width (_cbcfd ._gegf ,_adcg );
if _cbcfd ._bgfac {if _ddda ._cddc >=_cbcfd ._fbbg &&_ddda ._cddc <=_cbcfd ._dbca {if _adbff < 0{_adbff =_efdeb ;};_aacg =_efdeb ;};};_cdegc :=_cbcfd ._gbec [_ddda ._cddc +_ddda ._eddgb -2];if _aaae :=_ddda .height (_caca );_aaae > _cdegc {_cbed :=_aaae /float64 (_ddda ._eddgb );
for _ddbf :=1;_ddbf <=_ddda ._eddgb ;_ddbf ++{if _cbed > _cbcfd ._gbec [_ddda ._cddc +_ddbf -2]{_cbcfd ._gbec [_ddda ._cddc +_ddbf -2]=_cbed ;};};};};var (_baaac bool ;_becd int ;_bgef int ;_bceb bool ;_egbbe int ;_gggc error ;);for _fefgd :=0;_fefgd < len (_cbcfd ._deba );
_fefgd ++{_aggfd :=_cbcfd ._deba [_fefgd ];_gcebb :=_aggfd .width (_cbcfd ._gegf ,_adcg );_aedc :=float64 (0.0);for _agaaf :=0;_agaaf < _aggfd ._bbdb -1;_agaaf ++{_aedc +=_cbcfd ._gegf [_agaaf ]*_adcg ;};_acec :=float64 (0.0);for _afdc :=_acfac ;_afdc < _aggfd ._cddc -1;
_afdc ++{_acec +=_cbcfd ._gbec [_afdc ];};_abedb .Height =_cdfd -_acec ;_feac :=float64 (0.0);for _fgdf :=0;_fgdf < _aggfd ._eddgb ;_fgdf ++{_feac +=_cbcfd ._gbec [_aggfd ._cddc +_fgdf -1];};_adebd :=_bceb &&_aggfd ._cddc !=_egbbe ;_egbbe =_aggfd ._cddc ;
if _adebd ||_feac > _abedb .Height {if _cbcfd ._ggafc &&!_bceb {_bceb ,_gggc =_cbcfd .wrapRow (_fefgd ,_abedb ,_adcg );if _gggc !=nil {return nil ,_abedb ,_gggc ;};if _bceb {_fefgd --;continue ;};};_dddb =append (_dddb ,_cgeb );_cgeb =NewBlock (_abedb .PageWidth ,_abedb .PageHeight );
_bbee =_abedb .Margins .Left ;_cege =_abedb .Margins .Top ;_abedb .Height =_abedb .PageHeight -_abedb .Margins .Top -_abedb .Margins .Bottom ;_abedb .Page ++;_cdfd =_abedb .Height ;_acfac =_aggfd ._cddc -1;_acec =0;_bceb =false ;if _cbcfd ._bgfac &&_adbff >=0{_becd =_fefgd ;
_fefgd =_adbff -1;_bgef =_acfac ;_acfac =_cbcfd ._fbbg -1;_baaac =true ;continue ;};if _adebd {_fefgd --;continue ;};};_abedb .Width =_gcebb ;_abedb .X =_bbee +_aedc ;_abedb .Y =_cege +_acec ;_cfgg :=_abb (_abedb .X ,_abedb .Y ,_gcebb ,_feac );if _aggfd ._bcgcg !=nil {_cfgg .SetFillColor (_aggfd ._bcgcg );
};_cfgg .LineStyle =_aggfd ._ccaed ;_cfgg ._ccd =_aggfd ._agbe ;_cfgg ._gdge =_aggfd ._becde ;_cfgg ._edf =_aggfd ._fada ;_cfgg ._fbba =_aggfd ._geag ;if _aggfd ._gcfa !=nil {_cfgg .SetColorLeft (_aggfd ._gcfa );};if _aggfd ._fadc !=nil {_cfgg .SetColorBottom (_aggfd ._fadc );
};if _aggfd ._aafc !=nil {_cfgg .SetColorRight (_aggfd ._aafc );};if _aggfd ._agef !=nil {_cfgg .SetColorTop (_aggfd ._agef );};_cfgg .SetWidthBottom (_aggfd ._gcdd );_cfgg .SetWidthLeft (_aggfd ._egfce );_cfgg .SetWidthRight (_aggfd ._ccbea );_cfgg .SetWidthTop (_aggfd ._cfaac );
_fcdg :=_cgeb .Draw (_cfgg );if _fcdg !=nil {_f .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcdg );};if _aggfd ._aabaf !=nil {_gdab :=_aggfd ._aabaf .Width ();_dddca :=_aggfd ._aabaf .Height ();_daed :=0.0;switch _ddaeg :=_aggfd ._aabaf .(type ){case *Paragraph :if _ddaeg ._bbdf {_gdab =_ddaeg .getMaxLineWidth ()/1000.0;
};_gdab +=_ddaeg ._aaec .Left +_ddaeg ._aaec .Right ;_dddca +=_ddaeg ._aaec .Top +_ddaeg ._aaec .Bottom ;case *StyledParagraph :if _ddaeg ._gafc {_gdab =_ddaeg .getMaxLineWidth ()/1000.0;};_abef ,_gdcbe ,_aadae :=_ddaeg .getLineMetrics (0);_gbfa ,_aebfd :=_abef *_ddaeg ._gccd ,_gdcbe *_ddaeg ._gccd ;
if _ddaeg ._bgdc ==TextVerticalAlignmentCenter {_daed =_aebfd -(_gdcbe +(_abef +_aadae -_gdcbe )/2+(_aebfd -_gdcbe )/2);};if len (_ddaeg ._fbdf )==1{_dddca =_gbfa ;}else {_dddca =_dddca -_aebfd +_gbfa ;};_daed +=_gbfa -_aebfd ;switch _aggfd ._ecabe {case CellVerticalAlignmentTop :_daed +=_gbfa *0.5;
case CellVerticalAlignmentBottom :_daed -=_gbfa *0.5;};_gdab +=_ddaeg ._gaaa .Left +_ddaeg ._gaaa .Right ;_dddca +=_ddaeg ._gaaa .Top +_ddaeg ._gaaa .Bottom ;case *Table :_gdab =_gcebb ;case *List :_gdab =_gcebb ;};switch _aggfd ._babff {case CellHorizontalAlignmentLeft :_abedb .X +=_aggfd ._dddg ;
_abedb .Width -=_aggfd ._dddg ;case CellHorizontalAlignmentCenter :if _bgdae :=_gcebb -_gdab ;_bgdae > 0{_abedb .X +=_bgdae /2;_abedb .Width -=_bgdae /2;};case CellHorizontalAlignmentRight :if _gcebb > _gdab {_abedb .X =_abedb .X +_gcebb -_gdab -_aggfd ._dddg ;
_abedb .Width -=_aggfd ._dddg ;};};_abedb .Y +=_daed ;switch _aggfd ._ecabe {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _gbfac :=_feac -_dddca ;_gbfac > 0{_abedb .Y +=_gbfac /2;_abedb .Height -=_gbfac /2;};case CellVerticalAlignmentBottom :if _feac > _dddca {_abedb .Y =_abedb .Y +_feac -_dddca ;
_abedb .Height =_feac ;};};_cadb :=_cgeb .DrawWithContext (_aggfd ._aabaf ,_abedb );if _cadb !=nil {_f .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cadb );};_abedb .Y -=_daed ;};_abedb .Y +=_feac ;_abedb .Height -=_feac ;if _baaac &&_fefgd +1> _aacg {_cege +=_acec +_feac ;
_cdfd -=_feac +_acec ;_acfac =_bgef ;_fefgd =_becd -1;_baaac =false ;};};_dddb =append (_dddb ,_cgeb );if _cbcfd ._cbgc .IsAbsolute (){return _dddb ,_eacg ,nil ;};_abedb .X =_eacg .X ;_abedb .Width =_eacg .Width ;_abedb .Y +=_cbcfd ._gbcf .Bottom ;_abedb .Height -=_cbcfd ._gbcf .Bottom ;
return _dddb ,_abedb ,nil ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_aaaa *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gaab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfcb :=_cd .NewContentCreator ();_dfcb .Add_q ().Add_w (_aaaa ._cgce ).SetStrokingColor (_ebaf (_aaaa ._ffea )).Add_m (_aaaa ._egbe ,ctx .PageHeight -_aaaa ._aafd ).Add_v (_aaaa ._fbfb ,ctx .PageHeight -_aaaa ._cggg ,_aaaa ._fbdc ,ctx .PageHeight -_aaaa ._badce ).Add_S ().Add_Q ();
_dfae :=_gaab .addContentsByString (_dfcb .String ());if _dfae !=nil {return nil ,ctx ,_dfae ;};return []*Block {_gaab },ctx ,nil ;};func _bde (_bdf *Chapter ,_dgc *TOC ,_ccbf *_df .Outline ,_edc string ,_dbfb int ,_gddf TextStyle )*Chapter {var _dga uint =1;
if _bdf !=nil {_dga =_bdf ._egcd +1;};_degb :=&Chapter {_ccb :_dbfb ,_dccb :_edc ,_baec :true ,_dcad :true ,_gbca :_bdf ,_daee :_dgc ,_fgf :_ccbf ,_eef :[]Drawable {},_egcd :_dga };_aabc :=_afdf (_degb .headingText (),_gddf );_aabc .SetFont (_gddf .Font );
_aabc .SetFontSize (_gddf .FontSize );_degb ._bbf =_aabc ;return _degb ;};func _fegd (_eac ,_gba ,_abcdc ,_bcfcd ,_fegc ,_cbfae float64 )*Curve {_gbgf :=&Curve {};_gbgf ._egbe =_eac ;_gbgf ._aafd =_gba ;_gbgf ._fbfb =_abcdc ;_gbgf ._cggg =_bcfcd ;_gbgf ._fbdc =_fegc ;
_gbgf ._badce =_cbfae ;_gbgf ._ffea =ColorBlack ;_gbgf ._cgce =1.0;return _gbgf ;};func (_abde *Paragraph )getTextWidth ()float64 {_adeb :=0.0;for _ ,_becg :=range _abde ._fagc {if _becg =='\u000A'{continue ;};_eefd ,_eadc :=_abde ._cdga .GetRuneMetrics (_becg );
if !_eadc {_f .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_becg ,_becg );
return -1;};_adeb +=_abde ._dgda *_eefd .Wx ;};return _adeb ;};func (_eddb *Invoice )setCellBorder (_effc *TableCell ,_dea *InvoiceCell ){for _ ,_cbfd :=range _dea .BorderSides {_effc .SetBorder (_cbfd ,CellBorderStyleSingle ,_dea .BorderWidth );};_effc .SetBorderColor (_dea .BorderColor );
};

// WriteToFile writes the Creator output to file specified by path.
func (_gdfe *Creator )WriteToFile (outputPath string )error {_cgbc ,_cfaa :=_gcf .Create (outputPath );if _cfaa !=nil {return _cfaa ;};defer _cgbc .Close ();return _gdfe .Write (_cgbc );};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_gdbd *Ellipse )GetCoords ()(float64 ,float64 ){return _gdbd ._aggf ,_gdbd ._gbd };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_fcda *StyledParagraph ;_agcg []*TOCLine ;_fagee TextStyle ;_befac TextStyle ;_fbga TextStyle ;_afaa TextStyle ;_acdeg string ;_egfb float64 ;_eebef Margins ;_ccgc Positioning ;_eagead TextStyle ;_becc bool ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_adgc *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_adgc ._bdbd .Left =left ;_adgc ._bdbd .Right =right ;_adgc ._bdbd .Top =top ;_adgc ._bdbd .Bottom =bottom ;};

// SetFillOpacity sets the fill opacity.
func (_edbbd *PolyBezierCurve )SetFillOpacity (opacity float64 ){_edbbd ._gcbf =opacity };

// SetNotes sets the notes section of the invoice.
func (_fbbag *Invoice )SetNotes (title ,content string ){_fbbag ._fgge =[2]string {title ,content }};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_cfggb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_cfggb ._ecabe =valign };func (_eec *Invoice )drawAddress (_gafe *InvoiceAddress )[]*StyledParagraph {var _bdgbg []*StyledParagraph ;if _gafe .Heading !=""{_cdaa :=_cabf (_eec ._bdacg );
_cdaa .SetMargins (0,0,0,7);_cdaa .Append (_gafe .Heading );_bdgbg =append (_bdgbg ,_cdaa );};_bgea :=_cabf (_eec ._cgdc );_bgea .SetLineHeight (1.2);_fccg :=_gafe .Separator ;if _fccg ==""{_fccg =_eec ._bbga ;};_egcc :=_gafe .City ;if _gafe .State !=""{if _egcc !=""{_egcc +=_fccg ;
};_egcc +=_gafe .State ;};if _gafe .Zip !=""{if _egcc !=""{_egcc +=_fccg ;};_egcc +=_gafe .Zip ;};if _gafe .Name !=""{_bgea .Append (_gafe .Name +"\u000a");};if _gafe .Street !=""{_bgea .Append (_gafe .Street +"\u000a");};if _gafe .Street2 !=""{_bgea .Append (_gafe .Street2 +"\u000a");
};if _egcc !=""{_bgea .Append (_egcc +"\u000a");};if _gafe .Country !=""{_bgea .Append (_gafe .Country +"\u000a");};_fbda :=_cabf (_eec ._cgdc );_fbda .SetLineHeight (1.2);_fbda .SetMargins (0,0,7,0);if _gafe .Phone !=""{_fbda .Append (_gafe .fmtLine (_gafe .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_gafe .HidePhoneLabel ));
};if _gafe .Email !=""{_fbda .Append (_gafe .fmtLine (_gafe .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_gafe .HideEmailLabel ));};_bdgbg =append (_bdgbg ,_bgea ,_fbda );return _bdgbg ;};func (_fddb *Creator )initContext (){_fddb ._gfbg .X =_fddb ._dcea .Left ;
_fddb ._gfbg .Y =_fddb ._dcea .Top ;_fddb ._gfbg .Width =_fddb ._fdad -_fddb ._dcea .Right -_fddb ._dcea .Left ;_fddb ._gfbg .Height =_fddb ._bea -_fddb ._dcea .Bottom -_fddb ._dcea .Top ;_fddb ._gfbg .PageHeight =_fddb ._bea ;_fddb ._gfbg .PageWidth =_fddb ._fdad ;
_fddb ._gfbg .Margins =_fddb ._dcea ;_fddb ._gfbg ._ead =_fddb .UnsupportedCharacterReplacement ;};func (_deab *Invoice )generateHeaderBlocks (_cafg DrawContext )([]*Block ,DrawContext ,error ){_bcgde :=_cabf (_deab ._fdea );_bcgde .SetEnableWrap (true );
_bcgde .Append (_deab ._eaaf );_edeb :=_gaca (2);if _deab ._dggb !=nil {_dbfbc :=_edeb .NewCell ();_dbfbc .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_dbfbc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_dbfbc .SetIndent (0);_dbfbc .SetContent (_deab ._dggb );
_deab ._dggb .ScaleToHeight (_bcgde .Height ()+20);}else {_edeb .SkipCells (1);};_fbbc :=_edeb .NewCell ();_fbbc .SetHorizontalAlignment (CellHorizontalAlignmentRight );_fbbc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fbbc .SetContent (_bcgde );
return _edeb .GeneratePageBlocks (_cafg );};

// SkipRows skips over a specified number of rows in the table.
func (_gbaed *Table )SkipRows (num int ){_cbaf :=num *_gbaed ._bdgf -1;if _cbaf < 0{_f .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gbaed ._agdbb +=_cbaf ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dbae *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dbae ._dcea .Left =left ;_dbae ._dcea .Right =right ;_dbae ._dcea .Top =top ;_dbae ._dcea .Bottom =bottom ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_cbfa :_b .Min (float64 (c ),100)/100.0,_bbc :_b .Min (float64 (m ),100)/100.0,_fcg :_b .Min (float64 (y ),100)/100.0,_aedf :_b .Min (float64 (k ),100)/100.0};};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_face *Creator )SetOutlineTree (outlineTree *_df .PdfOutlineTreeNode ){_face ._bcfd =outlineTree };

// SetWidth sets line width.
func (_fbed *Curve )SetWidth (width float64 ){_fbed ._cgce =width };

// NewChapter creates a new chapter with the specified title as the heading.
func (_ecb *Creator )NewChapter (title string )*Chapter {_ecb ._baef ++;_agda :=_ecb .NewTextStyle ();_agda .FontSize =16;return _bde (nil ,_ecb ._ccff ,_ecb ._ggbe ,title ,_ecb ._baef ,_agda );};

// SetBorderColor sets the border color.
func (_fdff *PolyBezierCurve )SetBorderColor (color Color ){_fdff ._gcff .BorderColor =_ebaf (color )};func (_ede *Block )addContents (_ba *_cd .ContentStreamOperations ){_ede ._gea .WrapIfNeeded ();_ba .WrapIfNeeded ();*_ede ._gea =append (*_ede ._gea ,*_ba ...);
};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ef *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcc :=_cd .NewContentCreator ();_ad ,_dfg :=_ef .Width (),_ef .Height ();if _ef ._ag .IsRelative (){_gcc .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_dfg );}else {_gcc .Translate (_ef ._ged ,ctx .PageHeight -_ef ._bc -_dfg );
};_ceg :=_dfg ;if _ef ._cb !=0{_gcc .Translate (_ad /2,_dfg /2);_gcc .RotateDeg (_ef ._cb );_gcc .Translate (-_ad /2,-_dfg /2);_ ,_ceg =_ef .RotatedSize ();};if _ef ._ag .IsRelative (){ctx .Y +=_ceg ;};_cbd :=_ef .duplicate ();_bgb :=append (*_gcc .Operations (),*_cbd ._gea ...);
_bgb .WrapIfNeeded ();_cbd ._gea =&_bgb ;return []*Block {_cbd },ctx ,nil ;};

// SetAngle sets the rotation angle of the text.
func (_ccbfa *StyledParagraph )SetAngle (angle float64 ){_ccbfa ._gcbgd =angle };

// SetFillColor sets the fill color.
func (_bccd *PolyBezierCurve )SetFillColor (color Color ){_bccd ._gcff .FillColor =_ebaf (color )};func _cgaaa (_ebdg [][]_a .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_gfg :&_a .CurvePolygon {Rings :_ebdg },_eddg :1.0,_gcec :1.0};};

// SetFillColor sets the fill color for the path.
func (_ebec *FilledCurve )SetFillColor (color Color ){_ebec ._ecge =color };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_fedf *Invoice )TotalLines ()[][2]*InvoiceCell {_gdgg :=[][2]*InvoiceCell {_fedf ._agegec };_gdgg =append (_gdgg ,_fedf ._edfd ...);return append (_gdgg ,_fedf ._cdb );};

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_efde *Table )EnableRowWrap (enable bool ){_efde ._ggafc =enable };

// Write output of creator to io.Writer interface.
func (_bedd *Creator )Write (ws _gbc .Writer )error {if _gda :=_bedd .Finalize ();_gda !=nil {return _gda ;};_fdg :=_df .NewPdfWriter ();_fdg .SetOptimizer (_bedd ._cbfb );if _bedd ._gcb !=nil {_gfe :=_fdg .SetForms (_bedd ._gcb );if _gfe !=nil {_f .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_gfe );
return _gfe ;};};if _bedd ._bcfd !=nil {_fdg .AddOutlineTree (_bedd ._bcfd );}else if _bedd ._ggbe !=nil &&_bedd .AddOutlines {_fdg .AddOutlineTree (&_bedd ._ggbe .ToPdfOutline ().PdfOutlineTreeNode );};if _bedd ._fdca !=nil {if _bbd :=_fdg .SetPageLabels (_bedd ._fdca );
_bbd !=nil {_f .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_bbd );return _bbd ;};};if _bedd ._aabcc !=nil {for _ ,_dgdc :=range _bedd ._aabcc {_bbcc :=_dgdc .SubsetRegistered ();
if _bbcc !=nil {_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_bbcc );return _bbcc ;};};};if _bedd ._beff !=nil {_agd :=_bedd ._beff (&_fdg );
if _agd !=nil {_f .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_agd );return _agd ;};};for _ ,_egbb :=range _bedd ._aeg {_eed :=_fdg .AddPage (_egbb );if _eed !=nil {_f .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_eed );
return _eed ;};};_bbcd :=_fdg .Write (ws );if _bbcd !=nil {return _bbcd ;};return nil ;};func (_abefc *TextChunk )clone ()*TextChunk {_fadca :=*_abefc ;_fadca ._gadd =_beefb (_abefc ._gadd );return &_fadca ;};type border struct{_cbab float64 ;_adcb float64 ;
_egg float64 ;_gbg float64 ;_gga Color ;_abgf Color ;_eda float64 ;_abfc Color ;_gdg float64 ;_gfc Color ;_ageb float64 ;_cdf Color ;_bcbad float64 ;LineStyle _a .LineStyle ;_ccd CellBorderStyle ;_gdge CellBorderStyle ;_edf CellBorderStyle ;_fbba CellBorderStyle ;
};func _gdgeb (_ddfae ,_cgbag ,_bffc ,_efbe float64 )*Rectangle {return &Rectangle {_bcfb :_ddfae ,_bfcd :_cgbag ,_aage :_bffc ,_ddeg :_efbe ,_baee :ColorBlack ,_edfac :1.0,_ddfa :1.0,_gaac :1.0};};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_edfb *StyledParagraph )SetText (text string )*TextChunk {_edfb .Reset ();return _edfb .Append (text );};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_fgga *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_fgga ._bdgf {_f .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _gb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fgga ._gegf =widths ;return nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dbgb *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _ddaf float64 ;var _adeg []*StyledParagraph ;for _ ,_gdfc :=range _dbgb ._eaga {_afge :=_cabf (_dbgb ._cddda );_afge .SetEnableWrap (false );_afge .SetTextAlignment (TextAlignmentRight );
_afge .Append (_gdfc ._aegc .Text ).Style =_gdfc ._aegc .Style ;_fged :=_afge .getTextWidth ()/1000.0/ctx .Width ;if _ddaf < _fged {_ddaf =_fged ;};_adeg =append (_adeg ,_afge );};_cagbf :=_gaca (2);_cagbf .SetColumnWidths (_ddaf ,1-_ddaf );_cagbf .SetMargins (_dbgb ._dfgb ,0,0,0);
for _cgea ,_beaf :=range _dbgb ._eaga {_efce :=_cagbf .NewCell ();_efce .SetIndent (0);_efce .SetContent (_adeg [_cgea ]);_efce =_cagbf .NewCell ();_efce .SetIndent (0);_efce .SetContent (_beaf ._cfec );};return _cagbf .GeneratePageBlocks (ctx );};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_abed *Creator )Draw (d Drawable )error {if _abed .getActivePage ()==nil {_abed .NewPage ();};_gaff ,_abad ,_dfge :=d .GeneratePageBlocks (_abed ._gfbg );if _dfge !=nil {return _dfge ;};if len (_abad ._ggag )> 0{_abed .Errors =append (_abed .Errors ,_abad ._ggag ...);
};for _gfba ,_dadg :=range _gaff {if _gfba > 0{_abed .NewPage ();};_efg :=_abed .getActivePage ();if _fga ,_fbc :=_abed ._dcaf [_efg ];_fbc {if _dac :=_fga .mergeBlocks (_dadg );_dac !=nil {return _dac ;};if _bbbc :=_gfb (_dadg ._da ,_fga ._da );_bbbc !=nil {return _bbbc ;
};}else {_abed ._dcaf [_efg ]=_dadg ;};};_abed ._gfbg .X =_abad .X ;_abed ._gfbg .Y =_abad .Y ;_abed ._gfbg .Height =_abad .PageHeight -_abad .Y -_abad .Margins .Bottom ;return nil ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_bagc *_a .Polygon ;_ffgf float64 ;_bggc float64 ;};

// SetFillColor sets the fill color.
func (_ebdd *Polygon )SetFillColor (color Color ){_ebdd ._bagc .FillColor =_ebaf (color )};func (_bbaf *TableCell )width (_bddd []float64 ,_fgaed float64 )float64 {_abgb :=float64 (0.0);for _cfff :=0;_cfff < _bbaf ._fcgce ;_cfff ++{_abgb +=_bddd [_bbaf ._bbdb +_cfff -1];
};return _abgb *_fgaed ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_ffdbf *TOC )SetShowLinks (showLinks bool ){_ffdbf ._becc =showLinks };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_aace *TOC )SetLineLevelOffset (levelOffset float64 ){_aace ._egfb =levelOffset };func (_cbgb *Paragraph )getTextLineWidth (_ggeg string )float64 {var _febf float64 ;for _ ,_beeag :=range _ggeg {if _beeag =='\u000A'{continue ;};_eggg ,_cbebe :=_cbgb ._cdga .GetRuneMetrics (_beeag );
if !_cbebe {_f .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_beeag ,_beeag );
return -1;};_febf +=_cbgb ._dgda *_eggg .Wx ;};return _febf ;};

// Height returns the Block's height.
func (_cgb *Block )Height ()float64 {return _cgb ._gca };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_bgdd *Invoice )Sections ()[][2]string {return _bgdd ._bcgd };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_cbfcd *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_cbcc :=&_cbfcd ._feaf ._gaaa ;return _cbfcd ._cddcg ,_cbcc .Right ,_cbcc .Top ,_cbcc .Bottom ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_ddcb *Division )Height ()float64 {var _ecefb float64 ;for _ ,_decg :=range _ddcb ._eaag {switch _fgae :=_decg .(type ){case marginDrawable :_ ,_ ,_gab ,_fcggd :=_fgae .GetMargins ();_ecefb +=_fgae .Height ()+_gab +_fcggd ;default:_ecefb +=_fgae .Height ();
};};return _ecefb ;};

// SetBorderOpacity sets the border opacity.
func (_fbebd *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_fbebd ._fgb =opacity };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_cabgb *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gedb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eafa ,_dcee :=_gedb .setOpacity (_cabgb ._ffgf ,_cabgb ._bggc );if _dcee !=nil {return nil ,ctx ,_dcee ;};_ggbc :=_cabgb ._bagc ;
_ggbc .FillEnabled =_ggbc .FillColor !=nil ;_ggbc .BorderEnabled =_ggbc .BorderColor !=nil &&_ggbc .BorderWidth > 0;_gagd :=_ggbc .Points ;for _acfad :=range _gagd {for _ffda :=range _gagd [_acfad ]{_adeed :=&_gagd [_acfad ][_ffda ];_adeed .Y =ctx .PageHeight -_adeed .Y ;
};};_ddae ,_ ,_dcee :=_ggbc .Draw (_eafa );if _dcee !=nil {return nil ,ctx ,_dcee ;};if _dcee =_gedb .addContentsByString (string (_ddae ));_dcee !=nil {return nil ,ctx ,_dcee ;};return []*Block {_gedb },ctx ,nil ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aeag *Creator )NewParagraph (text string )*Paragraph {return _afdf (text ,_aeag .NewTextStyle ())};

// Title returns the title of the invoice.
func (_gdcf *Invoice )Title ()string {return _gdcf ._eaaf };

// SetIndent sets the left offset of the list when nested into another list.
func (_bcgf *List )SetIndent (indent float64 ){_bcgf ._dfgb =indent ;_bcgf ._fecfb =false };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_defef *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_defef .Text },nil ;};var _fdef []string ;var _daegd []rune ;var _fecg float64 ;var _eaeaa []float64 ;_aafdb :=_defef .Style ;for _ ,_acgc :=range _defef .Text {if _acgc =='\u000A'{_fdef =append (_fdef ,_dc .TrimRightFunc (string (_daegd ),_bb .IsSpace )+string (_acgc ));
_daegd =nil ;_fecg =0;_eaeaa =nil ;continue ;};_ddbe :=_acgc ==' ';_ggdcg ,_gcddc :=_aafdb .Font .GetRuneMetrics (_acgc );if !_gcddc {_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_acgc ,_acgc ,_aafdb .Font .BaseFont (),_aafdb .Font .Subtype ());
_f .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_aafdb .Font );_f .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_aafdb .Font .Encoder ());return nil ,_gb .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_gdcde :=_aafdb .FontSize *_ggdcg .Wx ;_bdag :=_gdcde ;if !_ddbe {_bdag =_gdcde +_aafdb .CharSpacing *1000.0;};if _fecg +_gdcde > width *1000.0{_fdbe :=-1;if !_ddbe {for _fbbcf :=len (_daegd )-1;_fbbcf >=0;_fbbcf --{if _daegd [_fbbcf ]==' '{_fdbe =_fbbcf ;
break ;};};};_bbae :=string (_daegd );if _fdbe > 0{_bbae =string (_daegd [0:_fdbe +1]);_daegd =append (_daegd [_fdbe +1:],_acgc );_eaeaa =append (_eaeaa [_fdbe +1:],_bdag );_fecg =0;for _ ,_gbde :=range _eaeaa {_fecg +=_gbde ;};}else {if _ddbe {_daegd =[]rune {};
_eaeaa =[]float64 {};_fecg =0;}else {_daegd =[]rune {_acgc };_eaeaa =[]float64 {_bdag };_fecg =_bdag ;};};_fdef =append (_fdef ,_dc .TrimRightFunc (_bbae ,_bb .IsSpace ));}else {_daegd =append (_daegd ,_acgc );_fecg +=_bdag ;_eaeaa =append (_eaeaa ,_bdag );
};};if len (_daegd )> 0{_fdef =append (_fdef ,string (_daegd ));};return _fdef ,nil ;};func (_bffcg *StyledParagraph )getTextWidth ()float64 {var _bbec float64 ;_bfeeb :=len (_bffcg ._cccac );for _dgbc ,_gdfg :=range _bffcg ._cccac {_cgfc :=&_gdfg .Style ;
_aggc :=len (_gdfg .Text );for _bcbb ,_cgad :=range _gdfg .Text {if _cgad =='\u000A'{continue ;};_afdae ,_gbegg :=_cgfc .Font .GetRuneMetrics (_cgad );if !_gbegg {_f .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cgad );
return -1;};_bbec +=_cgfc .FontSize *_afdae .Wx *_cgfc .horizontalScale ();if _cgad !=' '&&(_dgbc !=_bfeeb -1||_bcbb !=_aggc -1){_bbec +=_cgfc .CharSpacing *1000.0;};};};return _bbec ;};func _gdfgc (_gceee *_df .PdfRectangle ,_ddfc _gf .Matrix )*_df .PdfRectangle {var _dced _df .PdfRectangle ;
_dced .Llx ,_dced .Lly =_ddfc .Transform (_gceee .Llx ,_gceee .Lly );_dced .Urx ,_dced .Ury =_ddfc .Transform (_gceee .Urx ,_gceee .Ury );_dced .Normalize ();return &_dced ;};

// SetBorderWidth sets the border width.
func (_ebeb *Rectangle )SetBorderWidth (bw float64 ){_ebeb ._edfac =bw };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};func _fdcf (_eaea ,_ccdc ,_fdbf ,_fece float64 )*Line {_fcdbe :=&Line {};
_fcdbe ._eccf =_eaea ;_fcdbe ._acbbf =_ccdc ;_fcdbe ._ceac =_fdbf ;_fcdbe ._bgda =_fece ;_fcdbe ._cccb =ColorBlack ;_fcdbe ._cgag =1.0;return _fcdbe ;};

// SkipOver skips over a specified number of rows and cols.
func (_gbag *Table )SkipOver (rows ,cols int ){_ebfa :=rows *_gbag ._bdgf +cols -1;if _ebfa < 0{_f .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gbag ._agdbb +=_ebfa ;};

// CreateFrontPage sets a function to generate a front Page.
func (_eabe *Creator )CreateFrontPage (genFrontPageFunc func (_cccd FrontpageFunctionArgs )){_eabe ._bgfe =genFrontPageFunc ;};

// SetMargins sets the Paragraph's margins.
func (_aeea *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_aeea ._gaaa .Left =left ;_aeea ._gaaa .Right =right ;_aeea ._gaaa .Top =top ;_aeea ._gaaa .Bottom =bottom ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// Indent returns the left offset of the list when nested into another list.
func (_bcag *List )Indent ()float64 {return _bcag ._dfgb };func (_ade *Chapter )headingText ()string {_dgcb :=_ade ._dccb ;if _bcc :=_ade .headingNumber ();_bcc !=""{_dgcb =_gd .Sprintf ("\u0025\u0073\u0020%\u0073",_bcc ,_dgcb );};return _dgcb ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_egae *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _egae ._caee .Left ,_egae ._caee .Right ,_egae ._caee .Top ,_egae ._caee .Bottom ;};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_cgbg *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _gdgeb (x ,y ,width ,height );};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_aeeg *Paragraph )Height ()float64 {_aeeg .wrapText ();return float64 (len (_aeeg ._bcbfc ))*_aeeg ._ffg *_aeeg ._dgda ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_fgde *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfef :=ctx ;var _fafd []*Block ;_eegb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fgde ._becgb .IsRelative (){ctx .X +=_fgde ._gaaa .Left ;ctx .Y +=_fgde ._gaaa .Top ;
ctx .Width -=_fgde ._gaaa .Left +_fgde ._gaaa .Right ;ctx .Height -=_fgde ._gaaa .Top +_fgde ._gaaa .Bottom ;_fgde .SetWidth (ctx .Width );}else {if int (_fgde ._cgfgd )<=0{_fgde .SetWidth (_fgde .getTextWidth ()/1000.0);};ctx .X =_fgde ._bbgg ;ctx .Y =_fgde ._gfcd ;
};if _fgde ._gfbfg !=nil {_fgde ._gfbfg (_fgde ,ctx );};if _cggf :=_fgde .wrapText ();_cggf !=nil {return nil ,ctx ,_cggf ;};_eegf :=_fgde ._fbdf ;for {_ffcg ,_cgde ,_dfde :=_edca (_eegb ,_fgde ,_eegf ,ctx );if _dfde !=nil {_f .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dfde );
return nil ,ctx ,_dfde ;};ctx =_ffcg ;_fafd =append (_fafd ,_eegb );if _eegf =_cgde ;len (_cgde )==0{break ;};_eegb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ffcg =ctx ;_ffcg .Y =ctx .Margins .Top ;_ffcg .X =ctx .Margins .Left +_fgde ._gaaa .Left ;
_ffcg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fgde ._gaaa .Bottom ;_ffcg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fgde ._gaaa .Left -_fgde ._gaaa .Right ;ctx =_ffcg ;};if _fgde ._becgb .IsRelative (){ctx .X -=_fgde ._gaaa .Left ;
ctx .Width =_bfef .Width ;return _fafd ,ctx ,nil ;};return _fafd ,_bfef ,nil ;};

// Append adds a new text chunk to the paragraph.
func (_bcab *StyledParagraph )Append (text string )*TextChunk {_agdag :=NewTextChunk (text ,_bcab ._fee );return _bcab .appendChunk (_agdag );};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_fdcd *Line )SetColor (col Color ){_fdcd ._cccb =col };

// SetSellerAddress sets the seller address of the invoice.
func (_bgcf *Invoice )SetSellerAddress (address *InvoiceAddress ){_bgcf ._beef =address };func (_abgfb *TextStyle )horizontalScale ()float64 {return _abgfb .HorizontalScaling /100};

// SkipCells skips over a specified number of cells in the table.
func (_gbab *Table )SkipCells (num int ){if num < 0{_f .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gbab ._agdbb +=num ;};

// String implements error interface.
func (_dcg UnsupportedRuneError )Error ()string {return _dcg .Message };

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_eagea *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_cbgec :=NewTextChunk (text ,_eagea ._fgffa );_cbgec ._gadd =_cddca (url );return _eagea .appendChunk (_cbgec );};func _cbbe ()*FilledCurve {_cbea :=FilledCurve {};_cbea ._cddd =[]_a .CubicBezierCurve {};
return &_cbea ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// SetFillOpacity sets the fill opacity.
func (_afdac *CurvePolygon )SetFillOpacity (opacity float64 ){_afdac ._eddg =opacity };

// SetStyleBottom sets border style for bottom side.
func (_acc *border )SetStyleBottom (style CellBorderStyle ){_acc ._fbba =style };

// SetMargins sets the margins of the paragraph.
func (_bfge *List )SetMargins (left ,right ,top ,bottom float64 ){_bfge ._caee .Left =left ;_bfge ._caee .Right =right ;_bfge ._caee .Top =top ;_bfge ._caee .Bottom =bottom ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;
HorizontalAlignmentRight ;);

// Context returns the current drawing context.
func (_abeb *Creator )Context ()DrawContext {return _abeb ._gfbg };

// SetText sets the text content of the Paragraph.
func (_bgbe *Paragraph )SetText (text string ){_bgbe ._fagc =text };

// MoveX moves the drawing context to absolute position x.
func (_ggee *Creator )MoveX (x float64 ){_ggee ._gfbg .X =x };func _beefb (_gbgec *_df .PdfAnnotation )*_df .PdfAnnotation {if _gbgec ==nil {return nil ;};var _egec *_df .PdfAnnotation ;switch _gcbfb :=_gbgec .GetContext ().(type ){case *_df .PdfAnnotationLink :if _cfccc :=_cgbd (_gcbfb );
_cfccc !=nil {_egec =_cfccc .PdfAnnotation ;};};return _egec ;};func (_dbe *Block )duplicate ()*Block {_fcd :=&Block {};*_fcd =*_dbe ;_ae :=_cd .ContentStreamOperations {};_ae =append (_ae ,*_dbe ._gea ...);_fcd ._gea =&_ae ;return _fcd ;};func _daedd (_bagff *_gcf .File )([]*_df .PdfPage ,error ){_ceggf ,_ccdcfa :=_df .NewPdfReader (_bagff );
if _ccdcfa !=nil {return nil ,_ccdcfa ;};_adffb ,_ccdcfa :=_ceggf .GetNumPages ();if _ccdcfa !=nil {return nil ,_ccdcfa ;};var _fadf []*_df .PdfPage ;for _aged :=0;_aged < _adffb ;_aged ++{_eaca ,_dabb :=_ceggf .GetPage (_aged +1);if _dabb !=nil {return nil ,_dabb ;
};_fadf =append (_fadf ,_eaca );};return _fadf ,nil ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ffd *Block )Draw (d Drawable )error {_ada :=DrawContext {};_ada .Width =_ffd ._fc ;_ada .Height =_ffd ._gca ;_ada .PageWidth =_ffd ._fc ;_ada .PageHeight =_ffd ._gca ;_ada .X =0;_ada .Y =0;_fg ,_ ,_agc :=d .GeneratePageBlocks (_ada );if _agc !=nil {return _agc ;
};if len (_fg )!=1{return _gb .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_bcf :=range _fg {if _fcc :=_ffd .mergeBlocks (_bcf );_fcc !=nil {return _fcc ;};};return nil ;
};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_ccb int ;_dccb string ;_bbf *Paragraph ;_eef []Drawable ;_cfe int ;_baec bool ;_dcad bool ;_cbc Positioning ;_bggb ,_baecd float64 ;_bdbd Margins ;_gbca *Chapter ;_daee *TOC ;_fgf *_df .Outline ;_dgb *_df .OutlineItem ;_egcd uint ;
};func (_cdbf *Paragraph )wrapText ()error {if !_cdbf ._bbdf ||int (_cdbf ._adgge )<=0{_cdbf ._bcbfc =[]string {_cdbf ._fagc };return nil ;};_gdcg :=NewTextChunk (_cdbf ._fagc ,TextStyle {Font :_cdbf ._cdga ,FontSize :_cdbf ._dgda });_fcbf ,_ggcd :=_gdcg .Wrap (_cdbf ._adgge );
if _ggcd !=nil {return _ggcd ;};if _cdbf ._eecf > 0&&len (_fcbf )> _cdbf ._eecf {_fcbf =_fcbf [:_cdbf ._eecf ];};_cdbf ._bcbfc =_fcbf ;return nil ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_caag *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _caag ._agegec [0],_caag ._agegec [1];};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_cfebb *TOCLine )SetLevelOffset (levelOffset float64 ){_cfebb ._bada =levelOffset ;_cfebb ._feaf ._gaaa .Left =_cfebb ._cddcg +float64 (_cfebb ._afdb -1)*_cfebb ._bada ;};

// NewImageFromFile creates an Image from a file.
func (_cbfg *Creator )NewImageFromFile (path string )(*Image ,error ){return _bgfg (path )};

// SetFillOpacity sets the fill opacity.
func (_ggca *Rectangle )SetFillOpacity (opacity float64 ){_ggca ._ddfa =opacity };

// SetInline sets the inline mode of the division.
func (_bggba *Division )SetInline (inline bool ){_bggba ._cbdd =inline };

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_adec *Paragraph )SetColor (col Color ){_adec ._ggbf =col };

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_bbab *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_bbab ._bgdc =align ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_fefc *Invoice )SetTerms (title ,content string ){_fefc ._edfda =[2]string {title ,content }};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_eaag []VectorDrawable ;_ecfb Positioning ;_ccbe Margins ;_cbdd bool ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_gece *StyledParagraph )SetEnableWrap (enableWrap bool ){_gece ._gafc =enableWrap ;_gece ._gbeb =false ;};

// SetFillColor sets the fill color.
func (_cada *CurvePolygon )SetFillColor (color Color ){_cada ._gfg .FillColor =_ebaf (color )};

// DrawHeader sets a function to draw a header on created output pages.
func (_gbb *Creator )DrawHeader (drawHeaderFunc func (_egbd *Block ,_dfa HeaderFunctionArgs )){_gbb ._ggc =drawHeaderFunc ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_gcbc *Invoice )SetAddressHeadingStyle (style TextStyle ){_gcbc ._bdacg =style };

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ebce *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _ebce ._aee [0],_ebce ._aee [1]};

// GetMargins returns the left, right, top, bottom Margins.
func (_cccc *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cccc ._gbcf .Left ,_cccc ._gbcf .Right ,_cccc ._gbcf .Top ,_cccc ._gbcf .Bottom ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_baca *Table )Width ()float64 {return 0};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_fba *Chapter )SetShowNumbering (show bool ){_fba ._baec =show ;_fba ._bbf .SetText (_fba .headingText ());};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// Height returns Image's document height.
func (_fega *Image )Height ()float64 {return _fega ._cbce };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_egbe float64 ;_aafd float64 ;_fbfb float64 ;_cggg float64 ;_fbdc float64 ;_badce float64 ;_ffea Color ;_cgce float64 ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_cfbdc *TOC )SetLineStyle (style TextStyle ){_cfbdc .SetLineNumberStyle (style );_cfbdc .SetLineTitleStyle (style );_cfbdc .SetLineSeparatorStyle (style );_cfbdc .SetLinePageStyle (style );};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_gcff *_a .PolyBezierCurve ;_gcbf float64 ;_fgb float64 ;};

// Text sets the text content of the Paragraph.
func (_eedc *Paragraph )Text ()string {return _eedc ._fagc };

// NewTable create a new Table with a specified number of columns.
func (_eeac *Creator )NewTable (cols int )*Table {return _gaca (cols )};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_fagc string ;_cdga *_df .PdfFont ;_dgda float64 ;_ffg float64 ;_ggbf Color ;_beaa TextAlignment ;_bbdf bool ;_adgge float64 ;_eecf int ;_daga bool ;_dfeag float64 ;_aaec Margins ;_eeea Positioning ;_eege float64 ;_facc float64 ;_dbfg ,_abeg float64 ;
_bcbfc []string ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_bbfb *Creator )NewStyledParagraph ()*StyledParagraph {return _cabf (_bbfb .NewTextStyle ())};func (_fbgde *Invoice )generateTotalBlocks (_fedab DrawContext )([]*Block ,DrawContext ,error ){_aade :=_gaca (4);_aade .SetMargins (0,0,10,10);_abbb :=[][2]*InvoiceCell {_fbgde ._agegec };
_abbb =append (_abbb ,_fbgde ._edfd ...);_abbb =append (_abbb ,_fbgde ._cdb );for _ ,_eeeg :=range _abbb {_acda ,_dfdd :=_eeeg [0],_eeeg [1];if _dfdd .Value ==""{continue ;};_aade .SkipCells (2);_gceb :=_aade .NewCell ();_gceb .SetBackgroundColor (_acda .BackgroundColor );
_gceb .SetHorizontalAlignment (_dfdd .Alignment );_fbgde .setCellBorder (_gceb ,_acda );_ggddb :=_cabf (_acda .TextStyle );_ggddb .SetMargins (0,0,2,1);_ggddb .Append (_acda .Value );_gceb .SetContent (_ggddb );_gceb =_aade .NewCell ();_gceb .SetBackgroundColor (_dfdd .BackgroundColor );
_gceb .SetHorizontalAlignment (_dfdd .Alignment );_fbgde .setCellBorder (_gceb ,_acda );_ggddb =_cabf (_dfdd .TextStyle );_ggddb .SetMargins (0,0,2,1);_ggddb .Append (_dfdd .Value );_gceb .SetContent (_ggddb );};return _aade .GeneratePageBlocks (_fedab );
};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_gbdff *Paragraph )SetWidth (width float64 ){_gbdff ._adgge =width ;_gbdff .wrapText ()};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_ffca *List )Marker ()*TextChunk {return &_ffca ._edab };func (_addf *Table )wrapRow (_daca int ,_edbbbg DrawContext ,_adbe float64 )(bool ,error ){if !_addf ._ggafc {return false ,nil ;};var (_eagb =_addf ._deba [_daca ];_cfage =-1;_dceeg []*TableCell ;
_abge float64 ;_bcgca bool ;_abega =make ([]float64 ,0,len (_addf ._gegf )););_ceeg :=func (_aagc *TableCell ,_cdage VectorDrawable ,_efcg bool )*TableCell {_dece :=*_aagc ;_dece ._aabaf =_cdage ;if _efcg {_dece ._cddc ++;};return &_dece ;};_bgca :=func (_egd int ,_agf VectorDrawable ){var _cffb float64 =-1;
if _agf ==nil {if _dfga :=_abega [_egd -_daca ];_dfga > _edbbbg .Height {_agf =_addf ._deba [_egd ]._aabaf ;_addf ._deba [_egd ]._aabaf =nil ;_abega [_egd -_daca ]=0;_cffb =_dfga ;};};_ecda :=_ceeg (_addf ._deba [_egd ],_agf ,true );_dceeg =append (_dceeg ,_ecda );
if _cffb < 0{_cffb =_ecda .height (_edbbbg .Width );};if _cffb > _abge {_abge =_cffb ;};};for _gdag :=_daca ;_gdag < len (_addf ._deba );_gdag ++{_cfcd :=_addf ._deba [_gdag ];if _eagb ._cddc !=_cfcd ._cddc {_cfage =_gdag ;break ;};_edbbbg .Width =_cfcd .width (_addf ._gegf ,_adbe );
var _ebea VectorDrawable ;switch _aedg :=_cfcd ._aabaf .(type ){case *StyledParagraph :if _dcdb :=_cfcd .height (_edbbbg .Width );_dcdb > _edbbbg .Height {_fbea :=_edbbbg ;_fbea .Height =_b .Floor (_edbbbg .Height -_aedg ._gaaa .Top -_aedg ._gaaa .Bottom -0.5*_aedg .getTextHeight ());
_ggbg ,_eced ,_eggff :=_aedg .split (_fbea );if _eggff !=nil {return false ,_eggff ;};if _ggbg !=nil &&_eced !=nil {_aedg =_ggbg ;_cfcd =_ceeg (_cfcd ,_ggbg ,false );_addf ._deba [_gdag ]=_cfcd ;_ebea =_eced ;_bcgca =true ;};};case *Division :if _fgeag :=_cfcd .height (_edbbbg .Width );
_fgeag > _edbbbg .Height {_egccf :=_edbbbg ;_egccf .Height =_b .Floor (_edbbbg .Height -_aedg ._ccbe .Top -_aedg ._ccbe .Bottom );_gcbfg ,_cgfad :=_aedg .split (_egccf );if _gcbfg !=nil &&_cgfad !=nil {_aedg =_gcbfg ;_cfcd =_ceeg (_cfcd ,_gcbfg ,false );
_addf ._deba [_gdag ]=_cfcd ;_ebea =_cgfad ;_bcgca =true ;};};};_abega =append (_abega ,_cfcd .height (_edbbbg .Width ));if _bcgca {if _dceeg ==nil {_dceeg =make ([]*TableCell ,0,len (_addf ._gegf ));for _bacg :=_daca ;_bacg < _gdag ;_bacg ++{_bgca (_bacg ,nil );
};};_bgca (_gdag ,_ebea );};};var _fddba float64 ;for _ ,_aegb :=range _abega {if _aegb > _fddba {_fddba =_aegb ;};};if _bcgca &&_fddba < _edbbbg .Height {if _cfage < 0{_cfage =len (_addf ._deba );};_bdad :=_addf ._deba [_cfage -1]._cddc +_addf ._deba [_cfage -1]._eddgb -1;
for _fbcf :=_cfage ;_fbcf < len (_addf ._deba );_fbcf ++{_addf ._deba [_fbcf ]._cddc ++;};_addf ._deba =append (_addf ._deba [:_cfage ],append (_dceeg ,_addf ._deba [_cfage :]...)...);_addf ._gbec =append (_addf ._gbec [:_bdad ],append ([]float64 {_abge },_addf ._gbec [_bdad :]...)...);
_addf ._gbec [_eagb ._cddc +_eagb ._eddgb -2]=_fddba ;};return _bcgca ,nil ;};func _adfd (_deda *_df .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_deda ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_bfab *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _fdcf (x1 ,y1 ,x2 ,y2 )};func _bcba (_cea *_cd .ContentStreamOperations ,_bfe *_df .PdfPageResources ,_bfee *_cd .ContentStreamOperations ,_dbf *_df .PdfPageResources )error {_dcae :=map[_ga .PdfObjectName ]_ga .PdfObjectName {};
_bad :=map[_ga .PdfObjectName ]_ga .PdfObjectName {};_bca :=map[_ga .PdfObjectName ]_ga .PdfObjectName {};_fe :=map[_ga .PdfObjectName ]_ga .PdfObjectName {};_ebd :=map[_ga .PdfObjectName ]_ga .PdfObjectName {};_dfb :=map[_ga .PdfObjectName ]_ga .PdfObjectName {};
for _ ,_ege :=range *_bfee {switch _ege .Operand {case "\u0044\u006f":if len (_ege .Params )==1{if _eea ,_efb :=_ege .Params [0].(*_ga .PdfObjectName );_efb {if _ ,_bcg :=_dcae [*_eea ];!_bcg {var _cbb _ga .PdfObjectName ;_bfc ,_ :=_dbf .GetXObjectByName (*_eea );
if _bfc !=nil {_cbb =*_eea ;for {_cae ,_ :=_bfe .GetXObjectByName (_cbb );if _cae ==nil ||_cae ==_bfc {break ;};_cbb =_cbb +"\u0030";};};_bfe .SetXObjectByName (_cbb ,_bfc );_dcae [*_eea ]=_cbb ;};_bcbf :=_dcae [*_eea ];_ege .Params [0]=&_bcbf ;};};case "\u0054\u0066":if len (_ege .Params )==2{if _aabf ,_adag :=_ege .Params [0].(*_ga .PdfObjectName );
_adag {if _ ,_gag :=_bad [*_aabf ];!_gag {_bfd ,_ddg :=_dbf .GetFontByName (*_aabf );_gcac :=*_aabf ;if _ddg &&_bfd !=nil {_gcac =_fec (_aabf .String (),_bfd ,_bfe );};_bfe .SetFontByName (_gcac ,_bfd );_bad [*_aabf ]=_gcac ;};_ecab :=_bad [*_aabf ];_ege .Params [0]=&_ecab ;
};};case "\u0043\u0053","\u0063\u0073":if len (_ege .Params )==1{if _dee ,_aed :=_ege .Params [0].(*_ga .PdfObjectName );_aed {if _ ,_edg :=_bca [*_dee ];!_edg {var _ccc _ga .PdfObjectName ;_bff ,_bfec :=_dbf .GetColorspaceByName (*_dee );if _bfec {_ccc =*_dee ;
for {_dbd ,_aba :=_bfe .GetColorspaceByName (_ccc );if !_aba ||_bff ==_dbd {break ;};_ccc =_ccc +"\u0030";};_bfe .SetColorspaceByName (_ccc ,_bff );_bca [*_dee ]=_ccc ;}else {_f .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");
};};if _aag ,_egc :=_bca [*_dee ];_egc {_ege .Params [0]=&_aag ;}else {_f .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_dee );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_ege .Params )==1{if _eeg ,_eff :=_ege .Params [0].(*_ga .PdfObjectName );_eff {if _ ,_fbg :=_fe [*_eeg ];!_fbg {var _gccf _ga .PdfObjectName ;_daa ,_acb :=_dbf .GetPatternByName (*_eeg );if _acb {_gccf =*_eeg ;
for {_cce ,_abf :=_bfe .GetPatternByName (_gccf );if !_abf ||_cce ==_daa {break ;};_gccf =_gccf +"\u0030";};_ece :=_bfe .SetPatternByName (_gccf ,_daa .ToPdfObject ());if _ece !=nil {return _ece ;};_fe [*_eeg ]=_gccf ;};};if _faa ,_aea :=_fe [*_eeg ];_aea {_ege .Params [0]=&_faa ;
};};};case "\u0073\u0068":if len (_ege .Params )==1{if _ecef ,_bcgg :=_ege .Params [0].(*_ga .PdfObjectName );_bcgg {if _ ,_gbe :=_ebd [*_ecef ];!_gbe {var _cdeg _ga .PdfObjectName ;_bef ,_age :=_dbf .GetShadingByName (*_ecef );if _age {_cdeg =*_ecef ;
for {_cfa ,_cec :=_bfe .GetShadingByName (_cdeg );if !_cec ||_bef ==_cfa {break ;};_cdeg =_cdeg +"\u0030";};_dfc :=_bfe .SetShadingByName (_cdeg ,_bef .ToPdfObject ());if _dfc !=nil {_f .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_dfc );
return _dfc ;};_ebd [*_ecef ]=_cdeg ;}else {_f .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _daf ,_eae :=_ebd [*_ecef ];_eae {_ege .Params [0]=&_daf ;}else {_f .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ecef );
};};};case "\u0067\u0073":if len (_ege .Params )==1{if _cag ,_afd :=_ege .Params [0].(*_ga .PdfObjectName );_afd {if _ ,_ecg :=_dfb [*_cag ];!_ecg {var _bcd _ga .PdfObjectName ;_bac ,_fef :=_dbf .GetExtGState (*_cag );if _fef {_bcd =*_cag ;_adc :=1;for {_ecf ,_dgdg :=_bfe .GetExtGState (_bcd );
if !_dgdg ||_bac ==_ecf {break ;};_bcd =_ga .PdfObjectName (_gd .Sprintf ("\u0047\u0053\u0025\u0064",_adc ));_adc ++;};};_bfe .AddExtGState (_bcd ,_bac );_dfb [*_cag ]=_bcd ;};_eba :=_dfb [*_cag ];_ege .Params [0]=&_eba ;};};};*_cea =append (*_cea ,_ege );
};return nil ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fbeb *Creator )MoveDown (dy float64 ){_fbeb ._gfbg .Y +=dy };

// SetBorderColor sets border color.
func (_bccc *Rectangle )SetBorderColor (col Color ){_bccc ._baee =col };func (_gdfde *Table )resetColumnWidths (){_gdfde ._gegf =[]float64 {};_ddafe :=float64 (1.0)/float64 (_gdfde ._bdgf );for _acag :=0;_acag < _gdfde ._bdgf ;_acag ++{_gdfde ._gegf =append (_gdfde ._gegf ,_ddafe );
};};func (_bba *Division )split (_bcbd DrawContext )(_fage ,_ceeef *Division ){var _cegg float64 ;var _eabb ,_afec []VectorDrawable ;for _aabcd ,_gdb :=range _bba ._eaag {_cegg +=_dbce (_gdb ,_bcbd .Width );if _cegg < _bcbd .Height {_eabb =append (_eabb ,_gdb );
}else {_afec =_bba ._eaag [_aabcd :];break ;};};if len (_eabb )> 0{_fage =_ddf ();_fage ._eaag =_eabb ;};if len (_afec )> 0{_ceeef =_ddf ();_ceeef ._eaag =_afec ;};return _fage ,_ceeef ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_eebff *Invoice )AddressHeadingStyle ()TextStyle {return _eebff ._beab };

// AddTotalLine adds a new line in the invoice totals table.
func (_acfd *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_feff :=&InvoiceCell {_acfd ._dfgf ,desc };_feb :=&InvoiceCell {_acfd ._dfgf ,value };_acfd ._edfd =append (_acfd ._edfd ,[2]*InvoiceCell {_feff ,_feb });return _feff ,_feb ;
};

// SetPos sets absolute positioning with specified coordinates.
func (_ddba *StyledParagraph )SetPos (x ,y float64 ){_ddba ._becgb =PositionAbsolute ;_ddba ._bbgg =x ;_ddba ._gfcd =y ;};func _fedabf (_egea []_a .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_gcff :&_a .PolyBezierCurve {Curves :_egea ,BorderColor :_df .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_gcbf :1.0,_fgb :1.0};
};

// NewTOCLine creates a new table of contents line with the default style.
func (_dege *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _fccf (number ,title ,page ,level ,_dege .NewTextStyle ());};func (_cgaad *Invoice )newColumn (_cdaca string ,_bgee CellHorizontalAlignment )*InvoiceCell {_fffa :=&InvoiceCell {_cgaad ._gaffd ,_cdaca };
_fffa .Alignment =_bgee ;return _fffa ;};func (_efaca *StyledParagraph )getTextLineWidth (_beabg []*TextChunk )float64 {var _abdbg float64 ;_adddb :=len (_beabg );for _fccc ,_fgaf :=range _beabg {_gfcac :=&_fgaf .Style ;_cbebf :=len (_fgaf .Text );for _adegc ,_afagg :=range _fgaf .Text {if _afagg =='\u000A'{continue ;
};_gbda ,_fdfffa :=_gfcac .Font .GetRuneMetrics (_afagg );if !_fdfffa {_f .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_afagg );
return -1;};_abdbg +=_gfcac .FontSize *_gbda .Wx *_gfcac .horizontalScale ();if _afagg !=' '&&(_fccc !=_adddb -1||_adegc !=_cbebf -1){_abdbg +=_gfcac .CharSpacing *1000.0;};};};return _abdbg ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_aga *Block )SetMargins (left ,right ,top ,bottom float64 ){_aga ._bcb .Left =left ;_aga ._bcb .Right =right ;_aga ._bcb .Top =top ;_aga ._bcb .Bottom =bottom ;};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_ceff *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fbece :=_a .Line {LineWidth :_ceff ._cgag ,Opacity :1.0,LineColor :_ebaf (_ceff ._cccb ),LineEndingStyle1 :_a .LineEndingStyleNone ,LineEndingStyle2 :_a .LineEndingStyleNone ,X1 :_ceff ._eccf ,Y1 :ctx .PageHeight -_ceff ._acbbf ,X2 :_ceff ._ceac ,Y2 :ctx .PageHeight -_ceff ._bgda };
_fdgg ,_ ,_efd :=_fbece .Draw ("");if _efd !=nil {return nil ,ctx ,_efd ;};_efd =_efca .addContentsByString (string (_fdgg ));if _efd !=nil {return nil ,ctx ,_efd ;};return []*Block {_efca },ctx ,nil ;};func _cddca (_adddf string )*_df .PdfAnnotation {_gegg :=_df .NewPdfAnnotationLink ();
_begb :=_df .NewBorderStyle ();_begb .SetBorderWidth (0);_gegg .BS =_begb .ToPdfObject ();_ccce :=_df .NewPdfActionURI ();_ccce .URI =_ga .MakeString (_adddf );_gegg .SetAction (_ccce .PdfAction );return _gegg .PdfAnnotation ;};func (_cagb *Division )ctxHeight (_ddb float64 )float64 {var _daeg float64 ;
for _ ,_aebc :=range _cagb ._eaag {_daeg +=_dbce (_aebc ,_ddb );};return _daeg ;};

// SetBorderOpacity sets the border opacity.
func (_aefg *CurvePolygon )SetBorderOpacity (opacity float64 ){_aefg ._gcec =opacity };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func (_abbac *StyledParagraph )wrapChunks (_fdgga bool )error {if !_abbac ._gafc ||int (_abbac ._cgfgd )<=0{_abbac ._fbdf =[][]*TextChunk {_abbac ._cccac };return nil ;};_abbac ._fbdf =[][]*TextChunk {};var _bfaa []*TextChunk ;var _gdbdb float64 ;
_affc :=_bb .IsSpace ;if !_fdgga {_affc =func (rune )bool {return false };};for _ ,_aaaac :=range _abbac ._cccac {_abdf :=_aaaac .Style ;_gfdf :=_aaaac ._gadd ;var (_gbge []rune ;_accgb []float64 ;);for _ ,_ccfd :=range _aaaac .Text {if _ccfd =='\u000A'{if !_fdgga {_gbge =append (_gbge ,_ccfd );
};_bfaa =append (_bfaa ,&TextChunk {Text :_dc .TrimRightFunc (string (_gbge ),_affc ),Style :_abdf ,_gadd :_beefb (_gfdf )});_abbac ._fbdf =append (_abbac ._fbdf ,_bfaa );_bfaa =nil ;_gdbdb =0;_gbge =nil ;_accgb =nil ;continue ;};_ecbb :=_ccfd ==' ';_bcabc ,_agdf :=_abdf .Font .GetRuneMetrics (_ccfd );
if !_agdf {_f .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ccfd );return _gb .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_dbebd :=_abdf .FontSize *_bcabc .Wx *_abdf .horizontalScale ();_eebe :=_dbebd ;if !_ecbb {_eebe =_dbebd +_abdf .CharSpacing *1000.0;};if _gdbdb +_dbebd > _abbac ._cgfgd *1000.0{_dgcg :=-1;if !_ecbb {for _gabg :=len (_gbge )-1;_gabg >=0;_gabg --{if _gbge [_gabg ]==' '{_dgcg =_gabg ;
break ;};};};_ebff :=string (_gbge );if _dgcg >=0{_ebff =string (_gbge [0:_dgcg +1]);_gbge =_gbge [_dgcg +1:];_gbge =append (_gbge ,_ccfd );_accgb =_accgb [_dgcg +1:];_accgb =append (_accgb ,_eebe );_gdbdb =0;for _ ,_dgad :=range _accgb {_gdbdb +=_dgad ;
};}else {if _ecbb {_gdbdb =0;_gbge =[]rune {};_accgb =[]float64 {};}else {_gdbdb =_eebe ;_gbge =[]rune {_ccfd };_accgb =[]float64 {_eebe };};};if !_fdgga &&_ecbb {_ebff +="\u0020";};_bfaa =append (_bfaa ,&TextChunk {Text :_dc .TrimRightFunc (_ebff ,_affc ),Style :_abdf ,_gadd :_beefb (_gfdf )});
_abbac ._fbdf =append (_abbac ._fbdf ,_bfaa );_bfaa =[]*TextChunk {};}else {_gdbdb +=_eebe ;_gbge =append (_gbge ,_ccfd );_accgb =append (_accgb ,_eebe );};};if len (_gbge )> 0{_bfaa =append (_bfaa ,&TextChunk {Text :string (_gbge ),Style :_abdf ,_gadd :_beefb (_gfdf )});
};};if len (_bfaa )> 0{_abbac ._fbdf =append (_abbac ._fbdf ,_bfaa );};return nil ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_abebb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _fefaa (number ,title ,page ,level ,style );};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_eg *Block )ScaleToWidth (w float64 ){_fa :=w /_eg ._fc ;_eg .Scale (_fa ,_fa )};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_adaf *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _adaf ._eccf ,_adaf ._acbbf ,_adaf ._ceac ,_adaf ._bgda ;};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// SetOpacity sets opacity for Image.
func (_cefd *Image )SetOpacity (opacity float64 ){_cefd ._dcade =opacity };

// BuyerAddress returns the buyer address used in the invoice template.
func (_bece *Invoice )BuyerAddress ()*InvoiceAddress {return _bece ._gdeg };const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);

// SetColor sets the line color.
func (_gcbac *Curve )SetColor (col Color ){_gcbac ._ffea =col };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_beea *Creator )EnableFontSubsetting (font *_df .PdfFont ){_beea ._aabcc =append (_beea ._aabcc ,font );};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_gea *_cd .ContentStreamOperations ;_da *_df .PdfPageResources ;_ag Positioning ;_ged ,_bc float64 ;_fc float64 ;_gca float64 ;_cb float64 ;_bcb Margins ;_dd []*_df .PdfAnnotation ;};

// AppendColumn appends a column to the line items table.
func (_gdba *Invoice )AppendColumn (description string )*InvoiceCell {_dgee :=_gdba .NewColumn (description );_gdba ._bgdg =append (_gdba ._bgdg ,_dgee );return _dgee ;};func _cfcg (_deff int64 ,_dgcgd ,_gffg ,_edfcb float64 )*_df .PdfAnnotation {_cccf :=_df .NewPdfAnnotationLink ();
_acae :=_df .NewBorderStyle ();_acae .SetBorderWidth (0);_cccf .BS =_acae .ToPdfObject ();if _deff < 0{_deff =0;};_cccf .Dest =_ga .MakeArray (_ga .MakeInteger (_deff ),_ga .MakeName ("\u0058\u0059\u005a"),_ga .MakeFloat (_dgcgd ),_ga .MakeFloat (_gffg ),_ga .MakeFloat (_edfcb ));
return _cccf .PdfAnnotation ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_fbbcd *TOC )SetLinePageStyle (style TextStyle ){_fbbcd ._afaa =style };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_bade *Creator )NewPolyBezierCurve (curves []_a .CubicBezierCurve )*PolyBezierCurve {return _fedabf (curves );};func (_fbdg *Invoice )drawSection (_bbgae ,_fcaga string )[]*StyledParagraph {var _ebbe []*StyledParagraph ;if _bbgae !=""{_caab :=_cabf (_fbdg ._afce );
_caab .SetMargins (0,0,0,5);_caab .Append (_bbgae );_ebbe =append (_ebbe ,_caab );};if _fcaga !=""{_bgba :=_cabf (_fbdg ._abag );_bgba .Append (_fcaga );_ebbe =append (_ebbe ,_bgba );};return _ebbe ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_abbacf *Table )NewCell ()*TableCell {return _abbacf .MultiCell (1,1)};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;func (_gdfd *Image )rotatedSize ()(float64 ,float64 ){_ffae :=_gdfd ._ggfg ;_gded :=_gdfd ._cbce ;_gbfe :=_gdfd ._abdb ;if _gbfe ==0{return _ffae ,_gded ;};_efgc :=_a .Path {Points :[]_a .Point {_a .NewPoint (0,0).Rotate (_gbfe ),_a .NewPoint (_ffae ,0).Rotate (_gbfe ),_a .NewPoint (0,_gded ).Rotate (_gbfe ),_a .NewPoint (_ffae ,_gded ).Rotate (_gbfe )}}.GetBoundingBox ();
return _efgc .Width ,_efgc .Height ;};type cmykColor struct{_cbfa ,_bbc ,_fcg ,_aedf float64 };func _cabg (_beac *Block ,_cabe *Image ,_fdada DrawContext )(DrawContext ,error ){_adbb :=_fdada ;_ggad :=1;_dgaf :=_ga .PdfObjectName (_gd .Sprintf ("\u0049\u006d\u0067%\u0064",_ggad ));
for _beac ._da .HasXObjectByName (_dgaf ){_ggad ++;_dgaf =_ga .PdfObjectName (_gd .Sprintf ("\u0049\u006d\u0067%\u0064",_ggad ));};_dgcf :=_beac ._da .SetXObjectImageByName (_dgaf ,_cabe ._gcgc );if _dgcf !=nil {return _fdada ,_dgcf ;};_gbdf :=0;_gbae :=_ga .PdfObjectName (_gd .Sprintf ("\u0047\u0053\u0025\u0064",_gbdf ));
for _beac ._da .HasExtGState (_gbae ){_gbdf ++;_gbae =_ga .PdfObjectName (_gd .Sprintf ("\u0047\u0053\u0025\u0064",_gbdf ));};_cfce :=_ga .MakeDict ();_cfce .Set ("\u0042\u004d",_ga .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _cabe ._dcade < 1.0{_cfce .Set ("\u0043\u0041",_ga .MakeFloat (_cabe ._dcade ));
_cfce .Set ("\u0063\u0061",_ga .MakeFloat (_cabe ._dcade ));};_dgcf =_beac ._da .AddExtGState (_gbae ,_ga .MakeIndirectObject (_cfce ));if _dgcf !=nil {return _fdada ,_dgcf ;};_ccca :=_cabe .Width ();_aggg :=_cabe .Height ();_ ,_cbbc :=_cabe .rotatedSize ();
_acg :=_fdada .X ;_gccc :=_fdada .PageHeight -_fdada .Y -_aggg ;if _cabe ._fgfe .IsRelative (){_gccc -=(_cbbc -_aggg )/2;switch _cabe ._fae {case HorizontalAlignmentCenter :_acg +=(_fdada .Width -_ccca )/2;case HorizontalAlignmentRight :_acg =_fdada .PageWidth -_fdada .Margins .Right -_cabe ._afgb .Right -_ccca ;
};};_acde :=_cabe ._abdb ;_bdac :=_cd .NewContentCreator ();_bdac .Add_gs (_gbae );_bdac .Translate (_acg ,_gccc );if _acde !=0{_bdac .Translate (_ccca /2,_aggg /2);_bdac .RotateDeg (_acde );_bdac .Translate (-_ccca /2,-_aggg /2);};_bdac .Scale (_ccca ,_aggg ).Add_Do (_dgaf );
_dbag :=_bdac .Operations ();_dbag .WrapIfNeeded ();_beac .addContents (_dbag );if _cabe ._fgfe .IsRelative (){_fdada .Y +=_cbbc ;_fdada .Height -=_cbbc ;return _fdada ,nil ;};return _adbb ,nil ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bdec *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _bdec ._gfea [0],_bdec ._gfea [1]};func _fefaa (_fdcdd ,_agegc ,_eafc TextChunk ,_baeg uint ,_fdfcc TextStyle )*TOCLine {_caddc :=_cabf (_fdfcc );_caddc .SetEnableWrap (true );_caddc .SetTextAlignment (TextAlignmentLeft );
_caddc .SetMargins (0,0,2,2);_egad :=&TOCLine {_feaf :_caddc ,Number :_fdcdd ,Title :_agegc ,Page :_eafc ,Separator :TextChunk {Text :"\u002e",Style :_fdfcc },_cddcg :0,_afdb :_baeg ,_bada :10,_cedfd :PositionRelative };_caddc ._gaaa .Left =_egad ._cddcg +float64 (_egad ._afdb -1)*_egad ._bada ;
_caddc ._gfbfg =_egad .prepareParagraph ;return _egad ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_fgfb *StyledParagraph )SetWidth (width float64 ){_fgfb ._cgfgd =width ;_fgfb .wrapText ()};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);
ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););func _cgbd (_abaad *_df .PdfAnnotationLink )*_df .PdfAnnotationLink {if _abaad ==nil {return nil ;};_beeae :=_df .NewPdfAnnotationLink ();_beeae .BS =_abaad .BS ;_beeae .A =_abaad .A ;
if _fade ,_cbde :=_abaad .GetAction ();_cbde ==nil &&_fade !=nil {_beeae .SetAction (_fade );};if _cfbf ,_cdab :=_abaad .Dest .(*_ga .PdfObjectArray );_cdab {_beeae .Dest =_ga .MakeArray (_cfbf .Elements ()...);};return _beeae ;};

// SetAngle sets the rotation angle in degrees.
func (_bf *Block )SetAngle (angleDeg float64 ){_bf ._cb =angleDeg };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_dgaaf *Image )ScaleToHeight (h float64 ){_cagbb :=_dgaaf ._ggfg /_dgaaf ._cbce ;_dgaaf ._cbce =h ;_dgaaf ._ggfg =h *_cagbb ;};func (_fcaf rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _fcaf ._gcca ,_fcaf ._adab ,_fcaf ._ccfe ;};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_eccf float64 ;_acbbf float64 ;_ceac float64 ;_bgda float64 ;_cccb Color ;_cgag float64 ;};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_bceg *Table )MultiCell (rowspan ,colspan int )*TableCell {_bceg ._agdbb ++;_fbdb :=(_bceg .moveToNextAvailableCell ()-1)%(_bceg ._bdgf )+1;_gdbgb :=(_bceg ._agdbb -1)/_bceg ._bdgf +1;for _gdbgb > _bceg ._cead {_bceg ._cead ++;_bceg ._gbec =append (_bceg ._gbec ,_bceg ._gabeb );
};_cbfde :=&TableCell {};_cbfde ._cddc =_gdbgb ;_cbfde ._bbdb =_fbdb ;_cbfde ._dddg =5;_cbfde ._agbe =CellBorderStyleNone ;_cbfde ._ccaed =_a .LineStyleSolid ;_cbfde ._babff =CellHorizontalAlignmentLeft ;_cbfde ._ecabe =CellVerticalAlignmentTop ;_cbfde ._egfce =0;
_cbfde ._gcdd =0;_cbfde ._ccbea =0;_cbfde ._cfaac =0;_cebg :=ColorBlack ;_cbfde ._gcfa =_cebg ;_cbfde ._fadc =_cebg ;_cbfde ._aafc =_cebg ;_cbfde ._agef =_cebg ;if rowspan < 1{_f .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_faccg :=_bceg ._cead -(_cbfde ._cddc -1);if rowspan > _faccg {_f .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_faccg );
_bceg ._cead +=rowspan -1;for _fgbdb :=0;_fgbdb <=rowspan -_faccg ;_fgbdb ++{_bceg ._gbec =append (_bceg ._gbec ,_bceg ._gabeb );};};for _cgbf :=0;_cgbf < colspan &&_fbdb +_cgbf -1< len (_bceg ._cbfc );_cgbf ++{_bceg ._cbfc [_fbdb +_cgbf -1]=rowspan -1;
};_cbfde ._eddgb =rowspan ;if colspan < 1{_f .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_gfbe :=_bceg ._bdgf -(_cbfde ._bbdb -1);if colspan > _gfbe {_f .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_gfbe );
colspan =_gfbe ;};_cbfde ._fcgce =colspan ;_bceg ._agdbb +=colspan -1;_bceg ._deba =append (_bceg ._deba ,_cbfde );_cbfde ._gccda =_bceg ;return _cbfde ;};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_bbb *Creator )PageFinalize (pageFinalizeFunc func (_abe PageFinalizeFunctionArgs )error ){_bbb ._cfbde =pageFinalizeFunc ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_eaef *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _gb .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _gb .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _gb .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_eaef ._bgfac =true ;_eaef ._fbbg =startRow ;_eaef ._dbca =endRow ;return nil ;};

// SetAngle sets the rotation angle of the text.
func (_gfbb *Paragraph )SetAngle (angle float64 ){_gfbb ._dfeag =angle };