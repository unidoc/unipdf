//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_aa "bytes";_gg "crypto/aes";_c "crypto/cipher";_ae "crypto/md5";_cf "crypto/rand";_fa "crypto/rc4";_ca "crypto/sha256";_ge "crypto/sha512";_e "encoding/binary";_f "errors";_fg "fmt";_be "github.com/unidoc/unipdf/v4/common";_g "hash";
_b "io";_ef "math";);func (_dc *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dc ._efd !=0{_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_be .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_dc ._ga .Encrypt (dst ,src [:_dc ._efd ]);src =src [_dc ._efd :];dst =dst [_dc ._efd :];};};func (_eef stdHandlerR4 )alg3Key (R int ,_cbg []byte )[]byte {_bb :=_ae .New ();_ad :=_eef .paddedPass (_cbg );_bb .Write (_ad );if R >=3{for _gc :=0;
_gc < 50;_gc ++{_db :=_bb .Sum (nil );_bb =_ae .New ();_bb .Write (_db );};};_ceg :=_bb .Sum (nil );if R ==2{_ceg =_ceg [0:5];}else {_ceg =_ceg [0:_eef .Length /8];};return _ceg ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fgg stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bbd :=_fgg .alg3 (d .R ,upass ,opass );if _bbd !=nil {_be .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bbd );
return nil ,_bbd ;};d .O =O ;_be .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_bdb :=_fgg .alg2 (d ,upass );U ,_bbd :=_fgg .alg5 (_bdb ,upass );if _bbd !=nil {_be .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bbd );
return nil ,_bbd ;};d .U =U ;_be .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _bdb ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_dg stdHandlerR4 )alg3 (R int ,_geed ,_eec []byte )([]byte ,error ){var _ba []byte ;if len (_eec )> 0{_ba =_dg .alg3Key (R ,_eec );}else {_ba =_dg .alg3Key (R ,_geed );};_cc ,_cfg :=_fa .NewCipher (_ba );if _cfg !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dd :=_dg .paddedPass (_geed );_bgd :=make ([]byte ,len (_dd ));_cc .XORKeyStream (_bgd ,_dd );if R >=3{_fe :=make ([]byte ,len (_ba ));for _cbe :=0;_cbe < 19;_cbe ++{for _fd :=0;_fd < len (_ba );_fd ++{_fe [_fd ]=_ba [_fd ]^byte (_cbe +1);};_ggag ,_ab :=_fa .NewCipher (_fe );
if _ab !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ggag .XORKeyStream (_bgd ,_bgd );};};return _bgd ,nil ;};func _fc (_bg ,_cfd string ,_ee int ,_gee []byte )error {if len (_gee )< _ee {return errInvalidField {Func :_bg ,Field :_cfd ,Exp :_ee ,Got :len (_gee )};
};return nil ;};func (_ag *ecbEncrypter )BlockSize ()int {return _ag ._efd };func (_gf *ecbDecrypter )BlockSize ()int {return _gf ._efd };

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type stdHandlerR6 struct{};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_caff stdHandlerR6 )alg8 (_dace *StdEncryptDict ,_gfbf []byte ,_cbeb []byte )error {if _gffb :=_fc ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gfbf );
_gffb !=nil {return _gffb ;};var _cgd [16]byte ;if _ ,_gac :=_b .ReadFull (_cf .Reader ,_cgd [:]);_gac !=nil {return _gac ;};_bbdgc :=_cgd [0:8];_fbag :=_cgd [8:16];_aaad :=make ([]byte ,len (_cbeb )+len (_bbdgc ));_af :=copy (_aaad ,_cbeb );copy (_aaad [_af :],_bbdgc );
_dfg ,_dde :=_caff .alg2b (_dace .R ,_aaad ,_cbeb ,nil );if _dde !=nil {return _dde ;};U :=make ([]byte ,len (_dfg )+len (_bbdgc )+len (_fbag ));_af =copy (U ,_dfg [:32]);_af +=copy (U [_af :],_bbdgc );copy (U [_af :],_fbag );_dace .U =U ;_af =len (_cbeb );
copy (_aaad [_af :],_fbag );_dfg ,_dde =_caff .alg2b (_dace .R ,_aaad ,_cbeb ,nil );if _dde !=nil {return _dde ;};_beb ,_dde :=_geg (_dfg [:32]);if _dde !=nil {return _dde ;};_beaa :=make ([]byte ,_gg .BlockSize );_abd :=_c .NewCBCEncrypter (_beb ,_beaa );
UE :=make ([]byte ,32);_abd .CryptBlocks (UE ,_gfbf [:32]);_dace .UE =UE ;return nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _bbda (_bfa []byte )([]byte ,error ){_dcgb :=_ca .New ();_dcgb .Write (_bfa );return _dcgb .Sum (nil ),nil ;};type ecbDecrypter ecb ;func (_dbf stdHandlerR6 )alg12 (_fgge *StdEncryptDict ,_bgf []byte )([]byte ,error ){if _cfge :=_fc ("\u0061\u006c\u00671\u0032","\u0055",48,_fgge .U );
_cfge !=nil {return nil ,_cfge ;};if _aaaaf :=_fc ("\u0061\u006c\u00671\u0032","\u004f",48,_fgge .O );_aaaaf !=nil {return nil ,_aaaaf ;};_afc :=make ([]byte ,len (_bgf )+8+48);_bec :=copy (_afc ,_bgf );_bec +=copy (_afc [_bec :],_fgge .O [32:40]);_bec +=copy (_afc [_bec :],_fgge .U [0:48]);
_gce ,_aff :=_dbf .alg2b (_fgge .R ,_afc ,_bgf ,_fgge .U [0:48]);if _aff !=nil {return nil ,_aff ;};_gce =_gce [:32];if !_aa .Equal (_gce ,_fgge .O [:32]){return nil ,nil ;};return _gce ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););var _ StdHandler =stdHandlerR4 {};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;type ecb struct{_ga _c .Block ;_efd int ;};func _ff (_de _c .Block )_c .BlockMode {return (*ecbEncrypter )(_d (_de ))};func _gdb (_adc []byte ,_agc int ){_gfe :=_agc ;for _gfe < len (_adc ){copy (_adc [_gfe :],_adc [:_gfe ]);_gfe *=2;
};};func _geg (_ecg []byte )(_c .Block ,error ){_bdbe ,_bba :=_gg .NewCipher (_ecg );if _bba !=nil {_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bba );
return nil ,_bba ;};return _bdbe ,nil ;};func _gfb (_gba ,_dac ,_agd []byte )([]byte ,error ){var (_bab ,_efg ,_ebf _g .Hash ;);_bab =_ca .New ();_geegf :=make ([]byte ,64);_dbg :=_bab ;_dbg .Write (_gba );K :=_dbg .Sum (_geegf [:0]);_fga :=make ([]byte ,64*(127+64+48));
_ccg :=func (_ int )([]byte ,error ){_bbe :=len (_dac )+len (K )+len (_agd );_dae :=_fga [:_bbe ];_gdd :=copy (_dae ,_dac );_gdd +=copy (_dae [_gdd :],K [:]);_gdd +=copy (_dae [_gdd :],_agd );if _gdd !=_bbe {_be .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_f .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fga [:_bbe *64];_gdb (K1 ,_bbe );_gdfe ,_fecc :=_geg (K [0:16]);if _fecc !=nil {return nil ,_fecc ;};_fgaf :=_c .NewCBCEncrypter (_gdfe ,K [16:32]);_fgaf .CryptBlocks (K1 ,K1 );
E :=K1 ;_ddb :=0;for _cdf :=0;_cdf < 16;_cdf ++{_ddb +=int (E [_cdf ]%3);};var _gdbc _g .Hash ;switch _ddb %3{case 0:_gdbc =_bab ;case 1:if _efg ==nil {_efg =_ge .New384 ();};_gdbc =_efg ;case 2:if _ebf ==nil {_ebf =_ge .New ();};_gdbc =_ebf ;};_gdbc .Reset ();
_gdbc .Write (E );K =_gdbc .Sum (_geegf [:0]);return E ,nil ;};for _cdg :=0;;{E ,_gcb :=_ccg (_cdg );if _gcb !=nil {return nil ,_gcb ;};_fcb :=E [len (E )-1];_cdg ++;if _cdg >=64&&_fcb <=uint8 (_cdg -32){break ;};};return K [:32],nil ;};var _ StdHandler =stdHandlerR6 {};
func (_bbad stdHandlerR6 )alg11 (_ac *StdEncryptDict ,_fdd []byte )([]byte ,error ){if _def :=_fc ("\u0061\u006c\u00671\u0031","\u0055",48,_ac .U );_def !=nil {return nil ,_def ;};_aab :=make ([]byte ,len (_fdd )+8);_cbf :=copy (_aab ,_fdd );_cbf +=copy (_aab [_cbf :],_ac .U [32:40]);
_cgaa ,_cafg :=_bbad .alg2b (_ac .R ,_aab ,_fdd ,nil );if _cafg !=nil {return nil ,_cafg ;};_cgaa =_cgaa [:32];if !_aa .Equal (_cgaa ,_ac .U [:32]){return nil ,nil ;};return _cgaa ,nil ;};func (_eefg stdHandlerR6 )alg10 (_fcd *StdEncryptDict ,_bbg []byte )error {if _dcf :=_fc ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bbg );
_dcf !=nil {return _dcf ;};_gbc :=uint64 (uint32 (_fcd .P ))|(_ef .MaxUint32 <<32);Perms :=make ([]byte ,16);_e .LittleEndian .PutUint64 (Perms [:8],_gbc );if _fcd .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_cde :=_b .ReadFull (_cf .Reader ,Perms [12:16]);_cde !=nil {return _cde ;};_aed ,_cad :=_geg (_bbg [:32]);if _cad !=nil {return _cad ;};_ggg :=_ff (_aed );_ggg .CryptBlocks (Perms ,Perms );_fcd .Perms =Perms [:16];return nil ;};func (_eea stdHandlerR4 )alg5 (_dggd []byte ,_ []byte )([]byte ,error ){_da :=_ae .New ();
_da .Write ([]byte (_dcg ));_da .Write ([]byte (_eea .ID0 ));_abg :=_da .Sum (nil );_be .Log .Trace ("\u0061\u006c\u0067\u0035");_be .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_dggd );_be .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_eea .ID0 );
if len (_abg )!=16{return nil ,_f .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_aadc ,_gdf :=_fa .NewCipher (_dggd );if _gdf !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cag :=make ([]byte ,16);_aadc .XORKeyStream (_cag ,_abg );_bca :=make ([]byte ,len (_dggd ));for _eg :=0;_eg < 19;_eg ++{for _egf :=0;_egf < len (_dggd );_egf ++{_bca [_egf ]=_dggd [_egf ]^byte (_eg +1);};_aadc ,_gdf =_fa .NewCipher (_bca );if _gdf !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_aadc .XORKeyStream (_cag ,_cag );_be .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_eg ,_bca );_be .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_eg ,_cag );
};_gdg :=make ([]byte ,32);for _aba :=0;_aba < 16;_aba ++{_gdg [_aba ]=_cag [_aba ];};_ ,_gdf =_cf .Read (_gdg [16:32]);if _gdf !=nil {return nil ,_f .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _gdg ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_gfa Permissions )Allowed (p2 Permissions )bool {return _gfa &p2 ==p2 };func (_aaf stdHandlerR4 )alg7 (_dcca *StdEncryptDict ,_bdc []byte )([]byte ,error ){_abe :=_aaf .alg3Key (_dcca .R ,_bdc );_eff :=make ([]byte ,len (_dcca .O ));if _dcca .R ==2{_fgf ,_gag :=_fa .NewCipher (_abe );
if _gag !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fgf .XORKeyStream (_eff ,_dcca .O );}else if _dcca .R >=3{_dce :=append ([]byte {},_dcca .O ...);for _fba :=0;_fba < 20;_fba ++{_gcc :=append ([]byte {},_abe ...);
for _fcc :=0;_fcc < len (_abe );_fcc ++{_gcc [_fcc ]^=byte (19-_fba );};_daf ,_fbab :=_fa .NewCipher (_gcc );if _fbab !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_daf .XORKeyStream (_eff ,_dce );
_dce =append ([]byte {},_eff ...);};}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_fec ,_eab :=_aaf .alg6 (_dcca ,_eff );if _eab !=nil {return nil ,nil ;};return _fec ,nil ;};

// Authenticate implements StdHandler interface.
func (_fbdc stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _fbdc .alg2a (d ,pass );};func (_gca stdHandlerR4 )alg4 (_cbd []byte ,_ []byte )([]byte ,error ){_gfad ,_dgg :=_fa .NewCipher (_cbd );if _dgg !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_caf :=[]byte (_dcg );_dcc :=make ([]byte ,len (_caf ));_gfad .XORKeyStream (_dcc ,_caf );return _dcc ,nil ;};func (_dba stdHandlerR6 )alg13 (_dcae *StdEncryptDict ,_aabf []byte )error {if _aca :=_fc ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_aabf );
_aca !=nil {return _aca ;};if _fbd :=_fc ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_dcae .Perms );_fbd !=nil {return _fbd ;};_ada :=make ([]byte ,16);copy (_ada ,_dcae .Perms [:16]);_fdf ,_ecd :=_gg .NewCipher (_aabf [:32]);if _ecd !=nil {return _ecd ;
};_fbae :=_cd (_fdf );_fbae .CryptBlocks (_ada ,_ada );if !_aa .Equal (_ada [9:12],[]byte ("\u0061\u0064\u0062")){return _f .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_gdgd :=Permissions (_e .LittleEndian .Uint32 (_ada [0:4]));if _gdgd !=_dcae .P {return _f .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _acb bool ;switch _ada [8]{case 'T':_acb =true ;case 'F':_acb =false ;default:return _f .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _acb !=_dcae .EncryptMetadata {return _f .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func _cd (_gga _c .Block )_c .BlockMode {return (*ecbDecrypter )(_d (_gga ))};

// Authenticate implements StdHandler interface.
func (_aae stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_be .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_deg ,_ecc :=_aae .alg7 (d ,pass );if _ecc !=nil {return nil ,0,_ecc ;};if _deg !=nil {_be .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _deg ,PermOwner ,nil ;
};_be .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_deg ,_ecc =_aae .alg6 (d ,pass );if _ecc !=nil {return nil ,0,_ecc ;
};if _deg !=nil {_be .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _deg ,d .P ,nil ;};return nil ,0,nil ;};const _dcg ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";
func (_ded *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ded ._efd !=0{_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_be .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ded ._ga .Decrypt (dst ,src [:_ded ._efd ]);src =src [_ded ._efd :];dst =dst [_ded ._efd :];};};func (_agcg stdHandlerR6 )alg2b (R int ,_abf ,_cfe ,_eee []byte )([]byte ,error ){if R ==5{return _bbda (_abf );};return _gfb (_abf ,_cfe ,_eee );
};const (PermOwner =Permissions (_ef .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);
PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_cage stdHandlerR4 )alg6 (_bge *StdEncryptDict ,_ffe []byte )([]byte ,error ){var (_gb []byte ;_aac error ;);_cffe :=_cage .alg2 (_bge ,_ffe );if _bge .R ==2{_gb ,_aac =_cage .alg4 (_cffe ,_ffe );
}else if _bge .R >=3{_gb ,_aac =_cage .alg5 (_cffe ,_ffe );}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _aac !=nil {return nil ,_aac ;};_be .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gb ),string (_bge .U ));
_gfg :=_gb ;_geeg :=_bge .U ;if _bge .R >=3{if len (_gfg )> 16{_gfg =_gfg [0:16];};if len (_geeg )> 16{_geeg =_geeg [0:16];};};if !_aa .Equal (_gfg ,_geeg ){return nil ,nil ;};return _cffe ,nil ;};func (_fcf stdHandlerR4 )alg2 (_eb *StdEncryptDict ,_cff []byte )[]byte {_be .Log .Trace ("\u0061\u006c\u0067\u0032");
_gff :=_fcf .paddedPass (_cff );_ebd :=_ae .New ();_ebd .Write (_gff );_ebd .Write (_eb .O );var _ced [4]byte ;_e .LittleEndian .PutUint32 (_ced [:],uint32 (_eb .P ));_ebd .Write (_ced [:]);_be .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_ced );
_ebd .Write ([]byte (_fcf .ID0 ));_be .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_eb .R ,_eb .EncryptMetadata );
if (_eb .R >=4)&&!_eb .EncryptMetadata {_ebd .Write ([]byte {0xff,0xff,0xff,0xff});};_cg :=_ebd .Sum (nil );if _eb .R >=3{_ebd =_ae .New ();for _cga :=0;_cga < 50;_cga ++{_ebd .Reset ();_ebd .Write (_cg [0:_fcf .Length /8]);_cg =_ebd .Sum (nil );};};if _eb .R >=3{return _cg [0:_fcf .Length /8];
};return _cg [0:5];};func (_gcce stdHandlerR6 )alg2a (_cfa *StdEncryptDict ,_bf []byte )([]byte ,Permissions ,error ){if _fcg :=_fc ("\u0061\u006c\u00672\u0061","\u004f",48,_cfa .O );_fcg !=nil {return nil ,0,_fcg ;};if _aaaa :=_fc ("\u0061\u006c\u00672\u0061","\u0055",48,_cfa .U );
_aaaa !=nil {return nil ,0,_aaaa ;};if len (_bf )> 127{_bf =_bf [:127];};_ffc ,_bgb :=_gcce .alg12 (_cfa ,_bf );if _bgb !=nil {return nil ,0,_bgb ;};var (_dfe []byte ;_abga []byte ;_ebb []byte ;);var _dedg Permissions ;if len (_ffc )!=0{_dedg =PermOwner ;
_bea :=make ([]byte ,len (_bf )+8+48);_dfa :=copy (_bea ,_bf );_dfa +=copy (_bea [_dfa :],_cfa .O [40:48]);copy (_bea [_dfa :],_cfa .U [0:48]);_dfe =_bea ;_abga =_cfa .OE ;_ebb =_cfa .U [0:48];}else {_ffc ,_bgb =_gcce .alg11 (_cfa ,_bf );if _bgb ==nil &&len (_ffc )==0{_ffc ,_bgb =_gcce .alg11 (_cfa ,[]byte (""));
};if _bgb !=nil {return nil ,0,_bgb ;}else if len (_ffc )==0{return nil ,0,nil ;};_dedg =_cfa .P ;_bbdg :=make ([]byte ,len (_bf )+8);_efb :=copy (_bbdg ,_bf );copy (_bbdg [_efb :],_cfa .U [40:48]);_dfe =_bbdg ;_abga =_cfa .UE ;_ebb =nil ;};if _bgbd :=_fc ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_abga );
_bgbd !=nil {return nil ,0,_bgbd ;};_abga =_abga [:32];_cae ,_bgb :=_gcce .alg2b (_cfa .R ,_dfe ,_bf ,_ebb );if _bgb !=nil {return nil ,0,_bgb ;};_bad ,_bgb :=_gg .NewCipher (_cae [:32]);if _bgb !=nil {return nil ,0,_bgb ;};_bgg :=make ([]byte ,_gg .BlockSize );
_dad :=_c .NewCBCDecrypter (_bad ,_bgg );_eeb :=make ([]byte ,32);_dad .CryptBlocks (_eeb ,_abga );if _cfa .R ==5{return _eeb ,_dedg ,nil ;};_bgb =_gcce .alg13 (_cfa ,_eeb );if _bgb !=nil {return nil ,0,_bgb ;};return _eeb ,_dedg ,nil ;};func (stdHandlerR4 )paddedPass (_fb []byte )[]byte {_ec :=make ([]byte ,32);
_cac :=copy (_ec ,_fb );for ;_cac < 32;_cac ++{_ec [_cac ]=_dcg [_cac -len (_fb )];};return _ec ;};func (_cea stdHandlerR6 )alg9 (_eae *StdEncryptDict ,_fbabb []byte ,_cegc []byte )error {if _gae :=_fc ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_fbabb );
_gae !=nil {return _gae ;};if _fgac :=_fc ("\u0061\u006c\u0067\u0039","\u0055",48,_eae .U );_fgac !=nil {return _fgac ;};var _ggb [16]byte ;if _ ,_egd :=_b .ReadFull (_cf .Reader ,_ggb [:]);_egd !=nil {return _egd ;};_bagc :=_ggb [0:8];_ddea :=_ggb [8:16];
_dda :=_eae .U [:48];_ebdb :=make ([]byte ,len (_cegc )+len (_bagc )+len (_dda ));_eeg :=copy (_ebdb ,_cegc );_eeg +=copy (_ebdb [_eeg :],_bagc );_eeg +=copy (_ebdb [_eeg :],_dda );_aadg ,_ccd :=_cea .alg2b (_eae .R ,_ebdb ,_cegc ,_dda );if _ccd !=nil {return _ccd ;
};O :=make ([]byte ,len (_aadg )+len (_bagc )+len (_ddea ));_eeg =copy (O ,_aadg [:32]);_eeg +=copy (O [_eeg :],_bagc );_eeg +=copy (O [_eeg :],_ddea );_eae .O =O ;_eeg =len (_cegc );_eeg +=copy (_ebdb [_eeg :],_ddea );_aadg ,_ccd =_cea .alg2b (_eae .R ,_ebdb ,_cegc ,_dda );
if _ccd !=nil {return _ccd ;};_gfd ,_ccd :=_geg (_aadg [:32]);if _ccd !=nil {return _ccd ;};_efbb :=make ([]byte ,_gg .BlockSize );_fbac :=_c .NewCBCEncrypter (_gfd ,_efbb );OE :=make ([]byte ,32);_fbac .CryptBlocks (OE ,_fbabb [:32]);_eae .OE =OE ;return nil ;
};type ecbEncrypter ecb ;

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_bc *StdEncryptDict ,_dca ,_cb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ce *StdEncryptDict ,_cda []byte )([]byte ,Permissions ,error );};func (_gd errInvalidField )Error ()string {return _fg .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_gd .Func ,_gd .Field ,_gd .Exp ,_gd .Got );
};func _d (_aad _c .Block )*ecb {return &ecb {_ga :_aad ,_efd :_aad .BlockSize ()}};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_abef stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_dgga :=make ([]byte ,32);if _ ,_eaf :=_b .ReadFull (_cf .Reader ,_dgga );_eaf !=nil {return nil ,_eaf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _ffb :=_abef .alg8 (d ,_dgga ,upass );_ffb !=nil {return nil ,_ffb ;};if _ebfd :=_abef .alg9 (d ,_dgga ,opass );_ebfd !=nil {return nil ,_ebfd ;};if d .R ==5{return _dgga ,nil ;
};if _aef :=_abef .alg10 (d ,_dgga );_aef !=nil {return nil ,_aef ;};return _dgga ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};