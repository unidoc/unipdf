//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_cd "bytes";_cf "crypto/aes";_d "crypto/cipher";_g "crypto/md5";_cc "crypto/rand";_ec "crypto/rc4";_a "crypto/sha256";_c "crypto/sha512";_dg "encoding/binary";_e "errors";_ff "fmt";_ag "github.com/unidoc/unipdf/v3/common";_bb "hash";
_f "io";_dd "math";);func (_da stdHandlerR4 )alg3Key (R int ,_gef []byte )[]byte {_bcb :=_g .New ();_ca :=_da .paddedPass (_gef );_bcb .Write (_ca );if R >=3{for _fde :=0;_fde < 50;_fde ++{_df :=_bcb .Sum (nil );_bcb =_g .New ();_bcb .Write (_df );};};
_ada :=_bcb .Sum (nil );if R ==2{_ada =_ada [0:5];}else {_ada =_ada [0:_da .Length /8];};return _ada ;};func (_ebb *ecbEncrypter )BlockSize ()int {return _ebb ._cfb };var _ StdHandler =stdHandlerR6 {};type ecbDecrypter ecb ;

// Authenticate implements StdHandler interface.
func (_acf stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _acf .alg2a (d ,pass );};func _ae (_eb _d .Block )*ecb {return &ecb {_eg :_eb ,_cfb :_eb .BlockSize ()}};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_cbe stdHandlerR4 )alg4 (_aad []byte ,_efc []byte )([]byte ,error ){_cac ,_fa :=_ec .NewCipher (_aad );if _fa !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bag :=[]byte (_ege );_ed :=make ([]byte ,len (_bag ));_cac .XORKeyStream (_ed ,_bag );return _ed ,nil ;};const _ege ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";


// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_bgg stdHandlerR6 )alg2a (_ceb *StdEncryptDict ,_gab []byte )([]byte ,Permissions ,error ){if _gaa :=_gad ("\u0061\u006c\u00672\u0061","\u004f",48,_ceb .O );
_gaa !=nil {return nil ,0,_gaa ;};if _ac :=_gad ("\u0061\u006c\u00672\u0061","\u0055",48,_ceb .U );_ac !=nil {return nil ,0,_ac ;};if len (_gab )> 127{_gab =_gab [:127];};_baa ,_cfd :=_bgg .alg12 (_ceb ,_gab );if _cfd !=nil {return nil ,0,_cfd ;};var (_acc []byte ;
_bfb []byte ;_gea []byte ;);var _accb Permissions ;if len (_baa )!=0{_accb =PermOwner ;_bbg :=make ([]byte ,len (_gab )+8+48);_cgb :=copy (_bbg ,_gab );_cgb +=copy (_bbg [_cgb :],_ceb .O [40:48]);copy (_bbg [_cgb :],_ceb .U [0:48]);_acc =_bbg ;_bfb =_ceb .OE ;
_gea =_ceb .U [0:48];}else {_baa ,_cfd =_bgg .alg11 (_ceb ,_gab );if _cfd ==nil &&len (_baa )==0{_baa ,_cfd =_bgg .alg11 (_ceb ,[]byte (""));};if _cfd !=nil {return nil ,0,_cfd ;}else if len (_baa )==0{return nil ,0,nil ;};_accb =_ceb .P ;_fbc :=make ([]byte ,len (_gab )+8);
_ceg :=copy (_fbc ,_gab );copy (_fbc [_ceg :],_ceb .U [40:48]);_acc =_fbc ;_bfb =_ceb .UE ;_gea =nil ;};if _cddg :=_gad ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_bfb );_cddg !=nil {return nil ,0,_cddg ;};_bfb =_bfb [:32];_gfg ,_cfd :=_bgg .alg2b (_ceb .R ,_acc ,_gab ,_gea );
if _cfd !=nil {return nil ,0,_cfd ;};_gdc ,_cfd :=_cf .NewCipher (_gfg [:32]);if _cfd !=nil {return nil ,0,_cfd ;};_efb :=make ([]byte ,_cf .BlockSize );_adf :=_d .NewCBCDecrypter (_gdc ,_efb );_ebec :=make ([]byte ,32);_adf .CryptBlocks (_ebec ,_bfb );
if _ceb .R ==5{return _ebec ,_accb ,nil ;};_cfd =_bgg .alg13 (_ceb ,_ebec );if _cfd !=nil {return nil ,0,_cfd ;};return _ebec ,_accb ,nil ;};func _gad (_be ,_gf string ,_bc int ,_de []byte )error {if len (_de )< _bc {return errInvalidField {Func :_be ,Field :_gf ,Exp :_bc ,Got :len (_de )};
};return nil ;};func (_edb stdHandlerR4 )alg6 (_eca *StdEncryptDict ,_aec []byte )([]byte ,error ){var (_abf []byte ;_gfe error ;);_db :=_edb .alg2 (_eca ,_aec );if _eca .R ==2{_abf ,_gfe =_edb .alg4 (_db ,_aec );}else if _eca .R >=3{_abf ,_gfe =_edb .alg5 (_db ,_aec );
}else {return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _gfe !=nil {return nil ,_gfe ;};_ag .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_abf ),string (_eca .U ));
_fac :=_abf ;_gdd :=_eca .U ;if _eca .R >=3{if len (_fac )> 16{_fac =_fac [0:16];};if len (_gdd )> 16{_gdd =_gdd [0:16];};};if !_cd .Equal (_fac ,_gdd ){return nil ,nil ;};return _db ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_ad Permissions )Allowed (p2 Permissions )bool {return _ad &p2 ==p2 };func (_fbcf stdHandlerR6 )alg9 (_dcab *StdEncryptDict ,_fcgg []byte ,_gdfa []byte )error {if _ggf :=_gad ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_fcgg );_ggf !=nil {return _ggf ;
};if _eaa :=_gad ("\u0061\u006c\u0067\u0039","\u0055",48,_dcab .U );_eaa !=nil {return _eaa ;};var _bd [16]byte ;if _ ,_cegc :=_f .ReadFull (_cc .Reader ,_bd [:]);_cegc !=nil {return _cegc ;};_ggc :=_bd [0:8];_cef :=_bd [8:16];_bge :=_dcab .U [:48];_bcfc :=make ([]byte ,len (_gdfa )+len (_ggc )+len (_bge ));
_bcg :=copy (_bcfc ,_gdfa );_bcg +=copy (_bcfc [_bcg :],_ggc );_bcg +=copy (_bcfc [_bcg :],_bge );_deg ,_gda :=_fbcf .alg2b (_dcab .R ,_bcfc ,_gdfa ,_bge );if _gda !=nil {return _gda ;};O :=make ([]byte ,len (_deg )+len (_ggc )+len (_cef ));_bcg =copy (O ,_deg [:32]);
_bcg +=copy (O [_bcg :],_ggc );_bcg +=copy (O [_bcg :],_cef );_dcab .O =O ;_bcg =len (_gdfa );_bcg +=copy (_bcfc [_bcg :],_cef );_deg ,_gda =_fbcf .alg2b (_dcab .R ,_bcfc ,_gdfa ,_bge );if _gda !=nil {return _gda ;};_cfde ,_gda :=_edf (_deg [:32]);if _gda !=nil {return _gda ;
};_geab :=make ([]byte ,_cf .BlockSize );_aeb :=_d .NewCBCEncrypter (_cfde ,_geab );OE :=make ([]byte ,32);_aeb .CryptBlocks (OE ,_fcgg [:32]);_dcab .OE =OE ;return nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_ge *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ge ._cfb !=0{_ag .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ag .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ge ._eg .Decrypt (dst ,src [:_ge ._cfb ]);src =src [_ge ._cfb :];dst =dst [_ge ._cfb :];};};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e");
);func (_ce *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ce ._cfb !=0{_ag .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ag .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ce ._eg .Encrypt (dst ,src [:_ce ._cfb ]);src =src [_ce ._cfb :];dst =dst [_ce ._cfb :];};};func _edf (_cfbc []byte )(_d .Block ,error ){_ceea ,_ggb :=_cf .NewCipher (_cfbc );if _ggb !=nil {_ag .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_ggb );
return nil ,_ggb ;};return _ceea ,nil ;};type ecb struct{_eg _d .Block ;_cfb int ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_gg stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_fgd :=_gg .alg3 (d .R ,upass ,opass );if _fgd !=nil {_ag .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fgd );
return nil ,_fgd ;};d .O =O ;_ag .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_ebg :=_gg .alg2 (d ,upass );U ,_fgd :=_gg .alg5 (_ebg ,upass );if _fgd !=nil {_ag .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fgd );
return nil ,_fgd ;};d .U =U ;_ag .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _ebg ,nil ;};const (PermOwner =Permissions (_dd .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_defb stdHandlerR6 )alg12 (_bbf *StdEncryptDict ,_gegg []byte )([]byte ,error ){if _dea :=_gad ("\u0061\u006c\u00671\u0032","\u0055",48,_bbf .U );
_dea !=nil {return nil ,_dea ;};if _gfgc :=_gad ("\u0061\u006c\u00671\u0032","\u004f",48,_bbf .O );_gfgc !=nil {return nil ,_gfgc ;};_dcd :=make ([]byte ,len (_gegg )+8+48);_gegf :=copy (_dcd ,_gegg );_gegf +=copy (_dcd [_gegf :],_bbf .O [32:40]);_gegf +=copy (_dcd [_gegf :],_bbf .U [0:48]);
_aebd ,_ffff :=_defb .alg2b (_bbf .R ,_dcd ,_gegg ,_bbf .U [0:48]);if _ffff !=nil {return nil ,_ffff ;};_aebd =_aebd [:32];if !_cd .Equal (_aebd ,_bbf .O [:32]){return nil ,nil ;};return _aebd ,nil ;};func (_ccf stdHandlerR4 )alg3 (R int ,_caf ,_cbc []byte )([]byte ,error ){var _ece []byte ;
if len (_cbc )> 0{_ece =_ccf .alg3Key (R ,_cbc );}else {_ece =_ccf .alg3Key (R ,_caf );};_cba ,_ccdb :=_ec .NewCipher (_ece );if _ccdb !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ccdf :=_ccf .paddedPass (_caf );
_ebc :=make ([]byte ,len (_ccdf ));_cba .XORKeyStream (_ebc ,_ccdf );if R >=3{_fbf :=make ([]byte ,len (_ece ));for _bcbe :=0;_bcbe < 19;_bcbe ++{for _ba :=0;_ba < len (_ece );_ba ++{_fbf [_ba ]=_ece [_ba ]^byte (_bcbe +1);};_gd ,_cee :=_ec .NewCipher (_fbf );
if _cee !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gd .XORKeyStream (_ebc ,_ebc );};};return _ebc ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_fb *StdEncryptDict ,_fg ,_cb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_bf *StdEncryptDict ,_ega []byte )([]byte ,Permissions ,error );};func (_gfdg stdHandlerR6 )alg11 (_geea *StdEncryptDict ,_cbb []byte )([]byte ,error ){if _af :=_gad ("\u0061\u006c\u00671\u0031","\u0055",48,_geea .U );_af !=nil {return nil ,_af ;
};_fff :=make ([]byte ,len (_cbb )+8);_addc :=copy (_fff ,_cbb );_addc +=copy (_fff [_addc :],_geea .U [32:40]);_aee ,_cegb :=_gfdg .alg2b (_geea .R ,_fff ,_cbb ,nil );if _cegb !=nil {return nil ,_cegb ;};_aee =_aee [:32];if !_cd .Equal (_aee ,_geea .U [:32]){return nil ,nil ;
};return _aee ,nil ;};func (_bbb stdHandlerR4 )alg5 (_fbae []byte ,_bbe []byte )([]byte ,error ){_efd :=_g .New ();_efd .Write ([]byte (_ege ));_efd .Write ([]byte (_bbb .ID0 ));_beg :=_efd .Sum (nil );_ag .Log .Trace ("\u0061\u006c\u0067\u0035");_ag .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fbae );
_ag .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bbb .ID0 );if len (_beg )!=16{return nil ,_e .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_dec ,_dge :=_ec .NewCipher (_fbae );
if _dge !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fc :=make ([]byte ,16);_dec .XORKeyStream (_fc ,_beg );_ab :=make ([]byte ,len (_fbae ));for _gb :=0;_gb < 19;_gb ++{for _fbb :=0;
_fbb < len (_fbae );_fbb ++{_ab [_fbb ]=_fbae [_fbb ]^byte (_gb +1);};_dec ,_dge =_ec .NewCipher (_ab );if _dge !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dec .XORKeyStream (_fc ,_fc );
_ag .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_gb ,_ab );_ag .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_gb ,_fc );};_dab :=make ([]byte ,32);
for _cg :=0;_cg < 16;_cg ++{_dab [_cg ]=_fc [_cg ];};_ ,_dge =_cc .Read (_dab [16:32]);if _dge !=nil {return nil ,_e .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _dab ,nil ;
};func _bg (_ga _d .Block )_d .BlockMode {return (*ecbEncrypter )(_ae (_ga ))};type ecbEncrypter ecb ;func (_gbd stdHandlerR4 )alg7 (_fe *StdEncryptDict ,_fcg []byte )([]byte ,error ){_bee :=_gbd .alg3Key (_fe .R ,_fcg );_ffc :=make ([]byte ,len (_fe .O ));
if _fe .R ==2{_addd ,_gdb :=_ec .NewCipher (_bee );if _gdb !=nil {return nil ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_addd .XORKeyStream (_ffc ,_fe .O );}else if _fe .R >=3{_baf :=append ([]byte {},_fe .O ...);
for _bae :=0;_bae < 20;_bae ++{_dcf :=append ([]byte {},_bee ...);for _dad :=0;_dad < len (_bee );_dad ++{_dcf [_dad ]^=byte (19-_bae );};_fee ,_cdc :=_ec .NewCipher (_dcf );if _cdc !=nil {return nil ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_fee .XORKeyStream (_ffc ,_baf );_baf =append ([]byte {},_ffc ...);};}else {return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_deb ,_bcd :=_gbd .alg6 (_fe ,_ffc );if _bcd !=nil {return nil ,nil ;};return _deb ,nil ;};func (_ccd errInvalidField )Error ()string {return _ff .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ccd .Func ,_ccd .Field ,_ccd .Exp ,_ccd .Got );
};type stdHandlerR4 struct{Length int ;ID0 string ;};type stdHandlerR6 struct{};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _dde (_eea []byte ,_gee int ){_gec :=_gee ;for _gec < len (_eea ){copy (_eea [_gec :],_eea [:_gec ]);_gec *=2;};};func (_dca stdHandlerR6 )alg8 (_aaa *StdEncryptDict ,_fgg []byte ,_bcfg []byte )error {if _cdda :=_gad ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_fgg );
_cdda !=nil {return _cdda ;};var _gaag [16]byte ;if _ ,_def :=_f .ReadFull (_cc .Reader ,_gaag [:]);_def !=nil {return _def ;};_cda :=_gaag [0:8];_dbeg :=_gaag [8:16];_ea :=make ([]byte ,len (_bcfg )+len (_cda ));_bbdd :=copy (_ea ,_bcfg );copy (_ea [_bbdd :],_cda );
_bbba ,_bfg :=_dca .alg2b (_aaa .R ,_ea ,_bcfg ,nil );if _bfg !=nil {return _bfg ;};U :=make ([]byte ,len (_bbba )+len (_cda )+len (_dbeg ));_bbdd =copy (U ,_bbba [:32]);_bbdd +=copy (U [_bbdd :],_cda );copy (U [_bbdd :],_dbeg );_aaa .U =U ;_bbdd =len (_bcfg );
copy (_ea [_bbdd :],_dbeg );_bbba ,_bfg =_dca .alg2b (_aaa .R ,_ea ,_bcfg ,nil );if _bfg !=nil {return _bfg ;};_baeb ,_bfg :=_edf (_bbba [:32]);if _bfg !=nil {return _bfg ;};_bgb :=make ([]byte ,_cf .BlockSize );_caca :=_d .NewCBCEncrypter (_baeb ,_bgb );
UE :=make ([]byte ,32);_caca .CryptBlocks (UE ,_fgg [:32]);_aaa .UE =UE ;return nil ;};func (_ebe stdHandlerR4 )alg2 (_egd *StdEncryptDict ,_bcf []byte )[]byte {_ag .Log .Trace ("\u0061\u006c\u0067\u0032");_aa :=_ebe .paddedPass (_bcf );_add :=_g .New ();
_add .Write (_aa );_add .Write (_egd .O );var _cbd [4]byte ;_dg .LittleEndian .PutUint32 (_cbd [:],uint32 (_egd .P ));_add .Write (_cbd [:]);_ag .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cbd );_add .Write ([]byte (_ebe .ID0 ));_ag .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_egd .R ,_egd .EncryptMetadata );
if (_egd .R >=4)&&!_egd .EncryptMetadata {_add .Write ([]byte {0xff,0xff,0xff,0xff});};_bgf :=_add .Sum (nil );if _egd .R >=3{_add =_g .New ();for _dgg :=0;_dgg < 50;_dgg ++{_add .Reset ();_add .Write (_bgf [0:_ebe .Length /8]);_bgf =_add .Sum (nil );};
};if _egd .R >=3{return _bgf [0:_ebe .Length /8];};return _bgf [0:5];};func (_abg stdHandlerR6 )alg10 (_ecd *StdEncryptDict ,_ffb []byte )error {if _daff :=_gad ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_ffb );_daff !=nil {return _daff ;};_dcfb :=uint64 (uint32 (_ecd .P ))|(_dd .MaxUint32 <<32);
Perms :=make ([]byte ,16);_dg .LittleEndian .PutUint64 (Perms [:8],_dcfb );if _ecd .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_faf :=_f .ReadFull (_cc .Reader ,Perms [12:16]);_faf !=nil {return _faf ;
};_gdbb ,_dcc :=_edf (_ffb [:32]);if _dcc !=nil {return _dcc ;};_gfd :=_bg (_gdbb );_gfd .CryptBlocks (Perms ,Perms );_ecd .Perms =Perms [:16];return nil ;};func (_dc *ecbDecrypter )BlockSize ()int {return _dc ._cfb };

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cgdd stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_feg :=make ([]byte ,32);if _ ,_dgf :=_f .ReadFull (_cc .Reader ,_feg );_dgf !=nil {return nil ,_dgf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bac :=_cgdd .alg8 (d ,_feg ,upass );_bac !=nil {return nil ,_bac ;};if _adac :=_cgdd .alg9 (d ,_feg ,opass );_adac !=nil {return nil ,_adac ;};if d .R ==5{return _feg ,nil ;
};if _ffcf :=_cgdd .alg10 (d ,_feg );_ffcf !=nil {return nil ,_ffcf ;};return _feg ,nil ;};func _fd (_ef _d .Block )_d .BlockMode {return (*ecbDecrypter )(_ae (_ef ))};func (stdHandlerR4 )paddedPass (_ee []byte )[]byte {_cdd :=make ([]byte ,32);_fba :=copy (_cdd ,_ee );
for ;_fba < 32;_fba ++{_cdd [_fba ]=_ege [_fba -len (_ee )];};return _cdd ;};func (_dce stdHandlerR6 )alg13 (_adc *StdEncryptDict ,_eac []byte )error {if _eee :=_gad ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_eac );_eee !=nil {return _eee ;};
if _dgeb :=_gad ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_adc .Perms );_dgeb !=nil {return _dgeb ;};_ebaf :=make ([]byte ,16);copy (_ebaf ,_adc .Perms [:16]);_agb ,_gega :=_cf .NewCipher (_eac [:32]);if _gega !=nil {return _gega ;};_ecdf :=_fd (_agb );
_ecdf .CryptBlocks (_ebaf ,_ebaf );if !_cd .Equal (_ebaf [9:12],[]byte ("\u0061\u0064\u0062")){return _e .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_fbfa :=Permissions (_dg .LittleEndian .Uint32 (_ebaf [0:4]));if _fbfa !=_adc .P {return _e .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _efdd bool ;if _ebaf [8]=='T'{_efdd =true ;}else if _ebaf [8]=='F'{_efdd =false ;}else {return _e .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _efdd !=_adc .EncryptMetadata {return _e .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func _cgd (_bbd ,_abc ,_ggd []byte )([]byte ,error ){var (_aae ,_gag ,_fdga _bb .Hash ;);_aae =_a .New ();_dgb :=make ([]byte ,64);_efcb :=_aae ;_efcb .Write (_bbd );K :=_efcb .Sum (_dgb [:0]);_ceeg :=make ([]byte ,64*(127+64+48));_bafd :=func (_cbcc int )([]byte ,error ){_gdf :=len (_abc )+len (K )+len (_ggd );
_daf :=_ceeg [:_gdf ];_gbb :=copy (_daf ,_abc );_gbb +=copy (_daf [_gbb :],K [:]);_gbb +=copy (_daf [_gbb :],_ggd );if _gbb !=_gdf {_ag .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_e .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ceeg [:_gdf *64];_dde (K1 ,_gdf );_aba ,_cag :=_edf (K [0:16]);if _cag !=nil {return nil ,_cag ;};_ffd :=_d .NewCBCEncrypter (_aba ,K [16:32]);_ffd .CryptBlocks (K1 ,K1 );
E :=K1 ;_eba :=0;for _cddd :=0;_cddd < 16;_cddd ++{_eba +=int (E [_cddd ]%3);};var _dbe _bb .Hash ;switch _eba %3{case 0:_dbe =_aae ;case 1:if _gag ==nil {_gag =_c .New384 ();};_dbe =_gag ;case 2:if _fdga ==nil {_fdga =_c .New ();};_dbe =_fdga ;};_dbe .Reset ();
_dbe .Write (E );K =_dbe .Sum (_dgb [:0]);return E ,nil ;};for _ecb :=0;;{E ,_geac :=_bafd (_ecb );if _geac !=nil {return nil ,_geac ;};_bef :=E [len (E )-1];_ecb ++;if _ecb >=64&&_bef <=uint8 (_ecb -32){break ;};};return K [:32],nil ;};

// Authenticate implements StdHandler interface.
func (_fdg stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ag .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_gc ,_fed :=_fdg .alg7 (d ,pass );if _fed !=nil {return nil ,0,_fed ;};if _gc !=nil {_ag .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gc ,PermOwner ,nil ;
};_ag .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gc ,_fed =_fdg .alg6 (d ,pass );if _fed !=nil {return nil ,0,_fed ;
};if _gc !=nil {_ag .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gc ,d .P ,nil ;};return nil ,0,nil ;};var _ StdHandler =stdHandlerR4 {};func (_bga stdHandlerR6 )alg2b (R int ,_cbdb ,_ebd ,_fcd []byte )([]byte ,error ){if R ==5{return _fad (_cbdb );
};return _cgd (_cbdb ,_ebd ,_fcd );};func _fad (_ddd []byte )([]byte ,error ){_bab :=_a .New ();_bab .Write (_ddd );return _bab .Sum (nil ),nil };