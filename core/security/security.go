//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_fa "bytes";_ac "crypto/aes";_c "crypto/cipher";_ce "crypto/md5";_aa "crypto/rand";_ed "crypto/rc4";_e "crypto/sha256";_ff "crypto/sha512";_cf "encoding/binary";_ea "errors";_ffb "fmt";_d "github.com/unidoc/unipdf/v4/common";_f "hash";
_a "io";_cea "math";);func (stdHandlerR4 )paddedPass (_eabd []byte )[]byte {_fb :=make ([]byte ,32);_aaa :=copy (_fb ,_eabd );for ;_aaa < 32;_aaa ++{_fb [_aaa ]=_df [_aaa -len (_eabd )];};return _fb ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_dg stdHandlerR4 )alg3 (R int ,_ab ,_deb []byte )([]byte ,error ){var _bba []byte ;if len (_deb )> 0{_bba =_dg .alg3Key (R ,_deb );
}else {_bba =_dg .alg3Key (R ,_ab );};_fdd ,_dfd :=_ed .NewCipher (_bba );if _dfd !=nil {return nil ,_ea .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cgga :=_dg .paddedPass (_ab );_dgf :=make ([]byte ,len (_cgga ));
_fdd .XORKeyStream (_dgf ,_cgga );if R >=3{_ade :=make ([]byte ,len (_bba ));for _ace :=0;_ace < 19;_ace ++{for _ae :=0;_ae < len (_bba );_ae ++{_ade [_ae ]=_bba [_ae ]^byte (_ace +1);};_gb ,_cc :=_ed .NewCipher (_ade );if _cc !=nil {return nil ,_ea .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gb .XORKeyStream (_dgf ,_dgf );};};return _dgf ,nil ;};func (_efe *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_efe ._ca !=0{_d .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_d .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_efe ._b .Encrypt (dst ,src [:_efe ._ca ]);src =src [_efe ._ca :];dst =dst [_efe ._ca :];};};const (PermOwner =Permissions (_cea .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func _ga (_gg _c .Block )*ecb {return &ecb {_b :_gg ,_ca :_gg .BlockSize ()}};
const _df ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_eac *StdEncryptDict ,_bc ,_cef []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fde *StdEncryptDict ,_da []byte )([]byte ,Permissions ,error );};func (_fdbe stdHandlerR6 )alg11 (_gcf *StdEncryptDict ,_gee []byte )([]byte ,error ){if _dbg :=_be ("\u0061\u006c\u00671\u0031","\u0055",48,_gcf .U );_dbg !=nil {return nil ,_dbg ;
};_bcg :=make ([]byte ,len (_gee )+8);_cdb :=copy (_bcg ,_gee );_cdb +=copy (_bcg [_cdb :],_gcf .U [32:40]);_bgb ,_ebfb :=_fdbe .alg2b (_gcf .R ,_bcg ,_gee ,nil );if _ebfb !=nil {return nil ,_ebfb ;};_bgb =_bgb [:32];if !_fa .Equal (_bgb ,_gcf .U [:32]){return nil ,nil ;
};return _bgb ,nil ;};func (_abb stdHandlerR4 )alg4 (_efc []byte ,_ []byte )([]byte ,error ){_aef ,_fc :=_ed .NewCipher (_efc );if _fc !=nil {return nil ,_ea .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ffbf :=[]byte (_df );
_af :=make ([]byte ,len (_ffbf ));_aef .XORKeyStream (_af ,_ffbf );return _af ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_aed stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_eeg :=_aed .alg3 (d .R ,upass ,opass );if _eeg !=nil {_d .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_eeg );
return nil ,_eeg ;};d .O =O ;_d .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_eca :=_aed .alg2 (d ,upass );U ,_eeg :=_aed .alg5 (_eca ,upass );if _eeg !=nil {_d .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_eeg );
return nil ,_eeg ;};d .U =U ;_d .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _eca ,nil ;};func (_eb stdHandlerR4 )alg3Key (R int ,_de []byte )[]byte {_daf :=_ce .New ();_cga :=_eb .paddedPass (_de );_daf .Write (_cga );
if R >=3{for _adf :=0;_adf < 50;_adf ++{_eda :=_daf .Sum (nil );_daf =_ce .New ();_daf .Write (_eda );};};_bb :=_daf .Sum (nil );if R ==2{_bb =_bb [0:5];}else {_bb =_bb [0:_eb .Length /8];};return _bb ;};func _dbc (_ddc ,_gcd ,_bde []byte )([]byte ,error ){var (_dfcb ,_aee ,_afc _f .Hash ;
);_dfcb =_e .New ();_cgda :=make ([]byte ,64);_fdad :=_dfcb ;_fdad .Write (_ddc );K :=_fdad .Sum (_cgda [:0]);_fe :=make ([]byte ,64*(127+64+48));_dgg :=func (_ int )([]byte ,error ){_adg :=len (_gcd )+len (K )+len (_bde );_bgg :=_fe [:_adg ];_dbca :=copy (_bgg ,_gcd );
_dbca +=copy (_bgg [_dbca :],K [:]);_dbca +=copy (_bgg [_dbca :],_bde );if _dbca !=_adg {_d .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ea .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fe [:_adg *64];_ecg (K1 ,_adg );_ecag ,_ffgb :=_faf (K [0:16]);if _ffgb !=nil {return nil ,_ffgb ;};_bee :=_c .NewCBCEncrypter (_ecag ,K [16:32]);_bee .CryptBlocks (K1 ,K1 );
E :=K1 ;_adc :=0;for _egf :=0;_egf < 16;_egf ++{_adc +=int (E [_egf ]%3);};var _cfb _f .Hash ;switch _adc %3{case 0:_cfb =_dfcb ;case 1:if _aee ==nil {_aee =_ff .New384 ();};_cfb =_aee ;case 2:if _afc ==nil {_afc =_ff .New ();};_cfb =_afc ;};_cfb .Reset ();
_cfb .Write (E );K =_cfb .Sum (_cgda [:0]);return E ,nil ;};for _fgbb :=0;;{E ,_dde :=_dgg (_fgbb );if _dde !=nil {return nil ,_dde ;};_bag :=E [len (E )-1];_fgbb ++;if _fgbb >=64&&_bag <=uint8 (_fgbb -32){break ;};};return K [:32],nil ;};func _be (_gf ,_bf string ,_bd int ,_eab []byte )error {if len (_eab )< _bd {return errInvalidField {Func :_gf ,Field :_bf ,Exp :_bd ,Got :len (_eab )};
};return nil ;};func (_eddf stdHandlerR6 )alg2a (_cgaa *StdEncryptDict ,_bdg []byte )([]byte ,Permissions ,error ){if _aeb :=_be ("\u0061\u006c\u00672\u0061","\u004f",48,_cgaa .O );_aeb !=nil {return nil ,0,_aeb ;};if _ede :=_be ("\u0061\u006c\u00672\u0061","\u0055",48,_cgaa .U );
_ede !=nil {return nil ,0,_ede ;};if len (_bdg )> 127{_bdg =_bdg [:127];};_aac ,_dga :=_eddf .alg12 (_cgaa ,_bdg );if _dga !=nil {return nil ,0,_dga ;};var (_acg []byte ;_edf []byte ;_fgf []byte ;);var _gebg Permissions ;if len (_aac )!=0{_gebg =PermOwner ;
_dgcf :=make ([]byte ,len (_bdg )+8+48);_bbc :=copy (_dgcf ,_bdg );_bbc +=copy (_dgcf [_bbc :],_cgaa .O [40:48]);copy (_dgcf [_bbc :],_cgaa .U [0:48]);_acg =_dgcf ;_edf =_cgaa .OE ;_fgf =_cgaa .U [0:48];}else {_aac ,_dga =_eddf .alg11 (_cgaa ,_bdg );if _dga ==nil &&len (_aac )==0{_aac ,_dga =_eddf .alg11 (_cgaa ,[]byte (""));
};if _dga !=nil {return nil ,0,_dga ;}else if len (_aac )==0{return nil ,0,nil ;};_gebg =_cgaa .P ;_aad :=make ([]byte ,len (_bdg )+8);_gc :=copy (_aad ,_bdg );copy (_aad [_gc :],_cgaa .U [40:48]);_acg =_aad ;_edf =_cgaa .UE ;_fgf =nil ;};if _eef :=_be ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_edf );
_eef !=nil {return nil ,0,_eef ;};_edf =_edf [:32];_eacgg ,_dga :=_eddf .alg2b (_cgaa .R ,_acg ,_bdg ,_fgf );if _dga !=nil {return nil ,0,_dga ;};_bdf ,_dga :=_ac .NewCipher (_eacgg [:32]);if _dga !=nil {return nil ,0,_dga ;};_aedc :=make ([]byte ,_ac .BlockSize );
_dbe :=_c .NewCBCDecrypter (_bdf ,_aedc );_eae :=make ([]byte ,32);_dbe .CryptBlocks (_eae ,_edf );if _cgaa .R ==5{return _eae ,_gebg ,nil ;};_dga =_eddf .alg13 (_cgaa ,_eae );if _dga !=nil {return nil ,0,_dga ;};return _eae ,_gebg ,nil ;};var _ StdHandler =stdHandlerR4 {};


// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_afe stdHandlerR4 )alg7 (_geb *StdEncryptDict ,_cgd []byte )([]byte ,error ){_bac :=_afe .alg3Key (_geb .R ,_cgd );_caf :=make ([]byte ,len (_geb .O ));if _geb .R ==2{_fba ,_bbf :=_ed .NewCipher (_bac );if _bbf !=nil {return nil ,_ea .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_fba .XORKeyStream (_caf ,_geb .O );}else if _geb .R >=3{_eee :=append ([]byte {},_geb .O ...);for _adea :=0;_adea < 20;_adea ++{_fgc :=append ([]byte {},_bac ...);for _fgcf :=0;_fgcf < len (_bac );_fgcf ++{_fgc [_fgcf ]^=byte (19-_adea );};_cgf ,_dc :=_ed .NewCipher (_fgc );
if _dc !=nil {return nil ,_ea .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cgf .XORKeyStream (_caf ,_eee );_eee =append ([]byte {},_caf ...);};}else {return nil ,_ea .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_dda ,_ffg :=_afe .alg6 (_geb ,_caf );if _ffg !=nil {return nil ,nil ;};return _dda ,nil ;};func (_ead *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ead ._ca !=0{_d .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_d .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ead ._b .Decrypt (dst ,src [:_ead ._ca ]);src =src [_ead ._ca :];dst =dst [_ead ._ca :];};};func _fd (_db _c .Block )_c .BlockMode {return (*ecbDecrypter )(_ga (_db ))};func (_cg *ecbDecrypter )BlockSize ()int {return _cg ._ca };
type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_agc stdHandlerR6 )alg8 (_acge *StdEncryptDict ,_bda []byte ,_ged []byte )error {if _ecd :=_be ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bda );_ecd !=nil {return _ecd ;};var _baa [16]byte ;
if _ ,_ccg :=_a .ReadFull (_aa .Reader ,_baa [:]);_ccg !=nil {return _ccg ;};_dca :=_baa [0:8];_ebf :=_baa [8:16];_ccd :=make ([]byte ,len (_ged )+len (_dca ));_feg :=copy (_ccd ,_ged );copy (_ccd [_feg :],_dca );_aec ,_gd :=_agc .alg2b (_acge .R ,_ccd ,_ged ,nil );
if _gd !=nil {return _gd ;};U :=make ([]byte ,len (_aec )+len (_dca )+len (_ebf ));_feg =copy (U ,_aec [:32]);_feg +=copy (U [_feg :],_dca );copy (U [_feg :],_ebf );_acge .U =U ;_feg =len (_ged );copy (_ccd [_feg :],_ebf );_aec ,_gd =_agc .alg2b (_acge .R ,_ccd ,_ged ,nil );
if _gd !=nil {return _gd ;};_ddg ,_gd :=_faf (_aec [:32]);if _gd !=nil {return _gd ;};_eegb :=make ([]byte ,_ac .BlockSize );_egg :=_c .NewCBCEncrypter (_ddg ,_eegb );UE :=make ([]byte ,32);_egg .CryptBlocks (UE ,_bda [:32]);_acge .UE =UE ;return nil ;
};func (_ef *ecbEncrypter )BlockSize ()int {return _ef ._ca };func (_fdb stdHandlerR4 )alg6 (_efee *StdEncryptDict ,_bfb []byte )([]byte ,error ){var (_dgc []byte ;_ag error ;);_fad :=_fdb .alg2 (_efee ,_bfb );if _efee .R ==2{_dgc ,_ag =_fdb .alg4 (_fad ,_bfb );
}else if _efee .R >=3{_dgc ,_ag =_fdb .alg5 (_fad ,_bfb );}else {return nil ,_ea .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _ag !=nil {return nil ,_ag ;};_d .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dgc ),string (_efee .U ));
_eg :=_dgc ;_bea :=_efee .U ;if _efee .R >=3{if len (_eg )> 16{_eg =_eg [0:16];};if len (_bea )> 16{_bea =_bea [0:16];};};if !_fa .Equal (_eg ,_bea ){return nil ,nil ;};return _fad ,nil ;};func (_defg stdHandlerR6 )alg10 (_fec *StdEncryptDict ,_edae []byte )error {if _agg :=_be ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_edae );
_agg !=nil {return _agg ;};_cgef :=uint64 (uint32 (_fec .P ))|(_cea .MaxUint32 <<32);Perms :=make ([]byte ,16);_cf .LittleEndian .PutUint64 (Perms [:8],_cgef );if _fec .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_abae :=_a .ReadFull (_aa .Reader ,Perms [12:16]);_abae !=nil {return _abae ;};_dfe ,_aab :=_faf (_edae [:32]);if _aab !=nil {return _aab ;};_ada :=_ad (_dfe );_ada .CryptBlocks (Perms ,Perms );_fec .Perms =Perms [:16];return nil ;};func (_eba stdHandlerR4 )alg5 (_fcb []byte ,_ []byte )([]byte ,error ){_dd :=_ce .New ();
_dd .Write ([]byte (_df ));_dd .Write ([]byte (_eba .ID0 ));_bad :=_dd .Sum (nil );_d .Log .Trace ("\u0061\u006c\u0067\u0035");_d .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fcb );_d .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_eba .ID0 );
if len (_bad )!=16{return nil ,_ea .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_eacg ,_ee :=_ed .NewCipher (_fcb );if _ee !=nil {return nil ,_ea .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_fdeb :=make ([]byte ,16);_eacg .XORKeyStream (_fdeb ,_bad );_cd :=make ([]byte ,len (_fcb ));for _fcg :=0;_fcg < 19;_fcg ++{for _edb :=0;_edb < len (_fcb );_edb ++{_cd [_edb ]=_fcb [_edb ]^byte (_fcg +1);};_eacg ,_ee =_ed .NewCipher (_cd );if _ee !=nil {return nil ,_ea .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_eacg .XORKeyStream (_fdeb ,_fdeb );_d .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_fcg ,_cd );_d .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_fcg ,_fdeb );
};_aea :=make ([]byte ,32);for _ebg :=0;_ebg < 16;_ebg ++{_aea [_ebg ]=_fdeb [_ebg ];};_ ,_ee =_aa .Read (_aea [16:32]);if _ee !=nil {return nil ,_ea .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _aea ,nil ;};func (_ccf stdHandlerR6 )alg12 (_fab *StdEncryptDict ,_ecb []byte )([]byte ,error ){if _bed :=_be ("\u0061\u006c\u00671\u0032","\u0055",48,_fab .U );_bed !=nil {return nil ,_bed ;};if _dec :=_be ("\u0061\u006c\u00671\u0032","\u004f",48,_fab .O );
_dec !=nil {return nil ,_dec ;};_cgeg :=make ([]byte ,len (_ecb )+8+48);_cda :=copy (_cgeg ,_ecb );_cda +=copy (_cgeg [_cda :],_fab .O [32:40]);_cda +=copy (_cgeg [_cda :],_fab .U [0:48]);_ccgg ,_dgea :=_ccf .alg2b (_fab .R ,_cgeg ,_ecb ,_fab .U [0:48]);
if _dgea !=nil {return nil ,_dgea ;};_ccgg =_ccgg [:32];if !_fa .Equal (_ccgg ,_fab .O [:32]){return nil ,nil ;};return _ccgg ,nil ;};func _ecg (_fcf []byte ,_caa int ){_cgac :=_caa ;for _cgac < len (_fcf ){copy (_fcf [_cgac :],_fcf [:_cgac ]);_cgac *=2;
};};func _ad (_ge _c .Block )_c .BlockMode {return (*ecbEncrypter )(_ga (_ge ))};type ecbDecrypter ecb ;func _fgb (_bab []byte )([]byte ,error ){_bcbb :=_e .New ();_bcbb .Write (_bab );return _bcbb .Sum (nil ),nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// Allowed checks if a set of permissions can be granted.
func (_gfe Permissions )Allowed (p2 Permissions )bool {return _gfe &p2 ==p2 };

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _faf (_dfc []byte )(_c .Block ,error ){_bcb ,_gae :=_ac .NewCipher (_dfc );if _gae !=nil {_d .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_gae );
return nil ,_gae ;};return _bcb ,nil ;};func (_cee stdHandlerR6 )alg2b (R int ,_egb ,_ebb ,_gbc []byte )([]byte ,error ){if R ==5{return _fgb (_egb );};return _dbc (_egb ,_ebb ,_gbc );};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_cfbg stdHandlerR6 )alg9 (_efa *StdEncryptDict ,_gfb []byte ,_bgc []byte )error {if _fce :=_be ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gfb );
_fce !=nil {return _fce ;};if _gba :=_be ("\u0061\u006c\u0067\u0039","\u0055",48,_efa .U );_gba !=nil {return _gba ;};var _badb [16]byte ;if _ ,_cac :=_a .ReadFull (_aa .Reader ,_badb [:]);_cac !=nil {return _cac ;};_adb :=_badb [0:8];_ggc :=_badb [8:16];
_cdf :=_efa .U [:48];_cdd :=make ([]byte ,len (_bgc )+len (_adb )+len (_cdf ));_cgdc :=copy (_cdd ,_bgc );_cgdc +=copy (_cdd [_cgdc :],_adb );_cgdc +=copy (_cdd [_cgdc :],_cdf );_aba ,_fcbf :=_cfbg .alg2b (_efa .R ,_cdd ,_bgc ,_cdf );if _fcbf !=nil {return _fcbf ;
};O :=make ([]byte ,len (_aba )+len (_adb )+len (_ggc ));_cgdc =copy (O ,_aba [:32]);_cgdc +=copy (O [_cgdc :],_adb );_cgdc +=copy (O [_cgdc :],_ggc );_efa .O =O ;_cgdc =len (_bgc );_cgdc +=copy (_cdd [_cgdc :],_ggc );_aba ,_fcbf =_cfbg .alg2b (_efa .R ,_cdd ,_bgc ,_cdf );
if _fcbf !=nil {return _fcbf ;};_fdea ,_fcbf :=_faf (_aba [:32]);if _fcbf !=nil {return _fcbf ;};_cfba :=make ([]byte ,_ac .BlockSize );_faa :=_c .NewCBCEncrypter (_fdea ,_cfba );OE :=make ([]byte ,32);_faa .CryptBlocks (OE ,_gfb [:32]);_efa .OE =OE ;return nil ;
};func (_ba stdHandlerR4 )alg2 (_cgg *StdEncryptDict ,_acb []byte )[]byte {_d .Log .Trace ("\u0061\u006c\u0067\u0032");_gab :=_ba .paddedPass (_acb );_edd :=_ce .New ();_edd .Write (_gab );_edd .Write (_cgg .O );var _cb [4]byte ;_cf .LittleEndian .PutUint32 (_cb [:],uint32 (_cgg .P ));
_edd .Write (_cb [:]);_d .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cb );_edd .Write ([]byte (_ba .ID0 ));_d .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cgg .R ,_cgg .EncryptMetadata );
if (_cgg .R >=4)&&!_cgg .EncryptMetadata {_edd .Write ([]byte {0xff,0xff,0xff,0xff});};_eace :=_edd .Sum (nil );if _cgg .R >=3{_edd =_ce .New ();for _fg :=0;_fg < 50;_fg ++{_edd .Reset ();_edd .Write (_eace [0:_ba .Length /8]);_eace =_edd .Sum (nil );};
};if _cgg .R >=3{return _eace [0:_ba .Length /8];};return _eace [0:5];};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cbg stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bbcc :=make ([]byte ,32);if _ ,_beg :=_a .ReadFull (_aa .Reader ,_bbcc );_beg !=nil {return nil ,_beg ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _acgc :=_cbg .alg8 (d ,_bbcc ,upass );_acgc !=nil {return nil ,_acgc ;};if _deg :=_cbg .alg9 (d ,_bbcc ,opass );_deg !=nil {return nil ,_deg ;};if d .R ==5{return _bbcc ,nil ;
};if _dee :=_cbg .alg10 (d ,_bbcc );_dee !=nil {return nil ,_dee ;};return _bbcc ,nil ;};var _ StdHandler =stdHandlerR6 {};func (_bagf stdHandlerR6 )alg13 (_bgga *StdEncryptDict ,_acd []byte )error {if _gaa :=_be ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_acd );
_gaa !=nil {return _gaa ;};if _cce :=_be ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bgga .Perms );_cce !=nil {return _cce ;};_acba :=make ([]byte ,16);copy (_acba ,_bgga .Perms [:16]);_agb ,_cag :=_ac .NewCipher (_acd [:32]);if _cag !=nil {return _cag ;
};_ebba :=_fd (_agb );_ebba .CryptBlocks (_acba ,_acba );if !_fa .Equal (_acba [9:12],[]byte ("\u0061\u0064\u0062")){return _ea .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_ddef :=Permissions (_cf .LittleEndian .Uint32 (_acba [0:4]));if _ddef !=_bgga .P {return _ea .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _gaed bool ;switch _acba [8]{case 'T':_gaed =true ;case 'F':_gaed =false ;default:return _ea .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _gaed !=_bgga .EncryptMetadata {return _ea .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// Authenticate implements StdHandler interface.
func (_fae stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_d .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_gabb ,_abg :=_fae .alg7 (d ,pass );if _abg !=nil {return nil ,0,_abg ;};if _gabb !=nil {_d .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gabb ,PermOwner ,nil ;
};_d .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gabb ,_abg =_fae .alg6 (d ,pass );if _abg !=nil {return nil ,0,_abg ;
};if _gabb !=nil {_d .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gabb ,d .P ,nil ;};return nil ,0,nil ;};type ecb struct{_b _c .Block ;_ca int ;};type ecbEncrypter ecb ;
type stdHandlerR6 struct{};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_cge errInvalidField )Error ()string {return _ffb .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_cge .Func ,_cge .Field ,_cge .Exp ,_cge .Got );
};

// Authenticate implements StdHandler interface.
func (_cbf stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cbf .alg2a (d ,pass );};