//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ef "bytes";_a "crypto/aes";_b "crypto/cipher";_bd "crypto/md5";_df "crypto/rand";_eg "crypto/rc4";_d "crypto/sha256";_c "crypto/sha512";_cd "encoding/binary";_fc "errors";_g "fmt";_cg "github.com/unidoc/unipdf/v4/common";_bg "hash";
_f "io";_fcd "math";);type ecbDecrypter ecb ;func _fbb (_fd ,_fac string ,_cfa int ,_ecg []byte )error {if len (_ecg )< _cfa {return errInvalidField {Func :_fd ,Field :_fac ,Exp :_cfa ,Got :len (_ecg )};};return nil ;};type stdHandlerR6 struct{};func (_deb stdHandlerR4 )alg4 (_gce []byte ,_ []byte )([]byte ,error ){_egf ,_cec :=_eg .NewCipher (_gce );
if _cec !=nil {return nil ,_fc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_efb :=[]byte (_gg );_cgc :=make ([]byte ,len (_efb ));_egf .XORKeyStream (_cgc ,_efb );return _cgc ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};var _ StdHandler =stdHandlerR4 {};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};type ecb struct{_fe _b .Block ;
_gf int ;};func _fb (_gc _b .Block )_b .BlockMode {return (*ecbDecrypter )(_af (_gc ))};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// Allowed checks if a set of permissions can be granted.
func (_fba Permissions )Allowed (p2 Permissions )bool {return _fba &p2 ==p2 };func (_cgb *ecbDecrypter )BlockSize ()int {return _cgb ._gf };var _ StdHandler =stdHandlerR6 {};

// Authenticate implements StdHandler interface.
func (_cef stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cef .alg2a (d ,pass );};func _eb (_ec _b .Block )_b .BlockMode {return (*ecbEncrypter )(_af (_ec ))};func (_be stdHandlerR4 )alg6 (_daa *StdEncryptDict ,_feg []byte )([]byte ,error ){var (_edda []byte ;
_afe error ;);_gcf :=_be .alg2 (_daa ,_feg );if _daa .R ==2{_edda ,_afe =_be .alg4 (_gcf ,_feg );}else if _daa .R >=3{_edda ,_afe =_be .alg5 (_gcf ,_feg );}else {return nil ,_fc .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _afe !=nil {return nil ,_afe ;
};_cg .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_edda ),string (_daa .U ));_egc :=_edda ;_fbe :=_daa .U ;if _daa .R >=3{if len (_egc )> 16{_egc =_egc [0:16];};if len (_fbe )> 16{_fbe =_fbe [0:16];
};};if !_ef .Equal (_egc ,_fbe ){return nil ,nil ;};return _gcf ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););type ecbEncrypter ecb ;func (_ag errInvalidField )Error ()string {return _g .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ag .Func ,_ag .Field ,_ag .Exp ,_ag .Got );
};func (_ab stdHandlerR4 )alg2 (_db *StdEncryptDict ,_efg []byte )[]byte {_cg .Log .Trace ("\u0061\u006c\u0067\u0032");_fee :=_ab .paddedPass (_efg );_ad :=_bd .New ();_ad .Write (_fee );_ad .Write (_db .O );var _de [4]byte ;_cd .LittleEndian .PutUint32 (_de [:],uint32 (_db .P ));
_ad .Write (_de [:]);_cg .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_de );_ad .Write ([]byte (_ab .ID0 ));_cg .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_db .R ,_db .EncryptMetadata );
if (_db .R >=4)&&!_db .EncryptMetadata {_ad .Write ([]byte {0xff,0xff,0xff,0xff});};_ff :=_ad .Sum (nil );if _db .R >=3{_ad =_bd .New ();for _cfg :=0;_cfg < 50;_cfg ++{_ad .Reset ();_ad .Write (_ff [0:_ab .Length /8]);_ff =_ad .Sum (nil );};};if _db .R >=3{return _ff [0:_ab .Length /8];
};return _ff [0:5];};func _bb (_cbe []byte )(_b .Block ,error ){_cab ,_fcb :=_a .NewCipher (_cbe );if _fcb !=nil {_cg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_fcb );
return nil ,_fcb ;};return _cab ,nil ;};func (_gbe stdHandlerR4 )alg3 (R int ,_ffb ,_bdc []byte )([]byte ,error ){var _ca []byte ;if len (_bdc )> 0{_ca =_gbe .alg3Key (R ,_bdc );}else {_ca =_gbe .alg3Key (R ,_ffb );};_baa ,_fdd :=_eg .NewCipher (_ca );
if _fdd !=nil {return nil ,_fc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_abd :=_gbe .paddedPass (_ffb );_da :=make ([]byte ,len (_abd ));_baa .XORKeyStream (_da ,_abd );if R >=3{_ce :=make ([]byte ,len (_ca ));
for _fdb :=0;_fdb < 19;_fdb ++{for _fea :=0;_fea < len (_ca );_fea ++{_ce [_fea ]=_ca [_fea ]^byte (_fdb +1);};_feec ,_aac :=_eg .NewCipher (_ce );if _aac !=nil {return nil ,_fc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_feec .XORKeyStream (_da ,_da );};};return _da ,nil ;};

// Authenticate implements StdHandler interface.
func (_gcd stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_cg .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_gdg ,_gfb :=_gcd .alg7 (d ,pass );if _gfb !=nil {return nil ,0,_gfb ;};if _gdg !=nil {_cg .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gdg ,PermOwner ,nil ;
};_cg .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gdg ,_gfb =_gcd .alg6 (d ,pass );if _gfb !=nil {return nil ,0,_gfb ;
};if _gdg !=nil {_cg .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gdg ,d .P ,nil ;};return nil ,0,nil ;};func _bdbg (_fed []byte ,_fdgb int ){_gbb :=_fdgb ;
for _gbb < len (_fed ){copy (_fed [_gbb :],_fed [:_gbb ]);_gbb *=2;};};func (_acb stdHandlerR6 )alg2b (R int ,_dd ,_baf ,_ege []byte )([]byte ,error ){if R ==5{return _fad (_dd );};return _ffd (_dd ,_baf ,_ege );};func _ffd (_egba ,_cbb ,_cde []byte )([]byte ,error ){var (_ggb ,_dgd ,_fegb _bg .Hash ;
);_ggb =_d .New ();_abc :=make ([]byte ,64);_ecfe :=_ggb ;_ecfe .Write (_egba );K :=_ecfe .Sum (_abc [:0]);_cfb :=make ([]byte ,64*(127+64+48));_egcf :=func (_ int )([]byte ,error ){_gge :=len (_cbb )+len (K )+len (_cde );_fbf :=_cfb [:_gge ];_fce :=copy (_fbf ,_cbb );
_fce +=copy (_fbf [_fce :],K [:]);_fce +=copy (_fbf [_fce :],_cde );if _fce !=_gge {_cg .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_fc .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cfb [:_gge *64];_bdbg (K1 ,_gge );_eca ,_eff :=_bb (K [0:16]);if _eff !=nil {return nil ,_eff ;};_acga :=_b .NewCBCEncrypter (_eca ,K [16:32]);_acga .CryptBlocks (K1 ,K1 );
E :=K1 ;_bea :=0;for _fbeg :=0;_fbeg < 16;_fbeg ++{_bea +=int (E [_fbeg ]%3);};var _aga _bg .Hash ;switch _bea %3{case 0:_aga =_ggb ;case 1:if _dgd ==nil {_dgd =_c .New384 ();};_aga =_dgd ;case 2:if _fegb ==nil {_fegb =_c .New ();};_aga =_fegb ;};_aga .Reset ();
_aga .Write (E );K =_aga .Sum (_abc [:0]);return E ,nil ;};for _gbd :=0;;{E ,_egcc :=_egcf (_gbd );if _egcc !=nil {return nil ,_egcc ;};_dba :=E [len (E )-1];_gbd ++;if _gbd >=64&&_dba <=uint8 (_gbd -32){break ;};};return K [:32],nil ;};const _gg ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";
func (_dcf stdHandlerR6 )alg2a (_efc *StdEncryptDict ,_acg []byte )([]byte ,Permissions ,error ){if _eddg :=_fbb ("\u0061\u006c\u00672\u0061","\u004f",48,_efc .O );_eddg !=nil {return nil ,0,_eddg ;};if _eda :=_fbb ("\u0061\u006c\u00672\u0061","\u0055",48,_efc .U );
_eda !=nil {return nil ,0,_eda ;};if len (_acg )> 127{_acg =_acg [:127];};_add ,_bbc :=_dcf .alg12 (_efc ,_acg );if _bbc !=nil {return nil ,0,_bbc ;};var (_dab []byte ;_cdd []byte ;_bff []byte ;);var _caf Permissions ;if len (_add )!=0{_caf =PermOwner ;
_egg :=make ([]byte ,len (_acg )+8+48);_gdc :=copy (_egg ,_acg );_gdc +=copy (_egg [_gdc :],_efc .O [40:48]);copy (_egg [_gdc :],_efc .U [0:48]);_dab =_egg ;_cdd =_efc .OE ;_bff =_efc .U [0:48];}else {_add ,_bbc =_dcf .alg11 (_efc ,_acg );if _bbc ==nil &&len (_add )==0{_add ,_bbc =_dcf .alg11 (_efc ,[]byte (""));
};if _bbc !=nil {return nil ,0,_bbc ;}else if len (_add )==0{return nil ,0,nil ;};_caf =_efc .P ;_cbc :=make ([]byte ,len (_acg )+8);_bda :=copy (_cbc ,_acg );copy (_cbc [_bda :],_efc .U [40:48]);_dab =_cbc ;_cdd =_efc .UE ;_bff =nil ;};if _ae :=_fbb ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_cdd );
_ae !=nil {return nil ,0,_ae ;};_cdd =_cdd [:32];_fdg ,_bbc :=_dcf .alg2b (_efc .R ,_dab ,_acg ,_bff );if _bbc !=nil {return nil ,0,_bbc ;};_adf ,_bbc :=_a .NewCipher (_fdg [:32]);if _bbc !=nil {return nil ,0,_bbc ;};_dag :=make ([]byte ,_a .BlockSize );
_ee :=_b .NewCBCDecrypter (_adf ,_dag );_gfac :=make ([]byte ,32);_ee .CryptBlocks (_gfac ,_cdd );if _efc .R ==5{return _gfac ,_caf ,nil ;};_bbc =_dcf .alg13 (_efc ,_gfac );if _bbc !=nil {return nil ,0,_bbc ;};return _gfac ,_caf ,nil ;};const (PermOwner =Permissions (_fcd .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);type stdHandlerR4 struct{Length int ;ID0 string ;};func (stdHandlerR4 )paddedPass (_geg []byte )[]byte {_ed :=make ([]byte ,32);_gb :=copy (_ed ,_geg );for ;_gb < 32;_gb ++{_ed [_gb ]=_gg [_gb -len (_geg )];};return _ed ;};func _fad (_bee []byte )([]byte ,error ){_abb :=_d .New ();
_abb .Write (_bee );return _abb .Sum (nil ),nil };func (_fbafb stdHandlerR6 )alg13 (_cdc *StdEncryptDict ,_cge []byte )error {if _eea :=_fbb ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_cge );_eea !=nil {return _eea ;};if _fegbg :=_fbb ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_cdc .Perms );
_fegbg !=nil {return _fegbg ;};_gege :=make ([]byte ,16);copy (_gege ,_cdc .Perms [:16]);_ccd ,_cga :=_a .NewCipher (_cge [:32]);if _cga !=nil {return _cga ;};_bbee :=_fb (_ccd );_bbee .CryptBlocks (_gege ,_gege );if !_ef .Equal (_gege [9:12],[]byte ("\u0061\u0064\u0062")){return _fc .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_bffe :=Permissions (_cd .LittleEndian .Uint32 (_gege [0:4]));if _bffe !=_cdc .P {return _fc .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _ddf bool ;switch _gege [8]{case 'T':_ddf =true ;case 'F':_ddf =false ;default:return _fc .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _ddf !=_cdc .EncryptMetadata {return _fc .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_aaa stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_fec :=make ([]byte ,32);if _ ,_bga :=_f .ReadFull (_df .Reader ,_fec );_bga !=nil {return nil ,_bga ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _gab :=_aaa .alg8 (d ,_fec ,upass );_gab !=nil {return nil ,_gab ;};if _ada :=_aaa .alg9 (d ,_fec ,opass );_ada !=nil {return nil ,_ada ;};if d .R ==5{return _fec ,nil ;
};if _gcfg :=_aaa .alg10 (d ,_fec );_gcfg !=nil {return nil ,_gcfg ;};return _fec ,nil ;};func (_cf *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cf ._gf !=0{_cg .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cg .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cf ._fe .Decrypt (dst ,src [:_cf ._gf ]);src =src [_cf ._gf :];dst =dst [_cf ._gf :];};};func (_dea stdHandlerR4 )alg3Key (R int ,_gfa []byte )[]byte {_fbg :=_bd .New ();_gef :=_dea .paddedPass (_gfa );_fbg .Write (_gef );if R >=3{for _cfe :=0;
_cfe < 50;_cfe ++{_ecf :=_fbg .Sum (nil );_fbg =_bd .New ();_fbg .Write (_ecf );};};_aa :=_fbg .Sum (nil );if R ==2{_aa =_aa [0:5];}else {_aa =_aa [0:_dea .Length /8];};return _aa ;};func (_ba *ecbEncrypter )BlockSize ()int {return _ba ._gf };

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ac *StdEncryptDict ,_ea ,_ge []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fa *StdEncryptDict ,_bdb []byte )([]byte ,Permissions ,error );};func (_cb *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cb ._gf !=0{_cg .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cg .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cb ._fe .Encrypt (dst ,src [:_cb ._gf ]);src =src [_cb ._gf :];dst =dst [_cb ._gf :];};};func (_ded stdHandlerR6 )alg12 (_fdgf *StdEncryptDict ,_bdba []byte )([]byte ,error ){if _daf :=_fbb ("\u0061\u006c\u00671\u0032","\u0055",48,_fdgf .U );
_daf !=nil {return nil ,_daf ;};if _efbg :=_fbb ("\u0061\u006c\u00671\u0032","\u004f",48,_fdgf .O );_efbg !=nil {return nil ,_efbg ;};_bdce :=make ([]byte ,len (_bdba )+8+48);_ddd :=copy (_bdce ,_bdba );_ddd +=copy (_bdce [_ddd :],_fdgf .O [32:40]);_ddd +=copy (_bdce [_ddd :],_fdgf .U [0:48]);
_eab ,_dddg :=_ded .alg2b (_fdgf .R ,_bdce ,_bdba ,_fdgf .U [0:48]);if _dddg !=nil {return nil ,_dddg ;};_eab =_eab [:32];if !_ef .Equal (_eab ,_fdgf .O [:32]){return nil ,nil ;};return _eab ,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _af (_dc _b .Block )*ecb {return &ecb {_fe :_dc ,_gf :_dc .BlockSize ()}};func (_bdd stdHandlerR4 )alg7 (_daag *StdEncryptDict ,_gbc []byte )([]byte ,error ){_gea :=_bdd .alg3Key (_daag .R ,_gbc );
_edg :=make ([]byte ,len (_daag .O ));if _daag .R ==2{_dcb ,_beb :=_eg .NewCipher (_gea );if _beb !=nil {return nil ,_fc .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_dcb .XORKeyStream (_edg ,_daag .O );}else if _daag .R >=3{_cggd :=append ([]byte {},_daag .O ...);
for _agd :=0;_agd < 20;_agd ++{_bgg :=append ([]byte {},_gea ...);for _cggg :=0;_cggg < len (_gea );_cggg ++{_bgg [_cggg ]^=byte (19-_agd );};_gd ,_abg :=_eg .NewCipher (_bgg );if _abg !=nil {return nil ,_fc .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_gd .XORKeyStream (_edg ,_cggd );_cggd =append ([]byte {},_edg ...);};}else {return nil ,_fc .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_dga ,_gca :=_bdd .alg6 (_daag ,_edg );if _gca !=nil {return nil ,nil ;};return _dga ,nil ;};func (_bf stdHandlerR4 )alg5 (_eac []byte ,_ []byte )([]byte ,error ){_eaa :=_bd .New ();
_eaa .Write ([]byte (_gg ));_eaa .Write ([]byte (_bf .ID0 ));_dfg :=_eaa .Sum (nil );_cg .Log .Trace ("\u0061\u006c\u0067\u0035");_cg .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_eac );_cg .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bf .ID0 );
if len (_dfg )!=16{return nil ,_fc .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_egb ,_ade :=_eg .NewCipher (_eac );if _ade !=nil {return nil ,_fc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ffg :=make ([]byte ,16);_egb .XORKeyStream (_ffg ,_dfg );_fae :=make ([]byte ,len (_eac ));for _edd :=0;_edd < 19;_edd ++{for _dg :=0;_dg < len (_eac );_dg ++{_fae [_dg ]=_eac [_dg ]^byte (_edd +1);};_egb ,_ade =_eg .NewCipher (_fae );if _ade !=nil {return nil ,_fc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_egb .XORKeyStream (_ffg ,_ffg );_cg .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_edd ,_fae );_cg .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_edd ,_ffg );
};_egff :=make ([]byte ,32);for _bc :=0;_bc < 16;_bc ++{_egff [_bc ]=_ffg [_bc ];};_ ,_ade =_df .Read (_egff [16:32]);if _ade !=nil {return nil ,_fc .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _egff ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_eddb stdHandlerR6 )alg10 (_bfb *StdEncryptDict ,_agde []byte )error {if _bbe :=_fbb ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_agde );_bbe !=nil {return _bbe ;};_bcf :=uint64 (uint32 (_bfb .P ))|(_fcd .MaxUint32 <<32);
Perms :=make ([]byte ,16);_cd .LittleEndian .PutUint64 (Perms [:8],_bcf );if _bfb .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_fda :=_f .ReadFull (_df .Reader ,Perms [12:16]);_fda !=nil {return _fda ;
};_faa ,_fbc :=_bb (_agde [:32]);if _fbc !=nil {return _fbc ;};_gcb :=_eb (_faa );_gcb .CryptBlocks (Perms ,Perms );_bfb .Perms =Perms [:16];return nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_fbae stdHandlerR6 )alg9 (_abab *StdEncryptDict ,_cda []byte ,_cfbg []byte )error {if _gdcg :=_fbb ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_cda );_gdcg !=nil {return _gdcg ;};if _egbc :=_fbb ("\u0061\u006c\u0067\u0039","\u0055",48,_abab .U );
_egbc !=nil {return _egbc ;};var _eee [16]byte ;if _ ,_cc :=_f .ReadFull (_df .Reader ,_eee [:]);_cc !=nil {return _cc ;};_ccg :=_eee [0:8];_ffba :=_eee [8:16];_bge :=_abab .U [:48];_bfeb :=make ([]byte ,len (_cfbg )+len (_ccg )+len (_bge ));_fbaf :=copy (_bfeb ,_cfbg );
_fbaf +=copy (_bfeb [_fbaf :],_ccg );_fbaf +=copy (_bfeb [_fbaf :],_bge );_ggc ,_aef :=_fbae .alg2b (_abab .R ,_bfeb ,_cfbg ,_bge );if _aef !=nil {return _aef ;};O :=make ([]byte ,len (_ggc )+len (_ccg )+len (_ffba ));_fbaf =copy (O ,_ggc [:32]);_fbaf +=copy (O [_fbaf :],_ccg );
_fbaf +=copy (O [_fbaf :],_ffba );_abab .O =O ;_fbaf =len (_cfbg );_fbaf +=copy (_bfeb [_fbaf :],_ffba );_ggc ,_aef =_fbae .alg2b (_abab .R ,_bfeb ,_cfbg ,_bge );if _aef !=nil {return _aef ;};_ga ,_aef :=_bb (_ggc [:32]);if _aef !=nil {return _aef ;};_agb :=make ([]byte ,_a .BlockSize );
_bgec :=_b .NewCBCEncrypter (_ga ,_agb );OE :=make ([]byte ,32);_bgec .CryptBlocks (OE ,_cda [:32]);_abab .OE =OE ;return nil ;};func (_ebf stdHandlerR6 )alg11 (_cee *StdEncryptDict ,_degd []byte )([]byte ,error ){if _ffe :=_fbb ("\u0061\u006c\u00671\u0031","\u0055",48,_cee .U );
_ffe !=nil {return nil ,_ffe ;};_fca :=make ([]byte ,len (_degd )+8);_agcd :=copy (_fca ,_degd );_agcd +=copy (_fca [_agcd :],_cee .U [32:40]);_dgg ,_dbd :=_ebf .alg2b (_cee .R ,_fca ,_degd ,nil );if _dbd !=nil {return nil ,_dbd ;};_dgg =_dgg [:32];if !_ef .Equal (_dgg ,_cee .U [:32]){return nil ,nil ;
};return _dgg ,nil ;};func (_eaf stdHandlerR6 )alg8 (_adg *StdEncryptDict ,_eacf []byte ,_dce []byte )error {if _bad :=_fbb ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_eacf );_bad !=nil {return _bad ;};var _cdg [16]byte ;if _ ,_dgaa :=_f .ReadFull (_df .Reader ,_cdg [:]);
_dgaa !=nil {return _dgaa ;};_efe :=_cdg [0:8];_agc :=_cdg [8:16];_fcg :=make ([]byte ,len (_dce )+len (_efe ));_bcd :=copy (_fcg ,_dce );copy (_fcg [_bcd :],_efe );_efd ,_abf :=_eaf .alg2b (_adg .R ,_fcg ,_dce ,nil );if _abf !=nil {return _abf ;};U :=make ([]byte ,len (_efd )+len (_efe )+len (_agc ));
_bcd =copy (U ,_efd [:32]);_bcd +=copy (U [_bcd :],_efe );copy (U [_bcd :],_agc );_adg .U =U ;_bcd =len (_dce );copy (_fcg [_bcd :],_agc );_efd ,_abf =_eaf .alg2b (_adg .R ,_fcg ,_dce ,nil );if _abf !=nil {return _abf ;};_deg ,_abf :=_bb (_efd [:32]);if _abf !=nil {return _abf ;
};_egbg :=make ([]byte ,_a .BlockSize );_bab :=_b .NewCBCEncrypter (_deg ,_egbg );UE :=make ([]byte ,32);_bab .CryptBlocks (UE ,_eacf [:32]);_adg .UE =UE ;return nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fff stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_dcbf :=_fff .alg3 (d .R ,upass ,opass );if _dcbf !=nil {_cg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dcbf );
return nil ,_dcbf ;};d .O =O ;_cg .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_ega :=_fff .alg2 (d ,upass );U ,_dcbf :=_fff .alg5 (_ega ,upass );if _dcbf !=nil {_cg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dcbf );
return nil ,_dcbf ;};d .U =U ;_cg .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _ega ,nil ;};