//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ec "bytes";_g "crypto/aes";_f "crypto/cipher";_cf "crypto/md5";_fb "crypto/rand";_aa "crypto/rc4";_b "crypto/sha256";_ed "crypto/sha512";_bf "encoding/binary";_c "errors";_ab "fmt";_gg "github.com/unidoc/unipdf/v4/common";_a "hash";
_e "io";_bc "math";);func (_ecd stdHandlerR4 )alg2 (_bd *StdEncryptDict ,_gc []byte )[]byte {_gg .Log .Trace ("\u0061\u006c\u0067\u0032");_baa :=_ecd .paddedPass (_gc );_dac :=_cf .New ();_dac .Write (_baa );_dac .Write (_bd .O );var _eb [4]byte ;_bf .LittleEndian .PutUint32 (_eb [:],uint32 (_bd .P ));
_dac .Write (_eb [:]);_gg .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_eb );_dac .Write ([]byte (_ecd .ID0 ));_gg .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_bd .R ,_bd .EncryptMetadata );
if (_bd .R >=4)&&!_bd .EncryptMetadata {_dac .Write ([]byte {0xff,0xff,0xff,0xff});};_gaaa :=_dac .Sum (nil );if _bd .R >=3{_dac =_cf .New ();for _bb :=0;_bb < 50;_bb ++{_dac .Reset ();_dac .Write (_gaaa [0:_ecd .Length /8]);_gaaa =_dac .Sum (nil );};};
if _bd .R >=3{return _gaaa [0:_ecd .Length /8];};return _gaaa [0:5];};type ecbDecrypter ecb ;

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_edb stdHandlerR6 )alg2a (_ged *StdEncryptDict ,_fda []byte )([]byte ,Permissions ,error ){if _bdg :=_add ("\u0061\u006c\u00672\u0061","\u004f",48,_ged .O );_bdg !=nil {return nil ,0,_bdg ;};if _cec :=_add ("\u0061\u006c\u00672\u0061","\u0055",48,_ged .U );
_cec !=nil {return nil ,0,_cec ;};if len (_fda )> 127{_fda =_fda [:127];};_dgc ,_dfe :=_edb .alg12 (_ged ,_fda );if _dfe !=nil {return nil ,0,_dfe ;};var (_bce []byte ;_egd []byte ;_bafd []byte ;);var _gdg Permissions ;if len (_dgc )!=0{_gdg =PermOwner ;
_cfa :=make ([]byte ,len (_fda )+8+48);_ggg :=copy (_cfa ,_fda );_ggg +=copy (_cfa [_ggg :],_ged .O [40:48]);copy (_cfa [_ggg :],_ged .U [0:48]);_bce =_cfa ;_egd =_ged .OE ;_bafd =_ged .U [0:48];}else {_dgc ,_dfe =_edb .alg11 (_ged ,_fda );if _dfe ==nil &&len (_dgc )==0{_dgc ,_dfe =_edb .alg11 (_ged ,[]byte (""));
};if _dfe !=nil {return nil ,0,_dfe ;}else if len (_dgc )==0{return nil ,0,nil ;};_gdg =_ged .P ;_bfg :=make ([]byte ,len (_fda )+8);_edbe :=copy (_bfg ,_fda );copy (_bfg [_edbe :],_ged .U [40:48]);_bce =_bfg ;_egd =_ged .UE ;_bafd =nil ;};if _agf :=_add ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_egd );
_agf !=nil {return nil ,0,_agf ;};_egd =_egd [:32];_dec ,_dfe :=_edb .alg2b (_ged .R ,_bce ,_fda ,_bafd );if _dfe !=nil {return nil ,0,_dfe ;};_gde ,_dfe :=_g .NewCipher (_dec [:32]);if _dfe !=nil {return nil ,0,_dfe ;};_aef :=make ([]byte ,_g .BlockSize );
_ecf :=_f .NewCBCDecrypter (_gde ,_aef );_agd :=make ([]byte ,32);_ecf .CryptBlocks (_agd ,_egd );if _ged .R ==5{return _agd ,_gdg ,nil ;};_dfe =_edb .alg13 (_ged ,_agd );if _dfe !=nil {return nil ,0,_dfe ;};return _agd ,_gdg ,nil ;};func _bg (_ga _f .Block )*ecb {return &ecb {_fd :_ga ,_aad :_ga .BlockSize ()}};
const _bad ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";type ecbEncrypter ecb ;func (_df stdHandlerR4 )alg7 (_baf *StdEncryptDict ,_ece []byte )([]byte ,error ){_bfad :=_df .alg3Key (_baf .R ,_ece );
_ae :=make ([]byte ,len (_baf .O ));if _baf .R ==2{_cfgg ,_fcc :=_aa .NewCipher (_bfad );if _fcc !=nil {return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cfgg .XORKeyStream (_ae ,_baf .O );}else if _baf .R >=3{_fee :=append ([]byte {},_baf .O ...);
for _be :=0;_be < 20;_be ++{_gdf :=append ([]byte {},_bfad ...);for _ddg :=0;_ddg < len (_bfad );_ddg ++{_gdf [_ddg ]^=byte (19-_be );};_aba ,_cdbd :=_aa .NewCipher (_gdf );if _cdbd !=nil {return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_aba .XORKeyStream (_ae ,_fee );_fee =append ([]byte {},_ae ...);};}else {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_bed ,_edd :=_df .alg6 (_baf ,_ae );if _edd !=nil {return nil ,nil ;};return _bed ,nil ;};

// Authenticate implements StdHandler interface.
func (_eac stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _eac .alg2a (d ,pass );};func (_cad stdHandlerR4 )alg3Key (R int ,_acg []byte )[]byte {_bbb :=_cf .New ();_fe :=_cad .paddedPass (_acg );_bbb .Write (_fe );
if R >=3{for _ebb :=0;_ebb < 50;_ebb ++{_efa :=_bbb .Sum (nil );_bbb =_cf .New ();_bbb .Write (_efa );};};_bfe :=_bbb .Sum (nil );if R ==2{_bfe =_bfe [0:5];}else {_bfe =_bfe [0:_cad .Length /8];};return _bfe ;};func (_efb stdHandlerR6 )alg12 (_fga *StdEncryptDict ,_badc []byte )([]byte ,error ){if _edfg :=_add ("\u0061\u006c\u00671\u0032","\u0055",48,_fga .U );
_edfg !=nil {return nil ,_edfg ;};if _dcf :=_add ("\u0061\u006c\u00671\u0032","\u004f",48,_fga .O );_dcf !=nil {return nil ,_dcf ;};_bda :=make ([]byte ,len (_badc )+8+48);_ebfce :=copy (_bda ,_badc );_ebfce +=copy (_bda [_ebfce :],_fga .O [32:40]);_ebfce +=copy (_bda [_ebfce :],_fga .U [0:48]);
_ade ,_bbg :=_efb .alg2b (_fga .R ,_bda ,_badc ,_fga .U [0:48]);if _bbg !=nil {return nil ,_bbg ;};_ade =_ade [:32];if !_ec .Equal (_ade ,_fga .O [:32]){return nil ,nil ;};return _ade ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_fba *ecbEncrypter )BlockSize ()int {return _fba ._aad };func _ca (_ad _f .Block )_f .BlockMode {return (*ecbEncrypter )(_bg (_ad ))};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_edeb stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_fg :=_edeb .alg3 (d .R ,upass ,opass );if _fg !=nil {_gg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fg );
return nil ,_fg ;};d .O =O ;_gg .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_edc :=_edeb .alg2 (d ,upass );U ,_fg :=_edeb .alg5 (_edc ,upass );if _fg !=nil {_gg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fg );
return nil ,_fg ;};d .U =U ;_gg .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _edc ,nil ;};func (_gba stdHandlerR6 )alg13 (_cdgg *StdEncryptDict ,_fdca []byte )error {if _ccf :=_add ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_fdca );
_ccf !=nil {return _ccf ;};if _agc :=_add ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_cdgg .Perms );_agc !=nil {return _agc ;};_dgb :=make ([]byte ,16);copy (_dgb ,_cdgg .Perms [:16]);_ggcf ,_cgbd :=_g .NewCipher (_fdca [:32]);if _cgbd !=nil {return _cgbd ;
};_gff :=_dg (_ggcf );_gff .CryptBlocks (_dgb ,_dgb );if !_ec .Equal (_dgb [9:12],[]byte ("\u0061\u0064\u0062")){return _c .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_cfde :=Permissions (_bf .LittleEndian .Uint32 (_dgb [0:4]));if _cfde !=_cdgg .P {return _c .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _gfeb bool ;switch _dgb [8]{case 'T':_gfeb =true ;case 'F':_gfeb =false ;default:return _c .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _gfeb !=_cdgg .EncryptMetadata {return _c .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_bbfc stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_efe :=make ([]byte ,32);if _ ,_edcb :=_e .ReadFull (_fb .Reader ,_efe );_edcb !=nil {return nil ,_edcb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _fagg :=_bbfc .alg8 (d ,_efe ,upass );_fagg !=nil {return nil ,_fagg ;};if _dcc :=_bbfc .alg9 (d ,_efe ,opass );_dcc !=nil {return nil ,_dcc ;};if d .R ==5{return _efe ,nil ;
};if _cab :=_bbfc .alg10 (d ,_efe );_cab !=nil {return nil ,_cab ;};return _efe ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (stdHandlerR4 )paddedPass (_ce []byte )[]byte {_gaa :=make ([]byte ,32);_fc :=copy (_gaa ,_ce );for ;_fc < 32;_fc ++{_gaa [_fc ]=_bad [_fc -len (_ce )];
};return _gaa ;};func _cae (_fa ,_cgf ,_fbd []byte )([]byte ,error ){var (_eff ,_afgf ,_geb _a .Hash ;);_eff =_b .New ();_gfa :=make ([]byte ,64);_bfb :=_eff ;_bfb .Write (_fa );K :=_bfb .Sum (_gfa [:0]);_cfae :=make ([]byte ,64*(127+64+48));_acd :=func (_ int )([]byte ,error ){_agdb :=len (_cgf )+len (K )+len (_fbd );
_ebf :=_cfae [:_agdb ];_ccc :=copy (_ebf ,_cgf );_ccc +=copy (_ebf [_ccc :],K [:]);_ccc +=copy (_ebf [_ccc :],_fbd );if _ccc !=_agdb {_gg .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_c .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cfae [:_agdb *64];_gbf (K1 ,_agdb );_gfe ,_abe :=_dce (K [0:16]);if _abe !=nil {return nil ,_abe ;};_eagd :=_f .NewCBCEncrypter (_gfe ,K [16:32]);_eagd .CryptBlocks (K1 ,K1 );
E :=K1 ;_ffb :=0;for _aadb :=0;_aadb < 16;_aadb ++{_ffb +=int (E [_aadb ]%3);};var _bcd _a .Hash ;switch _ffb %3{case 0:_bcd =_eff ;case 1:if _afgf ==nil {_afgf =_ed .New384 ();};_bcd =_afgf ;case 2:if _geb ==nil {_geb =_ed .New ();};_bcd =_geb ;};_bcd .Reset ();
_bcd .Write (E );K =_bcd .Sum (_gfa [:0]);return E ,nil ;};for _fge :=0;;{E ,_bdca :=_acd (_fge );if _bdca !=nil {return nil ,_bdca ;};_bcef :=E [len (E )-1];_fge ++;if _fge >=64&&_bcef <=uint8 (_fge -32){break ;};};return K [:32],nil ;};type ecb struct{_fd _f .Block ;
_aad int ;};var _ StdHandler =stdHandlerR6 {};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_dgg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dgg ._aad !=0{_gg .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_gg .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_dgg ._fd .Decrypt (dst ,src [:_dgg ._aad ]);src =src [_dgg ._aad :];dst =dst [_dgg ._aad :];};};func _dg (_ba _f .Block )_f .BlockMode {return (*ecbDecrypter )(_bg (_ba ))};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};type stdHandlerR6 struct{};func _add (_ef ,_de string ,_eg int ,_ede []byte )error {if len (_ede )< _eg {return errInvalidField {Func :_ef ,Field :_de ,Exp :_eg ,Got :len (_ede )};};return nil ;};
func (_cfd stdHandlerR6 )alg2b (R int ,_ddd ,_cdcc ,_fbag []byte )([]byte ,error ){if R ==5{return _ggc (_ddd );};return _cae (_ddd ,_cdcc ,_fbag );};func (_bcc stdHandlerR4 )alg3 (R int ,_bfa ,_cfg []byte )([]byte ,error ){var _ea []byte ;if len (_cfg )> 0{_ea =_bcc .alg3Key (R ,_cfg );
}else {_ea =_bcc .alg3Key (R ,_bfa );};_bdc ,_efc :=_aa .NewCipher (_ea );if _efc !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cfgd :=_bcc .paddedPass (_bfa );_eca :=make ([]byte ,len (_cfgd ));
_bdc .XORKeyStream (_eca ,_cfgd );if R >=3{_aada :=make ([]byte ,len (_ea ));for _af :=0;_af < 19;_af ++{for _bdf :=0;_bdf < len (_ea );_bdf ++{_aada [_bdf ]=_ea [_bdf ]^byte (_af +1);};_cc ,_abb :=_aa .NewCipher (_aada );if _abb !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cc .XORKeyStream (_eca ,_eca );};};return _eca ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gge *StdEncryptDict ,_bag ,_adc []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_da *StdEncryptDict ,_bac []byte )([]byte ,Permissions ,error );};func (_fca stdHandlerR4 )alg4 (_bgf []byte ,_ []byte )([]byte ,error ){_dc ,_ff :=_aa .NewCipher (_bgf );if _ff !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dgd :=[]byte (_bad );_gd :=make ([]byte ,len (_dgd ));_dc .XORKeyStream (_gd ,_dgd );return _gd ,nil ;};func _ggc (_afc []byte )([]byte ,error ){_efcd :=_b .New ();_efcd .Write (_afc );return _efcd .Sum (nil ),nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_ebc stdHandlerR4 )alg5 (_bbbe []byte ,_ []byte )([]byte ,error ){_ecc :=_cf .New ();_ecc .Write ([]byte (_bad ));_ecc .Write ([]byte (_ebc .ID0 ));_bcf :=_ecc .Sum (nil );_gg .Log .Trace ("\u0061\u006c\u0067\u0035");
_gg .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_bbbe );_gg .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ebc .ID0 );if len (_bcf )!=16{return nil ,_c .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_ffe ,_dd :=_aa .NewCipher (_bbbe );if _dd !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eag :=make ([]byte ,16);_ffe .XORKeyStream (_eag ,_bcf );_gab :=make ([]byte ,len (_bbbe ));
for _bfag :=0;_bfag < 19;_bfag ++{for _fdg :=0;_fdg < len (_bbbe );_fdg ++{_gab [_fdg ]=_bbbe [_fdg ]^byte (_bfag +1);};_ffe ,_dd =_aa .NewCipher (_gab );if _dd !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ffe .XORKeyStream (_eag ,_eag );_gg .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_bfag ,_gab );_gg .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_bfag ,_eag );
};_fef :=make ([]byte ,32);for _bde :=0;_bde < 16;_bde ++{_fef [_bde ]=_eag [_bde ];};_ ,_dd =_fb .Read (_fef [16:32]);if _dd !=nil {return nil ,_c .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _fef ,nil ;};func (_cg *ecbDecrypter )BlockSize ()int {return _cg ._aad };func _dce (_dfg []byte )(_f .Block ,error ){_gb ,_eccd :=_g .NewCipher (_dfg );if _eccd !=nil {_gg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_eccd );
return nil ,_eccd ;};return _gb ,nil ;};func (_gcaf stdHandlerR6 )alg11 (_gedf *StdEncryptDict ,_bcaa []byte )([]byte ,error ){if _cfc :=_add ("\u0061\u006c\u00671\u0031","\u0055",48,_gedf .U );_cfc !=nil {return nil ,_cfc ;};_dbc :=make ([]byte ,len (_bcaa )+8);
_bbf :=copy (_dbc ,_bcaa );_bbf +=copy (_dbc [_bbf :],_gedf .U [32:40]);_edf ,_gcg :=_gcaf .alg2b (_gedf .R ,_dbc ,_bcaa ,nil );if _gcg !=nil {return nil ,_gcg ;};_edf =_edf [:32];if !_ec .Equal (_edf ,_gedf .U [:32]){return nil ,nil ;};return _edf ,nil ;
};func (_adf stdHandlerR6 )alg9 (_ffd *StdEncryptDict ,_cecd []byte ,_gfg []byte )error {if _bca :=_add ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_cecd );_bca !=nil {return _bca ;};if _gcff :=_add ("\u0061\u006c\u0067\u0039","\u0055",48,_ffd .U );
_gcff !=nil {return _gcff ;};var _eaed [16]byte ;if _ ,_ecdg :=_e .ReadFull (_fb .Reader ,_eaed [:]);_ecdg !=nil {return _ecdg ;};_cce :=_eaed [0:8];_gaf :=_eaed [8:16];_agg :=_ffd .U [:48];_fcb :=make ([]byte ,len (_gfg )+len (_cce )+len (_agg ));_agfd :=copy (_fcb ,_gfg );
_agfd +=copy (_fcb [_agfd :],_cce );_agfd +=copy (_fcb [_agfd :],_agg );_ace ,_dad :=_adf .alg2b (_ffd .R ,_fcb ,_gfg ,_agg );if _dad !=nil {return _dad ;};O :=make ([]byte ,len (_ace )+len (_cce )+len (_gaf ));_agfd =copy (O ,_ace [:32]);_agfd +=copy (O [_agfd :],_cce );
_agfd +=copy (O [_agfd :],_gaf );_ffd .O =O ;_agfd =len (_gfg );_agfd +=copy (_fcb [_agfd :],_gaf );_ace ,_dad =_adf .alg2b (_ffd .R ,_fcb ,_gfg ,_agg );if _dad !=nil {return _dad ;};_aac ,_dad :=_dce (_ace [:32]);if _dad !=nil {return _dad ;};_ecec :=make ([]byte ,_g .BlockSize );
_abf :=_f .NewCBCEncrypter (_aac ,_ecec );OE :=make ([]byte ,32);_abf .CryptBlocks (OE ,_cecd [:32]);_ffd .OE =OE ;return nil ;};

// Allowed checks if a set of permissions can be granted.
func (_cdb Permissions )Allowed (p2 Permissions )bool {return _cdb &p2 ==p2 };func (_gca stdHandlerR4 )alg6 (_aae *StdEncryptDict ,_ag []byte )([]byte ,error ){var (_gac []byte ;_ge error ;);_caf :=_gca .alg2 (_aae ,_ag );if _aae .R ==2{_gac ,_ge =_gca .alg4 (_caf ,_ag );
}else if _aae .R >=3{_gac ,_ge =_gca .alg5 (_caf ,_ag );}else {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _ge !=nil {return nil ,_ge ;};_gg .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gac ),string (_aae .U ));
_cdc :=_gac ;_gcf :=_aae .U ;if _aae .R >=3{if len (_cdc )> 16{_cdc =_cdc [0:16];};if len (_gcf )> 16{_gcf =_gcf [0:16];};};if !_ec .Equal (_cdc ,_gcf ){return nil ,nil ;};return _caf ,nil ;};func (_ac errInvalidField )Error ()string {return _ab .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ac .Func ,_ac .Field ,_ac .Exp ,_ac .Got );
};func _gbf (_db []byte ,_bagd int ){_cdg :=_bagd ;for _cdg < len (_db ){copy (_db [_cdg :],_db [:_cdg ]);_cdg *=2;};};func (_gce stdHandlerR6 )alg8 (_bede *StdEncryptDict ,_gged []byte ,_eab []byte )error {if _addf :=_add ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gged );
_addf !=nil {return _addf ;};var _bbbg [16]byte ;if _ ,_bcdb :=_e .ReadFull (_fb .Reader ,_bbbg [:]);_bcdb !=nil {return _bcdb ;};_ega :=_bbbg [0:8];_adde :=_bbbg [8:16];_ebfc :=make ([]byte ,len (_eab )+len (_ega ));_fgd :=copy (_ebfc ,_eab );copy (_ebfc [_fgd :],_ega );
_dgge ,_ebg :=_gce .alg2b (_bede .R ,_ebfc ,_eab ,nil );if _ebg !=nil {return _ebg ;};U :=make ([]byte ,len (_dgge )+len (_ega )+len (_adde ));_fgd =copy (U ,_dgge [:32]);_fgd +=copy (U [_fgd :],_ega );copy (U [_fgd :],_adde );_bede .U =U ;_fgd =len (_eab );
copy (_ebfc [_fgd :],_adde );_dgge ,_ebg =_gce .alg2b (_bede .R ,_ebfc ,_eab ,nil );if _ebg !=nil {return _ebg ;};_abbd ,_ebg :=_dce (_dgge [:32]);if _ebg !=nil {return _ebg ;};_ee :=make ([]byte ,_g .BlockSize );_eae :=_f .NewCBCEncrypter (_abbd ,_ee );
UE :=make ([]byte ,32);_eae .CryptBlocks (UE ,_gged [:32]);_bede .UE =UE ;return nil ;};func (_cd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cd ._aad !=0{_gg .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_gg .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cd ._fd .Encrypt (dst ,src [:_cd ._aad ]);src =src [_cd ._aad :];dst =dst [_cd ._aad :];};};

// Authenticate implements StdHandler interface.
func (_cbe stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_gg .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_fdc ,_fff :=_cbe .alg7 (d ,pass );if _fff !=nil {return nil ,0,_fff ;};if _fdc !=nil {_gg .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fdc ,PermOwner ,nil ;
};_gg .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_fdc ,_fff =_cbe .alg6 (d ,pass );if _fff !=nil {return nil ,0,_fff ;
};if _fdc !=nil {_gg .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fdc ,d .P ,nil ;};return nil ,0,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;
};const (PermOwner =Permissions (_bc .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);
PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););var _ StdHandler =stdHandlerR4 {};func (_aeg stdHandlerR6 )alg10 (_dgcg *StdEncryptDict ,_fbda []byte )error {if _cbd :=_add ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_fbda );
_cbd !=nil {return _cbd ;};_aace :=uint64 (uint32 (_dgcg .P ))|(_bc .MaxUint32 <<32);Perms :=make ([]byte ,16);_bf .LittleEndian .PutUint64 (Perms [:8],_aace );if _dgcg .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_acgg :=_e .ReadFull (_fb .Reader ,Perms [12:16]);_acgg !=nil {return _acgg ;};_adg ,_cdf :=_dce (_fbda [:32]);if _cdf !=nil {return _cdf ;};_fbf :=_ca (_adg );_fbf .CryptBlocks (Perms ,Perms );_dgcg .Perms =Perms [:16];return nil ;};