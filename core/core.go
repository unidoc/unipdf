//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_ag "bufio";_fcc "bytes";_gb "compress/lzw";_dg "compress/zlib";_cd "crypto/md5";_cc "crypto/rand";_df "encoding/hex";_c "errors";_ba "fmt";_ad "github.com/unidoc/unipdf/v3/common";_cda "github.com/unidoc/unipdf/v3/core/security";
_agf "github.com/unidoc/unipdf/v3/core/security/crypt";_af "github.com/unidoc/unipdf/v3/internal/ccittfax";_fd "github.com/unidoc/unipdf/v3/internal/imageutil";_ff "github.com/unidoc/unipdf/v3/internal/jbig2";_fg "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_ee "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_e "github.com/unidoc/unipdf/v3/internal/jbig2/document";_fgb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_bdc "github.com/unidoc/unipdf/v3/internal/strutils";_aa "golang.org/x/image/tiff/lzw";
_cg "golang.org/x/xerrors";_bdf "image";_gc "image/color";_be "image/jpeg";_gf "io";_fc "io/ioutil";_f "os";_db "reflect";_g "regexp";_fe "sort";_a "strconv";_abb "strings";_b "sync";_ab "time";_bd "unicode";);

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_baab *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func (_effa *PdfObjectInteger )String ()string {return _ba .Sprintf ("\u0025\u0064",*_effa )};func _bgeb (_agag *PdfObjectStream ,_cgd *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};var _aede =_g .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bdcc :=&PdfCrypt {_aga :false ,_edda :make (map[PdfObject ]bool ),_ga :make (map[PdfObject ]bool ),_geg :make (map[int ]struct{}),_bbd :parser };_aed ,_feg :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_feg {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _bdcc ,_c .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_aed !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_ad .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_aed );
return _bdcc ,_c .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bdcc ._gcc .Filter =string (*_aed );if _gfcc ,_adc :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_adc {_bdcc ._gcc .SubFilter =_gfcc .Str ();
_ad .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_gfcc );};if L ,_fgf :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_fgf {if (*L %8)!=0{_ad .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _bdcc ,_c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bdcc ._gcc .Length =int (*L );}else {_bdcc ._gcc .Length =40;};_bdcc ._gcc .V =0;if _adee ,_ec :=ed .Get ("\u0056").(*PdfObjectInteger );
_ec {V :=int (*_adee );_bdcc ._gcc .V =V ;if V >=1&&V <=2{_bdcc ._gca =_addg (_bdcc ._gcc .Length );}else if V >=4&&V <=5{if _eaf :=_bdcc .loadCryptFilters (ed );_eaf !=nil {return _bdcc ,_eaf ;};}else {_ad .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _bdcc ,_c .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _acdb :=_afe (&_bdcc ._ccf ,ed );_acdb !=nil {return _bdcc ,_acdb ;};_dda :="";if _bfe ,_bgd :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_bgd &&_bfe .Len ()>=1{_afde ,_dad :=GetString (_bfe .Get (0));if !_dad {return _bdcc ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_dda =_afde .Str ();}else {_ad .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_bdcc ._addd =_dda ;return _bdcc ,nil ;};const _cba ="\u0053\u0074\u0064C\u0046";func (_ccda *PdfCrypt )encryptBytes (_bafg []byte ,_fee string ,_gfda []byte )([]byte ,error ){_ad .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_eegc ,_dbd :=_ccda ._gca [_fee ];if !_dbd {return nil ,_ba .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fee );};return _eegc .EncryptBytes (_bafg ,_gfda );};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cbdg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_fde *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_fad ,_ ,_gbe :=_fde .lookupByNumberWrapper (objNumber ,true );return _fad ,_gbe ;};

// WriteString outputs the object as it is to be written to file.
func (_dgba *PdfObjectDictionary )WriteString ()string {var _becdc _abb .Builder ;_becdc .WriteString ("\u003c\u003c");for _ ,_dfagd :=range _dgba ._bgad {_bdceg :=_dgba ._bgga [_dfagd ];_becdc .WriteString (_dfagd .WriteString ());_becdc .WriteString ("\u0020");
_becdc .WriteString (_bdceg .WriteString ());};_becdc .WriteString ("\u003e\u003e");return _becdc .String ();};func (_addf *PdfParser )checkLinearizedInformation (_fdfg *PdfObjectDictionary )(bool ,error ){var _eadb error ;_addf ._edbde ,_eadb =GetNumberAsInt64 (_fdfg .Get ("\u004c"));
if _eadb !=nil {return false ,_eadb ;};_eadb =_addf .seekToEOFMarker (_addf ._edbde );switch _eadb {case nil :return true ,nil ;case _ffgd :return false ,nil ;default:return false ,_eadb ;};};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_eegde *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_eegde .setWithLock (key ,val ,true );};const (_gbgd =0;_gbbb =1;_gdb =2;_gfb =3;_afff =4;);

// GetParser returns the parser for lazy-loading or compare references.
func (_efga *PdfObjectReference )GetParser ()*PdfParser {return _efga ._bbcg };

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_acb ParserMetadata )HasInvalidSubsectionHeader ()bool {return _acb ._efb };

// DecodeStream implements ASCII85 stream decoding.
func (_gaaa *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gaaa .DecodeBytes (streamObj .Stream );};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _gf .ReadSeeker )(_geba *PdfParser ,_dbed error ){_geba =&PdfParser {_eebaa :rs ,ObjCache :make (objectCache ),_eedbc :map[int64 ]bool {},_afge :true ,_bdaf :make (map[*PdfParser ]*PdfParser )};if _dbed =_geba .parseDetailedHeader ();
_dbed !=nil {return nil ,_dbed ;};if _geba ._cdcd ,_dbed =_geba .loadXrefs ();_dbed !=nil {_ad .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dbed );
return nil ,_dbed ;};_ad .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_geba ._cdcd );if len (_geba ._caeg .ObjectMap )==0{return nil ,_ba .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _geba ,nil ;};type objectStream struct{N int ;_bec []byte ;_dbg map[int ]int64 ;};var _caec =_g .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_bfcg *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _eage ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _egcde :=_bfcg .AddPageImage (img ,&_bfcg .DefaultPageSettings );
_egcde !=nil {return nil ,_fgb .Wrap (_egcde ,_eage ,"");};return _bfcg .Encode ();};func (_gaacc *PdfParser )rebuildXrefTable ()error {_fbeb :=XrefTable {};_fbeb .ObjectMap =map[int ]XrefObject {};_bbeeb :=make ([]int ,0,len (_gaacc ._caeg .ObjectMap ));
for _gadcb :=range _gaacc ._caeg .ObjectMap {_bbeeb =append (_bbeeb ,_gadcb );};_fe .Ints (_bbeeb );for _ ,_ccgde :=range _bbeeb {_dddbb :=_gaacc ._caeg .ObjectMap [_ccgde ];_abacc ,_ ,_dabe :=_gaacc .lookupByNumberWrapper (_ccgde ,false );if _dabe !=nil {_ad .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_dabe );
_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_adfc ,_egfeg :=_gaacc .repairRebuildXrefsTopDown ();if _egfeg !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_egfeg );
return _egfeg ;};_gaacc ._caeg =*_adfc ;_ad .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_ccfa ,_cccd ,_dabe :=_ce (_abacc );if _dabe !=nil {return _dabe ;
};_dddbb .ObjectNumber =int (_ccfa );_dddbb .Generation =int (_cccd );_fbeb .ObjectMap [int (_ccfa )]=_dddbb ;};_gaacc ._caeg =_fbeb ;_ad .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_eee (_gaacc ._caeg );
return nil ;};func _daf (_bfgg *PdfObjectStream ,_gceg *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _afgd ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_cbee :=NewJBIG2Encoder ();
_dfac :=_bfgg .PdfObjectDictionary ;if _dfac ==nil {return _cbee ,nil ;};if _gceg ==nil {_afcg :=_dfac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _afcg !=nil {switch _cfec :=_afcg .(type ){case *PdfObjectDictionary :_gceg =_cfec ;
case *PdfObjectArray :if _cfec .Len ()==1{if _defg ,_bbbed :=GetDict (_cfec .Get (0));_bbbed {_gceg =_defg ;};};default:_ad .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_afcg );
return nil ,_fgb .Errorf (_afgd ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_cfec );};};};if _gceg ==nil {return _cbee ,nil ;};_cbee .UpdateParams (_gceg );
_gfecd ,_gfcg :=GetStream (_gceg .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_gfcg {return _cbee ,nil ;};var _fdcc error ;_cbee .Globals ,_fdcc =_ff .DecodeGlobals (_gfecd .Stream );if _fdcc !=nil {_fdcc =_fgb .Wrap (_fdcc ,_afgd ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_ad .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fdcc );return nil ,_fdcc ;};return _cbee ,nil ;};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_gfcd *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_agaf :=_gfcd ._dagae ;if _agaf ==revisionNumber {return _gfcd ,nil ;};if _agaf < revisionNumber {return nil ,_c .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _gfcd ._afbb [revisionNumber ]!=nil {return _gfcd ._afbb [revisionNumber ],nil ;};_fcdg :=_gfcd ;for ;_agaf > revisionNumber ;_agaf --{_dfcad ,_abac :=_fcdg .GetPreviousRevisionParser ();if _abac !=nil {return nil ,_abac ;};_gfcd ._afbb [_agaf -1]=_dfcad ;
_gfcd ._bdaf [_fcdg ]=_dfcad ;_fcdg =_dfcad ;};return _fcdg ,nil ;};func (_eedc *PdfCrypt )saveCryptFilters (_feb *PdfObjectDictionary )error {if _eedc ._gcc .V < 4{return _c .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_dce :=MakeDict ();_feb .Set ("\u0043\u0046",_dce );for _dgaf ,_abf :=range _eedc ._gca {if _dgaf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bcf :=_eeb (_abf ,"");_dce .Set (PdfObjectName (_dgaf ),_bcf );};_feb .Set ("\u0053\u0074\u0072\u0046",MakeName (_eedc ._dgea ));
_feb .Set ("\u0053\u0074\u006d\u0046",MakeName (_eedc ._ade ));return nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gcfab string ,_eaca bool ){_aacb ,_eaca :=TraceToDirectObject (obj ).(*PdfObjectString );if _eaca {return _aacb .Str (),true ;};return ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ecab *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_bddae :=MakeDict ();_bddae .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_ecab .GetFilterArray ());for _ ,_cfdc :=range _ecab ._bbee {_ggfd :=_cfdc .MakeStreamDict ();for _ ,_fcca :=range _ggfd .Keys (){_gecc :=_ggfd .Get (_fcca );
if _fcca !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_fcca !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_bddae .Set (_fcca ,_gecc );};};};_bffe :=_ecab .MakeDecodeParams ();if _bffe !=nil {_bddae .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bffe );
};return _bddae ;};func _cge (_eegcc _fd .Image )*JBIG2Image {_fbaf :=_eegcc .Base ();return &JBIG2Image {Data :_fbaf .Data ,Width :_fbaf .Width ,Height :_fbaf .Height ,HasPadding :true };};func _cbeeb (_eebd ,_gaead ,_edeg uint8 )uint8 {_dgdc :=int (_edeg );
_ebf :=int (_gaead )-_dgdc ;_afb :=int (_eebd )-_dgdc ;_dgdc =_dbca (_ebf +_afb );_ebf =_dbca (_ebf );_afb =_dbca (_afb );if _ebf <=_afb &&_ebf <=_dgdc {return _eebd ;}else if _afb <=_dgdc {return _gaead ;};return _edeg ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_dgafc :=MakeArray ();for _ ,_bcefe :=range vals {_dgafc .Append (MakeInteger (int64 (_bcefe )));};return _dgafc ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_adfb *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_adfb .GetFilterName ());
return data ,ErrNoJPXDecode ;};func (_afdfg *PdfParser )repairSeekXrefMarker ()error {_caced ,_ffcd :=_afdfg ._eebaa .Seek (0,_gf .SeekEnd );if _ffcd !=nil {return _ffcd ;};_cbcgd :=_g .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _aaff int64 ;
var _cfba int64 =1000;for _aaff < _caced {if _caced <=(_cfba +_aaff ){_cfba =_caced -_aaff ;};_ ,_fagd :=_afdfg ._eebaa .Seek (-_aaff -_cfba ,_gf .SeekEnd );if _fagd !=nil {return _fagd ;};_eaeb :=make ([]byte ,_cfba );_afdfg ._eebaa .Read (_eaeb );_ad .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_eaeb ));
_cdaaf :=_cbcgd .FindAllStringIndex (string (_eaeb ),-1);if _cdaaf !=nil {_deac :=_cdaaf [len (_cdaaf )-1];_ad .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cdaaf );_afdfg ._eebaa .Seek (-_aaff -_cfba +int64 (_deac [0]),_gf .SeekEnd );
_afdfg ._bgec =_ag .NewReader (_afdfg ._eebaa );for {_dcea ,_dbacd :=_afdfg ._bgec .Peek (1);if _dbacd !=nil {return _dbacd ;};_ad .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_dcea [0],_dcea [0]);if !IsWhiteSpace (_dcea [0]){break ;
};_afdfg ._bgec .Discard (1);};return nil ;};_ad .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_aaff +=_cfba ;};_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _c .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_cfcbd *PdfObjectFloat ,_bcceg bool ){_cfcbd ,_bcceg =TraceToDirectObject (obj ).(*PdfObjectFloat );return _cfcbd ,_bcceg ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_bgga map[PdfObjectName ]PdfObject ;_bgad []PdfObjectName ;_cbgf *_b .Mutex ;_gfca *PdfParser ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_ggfgc *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_egdc :=_ggfgc .Get (key );if _egdc ==nil {return "",false ;};_gcdea ,_fafb :=_egdc .(*PdfObjectString );if !_fafb {return "",false ;};return _gcdea .Str (),true ;};

// WriteString outputs the object as it is to be written to file.
func (_eccf *PdfObjectFloat )WriteString ()string {return _a .FormatFloat (float64 (*_eccf ),'f',-1,64);};var _ffgd =_c .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_acfd ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _acfd ._bgg };

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fddec *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _fbfg []float64 ;for _ ,_ccceb :=range _fddec .Elements (){switch _bbbg :=_ccceb .(type ){case *PdfObjectInteger :_fbfg =append (_fbfg ,float64 (*_bbbg ));case *PdfObjectFloat :_fbfg =append (_fbfg ,float64 (*_bbbg ));
default:return nil ,ErrTypeError ;};};return _fbfg ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bagf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_bcefc *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_bcage error ){const _dcfc ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _bcefc ==nil {return _fgb .Error (_dcfc ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_bcefc .DefaultPageSettings ;};if _bcefc ._afad ==nil {_bcefc ._afad =_e .InitEncodeDocument (settings .FileMode );
};if _bcage =settings .Validate ();_bcage !=nil {return _fgb .Wrap (_bcage ,_dcfc ,"");};_gfebd ,_bcage :=img .toBitmap ();if _bcage !=nil {return _fgb .Wrap (_bcage ,_dcfc ,"");};switch settings .Compression {case JB2Generic :if _bcage =_bcefc ._afad .AddGenericPage (_gfebd ,settings .DuplicatedLinesRemoval );
_bcage !=nil {return _fgb .Wrap (_bcage ,_dcfc ,"");};case JB2SymbolCorrelation :return _fgb .Error (_dcfc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _fgb .Error (_dcfc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _fgb .Error (_dcfc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_cbab *_fd .ImageBase ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_ebdd *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ad .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_ad .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ebdd .Predictor );
_fafe ,_gged :=_ebdd .DecodeBytes (streamObj .Stream );if _gged !=nil {return nil ,_gged ;};_ad .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_ad .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_fafe ),_fafe );
if _ebdd .Predictor > 1{if _ebdd .Predictor ==2{_ad .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fdee :=_ebdd .Columns *_ebdd .Colors ;if _fdee < 1{return []byte {},nil ;};_cccc :=len (_fafe )/_fdee ;if len (_fafe )%_fdee !=0{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fafe ),_fdee );};if _fdee %_ebdd .Colors !=0{return nil ,_ba .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fdee ,_ebdd .Colors );
};if _fdee > len (_fafe ){_ad .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fdee ,len (_fafe ));
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ad .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fafe ),_fafe );
_eddac :=_fcc .NewBuffer (nil );for _bde :=0;_bde < _cccc ;_bde ++{_cebg :=_fafe [_fdee *_bde :_fdee *(_bde +1)];for _aedd :=_ebdd .Colors ;_aedd < _fdee ;_aedd ++{_cebg [_aedd ]=byte (int (_cebg [_aedd ]+_cebg [_aedd -_ebdd .Colors ])%256);};_eddac .Write (_cebg );
};_fbae :=_eddac .Bytes ();_ad .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fbae ),_fbae );return _fbae ,nil ;}else if _ebdd .Predictor >=10&&_ebdd .Predictor <=15{_ad .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_edbf :=_ebdd .Columns *_ebdd .Colors +1;if _edbf < 1{return []byte {},nil ;};_aabf :=len (_fafe )/_edbf ;if len (_fafe )%_edbf !=0{return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fafe ),_edbf );
};if _edbf > len (_fafe ){_ad .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_edbf ,len (_fafe ));
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gefc :=_fcc .NewBuffer (nil );_ad .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ebdd .Columns );
_ad .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fafe ),_edbf ,_aabf );_efd :=make ([]byte ,_edbf );for _fecg :=0;_fecg < _edbf ;_fecg ++{_efd [_fecg ]=0;};
for _afee :=0;_afee < _aabf ;_afee ++{_aadg :=_fafe [_edbf *_afee :_edbf *(_afee +1)];_degf :=_aadg [0];switch _degf {case 0:case 1:for _afcb :=2;_afcb < _edbf ;_afcb ++{_aadg [_afcb ]=byte (int (_aadg [_afcb ]+_aadg [_afcb -1])%256);};case 2:for _egcd :=1;
_egcd < _edbf ;_egcd ++{_aadg [_egcd ]=byte (int (_aadg [_egcd ]+_efd [_egcd ])%256);};default:_ad .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_degf );
return nil ,_ba .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_degf );};for _ced :=0;_ced < _edbf ;_ced ++{_efd [_ced ]=_aadg [_ced ];};_gefc .Write (_aadg [1:]);
};_dadd :=_gefc .Bytes ();return _dadd ,nil ;}else {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ebdd .Predictor );
return nil ,_ba .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ebdd .Predictor );};};return _fafe ,nil ;};func (_fcde *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_fcde ._caeg .ObjectMap =make (map[int ]XrefObject );
_fcde ._eceb =make (objectStreams );_ccgga ,_dafd :=_fcde ._eebaa .Seek (0,_gf .SeekEnd );if _dafd !=nil {return nil ,_dafd ;};_ad .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_ccgga );_fcde ._edaa =_ccgga ;_dafd =_fcde .seekToEOFMarker (_ccgga );
if _dafd !=nil {_ad .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dafd );return nil ,_dafd ;};_afgc ,_dafd :=_fcde ._eebaa .Seek (0,_gf .SeekCurrent );
if _dafd !=nil {return nil ,_dafd ;};var _gfea int64 =64;_aggdc :=_afgc -_gfea ;if _aggdc < 0{_aggdc =0;};_ ,_dafd =_fcde ._eebaa .Seek (_aggdc ,_gf .SeekStart );if _dafd !=nil {return nil ,_dafd ;};_ecfd :=make ([]byte ,_gfea );_ ,_dafd =_fcde ._eebaa .Read (_ecfd );
if _dafd !=nil {_ad .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dafd );
return nil ,_dafd ;};_gdce :=_cade .FindStringSubmatch (string (_ecfd ));if len (_gdce )< 2{_ad .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_c .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};if len (_gdce )> 2{_ad .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ecfd );return nil ,_c .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");
};_cbbee ,_ :=_a .ParseInt (_gdce [1],10,64);_ad .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_cbbee );if _cbbee > _ccgga {_ad .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");
_ad .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_cbbee ,_dafd =_fcde .repairLocateXref ();if _dafd !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_dafd ;};};_fcde ._eebaa .Seek (_cbbee ,_gf .SeekStart );_fcde ._bgec =_ag .NewReader (_fcde ._eebaa );_beebe ,_dafd :=_fcde .parseXref ();if _dafd !=nil {return nil ,_dafd ;};_gcfbb :=_beebe .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _gcfbb !=nil {_gdccd ,_bedef :=_gcfbb .(*PdfObjectInteger );
if !_bedef {return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dafd =_fcde .parseXrefStream (_gdccd );if _dafd !=nil {return nil ,_dafd ;};};var _bcee []int64 ;_ggbc :=func (_cdad int64 ,_facdc []int64 )bool {for _ ,_ffa :=range _facdc {if _ffa ==_cdad {return true ;
};};return false ;};_gcfbb =_beebe .Get ("\u0050\u0072\u0065\u0076");for _gcfbb !=nil {_dbda ,_ccaf :=_gcfbb .(*PdfObjectInteger );if !_ccaf {_ad .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_gcfbb );
return _beebe ,nil ;};_dbdc :=*_dbda ;_ad .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_dbdc );_fcde ._eebaa .Seek (int64 (_dbdc ),_gf .SeekStart );
_fcde ._bgec =_ag .NewReader (_fcde ._eebaa );_ffab ,_ageb :=_fcde .parseXref ();if _ageb !=nil {_ad .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_ad .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_fcde ._afed =append (_fcde ._afed ,int64 (_dbdc ));
_gcfbb =_ffab .Get ("\u0050\u0072\u0065\u0076");if _gcfbb !=nil {_ffag :=*(_gcfbb .(*PdfObjectInteger ));if _ggbc (int64 (_ffag ),_bcee ){_ad .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_bcee =append (_bcee ,int64 (_ffag ));};};return _beebe ,nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_bbgg []PdfObject };

// SetImage sets the image base for given flate encoder.
func (_cfa *FlateEncoder )SetImage (img *_fd .ImageBase ){_cfa ._cbab =img };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fafd *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _edgab []int64 ;for _ ,_gfcgg :=range _fafd .Elements (){if _cfecb ,_cacb :=_gfcgg .(*PdfObjectInteger );_cacb {_edgab =append (_edgab ,int64 (*_cfecb ));}else {return nil ,ErrTypeError ;
};};return _edgab ,nil ;};

// String returns a string describing `array`.
func (_gcg *PdfObjectArray )String ()string {_eeacc :="\u005b";for _ecdb ,_cffb :=range _gcg .Elements (){_eeacc +=_cffb .String ();if _ecdb < (_gcg .Len ()-1){_eeacc +="\u002c\u0020";};};_eeacc +="\u005d";return _eeacc ;};func (_ddea *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_ddea ._bgec )};


// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _fdfa (obj1 ,obj2 ,0)};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_bdag *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_decg ,_gfae :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gfae ==nil {_bdag .BitsPerComponent =int (_decg );
};_gdg ,_gfae :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gfae ==nil {_bdag .Width =int (_gdg );};_aecfg ,_gfae :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gfae ==nil {_bdag .Height =int (_aecfg );
};_fbfa ,_gfae :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gfae ==nil {_bdag .ColorComponents =int (_fbfa );};};var _aacg =_g .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");


// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abea *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// Read implementation of Read interface.
func (_ebbcd *limitedReadSeeker )Read (p []byte )(_gcbcb int ,_ecfc error ){_cbcgb ,_ecfc :=_ebbcd ._cgbd .Seek (0,_gf .SeekCurrent );if _ecfc !=nil {return 0,_ecfc ;};_bafge :=_ebbcd ._ddgb -_cbcgb ;if _bafge ==0{return 0,_gf .EOF ;};if _edgaa :=int64 (len (p ));
_edgaa < _bafge {_bafge =_edgaa ;};_abdfd :=make ([]byte ,_bafge );_gcbcb ,_ecfc =_ebbcd ._cgbd .Read (_abdfd );copy (p ,_abdfd );return _gcbcb ,_ecfc ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_fgee *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_fgee ._cbgf .Lock ();defer _fgee ._cbgf .Unlock ();_fcac ,_bcce :=_fgee ._bgga [key ];if !_bcce {return nil ;};return _fcac ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cegd *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_fcfc *PdfObjectDictionary ,_ccdde bool ){_fcfc ,_ccdde =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _fcfc ,_ccdde ;};func (_aebe *PdfParser )parseHexString ()(*PdfObjectString ,error ){_aebe ._bgec .ReadByte ();
var _fbdd _fcc .Buffer ;for {_cfce ,_bagg :=_aebe ._bgec .Peek (1);if _bagg !=nil {return MakeString (""),_bagg ;};if _cfce [0]=='>'{_aebe ._bgec .ReadByte ();break ;};_adefe ,_ :=_aebe ._bgec .ReadByte ();if _aebe ._afge {if _fcc .IndexByte (_cbf ,_adefe )==-1{_aebe ._edac ._bce =true ;
};};if !IsWhiteSpace (_adefe ){_fbdd .WriteByte (_adefe );};};if _fbdd .Len ()%2==1{_aebe ._edac ._dee =true ;_fbdd .WriteRune ('0');};_facd ,_ :=_df .DecodeString (_fbdd .String ());return MakeHexString (string (_facd )),nil ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_dbfd *PdfParser )IsAuthenticated ()bool {return _dbfd ._bacc ._aga };func _efbab (_aafg ,_bbeg ,_efgae int )error {if _bbeg < 0||_bbeg > _aafg {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _efgae < _bbeg {return _c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _efgae > _aafg {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bdbe Version )String ()string {return _ba .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bdbe .Major ,_bdbe .Minor );};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_addggd *PdfParser )CheckAccessRights (password []byte )(bool ,_cda .Permissions ,error ){if _addggd ._bacc ==nil {return true ,_cda .PermOwner ,nil ;};return _addggd ._bacc .checkAccessRights (password );};func (_daedf *JBIG2Encoder )encodeImage (_gdad _bdf .Image )([]byte ,error ){const _fadb ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";
_fgeg ,_facf :=GoImageToJBIG2 (_gdad ,JB2ImageAutoThreshold );if _facf !=nil {return nil ,_fgb .Wrap (_facf ,_fadb ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");
};if _facf =_daedf .AddPageImage (_fgeg ,&_daedf .DefaultPageSettings );_facf !=nil {return nil ,_fgb .Wrap (_facf ,_fadb ,"");};return _daedf .Encode ();};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_baff *MultiEncoder )GetFilterArray ()*PdfObjectArray {_ecf :=make ([]PdfObject ,len (_baff ._bbee ));for _dabgg ,_aefd :=range _baff ._bbee {_ecf [_dabgg ]=MakeName (_aefd .GetFilterName ());};return MakeArray (_ecf ...);};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_ebgfb *PdfObjectString ,_gecb bool ){_ebgfb ,_gecb =TraceToDirectObject (obj ).(*PdfObjectString );return _ebgfb ,_gecb ;};

// String returns a string describing `d`.
func (_febb *PdfObjectDictionary )String ()string {var _aaec _abb .Builder ;_aaec .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_egcdf :=range _febb ._bgad {_geab :=_febb ._bgga [_egcdf ];_aaec .WriteString ("\u0022"+_egcdf .String ()+"\u0022\u003a\u0020");
_aaec .WriteString (_geab .String ());_aaec .WriteString ("\u002c\u0020");};_aaec .WriteString ("\u0029");return _aaec .String ();};

// String returns a string describing `streams`.
func (_gaaf *PdfObjectStreams )String ()string {return _ba .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_gaaf .ObjectNumber );};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_ceefc :=&PdfObjectDictionary {};_ceefc ._bgga =map[PdfObjectName ]PdfObject {};_ceefc ._bgad =[]PdfObjectName {};_ceefc ._cbgf =&_b .Mutex {};return _ceefc ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_ggfb *MultiEncoder )AddEncoder (encoder StreamEncoder ){_ggfb ._bbee =append (_ggfb ._bbee ,encoder );};func (_eadg *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_gf .SeekStart {offset +=_eadg ._eeef ;};_abee ,_eabb :=_eadg ._gabb .Seek (offset ,whence );
if _eabb !=nil {return _abee ,_eabb ;};if whence ==_gf .SeekCurrent {_abee -=_eadg ._eeef ;};if _abee < 0{return 0,_c .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _abee ,nil ;};func _dbca (_fagg int )int {_dbaef :=_fagg >>(_fgcd -1);return (_fagg ^_dbaef )-_dbaef };var _dac =_g .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_badbe *JBIG2Image )ToGoImage ()(_bdf .Image ,error ){const _badf ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _badbe .Data ==nil {return nil ,_fgb .Error (_badf ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _badbe .Width ==0||_badbe .Height ==0{return nil ,_fgb .Error (_badf ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_baffd ,_dddfe :=_fd .NewImage (_badbe .Width ,_badbe .Height ,1,1,_badbe .Data ,nil ,nil );if _dddfe !=nil {return nil ,_dddfe ;};return _baffd ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fdeab *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_bddf :=_fcc .NewReader (data );var _dabg []byte ;var _bcda []byte ;_cgge ,_cgca :=_bddf .ReadByte ();if _cgca ==_gf .EOF {return []byte {},nil ;}else if _cgca !=nil {return nil ,_cgca ;
};_gcda :=1;for {_cfe ,_dagf :=_bddf .ReadByte ();if _dagf ==_gf .EOF {break ;}else if _dagf !=nil {return nil ,_dagf ;};if _cfe ==_cgge {if len (_bcda )> 0{_bcda =_bcda [:len (_bcda )-1];if len (_bcda )> 0{_dabg =append (_dabg ,byte (len (_bcda )-1));
_dabg =append (_dabg ,_bcda ...);};_gcda =1;_bcda =[]byte {};};_gcda ++;if _gcda >=127{_dabg =append (_dabg ,byte (257-_gcda ),_cgge );_gcda =0;};}else {if _gcda > 0{if _gcda ==1{_bcda =[]byte {_cgge };}else {_dabg =append (_dabg ,byte (257-_gcda ),_cgge );
};_gcda =0;};_bcda =append (_bcda ,_cfe );if len (_bcda )>=127{_dabg =append (_dabg ,byte (len (_bcda )-1));_dabg =append (_dabg ,_bcda ...);_bcda =[]byte {};};};_cgge =_cfe ;};if len (_bcda )> 0{_dabg =append (_dabg ,byte (len (_bcda )-1));_dabg =append (_dabg ,_bcda ...);
}else if _gcda > 0{_dabg =append (_dabg ,byte (257-_gcda ),_cgge );};_dabg =append (_dabg ,128);return _dabg ,nil ;};func (_dbaec *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_dbaec ._eebaa .Seek (0,_gf .SeekStart );_dbaec ._bgec =_ag .NewReader (_dbaec ._eebaa );
_dfafc :=20;_fbacg :=make ([]byte ,_dfafc );for {_effd ,_cagc :=_dbaec ._bgec .ReadByte ();if _cagc !=nil {if _cagc ==_gf .EOF {break ;}else {return 0,0,_cagc ;};};if IsDecimalDigit (_effd )&&_fbacg [_dfafc -1]=='.'&&IsDecimalDigit (_fbacg [_dfafc -2])&&_fbacg [_dfafc -3]=='-'&&_fbacg [_dfafc -4]=='F'&&_fbacg [_dfafc -5]=='D'&&_fbacg [_dfafc -6]=='P'{_dgca :=int (_fbacg [_dfafc -2]-'0');
_abc :=int (_effd -'0');return _dgca ,_abc ,nil ;};_fbacg =append (_fbacg [1:_dfafc ],_effd );};return 0,0,_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fgce *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_gdbd :=MakeDict ();_gdbd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fgce .GetFilterName ()));return _gdbd ;};func (_aaaa *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){_aaaa .skipSpaces ();
const _ggfe =20;_acfeg ,_ :=_aaaa ._bgec .Peek (_ggfe );for _bgbf :=0;_bgbf < 2;_bgbf ++{if _aaaa ._gebae ==0{_aaaa ._gebae =_aaaa .GetFileOffset ();};if _ecabd .Match (_acfeg ){_ad .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_ad .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_acfeg ));return _aaaa .parseXrefStream (nil );};if _aag .Match (_acfeg ){_ad .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _aaaa .parseXrefTable ();};_feab :=_aaaa .GetFileOffset ();if _aaaa ._gebae ==0{_aaaa ._gebae =_feab ;};_aaaa .SetFileOffset (_feab -_ggfe );defer _aaaa .SetFileOffset (_feab );_fcga ,_ :=_aaaa ._bgec .Peek (_ggfe );_acfeg =append (_fcga ,_acfeg ...);
};_ad .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _eegdd :=_aaaa .repairSeekXrefMarker ();_eegdd !=nil {_ad .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_eegdd );return nil ,_eegdd ;};return _aaaa .parseXrefTable ();};func (_aae *PdfCrypt )isDecrypted (_cee PdfObject )bool {_ ,_dba :=_aae ._edda [_cee ];
if _dba {_ad .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _dgfg :=_cee .(type ){case *PdfObjectStream :if _aae ._ccf .R !=5{if _eae ,_acfb :=_dgfg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_acfb &&*_eae =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dba =_aae ._geg [int (_dgfg .ObjectNumber )];_dba {return true ;};switch _cbg :=_dgfg .PdfObject .(type ){case *PdfObjectDictionary :_eea :=true ;for _ ,_ecb :=range _ebed {if _cbg .Get (_ecb )==nil {_eea =false ;
break ;};};if _eea {return true ;};};};_ad .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_cdcc *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _cad ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _cdcc .ColorComponents !=1||_cdcc .BitsPerComponent !=1{return nil ,_fgb .Errorf (_cad ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_dcfbe *_fg .Bitmap ;_dabf error ;);_gdfe :=(_cdcc .Width *_cdcc .Height )==len (data );if _gdfe {_dcfbe ,_dabf =_fg .NewWithUnpaddedData (_cdcc .Width ,_cdcc .Height ,data );}else {_dcfbe ,_dabf =_fg .NewWithData (_cdcc .Width ,_cdcc .Height ,data );
};if _dabf !=nil {return nil ,_dabf ;};_fdfc :=_cdcc .DefaultPageSettings ;if _dabf =_fdfc .Validate ();_dabf !=nil {return nil ,_fgb .Wrap (_dabf ,_cad ,"");};if _cdcc ._afad ==nil {_cdcc ._afad =_e .InitEncodeDocument (_fdfc .FileMode );};switch _fdfc .Compression {case JB2Generic :if _dabf =_cdcc ._afad .AddGenericPage (_dcfbe ,_fdfc .DuplicatedLinesRemoval );
_dabf !=nil {return nil ,_fgb .Wrap (_dabf ,_cad ,"");};case JB2SymbolCorrelation :return nil ,_fgb .Error (_cad ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_fgb .Error (_cad ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_fgb .Error (_cad ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _cdcc .Encode ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfdf *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_cfgf :=MakeDict ();_cfgf .Set ("\u004b",MakeInteger (int64 (_bfdf .K )));_cfgf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bfdf .Columns )));if _bfdf .BlackIs1 {_cfgf .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_bfdf .BlackIs1 ));
};if _bfdf .EncodedByteAlign {_cfgf .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_bfdf .EncodedByteAlign ));};if _bfdf .EndOfLine &&_bfdf .K >=0{_cfgf .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_bfdf .EndOfLine ));
};if _bfdf .Rows !=0&&!_bfdf .EndOfBlock {_cfgf .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_bfdf .Rows )));};if !_bfdf .EndOfBlock {_cfgf .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_bfdf .EndOfBlock ));};if _bfdf .DamagedRowsBeforeError !=0{_cfgf .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_bfdf .DamagedRowsBeforeError )));
};return _cfgf ;};

// String returns the state of the bool as "true" or "false".
func (_adba *PdfObjectBool )String ()string {if *_adba {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_bcde *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bcde .Predictor !=1&&_bcde .Predictor !=11{_ad .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _bcde .Predictor ==11{_efea :=_bcde .Columns ;_ceb :=len (data )/_efea ;if len (data )%_efea !=0{_ad .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_gef :=_fcc .NewBuffer (nil );_fbac :=make ([]byte ,_efea );for _cdgb :=0;_cdgb < _ceb ;_cdgb ++{_aba :=data [_efea *_cdgb :_efea *(_cdgb +1)];
_fbac [0]=_aba [0];for _daa :=1;_daa < _efea ;_daa ++{_fbac [_daa ]=byte (int (_aba [_daa ]-_aba [_daa -1])%256);};_gef .WriteByte (1);_gef .Write (_fbac );};data =_gef .Bytes ();};var _dgef _fcc .Buffer ;_aggd :=_dg .NewWriter (&_dgef );_aggd .Write (data );
_aggd .Close ();return _dgef .Bytes (),nil ;};

// String returns a string describing `ind`.
func (_dfacf *PdfIndirectObject )String ()string {return _ba .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_dfacf ).ObjectNumber );};func (_abgf *PdfParser )traceStreamLength (_aecd PdfObject )(PdfObject ,error ){_dadgg ,_ffcc :=_aecd .(*PdfObjectReference );
if _ffcc {_bbce ,_fadcdb :=_abgf ._eedbc [_dadgg .ObjectNumber ];if _fadcdb &&_bbce {_ad .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_c .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_abgf ._eedbc [_dadgg .ObjectNumber ]=true ;};_ggea ,_aaaaf :=_abgf .Resolve (_aecd );if _aaaaf !=nil {return nil ,_aaaaf ;
};_ad .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ggea );if _ffcc {_abgf ._eedbc [_dadgg .ObjectNumber ]=false ;};return _ggea ,nil ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_cdgc *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cdgc .Predictor !=1{return nil ,_ba .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _cdgc .EarlyChange ==1{return nil ,_ba .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _ebge _fcc .Buffer ;_gcbf :=_gb .NewWriter (&_ebge ,_gb .MSB ,8);_gcbf .Write (data );_gcbf .Close ();return _ebge .Bytes (),nil ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_abab *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eaeec ,_cagf :=_af .NewDecoder (encoded ,_af .DecodeOptions {Columns :_abab .Columns ,Rows :_abab .Rows ,K :_abab .K ,EncodedByteAligned :_abab .EncodedByteAlign ,BlackIsOne :_abab .BlackIs1 ,EndOfBlock :_abab .EndOfBlock ,EndOfLine :_abab .EndOfLine ,DamagedRowsBeforeError :_abab .DamagedRowsBeforeError });
if _cagf !=nil {return nil ,_cagf ;};_ebdad ,_cagf :=_fc .ReadAll (_eaeec );if _cagf !=nil {return nil ,_cagf ;};return _ebdad ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bgab *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_aaea *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_bddde :=n ;_bdfc :=0;_gdbde :=0;for _bddde > 0{_cfgb ,_ebbc :=_aaea ._bgec .Read (p [_bdfc :]);if _ebbc !=nil {_ad .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_cfgb ,_gdbde ,_ebbc .Error ());
return _bdfc ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_gdbde ++;_bdfc +=_cfgb ;_bddde -=_cfgb ;};return _bdfc ,nil ;};var (ErrUnsupportedEncodingParameters =_c .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_c .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_c .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_c .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_cg .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_c .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);func (_cfae *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_bdbb :=_cfae ._bgec .Discard (4);return PdfObjectNull {},_bdbb ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_aac *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dccd :=_fcc .NewReader (encoded );var _eba []byte ;for {_febf ,_deb :=_dccd .ReadByte ();if _deb !=nil {return nil ,_deb ;};if _febf > 128{_gaea ,_caf :=_dccd .ReadByte ();if _caf !=nil {return nil ,_caf ;
};for _eccg :=0;_eccg < 257-int (_febf );_eccg ++{_eba =append (_eba ,_gaea );};}else if _febf < 128{for _dfdb :=0;_dfdb < int (_febf )+1;_dfdb ++{_geef ,_cbcf :=_dccd .ReadByte ();if _cbcf !=nil {return nil ,_cbcf ;};_eba =append (_eba ,_geef );};}else {break ;
};};return _eba ,nil ;};

// String returns a string representation of the *PdfObjectString.
func (_cdbb *PdfObjectString )String ()string {return _cdbb ._ffff };

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func _fgbed (_gcag PdfObject ,_adddbc int ,_aadd map[PdfObject ]struct{})error {_ad .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_adddbc );
if _ ,_bdeg :=_aadd [_gcag ];_bdeg {_ad .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_aadd [_gcag ]=struct{}{};switch _ecaga :=_gcag .(type ){case *PdfIndirectObject :_gaafa :=_ecaga ;
_ad .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_gaafa );_ad .Log .Trace ("\u002d\u0020\u0025\u0073",_gaafa .PdfObject );return _fgbed (_gaafa .PdfObject ,_adddbc +1,_aadd );case *PdfObjectStream :_fgdf :=_ecaga ;return _fgbed (_fgdf .PdfObjectDictionary ,_adddbc +1,_aadd );
case *PdfObjectDictionary :_edace :=_ecaga ;_ad .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_edace );for _ ,_adfa :=range _edace .Keys (){_cddg :=_edace .Get (_adfa );if _daca ,_affef :=_cddg .(*PdfObjectReference );_affef {_adbd :=_daca .Resolve ();
_edace .Set (_adfa ,_adbd );_eaab :=_fgbed (_adbd ,_adddbc +1,_aadd );if _eaab !=nil {return _eaab ;};}else {_aagb :=_fgbed (_cddg ,_adddbc +1,_aadd );if _aagb !=nil {return _aagb ;};};};return nil ;case *PdfObjectArray :_cfad :=_ecaga ;_ad .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_cfad );
for _eead ,_ggeb :=range _cfad .Elements (){if _eegce ,_afgfg :=_ggeb .(*PdfObjectReference );_afgfg {_cbcb :=_eegce .Resolve ();_cfad .Set (_eead ,_cbcb );_efcfd :=_fgbed (_cbcb ,_adddbc +1,_aadd );if _efcfd !=nil {return _efcfd ;};}else {_cgdb :=_fgbed (_ggeb ,_adddbc +1,_aadd );
if _cgdb !=nil {return _cgdb ;};};};return nil ;case *PdfObjectReference :_ad .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _c .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_feff *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_bcba ,_ede :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ede ==nil {_feff .Predictor =int (_bcba );};_gcbc ,_ede :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _ede ==nil {_feff .BitsPerComponent =int (_gcbc );};_eda ,_ede :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ede ==nil {_feff .Columns =int (_eda );};_fdda ,_ede :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _ede ==nil {_feff .Colors =int (_fdda );};};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_efedf :objects };};var _aag =_g .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");func (_edb *PdfCrypt )decryptBytes (_dfg []byte ,_cdg string ,_cdac []byte )([]byte ,error ){_ad .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_gcff ,_beff :=_edb ._gca [_cdg ];if !_beff {return nil ,_ba .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cdg );};return _gcff .DecryptBytes (_dfg ,_cdac );};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_cage *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_c .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_afgg ,_gggb :=_cage .getNumbersOfUpdatedObjects (prevParser );if _gggb !=nil {return nil ,_gggb ;};_gaac :=make (map[int64 ]PdfObject );for _ ,_cdda :=range _afgg {if _dggf ,_eebf :=_cage .LookupByNumber (_cdda );_eebf ==nil {_gaac [int64 (_cdda )]=_dggf ;
}else {return nil ,_eebf ;};};return _gaac ,nil ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_bgbg *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bgbg .DecodeBytes (streamObj .Stream );};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_dcbdf :=&ASCII85Encoder {};return _dcbdf };

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _agf .Filter ,userPass ,ownerPass []byte ,perm _cda .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_dfcf :=&PdfCrypt {_ga :make (map[PdfObject ]bool ),_gca :make (cryptFilters ),_ccf :_cda .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _eed Version ;if cf !=nil {_edg :=cf .PDFVersion ();_eed .Major ,_eed .Minor =_edg [0],_edg [1];V ,R :=cf .HandlerVersion ();_dfcf ._gcc .V =V ;_dfcf ._ccf .R =R ;_dfcf ._gcc .Length =cf .KeyLength ()*8;};const (_dea =_cba ;);_dfcf ._gca [_dea ]=cf ;
if _dfcf ._gcc .V >=4{_dfcf ._ade =_dea ;_dfcf ._dgea =_dea ;};_bcbg :=_dfcf .newEncryptDict ();_efa :=_cd .Sum ([]byte (_ab .Now ().Format (_ab .RFC850 )));_gcf :=string (_efa [:]);_afa :=make ([]byte ,100);_cc .Read (_afa );_efa =_cd .Sum (_afa );_ddb :=string (_efa [:]);
_ad .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_afa );_ad .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_gcf );_dfcf ._addd =_gcf ;_dge :=_dfcf .generateParams (userPass ,ownerPass );
if _dge !=nil {return nil ,nil ,_dge ;};_baef (&_dfcf ._ccf ,_bcbg );if _dfcf ._gcc .V >=4{if _bf :=_dfcf .saveCryptFilters (_bcbg );_bf !=nil {return nil ,nil ,_bf ;};};return _dfcf ,&EncryptInfo {Version :_eed ,Encrypt :_bcbg ,ID0 :_gcf ,ID1 :_ddb },nil ;
};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_gdeg *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dcag _fd .Gray ;switch len (data ){case _gdeg .Rows *_gdeg .Columns :_gfec ,_aeddb :=_fd .NewImage (_gdeg .Columns ,_gdeg .Rows ,8,1,data ,nil ,nil );if _aeddb !=nil {return nil ,_aeddb ;
};_dcag =_gfec .(_fd .Gray );case (_gdeg .Columns *_gdeg .Rows )+7>>3:_aecb ,_ggad :=_fd .NewImage (_gdeg .Columns ,_gdeg .Rows ,1,1,data ,nil ,nil );if _ggad !=nil {return nil ,_ggad ;};_babcb :=_aecb .(*_fd .Monochrome );if _ggad =_babcb .AddPadding ();
_ggad !=nil {return nil ,_ggad ;};_dcag =_babcb ;default:if len (data )< _fd .BytesPerLine (_gdeg .Columns ,1,1)*_gdeg .Rows {return nil ,_c .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_fbcb ,_aegdd :=_fd .NewImage (_gdeg .Columns ,_gdeg .Rows ,1,1,data ,nil ,nil );if _aegdd !=nil {return nil ,_aegdd ;};_cccg :=_fbcb .(*_fd .Monochrome );_dcag =_cccg ;};_gffa :=make ([][]byte ,_gdeg .Rows );for _ababe :=0;_ababe < _gdeg .Rows ;_ababe ++{_eegae :=make ([]byte ,_gdeg .Columns );
for _egbfc :=0;_egbfc < _gdeg .Columns ;_egbfc ++{_dgcef :=_dcag .GrayAt (_egbfc ,_ababe );_eegae [_egbfc ]=_dgcef .Y >>7;};_gffa [_ababe ]=_eegae ;};_egfb :=&_af .Encoder {K :_gdeg .K ,Columns :_gdeg .Columns ,EndOfLine :_gdeg .EndOfLine ,EndOfBlock :_gdeg .EndOfBlock ,BlackIs1 :_gdeg .BlackIs1 ,DamagedRowsBeforeError :_gdeg .DamagedRowsBeforeError ,Rows :_gdeg .Rows ,EncodedByteAlign :_gdeg .EncodedByteAlign };
return _egfb .Encode (_gffa ),nil ;};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_cffa *PdfObjectString )IsHexadecimal ()bool {return _cffa ._aggdd };

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};func _dfcdg (_deceg PdfObject )(*float64 ,error ){switch _aafde :=_deceg .(type ){case *PdfObjectFloat :_faee :=float64 (*_aafde );return &_faee ,nil ;case *PdfObjectInteger :_aefg :=float64 (*_aafde );return &_aefg ,nil ;case *PdfObjectNull :return nil ,nil ;
};return nil ,ErrNotANumber ;};type offsetReader struct{_gabb _gf .ReadSeeker ;_eeef int64 ;};func (_bgba *PdfParser )xrefNextObjectOffset (_gbda int64 )int64 {_bebf :=int64 (0);if len (_bgba ._caeg .ObjectMap )==0{return 0;};if len (_bgba ._caeg ._bdg )==0{_ffagf :=0;
for _ ,_cegb :=range _bgba ._caeg .ObjectMap {if _cegb .Offset > 0{_ffagf ++;};};if _ffagf ==0{return 0;};_bgba ._caeg ._bdg =make ([]XrefObject ,_ffagf );_ebaa :=0;for _ ,_cfbcd :=range _bgba ._caeg .ObjectMap {if _cfbcd .Offset > 0{_bgba ._caeg ._bdg [_ebaa ]=_cfbcd ;
_ebaa ++;};};_fe .Slice (_bgba ._caeg ._bdg ,func (_bfag ,_egee int )bool {return _bgba ._caeg ._bdg [_bfag ].Offset < _bgba ._caeg ._bdg [_egee ].Offset });};_efgcd :=_fe .Search (len (_bgba ._caeg ._bdg ),func (_dcbc int )bool {return _bgba ._caeg ._bdg [_dcbc ].Offset >=_gbda });
if _efgcd < len (_bgba ._caeg ._bdg ){_bebf =_bgba ._caeg ._bdg [_efgcd ].Offset ;};return _bebf ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_befe int ,_eedbf bool ){_egbeb ,_eedbf :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _eedbf &&_egbeb !=nil {return int (*_egbeb ),true ;};return 0,false ;};

// GetFilterName returns the name of the encoding filter.
func (_fgag *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_aace :=_fcc .NewReader ([]byte (txt ));_cgaea :=&PdfParser {ObjCache :objectCache {},_eebaa :_aace ,_bgec :_ag .NewReader (_aace ),_edaa :int64 (len (txt )),_eedbc :map[int64 ]bool {},_bdaf :make (map[*PdfParser ]*PdfParser )};
_cgaea ._caeg .ObjectMap =make (map[int ]XrefObject );return _cgaea ;};type limitedReadSeeker struct{_cgbd _gf .ReadSeeker ;_ddgb int64 ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_bac *PdfObjectDictionary );EncodeBytes (_aggc []byte )([]byte ,error );DecodeBytes (_ageg []byte )([]byte ,error );
DecodeStream (_ceebf *PdfObjectStream )([]byte ,error );};

// String returns a string describing `ref`.
func (_fadd *PdfObjectReference )String ()string {return _ba .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_fadd .ObjectNumber ,_fadd .GenerationNumber );};func (_abbg *PdfParser )readComment ()(string ,error ){var _bdga _fcc .Buffer ;
_ ,_aegdb :=_abbg .skipSpaces ();if _aegdb !=nil {return _bdga .String (),_aegdb ;};_fbag :=true ;for {_dadc ,_gefee :=_abbg ._bgec .Peek (1);if _gefee !=nil {_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gefee .Error ());return _bdga .String (),_gefee ;
};if _fbag &&_dadc [0]!='%'{return _bdga .String (),_c .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_fbag =false ;if (_dadc [0]!='\r')&&(_dadc [0]!='\n'){_gaba ,_ :=_abbg ._bgec .ReadByte ();
_bdga .WriteByte (_gaba );}else {break ;};};return _bdga .String (),nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gdcgd :=PdfObjectString {_ffff :s };return &_gdcgd };

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdee *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_gdee ._bbee )==0{return nil ;};if len (_gdee ._bbee )==1{return _gdee ._bbee [0].MakeDecodeParams ();};_gfeg :=MakeArray ();_bgbc :=true ;for _ ,_bbba :=range _gdee ._bbee {_fbce :=_bbba .MakeDecodeParams ();
if _fbce ==nil {_gfeg .Append (MakeNull ());}else {_bgbc =false ;_gfeg .Append (_fbce );};};if _bgbc {return nil ;};return _gfeg ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_gbba *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ad .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_ad .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gbba .Predictor );
if _gbba .BitsPerComponent !=8{return nil ,_ba .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_gbba .BitsPerComponent );
};_bdfda ,_badc :=_gbba .DecodeBytes (streamObj .Stream );if _badc !=nil {return nil ,_badc ;};_bdfda ,_badc =_gbba .postDecodePredict (_bdfda );if _badc !=nil {return nil ,_badc ;};return _bdfda ,nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_gddf *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_fafc :=MakeDict ();_fafc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gddf .GetFilterName ()));return _fafc ;};const (DefaultJPEGQuality =75;);

// UpdateParams updates the parameter values of the encoder.
func (_abbeg *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};var _ebed =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// WriteString outputs the object as it is to be written to file.
func (_gbdc *PdfObjectInteger )WriteString ()string {return _a .FormatInt (int64 (*_gbdc ),10)};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_egaa *PdfParser )IsEncrypted ()(bool ,error ){if _egaa ._bacc !=nil {return true ,nil ;}else if _egaa ._cdcd ==nil {return false ,nil ;};_ad .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_dbga :=_egaa ._cdcd .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _dbga ==nil {return false ,nil ;};_ad .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_ffbg *PdfObjectDictionary ;);switch _gcfae :=_dbga .(type ){case *PdfObjectDictionary :_ffbg =_gcfae ;
case *PdfObjectReference :_ad .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_gcfae );_fdef ,_cbdcc :=_egaa .LookupByReference (*_gcfae );_ad .Log .Trace ("\u0031\u003a\u0020%\u0071",_fdef );
if _cbdcc !=nil {return false ,_cbdcc ;};_ddae ,_gdbcd :=_fdef .(*PdfIndirectObject );if !_gdbcd {_ad .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_befd ,_gdbcd :=_ddae .PdfObject .(*PdfObjectDictionary );_egaa ._caae =_ddae ;_ad .Log .Trace ("\u0032\u003a\u0020%\u0071",_befd );if !_gdbcd {return false ,_c .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_ffbg =_befd ;case *PdfObjectNull :_ad .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_ba .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_gcfae );};_dbfeb ,_fcdc :=PdfCryptNewDecrypt (_egaa ,_ffbg ,_egaa ._cdcd );if _fcdc !=nil {return false ,_fcdc ;
};for _ ,_efcg :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_fbddd :=_egaa ._cdcd .Get (PdfObjectName (_efcg ));if _fbddd ==nil {continue ;};switch _bfdae :=_fbddd .(type ){case *PdfObjectReference :_dbfeb ._geg [int (_bfdae .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_dbfeb ._edda [_bfdae ]=true ;_dbfeb ._geg [int (_bfdae .ObjectNumber )]=struct{}{};};};_egaa ._bacc =_dbfeb ;_ad .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_dbfeb );
return true ,nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_egeeb string ,_bfgb bool ){_fcadf ,_bfgb :=TraceToDirectObject (obj ).(*PdfObjectName );if _bfgb {return string (*_fcadf ),true ;};return ;};func (_aecbe *PdfParser )skipSpaces ()(int ,error ){_cgee :=0;for {_cagfc ,_faff :=_aecbe ._bgec .ReadByte ();
if _faff !=nil {return 0,_faff ;};if IsWhiteSpace (_cagfc ){_cgee ++;}else {_aecbe ._bgec .UnreadByte ();break ;};};return _cgee ,nil ;};func (_ddad *PdfObjectDictionary )setWithLock (_eebe PdfObjectName ,_feac PdfObject ,_accb bool ){if _accb {_ddad ._cbgf .Lock ();
defer _ddad ._cbgf .Unlock ();};_ ,_ccgff :=_ddad ._bgga [_eebe ];if !_ccgff {_ddad ._bgad =append (_ddad ._bgad ,_eebe );};_ddad ._bgga [_eebe ]=_feac ;};func _ddfg (_caaad string )(PdfObjectReference ,error ){_cgaa :=PdfObjectReference {};_fdaa :=_caec .FindStringSubmatch (_caaad );
if len (_fdaa )< 3{_ad .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _cgaa ,_c .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};_ggec ,_ :=_a .Atoi (_fdaa [1]);_bgebc ,_ :=_a .Atoi (_fdaa [2]);_cgaa .ObjectNumber =int64 (_ggec );_cgaa .GenerationNumber =int64 (_bgebc );return _cgaa ,nil ;};const _ecabb =6;

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_ggeeb float64 ,_eccaf bool ){_bffdg ,_eccaf :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _eccaf {return float64 (*_bffdg ),true ;};return 0,false ;};

// GetFilterName returns the name of the encoding filter.
func (_dcgbd *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_aeaf *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _geedd []byte ;_ad .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_dfag :=0;_gcfa :=false ;for _dfag < len (encoded )&&!_gcfa {_eddc :=[5]byte {0,0,0,0,0};
_adbb :=0;_abbb :=0;_bbc :=4;for _abbb < 5+_adbb {if _dfag +_abbb ==len (encoded ){break ;};_ddec :=encoded [_dfag +_abbb ];if IsWhiteSpace (_ddec ){_adbb ++;_abbb ++;continue ;}else if _ddec =='~'&&_dfag +_abbb +1< len (encoded )&&encoded [_dfag +_abbb +1]=='>'{_bbc =(_abbb -_adbb )-1;
if _bbc < 0{_bbc =0;};_gcfa =true ;break ;}else if _ddec >='!'&&_ddec <='u'{_ddec -='!';}else if _ddec =='z'&&_abbb -_adbb ==0{_bbc =4;_abbb ++;break ;}else {_ad .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_eddc [_abbb -_adbb ]=_ddec ;_abbb ++;};_dfag +=_abbb ;for _bcab :=_bbc +1;_bcab < 5;_bcab ++{_eddc [_bcab ]=84;
};_ead :=uint32 (_eddc [0])*85*85*85*85+uint32 (_eddc [1])*85*85*85+uint32 (_eddc [2])*85*85+uint32 (_eddc [3])*85+uint32 (_eddc [4]);_caaa :=[]byte {byte ((_ead >>24)&0xff),byte ((_ead >>16)&0xff),byte ((_ead >>8)&0xff),byte (_ead &0xff)};_geedd =append (_geedd ,_caaa [:_bbc ]...);
};_ad .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_ad .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_geedd );
return _geedd ,nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bdceb ,_eggb :=obj .(*PdfObjectReference );_eggb {return _bdceb .Resolve ();};return obj ;};func (_eace *PdfParser )parseBool ()(PdfObjectBool ,error ){_ccddb ,_beebg :=_eace ._bgec .Peek (4);if _beebg !=nil {return PdfObjectBool (false ),_beebg ;
};if (len (_ccddb )>=4)&&(string (_ccddb [:4])=="\u0074\u0072\u0075\u0065"){_eace ._bgec .Discard (4);return PdfObjectBool (true ),nil ;};_ccddb ,_beebg =_eace ._bgec .Peek (5);if _beebg !=nil {return PdfObjectBool (false ),_beebg ;};if (len (_ccddb )>=5)&&(string (_ccddb [:5])=="\u0066\u0061\u006cs\u0065"){_eace ._bgec .Discard (5);
return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_c .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};func (_gcde *FlateEncoder )postDecodePredict (_dcd []byte )([]byte ,error ){if _gcde .Predictor > 1{if _gcde .Predictor ==2{_ad .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_ad .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_gcde .Colors );_fbbb :=_gcde .Columns *_gcde .Colors ;if _fbbb < 1{return []byte {},nil ;};_daga :=len (_dcd )/_fbbb ;if len (_dcd )%_fbbb !=0{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dcd ),_fbbb );};if _fbbb %_gcde .Colors !=0{return nil ,_ba .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fbbb ,_gcde .Colors );
};if _fbbb > len (_dcd ){_ad .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fbbb ,len (_dcd ));
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ad .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dcd ),_dcd );
_efecd :=_fcc .NewBuffer (nil );for _eab :=0;_eab < _daga ;_eab ++{_aabg :=_dcd [_fbbb *_eab :_fbbb *(_eab +1)];for _gea :=_gcde .Colors ;_gea < _fbbb ;_gea ++{_aabg [_gea ]+=_aabg [_gea -_gcde .Colors ];};_efecd .Write (_aabg );};_ggef :=_efecd .Bytes ();
_ad .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_ggef ),_ggef );return _ggef ,nil ;}else if _gcde .Predictor >=10&&_gcde .Predictor <=15{_ad .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_dbce :=_gcde .Columns *_gcde .Colors +1;_ccee :=len (_dcd )/_dbce ;if len (_dcd )%_dbce !=0{return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dcd ),_dbce );
};if _dbce > len (_dcd ){_ad .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dbce ,len (_dcd ));
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cfc :=_fcc .NewBuffer (nil );_ad .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gcde .Columns );
_ad .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dcd ),_dbce ,_ccee );_edc :=make ([]byte ,_dbce );for _gfe :=0;_gfe < _dbce ;_gfe ++{_edc [_gfe ]=0;};_gedg :=_gcde .Colors ;
for _fcd :=0;_fcd < _ccee ;_fcd ++{_eabd :=_dcd [_dbce *_fcd :_dbce *(_fcd +1)];_daea :=_eabd [0];switch _daea {case _gbgd :case _gbbb :for _ggba :=1+_gedg ;_ggba < _dbce ;_ggba ++{_eabd [_ggba ]+=_eabd [_ggba -_gedg ];};case _gdb :for _gdda :=1;_gdda < _dbce ;
_gdda ++{_eabd [_gdda ]+=_edc [_gdda ];};case _gfb :for _cae :=1;_cae < _gedg +1;_cae ++{_eabd [_cae ]+=_edc [_cae ]/2;};for _edab :=_gedg +1;_edab < _dbce ;_edab ++{_eabd [_edab ]+=byte ((int (_eabd [_edab -_gedg ])+int (_edc [_edab ]))/2);};case _afff :for _gff :=1;
_gff < _dbce ;_gff ++{var _dffb ,_bfd ,_fce byte ;_bfd =_edc [_gff ];if _gff >=_gedg +1{_dffb =_eabd [_gff -_gedg ];_fce =_edc [_gff -_gedg ];};_eabd [_gff ]+=_cbeeb (_dffb ,_bfd ,_fce );};default:_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_daea ,_fcd );
return nil ,_ba .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_daea );};copy (_edc ,_eabd );_cfc .Write (_eabd [1:]);};_fgc :=_cfc .Bytes ();return _fgc ,nil ;
}else {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gcde .Predictor );return nil ,_ba .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gcde .Predictor );
};};return _dcd ,nil ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_dcfa *JBIG2Encoder )EncodeImage (img _bdf .Image )([]byte ,error ){return _dcfa .encodeImage (img )};func (_efab *PdfCrypt )loadCryptFilters (_bef *PdfObjectDictionary )error {_efab ._gca =cryptFilters {};_fge :=_bef .Get ("\u0043\u0046");_fge =TraceToDirectObject (_fge );
if _bff ,_gfde :=_fge .(*PdfObjectReference );_gfde {_ebef ,_cag :=_efab ._bbd .LookupByReference (*_bff );if _cag !=nil {_ad .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _cag ;};_fge =TraceToDirectObject (_ebef );};_dbc ,_dgc :=_fge .(*PdfObjectDictionary );if !_dgc {_ad .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_fge );return _c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_ggdg :=range _dbc .Keys (){_agaa :=_dbc .Get (_ggdg );if _gce ,_aaa :=_agaa .(*PdfObjectReference );_aaa {_fccb ,_fbd :=_efab ._bbd .LookupByReference (*_gce );if _fbd !=nil {_ad .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _fbd ;};_agaa =TraceToDirectObject (_fccb );};_aaad ,_bcc :=_agaa .(*PdfObjectDictionary );if !_bcc {return _ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_ggdg ,_agaa );
};if _ggdg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _bbdc _agf .FilterDict ;if _dfe :=_bee (&_bbdc ,_aaad );_dfe !=nil {return _dfe ;};_gda ,_fbb :=_agf .NewFilter (_bbdc );if _fbb !=nil {return _fbb ;};_efab ._gca [string (_ggdg )]=_gda ;};_efab ._gca ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_agf .NewIdentity ();
_efab ._dgea ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ggb ,_baf :=_bef .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_baf {if _ ,_aad :=_efab ._gca [string (*_ggb )];!_aad {return _ba .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_ggb );
};_efab ._dgea =string (*_ggb );};_efab ._ade ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gad ,_agae :=_bef .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_agae {if _ ,_efe :=_efab ._gca [string (*_gad )];!_efe {return _ba .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gad );
};_efab ._ade =string (*_gad );};return nil ;};func (_aebc *JBIG2Image )toBitmap ()(_acfc *_fg .Bitmap ,_afdec error ){const _cea ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _aebc .Data ==nil {return nil ,_fgb .Error (_cea ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _aebc .Width ==0||_aebc .Height ==0{return nil ,_fgb .Error (_cea ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _aebc .HasPadding {_acfc ,_afdec =_fg .NewWithData (_aebc .Width ,_aebc .Height ,_aebc .Data );}else {_acfc ,_afdec =_fg .NewWithUnpaddedData (_aebc .Width ,_aebc .Height ,_aebc .Data );};if _afdec !=nil {return nil ,_fgb .Wrap (_afdec ,_cea ,"");
};return _acfc ,nil ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_agf .FilterDict ;};func (_afda *PdfCrypt )checkAccessRights (_afag []byte )(bool ,_cda .Permissions ,error ){_dgfb :=_afda .securityHandler ();
_bfg ,_abd ,_egd :=_dgfb .Authenticate (&_afda ._ccf ,_afag );if _egd !=nil {return false ,0,_egd ;}else if _abd ==0||len (_bfg )==0{return false ,0,nil ;};return true ,_abd ,nil ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_ccgg *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ff .Globals ,error ){return _ff .DecodeGlobals (encoded );};func (_dgf *PdfParser )lookupByNumberWrapper (_gg int ,_bbg bool )(PdfObject ,bool ,error ){_bc ,_acg ,_bed :=_dgf .lookupByNumber (_gg ,_bbg );
if _bed !=nil {return nil ,_acg ,_bed ;};if !_acg &&_dgf ._bacc !=nil &&_dgf ._bacc ._aga &&!_dgf ._bacc .isDecrypted (_bc ){_de :=_dgf ._bacc .Decrypt (_bc ,0,0);if _de !=nil {return nil ,_acg ,_de ;};};return _bc ,_acg ,nil ;};func (_cdbd *PdfParser )parseDetailedHeader ()(_dgbe error ){_cdbd ._eebaa .Seek (0,_gf .SeekStart );
_cdbd ._bgec =_ag .NewReader (_cdbd ._eebaa );_faf :=20;_bfad :=make ([]byte ,_faf );var (_ffg bool ;_eaa int ;);for {_dgac ,_ddg :=_cdbd ._bgec .ReadByte ();if _ddg !=nil {if _ddg ==_gf .EOF {break ;}else {return _ddg ;};};if IsDecimalDigit (_dgac )&&_bfad [_faf -1]=='.'&&IsDecimalDigit (_bfad [_faf -2])&&_bfad [_faf -3]=='-'&&_bfad [_faf -4]=='F'&&_bfad [_faf -5]=='D'&&_bfad [_faf -6]=='P'&&_bfad [_faf -7]=='%'{_cdbd ._fadc =Version {Major :int (_bfad [_faf -2]-'0'),Minor :int (_dgac -'0')};
_cdbd ._edac ._bag =_eaa -7;_ffg =true ;break ;};_eaa ++;_bfad =append (_bfad [1:_faf ],_dgac );};if !_ffg {return _ba .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_beb ,_dgbe :=_cdbd ._bgec .ReadByte ();
if _dgbe ==_gf .EOF {return _ba .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _dgbe !=nil {return _dgbe ;};_cdbd ._edac ._eagg =_beb =='\n';_beb ,_dgbe =_cdbd ._bgec .ReadByte ();
if _dgbe !=nil {return _ba .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_dgbe );};if _beb !='%'{return nil ;};_ccb :=make ([]byte ,4);_ ,_dgbe =_cdbd ._bgec .Read (_ccb );
if _dgbe !=nil {return _ba .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_dgbe );};_cdbd ._edac ._ecc =[4]byte {_ccb [0],_ccb [1],_ccb [2],_ccb [3]};
return nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_aada *PdfParser )GetFileOffset ()int64 {_ggg ,_ :=_aada ._eebaa .Seek (0,_gf .SeekCurrent );_ggg -=int64 (_aada ._bgec .Buffered ());return _ggg ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_dgcg :=PdfObjectString {_ffff :s ,_aggdd :true };return &_dgcg ;};func (_ccef *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_gccec ,_cead :=_ccef ._eebaa .Seek (0,_gf .SeekEnd );
if _cead !=nil {return nil ,_cead ;};var _eabg int64 ;var _acgce int64 =2048;for _eabg < _gccec -4{if _gccec <=(_acgce +_eabg ){_acgce =_gccec -_eabg ;};_ ,_bgfa :=_ccef ._eebaa .Seek (_eabg ,_gf .SeekStart );if _bgfa !=nil {return nil ,_bgfa ;};_bgbcf :=make ([]byte ,_acgce );
_ ,_bgfa =_ccef ._eebaa .Read (_bgbcf );if _bgfa !=nil {return nil ,_bgfa ;};_ad .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_bgbcf ));
_dada :=_ecabd .FindAllStringIndex (string (_bgbcf ),-1);if _dada !=nil {_bfbf :=_dada [0];_ad .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dada );_ ,_gagf :=_ccef ._eebaa .Seek (int64 (_bfbf [0]),_gf .SeekStart );if _gagf !=nil {return nil ,_gagf ;
};_ccef ._bgec =_ag .NewReader (_ccef ._eebaa );_efdb ,_gagf :=_ccef .ParseIndirectObject ();if _gagf !=nil {return nil ,nil ;};if _dccb ,_ecacg :=GetIndirect (_efdb );_ecacg {if _daeea ,_ceege :=GetDict (_dccb .PdfObject );_ceege {if _afecb :=_daeea .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_afecb !=nil {return _daeea ,nil ;};return nil ,nil ;};};return nil ,nil ;};_eabg +=_acgce -4;};return nil ,_c .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};

// String returns a descriptive information string about the encryption method used.
func (_dbf *PdfCrypt )String ()string {if _dbf ==nil {return "";};_cfb :=_dbf ._gcc .Filter +"\u0020\u002d\u0020";if _dbf ._gcc .V ==0{_cfb +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _dbf ._gcc .V ==1{_cfb +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _dbf ._gcc .V ==2{_cfb +=_ba .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_dbf ._gcc .Length );}else if _dbf ._gcc .V ==3{_cfb +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _dbf ._gcc .V >=4{_cfb +=_ba .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_dbf ._ade ,_dbf ._dgea );
_cfb +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _eega ,_cb :=range _dbf ._gca {_cfb +=_ba .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_eega ,_cb .Name (),_cb .KeyLength ());
};};_fef :=_dbf .GetAccessPermissions ();_cfb +=_ba .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_fef );return _cfb ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_ece *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dbedc :=encoded ;var _ccdc error ;for _ ,_dfcbg :=range _ece ._bbee {_ad .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_dfcbg ,_dfcbg );
_dbedc ,_ccdc =_dfcbg .DecodeBytes (_dbedc );if _ccdc !=nil {return nil ,_ccdc ;};};return _dbedc ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cgbc *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_cff ,_gec :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _gec ==nil {_cgbc .Predictor =int (_cff );};_efg ,_gec :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _gec ==nil {_cgbc .BitsPerComponent =int (_efg );};_aegg ,_gec :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gec ==nil {_cgbc .Columns =int (_aegg );};_efgc ,_gec :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _gec ==nil {_cgbc .Colors =int (_efgc );};_bbbe ,_gec :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _gec ==nil {_cgbc .EarlyChange =int (_bbbe );};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_edgfd *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_efbe :=MakeDict ();_efbe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_edgfd .GetFilterName ()));_efbe .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_edgfd .MakeDecodeParams ());
return _efbe ;};

// Seek implementation of Seek interface.
func (_bcfc *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _dadg int64 ;switch whence {case _gf .SeekStart :_dadg =offset ;case _gf .SeekCurrent :_facc ,_dbbe :=_bcfc ._cgbd .Seek (0,_gf .SeekCurrent );if _dbbe !=nil {return 0,_dbbe ;
};_dadg =_facc +offset ;case _gf .SeekEnd :_dadg =_bcfc ._ddgb +offset ;};if _gdbc :=_bcfc .getError (_dadg );_gdbc !=nil {return 0,_gdbc ;};if _ ,_cdfde :=_bcfc ._cgbd .Seek (_dadg ,_gf .SeekStart );_cdfde !=nil {return 0,_cdfde ;};return _dadg ,nil ;
};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_cabc :=MakeArray ();for _ ,_daba :=range vals {_cabc .Append (MakeFloat (_daba ));};return _cabc ;};

// String returns a string describing `null`.
func (_edf *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// LookupByReference looks up a PdfObject by a reference.
func (_ccgf *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_ad .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _ccgf .LookupByNumber (int (ref .ObjectNumber ));
};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// WriteString outputs the object as it is to be written to file.
func (_bgca *PdfObjectStream )WriteString ()string {var _gfgg _abb .Builder ;_gfgg .WriteString (_a .FormatInt (_bgca .ObjectNumber ,10));_gfgg .WriteString ("\u0020\u0030\u0020\u0052");return _gfgg .String ();};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_ada ParserMetadata )HasInvalidHexRunes ()bool {return _ada ._bce };

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_ddaag *PdfObjectString )Str ()string {return _ddaag ._ffff };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbdd *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_gebaa :=MakeDict ();_gebaa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbdd .GetFilterName ()));return _gebaa ;};func _ce (_ed PdfObject )(int64 ,int64 ,error ){if _gfd ,_dae :=_ed .(*PdfIndirectObject );
_dae {return _gfd .ObjectNumber ,_gfd .GenerationNumber ,nil ;};if _bdfe ,_bae :=_ed .(*PdfObjectStream );_bae {return _bdfe .ObjectNumber ,_bdfe .GenerationNumber ,nil ;};return 0,0,_c .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");
};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _gbge (obj ,0)};func (_eede *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_fca :=MakeDict ();_fca .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));
_fca .Set ("\u0056",MakeInteger (int64 (_eede ._gcc .V )));_fca .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_eede ._gcc .Length )));return _fca ;};func (_dff *PdfCrypt )securityHandler ()_cda .StdHandler {if _dff ._ccf .R >=5{return _cda .NewHandlerR6 ();
};return _cda .NewHandlerR4 (_dff ._addd ,_dff ._gcc .Length );};

// Remove removes an element specified by key.
func (_eabc *PdfObjectDictionary )Remove (key PdfObjectName ){_bfegg :=-1;for _fabc ,_ffea :=range _eabc ._bgad {if _ffea ==key {_bfegg =_fabc ;break ;};};if _bfegg >=0{_eabc ._bgad =append (_eabc ._bgad [:_bfegg ],_eabc ._bgad [_bfegg +1:]...);delete (_eabc ._bgga ,key );
};};

// WriteString outputs the object as it is to be written to file.
func (_cadd *PdfObjectReference )WriteString ()string {var _daae _abb .Builder ;_daae .WriteString (_a .FormatInt (_cadd .ObjectNumber ,10));_daae .WriteString ("\u0020");_daae .WriteString (_a .FormatInt (_cadd .GenerationNumber ,10));_daae .WriteString ("\u0020\u0052");
return _daae .String ();};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_agbe *PdfObjectStreams ,_cgce bool ){_agbe ,_cgce =obj .(*PdfObjectStreams );return _agbe ,_cgce ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func _dabcf (_gaf *PdfObjectStream )(*MultiEncoder ,error ){_dadb :=NewMultiEncoder ();_fbcbb :=_gaf .PdfObjectDictionary ;if _fbcbb ==nil {return _dadb ,nil ;};var _bbab *PdfObjectDictionary ;var _dgfbb []PdfObject ;_gcee :=_fbcbb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
if _gcee !=nil {_dcgbg ,_cdec :=_gcee .(*PdfObjectDictionary );if _cdec {_bbab =_dcgbg ;};_ceegg ,_eadd :=_gcee .(*PdfObjectArray );if _eadd {for _ ,_aaaf :=range _ceegg .Elements (){_aaaf =TraceToDirectObject (_aaaf );if _bfcb ,_fgfa :=_aaaf .(*PdfObjectDictionary );
_fgfa {_dgfbb =append (_dgfbb ,_bfcb );}else {_dgfbb =append (_dgfbb ,MakeDict ());};};};};_gcee =_fbcbb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _gcee ==nil {return nil ,_ba .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");
};_eafef ,_fgbf :=_gcee .(*PdfObjectArray );if !_fgbf {return nil ,_ba .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _fcb ,_bcefb :=range _eafef .Elements (){_cdaag ,_gdfa :=_bcefb .(*PdfObjectName );if !_gdfa {return nil ,_ba .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _def PdfObject ;if _bbab !=nil {_def =_bbab ;}else {if len (_dgfbb )> 0{if _fcb >=len (_dgfbb ){return nil ,_ba .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_def =_dgfbb [_fcb ];};};var _gded *PdfObjectDictionary ;if _afec ,_becd :=_def .(*PdfObjectDictionary );_becd {_gded =_afec ;};_ad .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_cdaag ,_def ,_gded );
if *_cdaag ==StreamEncodingFilterNameFlate {_fcbg ,_fgda :=_bga (_gaf ,_gded );if _fgda !=nil {return nil ,_fgda ;};_dadb .AddEncoder (_fcbg );}else if *_cdaag ==StreamEncodingFilterNameLZW {_fcdf ,_dfbe :=_ffbe (_gaf ,_gded );if _dfbe !=nil {return nil ,_dfbe ;
};_dadb .AddEncoder (_fcdf );}else if *_cdaag ==StreamEncodingFilterNameASCIIHex {_bgee :=NewASCIIHexEncoder ();_dadb .AddEncoder (_bgee );}else if *_cdaag ==StreamEncodingFilterNameASCII85 {_bacd :=NewASCII85Encoder ();_dadb .AddEncoder (_bacd );}else if *_cdaag ==StreamEncodingFilterNameDCT {_dbbg ,_gab :=_eeab (_gaf ,_dadb );
if _gab !=nil {return nil ,_gab ;};_dadb .AddEncoder (_dbbg );_ad .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_ad .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_dadb );
}else if *_cdaag ==StreamEncodingFilterNameCCITTFax {_dbcfa ,_badb :=_ddcef (_gaf ,_gded );if _badb !=nil {return nil ,_badb ;};_dadb .AddEncoder (_dbcfa );}else {_ad .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_cdaag );
return nil ,_ba .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _dadb ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_afad *_e .Document ;

// Globals are the JBIG2 global segments.
Globals _ff .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};func _baef (_ebe *_cda .StdEncryptDict ,_acf *PdfObjectDictionary ){_acf .Set ("\u0052",MakeInteger (int64 (_ebe .R )));_acf .Set ("\u0050",MakeInteger (int64 (_ebe .P )));_acf .Set ("\u004f",MakeStringFromBytes (_ebe .O ));
_acf .Set ("\u0055",MakeStringFromBytes (_ebe .U ));if _ebe .R >=5{_acf .Set ("\u004f\u0045",MakeStringFromBytes (_ebe .OE ));_acf .Set ("\u0055\u0045",MakeStringFromBytes (_ebe .UE ));_acf .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_ebe .EncryptMetadata ));
if _ebe .R > 5{_acf .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_ebe .Perms ));};};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_babc *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_bda :=MakeDict ();_bda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_babc .GetFilterName ()));return _bda ;};var _babf =_g .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");
func (_fcbgf *PdfParser )parseString ()(*PdfObjectString ,error ){_fcbgf ._bgec .ReadByte ();var _cgac _fcc .Buffer ;_edbdg :=1;for {_cbb ,_ggde :=_fcbgf ._bgec .Peek (1);if _ggde !=nil {return MakeString (_cgac .String ()),_ggde ;};if _cbb [0]=='\\'{_fcbgf ._bgec .ReadByte ();
_eafa ,_baefd :=_fcbgf ._bgec .ReadByte ();if _baefd !=nil {return MakeString (_cgac .String ()),_baefd ;};if IsOctalDigit (_eafa ){_aabef ,_fcdd :=_fcbgf ._bgec .Peek (2);if _fcdd !=nil {return MakeString (_cgac .String ()),_fcdd ;};var _abge []byte ;
_abge =append (_abge ,_eafa );for _ ,_fddf :=range _aabef {if IsOctalDigit (_fddf ){_abge =append (_abge ,_fddf );}else {break ;};};_fcbgf ._bgec .Discard (len (_abge )-1);_ad .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_abge );
_gbbaa ,_fcdd :=_a .ParseUint (string (_abge ),8,32);if _fcdd !=nil {return MakeString (_cgac .String ()),_fcdd ;};_cgac .WriteByte (byte (_gbbaa ));continue ;};switch _eafa {case 'n':_cgac .WriteRune ('\n');case 'r':_cgac .WriteRune ('\r');case 't':_cgac .WriteRune ('\t');
case 'b':_cgac .WriteRune ('\b');case 'f':_cgac .WriteRune ('\f');case '(':_cgac .WriteRune ('(');case ')':_cgac .WriteRune (')');case '\\':_cgac .WriteRune ('\\');};continue ;}else if _cbb [0]=='('{_edbdg ++;}else if _cbb [0]==')'{_edbdg --;if _edbdg ==0{_fcbgf ._bgec .ReadByte ();
break ;};};_cbgab ,_ :=_fcbgf ._bgec .ReadByte ();_cgac .WriteByte (_cbgab );};return MakeString (_cgac .String ()),nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_edgf *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _edgf .DecodeBytes (streamObj .Stream );};

// UpdateParams updates the parameter values of the encoder.
func (_agec *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_bbgg :objects }};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_babcd :=PdfObjectNull {};return &_babcd };

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_gbgg :=PdfObjectInteger (val );return &_gbgg };func (_cgga *limitedReadSeeker )getError (_cafa int64 )error {switch {case _cafa < 0:return _ba .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_cafa );
case _cafa > _cgga ._ddgb :return _ba .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_cafa );};return nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_bfbaa *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bfbaa .DecodeBytes (streamObj .Stream );};func (_gcea *PdfParser )parseXrefStream (_edbe *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _edbe !=nil {_ad .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_edbe );
_gcea ._eebaa .Seek (int64 (*_edbe ),_gf .SeekStart );_gcea ._bgec =_ag .NewReader (_gcea ._eebaa );};_edee :=_gcea .GetFileOffset ();_badcg ,_bbbd :=_gcea .ParseIndirectObject ();if _bbbd !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_ad .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_badcg );
_eddbb ,_cadf :=_badcg .(*PdfObjectStream );if !_cadf {_ad .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bcgc :=_eddbb .PdfObjectDictionary ;
_dbfb ,_cadf :=_eddbb .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_cadf {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_c .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_dbfb )> 8388607{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_dbfb );
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dgcb :=_eddbb .PdfObjectDictionary .Get ("\u0057");_bcccb ,_cadf :=_dgcb .(*PdfObjectArray );if !_cadf {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_afcc :=_bcccb .Len ();if _afcc !=3{_ad .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_afcc );
return nil ,_c .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _fefd []int64 ;for _ceae :=0;_ceae < 3;
_ceae ++{_babgc ,_fbagc :=GetInt (_bcccb .Get (_ceae ));if !_fbagc {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_fefd =append (_fefd ,int64 (*_babgc ));};_fdeg ,_bbbd :=DecodeStream (_eddbb );
if _bbbd !=nil {_ad .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_bbbd );return nil ,_bbbd ;};_dcdf :=int (_fefd [0]);
_cefg :=int (_fefd [0]+_fefd [1]);_dbdg :=int (_fefd [0]+_fefd [1]+_fefd [2]);_geaa :=int (_fefd [0]+_fefd [1]+_fefd [2]);if _dcdf < 0||_cefg < 0||_dbdg < 0{_ad .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_dcdf ,_cefg ,_dbdg );
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _geaa ==0{_ad .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _bcgc ,nil ;};_eegg :=len (_fdeg )/_geaa ;_cecf :=0;_acfdb :=_eddbb .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _fbcf []int ;if _acfdb !=nil {_ad .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_acfdb );_gffae ,_bdgb :=_acfdb .(*PdfObjectArray );
if !_bdgb {_ad .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_c .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _gffae .Len ()%2!=0{_ad .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cecf =0;_aaae ,_cbca :=_gffae .ToIntegerArray ();if _cbca !=nil {_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_cbca );
return nil ,_cbca ;};for _ebbe :=0;_ebbe < len (_aaae );_ebbe +=2{_fgbfb :=_aaae [_ebbe ];_accc :=_aaae [_ebbe +1];for _acff :=0;_acff < _accc ;_acff ++{_fbcf =append (_fbcf ,_fgbfb +_acff );};_cecf +=_accc ;};}else {for _cbge :=0;_cbge < int (*_dbfb );
_cbge ++{_fbcf =append (_fbcf ,_cbge );};_cecf =int (*_dbfb );};if _eegg ==_cecf +1{_ad .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_aacf :=_cecf -1;for _ ,_gcdf :=range _fbcf {if _gcdf > _aacf {_aacf =_gcdf ;};};_fbcf =append (_fbcf ,_aacf +1);_cecf ++;};if _eegg !=len (_fbcf ){_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_eegg ,len (_fbcf ));
return nil ,_c .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_ad .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_cecf );
_ad .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_fbcf );_aee :=func (_aabgg []byte )int64 {var _fadcd int64 ;for _gcbfe :=0;_gcbfe < len (_aabgg );_gcbfe ++{_fadcd +=int64 (_aabgg [_gcbfe ])*(1<<uint (8*(len (_aabgg )-_gcbfe -1)));
};return _fadcd ;};_ad .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_fdeg ));_cgdeg :=0;for _efed :=0;_efed < len (_fdeg );_efed +=_geaa {_cfeac :=_efbab (len (_fdeg ),_efed ,_efed +_dcdf );
if _cfeac !=nil {_ad .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cfeac );return nil ,_cfeac ;};_adddb :=_fdeg [_efed :_efed +_dcdf ];_cfeac =_efbab (len (_fdeg ),_efed +_dcdf ,_efed +_cefg );
if _cfeac !=nil {_ad .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cfeac );return nil ,_cfeac ;};_aacdd :=_fdeg [_efed +_dcdf :_efed +_cefg ];_cfeac =_efbab (len (_fdeg ),_efed +_cefg ,_efed +_dbdg );
if _cfeac !=nil {_ad .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cfeac );return nil ,_cfeac ;};_ceff :=_fdeg [_efed +_cefg :_efed +_dbdg ];_fbcc :=_aee (_adddb );
_fgffc :=_aee (_aacdd );_fgbae :=_aee (_ceff );if _fefd [0]==0{_fbcc =1;};if _cgdeg >=len (_fbcf ){_ad .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_efcd :=_fbcf [_cgdeg ];_cgdeg ++;_ad .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_efcd ,_adddb );_ad .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_efcd ,_aacdd );_ad .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_efcd ,_ceff );
_ad .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_efcd ,_fbcc ,_fgffc ,_fgbae );if _fbcc ==0{_ad .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _fbcc ==1{_ad .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_aacdd );if _fgffc ==_edee {_ad .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_efcd ,_eddbb .ObjectNumber );
_efcd =int (_eddbb .ObjectNumber );};if _cfgc ,_bdba :=_gcea ._caeg .ObjectMap [_efcd ];!_bdba ||int (_fgbae )> _cfgc .Generation {_cada :=XrefObject {ObjectNumber :_efcd ,XType :XrefTypeTableEntry ,Offset :_fgffc ,Generation :int (_fgbae )};_gcea ._caeg .ObjectMap [_efcd ]=_cada ;
};}else if _fbcc ==2{_ad .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_dabfe :=_gcea ._caeg .ObjectMap [_efcd ];!_dabfe {_aefb :=XrefObject {ObjectNumber :_efcd ,XType :XrefTypeObjectStream ,OsObjNumber :int (_fgffc ),OsObjIndex :int (_fgbae )};
_gcea ._caeg .ObjectMap [_efcd ]=_aefb ;_ad .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_aefb );};}else {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _gcea ._cecc ==nil {_defa :=XrefTypeObjectStream ;_gcea ._cecc =&_defa ;};return _bcgc ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ddff *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_cfdf :=&LZWEncoder {};_cfdf .Predictor =1;_cfdf .BitsPerComponent =8;_cfdf .Colors =1;_cfdf .Columns =1;_cfdf .EarlyChange =1;return _cfdf ;};

// GetFilterName returns the name of the encoding filter.
func (_cbabc *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Clear resets the array to an empty state.
func (_bedd *PdfObjectArray )Clear (){_bedd ._bbgg =[]PdfObject {}};func (_fbda *PdfParser )skipComments ()error {if _ ,_bffa :=_fbda .skipSpaces ();_bffa !=nil {return _bffa ;};_fegb :=true ;for {_dgg ,_ffba :=_fbda ._bgec .Peek (1);if _ffba !=nil {_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ffba .Error ());
return _ffba ;};if _fegb &&_dgg [0]!='%'{return nil ;};_fegb =false ;if (_dgg [0]!='\r')&&(_dgg [0]!='\n'){_fbda ._bgec .ReadByte ();}else {break ;};};return _fbda .skipComments ();};

// UpdateParams updates the parameter values of the encoder.
func (_cgfb *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_gcbe :=range _cgfb ._bbee {_gcbe .UpdateParams (params );};};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_cgbg *PdfObjectStreams )Elements ()[]PdfObject {if _cgbg ==nil {return nil ;};return _cgbg ._efedf ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_bbbc :=PdfObjectName (s );return &_bbbc };

// GetFilterName returns the name of the encoding filter.
func (_cccf *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ffee :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ffee .PdfObjectDictionary =encoder .MakeStreamDict ();_egca ,_efaf :=encoder .EncodeBytes (contents );
if _efaf !=nil {return nil ,_efaf ;};_ffee .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_egca ))));_ffee .Stream =_egca ;return _ffee ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ddfa *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_ddfa ._eebaa .Seek (offset ,_gf .SeekStart );_ddfa ._bgec =_ag .NewReader (_ddfa ._eebaa );};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_agaef []byte ,_efebf bool ){_fbgag ,_efebf :=TraceToDirectObject (obj ).(*PdfObjectString );if _efebf {return _fbgag .Bytes (),true ;};return ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// GetXrefType returns the type of the first xref object (table or stream).
func (_fccbe *PdfParser )GetXrefType ()*xrefType {return _fccbe ._cecc };

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_bbcg *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};func (_fdbc *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _fdbc ._aafd {return nil ,_ba .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_fdbc ._aafd =true ;_fdbc ._eebaa .Seek (0,_gf .SeekStart );_fdbc ._bgec =_ag .NewReader (_fdbc ._eebaa );_dgceg :=20;_gagc :=make ([]byte ,_dgceg );_ccea :=XrefTable {};_ccea .ObjectMap =make (map[int ]XrefObject );for {_cabe ,_bbcc :=_fdbc ._bgec .ReadByte ();
if _bbcc !=nil {if _bbcc ==_gf .EOF {break ;}else {return nil ,_bbcc ;};};if _cabe =='j'&&_gagc [_dgceg -1]=='b'&&_gagc [_dgceg -2]=='o'&&IsWhiteSpace (_gagc [_dgceg -3]){_ddeg :=_dgceg -4;for IsWhiteSpace (_gagc [_ddeg ])&&_ddeg > 0{_ddeg --;};if _ddeg ==0||!IsDecimalDigit (_gagc [_ddeg ]){continue ;
};for IsDecimalDigit (_gagc [_ddeg ])&&_ddeg > 0{_ddeg --;};if _ddeg ==0||!IsWhiteSpace (_gagc [_ddeg ]){continue ;};for IsWhiteSpace (_gagc [_ddeg ])&&_ddeg > 0{_ddeg --;};if _ddeg ==0||!IsDecimalDigit (_gagc [_ddeg ]){continue ;};for IsDecimalDigit (_gagc [_ddeg ])&&_ddeg > 0{_ddeg --;
};if _ddeg ==0{continue ;};_cgeb :=_fdbc .GetFileOffset ()-int64 (_dgceg -_ddeg );_fafeb :=append (_gagc [_ddeg +1:],_cabe );_eccge ,_ggaba ,_adaf :=_bbge (string (_fafeb ));if _adaf !=nil {_ad .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_adaf );
return nil ,_adaf ;};if _accff ,_gbbg :=_ccea .ObjectMap [_eccge ];!_gbbg ||_accff .Generation < _ggaba {_eedg :=XrefObject {};_eedg .XType =XrefTypeTableEntry ;_eedg .ObjectNumber =_eccge ;_eedg .Generation =_ggaba ;_eedg .Offset =_cgeb ;_ccea .ObjectMap [_eccge ]=_eedg ;
};};_gagc =append (_gagc [1:_dgceg ],_cabe );};_fdbc ._abafa =nil ;return &_ccea ,nil ;};const _gagb =10;

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_adcc :=&PdfIndirectObject {};_adcc .PdfObject =obj ;return _adcc ;};

// WriteString outputs the object as it is to be written to file.
func (_dfcbe *PdfObjectString )WriteString ()string {var _fcee _fcc .Buffer ;if _dfcbe ._aggdd {_fgbfd :=_df .EncodeToString (_dfcbe .Bytes ());_fcee .WriteString ("\u003c");_fcee .WriteString (_fgbfd );_fcee .WriteString ("\u003e");return _fcee .String ();
};_caabc :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_fcee .WriteString ("\u0028");for _gbfc :=0;_gbfc < len (_dfcbe ._ffff );
_gbfc ++{_ecbe :=_dfcbe ._ffff [_gbfc ];if _acbb ,_cddd :=_caabc [_ecbe ];_cddd {_fcee .WriteString (_acbb );}else {_fcee .WriteByte (_ecbe );};};_fcee .WriteString ("\u0029");return _fcee .String ();};

// PdfVersion returns version of the PDF file.
func (_ccce *PdfParser )PdfVersion ()Version {return _ccce ._fadc };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _fgbed (o ,0,traversed );};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_bdcea *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_ad .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_gdcc :=MakeDict ();_gdcc ._gfca =_bdcea ;_ebdf ,_ :=_bdcea ._bgec .ReadByte ();
if _ebdf !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_ebdf ,_ =_bdcea ._bgec .ReadByte ();if _ebdf !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_bdcea .skipSpaces ();_bdcea .skipComments ();_ddfd ,_edgb :=_bdcea ._bgec .Peek (2);if _edgb !=nil {return nil ,_edgb ;};_ad .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ddfd ),string (_ddfd ));
if (_ddfd [0]=='>')&&(_ddfd [1]=='>'){_ad .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_bdcea ._bgec .ReadByte ();_bdcea ._bgec .ReadByte ();break ;};_ad .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_dfea ,_edgb :=_bdcea .parseName ();_ad .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_dfea );if _edgb !=nil {_ad .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_edgb );
return nil ,_edgb ;};if len (_dfea )> 4&&_dfea [len (_dfea )-4:]=="\u006e\u0075\u006c\u006c"{_bfbd :=_dfea [0:len (_dfea )-4];_ad .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_dfea );
_ad .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_bfbd );_bdcea .skipSpaces ();_fffc ,_ :=_bdcea ._bgec .Peek (1);if _fffc [0]=='/'{_gdcc .Set (_bfbd ,MakeNull ());continue ;};};
_bdcea .skipSpaces ();_bgbcc ,_edgb :=_bdcea .parseObject ();if _edgb !=nil {return nil ,_edgb ;};_gdcc .Set (_dfea ,_bgbcc );if _ad .Log .IsLogLevel (_ad .LogLevelTrace ){_ad .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_dfea ,_bgbcc .String ());
};};_ad .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _gdcc ,nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func _begf (_dgee _gf .ReadSeeker ,_bcfdb int64 )(*offsetReader ,error ){_cfbd :=&offsetReader {_gabb :_dgee ,_eeef :_bcfdb };_ ,_ebeb :=_cfbd .Seek (0,_gf .SeekStart );return _cfbd ,_ebeb ;
};func _ecaca (_gdag *PdfObjectDictionary )(_edfc *_fd .ImageBase ){var (_bbddg *PdfObjectInteger ;_bbaab bool ;);if _bbddg ,_bbaab =_gdag .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_bbaab {_edfc =&_fd .ImageBase {Width :int (*_bbddg )};}else {return nil ;
};if _bbddg ,_bbaab =_gdag .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_bbaab {_edfc .Height =int (*_bbddg );};if _bbddg ,_bbaab =_gdag .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_bbaab {_edfc .BitsPerComponent =int (*_bbddg );};if _bbddg ,_bbaab =_gdag .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_bbaab {_edfc .ColorComponents =int (*_bbddg );};return _edfc ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_agde *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ecgd []int ;for _ ,_gddba :=range _agde .Elements (){if _bfcgg ,_cfgfe :=_gddba .(*PdfObjectInteger );_cfgfe {_ecgd =append (_ecgd ,int (*_bfcgg ));}else {return nil ,ErrTypeError ;};};
return _ecgd ,nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_gc .Model ;Bounds ()_bdf .Rectangle ;At (_gbec ,_cde int )_gc .Color ;Set (_ggede ,_gbbaf int ,_dcfb _gc .Color );};func (_bdeea *PdfParser )resolveReference (_fabgf *PdfObjectReference )(PdfObject ,bool ,error ){_ebfd ,_adda :=_bdeea .ObjCache [int (_fabgf .ObjectNumber )];
if _adda {return _ebfd ,true ,nil ;};_dece ,_dfab :=_bdeea .LookupByReference (*_fabgf );if _dfab !=nil {return nil ,false ,_dfab ;};_bdeea .ObjCache [int (_fabgf .ObjectNumber )]=_dece ;return _dece ,false ,nil ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};var _ecabd =_g .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");func _fdfa (_ded ,_fafeg PdfObject ,_ebefa int )bool {if _ebefa > _gagb {_ad .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gagb );
return false ;};if _ded ==nil &&_fafeg ==nil {return true ;}else if _ded ==nil ||_fafeg ==nil {return false ;};if _db .TypeOf (_ded )!=_db .TypeOf (_fafeg ){return false ;};switch _gfag :=_ded .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_gfag ==*(_fafeg .(*PdfObjectName ));case *PdfObjectString :return *_gfag ==*(_fafeg .(*PdfObjectString ));case *PdfObjectInteger :return *_gfag ==*(_fafeg .(*PdfObjectInteger ));case *PdfObjectBool :return *_gfag ==*(_fafeg .(*PdfObjectBool ));
case *PdfObjectFloat :return *_gfag ==*(_fafeg .(*PdfObjectFloat ));case *PdfIndirectObject :return _fdfa (TraceToDirectObject (_ded ),TraceToDirectObject (_fafeg ),_ebefa +1);case *PdfObjectArray :_fcea :=_fafeg .(*PdfObjectArray );if len ((*_gfag )._bbgg )!=len ((*_fcea )._bbgg ){return false ;
};for _cdae ,_efgcg :=range (*_gfag )._bbgg {if !_fdfa (_efgcg ,(*_fcea )._bbgg [_cdae ],_ebefa +1){return false ;};};return true ;case *PdfObjectDictionary :_fgfaa :=_fafeg .(*PdfObjectDictionary );_edeeb ,_bgacc :=(*_gfag )._bgga ,(*_fgfaa )._bgga ;if len (_edeeb )!=len (_bgacc ){return false ;
};for _eadf ,_dbcb :=range _edeeb {_dagd ,_gddae :=_bgacc [_eadf ];if !_gddae ||!_fdfa (_dbcb ,_dagd ,_ebefa +1){return false ;};};return true ;case *PdfObjectStream :_efgaed :=_fafeg .(*PdfObjectStream );return _fdfa ((*_gfag ).PdfObjectDictionary ,(*_efgaed ).PdfObjectDictionary ,_ebefa +1);
default:_ad .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_ded );
};return false ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gaeaf *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_aega :=MakeDict ();_aega .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gaeaf .GetFilterName ()));return _aega ;};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_bag int ;_eagg bool ;_ecc [4]byte ;_bdb bool ;_dee bool ;_bce bool ;_ecg bool ;_efb bool ;_bgg bool ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// UpdateParams updates the parameter values of the encoder.
func (_cfbe *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_gfeb ,_cagg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cagg ==nil {_cfbe .ColorComponents =int (_gfeb );
};_cbdc ,_cagg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cagg ==nil {_cfbe .BitsPerComponent =int (_cbdc );};_bggf ,_cagg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _cagg ==nil {_cfbe .Width =int (_bggf );};_edbg ,_cagg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _cagg ==nil {_cfbe .Height =int (_edbg );};_ggfg ,_cagg :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _cagg ==nil {_cfbe .Quality =int (_ggfg );};_dabc ,_egcge :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _egcge {_cfbe .Decode ,_cagg =_dabc .ToFloat64Array ();if _cagg !=nil {_ad .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_cagg );
};};};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_dbbf :=MakeDict ();return _dbbf .Update (objmap );};

// Append appends PdfObject(s) to the array.
func (_fgcf *PdfObjectArray )Append (objects ...PdfObject ){if _fgcf ==nil {_ad .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_fgcf ._bbgg =append (_fgcf ._bbgg ,objects ...);};

// Clear resets the dictionary to an empty state.
func (_bbae *PdfObjectDictionary )Clear (){_bbae ._bgad =[]PdfObjectName {};_bbae ._bgga =map[PdfObjectName ]PdfObject {};_bbae ._cbgf =&_b .Mutex {};};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
//
//	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _bdf .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _eedf ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_fgb .Error (_eedf ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_affe uint8 ;_fcbe _fd .Image ;_badcc error ;);if bwThreshold ==JB2ImageAutoThreshold {_fcbe ,_badcc =_fd .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_fgb .Error (_eedf ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_affe =uint8 (255*bwThreshold );_fcbe ,_badcc =_fd .MonochromeThresholdConverter (_affe ).Convert (i );};if _badcc !=nil {return nil ,_badcc ;};return _cge (_fcbe ),nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_gfdcdb *PdfObjectReference )Resolve ()PdfObject {if _gfdcdb ._bbcg ==nil {return MakeNull ();};_efge ,_ ,_adbg :=_gfdcdb ._bbcg .resolveReference (_gfdcdb );if _adbg !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_adbg );
return MakeNull ();};if _efge ==nil {_ad .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _efge ;};

// WriteString outputs the object as it is to be written to file.
func (_fbab *PdfObjectStreams )WriteString ()string {var _bdbag _abb .Builder ;_bdbag .WriteString (_a .FormatInt (_fbab .ObjectNumber ,10));_bdbag .WriteString ("\u0020\u0030\u0020\u0052");return _bdbag .String ();};type objectStreams map[int ]objectStream ;


// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_fbecg :=MakeArray ();for _ ,_gebbc :=range vals {_fbecg .Append (MakeInteger (_gebbc ));};return _fbecg ;};

// WriteString outputs the object as it is to be written to file.
func (_dgbf *PdfObjectName )WriteString ()string {var _cfdgb _fcc .Buffer ;if len (*_dgbf )> 127{_ad .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_dgbf );};_cfdgb .WriteString ("\u002f");
for _eeec :=0;_eeec < len (*_dgbf );_eeec ++{_gbc :=(*_dgbf )[_eeec ];if !IsPrintable (_gbc )||_gbc =='#'||IsDelimiter (_gbc ){_cfdgb .WriteString (_ba .Sprintf ("\u0023\u0025\u002e2\u0078",_gbc ));}else {_cfdgb .WriteByte (_gbc );};};return _cfdgb .String ();
};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _feeff :=obj .(type ){case *PdfObjectFloat :_ad .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_feeff ),nil ;case *PdfObjectInteger :return int64 (*_feeff ),nil ;case *PdfObjectReference :_eefe :=TraceToDirectObject (obj );return GetNumberAsInt64 (_eefe );case *PdfIndirectObject :return GetNumberAsInt64 (_feeff .PdfObject );};return 0,ErrNotANumber ;
};

// WriteString outputs the object as it is to be written to file.
func (_abede *PdfObjectBool )WriteString ()string {if *_abede {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abgc *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_caea *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _gebbb []float64 ;for _ ,_cedg :=range _caea .Elements (){_gaagd ,_beeg :=GetNumberAsFloat (TraceToDirectObject (_cedg ));if _beeg !=nil {return nil ,_ba .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_gebbb =append (_gebbb ,_gaagd );};return _gebbb ,nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func (_dcdc *PdfParser )seekToEOFMarker (_acgfb int64 )error {var _eagc int64 ;var _bebe int64 =2048;for _eagc < _acgfb -4{if _acgfb <=(_bebe +_eagc ){_bebe =_acgfb -_eagc ;};_ ,_ace :=_dcdc ._eebaa .Seek (_acgfb -_eagc -_bebe ,_gf .SeekStart );
if _ace !=nil {return _ace ;};_edbef :=make ([]byte ,_bebe );_dcdc ._eebaa .Read (_edbef );_ad .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_edbef ));
_ecca :=_bgdg .FindAllStringIndex (string (_edbef ),-1);if _ecca !=nil {_ddfe :=_ecca [len (_ecca )-1];_ad .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ecca );_dcbf :=_acgfb -_eagc -_bebe +int64 (_ddfe [0]);_dcdc ._eebaa .Seek (_dcbf ,_gf .SeekStart );
return nil ;};_ad .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_eagc +=_bebe -4;};_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _ffgd ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_cbd :=&FlateEncoder {};_cbd .Predictor =1;_cbd .BitsPerComponent =8;_cbd .Colors =1;_cbd .Columns =1;return _cbd ;};func _ffaca (_bddaa int )int {if _bddaa < 0{return -_bddaa ;};return _bddaa ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_abdfdg *PdfObjectDictionary )Keys ()[]PdfObjectName {if _abdfdg ==nil {return nil ;};return _abdfdg ._bgad ;};func _bbge (_cddac string )(int ,int ,error ){_dbbfa :=_ecabd .FindStringSubmatch (_cddac );if len (_dbbfa )< 3{return 0,0,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_abbeb ,_ :=_a .Atoi (_dbbfa [1]);_fefae ,_ :=_a .Atoi (_dbbfa [2]);return _abbeb ,_fefae ,nil ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_aaaaa *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_aaaaa ._cbgf .Lock ();defer _aaaaa ._cbgf .Unlock ();for _gddag ,_abddc :=range objmap {_aaaaa .setWithLock (PdfObjectName (_gddag ),_abddc ,false );};return _aaaaa ;
};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_efedf []PdfObject ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfdc *FlateEncoder )MakeDecodeParams ()PdfObject {if _gfdc .Predictor > 1{_dcfe :=MakeDict ();_dcfe .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gfdc .Predictor )));if _gfdc .BitsPerComponent !=8{_dcfe .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gfdc .BitsPerComponent )));
};if _gfdc .Columns !=1{_dcfe .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gfdc .Columns )));};if _gfdc .Colors !=1{_dcfe .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gfdc .Colors )));};return _dcfe ;};return nil ;
};var _cacbc =_g .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_ag .Reader )(PdfObject ,error ){_adca :=false ;_bgdc :=true ;var _bea _fcc .Buffer ;for {if _ad .Log .IsLogLevel (_ad .LogLevelTrace ){_ad .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_bea .String ());
};_afede ,_ebff :=buf .Peek (1);if _ebff ==_gf .EOF {break ;};if _ebff !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_ebff );return nil ,_ebff ;};if _bgdc &&(_afede [0]=='-'||_afede [0]=='+'){_faga ,_ :=buf .ReadByte ();_bea .WriteByte (_faga );
_bgdc =false ;}else if IsDecimalDigit (_afede [0]){_eggc ,_ :=buf .ReadByte ();_bea .WriteByte (_eggc );}else if _afede [0]=='.'{_cfag ,_ :=buf .ReadByte ();_bea .WriteByte (_cfag );_adca =true ;}else if _afede [0]=='e'||_afede [0]=='E'{_eaeaa ,_ :=buf .ReadByte ();
_bea .WriteByte (_eaeaa );_adca =true ;_bgdc =true ;}else {break ;};};var _edce PdfObject ;if _adca {_agdd ,_beegf :=_a .ParseFloat (_bea .String (),64);if _beegf !=nil {_ad .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_bea .String (),_beegf );
_agdd =0.0;};_aadeg :=PdfObjectFloat (_agdd );_edce =&_aadeg ;}else {_badd ,_bfeaa :=_a .ParseInt (_bea .String (),10,64);if _bfeaa !=nil {_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_bea .String (),_bfeaa );
_badd =0;};_effde :=PdfObjectInteger (_badd );_edce =&_effde ;};return _edce ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _faabb ,_gac :=obj .(*PdfObjectReference );_gac {obj =_faabb .Resolve ();};_gaee ,_gggd :=obj .(*PdfIndirectObject );_gceef :=0;for _gggd {obj =_gaee .PdfObject ;_gaee ,_gggd =GetIndirect (obj );_gceef ++;
if _gceef > _gagb {_ad .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_gagb );
return nil ;};};return obj ;};type xrefType int ;

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_gccf :=TraceToDirectObject (obj ).(*PdfObjectNull );return _gccf ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_bbcf *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bbcf .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_acccg *PdfObjectArray ,_cded bool ){_acccg ,_cded =TraceToDirectObject (obj ).(*PdfObjectArray );return _acccg ,_cded ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_afeg *PdfObjectName ,_fafba bool ){_afeg ,_fafba =TraceToDirectObject (obj ).(*PdfObjectName );return _afeg ,_fafba ;};

// HasNonConformantStream implements core.ParserMetadata.
func (_beda ParserMetadata )HasNonConformantStream ()bool {return _beda ._ecg };func (_fec *PdfCrypt )authenticate (_bba []byte )(bool ,error ){_fec ._aga =false ;_fbc :=_fec .securityHandler ();_eag ,_bfa ,_fff :=_fbc .Authenticate (&_fec ._ccf ,_bba );
if _fff !=nil {return false ,_fff ;}else if _bfa ==0||len (_eag )==0{return false ,nil ;};_fec ._aga =true ;_fec ._fea =_eag ;return true ,nil ;};func _ffbe (_dbeg *PdfObjectStream ,_dab *PdfObjectDictionary )(*LZWEncoder ,error ){_fgge :=NewLZWEncoder ();
_ebb :=_dbeg .PdfObjectDictionary ;if _ebb ==nil {return _fgge ,nil ;};if _dab ==nil {_eff :=TraceToDirectObject (_ebb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _eff !=nil {if _dcfd ,_aaba :=_eff .(*PdfObjectDictionary );
_aaba {_dab =_dcfd ;}else if _dfgc ,_gdae :=_eff .(*PdfObjectArray );_gdae {if _dfgc .Len ()==1{if _cefc ,_ddbce :=GetDict (_dfgc .Get (0));_ddbce {_dab =_cefc ;};};};if _dab ==nil {_ad .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_eff );
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_ccgd :=_ebb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _ccgd !=nil {_gba ,_bacb :=_ccgd .(*PdfObjectInteger );
if !_bacb {_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_ccgd );
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_gba !=0&&*_gba !=1{return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_fgge .EarlyChange =int (*_gba );}else {_fgge .EarlyChange =1;};if _dab ==nil {return _fgge ,nil ;};if _fdea ,_bebb :=GetIntVal (_dab .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_bebb {if _fdea ==0||_fdea ==1{_fgge .EarlyChange =_fdea ;
}else {_ad .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_fdea );};};_ccgd =_dab .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _ccgd !=nil {_daaa ,_fgga :=_ccgd .(*PdfObjectInteger );if !_fgga {_ad .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_ccgd );
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fgge .Predictor =int (*_daaa );};_ccgd =_dab .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _ccgd !=nil {_egcg ,_egcgg :=_ccgd .(*PdfObjectInteger );if !_egcgg {_ad .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ba .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fgge .BitsPerComponent =int (*_egcg );};if _fgge .Predictor > 1{_fgge .Columns =1;_ccgd =_dab .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _ccgd !=nil {_ceed ,_cffc :=_ccgd .(*PdfObjectInteger );if !_cffc {return nil ,_ba .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fgge .Columns =int (*_ceed );
};_fgge .Colors =1;_ccgd =_dab .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _ccgd !=nil {_dfb ,_eaaa :=_ccgd .(*PdfObjectInteger );if !_eaaa {return nil ,_ba .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_fgge .Colors =int (*_dfb );};};_ad .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dab .String ());return _fgge ,nil ;};func (_add *PdfParser )lookupByNumber (_aff int ,_fcg bool )(PdfObject ,bool ,error ){_ae ,_bcb :=_add .ObjCache [_aff ];
if _bcb {_ad .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_aff );return _ae ,false ,nil ;};if _add ._abafa ==nil {_add ._abafa =map[int ]bool {};
};if _add ._abafa [_aff ]{_ad .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_aff );
return nil ,false ,_c .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_add ._abafa [_aff ]=true ;defer delete (_add ._abafa ,_aff );
_bg ,_bcb :=_add ._caeg .ObjectMap [_aff ];if !_bcb {_ad .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _bbb PdfObjectNull ;return &_bbb ,false ,nil ;};_ad .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_aff );if _bg .XType ==XrefTypeTableEntry {_ad .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_bg .ObjectNumber );
_ad .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_bg .Generation );_ad .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_bg .Offset );_add ._eebaa .Seek (_bg .Offset ,_gf .SeekStart );
_add ._bgec =_ag .NewReader (_add ._eebaa );_caa ,_cef :=_add .ParseIndirectObject ();if _cef !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_cef );
if _fcg {_ad .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_ggd ,_bbgc :=_add .repairRebuildXrefsTopDown ();
if _bbgc !=nil {_ad .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_bbgc );return nil ,false ,_bbgc ;};_add ._caeg =*_ggd ;return _add .lookupByNumber (_aff ,false );
};return nil ,false ,_cef ;};if _fcg {_edd ,_ ,_ :=_ce (_caa );if int (_edd )!=_aff {_ad .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_cdd :=_add .rebuildXrefTable ();
if _cdd !=nil {return nil ,false ,_cdd ;};_add .ObjCache =objectCache {};return _add .lookupByNumberWrapper (_aff ,false );};};_ad .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_add .ObjCache [_aff ]=_caa ;
return _caa ,false ,nil ;}else if _bg .XType ==XrefTypeObjectStream {_ad .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_ad .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_ad .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_bg .OsObjNumber ,_bg .OsObjIndex );
if _bg .OsObjNumber ==_aff {_ad .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_c .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_becg :=_add ._caeg .ObjectMap [_bg .OsObjNumber ];_becg {_eeg ,_aeb :=_add .lookupObjectViaOS (_bg .OsObjNumber ,_aff );if _aeb !=nil {_ad .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_aeb );
return nil ,true ,_aeb ;};_ad .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_add .ObjCache [_aff ]=_eeg ;if _add ._bacc !=nil {_add ._bacc ._edda [_eeg ]=true ;};return _eeg ,true ,nil ;};_ad .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_c .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_c .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_bcdfe *PdfObjectString )Decoded ()string {if _bcdfe ==nil {return "";};_efdf :=[]byte (_bcdfe ._ffff );if len (_efdf )>=2&&_efdf [0]==0xFE&&_efdf [1]==0xFF{return _bdc .UTF16ToString (_efdf [2:]);};return _bdc .PDFDocEncodingToString (_efdf );};


// EncodeBytes encodes data into ASCII85 encoded format.
func (_abdf *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _ebag _fcc .Buffer ;for _acac :=0;_acac < len (data );_acac +=4{_gfdce :=data [_acac ];_eedb :=1;_adf :=byte (0);if _acac +1< len (data ){_adf =data [_acac +1];_eedb ++;};_acgf :=byte (0);
if _acac +2< len (data ){_acgf =data [_acac +2];_eedb ++;};_gbbc :=byte (0);if _acac +3< len (data ){_gbbc =data [_acac +3];_eedb ++;};_eagf :=(uint32 (_gfdce )<<24)|(uint32 (_adf )<<16)|(uint32 (_acgf )<<8)|uint32 (_gbbc );if _eagf ==0{_ebag .WriteByte ('z');
}else {_cdacd :=_abdf .base256Tobase85 (_eagf );for _ ,_efcf :=range _cdacd [:_eedb +1]{_ebag .WriteByte (_efcf +'!');};};};_ebag .WriteString ("\u007e\u003e");return _ebag .Bytes (),nil ;};type objectCache map[int ]PdfObject ;

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_degg *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_abaf :=_fcc .NewReader (encoded );var _fdde []byte ;for {_edddc ,_bbe :=_abaf .ReadByte ();if _bbe !=nil {return nil ,_bbe ;};if _edddc =='>'{break ;};if IsWhiteSpace (_edddc ){continue ;
};if (_edddc >='a'&&_edddc <='f')||(_edddc >='A'&&_edddc <='F')||(_edddc >='0'&&_edddc <='9'){_fdde =append (_fdde ,_edddc );}else {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_edddc );
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_edddc );};};if len (_fdde )%2==1{_fdde =append (_fdde ,'0');
};_ad .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_fdde );_baaa :=make ([]byte ,_df .DecodedLen (len (_fdde )));_ ,_bbag :=_df .Decode (_baaa ,_fdde );if _bbag !=nil {return nil ,_bbag ;};return _baaa ,nil ;};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_aedg ParserMetadata )HasDataAfterEOF ()bool {return _aedg ._bdb };

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dec *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_afad :_e .InitEncodeDocument (false )}};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_ffff string ;_aggdd bool ;};func _afe (_gee *_cda .StdEncryptDict ,_gdf *PdfObjectDictionary )error {R ,_bgf :=_gdf .Get ("\u0052").(*PdfObjectInteger );if !_bgf {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_gee .R =int (*R );O ,_bgf :=_gdf .GetString ("\u004f");if !_bgf {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _gee .R ==5||_gee .R ==6{if len (O )< 48{return _ba .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ba .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_gee .O =[]byte (O );U ,_bgf :=_gdf .GetString ("\u0055");if !_bgf {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _gee .R ==5||_gee .R ==6{if len (U )< 48{return _ba .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_ad .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_gee .U =[]byte (U );if _gee .R >=5{OE ,_gegc :=_gdf .GetString ("\u004f\u0045");
if !_gegc {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ba .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_gee .OE =[]byte (OE );UE ,_gegc :=_gdf .GetString ("\u0055\u0045");if !_gegc {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _ba .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_gee .UE =[]byte (UE );};P ,_bgf :=_gdf .Get ("\u0050").(*PdfObjectInteger );if !_bgf {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_gee .P =_cda .Permissions (*P );if _gee .R ==6{Perms ,_dgb :=_gdf .GetString ("\u0050\u0065\u0072m\u0073");if !_dgb {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _ba .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_gee .Perms =[]byte (Perms );};if _abg ,_bdcb :=_gdf .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_bdcb {_gee .EncryptMetadata =bool (*_abg );}else {_gee .EncryptMetadata =true ;};return nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_bad *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_fccf ,_dcg :=obj .(*PdfObjectReference );if !_dcg {return obj ,nil ;};_ef :=_bad .GetFileOffset ();defer func (){_bad .SetFileOffset (_ef )}();_dbgc ,_aeba :=_bad .LookupByReference (*_fccf );
if _aeba !=nil {return nil ,_aeba ;};_aec ,_ddd :=_dbgc .(*PdfIndirectObject );if !_ddd {return _dbgc ,nil ;};_dbgc =_aec .PdfObject ;_ ,_dcg =_dbgc .(*PdfObjectReference );if _dcg {return _aec ,_c .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _dbgc ,nil ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_fgde *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _bdgd :=val .(type ){case *PdfObjectName :if _bdgd !=nil {_fgde .Set (key ,val );};case *PdfObjectDictionary :if _bdgd !=nil {_fgde .Set (key ,val );
};case *PdfObjectStream :if _bdgd !=nil {_fgde .Set (key ,val );};case *PdfObjectString :if _bdgd !=nil {_fgde .Set (key ,val );};case *PdfObjectNull :if _bdgd !=nil {_fgde .Set (key ,val );};case *PdfObjectInteger :if _bdgd !=nil {_fgde .Set (key ,val );
};case *PdfObjectArray :if _bdgd !=nil {_fgde .Set (key ,val );};case *PdfObjectBool :if _bdgd !=nil {_fgde .Set (key ,val );};case *PdfObjectFloat :if _bdgd !=nil {_fgde .Set (key ,val );};case *PdfObjectReference :if _bdgd !=nil {_fgde .Set (key ,val );
};case *PdfIndirectObject :if _bdgd !=nil {_fgde .Set (key ,val );};default:_ad .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// Elements returns a slice of the PdfObject elements in the array.
func (_ccgb *PdfObjectArray )Elements ()[]PdfObject {if _ccgb ==nil {return nil ;};return _ccgb ._bbgg ;};type cryptFilters map[string ]_agf .Filter ;

// Len returns the number of elements in the array.
func (_ccgdf *PdfObjectArray )Len ()int {if _ccgdf ==nil {return 0;};return len (_ccgdf ._bbgg );};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_dgff *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dgff ._efedf ){return _c .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dgff ._efedf [i ]=obj ;return nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _gf .ReadSeeker )(*PdfParser ,error ){_edcbg :=&PdfParser {_eebaa :rs ,ObjCache :make (objectCache ),_eedbc :map[int64 ]bool {},_afed :make ([]int64 ,0),_bdaf :make (map[*PdfParser ]*PdfParser )};_eccgf ,_ddgba ,_fdae :=_edcbg .parsePdfVersion ();
if _fdae !=nil {_ad .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_fdae );return nil ,_fdae ;};_edcbg ._fadc .Major =_eccgf ;_edcbg ._fadc .Minor =_ddgba ;
if _edcbg ._cdcd ,_fdae =_edcbg .loadXrefs ();_fdae !=nil {_ad .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_fdae );return nil ,_fdae ;
};_ad .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_edcbg ._cdcd );_ebde ,_fdae :=_edcbg .parseLinearizedDictionary ();if _fdae !=nil {return nil ,_fdae ;};if _ebde !=nil {_edcbg ._fcba ,_fdae =_edcbg .checkLinearizedInformation (_ebde );
if _fdae !=nil {return nil ,_fdae ;};};if len (_edcbg ._caeg .ObjectMap )==0{return nil ,_ba .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};_edcbg ._dagae =len (_edcbg ._afed );if _edcbg ._fcba &&_edcbg ._dagae !=0{_edcbg ._dagae --;};_edcbg ._afbb =make ([]*PdfParser ,_edcbg ._dagae );return _edcbg ,nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_bgbe :=PdfObjectFloat (val );return &_bgbe };

// DecodeStream implements ASCII hex decoding.
func (_dbgf *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dbgf .DecodeBytes (streamObj .Stream );};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cbgaf *PdfObjectStream ,_edbga bool ){obj =ResolveReference (obj );_cbgaf ,_edbga =obj .(*PdfObjectStream );return _cbgaf ,_edbga ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_aade *PdfObjectBool ,_aeda bool ){_aade ,_aeda =TraceToDirectObject (obj ).(*PdfObjectBool );return _aade ,_aeda ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_adg *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_adeb *PdfParser )Inspect ()(map[string ]int ,error ){return _adeb .inspect ()};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func _eee (_acgc XrefTable ){_ad .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");
_ad .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_baeb :=0;for _ ,_agc :=range _acgc .ObjectMap {_ad .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_baeb +1,_agc .ObjectNumber ,_agc .Generation ,_agc .Offset );
_baeb ++;};};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_gdfg bool ,_efba bool ){_aeag ,_efba :=TraceToDirectObject (obj ).(*PdfObjectBool );if _efba {return bool (*_aeag ),true ;};return false ,false ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// Validate validates the page settings for the JBIG2 encoder.
func (_daef JBIG2EncoderSettings )Validate ()error {const _bdce ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _daef .Threshold < 0||_daef .Threshold > 1.0{return _fgb .Errorf (_bdce ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_daef .Threshold );
};if _daef .ResolutionX < 0{return _fgb .Errorf (_bdce ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_daef .ResolutionX );
};if _daef .ResolutionY < 0{return _fgb .Errorf (_bdce ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_daef .ResolutionY );
};if _daef .DefaultPixelValue !=0&&_daef .DefaultPixelValue !=1{return _fgb .Errorf (_bdce ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_daef .DefaultPixelValue );
};if _daef .Compression !=JB2Generic {return _fgb .Errorf (_bdce ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};func _eeab (_bede *PdfObjectStream ,_gebb *MultiEncoder )(*DCTEncoder ,error ){_gfg :=NewDCTEncoder ();_afaa :=_bede .PdfObjectDictionary ;if _afaa ==nil {return _gfg ,nil ;};_gaag :=_bede .Stream ;if _gebb !=nil {_dbcec ,_bcef :=_gebb .DecodeBytes (_gaag );
if _bcef !=nil {return nil ,_bcef ;};_gaag =_dbcec ;};_gaaga :=_fcc .NewReader (_gaag );_fgba ,_eeba :=_be .DecodeConfig (_gaaga );if _eeba !=nil {_ad .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_eeba );
return nil ,_eeba ;};switch _fgba .ColorModel {case _gc .RGBAModel :_gfg .BitsPerComponent =8;_gfg .ColorComponents =3;_gfg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _gc .RGBA64Model :_gfg .BitsPerComponent =16;_gfg .ColorComponents =3;_gfg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};
case _gc .GrayModel :_gfg .BitsPerComponent =8;_gfg .ColorComponents =1;_gfg .Decode =[]float64 {0.0,1.0};case _gc .Gray16Model :_gfg .BitsPerComponent =16;_gfg .ColorComponents =1;_gfg .Decode =[]float64 {0.0,1.0};case _gc .CMYKModel :_gfg .BitsPerComponent =8;
_gfg .ColorComponents =4;_gfg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};case _gc .YCbCrModel :_gfg .BitsPerComponent =8;_gfg .ColorComponents =3;_gfg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};default:return nil ,_c .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_gfg .Width =_fgba .Width ;_gfg .Height =_fgba .Height ;_ad .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_gfg );_gfg .Quality =DefaultJPEGQuality ;_afeb ,_egde :=GetArray (_afaa .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _egde {_dcgf ,_edbd :=_afeb .ToFloat64Array ();if _edbd !=nil {return _gfg ,_edbd ;};_gfg .Decode =_dcgf ;};return _gfg ,nil ;};func _gbge (_cedgg PdfObject ,_ceebg int )PdfObject {if _ceebg > _gagb {_ad .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gagb );
return MakeNull ();};switch _gcaf :=_cedgg .(type ){case *PdfIndirectObject :_cedgg =_gbge ((*_gcaf ).PdfObject ,_ceebg +1);case *PdfObjectArray :for _dcbb ,_dbef :=range (*_gcaf )._bbgg {(*_gcaf )._bbgg [_dcbb ]=_gbge (_dbef ,_ceebg +1);};case *PdfObjectDictionary :for _dbdd ,_eagff :=range (*_gcaf )._bgga {(*_gcaf )._bgga [_dbdd ]=_gbge (_eagff ,_ceebg +1);
};_fe .Slice ((*_gcaf )._bgad ,func (_fgdg ,_cffgg int )bool {return (*_gcaf )._bgad [_fgdg ]< (*_gcaf )._bgad [_cffgg ]});};return _cedgg ;};

// GetFilterName returns the name of the encoding filter.
func (_acfa *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ebee *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_eabf :=PdfIndirectObject {};_eabf ._bbcg =_ebee ;_ad .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_ccdgf ,_eccd :=_ebee ._bgec .Peek (20);
if _eccd !=nil {if _eccd !=_gf .EOF {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_eabf ,_eccd ;
};};_ad .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ccdgf ));_fdce :=_ecabd .FindStringSubmatchIndex (string (_ccdgf ));if len (_fdce )< 6{if _eccd ==_gf .EOF {return nil ,_eccd ;
};_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_ccdgf ));
return &_eabf ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ebee ._bgec .Discard (_fdce [0]);_ad .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_fdce );_bbdb :=_fdce [1]-_fdce [0];_cbdd :=make ([]byte ,_bbdb );_ ,_eccd =_ebee .ReadAtLeast (_cbdd ,_bbdb );if _eccd !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_eccd );
return nil ,_eccd ;};_ad .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cbdd );_adedd :=_ecabd .FindStringSubmatch (string (_cbdd ));if len (_adedd )< 3{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_cbdd ));
return &_eabf ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ccddf ,_ :=_a .Atoi (_adedd [1]);_bgac ,_ :=_a .Atoi (_adedd [2]);_eabf .ObjectNumber =int64 (_ccddf );_eabf .GenerationNumber =int64 (_bgac );for {_ggag ,_bbgf :=_ebee ._bgec .Peek (2);if _bbgf !=nil {return &_eabf ,_bbgf ;};_ad .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ggag ),string (_ggag ));
if IsWhiteSpace (_ggag [0]){_ebee .skipSpaces ();}else if _ggag [0]=='%'{_ebee .skipComments ();}else if (_ggag [0]=='<')&&(_ggag [1]=='<'){_ad .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_eabf .PdfObject ,_bbgf =_ebee .ParseDict ();
_ad .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_bbgf );if _bbgf !=nil {return &_eabf ,_bbgf ;};_ad .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_ggag [0]=='/')||(_ggag [0]=='(')||(_ggag [0]=='[')||(_ggag [0]=='<'){_eabf .PdfObject ,_bbgf =_ebee .parseObject ();if _bbgf !=nil {return &_eabf ,_bbgf ;};_ad .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _ggag [0]==']'{_ad .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_ebee ._bgec .Discard (1);}else {if _ggag [0]=='e'{_fggf ,_cccfc :=_ebee .readTextLine ();if _cccfc !=nil {return nil ,_cccfc ;};if len (_fggf )>=6&&_fggf [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _ggag [0]=='s'{_ggag ,_ =_ebee ._bgec .Peek (10);
if string (_ggag [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cebe :=6;if len (_ggag )> 6{if IsWhiteSpace (_ggag [_cebe ])&&_ggag [_cebe ]!='\r'&&_ggag [_cebe ]!='\n'{_ad .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_ebee ._edac ._ecg =true ;_cebe ++;};if _ggag [_cebe ]=='\r'{_cebe ++;if _ggag [_cebe ]=='\n'{_cebe ++;};}else if _ggag [_cebe ]=='\n'{_cebe ++;}else {_ebee ._edac ._ecg =true ;};};_ebee ._bgec .Discard (_cebe );_feeee ,_gage :=_eabf .PdfObject .(*PdfObjectDictionary );
if !_gage {return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ad .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_feeee );
_gcbg ,_fbgae :=_ebee .traceStreamLength (_feeee .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _fbgae !=nil {_ad .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_fbgae );
return nil ,_fbgae ;};_ad .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gcbg );_dccdb ,_aebd :=_gcbg .(*PdfObjectInteger );if !_aebd {return nil ,_c .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_facfa :=*_dccdb ;if _facfa < 0{return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_decf :=_ebee .GetFileOffset ();
_cfeb :=_ebee .xrefNextObjectOffset (_decf );if _decf +int64 (_facfa )> _cfeb &&_cfeb > _decf {_ad .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_decf +int64 (_facfa ));_ad .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_cfeb );
_beebd :=_cfeb -_decf -17;if _beebd < 0{return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_ad .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_beebd );_facfa =PdfObjectInteger (_beebd );
_feeee .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_beebd ));};if int64 (_facfa )> _ebee ._edaa {_ad .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_dfda :=make ([]byte ,_facfa );
_ ,_fbgae =_ebee .ReadAtLeast (_dfda ,int (_facfa ));if _fbgae !=nil {_ad .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_dfda ),_dfda );_ad .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbgae );
return nil ,_fbgae ;};_ffe :=PdfObjectStream {};_ffe .Stream =_dfda ;_ffe .PdfObjectDictionary =_eabf .PdfObject .(*PdfObjectDictionary );_ffe .ObjectNumber =_eabf .ObjectNumber ;_ffe .GenerationNumber =_eabf .GenerationNumber ;_ffe .PdfObjectReference ._bbcg =_ebee ;
_ebee .skipSpaces ();_ebee ._bgec .Discard (9);_ebee .skipSpaces ();return &_ffe ,nil ;};};_eabf .PdfObject ,_bbgf =_ebee .parseObject ();if _eabf .PdfObject ==nil {_ad .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_eabf .PdfObject =MakeNull ();};return &_eabf ,_bbgf ;};};if _eabf .PdfObject ==nil {_ad .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_eabf .PdfObject =MakeNull ();};_ad .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_eabf ,nil ;};func _eeb (_cbag _agf .Filter ,_aaf _cda .AuthEvent )*PdfObjectDictionary {if _aaf ==""{_aaf =_cda .EventDocOpen ;
};_geb :=MakeDict ();_geb .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_geb .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_aaf )));_geb .Set ("\u0043\u0046\u004d",MakeName (_cbag .Name ()));
_geb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cbag .KeyLength ())));return _geb ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_eaee :=&ASCIIHexEncoder {};return _eaee };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cac *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_bdd ParserMetadata )HasEOLAfterHeader ()bool {return _bdd ._eagg };

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_gcc encryptDict ;_ccf _cda .StdEncryptDict ;_addd string ;_fea []byte ;_edda map[PdfObject ]bool ;_ga map[PdfObject ]bool ;_aga bool ;_gca cryptFilters ;_ade string ;_dgea string ;_bbd *PdfParser ;_geg map[int ]struct{};};func (_acddf *ASCII85Encoder )base256Tobase85 (_adad uint32 )[5]byte {_faa :=[5]byte {0,0,0,0,0};
_cfdg :=_adad ;for _egfg :=0;_egfg < 5;_egfg ++{_caff :=uint32 (1);for _bbaa :=0;_bbaa < 4-_egfg ;_bbaa ++{_caff *=85;};_ebda :=_cfdg /_caff ;_cfdg =_cfdg %_caff ;_faa [_egfg ]=byte (_ebda );};return _faa ;};

// Append appends PdfObject(s) to the streams.
func (_egfa *PdfObjectStreams )Append (objects ...PdfObject ){if _egfa ==nil {_ad .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_egfa ._efedf =append (_egfa ._efedf ,objects ...);};

// WriteString outputs the object as it is to be written to file.
func (_fdgf *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetXrefTable returns the PDFs xref table.
func (_dddfec *PdfParser )GetXrefTable ()XrefTable {return _dddfec ._caeg };

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeLazy create temporary file for stream to reduce memory usage.
// It can be used for creating PDF with many images.
// Temporary files are removed automatically when Write/WriteToFile is called for creator object.
func (_bbafa *PdfObjectStream )MakeLazy ()error {if _bbafa .Lazy {return nil ;};_ecag ,_dega :=_f .CreateTemp ("","\u0078o\u0062\u006a\u0065\u0063\u0074");if _dega !=nil {return _dega ;};defer _ecag .Close ();_ ,_dega =_ecag .Write (_bbafa .Stream );if _dega !=nil {return _dega ;
};_bbafa .Lazy =true ;_bbafa .Stream =nil ;_bbafa .TempFile =_ecag .Name ();return nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_dcebe *PdfParser )GetCrypter ()*PdfCrypt {return _dcebe ._bacc };func (_adef *PdfCrypt )generateParams (_cddf ,_eac []byte )error {_ceeb :=_adef .securityHandler ();_abgd ,_dddb :=_ceeb .GenerateParams (&_adef ._ccf ,_eac ,_cddf );if _dddb !=nil {return _dddb ;
};_adef ._fea =_abgd ;return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cdfcbg *PdfIndirectObject )WriteString ()string {var _dgdf _abb .Builder ;_dgdf .WriteString (_a .FormatInt (_cdfcbg .ObjectNumber ,10));_dgdf .WriteString ("\u0020\u0030\u0020\u0052");return _dgdf .String ();};func _efbf ()string {return _ad .Version };


// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_cbcg *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cbcg .DecodeBytes (streamObj .Stream );};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_bfb *FlateEncoder )SetPredictor (columns int ){_bfb .Predictor =11;_bfb .Columns =columns };

// GetFilterName returns the name of the encoding filter.
func (_dfgbf *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//
//	renamed to String() as a pretty string to use in debugging etc.
func (_gbbf *MultiEncoder )GetFilterName ()string {_feda :="";for _dbae ,_cdbf :=range _gbbf ._bbee {_feda +=_cdbf .GetFilterName ();if _dbae < len (_gbbf ._bbee )-1{_feda +="\u0020";};};return _feda ;};func (_bca *PdfCrypt )isEncrypted (_gbg PdfObject )bool {_ ,_ceec :=_bca ._ga [_gbg ];
if _ceec {_ad .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_ad .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};func (_cbbe *PdfParser )parseArray ()(*PdfObjectArray ,error ){_egbb :=MakeArray ();_cbbe ._bgec .ReadByte ();for {_cbbe .skipSpaces ();_ddbf ,_fcdde :=_cbbe ._bgec .Peek (1);if _fcdde !=nil {return _egbb ,_fcdde ;};if _ddbf [0]==']'{_cbbe ._bgec .ReadByte ();
break ;};_gafa ,_fcdde :=_cbbe .parseObject ();if _fcdde !=nil {return _egbb ,_fcdde ;};_egbb .Append (_gafa );};return _egbb ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_eaea *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_fbgc *PdfParser )parseName ()(PdfObjectName ,error ){var _fdfb _fcc .Buffer ;_bfgdb :=false ;for {_bced ,_ggbga :=_fbgc ._bgec .Peek (1);if _ggbga ==_gf .EOF {break ;
};if _ggbga !=nil {return PdfObjectName (_fdfb .String ()),_ggbga ;};if !_bfgdb {if _bced [0]=='/'{_bfgdb =true ;_fbgc ._bgec .ReadByte ();}else if _bced [0]=='%'{_fbgc .readComment ();_fbgc .skipSpaces ();}else {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_bced ,_bced );
return PdfObjectName (_fdfb .String ()),_ba .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_bced [0]);};}else {if IsWhiteSpace (_bced [0]){break ;}else if (_bced [0]=='/')||(_bced [0]=='[')||(_bced [0]=='(')||(_bced [0]==']')||(_bced [0]=='<')||(_bced [0]=='>'){break ;
}else if _bced [0]=='#'{_fccg ,_egfe :=_fbgc ._bgec .Peek (3);if _egfe !=nil {return PdfObjectName (_fdfb .String ()),_egfe ;};_decb ,_egfe :=_df .DecodeString (string (_fccg [1:3]));if _egfe !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_fdfb .WriteByte ('#');_fbgc ._bgec .Discard (1);continue ;};_fbgc ._bgec .Discard (3);_fdfb .Write (_decb );}else {_fgaaa ,_ :=_fbgc ._bgec .ReadByte ();_fdfb .WriteByte (_fgaaa );};};};return PdfObjectName (_fdfb .String ()),nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_bbee []StreamEncoder };

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_babdf *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_fbbaa :=range another .Keys (){_bcbac :=another .Get (_fbbaa );_babdf .Set (_fbbaa ,_bcbac );};};return _babdf ;};var _cade =_g .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");


// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_dbac *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _dbac ._caae };

// HeaderPosition gets the file header position.
func (_dbfg ParserMetadata )HeaderPosition ()int {return _dbfg ._bag };

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_afg *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _afg .isEncrypted (obj ){return nil ;};switch _aea :=obj .(type ){case *PdfIndirectObject :_afg ._ga [_aea ]=true ;_ad .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_aea .ObjectNumber ,_aea .GenerationNumber );
_cbc :=_aea .ObjectNumber ;_dcgb :=_aea .GenerationNumber ;_dca :=_afg .Encrypt (_aea .PdfObject ,_cbc ,_dcgb );if _dca !=nil {return _dca ;};return nil ;case *PdfObjectStream :_afg ._ga [_aea ]=true ;_gbb :=_aea .PdfObjectDictionary ;if _addb ,_dgab :=_gbb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_dgab &&*_addb =="\u0058\u0052\u0065\u0066"{return nil ;};_gaa :=_aea .ObjectNumber ;_bcd :=_aea .GenerationNumber ;_ad .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gaa ,_bcd );
_eddb :=_cba ;if _afg ._gcc .V >=4{_eddb =_afg ._ade ;_ad .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_afg ._ade );if _dfed ,_ggf :=_gbb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_ggf {if _aeg ,_cgg :=GetName (_dfed .Get (0));_cgg {if *_aeg =="\u0043\u0072\u0079p\u0074"{_eddb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _deg ,_ged :=_gbb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_ged {if _ddc ,_cce :=_deg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cce {if _ ,_abe :=_afg ._gca [string (*_ddc )];_abe {_ad .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ddc );
_eddb =string (*_ddc );};};};};};};_ad .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_eddb );if _eddb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_eec :=_afg .Encrypt (_aea .PdfObjectDictionary ,_gaa ,_bcd );
if _eec !=nil {return _eec ;};_fbcd ,_eec :=_afg .makeKey (_eddb ,uint32 (_gaa ),uint32 (_bcd ),_afg ._fea );if _eec !=nil {return _eec ;};_aea .Stream ,_eec =_afg .encryptBytes (_aea .Stream ,_eddb ,_fbcd );if _eec !=nil {return _eec ;};_gbb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aea .Stream ))));
return nil ;case *PdfObjectString :_ad .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_ebd :=_cba ;if _afg ._gcc .V >=4{_ad .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_afg ._dgea );
if _afg ._dgea =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_ebd =_afg ._dgea ;};_fgaa ,_ccdg :=_afg .makeKey (_ebd ,uint32 (parentObjNum ),uint32 (parentGenNum ),_afg ._fea );if _ccdg !=nil {return _ccdg ;};_afc :=_aea .Str ();_cdc :=make ([]byte ,len (_afc ));
for _fecf :=0;_fecf < len (_afc );_fecf ++{_cdc [_fecf ]=_afc [_fecf ];};_ad .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_cdc ,_cdc );_cdc ,_ccdg =_afg .encryptBytes (_cdc ,_ebd ,_fgaa );
if _ccdg !=nil {return _ccdg ;};_aea ._ffff =string (_cdc );return nil ;case *PdfObjectArray :for _ ,_ddf :=range _aea .Elements (){_cdb :=_afg .Encrypt (_ddf ,parentObjNum ,parentGenNum );if _cdb !=nil {return _cdb ;};};return nil ;case *PdfObjectDictionary :_babg :=false ;
if _eedd :=_aea .Get ("\u0054\u0079\u0070\u0065");_eedd !=nil {_ddbc ,_aca :=_eedd .(*PdfObjectName );if _aca &&*_ddbc =="\u0053\u0069\u0067"{_babg =true ;};};for _ ,_acfeb :=range _aea .Keys (){_gcfc :=_aea .Get (_acfeb );if _babg &&string (_acfeb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;
};if string (_acfeb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_acfeb )!="\u0050\u0072\u0065\u0076"&&string (_acfeb )!="\u004c\u0061\u0073\u0074"{_gbd :=_afg .Encrypt (_gcfc ,parentObjNum ,parentGenNum );if _gbd !=nil {return _gbd ;};};};return nil ;
};return nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_abbf *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_abbf .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_ecce *JBIG2Encoder )DecodeImages (encoded []byte )([]_bdf .Image ,error ){const _cca ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_aecf ,_dfde :=_ee .Decode (encoded ,_ee .Parameters {},_ecce .Globals .ToDocumentGlobals ());
if _dfde !=nil {return nil ,_fgb .Wrap (_dfde ,_cca ,"");};_fddc ,_dfde :=_aecf .PageNumber ();if _dfde !=nil {return nil ,_fgb .Wrap (_dfde ,_cca ,"");};_cbcgg :=[]_bdf .Image {};var _gdfc _bdf .Image ;for _faabd :=1;_faabd <=_fddc ;_faabd ++{_gdfc ,_dfde =_aecf .DecodePageImage (_faabd );
if _dfde !=nil {return nil ,_fgb .Wrapf (_dfde ,_cca ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_faabd );};_cbcgg =append (_cbcgg ,_gdfc );};return _cbcgg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eecg *LZWEncoder )MakeDecodeParams ()PdfObject {if _eecg .Predictor > 1{_bddd :=MakeDict ();_bddd .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_eecg .Predictor )));if _eecg .BitsPerComponent !=8{_bddd .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_eecg .BitsPerComponent )));
};if _eecg .Columns !=1{_bddd .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_eecg .Columns )));};if _eecg .Colors !=1{_bddd .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_eecg .Colors )));};return _bddd ;};return nil ;
};

// UpdateParams updates the parameter values of the encoder.
func (_dfcb *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_bbea *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _cged *PdfObjectDictionary ;_ceaf ,_fgef :=_bbea .readTextLine ();if _fgef !=nil {return nil ,_fgef ;
};if _bbea ._afge &&_abb .Count (_abb .TrimPrefix (_ceaf ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_bbea ._edac ._bgg =true ;};_ad .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_ceaf );
_adea :=-1;_egbc :=0;_ccde :=false ;_cdea :="";for {_bbea .skipSpaces ();_ ,_fcce :=_bbea ._bgec .Peek (1);if _fcce !=nil {return nil ,_fcce ;};_ceaf ,_fcce =_bbea .readTextLine ();if _fcce !=nil {return nil ,_fcce ;};_ebebd :=_dac .FindStringSubmatch (_ceaf );
if len (_ebebd )==0{_bdee :=len (_cdea )> 0;_cdea +=_ceaf +"\u000a";if _bdee {_ebebd =_dac .FindStringSubmatch (_cdea );};};if len (_ebebd )==3{if _bbea ._afge &&!_bbea ._edac ._efb {var (_bccg bool ;_aegb int ;);for _ ,_bbaf :=range _ceaf {if _bd .IsDigit (_bbaf ){if _bccg {break ;
};continue ;};if !_bccg {_bccg =true ;};_aegb ++;};if _aegb > 1{_bbea ._edac ._efb =true ;};};_eeeg ,_ :=_a .Atoi (_ebebd [1]);_egdg ,_ :=_a .Atoi (_ebebd [2]);_adea =_eeeg ;_egbc =_egdg ;_ccde =true ;_cdea ="";_ad .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_adea ,_egbc );
continue ;};_aabcb :=_babf .FindStringSubmatch (_ceaf );if len (_aabcb )==4{if !_ccde {_ad .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_c .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_decd ,_ :=_a .ParseInt (_aabcb [1],10,64);_fae ,_ :=_a .Atoi (_aabcb [2]);_cgbb :=_aabcb [3];_cdea ="";if _abb .ToLower (_cgbb )=="\u006e"&&_decd > 1{_caef ,_agecb :=_bbea ._caeg .ObjectMap [_adea ];if !_agecb ||_fae > _caef .Generation {_geccd :=XrefObject {ObjectNumber :_adea ,XType :XrefTypeTableEntry ,Offset :_decd ,Generation :_fae };
_bbea ._caeg .ObjectMap [_adea ]=_geccd ;};};_adea ++;continue ;};if (len (_ceaf )> 6)&&(_ceaf [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_ad .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_ceaf );
if len (_ceaf )> 9{_adaa :=_bbea .GetFileOffset ();_bbea .SetFileOffset (_adaa -int64 (len (_ceaf ))+7);};_bbea .skipSpaces ();_bbea .skipComments ();_ad .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_ad .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_ceaf );_cged ,_fcce =_bbea .ParseDict ();_ad .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _fcce !=nil {_ad .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fcce );return nil ,_fcce ;};break ;};if _ceaf =="\u0025\u0025\u0045O\u0046"{_ad .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_c .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_ad .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_ceaf );
};_ad .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _bbea ._cecc ==nil {_feec :=XrefTypeTableEntry ;_bbea ._cecc =&_feec ;};return _cged ,nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_egea :=PdfObjectBool (val );return &_egea };

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_cffda *PdfObjectArray )Get (i int )PdfObject {if _cffda ==nil ||i >=len (_cffda ._bbgg )||i < 0{return nil ;};return _cffda ._bbgg [i ];};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func _ddcef (_cffd *PdfObjectStream ,_cfcd *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_fbga :=NewCCITTFaxEncoder ();
_ggab :=_cffd .PdfObjectDictionary ;if _ggab ==nil {return _fbga ,nil ;};if _cfcd ==nil {_dgaba :=TraceToDirectObject (_ggab .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dgaba !=nil {switch _feeb :=_dgaba .(type ){case *PdfObjectDictionary :_cfcd =_feeb ;
case *PdfObjectArray :if _feeb .Len ()==1{if _ffc ,_cdfd :=GetDict (_feeb .Get (0));_cdfd {_cfcd =_ffc ;};};default:_ad .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dgaba );
return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cfcd ==nil {_ad .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_dgaba );
return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _agaae ,_fdff :=GetNumberAsInt64 (_cfcd .Get ("\u004b"));_fdff ==nil {_fbga .K =int (_agaae );};if _bbdfc ,_feef :=GetNumberAsInt64 (_cfcd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_feef ==nil {_fbga .Columns =int (_bbdfc );}else {_fbga .Columns =1728;};if _bfba ,_badg :=GetNumberAsInt64 (_cfcd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_badg ==nil {_fbga .BlackIs1 =_bfba > 0;}else {if _ggee ,_egdf :=GetBoolVal (_cfcd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_egdf {_fbga .BlackIs1 =_ggee ;}else {if _aded ,_gcef :=GetArray (_cfcd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_gcef {_dfgb ,_aeaa :=_aded .ToIntegerArray ();if _aeaa ==nil {_fbga .BlackIs1 =_dfgb [0]==1&&_dfgb [1]==0;};};};};if _ebgfe ,_cecg :=GetNumberAsInt64 (_cfcd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_cecg ==nil {_fbga .EncodedByteAlign =_ebgfe > 0;}else {if _bdab ,_cbaf :=GetBoolVal (_cfcd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cbaf {_fbga .EncodedByteAlign =_bdab ;};};if _dabcb ,_fcf :=GetNumberAsInt64 (_cfcd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_fcf ==nil {_fbga .EndOfLine =_dabcb > 0;}else {if _bfbc ,_gdbf :=GetBoolVal (_cfcd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gdbf {_fbga .EndOfLine =_bfbc ;};};if _abeb ,_efff :=GetNumberAsInt64 (_cfcd .Get ("\u0052\u006f\u0077\u0073"));
_efff ==nil {_fbga .Rows =int (_abeb );};_fbga .EndOfBlock =true ;if _daee ,_gfdf :=GetNumberAsInt64 (_cfcd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gfdf ==nil {_fbga .EndOfBlock =_daee > 0;}else {if _bdda ,_gbfg :=GetBoolVal (_cfcd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_gbfg {_fbga .EndOfBlock =_bdda ;};};if _dadda ,_agb :=GetNumberAsInt64 (_cfcd .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_agb !=nil {_fbga .DamagedRowsBeforeError =int (_dadda );
};_ad .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cfcd .String ());return _fbga ,nil ;};func _addg (_ebg int )cryptFilters {return cryptFilters {_cba :_agf .NewFilterV2 (_ebg )}};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gefd *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_dgfc :=data ;var _cffg error ;for _bafa :=len (_gefd ._bbee )-1;_bafa >=0;_bafa --{_dagfe :=_gefd ._bbee [_bafa ];_dgfc ,_cffg =_dagfe .EncodeBytes (_dgfc );if _cffg !=nil {return nil ,_cffg ;
};};return _dgfc ,nil ;};func (_cdde *PdfParser )checkPostEOFData ()error {const _edga ="\u0025\u0025\u0045O\u0046";_ ,_beeb :=_cdde ._eebaa .Seek (-int64 (len ([]byte (_edga )))-1,_gf .SeekEnd );if _beeb !=nil {return _beeb ;};_agfd :=make ([]byte ,len ([]byte (_edga ))+1);
_ ,_beeb =_cdde ._eebaa .Read (_agfd );if _beeb !=nil {if _beeb !=_gf .EOF {return _beeb ;};};if string (_agfd )==_edga ||string (_agfd )==_edga +"\u000a"{_cdde ._edac ._bdb =true ;};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_acde *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _egba ,_dceb :=GetNumberAsInt64 (params .Get ("\u004b"));_dceb ==nil {_acde .K =int (_egba );};if _cgde ,_ggdgg :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_ggdgg ==nil {_acde .Columns =int (_cgde );}else if _cgde ,_ggdgg =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_ggdgg ==nil {_acde .Columns =int (_cgde );};if _fgcee ,_ebbg :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_ebbg ==nil {_acde .BlackIs1 =_fgcee > 0;}else {if _bfbg ,_abed :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_abed {_acde .BlackIs1 =_bfbg ;}else {if _ceef ,_ffd :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_ffd {_gefe ,_gde :=_ceef .ToIntegerArray ();if _gde ==nil {_acde .BlackIs1 =_gefe [0]==1&&_gefe [1]==0;};};};};if _abfg ,_babd :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_babd ==nil {_acde .EncodedByteAlign =_abfg > 0;}else {if _adga ,_gbdb :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gbdb {_acde .EncodedByteAlign =_adga ;};};if _befcd ,_cfcb :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_cfcb ==nil {_acde .EndOfLine =_befcd > 0;}else {if _efbcf ,_dfecf :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dfecf {_acde .EndOfLine =_efbcf ;};};if _ebdg ,_ggdb :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_ggdb ==nil {_acde .Rows =int (_ebdg );}else if _ebdg ,_ggdb =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_ggdb ==nil {_acde .Rows =int (_ebdg );};if _dbb ,_dfaf :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_dfaf ==nil {_acde .EndOfBlock =_dbb > 0;}else {if _faab ,_aabe :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_aabe {_acde .EndOfBlock =_faab ;};};if _babe ,_fbbg :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_fbbg !=nil {_acde .DamagedRowsBeforeError =int (_babe );};};func (_fa *PdfParser )lookupObjectViaOS (_ccg int ,_gd int )(PdfObject ,error ){var _dd *_fcc .Reader ;var _cdaa objectStream ;var _fdd bool ;_cdaa ,_fdd =_fa ._eceb [_ccg ];if !_fdd {_fab ,_ea :=_fa .LookupByNumber (_ccg );
if _ea !=nil {_ad .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ccg );return nil ,_ea ;};_bb ,_aab :=_fab .(*PdfObjectStream );
if !_aab {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _fa ._bacc !=nil &&!_fa ._bacc .isDecrypted (_bb ){return nil ,_c .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_aabb :=_bb .PdfObjectDictionary ;_ad .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_aabb .String ());_dbge ,_aab :=_aabb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_aab {_ad .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _abb .ToLower (string (*_dbge ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_c .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_aab :=_aabb .Get ("\u004e").(*PdfObjectInteger );if !_aab {return nil ,_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_eg ,_aab :=_aabb .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_aab {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_ad .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_dbge ,*N );_da ,_ea :=DecodeStream (_bb );if _ea !=nil {return nil ,_ea ;
};_ad .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_da );_dc :=_fa .GetFileOffset ();defer func (){_fa .SetFileOffset (_dc )}();_dd =_fcc .NewReader (_da );_fa ._bgec =_ag .NewReader (_dd );_ad .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_dfd :=map[int ]int64 {};for _dga :=0;_dga < int (*N );_dga ++{_fa .skipSpaces ();_dgd ,_aabbe :=_fa .parseNumber ();if _aabbe !=nil {return nil ,_aabbe ;};_fb ,_cf :=_dgd .(*PdfObjectInteger );if !_cf {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_fa .skipSpaces ();_dgd ,_aabbe =_fa .parseNumber ();if _aabbe !=nil {return nil ,_aabbe ;};_ccc ,_cf :=_dgd .(*PdfObjectInteger );if !_cf {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_ad .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fb ,*_ccc );_dfd [int (*_fb )]=int64 (*_eg +*_ccc );};_cdaa =objectStream {N :int (*N ),_bec :_da ,_dbg :_dfd };_fa ._eceb [_ccg ]=_cdaa ;}else {_cga :=_fa .GetFileOffset ();
defer func (){_fa .SetFileOffset (_cga )}();_dd =_fcc .NewReader (_cdaa ._bec );_fa ._bgec =_ag .NewReader (_dd );};_dfc :=_cdaa ._dbg [_gd ];_ad .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_gd ,_dfc );
_dd .Seek (_dfc ,_gf .SeekStart );_fa ._bgec =_ag .NewReader (_dd );_fbe ,_ :=_fa ._bgec .Peek (100);_ad .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_fbe ));_cgf ,_eb :=_fa .parseObject ();if _eb !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_eb );
return nil ,_eb ;};if _cgf ==nil {return nil ,_c .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_gbf :=PdfIndirectObject {};_gbf .ObjectNumber =int64 (_gd );_gbf .PdfObject =_cgf ;_gbf ._bbcg =_fa ;
return &_gbf ,nil ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;Lazy bool ;TempFile string ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _dgeae :=obj .(type ){case *PdfObjectFloat :return float64 (*_dgeae ),nil ;case *PdfObjectInteger :return float64 (*_dgeae ),nil ;case *PdfObjectReference :_ebgeb :=TraceToDirectObject (obj );
return GetNumberAsFloat (_ebgeb );case *PdfIndirectObject :return GetNumberAsFloat (_dgeae .PdfObject );};return 0,ErrNotANumber ;};

// String returns a string representation of `name`.
func (_eecd *PdfObjectName )String ()string {return string (*_eecd )};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_abfe *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _edge _fcc .Buffer ;_agd :=_fcc .NewReader (encoded );var _gcfb _gf .ReadCloser ;if _abfe .EarlyChange ==1{_gcfb =_aa .NewReader (_agd ,_aa .MSB ,8);}else {_gcfb =_gb .NewReader (_agd ,_gb .MSB ,8);
};defer _gcfb .Close ();if _ ,_bcag :=_edge .ReadFrom (_gcfb );_bcag !=nil {if _bcag !=_gf .ErrUnexpectedEOF ||_edge .Len ()==0{return nil ,_bcag ;};_ad .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_bcag );
};return _edge .Bytes (),nil ;};

// Len returns the number of elements in the streams.
func (_cefgf *PdfObjectStreams )Len ()int {if _cefgf ==nil {return 0;};return len (_cefgf ._efedf );};

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_dacc *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _dacc ._dagae ==0{return nil ,_c .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _efgcb ,_fafgd :=_dacc ._bdaf [_dacc ];
_fafgd {return _efgcb ,nil ;};_eedca ,_bcga :=_dacc .GetPreviousRevisionReadSeeker ();if _bcga !=nil {return nil ,_bcga ;};_dfca ,_bcga :=NewParser (_eedca );_dfca ._bdaf =_dacc ._bdaf ;if _bcga !=nil {return nil ,_bcga ;};_dacc ._bdaf [_dacc ]=_dfca ;
return _dfca ,nil ;};var _cggc =_g .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func (_ggcg *PdfParser )readTextLine ()(string ,error ){var _cggb _fcc .Buffer ;
for {_bbdfd ,_fdbe :=_ggcg ._bgec .Peek (1);if _fdbe !=nil {_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fdbe .Error ());return _cggb .String (),_fdbe ;};if (_bbdfd [0]!='\r')&&(_bbdfd [0]!='\n'){_dbacc ,_ :=_ggcg ._bgec .ReadByte ();
_cggb .WriteByte (_dbacc );}else {break ;};};return _cggb .String (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cbad *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_ad .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_abbd ,_fcda :=NewEncoderFromStream (streamObj );if _fcda !=nil {_ad .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fcda );
return _fcda ;};if _aeee ,_acag :=_abbd .(*LZWEncoder );_acag {_aeee .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_ad .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_abbd );
_eagdf ,_fcda :=_abbd .EncodeBytes (streamObj .Stream );if _fcda !=nil {_ad .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fcda );return _fcda ;
};streamObj .Stream =_eagdf ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eagdf ))));return nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_bdg []XrefObject ;};func _cdfce (_dceg _gf .ReadSeeker ,_dbgg int64 )(*limitedReadSeeker ,error ){_ ,_bccc :=_dceg .Seek (0,_gf .SeekStart );if _bccc !=nil {return nil ,_bccc ;};return &limitedReadSeeker {_cgbd :_dceg ,_ddgb :_dbgg },nil ;
};var _cbf =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");func _bga (_bfada *PdfObjectStream ,_eddd *PdfObjectDictionary )(*FlateEncoder ,error ){_gadc :=NewFlateEncoder ();
_eef :=_bfada .PdfObjectDictionary ;if _eef ==nil {return _gadc ,nil ;};_gadc ._cbab =_ecaca (_eef );if _eddd ==nil {_bebg :=TraceToDirectObject (_eef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _efbc :=_bebg .(type ){case *PdfObjectArray :if _efbc .Len ()!=1{_ad .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_efbc .Len ());
return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ggbg ,_fdf :=GetDict (_efbc .Get (0));_fdf {_eddd =_ggbg ;};case *PdfObjectDictionary :_eddd =_efbc ;case *PdfObjectNull ,nil :default:_ad .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_bebg );
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _eddd ==nil {return _gadc ,nil ;};_ad .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_eddd .String ());
_accf :=_eddd .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _accf ==nil {_ad .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_gcbb ,_fac :=_accf .(*PdfObjectInteger );if !_fac {_ad .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_accf );
return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gadc .Predictor =int (*_gcbb );};_accf =_eddd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _accf !=nil {_acfg ,_dddfd :=_accf .(*PdfObjectInteger );if !_dddfd {_ad .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ba .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gadc .BitsPerComponent =int (*_acfg );};if _gadc .Predictor > 1{_gadc .Columns =1;_accf =_eddd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _accf !=nil {_gebc ,_egb :=_accf .(*PdfObjectInteger );if !_egb {return nil ,_ba .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gadc .Columns =int (*_gebc );
};_gadc .Colors =1;_accf =_eddd .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _accf !=nil {_dfcd ,_bgc :=_accf .(*PdfObjectInteger );if !_bgc {return nil ,_ba .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_gadc .Colors =int (*_dfcd );};};return _gadc ,nil ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_ffb *PdfCrypt )GetAccessPermissions ()_cda .Permissions {return _ffb ._ccf .P };

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_dbfe *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ad .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_dde :=_fcc .NewReader (encoded );_fgea ,_efec :=_dg .NewReader (_dde );if _efec !=nil {_ad .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_efec );_ad .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_efec ;};defer _fgea .Close ();var _fcad _fcc .Buffer ;_fcad .ReadFrom (_fgea );return _fcad .Bytes (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gddb *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gfdcc *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_bdccb :=MakeDict ();_bdccb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gfdcc .GetFilterName ()));_bge :=_gfdcc .MakeDecodeParams ();if _bge !=nil {_bdccb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bge );
};_bdccb .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_gfdcc .EarlyChange )));return _bdccb ;};const _fgcd =32<<(^uint (0)>>63);

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_aebee :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _aebee ==nil {return NewRawEncoder (),nil ;};if _ ,_fgeag :=_aebee .(*PdfObjectNull );
_fgeag {return NewRawEncoder (),nil ;};_gfbc ,_egeec :=_aebee .(*PdfObjectName );if !_egeec {_ddffb ,_gceaa :=_aebee .(*PdfObjectArray );if !_gceaa {return nil ,_ba .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _ddffb .Len ()==0{return NewRawEncoder (),nil ;};if _ddffb .Len ()!=1{_fcbd ,_gdaa :=_dabcf (streamObj );if _gdaa !=nil {_ad .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_gdaa );
return nil ,_gdaa ;};_ad .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_fcbd );return _fcbd ,nil ;};_aebee =_ddffb .Get (0);_gfbc ,_gceaa =_aebee .(*PdfObjectName );if !_gceaa {return nil ,_ba .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _gadce ,_dcgdb :=_ddfc .Load (_gfbc .String ());_dcgdb {return _gadce .(StreamEncoder ),nil ;};switch *_gfbc {case StreamEncodingFilterNameFlate :return _bga (streamObj ,nil );case StreamEncodingFilterNameLZW :return _ffbe (streamObj ,nil );case StreamEncodingFilterNameDCT :return _eeab (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _bgeb (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _ddcef (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _daf (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_ad .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_ba .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_gfbc );};func (_bgce *PdfParser )parsePdfVersion ()(int ,int ,error ){var _addgg int64 =20;
_eeag :=make ([]byte ,_addgg );_bgce ._eebaa .Seek (0,_gf .SeekStart );_bgce ._eebaa .Read (_eeag );var _fgged error ;var _eabdg ,_gead int ;if _abbbf :=_aacg .FindStringSubmatch (string (_eeag ));len (_abbbf )< 3{if _eabdg ,_gead ,_fgged =_bgce .seekPdfVersionTopDown ();
_fgged !=nil {_ad .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_fgged ;
};_bgce ._eebaa ,_fgged =_begf (_bgce ._eebaa ,_bgce .GetFileOffset ()-8);if _fgged !=nil {return 0,0,_fgged ;};}else {if _eabdg ,_fgged =_a .Atoi (_abbbf [1]);_fgged !=nil {return 0,0,_fgged ;};if _gead ,_fgged =_a .Atoi (_abbbf [2]);_fgged !=nil {return 0,0,_fgged ;
};_bgce .SetFileOffset (0);};_bgce ._bgec =_ag .NewReader (_bgce ._eebaa );_ad .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_eabdg ,_gead );return _eabdg ,_gead ,nil ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_aegd :=&DCTEncoder {};_aegd .ColorComponents =3;_aegd .BitsPerComponent =8;_aegd .Quality =DefaultJPEGQuality ;_aegd .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _aegd ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_cdee *PdfParser )GetObjectNums ()[]int {var _ffac []int ;for _ ,_bdbd :=range _cdee ._caeg .ObjectMap {_ffac =append (_ffac ,_bdbd .ObjectNumber );};_fe .Ints (_ffac );return _ffac ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _eaba _fcc .Buffer ;_eaba .Write ([]byte {0xFE,0xFF});_eaba .WriteString (_bdc .StringToUTF16 (s ));return &PdfObjectString {_ffff :_eaba .String (),_aggdd :true };};return &PdfObjectString {_ffff :string (_bdc .StringToPDFDocEncoding (s )),_aggdd :false };
};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_ddfc .Store (filterName ,customStreamEncoder );};func _cdgcg (_eddda uint ,_eafc ,_ggc float64 )float64 {return (_eafc +(float64 (_eddda )*(_ggc -_eafc )/255))*255;
};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_gaed *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ff .DecodeBytes (encoded ,_ee .Parameters {},_gaed .Globals );};func _bee (_fga *_agf .FilterDict ,_agg *PdfObjectDictionary )error {if _egf ,_fdb :=_agg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_fdb {if _dag :=string (*_egf );_dag !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_ad .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_dag );
};};_acd ,_aef :=_agg .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_aef {return _ba .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_fga .CFM =string (*_acd );if _efc ,_fdc :=_agg .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_fdc {_fga .AuthEvent =_cda .AuthEvent (*_efc );}else {_fga .AuthEvent =_cda .EventDocOpen ;};if _fabg ,_afd :=_agg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_afd {_fga .Length =int (*_fabg );};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dfcfg *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_fffce *PdfParser )Decrypt (password []byte )(bool ,error ){if _fffce ._bacc ==nil {return false ,_c .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_daddg ,_abbc :=_fffce ._bacc .authenticate (password );
if _abbc !=nil {return false ,_abbc ;};if !_daddg {_daddg ,_abbc =_fffce ._bacc .authenticate ([]byte (""));};return _daddg ,_abbc ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func (_baac *PdfObjectFloat )String ()string {return _ba .Sprintf ("\u0025\u0066",*_baac )};func (_bfcc *offsetReader )Read (p []byte )(_egbe int ,_gfdcd error ){return _bfcc ._gabb .Read (p )};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_bcdd *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gdc _bdf .Image ;if _bcdd .ColorComponents ==1&&_bcdd .BitsPerComponent ==8{_gdc =&_bdf .Gray {Rect :_bdf .Rect (0,0,_bcdd .Width ,_bcdd .Height ),Pix :data ,Stride :_fd .BytesPerLine (_bcdd .Width ,_bcdd .BitsPerComponent ,_bcdd .ColorComponents )};
}else {var _adb error ;_gdc ,_adb =_fd .NewImage (_bcdd .Width ,_bcdd .Height ,_bcdd .BitsPerComponent ,_bcdd .ColorComponents ,data ,nil ,nil );if _adb !=nil {return nil ,_adb ;};};_dbde :=_be .Options {};_dbde .Quality =_bcdd .Quality ;var _bfga _fcc .Buffer ;
if _gdcg :=_be .Encode (&_bfga ,_gdc ,&_dbde );_gdcg !=nil {return nil ,_gdcg ;};return _bfga .Bytes (),nil ;};func (_aeagc *PdfParser )repairLocateXref ()(int64 ,error ){_gbcf :=int64 (1000);_aeagc ._eebaa .Seek (-_gbcf ,_gf .SeekCurrent );_egef ,_dbdcc :=_aeagc ._eebaa .Seek (0,_gf .SeekCurrent );
if _dbdcc !=nil {return 0,_dbdcc ;};_afbd :=make ([]byte ,_gbcf );_aeagc ._eebaa .Read (_afbd );_bdfb :=_cacbc .FindAllStringIndex (string (_afbd ),-1);if len (_bdfb )< 1{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_c .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_efecdc :=int64 (_bdfb [len (_bdfb )-1][0]);_bfdg :=_egef +_efecdc ;return _bfdg ,nil ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_face *PdfObjectString )Bytes ()[]byte {return []byte (_face ._ffff )};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// GetFilterName returns the name of the encoding filter.
func (_bfc *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// ParserMetadata gets the pdf parser metadata.
func (_ceeg *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_ceeg ._afge {return ParserMetadata {},_ba .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _ceeg ._edac ,nil ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};const JB2ImageAutoThreshold =-1.0;

// GetXrefOffset returns the offset of the xref table.
func (_fefb *PdfParser )GetXrefOffset ()int64 {return _fefb ._gebae };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_fdcb *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fdcb .DecodeBytes (streamObj .Stream );};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_eged *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_cfcf :=_eged .GetFileOffset ();_ ,_bfdd :=_eged ._eebaa .Seek (offset ,_gf .SeekStart );if _bfdd !=nil {return nil ,_bfdd ;};_ecge :=make ([]byte ,len );_ ,_bfdd =_gf .ReadAtLeast (_eged ._eebaa ,_ecge ,int (len ));
if _bfdd !=nil {return nil ,_bfdd ;};_eged .SetFileOffset (_cfcf );return _ecge ,nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_decbd *PdfIndirectObject ,_bgbec bool ){obj =ResolveReference (obj );_decbd ,_bgbec =obj .(*PdfIndirectObject );return _decbd ,_bgbec ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_cfef :=MultiEncoder {};_cfef ._bbee =[]StreamEncoder {};return &_cfef ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fbde *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fbde .isDecrypted (obj ){return nil ;};switch _gae :=obj .(type ){case *PdfIndirectObject :_fbde ._edda [_gae ]=true ;_ad .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_gae .ObjectNumber ,_gae .GenerationNumber );
_acfe :=_gae .ObjectNumber ;_dfdd :=_gae .GenerationNumber ;_bcfd :=_fbde .Decrypt (_gae .PdfObject ,_acfe ,_dfdd );if _bcfd !=nil {return _bcfd ;};return nil ;case *PdfObjectStream :_fbde ._edda [_gae ]=true ;_ecd :=_gae .PdfObjectDictionary ;if _fbde ._ccf .R !=5{if _age ,_beg :=_ecd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_beg &&*_age =="\u0058\u0052\u0065\u0066"{return nil ;};};_dddf :=_gae .ObjectNumber ;_egc :=_gae .GenerationNumber ;_ad .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dddf ,_egc );
_cabg :=_cba ;if _fbde ._gcc .V >=4{_cabg =_fbde ._ade ;_ad .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fbde ._ade );if _geed ,_fada :=_ecd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_fada {if _ebgf ,_ffbf :=GetName (_geed .Get (0));_ffbf {if *_ebgf =="\u0043\u0072\u0079p\u0074"{_cabg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cfd ,_fgff :=_ecd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_fgff {if _dbcf ,_ddbd :=_cfd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_ddbd {if _ ,_abfd :=_fbde ._gca [string (*_dbcf )];_abfd {_ad .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_dbcf );
_cabg =string (*_dbcf );};};};};};};_ad .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cabg );if _cabg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bbgd :=_fbde .Decrypt (_ecd ,_dddf ,_egc );
if _bbgd !=nil {return _bbgd ;};_addgd ,_bbgd :=_fbde .makeKey (_cabg ,uint32 (_dddf ),uint32 (_egc ),_fbde ._fea );if _bbgd !=nil {return _bbgd ;};_gae .Stream ,_bbgd =_fbde .decryptBytes (_gae .Stream ,_cabg ,_addgd );if _bbgd !=nil {return _bbgd ;};
_ecd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gae .Stream ))));return nil ;case *PdfObjectString :_ad .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_dcf :=_cba ;if _fbde ._gcc .V >=4{_ad .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fbde ._dgea );
if _fbde ._dgea =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_dcf =_fbde ._dgea ;};_ggdf ,_eca :=_fbde .makeKey (_dcf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fbde ._fea );if _eca !=nil {return _eca ;};_acc :=_gae .Str ();_efce :=make ([]byte ,len (_acc ));
for _cbga :=0;_cbga < len (_acc );_cbga ++{_efce [_cbga ]=_acc [_cbga ];};if len (_efce )> 0{_ad .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_efce ,_efce );
_efce ,_eca =_fbde .decryptBytes (_efce ,_dcf ,_ggdf );if _eca !=nil {return _eca ;};};_gae ._ffff =string (_efce );return nil ;case *PdfObjectArray :for _ ,_ceea :=range _gae .Elements (){_fgd :=_fbde .Decrypt (_ceea ,parentObjNum ,parentGenNum );if _fgd !=nil {return _fgd ;
};};return nil ;case *PdfObjectDictionary :_ccd :=false ;if _gcce :=_gae .Get ("\u0054\u0079\u0070\u0065");_gcce !=nil {_fcge ,_bgb :=_gcce .(*PdfObjectName );if _bgb &&*_fcge =="\u0053\u0069\u0067"{_ccd =true ;};};for _ ,_abbe :=range _gae .Keys (){_geec :=_gae .Get (_abbe );
if _ccd &&string (_abbe )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_abbe )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_abbe )!="\u0050\u0072\u0065\u0076"&&string (_abbe )!="\u004c\u0061\u0073\u0074"{_fdeb :=_fbde .Decrypt (_geec ,parentObjNum ,parentGenNum );
if _fdeb !=nil {return _fdeb ;};};};return nil ;};return nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_gdba *PdfObjectInteger ,_dcdfb bool ){_gdba ,_dcdfb =TraceToDirectObject (obj ).(*PdfObjectInteger );return _gdba ,_dcdfb ;};

// HeaderCommentBytes gets the header comment bytes.
func (_dbe ParserMetadata )HeaderCommentBytes ()[4]byte {return _dbe ._ecc };func (_fba *PdfCrypt )makeKey (_gcb string ,_aaadg ,_ddaa uint32 ,_ceg []byte )([]byte ,error ){_dfa ,_cbaa :=_fba ._gca [_gcb ];if !_cbaa {return nil ,_ba .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_gcb );
};return _dfa .MakeKey (_aaadg ,_ddaa ,_ceg );};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_gfdcb *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _edcb _fcc .Buffer ;for _ ,_fedf :=range data {_edcb .WriteString (_ba .Sprintf ("\u0025\u002e\u0032X\u0020",_fedf ));};_edcb .WriteByte ('>');return _edcb .Bytes (),nil ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_eegd ParserMetadata )HasOddLengthHexStrings ()bool {return _eegd ._dee };

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ad .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_fbedc ,_affc :=NewEncoderFromStream (streamObj );if _affc !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_affc );
return nil ,_affc ;};_ad .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_fbedc );_gfee ,_affc :=_fbedc .DecodeStream (streamObj );if _affc !=nil {_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_affc );
return nil ,_affc ;};return _gfee ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;func (_becf *PdfParser )parseObject ()(PdfObject ,error ){_ad .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_becf .skipSpaces ();for {_agegb ,_ebca :=_becf ._bgec .Peek (2);
if _ebca !=nil {if _ebca !=_gf .EOF ||len (_agegb )==0{return nil ,_ebca ;};if len (_agegb )==1{_agegb =append (_agegb ,' ');};};_ad .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_agegb ));if _agegb [0]=='/'{_ebdgb ,_fdgc :=_becf .parseName ();
_ad .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_ebdgb );return &_ebdgb ,_fdgc ;}else if _agegb [0]=='('{_ad .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_cdgd ,_gag :=_becf .parseString ();return _cdgd ,_gag ;
}else if _agegb [0]=='['{_ad .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_aacd ,_bbad :=_becf .parseArray ();return _aacd ,_bbad ;}else if (_agegb [0]=='<')&&(_agegb [1]=='<'){_ad .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_ggca ,_daff :=_becf .ParseDict ();return _ggca ,_daff ;}else if _agegb [0]=='<'{_ad .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_eggf ,_cadea :=_becf .parseHexString ();return _eggf ,_cadea ;}else if _agegb [0]=='%'{_becf .readComment ();
_becf .skipSpaces ();}else {_ad .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_agegb ,_ =_becf ._bgec .Peek (15);_ega :=string (_agegb );_ad .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_ega );
if (len (_ega )> 3)&&(_ega [:4]=="\u006e\u0075\u006c\u006c"){_eeaa ,_fafg :=_becf .parseNull ();return &_eeaa ,_fafg ;}else if (len (_ega )> 4)&&(_ega [:5]=="\u0066\u0061\u006cs\u0065"){_ggcf ,_acdg :=_becf .parseBool ();return &_ggcf ,_acdg ;}else if (len (_ega )> 3)&&(_ega [:4]=="\u0074\u0072\u0075\u0065"){_deeae ,_fdbb :=_becf .parseBool ();
return &_deeae ,_fdbb ;};_gffc :=_caec .FindStringSubmatch (_ega );if len (_gffc )> 1{_agegb ,_ =_becf ._bgec .ReadBytes ('R');_ad .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_agegb [:]));_fdaf ,_fade :=_ddfg (string (_agegb ));
_fdaf ._bbcg =_becf ;return &_fdaf ,_fade ;};_fgbg :=_aede .FindStringSubmatch (_ega );if len (_fgbg )> 1{_ad .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_ggcad ,_fecfe :=_becf .parseNumber ();return _ggcad ,_fecfe ;};_fgbg =_cggc .FindStringSubmatch (_ega );
if len (_fgbg )> 1{_ad .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_ad .Log .Trace ("\u0025\u0020\u0073",_fgbg );_daaag ,_aabc :=_becf .parseNumber ();return _daaag ,_aabc ;
};_ad .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_ega );return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};

// GetRevisionNumber returns the current version of the Pdf document.
func (_cace *PdfParser )GetRevisionNumber ()int {return _cace ._dagae };var _ddfc _b .Map ;func (_bfea *PdfParser )inspect ()(map[string ]int ,error ){_ad .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_ad .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bacf :=map[string ]int {};_baaf :=0;_egdef :=0;var _ceeca []int ;for _eefa :=range _bfea ._caeg .ObjectMap {_ceeca =append (_ceeca ,_eefa );};_fe .Ints (_ceeca );_ebgb :=0;
for _ ,_dggg :=range _ceeca {_eaaac :=_bfea ._caeg .ObjectMap [_dggg ];if _eaaac .ObjectNumber ==0{continue ;};_baaf ++;_ad .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_ad .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_eaaac .ObjectNumber );
_cabcb ,_cfcdc :=_bfea .LookupByNumber (_eaaac .ObjectNumber );if _cfcdc !=nil {_ad .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_eaaac .ObjectNumber ,_cfcdc );
_egdef ++;continue ;};_ad .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_cabcb );_eagcf ,_gdab :=_cabcb .(*PdfIndirectObject );if _gdab {_ad .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_eaaac .ObjectNumber ,_eagcf );
_abfec ,_fagdb :=_eagcf .PdfObject .(*PdfObjectDictionary );if _fagdb {if _gddagf ,_ecbc :=_abfec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ecbc {_fafga :=string (*_gddagf );_ad .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_fafga );
_ ,_dcebf :=_bacf [_fafga ];if _dcebf {_bacf [_fafga ]++;}else {_bacf [_fafga ]=1;};}else if _aacgd ,_cgfe :=_abfec .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_cgfe {_gfdd :=string (*_aacgd );_ad .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_gfdd );
_ ,_cebge :=_bacf [_gfdd ];if _cebge {_bacf [_gfdd ]++;}else {_bacf [_gfdd ]=1;};};if _ceffe ,_gadf :=_abfec .Get ("\u0053").(*PdfObjectName );_gadf &&*_ceffe =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_fcfca :=_bacf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _fcfca {_bacf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_bacf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _dgbg ,_beeba :=_cabcb .(*PdfObjectStream );_beeba {if _acgcea ,_cdgcd :=_dgbg .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cdgcd {_ad .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_acgcea );_ggeed :=string (*_acgcea );_bacf [_ggeed ]++;};}else {_abaff ,_cfgbe :=_cabcb .(*PdfObjectDictionary );
if _cfgbe {_addc ,_fdfe :=_abaff .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fdfe {_efdfc :=string (*_addc );_ad .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_efdfc );_bacf [_efdfc ]++;};};
_ad .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_eaaac .ObjectNumber ,_cabcb );};_ebgb ++;};_ad .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");
_ad .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_ad .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_baaf );_ad .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_egdef );
for _cdcga ,_dfbeb :=range _bacf {_ad .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_cdcga ,_dfbeb );};_ad .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_bfea ._caeg .ObjectMap )< 1{_ad .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_ba .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cgeba ,_fadab :=_bacf ["\u0046\u006f\u006e\u0074"];
if !_fadab ||_cgeba < 2{_ad .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_ad .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _bacf ,nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_cdfcb *PdfParser )GetTrailer ()*PdfObjectDictionary {return _cdfcb ._cdcd };

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_gcfbd *PdfParser )GetPreviousRevisionReadSeeker ()(_gf .ReadSeeker ,error ){if _bdbae :=_gcfbd .seekToEOFMarker (_gcfbd ._edaa -_ecabb );_bdbae !=nil {return nil ,_bdbae ;};_cdce ,_gbgc :=_gcfbd ._eebaa .Seek (0,_gf .SeekCurrent );if _gbgc !=nil {return nil ,_gbgc ;
};_cdce +=_ecabb ;return _cdfce (_gcfbd ._eebaa ,_cdce );};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_bddfe []float64 ,_ddge error ){for _ ,_gceag :=range objects {_dfgcf ,_fbge :=GetNumberAsFloat (_gceag );if _fbge !=nil {return nil ,_fbge ;};_bddfe =append (_bddfe ,_dfgcf );};return _bddfe ,nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_dgfd *JBIG2Encoder )Encode ()(_fbdc []byte ,_deea error ){const _gafd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _dgfd ._afad ==nil {return nil ,_fgb .Errorf (_gafd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_dgfd ._afad .FullHeaders =_dgfd .DefaultPageSettings .FileMode ;_fbdc ,_deea =_dgfd ._afad .Encode ();if _deea !=nil {return nil ,_fgb .Wrap (_deea ,_gafd ,"");};return _fbdc ,nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_fadc Version ;_eebaa _gf .ReadSeeker ;_bgec *_ag .Reader ;_edaa int64 ;_caeg XrefTable ;_gebae int64 ;_cecc *xrefType ;_eceb objectStreams ;_cdcd *PdfObjectDictionary ;_bacc *PdfCrypt ;_caae *PdfIndirectObject ;_aafd bool ;ObjCache objectCache ;
_abafa map[int ]bool ;_eedbc map[int64 ]bool ;_edac ParserMetadata ;_afge bool ;_afed []int64 ;_dagae int ;_fcba bool ;_edbde int64 ;_bdaf map[*PdfParser ]*PdfParser ;_afbb []*PdfParser ;};var _bgdg =_g .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");


// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// WriteString outputs the object as it is to be written to file.
func (_bcfca *PdfObjectArray )WriteString ()string {var _baed _abb .Builder ;_baed .WriteString ("\u005b");for _dgcc ,_dddbd :=range _bcfca .Elements (){_baed .WriteString (_dddbd .WriteString ());if _dgcc < (_bcfca .Len ()-1){_baed .WriteString ("\u0020");
};};_baed .WriteString ("\u005d");return _baed .String ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cec *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_ebga :=MakeDict ();_ebga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cec .GetFilterName ()));_adec :=_cec .MakeDecodeParams ();if _adec !=nil {_ebga .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_adec );
};return _ebga ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ddce *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_acbd *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aaab :=_fcc .NewReader (encoded );_gffb ,_cbgd :=_be .Decode (_aaab );if _cbgd !=nil {_ad .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cbgd );
return nil ,_cbgd ;};_abfed :=_gffb .Bounds ();var _gbde =make ([]byte ,_abfed .Dx ()*_abfed .Dy ()*_acbd .ColorComponents *_acbd .BitsPerComponent /8);_fdg :=0;switch _acbd .ColorComponents {case 1:_ecad :=[]float64 {_acbd .Decode [0],_acbd .Decode [1]};
for _daac :=_abfed .Min .Y ;_daac < _abfed .Max .Y ;_daac ++{for _gfdg :=_abfed .Min .X ;_gfdg < _abfed .Max .X ;_gfdg ++{_bffd :=_gffb .At (_gfdg ,_daac );if _acbd .BitsPerComponent ==16{_dfbf ,_fbf :=_bffd .(_gc .Gray16 );if !_fbf {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_baa :=_cdgcg (uint (_dfbf .Y >>8),_ecad [0],_ecad [1]);_fbed :=_cdgcg (uint (_dfbf .Y ),_ecad [0],_ecad [1]);_gbde [_fdg ]=byte (_baa );_fdg ++;_gbde [_fdg ]=byte (_fbed );_fdg ++;}else {_ccdd ,_ecgb :=_bffd .(_gc .Gray );if !_ecgb {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gbde [_fdg ]=byte (_cdgcg (uint (_ccdd .Y ),_ecad [0],_ecad [1]));_fdg ++;};};};case 3:_dfec :=[]float64 {_acbd .Decode [0],_acbd .Decode [1]};_bbdf :=[]float64 {_acbd .Decode [2],_acbd .Decode [3]};_eafe :=[]float64 {_acbd .Decode [4],_acbd .Decode [5]};
for _bbdg :=_abfed .Min .Y ;_bbdg < _abfed .Max .Y ;_bbdg ++{for _cddb :=_abfed .Min .X ;_cddb < _abfed .Max .X ;_cddb ++{_bcec :=_gffb .At (_cddb ,_bbdg );if _acbd .BitsPerComponent ==16{_bfgd ,_egff :=_bcec .(_gc .RGBA64 );if !_egff {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_bcg :=_cdgcg (uint (_bfgd .R >>8),_dfec [0],_dfec [1]);_feee :=_cdgcg (uint (_bfgd .R ),_dfec [0],_dfec [1]);_ccdb :=_cdgcg (uint (_bfgd .G >>8),_bbdf [0],_bbdf [1]);_afgf :=_cdgcg (uint (_bfgd .G ),_bbdf [0],_bbdf [1]);_agfb :=_cdgcg (uint (_bfgd .B >>8),_eafe [0],_eafe [1]);
_daed :=_cdgcg (uint (_bfgd .B ),_eafe [0],_eafe [1]);_gbde [_fdg ]=byte (_bcg );_fdg ++;_gbde [_fdg ]=byte (_feee );_fdg ++;_gbde [_fdg ]=byte (_ccdb );_fdg ++;_gbde [_fdg ]=byte (_afgf );_fdg ++;_gbde [_fdg ]=byte (_agfb );_fdg ++;_gbde [_fdg ]=byte (_daed );
_fdg ++;}else {_gfa ,_egbf :=_bcec .(_gc .RGBA );if _egbf {_fbad :=_cdgcg (uint (_gfa .R ),_dfec [0],_dfec [1]);_aaabg :=_cdgcg (uint (_gfa .G ),_bbdf [0],_bbdf [1]);_abdd :=_cdgcg (uint (_gfa .B ),_eafe [0],_eafe [1]);_gbde [_fdg ]=byte (_fbad );_fdg ++;
_gbde [_fdg ]=byte (_aaabg );_fdg ++;_gbde [_fdg ]=byte (_abdd );_fdg ++;}else {_fda ,_dcbd :=_bcec .(_gc .YCbCr );if !_dcbd {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_afdf ,_gaae ,_eddf ,_ :=_fda .RGBA ();
_ebede :=_cdgcg (uint (_afdf >>8),_dfec [0],_dfec [1]);_gadb :=_cdgcg (uint (_gaae >>8),_bbdf [0],_bbdf [1]);_fbba :=_cdgcg (uint (_eddf >>8),_eafe [0],_eafe [1]);_gbde [_fdg ]=byte (_ebede );_fdg ++;_gbde [_fdg ]=byte (_gadb );_fdg ++;_gbde [_fdg ]=byte (_fbba );
_fdg ++;};};};};case 4:_cfg :=[]float64 {_acbd .Decode [0],_acbd .Decode [1]};_aecc :=[]float64 {_acbd .Decode [2],_acbd .Decode [3]};_ecbg :=[]float64 {_acbd .Decode [4],_acbd .Decode [5]};_ebc :=[]float64 {_acbd .Decode [6],_acbd .Decode [7]};for _ege :=_abfed .Min .Y ;
_ege < _abfed .Max .Y ;_ege ++{for _dcgd :=_abfed .Min .X ;_dcgd < _abfed .Max .X ;_dcgd ++{_gga :=_gffb .At (_dcgd ,_ege );_bfeg ,_cdf :=_gga .(_gc .CMYK );if !_cdf {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_edbdb :=255-_cdgcg (uint (_bfeg .C ),_cfg [0],_cfg [1]);_afffg :=255-_cdgcg (uint (_bfeg .M ),_aecc [0],_aecc [1]);_dcc :=255-_cdgcg (uint (_bfeg .Y ),_ecbg [0],_ecbg [1]);_ceegd :=255-_cdgcg (uint (_bfeg .K ),_ebc [0],_ebc [1]);_gbde [_fdg ]=byte (_edbdb );
_fdg ++;_gbde [_fdg ]=byte (_afffg );_fdg ++;_gbde [_fdg ]=byte (_dcc );_fdg ++;_gbde [_fdg ]=byte (_ceegd );_fdg ++;};};};return _gbde ,nil ;};func (_fbgad *PdfParser )getNumbersOfUpdatedObjects (_eddad *PdfParser )([]int ,error ){if _eddad ==nil {return nil ,_c .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_fegc :=_eddad ._edaa ;_gfab :=make ([]int ,0);_fabb :=make (map[int ]interface{});_fefc :=make (map[int ]int64 );for _gbgf ,_bcagb :=range _fbgad ._caeg .ObjectMap {if _bcagb .Offset ==0{if _bcagb .OsObjNumber !=0{if _abga ,_dccc :=_fbgad ._caeg .ObjectMap [_bcagb .OsObjNumber ];
_dccc {_fabb [_bcagb .OsObjNumber ]=struct{}{};_fefc [_gbgf ]=_abga .Offset ;}else {return nil ,_c .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_fefc [_gbgf ]=_bcagb .Offset ;};};for _ebeda ,_bdff :=range _fefc {if _ ,_fcdcd :=_fabb [_ebeda ];
_fcdcd {continue ;};if _bdff > _fegc {_gfab =append (_gfab ,_ebeda );};};return _gfab ,nil ;};

// String returns a string describing `stream`.
func (_fdba *PdfObjectStream )String ()string {return _ba .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_fdba .ObjectNumber ,_fdba .PdfObjectDictionary );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fed *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_ccgdb *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ccgdb ._bbgg ){return _c .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ccgdb ._bbgg [i ]=obj ;return nil ;};