//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_fg "bufio";_c "bytes";_b "compress/lzw";_ab "compress/zlib";_ge "crypto/md5";_f "crypto/rand";_cf "encoding/hex";_be "errors";_cg "fmt";_cbf "github.com/unidoc/unipdf/v4/common";_ff "github.com/unidoc/unipdf/v4/core/security";_dfa "github.com/unidoc/unipdf/v4/core/security/crypt";
_geg "github.com/unidoc/unipdf/v4/internal/ccittfax";_cgg "github.com/unidoc/unipdf/v4/internal/imageutil";_cbd "github.com/unidoc/unipdf/v4/internal/jbig2";_cfb "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_fbe "github.com/unidoc/unipdf/v4/internal/jbig2/decoder";
_bc "github.com/unidoc/unipdf/v4/internal/jbig2/document";_de "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_bee "github.com/unidoc/unipdf/v4/internal/precision";_gb "github.com/unidoc/unipdf/v4/internal/strutils";_cb "golang.org/x/image/tiff/lzw";
_fb "golang.org/x/text/unicode/bidi";_gf "golang.org/x/xerrors";_ac "image";_aa "image/color";_gc "image/jpeg";_eb "io";_ee "os";_a "reflect";_df "regexp";_d "sort";_g "strconv";_dg "strings";_cge "sync";_ea "time";_cd "unicode";);

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ffbf *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _ffbf .Predictor !=1&&_ffbf .Predictor !=11{_cbf .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _ffbf .Predictor ==11{_bcde :=_ffbf .Columns ;_beab :=len (data )/_bcde ;if len (data )%_bcde !=0{_cbf .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_be .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_ggac :=_c .NewBuffer (nil );_fgcg :=make ([]byte ,_bcde );for _fdea :=0;_fdea < _beab ;_fdea ++{_ggaa :=data [_bcde *_fdea :_bcde *(_fdea +1)];
_fgcg [0]=_ggaa [0];for _bfce :=1;_bfce < _bcde ;_bfce ++{_fgcg [_bfce ]=byte (int (_ggaa [_bfce ]-_ggaa [_bfce -1])%256);};_ggac .WriteByte (1);_ggac .Write (_fgcg );};data =_ggac .Bytes ();};var _acf _c .Buffer ;_bbbe :=_ab .NewWriter (&_acf );_bbbe .Write (data );
_bbbe .Close ();return _acf .Bytes (),nil ;};const JB2ImageAutoThreshold =-1.0;

// Buffered returns the number of bytes currently buffered.
func (_cfab *bufferedReadSeeker )Buffered ()int {return _cfab ._acg .Buffered ()};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_dbaae *FlateEncoder )SetPredictor (columns int ){_dbaae .Predictor =11;_dbaae .Columns =columns ;};var _aagc =_be .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");func (_aaa *PdfCrypt )saveCryptFilters (_gee *PdfObjectDictionary )error {if _aaa ._eegf .V < 4{return _be .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_abggb :=MakeDict ();_gee .Set ("\u0043\u0046",_abggb );for _gcfb ,_dfg :=range _aaa ._aab {if _gcfb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_cad :=_gfd (_dfg ,"");_abggb .Set (PdfObjectName (_gcfb ),_cad );};_gee .Set ("\u0053\u0074\u0072\u0046",MakeName (_aaa ._eda ));
_gee .Set ("\u0053\u0074\u006d\u0046",MakeName (_aaa ._ebbf ));return nil ;};func _agc (_gdb *PdfObjectStream ,_agde *PdfObjectDictionary )(*FlateEncoder ,error ){_bdfg :=NewFlateEncoder ();_fbc :=_gdb .PdfObjectDictionary ;if _fbc ==nil {return _bdfg ,nil ;
};_bdfg ._ccgd =_fcac (_fbc );if _agde ==nil {_cdcae :=TraceToDirectObject (_fbc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _gbcf :=_cdcae .(type ){case *PdfObjectArray :if _gbcf .Len ()!=1{_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_gbcf .Len ());
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cdaa ,_bccg :=GetDict (_gbcf .Get (0));_bccg {_agde =_cdaa ;};case *PdfObjectDictionary :_agde =_gbcf ;case *PdfObjectNull ,nil :default:_cbf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_cdcae );
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _agde ==nil {return _bdfg ,nil ;};_cbf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_agde .String ());
_egg :=_agde .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _egg ==nil {_cbf .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_bfae ,_fda :=_egg .(*PdfObjectInteger );if !_fda {_cbf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_egg );
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bdfg .Predictor =int (*_bfae );};_egg =_agde .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _egg !=nil {_cffc ,_aecf :=_egg .(*PdfObjectInteger );if !_aecf {_cbf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_cg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bdfg .BitsPerComponent =int (*_cffc );if _bdfg .BitsPerComponent !=_bdfg ._ccgd .BitsPerComponent {_cbf .Log .Debug ("\u0057A\u0052\u004e\u0049\u004eG\u003a \u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006di\u0073\u006d\u0061\u0074\u0063\u0068\u0020\u0077\u0069\u0074\u0068 \u0069\u006d\u0061\u0067\u0065\u0020\u0028\u0025\u0064\u002f%\u0064\u0029\u002c\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020i\u006da\u0067\u0065",_bdfg .BitsPerComponent ,_bdfg ._ccgd .BitsPerComponent );
_bdfg .BitsPerComponent =_bdfg ._ccgd .BitsPerComponent ;};};if _bdfg .Predictor > 1{_bdfg .Columns =1;_egg =_agde .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _egg !=nil {_cedg ,_edcd :=_egg .(*PdfObjectInteger );if !_edcd {return nil ,_cg .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_bdfg .Columns =int (*_cedg );};_bdfg .Colors =1;_egg =_agde .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _egg !=nil {_cfgg ,_ebf :=_egg .(*PdfObjectInteger );if !_ebf {return nil ,_cg .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_bdfg .Colors =int (*_cfgg );};};return _bdfg ,nil ;};func (_bdeg *offsetReader )Read (p []byte )(_bggf int ,_fcgb error ){return _bdeg ._ffba .Read (p )};func (_dgbdd *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ccde :=_dgbdd ._cafb .Discard (4);
return PdfObjectNull {},_ccde ;};func (_eacde *PdfObjectInteger )String ()string {return _cg .Sprintf ("\u0025\u0064",*_eacde )};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_dcfc *PdfParser )IsEncrypted ()(bool ,error ){if _dcfc ._dfabf !=nil {return true ,nil ;}else if _dcfc ._eaaf ==nil {return false ,nil ;};_cbf .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_deaa :=_dcfc ._eaaf .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _deaa ==nil {return false ,nil ;};_cbf .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_gdced *PdfObjectDictionary ;);switch _cdbee :=_deaa .(type ){case *PdfObjectDictionary :_gdced =_cdbee ;
case *PdfObjectReference :_cbf .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_cdbee );_cccc ,_egec :=_dcfc .LookupByReference (*_cdbee );_cbf .Log .Trace ("\u0031\u003a\u0020%\u0071",_cccc );
if _egec !=nil {return false ,_egec ;};_cdffe ,_abegc :=_cccc .(*PdfIndirectObject );if !_abegc {_cbf .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_be .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_edecg ,_abegc :=_cdffe .PdfObject .(*PdfObjectDictionary );_dcfc ._facb =_cdffe ;_cbf .Log .Trace ("\u0032\u003a\u0020%\u0071",_edecg );
if !_abegc {return false ,_be .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_gdced =_edecg ;
case *PdfObjectNull :_cbf .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_cg .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_cdbee );};_decfd ,_fbfb :=PdfCryptNewDecrypt (_dcfc ,_gdced ,_dcfc ._eaaf );if _fbfb !=nil {return false ,_fbfb ;
};for _ ,_eafd :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_gfacc :=_dcfc ._eaaf .Get (PdfObjectName (_eafd ));if _gfacc ==nil {continue ;};switch _gggcg :=_gfacc .(type ){case *PdfObjectReference :_decfd ._ede [int (_gggcg .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_decfd ._bedd [_gggcg ]=true ;_decfd ._ede [int (_gggcg .ObjectNumber )]=struct{}{};};};_dcfc ._dfabf =_decfd ;_cbf .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_decfd );
return true ,nil ;};

// String returns a descriptive information string about the encryption method used.
func (_cbda *PdfCrypt )String ()string {if _cbda ==nil {return "";};_aebe :=_cbda ._eegf .Filter +"\u0020\u002d\u0020";if _cbda ._eegf .V ==0{_aebe +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _cbda ._eegf .V ==1{_aebe +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _cbda ._eegf .V ==2{_aebe +=_cg .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_cbda ._eegf .Length );}else if _cbda ._eegf .V ==3{_aebe +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _cbda ._eegf .V >=4{_aebe +=_cg .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_cbda ._ebbf ,_cbda ._eda );
_aebe +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _dgag ,_dab :=range _cbda ._aab {_aebe +=_cg .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_dgag ,_dab .Name (),_dab .KeyLength ());
};};_cab :=_cbda .GetAccessPermissions ();_aebe +=_cg .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_cab );return _aebe ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _adad (obj ,0)};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_fecd ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _fecd ._baf };

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_ccae ParserMetadata )HasEOLAfterHeader ()bool {return _ccae ._fce };

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_adbf []PdfObject ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_egdfd *PdfParser )CheckAccessRights (password []byte )(bool ,_ff .Permissions ,error ){if _egdfd ._dfabf ==nil {return true ,_ff .PermOwner ,nil ;};return _egdfd ._dfabf .checkAccessRights (password );};func (_cba *PdfParser )lookupObjectViaOS (_dde int ,_afgc int )(PdfObject ,error ){var _ebgd *_c .Reader ;
var _bea objectStream ;var _beac bool ;_bea ,_beac =_cba ._cacf [_dde ];if !_beac {_ce ,_dga :=_cba .LookupByNumber (_dde );if _dga !=nil {_cbf .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_dde );
return nil ,_dga ;};_gcc ,_efe :=_ce .(*PdfObjectStream );if !_efe {return nil ,_be .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _cba ._dfabf !=nil &&!_cba ._dfabf .isDecrypted (_gcc ){return nil ,_be .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_bfd :=_gcc .PdfObjectDictionary ;_cbf .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_bfd .String ());_gcf ,_efe :=_bfd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_efe {_cbf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_be .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _dg .ToLower (string (*_gcf ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_be .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_efe :=_bfd .Get ("\u004e").(*PdfObjectInteger );if !_efe {return nil ,_be .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_cdb ,_efe :=_bfd .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_efe {return nil ,_be .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_cbf .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gcf ,*N );_ead ,_dga :=DecodeStream (_gcc );if _dga !=nil {return nil ,_dga ;
};_cbf .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ead );_agf :=_cba .GetFileOffset ();defer func (){_cba .SetFileOffset (_agf )}();_ebgd =_c .NewReader (_ead );_cba ._cafb ._acg =_fg .NewReader (_ebgd );_cbf .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_efee :=map[int ]int64 {};for _adc :=0;_adc < int (*N );_adc ++{_cba .skipSpaces ();_acd ,_bcac :=_cba .parseNumber ();if _bcac !=nil {return nil ,_bcac ;};_eeg ,_dbd :=_acd .(*PdfObjectInteger );if !_dbd {return nil ,_be .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_cba .skipSpaces ();_acd ,_bcac =_cba .parseNumber ();if _bcac !=nil {return nil ,_bcac ;};_dcb ,_dbd :=_acd .(*PdfObjectInteger );if !_dbd {return nil ,_be .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_cbf .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_eeg ,*_dcb );_efee [int (*_eeg )]=int64 (*_cdb +*_dcb );};_bea =objectStream {N :int (*N ),_ba :_ead ,_aec :_efee };_cba ._cacf [_dde ]=_bea ;
}else {_gd :=_cba .GetFileOffset ();defer func (){_cba .SetFileOffset (_gd )}();_ebgd =_c .NewReader (_bea ._ba );_cba ._cafb ._acg =_fg .NewReader (_ebgd );};_eee :=_bea ._aec [_afgc ];_cbf .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_afgc ,_eee );
_ebgd .Seek (_eee ,_eb .SeekStart );_cba ._cafb ._acg =_fg .NewReader (_ebgd );_cgd ,_ :=_cba ._cafb ._acg .Peek (100);_cbf .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_cgd ));_def ,_dec :=_cba .parseObject ();
if _dec !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_dec );return nil ,_dec ;};if _def ==nil {return nil ,_be .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");
};_cbg :=PdfIndirectObject {};_cbg .ObjectNumber =int64 (_afgc );_cbg .PdfObject =_def ;_cbg ._ffbgd =_cba ;return &_cbg ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_dfab *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _cfed _cgg .Gray ;switch len (data ){case _dfab .Rows *_dfab .Columns :_egca ,_ggga :=_cgg .NewImage (_dfab .Columns ,_dfab .Rows ,8,1,data ,nil ,nil );if _ggga !=nil {return nil ,_ggga ;
};_cfed =_egca .(_cgg .Gray );case (_dfab .Columns *_dfab .Rows )+7>>3:_afcc ,_deeg :=_cgg .NewImage (_dfab .Columns ,_dfab .Rows ,1,1,data ,nil ,nil );if _deeg !=nil {return nil ,_deeg ;};_edaa :=_afcc .(*_cgg .Monochrome );if _deeg =_edaa .AddPadding ();
_deeg !=nil {return nil ,_deeg ;};_cfed =_edaa ;default:if len (data )< _cgg .BytesPerLine (_dfab .Columns ,1,1)*_dfab .Rows {return nil ,_be .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_cedd ,_eac :=_cgg .NewImage (_dfab .Columns ,_dfab .Rows ,1,1,data ,nil ,nil );if _eac !=nil {return nil ,_eac ;};_eeafb :=_cedd .(*_cgg .Monochrome );_cfed =_eeafb ;};_cbdd :=make ([][]byte ,_dfab .Rows );for _eca :=0;_eca < _dfab .Rows ;_eca ++{_faefa :=make ([]byte ,_dfab .Columns );
for _cbdae :=0;_cbdae < _dfab .Columns ;_cbdae ++{_fcdf :=_cfed .GrayAt (_cbdae ,_eca );_faefa [_cbdae ]=_fcdf .Y >>7;};_cbdd [_eca ]=_faefa ;};_bdc :=&_geg .Encoder {K :_dfab .K ,Columns :_dfab .Columns ,EndOfLine :_dfab .EndOfLine ,EndOfBlock :_dfab .EndOfBlock ,BlackIs1 :_dfab .BlackIs1 ,DamagedRowsBeforeError :_dfab .DamagedRowsBeforeError ,Rows :_dfab .Rows ,EncodedByteAlign :_dfab .EncodedByteAlign };
return _bdc .Encode (_cbdd ),nil ;};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_bbag int ;_fce bool ;_fede [4]byte ;_gggc bool ;_dcc bool ;_gcca bool ;_bge bool ;_aeg bool ;_baf bool ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_becf *PdfParser )Decrypt (password []byte )(bool ,error ){if _becf ._dfabf ==nil {return false ,_be .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_ebbgc ,_afbd :=_becf ._dfabf .authenticate (password );
if _afbd !=nil {return false ,_afbd ;};if !_ebbgc {_ebbgc ,_afbd =_becf ._dfabf .authenticate ([]byte (""));};return _ebbgc ,_afbd ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_cfdb *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cfdb .DecodeBytes (streamObj .Stream );};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_fbcd :=&ASCII85Encoder {};return _fbcd };

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_ffdf :=&ASCIIHexEncoder {};return _ffdf };

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_aeab *PdfObjectArray ,_agfab bool ){_aeab ,_agfab =TraceToDirectObject (obj ).(*PdfObjectArray );return _aeab ,_agfab ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_aefg :=&LZWEncoder {};_aefg .Predictor =1;_aefg .BitsPerComponent =8;_aefg .Colors =1;_aefg .Columns =1;_aefg .EarlyChange =1;return _aefg ;};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_dfbd ParserMetadata )HasInvalidSubsectionHeader ()bool {return _dfbd ._aeg };

// Write outputs the object as it is to be written to file.
func (_caba *PdfObjectInteger )Write ()[]byte {return []byte (_g .FormatInt (int64 (*_caba ),10))};

// UpdateParams updates the parameter values of the encoder.
func (_cdcc *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_gac ,_adge :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _adge ==nil {_cdcc .Predictor =int (_gac );};_cbdb ,_adge :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _adge ==nil {_cdcc .BitsPerComponent =int (_cbdb );};_ebc ,_adge :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _adge ==nil {_cdcc .Columns =int (_ebc );};_ece ,_adge :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _adge ==nil {_cdcc .Colors =int (_ece );};_gcfdg ,_adge :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _adge ==nil {_cdcc .EarlyChange =int (_gcfdg );};};

// Write outputs the object as it is to be written to file.
func (_acae *PdfObjectReference )Write ()[]byte {return _bef (func (_ggae *_c .Buffer ){_ggae .WriteString (_g .FormatInt (_acae .ObjectNumber ,10));_ggae .WriteString ("\u0020");_ggae .WriteString (_g .FormatInt (_acae .GenerationNumber ,10));_ggae .WriteString ("\u0020\u0052");
});};

// GetFilterName returns the name of the encoding filter.
func (_ebgcg *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func (_bba *PdfCrypt )makeKey (_cdf string ,_ffb ,_afb uint32 ,_eea []byte )([]byte ,error ){_cga ,_gae :=_bba ._aab [_cdf ];if !_gae {return nil ,_cg .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cdf );
};return _cga .MakeKey (_ffb ,_afb ,_eea );};func _cc (_bd *_c .Buffer ){_bd .Reset ();_fc .Put (_bd )};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_fbaa *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_fbaa .setWithLock (key ,val ,true );};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_bgdg float64 ,_geda bool ){_fbacc ,_geda :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _geda {return float64 (*_fbacc ),true ;};return 0,false ;};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_ccda ParserMetadata )HasInvalidHexRunes ()bool {return _ccda ._gcca };

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_fgef *JBIG2Encoder )DecodeGlobals (encoded []byte )(_cbd .Globals ,error ){return _cbd .DecodeGlobals (encoded );};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_acbf :=&FlateEncoder {};_acbf .Predictor =1;_acbf .BitsPerComponent =8;_acbf .Colors =1;_acbf .Columns =1;return _acbf ;};func (_aee *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_bde :=MakeDict ();_bde .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));
_bde .Set ("\u0056",MakeInteger (int64 (_aee ._eegf .V )));_bde .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_aee ._eegf .Length )));return _bde ;};func _fged (_beca _eb .ReadSeeker ,_edad int64 )(*offsetReader ,error ){_befeb :=&offsetReader {_ffba :_beca ,_efcf :_edad };
_ ,_ebce :=_befeb .Seek (0,_eb .SeekStart );return _befeb ,_ebce ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecg *FlateEncoder )MakeDecodeParams ()PdfObject {if _ecg .Predictor > 1{_beacb :=MakeDict ();_beacb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ecg .Predictor )));if _ecg .BitsPerComponent !=8{_beacb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ecg .BitsPerComponent )));
};if _ecg .Columns !=1{_beacb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ecg .Columns )));};if _ecg .Colors !=1{_beacb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ecg .Colors )));};return _beacb ;};return nil ;
};var _abbd =_df .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_efaae []StreamEncoder };func (_dgf *PdfParser )lookupByNumber (_bb int ,_dcg bool )(PdfObject ,bool ,error ){_gccb ,_ed :=_dgf .ObjCache [_bb ];if _ed {_cbf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_bb );
return _gccb ,false ,nil ;};if _dgf ._cfeeg ==nil {_dgf ._cfeeg =map[int ]bool {};};if _dgf ._cfeeg [_bb ]{_cbf .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_bb );
return nil ,false ,_be .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_dgf ._cfeeg [_bb ]=true ;defer delete (_dgf ._cfeeg ,_bb );
_geff ,_ed :=_dgf ._dbbe .ObjectMap [_bb ];if !_ed {_cbf .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _fbf PdfObjectNull ;return &_fbf ,false ,nil ;};_cbf .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_bb );switch _geff .XType {case XrefTypeTableEntry :_cbf .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_geff .ObjectNumber );
_cbf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_geff .Generation );_cbf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_geff .Offset );
_dgf ._cafb .Seek (_geff .Offset ,_eb .SeekStart );_gag ,_fbea :=_dgf .ParseIndirectObject ();if _fbea !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fbea );
if _dcg {_cbf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_gab ,_fe :=_dgf .repairRebuildXrefsTopDown ();
if _fe !=nil {_cbf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_fe );return nil ,false ,_fe ;};_dgf ._dbbe =*_gab ;return _dgf .lookupByNumber (_bb ,false );
};return nil ,false ,_fbea ;};if _dcg {_dba ,_ ,_ :=_bed (_gag );if int (_dba )!=_bb {_cbf .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_ace :=_dgf .rebuildXrefTable ();
if _ace !=nil {return nil ,false ,_ace ;};_dgf .ObjCache =objectCache {};return _dgf .lookupByNumberWrapper (_bb ,false );};};_cbf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_dgf .ObjCache [_bb ]=_gag ;
return _gag ,false ,nil ;case XrefTypeObjectStream :_cbf .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_cbf .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_cbf .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_geff .OsObjNumber ,_geff .OsObjIndex );
if _geff .OsObjNumber ==_bb {_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_be .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_cee :=_dgf ._dbbe .ObjectMap [_geff .OsObjNumber ];_cee {_fa ,_eba :=_dgf .lookupObjectViaOS (_geff .OsObjNumber ,_bb );if _eba !=nil {_cbf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_eba );
return nil ,true ,_eba ;};_cbf .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_dgf .ObjCache [_bb ]=_fa ;if _dgf ._dfabf !=nil {_dgf ._dfabf ._bedd [_fa ]=true ;};return _fa ,true ,nil ;};_cbf .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_be .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_be .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};var _efed =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// Implement the Read and Seek methods.
func (_eag *bufferedReadSeeker )Read (p []byte )(int ,error ){return _eag ._acg .Read (p )};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _dgfba :=obj .(type ){case *PdfObjectFloat :_cbf .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_dgfba ),nil ;case *PdfObjectInteger :return int64 (*_dgfba ),nil ;case *PdfObjectReference :_fceb :=TraceToDirectObject (obj );return GetNumberAsInt64 (_fceb );case *PdfIndirectObject :return GetNumberAsInt64 (_dgfba .PdfObject );};return 0,ErrNotANumber ;
};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_gaag *PdfObjectFloat ,_ddcb bool ){_gaag ,_ddcb =TraceToDirectObject (obj ).(*PdfObjectFloat );return _gaag ,_ddcb ;};func (_fccae *PdfParser )repairSeekXrefMarker ()error {_dbaaf ,_ddgee :=_fccae ._cafb .Seek (0,_eb .SeekEnd );
if _ddgee !=nil {return _ddgee ;};_eace :=_df .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _feaba int64 ;var _cgbf int64 =1000;for _feaba < _dbaaf {if _dbaaf <=(_cgbf +_feaba ){_cgbf =_dbaaf -_feaba ;};_ ,_cfggg :=_fccae ._cafb .Seek (-_feaba -_cgbf ,_eb .SeekEnd );
if _cfggg !=nil {return _cfggg ;};_bcca :=make ([]byte ,_cgbf );_fccae ._cafb .Read (_bcca );_cbf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_bcca ));
_cdaad :=_eace .FindAllStringIndex (string (_bcca ),-1);if _cdaad !=nil {_bdebe :=_cdaad [len (_cdaad )-1];_cbf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cdaad );_fccae ._cafb .Seek (-_feaba -_cgbf +int64 (_bdebe [0]),_eb .SeekEnd );
for {_badc ,_acbcd :=_fccae ._cafb .Peek (1);if _acbcd !=nil {return _acbcd ;};_cbf .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_badc [0],_badc [0]);if !IsWhiteSpace (_badc [0]){break ;};_fccae ._cafb .Discard (1);};return nil ;};_cbf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_feaba +=_cgbf ;};_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _be .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};func (_badbc *PdfParser )parseObject ()(PdfObject ,error ){_cbf .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_badbc .skipSpaces ();for {_dbdfc ,_cddgf :=_badbc ._cafb .Peek (2);if _cddgf !=nil {if _cddgf !=_eb .EOF ||len (_dbdfc )==0{return nil ,_cddgf ;};if len (_dbdfc )==1{_dbdfc =append (_dbdfc ,' ');};};_cbf .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_dbdfc ));
if _dbdfc [0]=='/'{_cfag ,_fbdb :=_badbc .parseName ();_cbf .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_cfag );return &_cfag ,_fbdb ;}else if _dbdfc [0]=='('{_cbf .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_eddag ,_cbee :=_badbc .parseString ();return _eddag ,_cbee ;}else if _dbdfc [0]=='['{_cbf .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_ccdfca ,_eacdc :=_badbc .parseArray ();return _ccdfca ,_eacdc ;}else if (_dbdfc [0]=='<')&&(_dbdfc [1]=='<'){_cbf .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_caaa ,_bgeeb :=_badbc .ParseDict ();return _caaa ,_bgeeb ;}else if _dbdfc [0]=='<'{_cbf .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_cgcb ,_egeg :=_badbc .parseHexString ();return _cgcb ,_egeg ;}else if _dbdfc [0]=='%'{_badbc .readComment ();
_badbc .skipSpaces ();}else {_cbf .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_dbdfc ,_ =_badbc ._cafb .Peek (15);_ebbaf :=string (_dbdfc );_cbf .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_ebbaf );
if (len (_ebbaf )> 3)&&(_ebbaf [:4]=="\u006e\u0075\u006c\u006c"){_fdga ,_cbbb :=_badbc .parseNull ();return &_fdga ,_cbbb ;}else if (len (_ebbaf )> 4)&&(_ebbaf [:5]=="\u0066\u0061\u006cs\u0065"){_egdg ,_fcbdd :=_badbc .parseBool ();return &_egdg ,_fcbdd ;
}else if (len (_ebbaf )> 3)&&(_ebbaf [:4]=="\u0074\u0072\u0075\u0065"){_ageb ,_ageg :=_badbc .parseBool ();return &_ageb ,_ageg ;};_effdb :=_bfcef .FindStringSubmatch (_ebbaf );if len (_effdb )> 1{_dbdfc ,_ =_badbc ._cafb .ReadBytes ('R');_cbf .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_dbdfc [:]));
_cedaa ,_egge :=_cddg (string (_dbdfc ));_cedaa ._ffbgd =_badbc ;return &_cedaa ,_egge ;};_gfcb :=_abbd .FindStringSubmatch (_ebbaf );if len (_gfcb )> 1{_cbf .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_bfee ,_ebec :=_badbc .parseNumber ();
return _bfee ,_ebec ;};_gfcb =_gcede .FindStringSubmatch (_ebbaf );if len (_gfcb )> 1{_cbf .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_cbf .Log .Trace ("\u0025\u0020\u0073",_gfcb );
_gafb ,_bfec :=_badbc .parseNumber ();return _gafb ,_bfec ;};_cbf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_ebbaf );return nil ,_be .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_gdeg *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gdeg .DecodeBytes (streamObj .Stream );};func _facfg (_bdeda int )int {_bcebb :=_bdeda >>(_gabe -1);return (_bdeda ^_bcebb )-_bcebb };

// Clear resets the dictionary to an empty state.
func (_bggge *PdfObjectDictionary )Clear (){_bggge ._gdcb =[]PdfObjectName {};_bggge ._gfed =map[PdfObjectName ]PdfObject {};_bggge ._aaae =&_cge .Mutex {};};var _bfag =_df .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// Remove removes an element specified by key.
func (_ccfca *PdfObjectDictionary )Remove (key PdfObjectName ){_bgcfg :=-1;for _aegc ,_ecaf :=range _ccfca ._gdcb {if _ecaf ==key {_bgcfg =_aegc ;break ;};};if _bgcfg >=0{_ccfca ._gdcb =append (_ccfca ._gdcb [:_bgcfg ],_ccfca ._gdcb [_bgcfg +1:]...);delete (_ccfca ._gfed ,key );
};};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_daeb *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_daeb ._cbgc ){return _be .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_daeb ._cbgc [i ]=obj ;return nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// Seek sets the offset for the next Read to offset, interpreted according to whence:
// 0 means relative to the start of the file,
// 1 means relative to the current offset, and 2 means relative to the end.
func (_ebe *bufferedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){_bf ,_cfa :=_ebe ._add .Seek (offset ,whence );if _cfa !=nil {return _bf ,_cfa ;};_ebe ._acg =_fg .NewReader (_ebe ._add );return _bf ,nil ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func (_ggbac *PdfParser )readComment ()(string ,error ){var _abegg _c .Buffer ;_ ,_fbed :=_ggbac .skipSpaces ();if _fbed !=nil {return _abegg .String (),_fbed ;};_fccad :=true ;for {_gbgf ,_cfgafa :=_ggbac ._cafb .Peek (1);if _cfgafa !=nil {_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cfgafa .Error ());
return _abegg .String (),_cfgafa ;};if _fccad &&_gbgf [0]!='%'{return _abegg .String (),_be .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_fccad =false ;
if (_gbgf [0]!='\r')&&(_gbgf [0]!='\n'){_cgadc ,_ :=_ggbac ._cafb .ReadByte ();_abegg .WriteByte (_cgadc );}else {break ;};};return _abegg .String (),nil ;};

// Discard discards the next n bytes from the buffered reader.
func (_eff *bufferedReadSeeker )Discard (n int )(int ,error ){return _eff ._acg .Discard (n )};func (_bdeb *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){_bdeb .skipSpaces ();const _fbgfd =20;_ccbd ,_ :=_bdeb ._cafb .Peek (_fbgfd );for _afgd :=0;
_afgd < 2;_afgd ++{if _bdeb ._afcca ==0{_bdeb ._afcca =_bdeb .GetFileOffset ();};if _geffg .Match (_ccbd ){_cbf .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_cbf .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_ccbd ));return _bdeb .parseXrefStream (nil );};if _gagf .Match (_ccbd ){_cbf .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _bdeb .parseXrefTable ();};_gfga :=_bdeb .GetFileOffset ();if _bdeb ._afcca ==0{_bdeb ._afcca =_gfga ;};_bdeb .SetFileOffset (_gfga -_fbgfd );defer _bdeb .SetFileOffset (_gfga );_effb ,_ :=_bdeb ._cafb .Peek (_fbgfd );_ccbd =append (_effb ,_ccbd ...);
};_cbf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _becbf :=_bdeb .repairSeekXrefMarker ();_becbf !=nil {_cbf .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_becbf );return nil ,_becbf ;};return _bdeb .parseXrefTable ();};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ggf *JBIG2Encoder )EncodeImage (img _ac .Image )([]byte ,error ){return _ggf .encodeImage (img )};

// GetParser returns the parser for lazy-loading or compare references.
func (_abag *PdfObjectReference )GetParser ()*PdfParser {return _abag ._ffbgd };

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_eddc *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };func _adad (_dfff PdfObject ,_gcbc int )PdfObject {if _gcbc > _ecfca {_cbf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ecfca );
return MakeNull ();};switch _fbdgf :=_dfff .(type ){case *PdfIndirectObject :_dfff =_adad ((*_fbdgf ).PdfObject ,_gcbc +1);case *PdfObjectArray :for _gfgb ,_cbcce :=range (*_fbdgf )._cbgc {(*_fbdgf )._cbgc [_gfgb ]=_adad (_cbcce ,_gcbc +1);};case *PdfObjectDictionary :for _cdaf ,_agga :=range (*_fbdgf )._gfed {(*_fbdgf )._gfed [_cdaf ]=_adad (_agga ,_gcbc +1);
};_d .Slice ((*_fbdgf )._gdcb ,func (_bfaa ,_bbdd int )bool {return (*_fbdgf )._gdcb [_bfaa ]< (*_fbdgf )._gdcb [_bbdd ]});};return _dfff ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_acfc *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// UpdateParams updates the parameter values of the encoder.
func (_fgaf *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_aeac :=PdfObjectString {_agaa :s ,_dddf :true };return &_aeac ;};

// UpdateParams updates the parameter values of the encoder.
func (_fcad *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_eedb *PdfParser )skipSpaces ()(int ,error ){_dfba :=0;for {_bbgb ,_cebb :=_eedb ._cafb .ReadByte ();if _cebb !=nil {return 0,_cebb ;};if IsWhiteSpace (_bbgb ){_dfba ++;}else {_eedb ._cafb .UnreadByte ();
break ;};};return _dfba ,nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_aa .Model ;Bounds ()_ac .Rectangle ;At (_dabff ,_cce int )_aa .Color ;Set (_bfbcg ,_bbbed int ,_agge _aa .Color );};

// String returns a string representation of `name`.
func (_aedc *PdfObjectName )String ()string {return string (*_aedc )};var _gcacf =_df .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func _gbfbc (_ffbe *PdfObjectStream )(*MultiEncoder ,error ){_bgg :=NewMultiEncoder ();
_bdfc :=_ffbe .PdfObjectDictionary ;if _bdfc ==nil {return _bgg ,nil ;};var _ddec *PdfObjectDictionary ;var _abef []PdfObject ;_cfbda :=_bdfc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cfbda !=nil {_fedee ,_cdfe :=_cfbda .(*PdfObjectDictionary );
if _cdfe {_ddec =_fedee ;};_dbgb ,_dgad :=_cfbda .(*PdfObjectArray );if _dgad {for _ ,_ebgg :=range _dbgb .Elements (){_ebgg =TraceToDirectObject (_ebgg );if _egdf ,_bfcca :=_ebgg .(*PdfObjectDictionary );_bfcca {_abef =append (_abef ,_egdf );}else {_abef =append (_abef ,MakeDict ());
};};};};_cfbda =_bdfc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _cfbda ==nil {return nil ,_cg .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_gega ,_ddbc :=_cfbda .(*PdfObjectArray );if !_ddbc {return nil ,_cg .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _addbc ,_ecaa :=range _gega .Elements (){_ddfe ,_acbb :=_ecaa .(*PdfObjectName );if !_acbb {return nil ,_cg .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _ega PdfObject ;if _ddec !=nil {_ega =_ddec ;}else {if len (_abef )> 0{if _addbc >=len (_abef ){return nil ,_cg .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_ega =_abef [_addbc ];};};var _gabge *PdfObjectDictionary ;if _aacc ,_gdce :=_ega .(*PdfObjectDictionary );_gdce {_gabge =_aacc ;};_cbf .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_ddfe ,_ega ,_gabge );
switch *_ddfe {case StreamEncodingFilterNameFlate :_adfef ,_aea :=_agc (_ffbe ,_gabge );if _aea !=nil {return nil ,_aea ;};_bgg .AddEncoder (_adfef );case StreamEncodingFilterNameLZW :_ecfc ,_dgbe :=_agfa (_ffbe ,_gabge );if _dgbe !=nil {return nil ,_dgbe ;
};_bgg .AddEncoder (_ecfc );case StreamEncodingFilterNameASCIIHex :_fceg :=NewASCIIHexEncoder ();_bgg .AddEncoder (_fceg );case StreamEncodingFilterNameASCII85 :_abf :=NewASCII85Encoder ();_bgg .AddEncoder (_abf );case StreamEncodingFilterNameDCT :_fcdfe ,_gdcfc :=_bdea (_ffbe ,_bgg );
if _gdcfc !=nil {return nil ,_gdcfc ;};_bgg .AddEncoder (_fcdfe );_cbf .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_cbf .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_bgg );
case StreamEncodingFilterNameCCITTFax :_aedeg ,_bcdd :=_agfd (_ffbe ,_gabge );if _bcdd !=nil {return nil ,_bcdd ;};_bgg .AddEncoder (_aedeg );default:_cbf .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_ddfe );
return nil ,_cg .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _bgg ,nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_ccgd *_cgg .ImageBase ;};func (_bgcf *PdfParser )parseString ()(*PdfObjectString ,error ){_bgcf ._cafb .ReadByte ();var _aebc _c .Buffer ;_eeed :=1;for {_dfdd ,_fgfdb :=_bgcf ._cafb .Peek (1);if _fgfdb !=nil {return MakeString (_aebc .String ()),_fgfdb ;
};if _dfdd [0]=='\\'{_bgcf ._cafb .ReadByte ();_ceeee ,_ddaeg :=_bgcf ._cafb .ReadByte ();if _ddaeg !=nil {return MakeString (_aebc .String ()),_ddaeg ;};if IsOctalDigit (_ceeee ){_gegf ,_dae :=_bgcf ._cafb .Peek (2);if _dae !=nil {return MakeString (_aebc .String ()),_dae ;
};var _bagb []byte ;_bagb =append (_bagb ,_ceeee );for _ ,_egdb :=range _gegf {if IsOctalDigit (_egdb ){_bagb =append (_bagb ,_egdb );}else {break ;};};_bgcf ._cafb .Discard (len (_bagb )-1);_cbf .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bagb );
_dbbg ,_dae :=_g .ParseUint (string (_bagb ),8,32);if _dae !=nil {return MakeString (_aebc .String ()),_dae ;};_aebc .WriteByte (byte (_dbbg ));continue ;};switch _ceeee {case 'n':_aebc .WriteRune ('\n');case 'r':_aebc .WriteRune ('\r');case 't':_aebc .WriteRune ('\t');
case 'b':_aebc .WriteRune ('\b');case 'f':_aebc .WriteRune ('\f');case '(':_aebc .WriteRune ('(');case ')':_aebc .WriteRune (')');case '\\':_aebc .WriteRune ('\\');};continue ;}else if _dfdd [0]=='('{_eeed ++;}else if _dfdd [0]==')'{_eeed --;if _eeed ==0{_bgcf ._cafb .ReadByte ();
break ;};};_dcfae ,_ :=_bgcf ._cafb .ReadByte ();_aebc .WriteByte (_dcfae );};return MakeString (_aebc .String ()),nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// UpdateParams updates the parameter values of the encoder.
func (_ccb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_gga ,_cfbd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cfbd ==nil {_ccb .Predictor =int (_gga );};_efc ,_cfbd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _cfbd ==nil {_ccb .BitsPerComponent =int (_efc );};_adgb ,_cfbd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cfbd ==nil {_ccb .Columns =int (_adgb );};_edd ,_cfbd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _cfbd ==nil {_ccb .Colors =int (_edd );};};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_cebe *PdfObjectDictionary )Keys ()[]PdfObjectName {if _cebe ==nil {return nil ;};return _cebe ._gdcb ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_fece *MultiEncoder )AddEncoder (encoder StreamEncoder ){_fece ._efaae =append (_fece ._efaae ,encoder );};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_gdba *PdfObjectString )Decoded ()string {if _gdba ==nil {return "";};_dfbe :=[]byte (_gdba ._agaa );if len (_dfbe )>=2&&_dfbe [0]==0xFE&&_dfbe [1]==0xFF{return _gb .UTF16ToString (_dfbe [2:]);};return _gb .PDFDocEncodingToString (_dfbe );};

// HeaderPosition gets the file header position.
func (_fedc ParserMetadata )HeaderPosition ()int {return _fedc ._bbag };

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_bcbg *PdfParser )IsAuthenticated ()bool {return _bcbg ._dfabf ._cbdg };

// Write outputs the object as it is to be written to file.
func (_adgbe *PdfObjectStreams )Write ()[]byte {return _bef (func (_adgc *_c .Buffer ){_adgc .WriteString (_g .FormatInt (_adgbe .ObjectNumber ,10));_adgc .WriteString ("\u0020\u0030\u0020\u0052");});};func _bdea (_fbggb *PdfObjectStream ,_gdbe *MultiEncoder )(*DCTEncoder ,error ){_fgfe :=NewDCTEncoder ();
_dbbf :=_fbggb .PdfObjectDictionary ;if _dbbf ==nil {return _fgfe ,nil ;};_gec :=_fbggb .Stream ;if _gdbe !=nil {_bfda ,_gff :=_gdbe .DecodeBytes (_gec );if _gff !=nil {return nil ,_gff ;};_gec =_bfda ;};_aadf :=_c .NewReader (_gec );_gaca ,_efagc :=_gc .DecodeConfig (_aadf );
if _efagc !=nil {_cbf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_efagc );return nil ,_efagc ;};switch _gaca .ColorModel {case _aa .RGBAModel :_fgfe .BitsPerComponent =8;
_fgfe .ColorComponents =3;_fgfe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _aa .RGBA64Model :_fgfe .BitsPerComponent =16;_fgfe .ColorComponents =3;_fgfe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _aa .GrayModel :_fgfe .BitsPerComponent =8;
_fgfe .ColorComponents =1;_fgfe .Decode =[]float64 {0.0,1.0};case _aa .Gray16Model :_fgfe .BitsPerComponent =16;_fgfe .ColorComponents =1;_fgfe .Decode =[]float64 {0.0,1.0};case _aa .CMYKModel :_fgfe .BitsPerComponent =8;_fgfe .ColorComponents =4;_fgfe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};
case _aa .YCbCrModel :_fgfe .BitsPerComponent =8;_fgfe .ColorComponents =3;_fgfe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};default:return nil ,_be .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_fgfe .Width =_gaca .Width ;_fgfe .Height =_gaca .Height ;_cbf .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_fgfe );_fgfe .Quality =DefaultJPEGQuality ;_egfb ,_cfga :=GetArray (_dbbf .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _cfga {_gbfd ,_cebfd :=_egfb .ToFloat64Array ();if _cebfd !=nil {return _fgfe ,_cebfd ;};_fgfe .Decode =_gbfd ;};return _fgfe ,nil ;};

// ReadByte reads a single byte from the buffered reader.
func (_bec *bufferedReadSeeker )ReadByte ()(byte ,error ){_ada ,_cff :=_bec ._acg .ReadByte ();if _cff !=nil {return 0,_cff ;};return _ada ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcd *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_eggge *PdfParser )Inspect ()(map[string ]int ,error ){return _eggge .inspect ()};

// Elements returns a slice of the PdfObject elements in the array.
func (_cbdgb *PdfObjectArray )Elements ()[]PdfObject {if _cbdgb ==nil {return nil ;};return _cbdgb ._cbgc ;};func (_egbf *PdfParser )repairLocateXref ()(int64 ,error ){_gafeb :=int64 (1000);_egbf ._cafb .Seek (-_gafeb ,_eb .SeekCurrent );_ebgce ,_ebfb :=_egbf ._cafb .Seek (0,_eb .SeekCurrent );
if _ebfb !=nil {return 0,_ebfb ;};_ecce :=make ([]byte ,_gafeb );_egbf ._cafb .Read (_ecce );_gebdf :=_dbddg .FindAllStringIndex (string (_ecce ),-1);if len (_gebdf )< 1{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_be .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_ggbf :=int64 (_gebdf [len (_gebdf )-1][0]);_gaaf :=_ebgce +_ggbf ;return _gaaf ,nil ;};func _befcb (_ *PdfObjectStream ,_ *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};func (_beaeb *PdfParser )skipComments ()error {if _ ,_deega :=_beaeb .skipSpaces ();_deega !=nil {return _deega ;};_adeb :=true ;for {_fgdeb ,_fcgbe :=_beaeb ._cafb .Peek (1);if _fcgbe !=nil {_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fcgbe .Error ());
return _fcgbe ;};if _adeb &&_fgdeb [0]!='%'{return nil ;};_adeb =false ;if (_fgdeb [0]!='\r')&&(_fgdeb [0]!='\n'){_beaeb ._cafb .ReadByte ();}else {break ;};};return _beaeb .skipComments ();};func (_fbcc *ASCII85Encoder )base256Tobase85 (_adee uint32 )[5]byte {_febgg :=[5]byte {0,0,0,0,0};
_fac :=_adee ;for _cde :=0;_cde < 5;_cde ++{_dgdf :=uint32 (1);for _cddb :=0;_cddb < 4-_cde ;_cddb ++{_dgdf *=85;};_cbfb :=_fac /_dgdf ;_fac =_fac %_dgdf ;_febgg [_cde ]=byte (_cbfb );};return _febgg ;};func _gfd (_dcd _dfa .Filter ,_fab _ff .AuthEvent )*PdfObjectDictionary {if _fab ==""{_fab =_ff .EventDocOpen ;
};_agd :=MakeDict ();_agd .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_agd .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_fab )));_agd .Set ("\u0043\u0046\u004d",MakeName (_dcd .Name ()));
_agd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dcd .KeyLength ())));return _agd ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_cfgaf *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _cdga _c .Buffer ;for _ ,_accf :=range data {_cdga .WriteString (_cg .Sprintf ("\u0025\u002e\u0032X\u0020",_accf ));};_cdga .WriteByte ('>');return _cdga .Bytes (),nil ;};func (_ddef *PdfCrypt )encryptBytes (_ecfd []byte ,_adggf string ,_ffg []byte )([]byte ,error ){_cbf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_ffcg ,_gbge :=_ddef ._aab [_adggf ];if !_gbge {return nil ,_cg .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_adggf );};return _ffcg .EncryptBytes (_ecfd ,_ffg );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcca *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {val =_bee .RoundDefault (val );_dcgb :=PdfObjectFloat (val );return &_dcgb ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_ccdf *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_befc :=_c .NewReader (encoded );_effd ,_ffgg :=_gc .Decode (_befc );if _ffgg !=nil {_cbf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ffgg );
return nil ,_ffgg ;};_fbee :=_effd .Bounds ();var _acgdd =make ([]byte ,_fbee .Dx ()*_fbee .Dy ()*_ccdf .ColorComponents *_ccdf .BitsPerComponent /8);_gbfdc :=0;switch _ccdf .ColorComponents {case 1:_dfeb :=[]float64 {_ccdf .Decode [0],_ccdf .Decode [1]};
for _efaa :=_fbee .Min .Y ;_efaa < _fbee .Max .Y ;_efaa ++{for _deba :=_fbee .Min .X ;_deba < _fbee .Max .X ;_deba ++{_dcfaa :=_effd .At (_deba ,_efaa );if _ccdf .BitsPerComponent ==16{_dbf ,_gacf :=_dcfaa .(_aa .Gray16 );if !_gacf {return nil ,_be .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_daa :=_gacg (uint (_dbf .Y >>8),_dfeb [0],_dfeb [1]);_dcge :=_gacg (uint (_dbf .Y ),_dfeb [0],_dfeb [1]);_acgdd [_gbfdc ]=byte (_daa );_gbfdc ++;_acgdd [_gbfdc ]=byte (_dcge );_gbfdc ++;}else {_fabc ,_eed :=_dcfaa .(_aa .Gray );if !_eed {return nil ,_be .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_acgdd [_gbfdc ]=byte (_gacg (uint (_fabc .Y ),_dfeb [0],_dfeb [1]));_gbfdc ++;};};};case 3:_cgcc :=[]float64 {_ccdf .Decode [0],_ccdf .Decode [1]};_gfb :=[]float64 {_ccdf .Decode [2],_ccdf .Decode [3]};_dfd :=[]float64 {_ccdf .Decode [4],_ccdf .Decode [5]};
for _afdd :=_fbee .Min .Y ;_afdd < _fbee .Max .Y ;_afdd ++{for _eafe :=_fbee .Min .X ;_eafe < _fbee .Max .X ;_eafe ++{_edea :=_effd .At (_eafe ,_afdd );if _ccdf .BitsPerComponent ==16{_bbcf ,_aafe :=_edea .(_aa .RGBA64 );if !_aafe {return nil ,_be .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_agac :=_gacg (uint (_bbcf .R >>8),_cgcc [0],_cgcc [1]);_befd :=_gacg (uint (_bbcf .R ),_cgcc [0],_cgcc [1]);_dbgc :=_gacg (uint (_bbcf .G >>8),_gfb [0],_gfb [1]);_abab :=_gacg (uint (_bbcf .G ),_gfb [0],_gfb [1]);_egcb :=_gacg (uint (_bbcf .B >>8),_dfd [0],_dfd [1]);
_dcdc :=_gacg (uint (_bbcf .B ),_dfd [0],_dfd [1]);_acgdd [_gbfdc ]=byte (_agac );_gbfdc ++;_acgdd [_gbfdc ]=byte (_befd );_gbfdc ++;_acgdd [_gbfdc ]=byte (_dbgc );_gbfdc ++;_acgdd [_gbfdc ]=byte (_abab );_gbfdc ++;_acgdd [_gbfdc ]=byte (_egcb );_gbfdc ++;
_acgdd [_gbfdc ]=byte (_dcdc );_gbfdc ++;}else {_bcga ,_abbc :=_edea .(_aa .RGBA );if _abbc {_acbc :=_gacg (uint (_bcga .R ),_cgcc [0],_cgcc [1]);_gfae :=_gacg (uint (_bcga .G ),_gfb [0],_gfb [1]);_bgae :=_gacg (uint (_bcga .B ),_dfd [0],_dfd [1]);_acgdd [_gbfdc ]=byte (_acbc );
_gbfdc ++;_acgdd [_gbfdc ]=byte (_gfae );_gbfdc ++;_acgdd [_gbfdc ]=byte (_bgae );_gbfdc ++;}else {_cdd ,_aegg :=_edea .(_aa .YCbCr );if !_aegg {return nil ,_be .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_eae ,_ebgc ,_fga ,_ :=_cdd .RGBA ();_ccgda :=_gacg (uint (_eae >>8),_cgcc [0],_cgcc [1]);_fgecf :=_gacg (uint (_ebgc >>8),_gfb [0],_gfb [1]);_cfcf :=_gacg (uint (_fga >>8),_dfd [0],_dfd [1]);_acgdd [_gbfdc ]=byte (_ccgda );_gbfdc ++;_acgdd [_gbfdc ]=byte (_fgecf );
_gbfdc ++;_acgdd [_gbfdc ]=byte (_cfcf );_gbfdc ++;};};};};case 4:_bcb :=[]float64 {_ccdf .Decode [0],_ccdf .Decode [1]};_bgad :=[]float64 {_ccdf .Decode [2],_ccdf .Decode [3]};_gded :=[]float64 {_ccdf .Decode [4],_ccdf .Decode [5]};_gfaa :=[]float64 {_ccdf .Decode [6],_ccdf .Decode [7]};
for _ffbfc :=_fbee .Min .Y ;_ffbfc < _fbee .Max .Y ;_ffbfc ++{for _fbbd :=_fbee .Min .X ;_fbbd < _fbee .Max .X ;_fbbd ++{_bdge :=_effd .At (_fbbd ,_ffbfc );_beada ,_aegd :=_bdge .(_aa .CMYK );if !_aegd {return nil ,_be .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ebfe :=255-_gacg (uint (_beada .C ),_bcb [0],_bcb [1]);_adca :=255-_gacg (uint (_beada .M ),_bgad [0],_bgad [1]);_cag :=255-_gacg (uint (_beada .Y ),_gded [0],_gded [1]);_gceb :=255-_gacg (uint (_beada .K ),_gfaa [0],_gfaa [1]);_acgdd [_gbfdc ]=byte (_ebfe );
_gbfdc ++;_acgdd [_gbfdc ]=byte (_adca );_gbfdc ++;_acgdd [_gbfdc ]=byte (_cag );_gbfdc ++;_acgdd [_gbfdc ]=byte (_gceb );_gbfdc ++;};};};return _acgdd ,nil ;};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_aece *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_be .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_aegbg ,_ccfc :=_aece .getNumbersOfUpdatedObjects (prevParser );if _ccfc !=nil {return nil ,_ccfc ;};_gdgd :=make (map[int64 ]PdfObject );for _ ,_cefd :=range _aegbg {if _cfad ,_agbg :=_aece .LookupByNumber (_cefd );_agbg ==nil {_gdgd [int64 (_cefd )]=_cfad ;
}else {return nil ,_agbg ;};};return _gdgd ,nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_bbee *PdfParser )GetTrailer ()*PdfObjectDictionary {return _bbee ._eaaf };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_cbfcd *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_ddaa :=_cbfcd .GetFileOffset ();_ ,_ddae :=_cbfcd ._cafb .Seek (offset ,_eb .SeekStart );if _ddae !=nil {return nil ,_ddae ;};_acac :=make ([]byte ,len );_ ,_ddae =_eb .ReadAtLeast (_cbfcd ._cafb ,_acac ,int (len ));
if _ddae !=nil {return nil ,_ddae ;};_cbfcd .SetFileOffset (_ddaa );return _acac ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dgd *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_gede *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fbge _ac .Image ;if _gede .ColorComponents ==1&&_gede .BitsPerComponent ==8{_fbge =&_ac .Gray {Rect :_ac .Rect (0,0,_gede .Width ,_gede .Height ),Pix :data ,Stride :_cgg .BytesPerLine (_gede .Width ,_gede .BitsPerComponent ,_gede .ColorComponents )};
}else {var _ebac error ;_fbge ,_ebac =_cgg .NewImage (_gede .Width ,_gede .Height ,_gede .BitsPerComponent ,_gede .ColorComponents ,data ,nil ,nil );if _ebac !=nil {return nil ,_ebac ;};};_egcg :=_gc .Options {};_egcg .Quality =_gede .Quality ;var _ebbg _c .Buffer ;
if _fggg :=_gc .Encode (&_ebbg ,_fbge ,&_egcg );_fggg !=nil {return nil ,_fggg ;};return _ebbg .Bytes (),nil ;};func (_acfd *PdfParser )initParser ()error {_cbbg ,_aadd ,_acfcd :=_acfd .parsePdfVersion ();if _acfcd !=nil {_cbf .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_acfcd );
return _acfcd ;};_acfd ._aaga .Major =_cbbg ;_acfd ._aaga .Minor =_aadd ;if _acfd ._eaaf ,_acfcd =_acfd .loadXrefs ();_acfcd !=nil {_cbf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_acfcd );
return _acfcd ;};_cbf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_acfd ._eaaf );_gagdb ,_acfcd :=_acfd .parseLinearizedDictionary ();if _acfcd !=nil {return _acfcd ;};if _gagdb !=nil {_acfd ._egac ,_acfcd =_acfd .checkLinearizedInformation (_gagdb );
if _acfcd !=nil {return _acfcd ;};};if len (_acfd ._dbbe .ObjectMap )==0{return _cg .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};_acfd ._egef =len (_acfd ._faae );
if _acfd ._egac &&_acfd ._egef !=0{_acfd ._egef --;};_acfd ._gddf =make ([]*PdfParser ,_acfd ._egef );return nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};var _gagf =_df .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_acee *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _edg _c .Buffer ;_acec :=_c .NewReader (encoded );var _gde _eb .ReadCloser ;if _acee .EarlyChange ==1{_gde =_cb .NewReader (_acec ,_cb .MSB ,8);}else {_gde =_b .NewReader (_acec ,_b .MSB ,8);
};defer _gde .Close ();if _ ,_ccdc :=_edg .ReadFrom (_gde );_ccdc !=nil {if _ccdc !=_eb .ErrUnexpectedEOF ||_edg .Len ()==0{return nil ,_ccdc ;};_cbf .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ccdc );
};return _edg .Bytes (),nil ;};

// Read implementation of Read interface.
func (_agbb *limitedReadSeeker )Read (p []byte )(_abggg int ,_gaga error ){_eeac ,_gaga :=_agbb ._bdgd .Seek (0,_eb .SeekCurrent );if _gaga !=nil {return 0,_gaga ;};_ecbad :=_agbb ._abdb -_eeac ;if _ecbad ==0{return 0,_eb .EOF ;};if _gafe :=int64 (len (p ));
_gafe < _ecbad {_ecbad =_gafe ;};_egcd :=make ([]byte ,_ecbad );_abggg ,_gaga =_agbb ._bdgd .Read (_egcd );copy (p ,_egcd );return _abggg ,_gaga ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_cfabc *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aaff :=_c .NewReader (encoded );var _dge []byte ;for {_ecb ,_cebae :=_aaff .ReadByte ();if _cebae !=nil {return nil ,_cebae ;};if _ecb =='>'{break ;};if IsWhiteSpace (_ecb ){continue ;
};if (_ecb >='a'&&_ecb <='f')||(_ecb >='A'&&_ecb <='F')||(_ecb >='0'&&_ecb <='9'){_dge =append (_dge ,_ecb );}else {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_ecb );
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_ecb );};};if len (_dge )%2==1{_dge =append (_dge ,'0');
};_cbf .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dge );_gebd :=make ([]byte ,_cf .DecodedLen (len (_dge )));_ ,_bgbf :=_cf .Decode (_gebd ,_dge );if _bgbf !=nil {return nil ,_bgbf ;};return _gebd ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_fdfe :=PdfObjectName (s );return &_fdfe };

// LookupByReference looks up a PdfObject by a reference.
func (_gcd *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_cbf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _gcd .LookupByNumber (int (ref .ObjectNumber ));
};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_cbe *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cbe .DecodeBytes (streamObj .Stream );};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_bdaa *PdfIndirectObject ,_dgaa bool ){obj =ResolveReference (obj );_bdaa ,_dgaa =obj .(*PdfIndirectObject );return _bdaa ,_dgaa ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;
StrF string ;EFF string ;CF map[string ]_dfa .FilterDict ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
//
//	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _ac .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _ggbd ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_de .Error (_ggbd ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_cdcd uint8 ;_adda _cgg .Image ;_eebf error ;);if bwThreshold ==JB2ImageAutoThreshold {_adda ,_eebf =_cgg .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_de .Error (_ggbd ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_cdcd =uint8 (255*bwThreshold );_adda ,_eebf =_cgg .MonochromeThresholdConverter (_cdcd ).Convert (i );};if _eebf !=nil {return nil ,_eebf ;};return _egdd (_adda ),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ddf *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_ecc :=MakeDict ();_ecc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ddf .GetFilterName ()));_gcac :=_ddf .MakeDecodeParams ();if _gcac !=nil {_ecc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gcac );
};_ecc .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_ddf .EarlyChange )));return _ecc ;};func (_gggea *PdfParser )parsePdfVersion ()(int ,int ,error ){var _dcfd int64 =20;_febf :=make ([]byte ,_dcfd );_gggea ._cafb .Seek (0,_eb .SeekStart );
_gggea ._cafb .Read (_febf );var _cegf error ;var _fgee ,_ecbb int ;if _fefe :=_aceca .FindStringSubmatch (string (_febf ));len (_fefe )< 3{if _fgee ,_ecbb ,_cegf =_gggea .seekPdfVersionTopDown ();_cegf !=nil {_cbf .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_cegf ;};_gggea ._cafb ._add ,_cegf =_fged (_gggea ._cafb ._add ,_gggea .GetFileOffset ()-8);if _cegf !=nil {return 0,0,_cegf ;};}else {if _fgee ,_cegf =_g .Atoi (_fefe [1]);_cegf !=nil {return 0,0,_cegf ;};if _ecbb ,_cegf =_g .Atoi (_fefe [2]);
_cegf !=nil {return 0,0,_cegf ;};_gggea .SetFileOffset (0);};_gggea ._cafb ._acg =_fg .NewReader (_gggea ._cafb ._add );_cbf .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_fgee ,_ecbb );
return _fgee ,_ecbb ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gbde *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_gfbgd :=&PdfIndirectObject {};_gfbgd .PdfObject =obj ;return _gfbgd ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_gcecc *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_gcecc ._aaae .Lock ();defer _gcecc ._aaae .Unlock ();for _aagbe ,_bfea :=range objmap {_gcecc .setWithLock (PdfObjectName (_aagbe ),_bfea ,false );};return _gcecc ;
};func (_adggfg *PdfParser )resolveReference (_gggg *PdfObjectReference )(PdfObject ,bool ,error ){_gcgc ,_dbfd :=_adggfg .ObjCache [int (_gggg .ObjectNumber )];if _dbfd {return _gcgc ,true ,nil ;};_caed ,_bbagb :=_adggfg .LookupByReference (*_gggg );if _bbagb !=nil {return nil ,false ,_bbagb ;
};_adggfg .ObjCache [int (_gggg .ObjectNumber )]=_caed ;return _caed ,false ,nil ;};

// String returns a string describing `ind`.
func (_aeee *PdfIndirectObject )String ()string {return _cg .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_aeee ).ObjectNumber );};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_cbdbg *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_cbdbg ._aaae .Lock ();defer _cbdbg ._aaae .Unlock ();_addae ,_bcgfd :=_cbdbg ._gfed [key ];if !_bcgfd {return nil ;};return _addae ;};func _bgcca (_bbdc _eb .ReadSeeker ,_cgfa int64 )(*limitedReadSeeker ,error ){_ ,_fefd :=_bbdc .Seek (0,_eb .SeekStart );
if _fefd !=nil {return nil ,_fefd ;};return &limitedReadSeeker {_bdgd :_bbdc ,_abdb :_cgfa },nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_bgba *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bgba .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};func (_cbbda *PdfCrypt )authenticate (_aad []byte )(bool ,error ){_cbbda ._cbdg =false ;_bgc :=_cbbda .securityHandler ();_aabb ,_gaa ,_befg :=_bgc .Authenticate (&_cbbda ._baa ,_aad );if _befg !=nil {return false ,_befg ;
}else if _gaa ==0||len (_aabb )==0{return false ,nil ;};_cbbda ._cbdg =true ;_cbbda ._beaf =_aabb ;return true ,nil ;};var _dbddg =_df .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");


// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_agcg *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_ddfd :=data ;var _addc error ;for _daaa :=len (_agcg ._efaae )-1;_daaa >=0;_daaa --{_cddf :=_agcg ._efaae [_daaa ];_ddfd ,_addc =_cddf .EncodeBytes (_ddfd );if _addc !=nil {return nil ,_addc ;
};};return _ddfd ,nil ;};func (_gg *PdfParser )lookupByNumberWrapper (_acgd int ,_ebee bool )(PdfObject ,bool ,error ){_ggg ,_fd ,_cdc :=_gg .lookupByNumber (_acgd ,_ebee );if _cdc !=nil {return nil ,_fd ,_cdc ;};if !_fd &&_gg ._dfabf !=nil &&_gg ._dfabf ._cbdg &&!_gg ._dfabf .isDecrypted (_ggg ){_dea :=_gg ._dfabf .Decrypt (_ggg ,0,0);
if _dea !=nil {return nil ,_fd ,_dea ;};};return _ggg ,_fd ,nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_eggc :=PdfObjectNull {};return &_eggc };

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_febc *PdfParser )GetFileOffset ()int64 {return _febc ._cafb .GetFileOffset ()};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_afg *bufferedReadSeeker )GetFileOffset ()int64 {_eeb ,_ :=_afg ._add .Seek (0,_eb .SeekCurrent );_eeb -=int64 (_afg ._acg .Buffered ());return _eeb ;};func _cbb (_ebg _eb .ReadSeeker )*bufferedReadSeeker {return &bufferedReadSeeker {_add :_ebg ,_acg :_fg .NewReader (_ebg )};
};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_gabg ParserMetadata )HasDataAfterEOF ()bool {return _gabg ._gggc };

// Bytes returns the PdfObjectString content as a []byte array.
func (_cdfef *PdfObjectString )Bytes ()[]byte {return []byte (_cdfef ._agaa )};

// GetXrefTable returns the PDFs xref table.
func (_edec *PdfParser )GetXrefTable ()XrefTable {return _edec ._dbbe };

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_efbe bool ,_eef bool ){_aaccd ,_eef :=TraceToDirectObject (obj ).(*PdfObjectBool );if _eef {return bool (*_aaccd ),true ;};return false ,false ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _eb .ReadSeeker )(_dgaf *PdfParser ,_gcfd error ){_dgaf =&PdfParser {_cafb :_cbb (rs ),ObjCache :make (objectCache ),_bbec :map[int64 ]bool {},_bfbgb :true ,_cedbf :make (map[*PdfParser ]*PdfParser )};if _gcfd =_dgaf .parseDetailedHeader ();
_gcfd !=nil {return nil ,_gcfd ;};if _dgaf ._eaaf ,_gcfd =_dgaf .loadXrefs ();_gcfd !=nil {_cbf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_gcfd );
return nil ,_gcfd ;};_cbf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_dgaf ._eaaf );if len (_dgaf ._dbbe .ObjectMap )==0{return nil ,_cg .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _dgaf ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gcff *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_cbed :=range another .Keys (){_ddbb :=another .Get (_cbed );_gcff .Set (_cbed ,_ddbb );};};return _gcff ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func _egdd (_afef _cgg .Image )*JBIG2Image {_caaf :=_afef .Base ();return &JBIG2Image {Data :_caaf .Data ,Width :_caaf .Width ,Height :_caaf .Height ,HasPadding :true };
};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_geca *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_dda :=_c .NewReader (data );var _ffbb []byte ;var _adfcf []byte ;_ggbg ,_dcff :=_dda .ReadByte ();if _dcff ==_eb .EOF {return []byte {},nil ;}else if _dcff !=nil {return nil ,_dcff ;
};_babf :=1;for {_eggg ,_bdgbf :=_dda .ReadByte ();if _bdgbf ==_eb .EOF {break ;}else if _bdgbf !=nil {return nil ,_bdgbf ;};if _eggg ==_ggbg {if len (_adfcf )> 0{_adfcf =_adfcf [:len (_adfcf )-1];if len (_adfcf )> 0{_ffbb =append (_ffbb ,byte (len (_adfcf )-1));
_ffbb =append (_ffbb ,_adfcf ...);};_babf =1;_adfcf =[]byte {};};_babf ++;if _babf >=127{_ffbb =append (_ffbb ,byte (257-_babf ),_ggbg );_babf =0;};}else {if _babf > 0{if _babf ==1{_adfcf =[]byte {_ggbg };}else {_ffbb =append (_ffbb ,byte (257-_babf ),_ggbg );
};_babf =0;};_adfcf =append (_adfcf ,_eggg );if len (_adfcf )>=127{_ffbb =append (_ffbb ,byte (len (_adfcf )-1));_ffbb =append (_ffbb ,_adfcf ...);_adfcf =[]byte {};};};_ggbg =_eggg ;};if len (_adfcf )> 0{_ffbb =append (_ffbb ,byte (len (_adfcf )-1));_ffbb =append (_ffbb ,_adfcf ...);
}else if _babf > 0{_ffbb =append (_ffbb ,byte (257-_babf ),_ggbg );};_ffbb =append (_ffbb ,128);return _ffbb ,nil ;};func _ecefe (_adage ,_agee ,_feae uint8 )uint8 {_bbeg :=int (_feae );_fbcf :=int (_agee )-_bbeg ;_bcgd :=int (_adage )-_bbeg ;_bbeg =_facfg (_fbcf +_bcgd );
_fbcf =_facfg (_fbcf );_bcgd =_facfg (_bcgd );if _fbcf <=_bcgd &&_fbcf <=_bbeg {return _adage ;}else if _bcgd <=_bbeg {return _agee ;};return _feae ;};

// UpdateParams updates the parameter values of the encoder.
func (_ecba *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_gedee :=MakeArray ();for _ ,_cebg :=range vals {_gedee .Append (MakeFloat (_cebg ));};return _gedee ;};

// HasNonConformantStream implements core.ParserMetadata.
func (_beg ParserMetadata )HasNonConformantStream ()bool {return _beg ._bge };

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_geba :=PdfObjectString {_agaa :s };return &_geba };func (_agdf *FlateEncoder )postDecodePredict (_adf []byte )([]byte ,error ){if _agdf .Predictor > 1{if _agdf .Predictor ==2{_cbf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_cbf .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_agdf .Colors );_fdac :=_agdf .Columns *_agdf .Colors ;if _fdac < 1{return []byte {},nil ;};_bbda :=len (_adf )/_fdac ;if len (_adf )%_fdac !=0{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_adf ),_fdac );};if _fdac %_agdf .Colors !=0{return nil ,_cg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fdac ,_agdf .Colors );
};if _fdac > len (_adf ){_cbf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fdac ,len (_adf ));
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cbf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_adf ),_adf );
_bead :=_c .NewBuffer (nil );for _cfeg :=0;_cfeg < _bbda ;_cfeg ++{_ecd :=_adf [_fdac *_cfeg :_fdac *(_cfeg +1)];for _dcdd :=_agdf .Colors ;_dcdd < _fdac ;_dcdd ++{_ecd [_dcdd ]+=_ecd [_dcdd -_agdf .Colors ];};_bead .Write (_ecd );};_aecg :=_bead .Bytes ();
_cbf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_aecg ),_aecg );return _aecg ,nil ;}else if _agdf .Predictor >=10&&_agdf .Predictor <=15{_cbf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_agg :=_agdf .Columns *_agdf .Colors +1;_debc :=len (_adf )/_agg ;if len (_adf )%_agg !=0{return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_adf ),_agg );
};if _agg > len (_adf ){_cbf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_agg ,len (_adf ));
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fbfd :=_c .NewBuffer (nil );_cbf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_agdf .Columns );
_cbf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_adf ),_agg ,_debc );_egb :=make ([]byte ,_agg );for _gbd :=0;_gbd < _agg ;_gbd ++{_egb [_gbd ]=0;};_aaad :=_agdf .Colors ;
for _bdgb :=0;_bdgb < _debc ;_bdgb ++{_ceda :=_adf [_agg *_bdgb :_agg *(_bdgb +1)];_cfcb :=_ceda [0];switch _cfcb {case _bag :case _bfbg :for _gdbd :=1+_aaad ;_gdbd < _agg ;_gdbd ++{_ceda [_gdbd ]+=_ceda [_gdbd -_aaad ];};case _agbd :for _bgeb :=1;_bgeb < _agg ;
_bgeb ++{_ceda [_bgeb ]+=_egb [_bgeb ];};case _eafc :for _abdc :=1;_abdc < _aaad +1;_abdc ++{_ceda [_abdc ]+=_egb [_abdc ]/2;};for _egf :=_aaad +1;_egf < _agg ;_egf ++{_ceda [_egf ]+=byte ((int (_ceda [_egf -_aaad ])+int (_egb [_egf ]))/2);};case _gbfb :for _gda :=1;
_gda < _agg ;_gda ++{var _dbae ,_ddbe ,_cggb byte ;_ddbe =_egb [_gda ];if _gda >=_aaad +1{_dbae =_ceda [_gda -_aaad ];_cggb =_egb [_gda -_aaad ];};_ceda [_gda ]+=_ecefe (_dbae ,_ddbe ,_cggb );};default:_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_cfcb ,_bdgb );
return nil ,_cg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cfcb );};copy (_egb ,_ceda );_fbfd .Write (_ceda [1:]);};_dceg :=_fbfd .Bytes ();return _dceg ,nil ;
}else {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_agdf .Predictor );return nil ,_cg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_agdf .Predictor );
};};return _adf ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_acgf *PdfObjectStreams )Elements ()[]PdfObject {if _acgf ==nil {return nil ;};return _acgf ._adbf ;};func (_fdbe *PdfParser )checkPostEOFData ()error {const _ebab ="\u0025\u0025\u0045O\u0046";_ ,_caf :=_fdbe ._cafb .Seek (-int64 (len ([]byte (_ebab )))-1,_eb .SeekEnd );
if _caf !=nil {return _caf ;};_afca :=make ([]byte ,len ([]byte (_ebab ))+1);_ ,_caf =_fdbe ._cafb .Read (_afca );if _caf !=nil {if _caf !=_eb .EOF {return _caf ;};};if string (_afca )==_ebab ||string (_afca )==_ebab +"\u000a"{_fdbe ._aefd ._gggc =true ;
};return nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};const _gabe =32<<(^uint (0)>>63);

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_fcbd *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};type offsetReader struct{_ffba _eb .ReadSeeker ;_efcf int64 ;};func (_dagb *PdfParser )rebuildXrefTable ()error {_acggf :=XrefTable {};_acggf .ObjectMap =map[int ]XrefObject {};
_dgbf :=make ([]int ,0,len (_dagb ._dbbe .ObjectMap ));for _becae :=range _dagb ._dbbe .ObjectMap {_dgbf =append (_dgbf ,_becae );};_d .Ints (_dgbf );for _ ,_gfcbg :=range _dgbf {_fdce :=_dagb ._dbbe .ObjectMap [_gfcbg ];_cefe ,_ ,_bccge :=_dagb .lookupByNumberWrapper (_gfcbg ,false );
if _bccge !=nil {_cbf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_bccge );_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_ffffg ,_egbc :=_dagb .repairRebuildXrefsTopDown ();if _egbc !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_egbc );
return _egbc ;};_dagb ._dbbe =*_ffffg ;_cbf .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_bafc ,_bbca ,_bccge :=_bed (_cefe );if _bccge !=nil {return _bccge ;
};_fdce .ObjectNumber =int (_bafc );_fdce .Generation =int (_bbca );_acggf .ObjectMap [int (_bafc )]=_fdce ;};_dagb ._dbbe =_acggf ;_cbf .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_faef (_dagb ._dbbe );
return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fea *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};var _aceca =_df .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");type objectStream struct{N int ;_ba []byte ;_aec map[int ]int64 ;};type objectCache map[int ]PdfObject ;

// ReadBytes reads until the first occurrence of delim in the buffered reader.
func (_ebb *bufferedReadSeeker )ReadBytes (delim byte )([]byte ,error ){_gef ,_abe :=_ebb ._acg .ReadBytes (delim );if _abe !=nil {return nil ,_abe ;};return _gef ,nil ;};func (_faaeb *PdfParser )xrefNextObjectOffset (_agba int64 )int64 {_aabd :=int64 (0);
if len (_faaeb ._dbbe .ObjectMap )==0{return 0;};if len (_faaeb ._dbbe ._ade )==0{_beba :=0;for _ ,_gafg :=range _faaeb ._dbbe .ObjectMap {if _gafg .Offset > 0{_beba ++;};};if _beba ==0{return 0;};_faaeb ._dbbe ._ade =make ([]XrefObject ,_beba );_beagg :=0;
for _ ,_fcbc :=range _faaeb ._dbbe .ObjectMap {if _fcbc .Offset > 0{_faaeb ._dbbe ._ade [_beagg ]=_fcbc ;_beagg ++;};};_d .Slice (_faaeb ._dbbe ._ade ,func (_baec ,_abgb int )bool {return _faaeb ._dbbe ._ade [_baec ].Offset < _faaeb ._dbbe ._ade [_abgb ].Offset });
};_gdbdb :=_d .Search (len (_faaeb ._dbbe ._ade ),func (_bgcce int )bool {return _faaeb ._dbbe ._ade [_bgcce ].Offset >=_agba });if _gdbdb < len (_faaeb ._dbbe ._ade ){_aabd =_faaeb ._dbbe ._ade [_gdbdb ].Offset ;};return _aabd ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cfeec *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gaff :=MakeDict ();_gaff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfeec .GetFilterName ()));return _gaff ;};

// String returns a string describing `d`.
func (_gfcge *PdfObjectDictionary )String ()string {var _daccd _dg .Builder ;_daccd .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_eecde :=range _gfcge ._gdcb {_dbed :=_gfcge ._gfed [_eecde ];_daccd .WriteString ("\u0022"+_eecde .String ()+"\u0022\u003a\u0020");
_daccd .WriteString (_dbed .String ());_daccd .WriteString ("\u002c\u0020");};_daccd .WriteString ("\u0029");return _daccd .String ();};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_gade :=PdfObjectBool (val );return &_gade };

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_eaab *_bc .Document ;

// Globals are the JBIG2 global segments.
Globals _cbd .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_ddbdde *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _dggf :=val .(type ){case *PdfObjectName :if _dggf !=nil {_ddbdde .Set (key ,val );};case *PdfObjectDictionary :if _dggf !=nil {_ddbdde .Set (key ,val );
};case *PdfObjectStream :if _dggf !=nil {_ddbdde .Set (key ,val );};case *PdfObjectString :if _dggf !=nil {_ddbdde .Set (key ,val );};case *PdfObjectNull :if _dggf !=nil {_ddbdde .Set (key ,val );};case *PdfObjectInteger :if _dggf !=nil {_ddbdde .Set (key ,val );
};case *PdfObjectArray :if _dggf !=nil {_ddbdde .Set (key ,val );};case *PdfObjectBool :if _dggf !=nil {_ddbdde .Set (key ,val );};case *PdfObjectFloat :if _dggf !=nil {_ddbdde .Set (key ,val );};case *PdfObjectReference :if _dggf !=nil {_ddbdde .Set (key ,val );
};case *PdfIndirectObject :if _dggf !=nil {_ddbdde .Set (key ,val );};default:_cbf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_agcc *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_cbf .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_egaa :=MakeDict ();_egaa ._aecd =_agcc ;_dafc ,_ :=_agcc ._cafb .ReadByte ();
if _dafc !='<'{return nil ,_be .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_dafc ,_ =_agcc ._cafb .ReadByte ();if _dafc !='<'{return nil ,_be .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_agcc .skipSpaces ();_agcc .skipComments ();_bfdf ,_cace :=_agcc ._cafb .Peek (2);if _cace !=nil {return nil ,_cace ;};_cbf .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bfdf ),string (_bfdf ));
if (_bfdf [0]=='>')&&(_bfdf [1]=='>'){_cbf .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_agcc ._cafb .ReadByte ();_agcc ._cafb .ReadByte ();break ;};_cbf .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_ccgec ,_cace :=_agcc .parseName ();_cbf .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_ccgec );if _cace !=nil {_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_cace );
return nil ,_cace ;};if len (_ccgec )> 4&&_ccgec [len (_ccgec )-4:]=="\u006e\u0075\u006c\u006c"{_baea :=_ccgec [0:len (_ccgec )-4];_cbf .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_ccgec );
_cbf .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_baea );_agcc .skipSpaces ();_gebg ,_ :=_agcc ._cafb .Peek (1);if _gebg [0]=='/'{_egaa .Set (_baea ,MakeNull ());continue ;};};
_agcc .skipSpaces ();_ddce ,_cace :=_agcc .parseObject ();if _cace !=nil {return nil ,_cace ;};_egaa .Set (_ccgec ,_ddce );if _cbf .Log .IsLogLevel (_cbf .LogLevelTrace ){_cbf .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_ccgec ,_ddce .String ());
};};_cbf .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _egaa ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_bbg JBIG2EncoderSettings )Validate ()error {const _bgcd ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _bbg .Threshold < 0||_bbg .Threshold > 1.0{return _de .Errorf (_bgcd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_bbg .Threshold );
};if _bbg .ResolutionX < 0{return _de .Errorf (_bgcd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbg .ResolutionX );
};if _bbg .ResolutionY < 0{return _de .Errorf (_bgcd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbg .ResolutionY );
};if _bbg .DefaultPixelValue !=0&&_bbg .DefaultPixelValue !=1{return _de .Errorf (_bgcd ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_bbg .DefaultPixelValue );
};if _bbg .Compression !=JB2Generic {return _de .Errorf (_bgcd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_eecg *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_eecba :=range _eecg ._efaae {_eecba .UpdateParams (params );};};

// ParserMetadata gets the pdf parser metadata.
func (_fgg *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_fgg ._bfbgb {return ParserMetadata {},_cg .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _fgg ._aefd ,nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_gdeb *JBIG2Encoder )Encode ()(_gagd []byte ,_gdg error ){const _gaf ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _gdeb ._eaab ==nil {return nil ,_de .Errorf (_gaf ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_gdeb ._eaab .FullHeaders =_gdeb .DefaultPageSettings .FileMode ;_gagd ,_gdg =_gdeb ._eaab .Encode ();if _gdg !=nil {return nil ,_de .Wrap (_gdg ,_gaf ,"");};return _gagd ,nil ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_aefgf :=_c .NewReader ([]byte (txt ));_dcda :=&PdfParser {ObjCache :objectCache {},_cafb :_cbb (_aefgf ),_eacd :int64 (len (txt )),_bbec :map[int64 ]bool {},_cedbf :make (map[*PdfParser ]*PdfParser )};
_dcda ._dbbe .ObjectMap =make (map[int ]XrefObject );return _dcda ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bffb *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_bffb ._efaae )==0{return nil ;};if len (_bffb ._efaae )==1{return _bffb ._efaae [0].MakeDecodeParams ();};_acgg :=MakeArray ();_beae :=true ;for _ ,_facf :=range _bffb ._efaae {_eedf :=_facf .MakeDecodeParams ();
if _eedf ==nil {_acgg .Append (MakeNull ());}else {_beae =false ;_acgg .Append (_eedf );};};if _beae {return nil ;};return _acgg ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_beb *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_fdcg string ,_bggga bool ){_agbda ,_bggga :=TraceToDirectObject (obj ).(*PdfObjectString );if _bggga {return _agbda .Str (),true ;};return ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _ffcd ,_bcgec :=obj .(*PdfObjectReference );_bcgec {return _ffcd .Resolve ();};return obj ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_gbc *PdfObjectDictionary );EncodeBytes (_ebba []byte )([]byte ,error );DecodeBytes (_cgbd []byte )([]byte ,error );
DecodeStream (_geb *PdfObjectStream )([]byte ,error );};func (_fffff *JBIG2Encoder )encodeImage (_cefg _ac .Image )([]byte ,error ){const _gbbbb ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_fagf ,_geeb :=GoImageToJBIG2 (_cefg ,JB2ImageAutoThreshold );
if _geeb !=nil {return nil ,_de .Wrap (_geeb ,_gbbbb ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _geeb =_fffff .AddPageImage (_fagf ,&_fffff .DefaultPageSettings );
_geeb !=nil {return nil ,_de .Wrap (_geeb ,_gbbbb ,"");};return _fffff .Encode ();};func (_gdcfca *PdfParser )parseBool ()(PdfObjectBool ,error ){_ceac ,_bgeag :=_gdcfca ._cafb .Peek (4);if _bgeag !=nil {return PdfObjectBool (false ),_bgeag ;};if (len (_ceac )>=4)&&(string (_ceac [:4])=="\u0074\u0072\u0075\u0065"){_gdcfca ._cafb .Discard (4);
return PdfObjectBool (true ),nil ;};_ceac ,_bgeag =_gdcfca ._cafb .Peek (5);if _bgeag !=nil {return PdfObjectBool (false ),_bgeag ;};if (len (_ceac )>=5)&&(string (_ceac [:5])=="\u0066\u0061\u006cs\u0065"){_gdcfca ._cafb .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_be .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// FormatWriteDirectionLTR formats a string for left-to-right rendering, handling bidirectional runs.
func FormatWriteDirectionLTR (str string ,isLTR bool )string {_fddbc :=str ;if _fddbc ==""{return "";};_ebece :=_fb .Paragraph {};_ ,_dcgc :=_ebece .SetString (str );if _dcgc !=nil {return _fddbc ;};_dgdda ,_dcgc :=_ebece .Order ();if _dcgc !=nil {return _fddbc ;
};_befgb :=_dgdda .NumRuns ();_ecefeg :=make ([]string ,_befgb );for _fegg :=0;_fegg < _dgdda .NumRuns ();_fegg ++{_gdbcc :=_dgdda .Run (_fegg );_eaad :=_gdbcc .String ();if _gdbcc .Direction ()==_fb .RightToLeft {_eaad =_fb .ReverseString (_eaad );};if isLTR {_ecefeg [_fegg ]=_eaad ;
}else {_ecefeg [_befgb -1]=_eaad ;};_befgb --;};if len (_ecefeg )!=_dgdda .NumRuns (){return str ;};_fddbc =_dg .Join (_ecefeg ,"");return _fddbc ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_agdg *PdfObjectString )Str ()string {return _agdg ._agaa };

// NewParserWithOpts creates and initializes a new PdfParser using the provided options.
// It creates a parser that tolerates certain non-critical PDF errors.
// Returns a PdfParser or an error if initialization fails.
func NewParserWithOpts (rs _eb .ReadSeeker ,opts ParserOpts )(*PdfParser ,error ){_aead :=&PdfParser {_cafb :_cbb (rs ),ObjCache :make (objectCache ),_bbec :map[int64 ]bool {},_faae :make ([]int64 ,0),_cedbf :make (map[*PdfParser ]*PdfParser ),Opts :&opts };
_caafb :=_aead .initParser ();if _caafb !=nil {return nil ,_caafb ;};return _aead ,nil ;};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_faga *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _faga ._facb };

// String returns a string describing `ref`.
func (_cbgg *PdfObjectReference )String ()string {return _cg .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_cbgg .ObjectNumber ,_cbgg .GenerationNumber );};

// UnreadByte unreads the last byte read from the buffered reader.
func (_eaf *bufferedReadSeeker )UnreadByte ()error {return _eaf ._acg .UnreadByte ()};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_effe *JBIG2Encoder )DecodeImages (encoded []byte )([]_ac .Image ,error ){const _gaac ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_gcgg ,_bece :=_fbe .Decode (encoded ,_fbe .Parameters {},_effe .Globals .ToDocumentGlobals ());
if _bece !=nil {return nil ,_de .Wrap (_bece ,_gaac ,"");};_abfg ,_bece :=_gcgg .PageNumber ();if _bece !=nil {return nil ,_de .Wrap (_bece ,_gaac ,"");};_aacf :=[]_ac .Image {};var _eaff _ac .Image ;for _cbbcb :=1;_cbbcb <=_abfg ;_cbbcb ++{_eaff ,_bece =_gcgg .DecodePageImage (_cbbcb );
if _bece !=nil {return nil ,_de .Wrapf (_bece ,_gaac ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cbbcb );};_aacf =append (_aacf ,_eaff );};return _aacf ,nil ;};func _acaf (_agad PdfObject ,_cfbgb int ,_decbf map[PdfObject ]struct{})error {_cbf .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_cfbgb );
if _ ,_dfdde :=_decbf [_agad ];_dfdde {_cbf .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_decbf [_agad ]=struct{}{};switch _egbbc :=_agad .(type ){case *PdfIndirectObject :_eadfc :=_egbbc ;
_cbf .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_eadfc );_cbf .Log .Trace ("\u002d\u0020\u0025\u0073",_eadfc .PdfObject );return _acaf (_eadfc .PdfObject ,_cfbgb +1,_decbf );case *PdfObjectStream :_bdad :=_egbbc ;return _acaf (_bdad .PdfObjectDictionary ,_cfbgb +1,_decbf );
case *PdfObjectDictionary :_gfca :=_egbbc ;_cbf .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_gfca );for _ ,_caec :=range _gfca .Keys (){_fbfa :=_gfca .Get (_caec );if _gagb ,_fdggd :=_fbfa .(*PdfObjectReference );_fdggd {_gddd :=_gagb .Resolve ();
_gfca .Set (_caec ,_gddd );_bgaee :=_acaf (_gddd ,_cfbgb +1,_decbf );if _bgaee !=nil {return _bgaee ;};}else {_efab :=_acaf (_fbfa ,_cfbgb +1,_decbf );if _efab !=nil {return _efab ;};};};return nil ;case *PdfObjectArray :_ffgd :=_egbbc ;_cbf .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_ffgd );
for _dage ,_dgba :=range _ffgd .Elements (){if _gdebc ,_fgbg :=_dgba .(*PdfObjectReference );_fgbg {_cgeca :=_gdebc .Resolve ();_ffgd .Set (_dage ,_cgeca );_bgfe :=_acaf (_cgeca ,_cfbgb +1,_decbf );if _bgfe !=nil {return _bgfe ;};}else {_ebed :=_acaf (_dgba ,_cfbgb +1,_decbf );
if _ebed !=nil {return _ebed ;};};};return nil ;case *PdfObjectReference :_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _be .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fead *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// ParserOpts defines configuration options for Parser.
// These options allow setting customization flags to control parsing behaviors.
type ParserOpts struct{

// RelaxedMode enables tolerant parsing by ignoring certain non-critical PDF errors.
// When set to true, the parser will attempt to continue processing despite certain
// structural errors such as:
// - Missing or invalid /XRefStm entries
// - Non-/Page or non-/Pages objects found in the page tree (/Kids array)
RelaxedMode bool ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_cffcf *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cbf .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_fca :=_c .NewReader (encoded );_acdfg ,_ffa :=_ab .NewReader (_fca );if _ffa !=nil {_cbf .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_ffa );_cbf .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_ffa ;};defer _acdfg .Close ();var _ddd _c .Buffer ;_ddd .ReadFrom (_acdfg );return _ddd .Bytes (),nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _eecd _c .Buffer ;_eecd .Write ([]byte {0xFE,0xFF});_eecd .WriteString (_gb .StringToUTF16 (s ));return &PdfObjectString {_agaa :_eecd .String (),_dddf :true };};return &PdfObjectString {_agaa :string (_gb .StringToPDFDocEncoding (s )),_dddf :false };
};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_fbga :=TraceToDirectObject (obj ).(*PdfObjectNull );return _fbga ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_cfgaa *PdfObjectDictionary ,_ebgf bool ){_cfgaa ,_ebgf =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _cfgaa ,_ebgf ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_fbgg *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _fbgg .Predictor !=1{return nil ,_cg .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _fbgg .EarlyChange ==1{return nil ,_cg .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _efag _c .Buffer ;_aada :=_b .NewWriter (&_efag ,_b .MSB ,8);_aada .Write (data );_aada .Close ();return _efag .Bytes (),nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _dfa .Filter ,userPass ,ownerPass []byte ,perm _ff .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_ccd :=&PdfCrypt {_defg :make (map[PdfObject ]bool ),_aab :make (cryptFilters ),_baa :_ff .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _cgge Version ;if cf !=nil {_fdb :=cf .PDFVersion ();_cgge .Major ,_cgge .Minor =_fdb [0],_fdb [1];V ,R :=cf .HandlerVersion ();_ccd ._eegf .V =V ;_ccd ._baa .R =R ;_ccd ._eegf .Length =cf .KeyLength ()*8;};const (_abb =_cbbd ;);_ccd ._aab [_abb ]=cf ;
if _ccd ._eegf .V >=4{_ccd ._ebbf =_abb ;_ccd ._eda =_abb ;};_agb :=_ccd .newEncryptDict ();_eagd :=_ge .Sum ([]byte (_ea .Now ().Format (_ea .RFC850 )));_feb :=string (_eagd [:]);_fef :=make ([]byte ,100);_f .Read (_fef );_eagd =_ge .Sum (_fef );_adg :=string (_eagd [:]);
_cbf .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_fef );_cbf .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_feb );_ccd ._fee =_feb ;_addf :=_ccd .generateParams (userPass ,ownerPass );
if _addf !=nil {return nil ,nil ,_addf ;};_aef (&_ccd ._baa ,_agb );if _ccd ._eegf .V >=4{if _edc :=_ccd .saveCryptFilters (_agb );_edc !=nil {return nil ,nil ,_edc ;};};return _ccd ,&EncryptInfo {Version :_cgge ,Encrypt :_agb ,ID0 :_feb ,ID1 :_adg },nil ;
};

// Write outputs the object as it is to be written to file.
func (_dgagd *PdfObjectNull )Write ()[]byte {return []byte ("\u006e\u0075\u006c\u006c")};func (_fddbd *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _gaeea *PdfObjectDictionary ;_feed ,_ddaf :=_fddbd .readTextLine ();if _ddaf !=nil {return nil ,_ddaf ;
};if _fddbd ._bfbgb &&_dg .Count (_dg .TrimPrefix (_feed ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_fddbd ._aefd ._baf =true ;};_cbf .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_feed );
_edgfe :=-1;_bdgbb :=0;_eadf :=false ;_bcbb :="";for {_fddbd .skipSpaces ();_ ,_fbgf :=_fddbd ._cafb .Peek (1);if _fbgf !=nil {return nil ,_fbgf ;};_feed ,_fbgf =_fddbd .readTextLine ();if _fbgf !=nil {return nil ,_fbgf ;};_ddaaf :=_gcacf .FindStringSubmatch (_feed );
if len (_ddaaf )==0{_ggdg :=len (_bcbb )> 0;_bcbb +=_feed +"\u000a";if _ggdg {_ddaaf =_gcacf .FindStringSubmatch (_bcbb );};};if len (_ddaaf )==3{if _fddbd ._bfbgb &&!_fddbd ._aefd ._aeg {var (_eadc bool ;_debee int ;);for _ ,_edadg :=range _feed {if _cd .IsDigit (_edadg ){if _eadc {break ;
};continue ;};if !_eadc {_eadc =true ;};_debee ++;};if _debee > 1{_fddbd ._aefd ._aeg =true ;};};_egfa ,_ :=_g .Atoi (_ddaaf [1]);_cdac ,_ :=_g .Atoi (_ddaaf [2]);_edgfe =_egfa ;_bdgbb =_cdac ;_eadf =true ;_bcbb ="";_cbf .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_edgfe ,_bdgbb );
continue ;};_gbaa :=_edgb .FindStringSubmatch (_feed );if len (_gbaa )==4{if !_eadf {_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_be .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_cfae ,_ :=_g .ParseInt (_gbaa [1],10,64);_dccd ,_ :=_g .Atoi (_gbaa [2]);_ffbg :=_gbaa [3];_bcbb ="";if _dg .ToLower (_ffbg )=="\u006e"&&_cfae > 1{_fddd ,_ccbb :=_fddbd ._dbbe .ObjectMap [_edgfe ];if !_ccbb ||_dccd > _fddd .Generation {_fabf :=XrefObject {ObjectNumber :_edgfe ,XType :XrefTypeTableEntry ,Offset :_cfae ,Generation :_dccd };
_fddbd ._dbbe .ObjectMap [_edgfe ]=_fabf ;};};_edgfe ++;continue ;};if (len (_feed )> 6)&&(_feed [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_cbf .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_feed );
if len (_feed )> 9{_dbbgg :=_fddbd .GetFileOffset ();_fddbd .SetFileOffset (_dbbgg -int64 (len (_feed ))+7);};_fddbd .skipSpaces ();_fddbd .skipComments ();_cbf .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_cbf .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_feed );_gaeea ,_fbgf =_fddbd .ParseDict ();_cbf .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _fbgf !=nil {_cbf .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fbgf );return nil ,_fbgf ;};break ;};if _feed =="\u0025\u0025\u0045O\u0046"{_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_be .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_cbf .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_feed );
};_cbf .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _fddbd ._ceca ==nil {_bdcc :=XrefTypeTableEntry ;_fddbd ._ceca =&_bdcc ;};return _gaeea ,nil ;};

// String returns a string describing `null`.
func (_aabf *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// MakeLazy create temporary file for stream to reduce memory usage.
// It can be used for creating PDF with many images.
// Temporary files are removed automatically when Write/WriteToFile is called for creator object.
func (_eecc *PdfObjectStream )MakeLazy ()error {if _eecc .Lazy {return nil ;};_eedd ,_acdfb :=_ee .CreateTemp ("","\u0078o\u0062\u006a\u0065\u0063\u0074");if _acdfb !=nil {return _acdfb ;};defer _eedd .Close ();_ ,_acdfb =_eedd .Write (_eecc .Stream );
if _acdfb !=nil {return _acdfb ;};_eecc .Lazy =true ;_eecc .Stream =nil ;_eecc .TempFile =_eedd .Name ();return nil ;};func _feg (_bga int )cryptFilters {return cryptFilters {_cbbd :_dfa .NewFilterV2 (_bga )}};

// Close closes the bufferedReadSeeker.
func (_db *bufferedReadSeeker )Close ()error {if _abd ,_abc :=_db ._add .(_eb .Closer );_abc {return _abd .Close ();};return nil ;};func (_feac *PdfParser )inspect ()(map[string ]int ,error ){_cbf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_cbf .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bgeg :=map[string ]int {};_dgab :=0;_dfga :=0;var _aeadf []int ;for _beadf :=range _feac ._dbbe .ObjectMap {_aeadf =append (_aeadf ,_beadf );};_d .Ints (_aeadf );_gcebdg :=0;
for _ ,_gefef :=range _aeadf {_fega :=_feac ._dbbe .ObjectMap [_gefef ];if _fega .ObjectNumber ==0{continue ;};_dgab ++;_cbf .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_cbf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_fega .ObjectNumber );
_aafd ,_gddc :=_feac .LookupByNumber (_fega .ObjectNumber );if _gddc !=nil {_cbf .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_fega .ObjectNumber ,_gddc );
_dfga ++;continue ;};_cbf .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_aafd );_fbbgg ,_fefb :=_aafd .(*PdfIndirectObject );if _fefb {_cbf .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_fega .ObjectNumber ,_fbbgg );
_gaba ,_dgcg :=_fbbgg .PdfObject .(*PdfObjectDictionary );if _dgcg {if _cgaab ,_dgfea :=_gaba .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dgfea {_aegcf :=string (*_cgaab );_cbf .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_aegcf );
_ ,_baca :=_bgeg [_aegcf ];if _baca {_bgeg [_aegcf ]++;}else {_bgeg [_aegcf ]=1;};}else if _dgfeab ,_ggded :=_gaba .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ggded {_dgae :=string (*_dgfeab );_cbf .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_dgae );
_ ,_gdcc :=_bgeg [_dgae ];if _gdcc {_bgeg [_dgae ]++;}else {_bgeg [_dgae ]=1;};};if _geeg ,_ffffa :=_gaba .Get ("\u0053").(*PdfObjectName );_ffffa &&*_geeg =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_fgbf :=_bgeg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _fgbf {_bgeg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_bgeg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _dgfef ,_gdbaa :=_aafd .(*PdfObjectStream );_gdbaa {if _adbb ,_faec :=_dgfef .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_faec {_cbf .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_adbb );_cbdaec :=string (*_adbb );_bgeg [_cbdaec ]++;};}else {_fgdd ,_ffad :=_aafd .(*PdfObjectDictionary );
if _ffad {_feff ,_ababd :=_fgdd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _ababd {_egad :=string (*_feff );_cbf .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_egad );_bgeg [_egad ]++;};};_cbf .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_fega .ObjectNumber ,_aafd );
};_gcebdg ++;};_cbf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_cbf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");
_cbf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_dgab );_cbf .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_dfga );for _fccec ,_gfdfb :=range _bgeg {_cbf .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_fccec ,_gfdfb );
};_cbf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_feac ._dbbe .ObjectMap )< 1{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_cg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_fceca ,_fbef :=_bgeg ["\u0046\u006f\u006e\u0074"];
if !_fbef ||_fceca < 2{_cbf .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_cbf .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _bgeg ,nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_aaegc *PdfObjectReference )Resolve ()PdfObject {if _aaegc ._ffbgd ==nil {return MakeNull ();};_ebgb ,_ ,_fbcea :=_aaegc ._ffbgd .resolveReference (_aaegc );if _fbcea !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_fbcea );
return MakeNull ();};if _ebgb ==nil {_cbf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _ebgb ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_bbgg :=&PdfObjectDictionary {};_bbgg ._gfed =map[PdfObjectName ]PdfObject {};_bbgg ._gdcb =[]PdfObjectName {};_bbgg ._aaae =&_cge .Mutex {};return _bbgg ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_gcbe Version )String ()string {return _cg .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_gcbe .Major ,_gcbe .Minor );};

// HeaderCommentBytes gets the header comment bytes.
func (_aba ParserMetadata )HeaderCommentBytes ()[4]byte {return _aba ._fede };

// Len returns the number of elements in the streams.
func (_gfba *PdfObjectStreams )Len ()int {if _gfba ==nil {return 0;};return len (_gfba ._adbf );};func (_acdfgc *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _acdfgc ._dfag {return nil ,_cg .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_acdfgc ._dfag =true ;_acdfgc ._cafb .Seek (0,_eb .SeekStart );_dgage :=20;_dbfc :=make ([]byte ,_dgage );_gbgg :=XrefTable {};_gbgg .ObjectMap =make (map[int ]XrefObject );for {_ebcbe ,_cgeaa :=_acdfgc ._cafb .ReadByte ();if _cgeaa !=nil {if _cgeaa ==_eb .EOF {break ;
}else {return nil ,_cgeaa ;};};if _ebcbe =='j'&&_dbfc [_dgage -1]=='b'&&_dbfc [_dgage -2]=='o'&&IsWhiteSpace (_dbfc [_dgage -3]){_cgef :=_dgage -4;for IsWhiteSpace (_dbfc [_cgef ])&&_cgef > 0{_cgef --;};if _cgef ==0||!IsDecimalDigit (_dbfc [_cgef ]){continue ;
};for IsDecimalDigit (_dbfc [_cgef ])&&_cgef > 0{_cgef --;};if _cgef ==0||!IsWhiteSpace (_dbfc [_cgef ]){continue ;};for IsWhiteSpace (_dbfc [_cgef ])&&_cgef > 0{_cgef --;};if _cgef ==0||!IsDecimalDigit (_dbfc [_cgef ]){continue ;};for IsDecimalDigit (_dbfc [_cgef ])&&_cgef > 0{_cgef --;
};if _cgef ==0{continue ;};_cafc :=_acdfgc .GetFileOffset ()-int64 (_dgage -_cgef );_bggc :=append (_dbfc [_cgef +1:],_ebcbe );_ffec ,_bcacb ,_bbdaa :=_gdbb (string (_bggc ));if _bbdaa !=nil {_cbf .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_bbdaa );
return nil ,_bbdaa ;};if _fcdc ,_bdaab :=_gbgg .ObjectMap [_ffec ];!_bdaab ||_fcdc .Generation <=_bcacb {_ebgcc :=XrefObject {};_ebgcc .XType =XrefTypeTableEntry ;_ebgcc .ObjectNumber =_ffec ;_ebgcc .Generation =_bcacb ;_ebgcc .Offset =_cafc ;_gbgg .ObjectMap [_ffec ]=_ebgcc ;
};};_dbfc =append (_dbfc [1:_dgage ],_ebcbe );};_acdfgc ._cfeeg =nil ;return &_gbgg ,nil ;};func _efbf (_eggca ,_beeb PdfObject ,_bbfga int )bool {if _bbfga > _ecfca {_cbf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ecfca );
return false ;};if _eggca ==nil &&_beeb ==nil {return true ;}else if _eggca ==nil ||_beeb ==nil {return false ;};if _a .TypeOf (_eggca )!=_a .TypeOf (_beeb ){return false ;};switch _eebg :=_eggca .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_eebg ==*(_beeb .(*PdfObjectName ));case *PdfObjectString :return *_eebg ==*(_beeb .(*PdfObjectString ));case *PdfObjectInteger :return *_eebg ==*(_beeb .(*PdfObjectInteger ));case *PdfObjectBool :return *_eebg ==*(_beeb .(*PdfObjectBool ));
case *PdfObjectFloat :return *_eebg ==*(_beeb .(*PdfObjectFloat ));case *PdfIndirectObject :return _efbf (TraceToDirectObject (_eggca ),TraceToDirectObject (_beeb ),_bbfga +1);case *PdfObjectArray :_cfcba :=_beeb .(*PdfObjectArray );if len ((*_eebg )._cbgc )!=len ((*_cfcba )._cbgc ){return false ;
};for _gggb ,_ecfb :=range (*_eebg )._cbgc {if !_efbf (_ecfb ,(*_cfcba )._cbgc [_gggb ],_bbfga +1){return false ;};};return true ;case *PdfObjectDictionary :_bcdf :=_beeb .(*PdfObjectDictionary );_agfdg ,_dafge :=(*_eebg )._gfed ,(*_bcdf )._gfed ;if len (_agfdg )!=len (_dafge ){return false ;
};for _cdfd ,_gfeb :=range _agfdg {_gcbb ,_faaed :=_dafge [_cdfd ];if !_faaed ||!_efbf (_gfeb ,_gcbb ,_bbfga +1){return false ;};};return true ;case *PdfObjectStream :_bedc :=_beeb .(*PdfObjectStream );return _efbf ((*_eebg ).PdfObjectDictionary ,(*_bedc ).PdfObjectDictionary ,_bbfga +1);
default:_cbf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_eggca );
};return false ;};

// GetFilterName returns the name of the encoding filter.
func (_cbbc *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_agaa string ;_dddf bool ;};

// UpdateParams updates the parameter values of the encoder.
func (_dded *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// Reset resets the buffered reader with a new io.Reader.
func (_fbec *bufferedReadSeeker )Reset (r _eb .Reader ){_fbec ._acg .Reset (r )};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ccba *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_cgcg :=MakeDict ();_cgcg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ccba .GetFilterName ()));return _cgcg ;};var _gcede =_df .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_gfdd *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_acff :=MakeDict ();_acff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gfdd .GetFilterName ()));return _acff ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfddg *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_ccge :=MakeDict ();_ccge .Set ("\u004b",MakeInteger (int64 (_gfddg .K )));_ccge .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gfddg .Columns )));if _gfddg .BlackIs1 {_ccge .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_gfddg .BlackIs1 ));
};if _gfddg .EncodedByteAlign {_ccge .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_gfddg .EncodedByteAlign ));};if _gfddg .EndOfLine &&_gfddg .K >=0{_ccge .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_gfddg .EndOfLine ));
};if _gfddg .Rows !=0&&!_gfddg .EndOfBlock {_ccge .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_gfddg .Rows )));};if !_gfddg .EndOfBlock {_ccge .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_gfddg .EndOfBlock ));
};if _gfddg .DamagedRowsBeforeError !=0{_ccge .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_gfddg .DamagedRowsBeforeError )));};return _ccge ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// Write outputs the PDF primitive as written to file as expected by the standard.
Write ()[]byte ;};type xrefType int ;

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_fdee int ,_afdf bool ){_eeeac ,_afdf :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _afdf &&_eeeac !=nil {return int (*_eeeac ),true ;};return 0,false ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdbc *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_ffgb :=TraceToDirectObject (streamObj .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _ffgb ==nil {return NewRawEncoder (),nil ;};if _ ,_gdbf :=_ffgb .(*PdfObjectNull );_gdbf {return NewRawEncoder (),nil ;
};_becg ,_fadg :=_ffgb .(*PdfObjectName );if !_fadg {_ffcc ,_fcdd :=_ffgb .(*PdfObjectArray );if !_fcdd {return nil ,_cg .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _ffcc .Len ()==0{return NewRawEncoder (),nil ;};if _ffcc .Len ()!=1{_cdaae ,_ccdg :=_gbfbc (streamObj );if _ccdg !=nil {_cbf .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_ccdg );
return nil ,_ccdg ;};_cbf .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_cdaae );return _cdaae ,nil ;};_ffgb =_ffcc .Get (0);_becg ,_fcdd =_ffgb .(*PdfObjectName );if !_fcdd {return nil ,_cg .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _bdgeg ,_fccf :=_fbeb .Load (_becg .String ());_fccf {return _bdgeg .(StreamEncoder ),nil ;};switch *_becg {case StreamEncodingFilterNameFlate :return _agc (streamObj ,nil );case StreamEncodingFilterNameLZW :return _agfa (streamObj ,nil );case StreamEncodingFilterNameDCT :return _bdea (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _befcb (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _agfd (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _bgee (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_cg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_becg );};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;Lazy bool ;TempFile string ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_aecfe *PdfObjectInteger ,_bgbbf bool ){_aecfe ,_bgbbf =TraceToDirectObject (obj ).(*PdfObjectInteger );return _aecfe ,_bgbbf ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_fgab *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ebbb :=_c .NewReader (encoded );var _cadg []byte ;for {_fbfe ,_cddd :=_ebbb .ReadByte ();if _cddd !=nil {return nil ,_cddd ;};if _fbfe > 128{_dbag ,_aac :=_ebbb .ReadByte ();
if _aac !=nil {return nil ,_aac ;};for _bccf :=0;_bccf < 257-int (_fbfe );_bccf ++{_cadg =append (_cadg ,_dbag );};}else if _fbfe < 128{for _aeea :=0;_aeea < int (_fbfe )+1;_aeea ++{_gcb ,_eaa :=_ebbb .ReadByte ();if _eaa !=nil {return nil ,_eaa ;};_cadg =append (_cadg ,_gcb );
};}else {break ;};};return _cadg ,nil ;};func (_agbag *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_agbag ._cafb .Seek (0,_eb .SeekStart );_cdaab :=20;_bgff :=make ([]byte ,_cdaab );for {_caffa ,_bgdae :=_agbag ._cafb .ReadByte ();if _bgdae !=nil {if _bgdae ==_eb .EOF {break ;
}else {return 0,0,_bgdae ;};};if IsDecimalDigit (_caffa )&&_bgff [_cdaab -1]=='.'&&IsDecimalDigit (_bgff [_cdaab -2])&&_bgff [_cdaab -3]=='-'&&_bgff [_cdaab -4]=='F'&&_bgff [_cdaab -5]=='D'&&_bgff [_cdaab -6]=='P'{_efad :=int (_bgff [_cdaab -2]-'0');_eagc :=int (_caffa -'0');
return _efad ,_eagc ,nil ;};_bgff =append (_bgff [1:_cdaab ],_caffa );};return 0,0,_be .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _acaf (o ,0,traversed );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cdag *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_acad :=MakeDict ();_acad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cdag .GetFilterName ()));_defb :=_cdag .MakeDecodeParams ();if _defb !=nil {_acad .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_defb );
};return _acad ;};func (_egfe *PdfParser )readTextLine ()(string ,error ){var _gbbe _c .Buffer ;for {_aeae ,_gbac :=_egfe ._cafb .Peek (1);if _gbac !=nil {_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gbac .Error ());return _gbbe .String (),_gbac ;
};if (_aeae [0]!='\r')&&(_aeae [0]!='\n'){_dada ,_ :=_egfe ._cafb .ReadByte ();_gbbe .WriteByte (_dada );}else {break ;};};return _gbbe .String (),nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_ddedc *PdfObjectStream ,_cgaa bool ){obj =ResolveReference (obj );_ddedc ,_cgaa =obj .(*PdfObjectStream );return _ddedc ,_cgaa ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_defe *PdfParser )GetObjectNums ()[]int {var _aefaf []int ;for _ ,_befgd :=range _defe ._dbbe .ObjectMap {_aefaf =append (_aefaf ,_befgd .ObjectNumber );};_d .Ints (_aefaf );return _aefaf ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_fbeb .Store (filterName ,customStreamEncoder );};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_bgea *PdfParser )SetFileOffset (offset int64 ){_bgea ._cafb .SetFileOffset (offset )};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bcee *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_acca *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_afadb :=_acca .Get (key );if _afadb ==nil {return "",false ;};_fffgf ,_ffbbd :=_afadb .(*PdfObjectString );if !_ffbbd {return "",false ;};return _fffgf .Str (),true ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};func (_afce *JBIG2Image )toBitmap ()(_gfbg *_cfb .Bitmap ,_fdbf error ){const _bddb ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _afce .Data ==nil {return nil ,_de .Error (_bddb ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _afce .Width ==0||_afce .Height ==0{return nil ,_de .Error (_bddb ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _afce .HasPadding {_gfbg ,_fdbf =_cfb .NewWithData (_afce .Width ,_afce .Height ,_afce .Data );}else {_gfbg ,_fdbf =_cfb .NewWithUnpaddedData (_afce .Width ,_afce .Height ,_afce .Data );};if _fdbf !=nil {return nil ,_de .Wrap (_fdbf ,_bddb ,"");};
return _gfbg ,nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_febg *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cbf .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_cbf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_febg .Predictor );
_ccgf ,_dgg :=_febg .DecodeBytes (streamObj .Stream );if _dgg !=nil {return nil ,_dgg ;};_cbf .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_cbf .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_ccgf ),_ccgf );
if _febg .Predictor > 1{if _febg .Predictor ==2{_cbf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_edb :=_febg .Columns *_febg .Colors ;if _edb < 1{return []byte {},nil ;};_afgce :=len (_ccgf )/_edb ;if len (_ccgf )%_edb !=0{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ccgf ),_edb );};if _edb %_febg .Colors !=0{return nil ,_cg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_edb ,_febg .Colors );
};if _edb > len (_ccgf ){_cbf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_edb ,len (_ccgf ));
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cbf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ccgf ),_ccgf );
_gadc :=_c .NewBuffer (nil );for _fcbe :=0;_fcbe < _afgce ;_fcbe ++{_gcae :=_ccgf [_edb *_fcbe :_edb *(_fcbe +1)];for _adfc :=_febg .Colors ;_adfc < _edb ;_adfc ++{_gcae [_adfc ]=byte (int (_gcae [_adfc ]+_gcae [_adfc -_febg .Colors ])%256);};_gadc .Write (_gcae );
};_caeg :=_gadc .Bytes ();_cbf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_caeg ),_caeg );return _caeg ,nil ;}else if _febg .Predictor >=10&&_febg .Predictor <=15{_cbf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_aede :=_febg .Columns *_febg .Colors +1;if _aede < 1{return []byte {},nil ;};_bcgg :=len (_ccgf )/_aede ;if len (_ccgf )%_aede !=0{return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ccgf ),_aede );
};if _aede > len (_ccgf ){_cbf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aede ,len (_ccgf ));
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fgbb :=_c .NewBuffer (nil );_cbf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_febg .Columns );
_cbf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ccgf ),_aede ,_bcgg );_gcaa :=make ([]byte ,_aede );for _fdeg :=0;_fdeg < _aede ;_fdeg ++{_gcaa [_fdeg ]=0;
};for _gccg :=0;_gccg < _bcgg ;_gccg ++{_bgb :=_ccgf [_aede *_gccg :_aede *(_gccg +1)];_dceb :=_bgb [0];switch _dceb {case 0:case 1:for _edgf :=2;_edgf < _aede ;_edgf ++{_bgb [_edgf ]=byte (int (_bgb [_edgf ]+_bgb [_edgf -1])%256);};case 2:for _dbde :=1;
_dbde < _aede ;_dbde ++{_bgb [_dbde ]=byte (int (_bgb [_dbde ]+_gcaa [_dbde ])%256);};default:_cbf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dceb );
return nil ,_cg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dceb );};for _dcce :=0;_dcce < _aede ;_dcce ++{_gcaa [_dcce ]=_bgb [_dcce ];};_fgbb .Write (_bgb [1:]);
};_gfc :=_fgbb .Bytes ();return _gfc ,nil ;}else {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_febg .Predictor );
return nil ,_cg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_febg .Predictor );};};return _ccgf ,nil ;};var _cfcfc =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");


// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cfdc *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_fgcd :=MakeDict ();_fgcd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfdc .GetFilterName ()));_fgcd .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cfdc .MakeDecodeParams ());
return _fgcd ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_ef *bufferedReadSeeker )ReadAtLeast (p []byte ,n int )(int ,error ){_ag :=n ;_bdb :=0;for _ag > 0{_ga ,_bca :=_ef .Read (p [n -_bdb :]);if _bca !=nil {return _bdb ,_bca ;};_bdb ++;_ag -=_ga ;};return _bdb ,nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_ddbec *PdfParser )GetXrefType ()*xrefType {return _ddbec ._ceca };

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_debad *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _agffd []int64 ;for _ ,_bbdce :=range _debad .Elements (){if _gbeg ,_gfdb :=_bbdce .(*PdfObjectInteger );_gfdb {_agffd =append (_agffd ,int64 (*_gbeg ));}else {return nil ,ErrTypeError ;
};};return _agffd ,nil ;};const _cbbd ="\u0053\u0074\u0064C\u0046";var (ErrUnsupportedEncodingParameters =_be .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_be .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_be .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_be .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_be .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_be .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_gf .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_be .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// Seek implementation of Seek interface.
func (_agff *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _bgf int64 ;switch whence {case _eb .SeekStart :_bgf =offset ;case _eb .SeekCurrent :_abbab ,_dbef :=_agff ._bdgd .Seek (0,_eb .SeekCurrent );if _dbef !=nil {return 0,_dbef ;
};_bgf =_abbab +offset ;case _eb .SeekEnd :_bgf =_agff ._abdb +offset ;};if _aaee :=_agff .getError (_bgf );_aaee !=nil {return 0,_aaee ;};if _ ,_dgda :=_agff ._bdgd .Seek (_bgf ,_eb .SeekStart );_dgda !=nil {return 0,_dgda ;};return _bgf ,nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_eedc *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_eedc .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
// renamed to String() as a pretty string to use in debugging etc.
func (_gegg *MultiEncoder )GetFilterName ()string {_dgfb :="";for _gebb ,_cecb :=range _gegg ._efaae {_dgfb +=_cecb .GetFilterName ();if _gebb < len (_gegg ._efaae )-1{_dgfb +="\u0020";};};return _dgfb ;};func _aef (_ddb *_ff .StdEncryptDict ,_dcf *PdfObjectDictionary ){_dcf .Set ("\u0052",MakeInteger (int64 (_ddb .R )));
_dcf .Set ("\u0050",MakeInteger (int64 (_ddb .P )));_dcf .Set ("\u004f",MakeStringFromBytes (_ddb .O ));_dcf .Set ("\u0055",MakeStringFromBytes (_ddb .U ));if _ddb .R >=5{_dcf .Set ("\u004f\u0045",MakeStringFromBytes (_ddb .OE ));_dcf .Set ("\u0055\u0045",MakeStringFromBytes (_ddb .UE ));
_dcf .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_ddb .EncryptMetadata ));if _ddb .R > 5{_dcf .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_ddb .Perms ));};};};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ccf *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fgde *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_degc *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _degc ._egef ==0{return nil ,_be .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _eced ,_cffce :=_degc ._cedbf [_degc ];
_cffce {return _eced ,nil ;};_fdff ,_geef :=_degc .GetPreviousRevisionReadSeeker ();if _geef !=nil {return nil ,_geef ;};_ggde ,_geef :=NewParser (_fdff );_ggde ._cedbf =_degc ._cedbf ;if _geef !=nil {return nil ,_geef ;};_degc ._cedbf [_degc ]=_ggde ;
return _ggde ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _cbedb ,_fcag :=obj .(*PdfObjectReference );_fcag {obj =_cbedb .Resolve ();};_afcdf ,_eadg :=obj .(*PdfIndirectObject );_feea :=0;for _eadg {obj =_afcdf .PdfObject ;_afcdf ,_eadg =GetIndirect (obj );
_feea ++;if _feea > _ecfca {_cbf .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_ecfca );
return nil ;};};return obj ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_cafd *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_cege :=n ;_eeea :=0;_addff :=0;for _cege > 0{_age ,_ddc :=_cafd ._cafb .Read (p [_eeea :]);if _ddc !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_age ,_addff ,_ddc .Error ());
return _eeea ,_be .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_addff ++;_eeea +=_age ;_cege -=_age ;};return _eeea ,nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _efbf (obj1 ,obj2 ,0)};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ebdd *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_abeb :=PdfIndirectObject {};_abeb ._ffbgd =_ebdd ;_cbf .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_bcfe ,_dcfaee :=_ebdd ._cafb .Peek (20);
if _dcfaee !=nil {if _dcfaee !=_eb .EOF {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_abeb ,_dcfaee ;
};};_cbf .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_bcfe ));_afbc :=_geffg .FindStringSubmatchIndex (string (_bcfe ));if len (_afbc )< 6{if _dcfaee ==_eb .EOF {return nil ,_dcfaee ;
};_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_bcfe ));
return &_abeb ,_be .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ebdd ._cafb .Discard (_afbc [0]);_cbf .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_afbc );_dbdda :=_afbc [1]-_afbc [0];_cbbf :=make ([]byte ,_dbdda );_ ,_dcfaee =_ebdd .ReadAtLeast (_cbbf ,_dbdda );if _dcfaee !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_dcfaee );
return nil ,_dcfaee ;};_cbf .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cbbf );_cbcd :=_geffg .FindStringSubmatch (string (_cbbf ));if len (_cbcd )< 3{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_cbbf ));
return &_abeb ,_be .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_bbfdf ,_ :=_g .Atoi (_cbcd [1]);_befda ,_ :=_g .Atoi (_cbcd [2]);_abeb .ObjectNumber =int64 (_bbfdf );_abeb .GenerationNumber =int64 (_befda );for {_fgfga ,_addg :=_ebdd ._cafb .Peek (2);if _addg !=nil {return &_abeb ,_addg ;};_cbf .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fgfga ),string (_fgfga ));
if IsWhiteSpace (_fgfga [0]){_ebdd .skipSpaces ();}else if _fgfga [0]=='%'{_ebdd .skipComments ();}else if (_fgfga [0]=='<')&&(_fgfga [1]=='<'){_cbf .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_abeb .PdfObject ,_addg =_ebdd .ParseDict ();
_cbf .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_addg );if _addg !=nil {return &_abeb ,_addg ;};_cbf .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_fgfga [0]=='/')||(_fgfga [0]=='(')||(_fgfga [0]=='[')||(_fgfga [0]=='<'){_abeb .PdfObject ,_addg =_ebdd .parseObject ();if _addg !=nil {return &_abeb ,_addg ;};_cbf .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _fgfga [0]==']'{_cbf .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_ebdd ._cafb .Discard (1);}else {if _fgfga [0]=='e'{_bfdgf ,_feab :=_ebdd .readTextLine ();if _feab !=nil {return nil ,_feab ;};if len (_bfdgf )>=6&&_bfdgf [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _fgfga [0]=='s'{_fgfga ,_ =_ebdd ._cafb .Peek (10);
if string (_fgfga [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cfcbfe :=6;if len (_fgfga )> 6{if IsWhiteSpace (_fgfga [_cfcbfe ])&&_fgfga [_cfcbfe ]!='\r'&&_fgfga [_cfcbfe ]!='\n'{_cbf .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_ebdd ._aefd ._bge =true ;_cfcbfe ++;};switch _fgfga [_cfcbfe ]{case '\r':_cfcbfe ++;if _fgfga [_cfcbfe ]=='\n'{_cfcbfe ++;};case '\n':_cfcbfe ++;default:_ebdd ._aefd ._bge =true ;};};_ebdd ._cafb .Discard (_cfcbfe );_dcfdd ,_cbdf :=_abeb .PdfObject .(*PdfObjectDictionary );
if !_cbdf {return nil ,_be .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_cbf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_dcfdd );
_afced ,_fcfe :=_ebdd .traceStreamLength (_dcfdd .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _fcfe !=nil {_cbf .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_fcfe );
return nil ,_fcfe ;};_cbf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_afced );_ddcfc ,_ebfga :=_afced .(*PdfObjectInteger );if !_ebfga {return nil ,_be .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_gfac :=*_ddcfc ;if _gfac < 0{return nil ,_be .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_ggaf :=_ebdd .GetFileOffset ();
_ccbgd :=_ebdd .xrefNextObjectOffset (_ggaf );if _ggaf +int64 (_gfac )> _ccbgd &&_ccbgd > _ggaf {_cbf .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_ggaf +int64 (_gfac ));_cbf .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ccbgd );
_aaca :=_ccbgd -_ggaf -17;if _aaca < 0{return nil ,_be .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_cbf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_aaca );_gfac =PdfObjectInteger (_aaca );
_dcfdd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_aaca ));};if int64 (_gfac )> _ebdd ._eacd {_cbf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_be .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_aaeg :=make ([]byte ,_gfac );
_ ,_fcfe =_ebdd .ReadAtLeast (_aaeg ,int (_gfac ));if _fcfe !=nil {_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_aaeg ),_aaeg );_cbf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcfe );
return nil ,_fcfe ;};_bcffa :=PdfObjectStream {};_bcffa .Stream =_aaeg ;_bcffa .PdfObjectDictionary =_abeb .PdfObject .(*PdfObjectDictionary );_bcffa .ObjectNumber =_abeb .ObjectNumber ;_bcffa .GenerationNumber =_abeb .GenerationNumber ;_bcffa .PdfObjectReference ._ffbgd =_ebdd ;
_ebdd .skipSpaces ();_ebdd ._cafb .Discard (9);_ebdd .skipSpaces ();return &_bcffa ,nil ;};};_abeb .PdfObject ,_addg =_ebdd .parseObject ();if _abeb .PdfObject ==nil {_cbf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_abeb .PdfObject =MakeNull ();};return &_abeb ,_addg ;};};if _abeb .PdfObject ==nil {_cbf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_abeb .PdfObject =MakeNull ();};_cbf .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_abeb ,nil ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_cged *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cbf .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_cbf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cged .Predictor );
if _cged .BitsPerComponent !=8{return nil ,_cg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_cged .BitsPerComponent );
};_bbe ,_cdbf :=_cged .DecodeBytes (streamObj .Stream );if _cdbf !=nil {return nil ,_cdbf ;};_bbe ,_cdbf =_cged .postDecodePredict (_bbe );if _cdbf !=nil {return nil ,_cdbf ;};return _bbe ,nil ;};func (_efbb *PdfObjectFloat )String ()string {return _cg .Sprintf ("\u0025\u0066",*_efbb )};


// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_gfed map[PdfObjectName ]PdfObject ;_gdcb []PdfObjectName ;_aaae *_cge .Mutex ;_aecd *PdfParser ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_fgeaa *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_dbdd ,_begg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _begg ==nil {_fgeaa .BitsPerComponent =int (_dbdd );
};_babc ,_begg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _begg ==nil {_fgeaa .Width =int (_babc );};_dbbb ,_begg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _begg ==nil {_fgeaa .Height =int (_dbbb );
};_bffa ,_begg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _begg ==nil {_fgeaa .ColorComponents =int (_bffa );};};

// String returns a string representation of the *PdfObjectString.
func (_bcfb *PdfObjectString )String ()string {return _bcfb ._agaa };func (_bfg *PdfCrypt )decryptBytes (_efedb []byte ,_fccg string ,_bff []byte )([]byte ,error ){_cbf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_acdf ,_adaf :=_bfg ._aab [_fccg ];if !_adaf {return nil ,_cg .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fccg );};return _acdf .DecryptBytes (_efedb ,_bff );};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ddg *bufferedReadSeeker )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_ddg .Seek (offset ,_eb .SeekStart );};var _fc =_cge .Pool {New :func ()interface{}{return new (_c .Buffer )}};func (_gcg *PdfCrypt )loadCryptFilters (_bfba *PdfObjectDictionary )error {_gcg ._aab =cryptFilters {};
_gba :=_bfba .Get ("\u0043\u0046");_gba =TraceToDirectObject (_gba );if _adcf ,_fegb :=_gba .(*PdfObjectReference );_fegb {_bfe ,_agfe :=_gcg ._fbb .LookupByReference (*_adcf );if _agfe !=nil {_cbf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _agfe ;};_gba =TraceToDirectObject (_bfe );};_eg ,_dgfc :=_gba .(*PdfObjectDictionary );if !_dgfc {_cbf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_gba );return _be .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_ddbd :=range _eg .Keys (){_feeg :=_eg .Get (_ddbd );if _ebaa ,_dfbb :=_feeg .(*PdfObjectReference );_dfbb {_decb ,_abeg :=_gcg ._fbb .LookupByReference (*_ebaa );if _abeg !=nil {_cbf .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _abeg ;};_feeg =TraceToDirectObject (_decb );};_gbbb ,_eebc :=_feeg .(*PdfObjectDictionary );if !_eebc {return _cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_ddbd ,_feeg );
};if _ddbd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _bfde _dfa .FilterDict ;if _ebga :=_fff (&_bfde ,_gbbb );_ebga !=nil {return _ebga ;};_abdf ,_ec :=_dfa .NewFilter (_bfde );if _ec !=nil {return _ec ;};_gcg ._aab [string (_ddbd )]=_abdf ;};_gcg ._aab ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_dfa .NewIdentity ();
_gcg ._eda ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _abgg ,_gce :=_bfba .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_gce {if _ ,_cef :=_gcg ._aab [string (*_abgg )];!_cef {return _cg .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_abgg );
};_gcg ._eda =string (*_abgg );};_gcg ._ebbf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gdf ,_bbd :=_bfba .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_bbd {if _ ,_dfc :=_gcg ._aab [string (*_gdf )];!_dfc {return _cg .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gdf );
};_gcg ._ebbf =string (*_gdf );};return nil ;};

// Write outputs the object as it is to be written to file.
func (_bfccaf *PdfObjectName )Write ()[]byte {return _bef (func (_dgdg *_c .Buffer ){if len (*_bfccaf )> 127{_cbf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_bfccaf );
};_dgdg .WriteString ("\u002f");for _aabbf :=0;_aabbf < len (*_bfccaf );_aabbf ++{_caagb :=(*_bfccaf )[_aabbf ];if !IsPrintable (_caagb )||_caagb =='#'||IsDelimiter (_caagb ){_cg .Fprintf (_dgdg ,"\u0023\u0025\u002e2\u0078",_caagb );}else {_dgdg .WriteByte (_caagb );
};};});};var _caag =_df .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_cfbb *MultiEncoder )GetFilterArray ()*PdfObjectArray {_baga :=make ([]PdfObject ,len (_cfbb ._efaae ));for _fddb ,_gece :=range _cfbb ._efaae {_baga [_fddb ]=MakeName (_gece .GetFilterName ());};return MakeArray (_baga ...);};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_fcde *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cgea :=encoded ;var _fgae error ;for _ ,_ccbg :=range _fcde ._efaae {_cbf .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_ccbg ,_ccbg );
_cgea ,_fgae =_ccbg .DecodeBytes (_cgea );if _fgae !=nil {return nil ,_fgae ;};};return _cgea ,nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_ebbcb []float64 ,_gbec error ){for _ ,_cbbde :=range objects {_defd ,_ebcc :=GetNumberAsFloat (_cbbde );if _ebcc !=nil {return nil ,_ebcc ;};_ebbcb =append (_ebbcb ,_defd );};return _ebbcb ,nil ;};

// Write outputs the object as it is to be written to file.
func (_efbbg *PdfObjectArray )Write ()[]byte {return _bef (func (_dacg *_c .Buffer ){_dacg .WriteString ("\u005b");for _ffdc ,_adfd :=range _efbbg .Elements (){_dacg .Write (_adfd .Write ());if _ffdc < (_efbbg .Len ()-1){_dacg .WriteString ("\u0020");};
};_dacg .WriteString ("\u005d");});};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// String returns a string describing `streams`.
func (_gbdg *PdfObjectStreams )String ()string {return _cg .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_gbdg .ObjectNumber );};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_eedda *PdfObjectString ,_gbfdf bool ){_eedda ,_gbfdf =TraceToDirectObject (obj ).(*PdfObjectString );return _eedda ,_gbfdf ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_adbf :objects };};const _dbac =6;var _bfcef =_df .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_dcde *PdfParser )GetPreviousRevisionReadSeeker ()(_eb .ReadSeeker ,error ){if _ebgdgd :=_dcde .seekToEOFMarker (_dcde ._eacd -_dbac );_ebgdgd !=nil {return nil ,_ebgdgd ;};_efff ,_fagb :=_dcde ._cafb .Seek (0,_eb .SeekCurrent );if _fagb !=nil {return nil ,_fagb ;
};_efff +=_dbac ;return _bgcca (_dcde ._cafb ,_efff );};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// GetFilterName returns the name of the encoding filter.
func (_gbaf *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };const (_bag =0;_bfbg =1;_agbd =2;_eafc =3;_gbfb =4;);var _eaegb =map[byte ][]byte {'\n':[]byte ("\u005c\u006e"),'\r':[]byte ("\u005c\u0072"),'\t':[]byte ("\u005c\u0074"),'\b':[]byte ("\u005c\u0062"),'\f':[]byte ("\u005c\u0066"),'(':[]byte ("\u005c\u0028"),')':[]byte ("\u005c\u0029"),'\\':[]byte ("\u005c\u005c")};


// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_fcc *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_abg ,_ ,_gbe :=_fcc .lookupByNumberWrapper (objNumber ,true );return _abg ,_gbe ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_bdaf *PdfObjectName ,_gdcdb bool ){_bdaf ,_gdcdb =TraceToDirectObject (obj ).(*PdfObjectName );return _bdaf ,_gdcdb ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bdf *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bdf .isDecrypted (obj ){return nil ;};switch _aebee :=obj .(type ){case *PdfIndirectObject :_bdf ._bedd [_aebee ]=true ;_cbf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_aebee .ObjectNumber ,_aebee .GenerationNumber );
_adde :=_aebee .ObjectNumber ;_ced :=_aebee .GenerationNumber ;_fed :=_bdf .Decrypt (_aebee .PdfObject ,_adde ,_ced );if _fed !=nil {return _fed ;};return nil ;case *PdfObjectStream :_bdf ._bedd [_aebee ]=true ;_aga :=_aebee .PdfObjectDictionary ;if _bdf ._baa .R !=5{if _fbbg ,_deb :=_aga .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_deb &&*_fbbg =="\u0058\u0052\u0065\u0066"{return nil ;};};_decf :=_aebee .ObjectNumber ;_dcbg :=_aebee .GenerationNumber ;_cbf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_decf ,_dcbg );
_cgb :=_cbbd ;if _bdf ._eegf .V >=4{_cgb =_bdf ._ebbf ;_cbf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bdf ._ebbf );if _dffd ,_abed :=_aga .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_abed {if _fcb ,_gfg :=GetName (_dffd .Get (0));_gfg {if *_fcb =="\u0043\u0072\u0079p\u0074"{_cgb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cfge ,_cedb :=_aga .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_cedb {if _fbg ,_fge :=_cfge .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fge {if _ ,_bcg :=_bdf ._aab [string (*_fbg )];_bcg {_cbf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_fbg );
_cgb =string (*_fbg );};};};};};};_cbf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cgb );if _cgb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_edae :=_bdf .Decrypt (_aga ,_decf ,_dcbg );
if _edae !=nil {return _edae ;};_ffbd ,_edae :=_bdf .makeKey (_cgb ,uint32 (_decf ),uint32 (_dcbg ),_bdf ._beaf );if _edae !=nil {return _edae ;};_aebee .Stream ,_edae =_bdf .decryptBytes (_aebee .Stream ,_cgb ,_ffbd );if _edae !=nil {return _edae ;};_aga .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aebee .Stream ))));
return nil ;case *PdfObjectString :_cbf .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_aefe :=_cbbd ;if _bdf ._eegf .V >=4{_cbf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bdf ._eda );
if _bdf ._eda =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_aefe =_bdf ._eda ;};_edeb ,_cfca :=_bdf .makeKey (_aefe ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bdf ._beaf );if _cfca !=nil {return _cfca ;};_gbg :=_aebee .Str ();
_gaee :=make ([]byte ,len (_gbg ));for _gefg :=0;_gefg < len (_gbg );_gefg ++{_gaee [_gefg ]=_gbg [_gefg ];};if len (_gaee )> 0{_cbf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_gaee ,_gaee );
_gaee ,_cfca =_bdf .decryptBytes (_gaee ,_aefe ,_edeb );if _cfca !=nil {return _cfca ;};};_aebee ._agaa =string (_gaee );return nil ;case *PdfObjectArray :for _ ,_cfd :=range _aebee .Elements (){_cea :=_bdf .Decrypt (_cfd ,parentObjNum ,parentGenNum );
if _cea !=nil {return _cea ;};};return nil ;case *PdfObjectDictionary :_bgd :=false ;if _fgb :=_aebee .Get ("\u0054\u0079\u0070\u0065");_fgb !=nil {_fgcb ,_badf :=_fgb .(*PdfObjectName );if _badf &&*_fgcb =="\u0053\u0069\u0067"{_bgd =true ;};};for _ ,_acb :=range _aebee .Keys (){_ddge :=_aebee .Get (_acb );
if _bgd &&string (_acb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_acb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_acb )!="\u0050\u0072\u0065\u0076"&&string (_acb )!="\u004c\u0061\u0073\u0074"{_cfde :=_bdf .Decrypt (_ddge ,parentObjNum ,parentGenNum );
if _cfde !=nil {return _cfde ;};};};return nil ;};return nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_ebgdg *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _bcba ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _aae :=_ebgdg .AddPageImage (img ,&_ebgdg .DefaultPageSettings );
_aae !=nil {return nil ,_de .Wrap (_aae ,_bcba ,"");};return _ebgdg .Encode ();};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_cebge *PdfObjectStreams ,_gdae bool ){_cebge ,_gdae =obj .(*PdfObjectStreams );return _cebge ,_gdae ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_cbf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_ggec ,_ecaff :=NewEncoderFromStream (streamObj );if _ecaff !=nil {_cbf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ecaff );
return _ecaff ;};if _aaed ,_gdaa :=_ggec .(*LZWEncoder );_gdaa {_aaed .EarlyChange =0;streamObj .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_cbf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_ggec );
_bgab ,_ecaff :=_ggec .EncodeBytes (streamObj .Stream );if _ecaff !=nil {_cbf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ecaff );return _ecaff ;
};streamObj .Stream =_bgab ;streamObj .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bgab ))));return nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_aeda *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _aeda .isEncrypted (obj ){return nil ;};switch _gfa :=obj .(type ){case *PdfIndirectObject :_aeda ._defg [_gfa ]=true ;_cbf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_gfa .ObjectNumber ,_gfa .GenerationNumber );
_gca :=_gfa .ObjectNumber ;_afd :=_gfa .GenerationNumber ;_fdf :=_aeda .Encrypt (_gfa .PdfObject ,_gca ,_afd );if _fdf !=nil {return _fdf ;};return nil ;case *PdfObjectStream :_aeda ._defg [_gfa ]=true ;_bcae :=_gfa .PdfObjectDictionary ;if _cdg ,_ebgaf :=_bcae .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_ebgaf &&*_cdg =="\u0058\u0052\u0065\u0066"{return nil ;};_dbaa :=_gfa .ObjectNumber ;_egd :=_gfa .GenerationNumber ;_cbf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dbaa ,_egd );
_gbgd :=_cbbd ;if _aeda ._eegf .V >=4{_gbgd =_aeda ._ebbf ;_cbf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_aeda ._ebbf );if _fgfd ,_dbc :=_bcae .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_dbc {if _afc ,_ceba :=GetName (_fgfd .Get (0));_ceba {if *_afc =="\u0043\u0072\u0079p\u0074"{_gbgd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cgba ,_acbe :=_bcae .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_acbe {if _bdg ,_bcc :=_cgba .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bcc {if _ ,_ggc :=_aeda ._aab [string (*_bdg )];_ggc {_cbf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_bdg );
_gbgd =string (*_bdg );};};};};};};_cbf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gbgd );if _gbgd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bfa :=_aeda .Encrypt (_gfa .PdfObjectDictionary ,_dbaa ,_egd );
if _bfa !=nil {return _bfa ;};_cfaa ,_bfa :=_aeda .makeKey (_gbgd ,uint32 (_dbaa ),uint32 (_egd ),_aeda ._beaf );if _bfa !=nil {return _bfa ;};_gfa .Stream ,_bfa =_aeda .encryptBytes (_gfa .Stream ,_gbgd ,_cfaa );if _bfa !=nil {return _bfa ;};_bcae .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gfa .Stream ))));
return nil ;case *PdfObjectString :_cbf .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_dcfa :=_cbbd ;if _aeda ._eegf .V >=4{_cbf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aeda ._eda );
if _aeda ._eda =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_dcfa =_aeda ._eda ;};_gbea ,_bffd :=_aeda .makeKey (_dcfa ,uint32 (parentObjNum ),uint32 (parentGenNum ),_aeda ._beaf );if _bffd !=nil {return _bffd ;};_bfc :=_gfa .Str ();
_bcec :=make ([]byte ,len (_bfc ));for _edee :=0;_edee < len (_bfc );_edee ++{_bcec [_edee ]=_bfc [_edee ];};_cbf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bcec ,_bcec );
_bcec ,_bffd =_aeda .encryptBytes (_bcec ,_dcfa ,_gbea );if _bffd !=nil {return _bffd ;};_gfa ._agaa =string (_bcec );return nil ;case *PdfObjectArray :for _ ,_ggge :=range _gfa .Elements (){_eaga :=_aeda .Encrypt (_ggge ,parentObjNum ,parentGenNum );if _eaga !=nil {return _eaga ;
};};return nil ;case *PdfObjectDictionary :_fec :=false ;if _cfgb :=_gfa .Get ("\u0054\u0079\u0070\u0065");_cfgb !=nil {_ggb ,_fbba :=_cfgb .(*PdfObjectName );if _fbba &&*_ggb =="\u0053\u0069\u0067"{_fec =true ;};};for _ ,_fgd :=range _gfa .Keys (){_gad :=_gfa .Get (_fgd );
if _fec &&string (_fgd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fgd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fgd )!="\u0050\u0072\u0065\u0076"&&string (_fgd )!="\u004c\u0061\u0073\u0074"{_ceg :=_aeda .Encrypt (_gad ,parentObjNum ,parentGenNum );
if _ceg !=nil {return _ceg ;};};};return nil ;};return nil ;};

// String returns a string describing `array`.
func (_egda *PdfObjectArray )String ()string {_cbbeb :="\u005b";for _ceeb ,_bebf :=range _egda .Elements (){_cbbeb +=_bebf .String ();if _ceeb < (_egda .Len ()-1){_cbbeb +="\u002c\u0020";};};_cbbeb +="\u005d";return _cbbeb ;};func _ae ()*_c .Buffer {return _fc .Get ().(*_c .Buffer )};


// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_gbdf *PdfObjectString )IsHexadecimal ()bool {return _gbdf ._dddf };

// Append appends PdfObject(s) to the array.
func (_dece *PdfObjectArray )Append (objects ...PdfObject ){if _dece ==nil {_cbf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_dece ._cbgc =append (_dece ._cbgc ,objects ...);};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_cbgc :objects }};

// Write outputs the object as it is to be written to file.
func (_gbbd *PdfObjectDictionary )Write ()[]byte {var _fbbc _c .Buffer ;_fbbc .WriteString ("\u003c\u003c");for _ ,_becfa :=range _gbbd ._gdcb {_dbfda :=_gbbd ._gfed [_becfa ];_fbbc .Write (_becfa .Write ());_fbbc .WriteString ("\u0020");_fbbc .Write (_dbfda .Write ());
};_fbbc .WriteString ("\u003e\u003e");return _fbbc .Bytes ();};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func _gbb (_cec *_ff .StdEncryptDict ,_fdc *PdfObjectDictionary )error {R ,_bfbc :=_fdc .Get ("\u0052").(*PdfObjectInteger );if !_bfbc {return _be .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_cec .R =int (*R );O ,_bfbc :=_fdc .GetString ("\u004f");if !_bfbc {return _be .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _cec .R ==5||_cec .R ==6{if len (O )< 48{return _cg .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _cg .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_cec .O =[]byte (O );U ,_bfbc :=_fdc .GetString ("\u0055");if !_bfbc {return _be .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _cec .R ==5||_cec .R ==6{if len (U )< 48{return _cg .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_cbf .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_cec .U =[]byte (U );if _cec .R >=5{OE ,_ccdb :=_fdc .GetString ("\u004f\u0045");
if !_ccdb {return _be .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _cg .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_cec .OE =[]byte (OE );UE ,_ccdb :=_fdc .GetString ("\u0055\u0045");if !_ccdb {return _be .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _cg .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_cec .UE =[]byte (UE );};P ,_bfbc :=_fdc .Get ("\u0050").(*PdfObjectInteger );if !_bfbc {return _be .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_cec .P =_ff .Permissions (*P );if _cec .R ==6{Perms ,_ffd :=_fdc .GetString ("\u0050\u0065\u0072m\u0073");if !_ffd {return _be .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _cg .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_cec .Perms =[]byte (Perms );};if _cfc ,_adgg :=_fdc .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_adgg {_cec .EncryptMetadata =bool (*_cfc );}else {_cec .EncryptMetadata =true ;};return nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_cadc *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _ffce ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _cadc .ColorComponents !=1||_cadc .BitsPerComponent !=1{return nil ,_de .Errorf (_ffce ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_abggf *_cfb .Bitmap ;_ffag error ;);_dedf :=(_cadc .Width *_cadc .Height )==len (data );if _dedf {_abggf ,_ffag =_cfb .NewWithUnpaddedData (_cadc .Width ,_cadc .Height ,data );}else {_abggf ,_ffag =_cfb .NewWithData (_cadc .Width ,_cadc .Height ,data );
};if _ffag !=nil {return nil ,_ffag ;};_afcf :=_cadc .DefaultPageSettings ;if _ffag =_afcf .Validate ();_ffag !=nil {return nil ,_de .Wrap (_ffag ,_ffce ,"");};if _cadc ._eaab ==nil {_cadc ._eaab =_bc .InitEncodeDocument (_afcf .FileMode );};switch _afcf .Compression {case JB2Generic :if _ffag =_cadc ._eaab .AddGenericPage (_abggf ,_afcf .DuplicatedLinesRemoval );
_ffag !=nil {return nil ,_de .Wrap (_ffag ,_ffce ,"");};case JB2SymbolCorrelation :return nil ,_de .Error (_ffce ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_de .Error (_ffce ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_de .Error (_ffce ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _cadc .Encode ();};

// GetFilterName returns the name of the encoding filter.
func (_fcec *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func _gdbb (_caff string )(int ,int ,error ){_eab :=_geffg .FindStringSubmatch (_caff );if len (_eab )< 3{return 0,0,_be .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_aebb ,_ :=_g .Atoi (_eab [1]);_eddd ,_ :=_g .Atoi (_eab [2]);return _aebb ,_eddd ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_fded ParserMetadata )HasOddLengthHexStrings ()bool {return _fded ._dcc };

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_ffbgd *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_geffb *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _agbc []float64 ;for _ ,_aceb :=range _geffb .Elements (){_afda ,_egee :=GetNumberAsFloat (TraceToDirectObject (_aceb ));if _egee !=nil {return nil ,_cg .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_agbc =append (_agbc ,_afda );};return _agbc ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bfaeb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_eecbd :=MakeDict ();_eecbd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_bfaeb .GetFilterArray ());for _ ,_gcec :=range _bfaeb ._efaae {_feegg :=_gcec .MakeStreamDict ();for _ ,_cffca :=range _feegg .Keys (){_cfee :=_feegg .Get (_cffca );
if _cffca !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_cffca !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_eecbd .Set (_cffca ,_cfee );};};};_fgaa :=_bfaeb .MakeDecodeParams ();if _fgaa !=nil {_eecbd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fgaa );
};return _eecbd ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fgbc *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ddda []int ;for _ ,_cbbge :=range _fgbc .Elements (){if _dddbd ,_gaea :=_cbbge .(*PdfObjectInteger );_gaea {_ddda =append (_ddda ,int (*_dddbd ));}else {return nil ,ErrTypeError ;};};return _ddda ,nil ;
};func (_dfcb *PdfParser )checkLinearizedInformation (_cgbe *PdfObjectDictionary )(bool ,error ){var _bbfea error ;_dfcb ._dad ,_bbfea =GetNumberAsInt64 (_cgbe .Get ("\u004c"));if _bbfea !=nil {return false ,_bbfea ;};_bbfea =_dfcb .seekToEOFMarker (_dfcb ._dad );
switch _bbfea {case nil :return true ,nil ;case _aagc :return false ,nil ;default:return false ,_bbfea ;};};

// GetFilterName returns the name of the encoding filter.
func (_fdegg *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// PdfVersion returns version of the PDF file.
func (_agcgg *PdfParser )PdfVersion ()Version {return _agcgg ._aaga };func (_dce *PdfCrypt )isEncrypted (_efb PdfObject )bool {_ ,_aefb :=_dce ._defg [_efb ];if _aefb {_cbf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_cbf .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func _agfa (_cgc *PdfObjectStream ,_effg *PdfObjectDictionary )(*LZWEncoder ,error ){_gfgc :=NewLZWEncoder ();
_gea :=_cgc .PdfObjectDictionary ;if _gea ==nil {return _gfgc ,nil ;};if _effg ==nil {_ege :=TraceToDirectObject (_gea .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _ege !=nil {if _bcece ,_gcgfb :=_ege .(*PdfObjectDictionary );
_gcgfb {_effg =_bcece ;}else if _fdbg ,_efa :=_ege .(*PdfObjectArray );_efa {if _fdbg .Len ()==1{if _aaac ,_gbef :=GetDict (_fdbg .Get (0));_gbef {_effg =_aaac ;};};};if _effg ==nil {_cbf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_ege );
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_aagb :=_gea .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _aagb !=nil {_baaf ,_eec :=_aagb .(*PdfObjectInteger );
if !_eec {_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_aagb );
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_baaf !=0&&*_baaf !=1{return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_gfgc .EarlyChange =int (*_baaf );}else {_gfgc .EarlyChange =1;};if _effg ==nil {return _gfgc ,nil ;};if _ccdd ,_bafd :=GetIntVal (_effg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_bafd {if _ccdd ==0||_ccdd ==1{_gfgc .EarlyChange =_ccdd ;
}else {_cbf .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_ccdd );};};_aagb =_effg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _aagb !=nil {_caa ,_bbfd :=_aagb .(*PdfObjectInteger );if !_bbfd {_cbf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_aagb );
return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gfgc .Predictor =int (*_caa );};_aagb =_effg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _aagb !=nil {_ceee ,_cbc :=_aagb .(*PdfObjectInteger );if !_cbc {_cbf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_cg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gfgc .BitsPerComponent =int (*_ceee );};if _gfgc .Predictor > 1{_gfgc .Columns =1;_aagb =_effg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _aagb !=nil {_cbfe ,_ccgb :=_aagb .(*PdfObjectInteger );if !_ccgb {return nil ,_cg .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gfgc .Columns =int (*_cbfe );
};_gfgc .Colors =1;_aagb =_effg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _aagb !=nil {_dabf ,_cfeb :=_aagb .(*PdfObjectInteger );if !_cfeb {return nil ,_cg .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_gfgc .Colors =int (*_dabf );};};_cbf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_effg .String ());return _gfgc ,nil ;};const (DefaultJPEGQuality =75;);func (_cgfe *PdfCrypt )checkAccessRights (_bded []byte )(bool ,_ff .Permissions ,error ){_ceb :=_cgfe .securityHandler ();
_bcd ,_bddc ,_afa :=_ceb .Authenticate (&_cgfe ._baa ,_bded );if _afa !=nil {return false ,0,_afa ;}else if _bddc ==0||len (_bcd )==0{return false ,0,nil ;};return true ,_bddc ,nil ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_eegf encryptDict ;_baa _ff .StdEncryptDict ;_fee string ;_beaf []byte ;_bedd map[PdfObject ]bool ;_defg map[PdfObject ]bool ;_cbdg bool ;_aab cryptFilters ;_ebbf string ;_eda string ;_fbb *PdfParser ;_ede map[int ]struct{};};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_eeec :=MultiEncoder {};_eeec ._efaae =[]StreamEncoder {};return &_eeec ;};

// Write outputs the object as it is to be written to file.
func (_ecgf *PdfObjectStream )Write ()[]byte {return _bef (func (_agcgc *_c .Buffer ){_agcgc .WriteString (_g .FormatInt (_ecgf .ObjectNumber ,10));_agcgc .WriteString ("\u0020\u0030\u0020\u0052");});};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aeeg *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_cdcce :=MakeDict ();_cdcce .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aeeg .GetFilterName ()));return _cdcce ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_ded *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ded .DecodeBytes (streamObj .Stream );};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_fdfb *JBIG2Image )ToGoImage ()(_ac .Image ,error ){const _ecef ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _fdfb .Data ==nil {return nil ,_de .Error (_ecef ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _fdfb .Width ==0||_fdfb .Height ==0{return nil ,_de .Error (_ecef ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_agaf ,_cgec :=_cgg .NewImage (_fdfb .Width ,_fdfb .Height ,1,1,_fdfb .Data ,nil ,nil );if _cgec !=nil {return nil ,_cgec ;};return _agaf ,nil ;};

// DecodeStream implements ASCII hex decoding.
func (_eecb *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eecb .DecodeBytes (streamObj .Stream );};

// Clear resets the array to an empty state.
func (_ebgga *PdfObjectArray )Clear (){_ebgga ._cbgc =[]PdfObject {}};func _fgeaaf (_adafd ,_abec ,_bcdca int )error {if _abec < 0||_abec > _adafd {return _be .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _bcdca < _abec {return _be .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bcdca > _adafd {return _be .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// IsTextWriteDirectionLTR returns `true` if string write direction Left To Right.
// detect string write direction using golang.org/x/text/unicode/bidi library.
func IsTextWriteDirectionLTR (str string )bool {_fgfdf :=func (_gbcfb rune )bool {return _gbcfb =='\u000A'};_ccdcc :=_dg .TrimFunc (str ,_fgfdf );_fafdb :=_fb .Paragraph {};_ ,_ebef :=_fafdb .SetString (_ccdcc );if _ebef !=nil {return true ;};_bbddg ,_ebef :=_fafdb .Order ();
if _ebef !=nil {return true ;};if _bbddg .NumRuns ()< 1{return true ;};return _fafdb .IsLeftToRight ();};func (_bcdc *PdfParser )seekToEOFMarker (_cfdbc int64 )error {var _gadg int64 ;var _dfed int64 =2048;for _gadg < _cfdbc -4{if _cfdbc <=(_dfed +_gadg ){_dfed =_cfdbc -_gadg ;
};_ ,_dfeda :=_bcdc ._cafb .Seek (_cfdbc -_gadg -_dfed ,_eb .SeekStart );if _dfeda !=nil {return _dfeda ;};_cfgaff :=make ([]byte ,_dfed );_bcdc ._cafb .Read (_cfgaff );_cbf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_cfgaff ));
_bcff :=_bfag .FindAllStringIndex (string (_cfgaff ),-1);if _bcff !=nil {_gfef :=_bcff [len (_bcff )-1];_cbf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_bcff );_gcgb :=_cfdbc -_gadg -_dfed +int64 (_gfef [0]);_bcdc ._cafb .Seek (_gcgb ,_eb .SeekStart );
return nil ;};_cbf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_gadg +=_dfed -4;};_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _aagc ;};const _ecfca =10;


// Write outputs the object as it is to be written to file.
func (_adafa *PdfObjectBool )Write ()[]byte {if *_adafa {return []byte ("\u0074\u0072\u0075\u0065");};return []byte ("\u0066\u0061\u006cs\u0065");};func (_fdgc *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_ebggc ,_cfaaa :=_fdgc ._cafb .Seek (0,_eb .SeekEnd );
if _cfaaa !=nil {return nil ,_cfaaa ;};var _gaged int64 ;var _beafd int64 =2048;for _gaged < _ebggc -4{if _ebggc <=(_beafd +_gaged ){_beafd =_ebggc -_gaged ;};_ ,_dafa :=_fdgc ._cafb .Seek (_gaged ,_eb .SeekStart );if _dafa !=nil {return nil ,_dafa ;};
_cfaac :=make ([]byte ,_beafd );_ ,_dafa =_fdgc ._cafb .Read (_cfaac );if _dafa !=nil {return nil ,_dafa ;};_cbf .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_cfaac ));
_bfef :=_geffg .FindAllStringIndex (string (_cfaac ),-1);if _bfef !=nil {_ddbdd :=_bfef [0];_cbf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_bfef );_ ,_cbfa :=_fdgc ._cafb .Seek (int64 (_ddbdd [0]),_eb .SeekStart );if _cbfa !=nil {return nil ,_cbfa ;
};_fdgc ._cafb ._acg =_fg .NewReader (_fdgc ._cafb ._add );_cbcb ,_cbfa :=_fdgc .ParseIndirectObject ();if _cbfa !=nil {return nil ,nil ;};if _dfdac ,_edeac :=GetIndirect (_cbcb );_edeac {if _dgfe ,_acfeg :=GetDict (_dfdac .PdfObject );_acfeg {if _cbcc :=_dgfe .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_cbcc !=nil {return _dgfe ,nil ;};return nil ,nil ;};};return nil ,nil ;};_gaged +=_beafd -4;};return nil ,_be .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};type bufferedReadSeeker struct{_add _eb .ReadSeeker ;_acg *_fg .Reader ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_aebae *PdfObjectArray )Get (i int )PdfObject {if _aebae ==nil ||i >=len (_aebae ._cbgc )||i < 0{return nil ;};return _aebae ._cbgc [i ];};func _bed (_aeb PdfObject )(int64 ,int64 ,error ){if _daf ,_fgc :=_aeb .(*PdfIndirectObject );_fgc {return _daf .ObjectNumber ,_daf .GenerationNumber ,nil ;
};if _ddee ,_bfb :=_aeb .(*PdfObjectStream );_bfb {return _ddee .ObjectNumber ,_ddee .GenerationNumber ,nil ;};return 0,0,_be .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");
};func (_fgdeg *PdfParser )getNumbersOfUpdatedObjects (_bbff *PdfParser )([]int ,error ){if _bbff ==nil {return nil ,_be .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_bgda :=_bbff ._eacd ;_ggdag :=make ([]int ,0);_acfde :=make (map[int ]interface{});_cfbdd :=make (map[int ]int64 );for _bgbac ,_aecc :=range _fgdeg ._dbbe .ObjectMap {if _aecc .Offset ==0{if _aecc .OsObjNumber !=0{if _eaec ,_gacac :=_fgdeg ._dbbe .ObjectMap [_aecc .OsObjNumber ];
_gacac {_acfde [_aecc .OsObjNumber ]=struct{}{};_cfbdd [_bgbac ]=_eaec .Offset ;}else {return nil ,_be .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_cfbdd [_bgbac ]=_aecc .Offset ;};
};for _fdedd ,_aacd :=range _cfbdd {if _ ,_dacc :=_acfde [_fdedd ];_dacc {continue ;};if _aacd > _bgda {_ggdag =append (_ggdag ,_fdedd );};};return _ggdag ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_gfaec *PdfObjectBool ,_eecdf bool ){_gfaec ,_eecdf =TraceToDirectObject (obj ).(*PdfObjectBool );return _gfaec ,_eecdf ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// EncodeBytes encodes data into ASCII85 encoded format.
func (_deab *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _gecf _c .Buffer ;for _dfae :=0;_dfae < len (data );_dfae +=4{_adbe :=data [_dfae ];_edda :=1;_ceeg :=byte (0);if _dfae +1< len (data ){_ceeg =data [_dfae +1];_edda ++;};_beag :=byte (0);
if _dfae +2< len (data ){_beag =data [_dfae +2];_edda ++;};_addb :=byte (0);if _dfae +3< len (data ){_addb =data [_dfae +3];_edda ++;};_ffaf :=(uint32 (_adbe )<<24)|(uint32 (_ceeg )<<16)|(uint32 (_beag )<<8)|uint32 (_addb );if _ffaf ==0{_gecf .WriteByte ('z');
}else {_badfb :=_deab .base256Tobase85 (_ffaf );for _ ,_ggca :=range _badfb [:_edda +1]{_gecf .WriteByte (_ggca +'!');};};};_gecf .WriteString ("\u007e\u003e");return _gecf .Bytes (),nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_cbgc []PdfObject };func (_fgca *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fcdfea :=MakeArray ();_fgca ._cafb .ReadByte ();for {_fgca .skipSpaces ();_fdg ,_ddba :=_fgca ._cafb .Peek (1);if _ddba !=nil {return _fcdfea ,_ddba ;
};if _fdg [0]==']'{_fgca ._cafb .ReadByte ();break ;};_beea ,_ddba :=_fgca .parseObject ();if _ddba !=nil {return _fcdfea ,_ddba ;};_fcdfea .Append (_beea );};return _fcdfea ,nil ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_gedf :=MakeArray ();for _ ,_aaadb :=range vals {_gedf .Append (MakeInteger (int64 (_aaadb )));};return _gedf ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_ebbd :=&PdfCrypt {_cbdg :false ,_bedd :make (map[PdfObject ]bool ),_defg :make (map[PdfObject ]bool ),_ede :make (map[int ]struct{}),_fbb :parser };_fad ,_cae :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_cae {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _ebbd ,_be .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_fad !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_cbf .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_fad );
return _ebbd ,_be .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_ebbd ._eegf .Filter =string (*_fad );if _dfca ,_fbd :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_fbd {_ebbd ._eegf .SubFilter =_dfca .Str ();
_cbf .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_dfca );};if L ,_aed :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_aed {if (*L %8)!=0{_cbf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _ebbd ,_be .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_ebbd ._eegf .Length =int (*L );}else {_ebbd ._eegf .Length =40;};_ebbd ._eegf .V =0;if _gdc ,_fde :=ed .Get ("\u0056").(*PdfObjectInteger );
_fde {V :=int (*_gdc );_ebbd ._eegf .V =V ;if V >=1&&V <=2{_ebbd ._aab =_feg (_ebbd ._eegf .Length );}else if V >=4&&V <=5{if _ggd :=_ebbd .loadCryptFilters (ed );_ggd !=nil {return _ebbd ,_ggd ;};}else {_cbf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _ebbd ,_be .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _cgf :=_gbb (&_ebbd ._baa ,ed );_cgf !=nil {return _ebbd ,_cgf ;};_cfg :="";if _ccg ,_dff :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_dff &&_ccg .Len ()>=1{_egc ,_ccc :=GetString (_ccg .Get (0));if !_ccc {return _ebbd ,_be .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_cfg =_egc .Str ();}else {_cbf .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_ebbd ._fee =_cfg ;return _ebbd ,nil ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_fbeg *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fbeg .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_ecdc *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ecdc ._adbf ){return _be .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ecdc ._adbf [i ]=obj ;return nil ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_gbgb :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_gbgb .PdfObjectDictionary =encoder .MakeStreamDict ();_dbbeff ,_agacc :=encoder .EncodeBytes (contents );
if _agacc !=nil {return nil ,_agacc ;};_gbgb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dbbeff ))));_gbgb .Stream =_dbbeff ;return _gbgb ,nil ;};

// Append appends PdfObject(s) to the streams.
func (_fafdf *PdfObjectStreams )Append (objects ...PdfObject ){if _fafdf ==nil {_cbf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_fafdf ._adbf =append (_fafdf ._adbf ,objects ...);};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_ged *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_aegb :=MakeDict ();_aegb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ged .GetFilterName ()));return _aegb ;};func (_faf *PdfParser )parseDetailedHeader ()(_bddf error ){_faf ._cafb .Seek (0,_eb .SeekStart );
_bcge :=20;_eagb :=make ([]byte ,_bcge );var (_bcaee bool ;_cdca int ;);for {_eeaf ,_adb :=_faf ._cafb .ReadByte ();if _adb !=nil {if _adb ==_eb .EOF {break ;}else {return _adb ;};};if IsDecimalDigit (_eeaf )&&_eagb [_bcge -1]=='.'&&IsDecimalDigit (_eagb [_bcge -2])&&_eagb [_bcge -3]=='-'&&_eagb [_bcge -4]=='F'&&_eagb [_bcge -5]=='D'&&_eagb [_bcge -6]=='P'&&_eagb [_bcge -7]=='%'{_faf ._aaga =Version {Major :int (_eagb [_bcge -2]-'0'),Minor :int (_eeaf -'0')};
_faf ._aefd ._bbag =_cdca -7;_bcaee =true ;break ;};_cdca ++;_eagb =append (_eagb [1:_bcge ],_eeaf );};if !_bcaee {return _cg .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_eead ,_bddf :=_faf ._cafb .ReadByte ();
if _bddf ==_eb .EOF {return _cg .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _bddf !=nil {return _bddf ;};_faf ._aefd ._fce =_eead =='\n';_eead ,_bddf =_faf ._cafb .ReadByte ();
if _bddf !=nil {return _cg .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_bddf );};if _eead !='%'{return nil ;};_defc :=make ([]byte ,4);_ ,_bddf =_faf ._cafb .Read (_defc );
if _bddf !=nil {return _cg .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_bddf );};_faf ._aefd ._fede =[4]byte {_defc [0],_defc [1],_defc [2],_defc [3]};
return nil ;};func (_egfdd *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_egfdd ._dbbe .ObjectMap =make (map[int ]XrefObject );_egfdd ._cacf =make (objectStreams );_feec ,_ddbca :=_egfdd ._cafb .Seek (0,_eb .SeekEnd );if _ddbca !=nil {return nil ,_ddbca ;
};_cbf .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_feec );_egfdd ._eacd =_feec ;_ddbca =_egfdd .seekToEOFMarker (_feec );if _ddbca !=nil {_cbf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_ddbca );
return nil ,_ddbca ;};_edgbd ,_ddbca :=_egfdd ._cafb .Seek (0,_eb .SeekCurrent );if _ddbca !=nil {return nil ,_ddbca ;};var _fgdb int64 =64;_efcc :=_edgbd -_fgdb ;if _efcc < 0{_efcc =0;};_ ,_ddbca =_egfdd ._cafb .Seek (_efcc ,_eb .SeekStart );if _ddbca !=nil {return nil ,_ddbca ;
};_ggda :=make ([]byte ,_fgdb );_ ,_ddbca =_egfdd ._cafb .Read (_ggda );if _ddbca !=nil {_cbf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_ddbca );
return nil ,_ddbca ;};_eebfc :=_caag .FindStringSubmatch (string (_ggda ));if len (_eebfc )< 2{_cbf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_be .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_eebfc )> 2{_cbf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ggda );
return nil ,_be .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_afcad ,_ :=_g .ParseInt (_eebfc [1],10,64);_cbf .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_afcad );
if _afcad > _feec {_cbf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_cbf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_afcad ,_ddbca =_egfdd .repairLocateXref ();if _ddbca !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_ddbca ;};};_egfdd ._cafb .Seek (_afcad ,_eb .SeekStart );_fbda ,_ddbca :=_egfdd .parseXref ();if _ddbca !=nil {return nil ,_ddbca ;};_efef :=_fbda .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _efef !=nil {_acdd ,_ddgg :=_efef .(*PdfObjectInteger );
if !_ddgg {return nil ,_be .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_ddbca =_egfdd .parseXrefStream (_acdd );if _ddbca !=nil &&_egfdd .Opts !=nil &&!_egfdd .Opts .RelaxedMode {return nil ,_ddbca ;};};
var _ebgcd []int64 ;_cggbd :=func (_abgd int64 ,_dcdf []int64 )bool {for _ ,_eaeg :=range _dcdf {if _eaeg ==_abgd {return true ;};};return false ;};_efef =_fbda .Get ("\u0050\u0072\u0065\u0076");for _efef !=nil {_gdea ,_fbbda :=_efef .(*PdfObjectInteger );
if !_fbbda {_cbf .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_efef );
return _fbda ,nil ;};_gecfe :=*_gdea ;_cbf .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_gecfe );_egfdd ._cafb .Seek (int64 (_gecfe ),_eb .SeekStart );
_eecfa ,_dbfe :=_egfdd .parseXref ();if _dbfe !=nil {_cbf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_cbf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_egfdd ._faae =append (_egfdd ._faae ,int64 (_gecfe ));
_efef =_eecfa .Get ("\u0050\u0072\u0065\u0076");if _efef !=nil {_dcgd :=*(_efef .(*PdfObjectInteger ));if _cggbd (int64 (_dcgd ),_ebgcd ){_cbf .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_ebgcd =append (_ebgcd ,int64 (_dcgd ));};};return _fbda ,nil ;};func _fff (_gfe *_dfa .FilterDict ,_bbf *PdfObjectDictionary )error {if _dgb ,_dfb :=_bbf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dfb {if _bdd :=string (*_dgb );_bdd !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_cbf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_bdd );
};};_cggg ,_fag :=_bbf .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_fag {return _cg .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_gfe .CFM =string (*_cggg );if _fagd ,_bab :=_bbf .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_bab {_gfe .AuthEvent =_ff .AuthEvent (*_fagd );}else {_gfe .AuthEvent =_ff .EventDocOpen ;};if _bad ,_bg :=_bbf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_bg {_gfe .Length =int (*_bad );};return nil ;};func (_gcde *PdfCrypt )generateParams (_faa ,_fgec []byte )error {_dfe :=_gcde .securityHandler ();_ffeg ,_acc :=_dfe .GenerateParams (&_gcde ._baa ,_fgec ,_faa );if _acc !=nil {return _acc ;};_gcde ._beaf =_ffeg ;
return nil ;};

// SetImage sets the image base for given flate encoder.
func (_caee *FlateEncoder )SetImage (img *_cgg .ImageBase ){_caee ._ccgd =img };

// String returns the state of the bool as "true" or "false".
func (_dbcc *PdfObjectBool )String ()string {if *_dbcc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_ddad *PdfParser )GetCrypter ()*PdfCrypt {return _ddad ._dfabf };

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_cgab *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _cbd .DecodeBytes (encoded ,_fbe .Parameters {},_cgab .Globals );};func _ddcg ()string {return _cbf .Version };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_aceg string ,_dcgdf bool ){_gbeaf ,_dcgdf :=TraceToDirectObject (obj ).(*PdfObjectName );if _dcgdf {return string (*_gbeaf ),true ;};return ;};func (_baba *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_eb .SeekStart {offset +=_baba ._efcf ;
};_dfef ,_abde :=_baba ._ffba .Seek (offset ,whence );if _abde !=nil {return _dfef ,_abde ;};if whence ==_eb .SeekCurrent {_dfef -=_baba ._efcf ;};if _dfef < 0{return 0,_be .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _dfef ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdde *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_aaga Version ;_cafb *bufferedReadSeeker ;_eacd int64 ;_dbbe XrefTable ;_afcca int64 ;_ceca *xrefType ;_cacf objectStreams ;_eaaf *PdfObjectDictionary ;_dfabf *PdfCrypt ;_facb *PdfIndirectObject ;_dfag bool ;ObjCache objectCache ;
_cfeeg map[int ]bool ;_bbec map[int64 ]bool ;_aefd ParserMetadata ;_bfbgb bool ;_faae []int64 ;_egef int ;_egac bool ;_dad int64 ;_cedbf map[*PdfParser ]*PdfParser ;_gddf []*PdfParser ;

// Opts holds different parsing options.
Opts *ParserOpts ;};

// DecodeStream implements ASCII85 stream decoding.
func (_afe *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _afe .DecodeBytes (streamObj .Stream );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aefa *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fage *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _bdba []float64 ;for _ ,_ccbbd :=range _fage .Elements (){switch _gebga :=_ccbbd .(type ){case *PdfObjectInteger :_bdba =append (_bdba ,float64 (*_gebga ));case *PdfObjectFloat :_bdba =append (_bdba ,float64 (*_gebga ));
default:return nil ,ErrTypeError ;};};return _bdba ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_adcac *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// UpdateParams updates the parameter values of the encoder.
func (_ffge *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_aff ,_fcf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fcf ==nil {_ffge .ColorComponents =int (_aff );};_edcf ,_fcf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _fcf ==nil {_ffge .BitsPerComponent =int (_edcf );};_dee ,_fcf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fcf ==nil {_ffge .Width =int (_dee );};_gccca ,_fcf :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));
if _fcf ==nil {_ffge .Height =int (_gccca );};_bdedf ,_fcf :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _fcf ==nil {_ffge .Quality =int (_bdedf );};_fbcb ,_adfg :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _adfg {_ffge .Decode ,_fcf =_fbcb .ToFloat64Array ();if _fcf !=nil {_cbf .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_fcf );
};};};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_ccca :=MakeArray ();for _ ,_acbfb :=range vals {_ccca .Append (MakeInteger (_acbfb ));};return _ccca ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ade []XrefObject ;};func (_geed *PdfParser )parseName ()(PdfObjectName ,error ){var _ecfde _c .Buffer ;_ccbac :=false ;for {_bgfc ,_eecf :=_geed ._cafb .Peek (1);if _eecf ==_eb .EOF {break ;};if _eecf !=nil {return PdfObjectName (_ecfde .String ()),_eecf ;
};if !_ccbac {switch _bgfc [0]{case '/':_ccbac =true ;_geed ._cafb .ReadByte ();case '%':_geed .readComment ();_geed .skipSpaces ();default:_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_bgfc ,_bgfc );
return PdfObjectName (_ecfde .String ()),_cg .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_bgfc [0]);};}else {if IsWhiteSpace (_bgfc [0]){break ;}else if (_bgfc [0]=='/')||(_bgfc [0]=='[')||(_bgfc [0]=='(')||(_bgfc [0]==']')||(_bgfc [0]=='<')||(_bgfc [0]=='>'){break ;
}else if _bgfc [0]=='#'{_gge ,_efbd :=_geed ._cafb .Peek (3);if _efbd !=nil {return PdfObjectName (_ecfde .String ()),_efbd ;};_fgagg ,_efbd :=_cf .DecodeString (string (_gge [1:3]));if _efbd !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_ecfde .WriteByte ('#');_geed ._cafb .Discard (1);continue ;};_geed ._cafb .Discard (3);_ecfde .Write (_fgagg );}else {_debe ,_ :=_geed ._cafb .ReadByte ();_ecfde .WriteByte (_debe );};};};return PdfObjectName (_ecfde .String ()),nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_fcce []byte ,_fefc bool ){_eeee ,_fefc :=TraceToDirectObject (obj ).(*PdfObjectString );if _fefc {return _eeee .Bytes (),true ;};return ;};type limitedReadSeeker struct{_bdgd _eb .ReadSeeker ;_abdb int64 ;};

// Peek returns the next n bytes from the buffered reader without advancing the reader.
func (_ca *bufferedReadSeeker )Peek (n int )([]byte ,error ){return _ca ._acg .Peek (n )};

// Write outputs the object as it is to be written to file.
func (_accd *PdfIndirectObject )Write ()[]byte {return _bef (func (_ccbf *_c .Buffer ){_ccbf .WriteString (_g .FormatInt (_accd .ObjectNumber ,10));_ccbf .WriteString ("\u0020\u0030\u0020\u0052");});};func _agfd (_bfbga *PdfObjectStream ,_cdbd *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_ebbe :=NewCCITTFaxEncoder ();
_affd :=_bfbga .PdfObjectDictionary ;if _affd ==nil {return _ebbe ,nil ;};if _cdbd ==nil {_gcdeg :=TraceToDirectObject (_affd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gcdeg !=nil {switch _cgdc :=_gcdeg .(type ){case *PdfObjectDictionary :_cdbd =_cgdc ;
case *PdfObjectArray :if _cgdc .Len ()==1{if _bae ,_cbba :=GetDict (_cgdc .Get (0));_cbba {_cdbd =_bae ;};};default:_cbf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gcdeg );
return nil ,_be .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cdbd ==nil {_cbf .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gcdeg );
return nil ,_be .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fbag ,_bgcc :=GetNumberAsInt64 (_cdbd .Get ("\u004b"));_bgcc ==nil {_ebbe .K =int (_fbag );};if _gbcg ,_aeeb :=GetNumberAsInt64 (_cdbd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_aeeb ==nil {_ebbe .Columns =int (_gbcg );}else {_ebbe .Columns =1728;};if _fbac ,_eccf :=GetNumberAsInt64 (_cdbd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eccf ==nil {_ebbe .BlackIs1 =_fbac > 0;}else {if _fadb ,_cbbe :=GetBoolVal (_cdbd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_cbbe {_ebbe .BlackIs1 =_fadb ;}else {if _eeaff ,_ddgc :=GetArray (_cdbd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ddgc {_dabd ,_bfcb :=_eeaff .ToIntegerArray ();if _bfcb ==nil {_ebbe .BlackIs1 =_dabd [0]==1&&_dabd [1]==0;};};};};if _gdcf ,_gbcc :=GetNumberAsInt64 (_cdbd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_gbcc ==nil {_ebbe .EncodedByteAlign =_gdcf > 0;}else {if _adeed ,_gdaf :=GetBoolVal (_cdbd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gdaf {_ebbe .EncodedByteAlign =_adeed ;};};if _cefb ,_acba :=GetNumberAsInt64 (_cdbd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_acba ==nil {_ebbe .EndOfLine =_cefb > 0;}else {if _fcff ,_bafg :=GetBoolVal (_cdbd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bafg {_ebbe .EndOfLine =_fcff ;};};if _efcd ,_egbd :=GetNumberAsInt64 (_cdbd .Get ("\u0052\u006f\u0077\u0073"));
_egbd ==nil {_ebbe .Rows =int (_efcd );};_ebbe .EndOfBlock =true ;if _aace ,_aeba :=GetNumberAsInt64 (_cdbd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_aeba ==nil {_ebbe .EndOfBlock =_aace > 0;}else {if _agbdf ,_fgcbf :=GetBoolVal (_cdbd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_fgcbf {_ebbe .EndOfBlock =_agbdf ;};};if _ecgd ,_abba :=GetNumberAsInt64 (_cdbd .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_abba !=nil {_ebbe .DamagedRowsBeforeError =int (_ecgd );
};_cbf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cdbd .String ());return _ebbe ,nil ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_ggba *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dcbgd ,_fdd :=_geg .NewDecoder (encoded ,_geg .DecodeOptions {Columns :_ggba .Columns ,Rows :_ggba .Rows ,K :_ggba .K ,EncodedByteAligned :_ggba .EncodedByteAlign ,BlackIsOne :_ggba .BlackIs1 ,EndOfBlock :_ggba .EndOfBlock ,EndOfLine :_ggba .EndOfLine ,DamagedRowsBeforeError :_ggba .DamagedRowsBeforeError });
if _fdd !=nil {return nil ,_fdd ;};_bfcc ,_fdd :=_eb .ReadAll (_dcbgd );if _fdd !=nil {return nil ,_fdd ;};return _bfcc ,nil ;};type objectStreams map[int ]objectStream ;

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_ebbc *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_bdbd error ){const _dgfg ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _ebbc ==nil {return _de .Error (_dgfg ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_ebbc .DefaultPageSettings ;};if _ebbc ._eaab ==nil {_ebbc ._eaab =_bc .InitEncodeDocument (settings .FileMode );
};if _bdbd =settings .Validate ();_bdbd !=nil {return _de .Wrap (_bdbd ,_dgfg ,"");};_dcdcc ,_bdbd :=img .toBitmap ();if _bdbd !=nil {return _de .Wrap (_bdbd ,_dgfg ,"");};switch settings .Compression {case JB2Generic :if _bdbd =_ebbc ._eaab .AddGenericPage (_dcdcc ,settings .DuplicatedLinesRemoval );
_bdbd !=nil {return _de .Wrap (_bdbd ,_dgfg ,"");};case JB2SymbolCorrelation :return _de .Error (_dgfg ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _de .Error (_dgfg ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _de .Error (_dgfg ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func _bgee (_gecd *PdfObjectStream ,_fbdg *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _ebd ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_afbg :=NewJBIG2Encoder ();_bgag :=_gecd .PdfObjectDictionary ;if _bgag ==nil {return _afbg ,nil ;};if _fbdg ==nil {_fegc :=_bgag .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _fegc !=nil {switch _cefgf :=_fegc .(type ){case *PdfObjectDictionary :_fbdg =_cefgf ;
case *PdfObjectArray :if _cefgf .Len ()==1{if _ebaac ,_ccdfc :=GetDict (_cefgf .Get (0));_ccdfc {_fbdg =_ebaac ;};};default:_cbf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_fegc );
return nil ,_de .Errorf (_ebd ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_cefgf );};};};if _fbdg ==nil {return _afbg ,nil ;};_afbg .UpdateParams (_fbdg );
_bggd ,_adbec :=GetStream (_fbdg .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_adbec {return _afbg ,nil ;};var _gggf error ;_afbg .Globals ,_gggf =_cbd .DecodeGlobals (_bggd .Stream );if _gggf !=nil {_gggf =_de .Wrap (_gggf ,_ebd ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_cbf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gggf );return nil ,_gggf ;};return _afbg ,nil ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_bffg :=&DCTEncoder {};_bffg .ColorComponents =3;_bffg .BitsPerComponent =8;_bffg .Quality =DefaultJPEGQuality ;_bffg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _bffg ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cbf .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_ggbb ,_deed :=NewEncoderFromStream (streamObj );if _deed !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_deed );
return nil ,_deed ;};_cbf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_ggbb );_eafa ,_deed :=_ggbb .DecodeStream (streamObj );if _deed !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_deed );
return nil ,_deed ;};return _eafa ,nil ;};

// Write outputs the object as it is to be written to file.
func (_fafd *PdfObjectString )Write ()[]byte {return _bef (func (_eccfd *_c .Buffer ){if _fafd ._dddf {_adff :=_cf .EncodeToString (_fafd .Bytes ());_eccfd .Grow (len (_adff )+2);_eccfd .WriteString ("\u003c");_eccfd .WriteString (_adff );_eccfd .WriteString ("\u003e");
return ;};_eccfd .Grow (len (_fafd ._agaa )+len (_fafd ._agaa )/5+2);_eccfd .WriteString ("\u0028");for _afge :=0;_afge < len (_fafd ._agaa );_afge ++{_cfbba :=_fafd ._agaa [_afge ];if _cffd ,_fdfg :=_eaegb [_cfbba ];_fdfg {_eccfd .Write (_cffd );}else {_eccfd .WriteByte (_cfbba );
};};_eccfd .WriteString ("\u0029");});};

// Len returns the number of elements in the array.
func (_ebcg *PdfObjectArray )Len ()int {if _ebcg ==nil {return 0;};return len (_ebcg ._cbgc );};

// GetRevisionNumber returns the current version of the Pdf document.
func (_ddcc *PdfParser )GetRevisionNumber ()int {return _ddcc ._egef };var _fbeb _cge .Map ;func _gacg (_dbe uint ,_gcaab ,_fcea float64 )float64 {_adcab :=_bee .RoundFloat ((float64 (_dbe )/255.0),6);_fbbb :=_bee .RoundFloat ((_fcea -_gcaab )*_adcab ,6);
return _bee .RoundFloat ((_gcaab +_fbbb )*255.0,6);};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfdg *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };func _bef (_af func (*_c .Buffer ))[]byte {_ad :=_ae ();defer _cc (_ad );_af (_ad );_dd :=_ad .Bytes ();_aaf :=make ([]byte ,len (_dd ));copy (_aaf ,_dd );return _aaf ;};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_gfdf *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_adcc :=_gfdf ._egef ;if _adcc ==revisionNumber {return _gfdf ,nil ;};if _adcc < revisionNumber {return nil ,_be .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _gfdf ._gddf [revisionNumber ]!=nil {return _gfdf ._gddf [revisionNumber ],nil ;};_eege :=_gfdf ;for ;_adcc > revisionNumber ;_adcc --{_bbcg ,_bcgdd :=_eege .GetPreviousRevisionParser ();if _bcgdd !=nil {return nil ,_bcgdd ;};_gfdf ._gddf [_adcc -1]=_bbcg ;
_gfdf ._cedbf [_eege ]=_bbcg ;_eege =_bbcg ;};return _eege ,nil ;};func _fcac (_cgeg *PdfObjectDictionary )(_gcgcb *_cgg .ImageBase ){var (_bbbf *PdfObjectInteger ;_dabc bool ;);if _bbbf ,_dabc =_cgeg .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_dabc {_gcgcb =&_cgg .ImageBase {Width :int (*_bbbf )};}else {return nil ;};if _bbbf ,_dabc =_cgeg .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_dabc {_gcgcb .Height =int (*_bbbf );};if _bbbf ,_dabc =_cgeg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_dabc {_gcgcb .BitsPerComponent =int (*_bbbf );};if _bbbf ,_dabc =_cgeg .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_dabc {_gcgcb .ColorComponents =int (*_bbbf );};return _gcgcb ;};func (_egecg *PdfObjectDictionary )setWithLock (_egdde PdfObjectName ,_bgbb PdfObject ,_geab bool ){if _geab {_egecg ._aaae .Lock ();
defer _egecg ._aaae .Unlock ();};_ ,_aecef :=_egecg ._gfed [_egdde ];if !_aecef {_egecg ._gdcb =append (_egecg ._gdcb ,_egdde );};_egecg ._gfed [_egdde ]=_bgbb ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _deca :=obj .(type ){case *PdfObjectFloat :return float64 (*_deca ),nil ;case *PdfObjectInteger :return float64 (*_deca ),nil ;case *PdfObjectReference :_ddfec :=TraceToDirectObject (obj );
return GetNumberAsFloat (_ddfec );case *PdfIndirectObject :return GetNumberAsFloat (_deca .PdfObject );};return 0,ErrNotANumber ;};func (_gaab *PdfParser )traceStreamLength (_ecge PdfObject )(PdfObject ,error ){_daba ,_eacf :=_ecge .(*PdfObjectReference );
if _eacf {_cdbe ,_bcdeb :=_gaab ._bbec [_daba .ObjectNumber ];if _bcdeb &&_cdbe {_cbf .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_be .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_gaab ._bbec [_daba .ObjectNumber ]=true ;};_dbbc ,_cebbb :=_gaab .Resolve (_ecge );if _cebbb !=nil {return nil ,_cebbb ;
};_cbf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_dbbc );if _eacf {_gaab ._bbec [_daba .ObjectNumber ]=false ;};return _dbbc ,nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_eaab :_bc .InitEncodeDocument (false )}};func (_ggcb *PdfParser )parseHexString ()(*PdfObjectString ,error ){_ggcb ._cafb .ReadByte ();var _gbed _c .Buffer ;for {_ffbag ,_eaea :=_ggcb ._cafb .Peek (1);
if _eaea !=nil {return MakeString (""),_eaea ;};if _ffbag [0]=='>'{_ggcb ._cafb .ReadByte ();break ;};_begc ,_ :=_ggcb ._cafb .ReadByte ();if _ggcb ._bfbgb {if _c .IndexByte (_cfcfc ,_begc )==-1{_ggcb ._aefd ._gcca =true ;};};if !IsWhiteSpace (_begc ){_gbed .WriteByte (_begc );
};};if _gbed .Len ()%2==1{_ggcb ._aefd ._dcc =true ;_gbed .WriteRune ('0');};_ebbdf ,_ :=_cf .DecodeString (_gbed .String ());return MakeHexString (string (_ebbdf )),nil ;};func (_dafg *PdfCrypt )securityHandler ()_ff .StdHandler {if _dafg ._baa .R >=5{return _ff .NewHandlerR6 ();
};return _ff .NewHandlerR4 (_dafg ._fee ,_dafg ._eegf .Length );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fffg *LZWEncoder )MakeDecodeParams ()PdfObject {if _fffg .Predictor > 1{_bfeg :=MakeDict ();_bfeg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fffg .Predictor )));if _fffg .BitsPerComponent !=8{_bfeg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fffg .BitsPerComponent )));
};if _fffg .Columns !=1{_bfeg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fffg .Columns )));};if _fffg .Colors !=1{_bfeg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fffg .Colors )));};return _bfeg ;};return nil ;
};

// RGBToGrayscale converts RGB color values to grayscale using the standard luminance formula.
//
// Parameters r, g, b are expected to be integers in the range [0, 255].
//
// The coefficient used in the formula to convert RGB values to grayscale.
// This formula is based on the luminance perception of the human eye,
// which is more sensitive to green light and less sensitive to blue light.
// The full formula is:  [ gray = 0.299 * R + 0.587 * G + 0.114 * B ]
//
// This implementation uses integer arithmetic for better performance by using
// scaled coefficients: 299, 587, 114 (scaled by 1000).
func RGBToGrayscale (r ,g ,b int )int {_dbgca :=299*r +587*g +114*b ;return _dbgca /1000};type cryptFilters map[string ]_dfa .Filter ;func (_gfbf *limitedReadSeeker )getError (_cgde int64 )error {switch {case _cgde < 0:return _cg .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_cgde );
case _cgde > _gfbf ._abdb :return _cg .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_cgde );};return nil ;};func _afad (_fafe PdfObject )(*float64 ,error ){switch _fcba :=_fafe .(type ){case *PdfObjectFloat :_bdfca :=float64 (*_fcba );
return &_bdfca ,nil ;case *PdfObjectInteger :_bbcc :=float64 (*_fcba );return &_bbcc ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// GetXrefOffset returns the offset of the xref table.
func (_fgaea *PdfParser )GetXrefOffset ()int64 {return _fgaea ._afcca };

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _eb .ReadSeeker )(*PdfParser ,error ){_gafa :=&PdfParser {_cafb :_cbb (rs ),ObjCache :make (objectCache ),_bbec :map[int64 ]bool {},_faae :make ([]int64 ,0),_cedbf :make (map[*PdfParser ]*PdfParser )};_abdd :=_gafa .initParser ();if _abdd !=nil {return nil ,_abdd ;
};return _gafa ,nil ;};func (_adgba *PdfParser )parseXrefStream (_afcd *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _afcd !=nil {_cbf .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_afcd );
_adgba ._cafb .Seek (int64 (*_afcd ),_eb .SeekStart );};_dbdge :=_adgba .GetFileOffset ();_efaga ,_aeaf :=_adgba .ParseIndirectObject ();if _aeaf !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_be .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_cbf .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_efaga );
_aebeee ,_bggdb :=_efaga .(*PdfObjectStream );if !_bggdb {_cbf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_be .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_egbb :=_aebeee .PdfObjectDictionary ;
_ggee ,_bggdb :=_aebeee .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_bggdb {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_be .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_ggee )> 8388607{_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_ggee );
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bcgf :=_aebeee .Get ("\u0057");_fbggg ,_bggdb :=_bcgf .(*PdfObjectArray );if !_bggdb {return nil ,_be .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_daee :=_fbggg .Len ();if _daee !=3{_cbf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_daee );
return nil ,_be .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _dddb []int64 ;for _dcfe :=0;_dcfe < 3;
_dcfe ++{_efdb ,_ccag :=GetInt (_fbggg .Get (_dcfe ));if !_ccag {return nil ,_be .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_dddb =append (_dddb ,int64 (*_efdb ));};_dddde ,_aeaf :=DecodeStream (_aebeee );
if _aeaf !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_aeaf );return nil ,_aeaf ;};_cfede :=int (_dddb [0]);
_dafce :=int (_dddb [0]+_dddb [1]);_cffae :=int (_dddb [0]+_dddb [1]+_dddb [2]);_ddcf :=int (_dddb [0]+_dddb [1]+_dddb [2]);if _cfede < 0||_dafce < 0||_cffae < 0{_cbf .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_cfede ,_dafce ,_cffae );
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ddcf ==0{_cbf .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _egbb ,nil ;};_bda :=len (_dddde )/_ddcf ;_ccec :=0;_edba :=_aebeee .Get ("\u0049\u006e\u0064e\u0078");var _dbgf []int ;if _edba !=nil {_cbf .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_edba );_ddeef ,_afdg :=_edba .(*PdfObjectArray );
if !_afdg {_cbf .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_be .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _ddeef .Len ()%2!=0{_cbf .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_be .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ccec =0;_addfe ,_cfcbe :=_ddeef .ToIntegerArray ();if _cfcbe !=nil {_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_cfcbe );
return nil ,_cfcbe ;};for _efeea :=0;_efeea < len (_addfe );_efeea +=2{_bccd :=_addfe [_efeea ];_edeaf :=_addfe [_efeea +1];for _fabcd :=0;_fabcd < _edeaf ;_fabcd ++{_dbgf =append (_dbgf ,_bccd +_fabcd );};_ccec +=_edeaf ;};}else {for _abeff :=0;_abeff < int (*_ggee );
_abeff ++{_dbgf =append (_dbgf ,_abeff );};_ccec =int (*_ggee );};if _bda ==_ccec +1{_cbf .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_cfgea :=_ccec -1;for _ ,_febb :=range _dbgf {if _febb > _cfgea {_cfgea =_febb ;};};_dbgf =append (_dbgf ,_cfgea +1);_ccec ++;};if _bda !=len (_dbgf ){_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_bda ,len (_dbgf ));
return nil ,_be .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_cbf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ccec );
_cbf .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_dbgf );_gagc :=func (_dgc []byte )int64 {var _aaadd int64 ;for _fbfg :=0;_fbfg < len (_dgc );_fbfg ++{_aaadd +=int64 (_dgc [_fbfg ])*(1<<uint (8*(len (_dgc )-_fbfg -1)));
};return _aaadd ;};_cbf .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_dddde ));_gcgd :=0;for _ceeea :=0;_ceeea < len (_dddde );_ceeea +=_ddcf {_cbde :=_fgeaaf (len (_dddde ),_ceeea ,_ceeea +_cfede );
if _cbde !=nil {_cbf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cbde );return nil ,_cbde ;};_ebdfg :=_dddde [_ceeea :_ceeea +_cfede ];_cbde =_fgeaaf (len (_dddde ),_ceeea +_cfede ,_ceeea +_dafce );
if _cbde !=nil {_cbf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cbde );return nil ,_cbde ;};_egefc :=_dddde [_ceeea +_cfede :_ceeea +_dafce ];_cbde =_fgeaaf (len (_dddde ),_ceeea +_dafce ,_ceeea +_cffae );
if _cbde !=nil {_cbf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cbde );return nil ,_cbde ;};_cdgc :=_dddde [_ceeea +_dafce :_ceeea +_cffae ];_cbdea :=_gagc (_ebdfg );
_bcbeg :=_gagc (_egefc );_bcf :=_gagc (_cdgc );if _dddb [0]==0{_cbdea =1;};if _gcgd >=len (_dbgf ){_cbf .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_cfaf :=_dbgf [_gcgd ];_gcgd ++;_cbf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_cfaf ,_ebdfg );_cbf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_cfaf ,_egefc );_cbf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_cfaf ,_cdgc );
_cbf .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_cfaf ,_cbdea ,_bcbeg ,_bcf );switch _cbdea {case 0:_cbf .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
case 1:_cbf .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_egefc );if _bcbeg ==_dbdge {_cbf .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_cfaf ,_aebeee .ObjectNumber );
_cfaf =int (_aebeee .ObjectNumber );};if _debd ,_gdgc :=_adgba ._dbbe .ObjectMap [_cfaf ];!_gdgc ||int (_bcf )> _debd .Generation {_bdcf :=XrefObject {ObjectNumber :_cfaf ,XType :XrefTypeTableEntry ,Offset :_bcbeg ,Generation :int (_bcf )};_adgba ._dbbe .ObjectMap [_cfaf ]=_bdcf ;
};case 2:_cbf .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_gfbb :=_adgba ._dbbe .ObjectMap [_cfaf ];!_gfbb {_cafda :=XrefObject {ObjectNumber :_cfaf ,XType :XrefTypeObjectStream ,OsObjNumber :int (_bcbeg ),OsObjIndex :int (_bcf )};
_adgba ._dbbe .ObjectMap [_cfaf ]=_cafda ;_cbf .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_cafda );};default:_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _adgba ._ceca ==nil {_cfafb :=XrefTypeObjectStream ;_adgba ._ceca =&_cfafb ;};return _egbb ,nil ;};

// String returns a string describing `stream`.
func (_ddgb *PdfObjectStream )String ()string {return _cg .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_ddgb .ObjectNumber ,_ddgb .PdfObjectDictionary );};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_ccdbg *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ccdbg .DecodeBytes (streamObj .Stream );};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_ccfg :=MakeDict ();return _ccfg .Update (objmap );};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_ffe *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_dbdf ,_bbbc :=obj .(*PdfObjectReference );if !_bbbc {return obj ,nil ;};_dbg :=_ffe .GetFileOffset ();defer func (){_ffe .SetFileOffset (_dbg )}();_fba ,_befe :=_ffe .LookupByReference (*_dbdf );
if _befe !=nil {return nil ,_befe ;};_fae ,_aca :=_fba .(*PdfIndirectObject );if !_aca {return _fba ,nil ;};_fba =_fae .PdfObject ;_ ,_bbbc =_fba .(*PdfObjectReference );if _bbbc {return _fae ,_be .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _fba ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_fg .Reader )(PdfObject ,error ){_dgge :=false ;_aacab :=true ;var _dgfbc _c .Buffer ;for {if _cbf .Log .IsLogLevel (_cbf .LogLevelTrace ){_cbf .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dgfbc .String ());
};_gfaab ,_adcfa :=buf .Peek (1);if _adcfa ==_eb .EOF {break ;};if _adcfa !=nil {_cbf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_adcfa );return nil ,_adcfa ;};if _aacab &&(_gfaab [0]=='-'||_gfaab [0]=='+'){_fadbg ,_ :=buf .ReadByte ();
_dgfbc .WriteByte (_fadbg );_aacab =false ;}else if IsDecimalDigit (_gfaab [0]){_edca ,_ :=buf .ReadByte ();_dgfbc .WriteByte (_edca );}else if _gfaab [0]=='.'{_dgdd ,_ :=buf .ReadByte ();_dgfbc .WriteByte (_dgdd );_dgge =true ;}else if _gfaab [0]=='e'||_gfaab [0]=='E'{_ddfa ,_ :=buf .ReadByte ();
_dgfbc .WriteByte (_ddfa );_dgge =true ;_aacab =true ;}else {break ;};};var _bgce PdfObject ;if _dgge {_dcdfa ,_geaf :=_g .ParseFloat (_dgfbc .String (),64);if _geaf !=nil {_cbf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dgfbc .String (),_geaf );
_dcdfa =0.0;};_bcgef :=PdfObjectFloat (_dcdfa );_bgce =&_bcgef ;}else {_cdcac ,_abdfc :=_g .ParseInt (_dgfbc .String (),10,64);if _abdfc !=nil {_cbf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dgfbc .String (),_abdfc );
_cdcac =0;};_eded :=PdfObjectInteger (_cdcac );_bgce =&_eded ;};return _bgce ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dbagb *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _fcecg ,_fecdf :=GetNumberAsInt64 (params .Get ("\u004b"));_fecdf ==nil {_dbagb .K =int (_fcecg );};if _eecbb ,_ffff :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_ffff ==nil {_dbagb .Columns =int (_eecbb );}else if _eecbb ,_ffff =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_ffff ==nil {_dbagb .Columns =int (_eecbb );};if _fgea ,_befb :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_befb ==nil {_dbagb .BlackIs1 =_fgea > 0;}else {if _efg ,_cage :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cage {_dbagb .BlackIs1 =_efg ;}else {if _ccdcd ,_efd :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_efd {_bgbd ,_gced :=_ccdcd .ToIntegerArray ();if _gced ==nil {_dbagb .BlackIs1 =_bgbd [0]==1&&_bgbd [1]==0;};};};};if _bcdg ,_defbb :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_defbb ==nil {_dbagb .EncodedByteAlign =_bcdg > 0;}else {if _bbfe ,_gbab :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gbab {_dbagb .EncodedByteAlign =_bbfe ;};};if _fcg ,_cbfc :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_cbfc ==nil {_dbagb .EndOfLine =_fcg > 0;}else {if _gegd ,_fdcf :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fdcf {_dbagb .EndOfLine =_gegd ;};};if _gecb ,_dcea :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_dcea ==nil {_dbagb .Rows =int (_gecb );}else if _gecb ,_dcea =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_dcea ==nil {_dbagb .Rows =int (_gecb );};if _ffed ,_dbga :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_dbga ==nil {_dbagb .EndOfBlock =_ffed > 0;}else {if _bbfg ,_fgfg :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fgfg {_dbagb .EndOfBlock =_bbfg ;};};if _deff ,_agcf :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_agcf !=nil {_dbagb .DamagedRowsBeforeError =int (_deff );};};func (_accg *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_accg ._cafb ._acg )};func _faef (_bce XrefTable ){_cbf .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_cbf .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");
_cca :=0;for _ ,_gage :=range _bce .ObjectMap {_cbf .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_cca +1,_gage .ObjectNumber ,_gage .Generation ,_gage .Offset );
_cca ++;};};var _edgb =_df .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_gdcd *PdfCrypt )GetAccessPermissions ()_ff .Permissions {return _gdcd ._baa .P };

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_cbeeg :=PdfObjectInteger (val );return &_cbeeg };

// Write outputs the object as it is to be written to file.
func (_eaabb *PdfObjectFloat )Write ()[]byte {return []byte (_g .FormatFloat (float64 (*_eaabb ),'f',-1,64));};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func _cddg (_ffaa string )(PdfObjectReference ,error ){_bgcg :=PdfObjectReference {};_cegb :=_bfcef .FindStringSubmatch (_ffaa );if len (_cegb )< 3{_cbf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _bgcg ,_be .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_acge ,_ :=_g .Atoi (_cegb [1]);_cgdb ,_ :=_g .Atoi (_cegb [2]);_bgcg .ObjectNumber =int64 (_acge );_bgcg .GenerationNumber =int64 (_cgdb );
return _bgcg ,nil ;};func (_ecf *PdfCrypt )isDecrypted (_cdff PdfObject )bool {_ ,_cda :=_ecf ._bedd [_cdff ];if _cda {_cbf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};
switch _ffc :=_cdff .(type ){case *PdfObjectStream :if _ecf ._baa .R !=5{if _cccf ,_bbc :=_ffc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bbc &&*_cccf =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_cda =_ecf ._ede [int (_ffc .ObjectNumber )];
_cda {return true ;};switch _baag :=_ffc .PdfObject .(type ){case *PdfObjectDictionary :_bcad :=true ;for _ ,_badb :=range _efed {if _baag .Get (_badb )==nil {_bcad =false ;break ;};};if _bcad {return true ;};};};_cbf .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_fgfa *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _efea []byte ;_cbf .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_dfbg :=0;_ecde :=false ;for _dfbg < len (encoded )&&!_ecde {_bac :=[5]byte {0,0,0,0,0};
_gaaa :=0;_febe :=0;_cgad :=4;for _febe < 5+_gaaa {if _dfbg +_febe ==len (encoded ){break ;};_cbec :=encoded [_dfbg +_febe ];if IsWhiteSpace (_cbec ){_gaaa ++;_febe ++;continue ;}else if _cbec =='~'&&_dfbg +_febe +1< len (encoded )&&encoded [_dfbg +_febe +1]=='>'{_cgad =(_febe -_gaaa )-1;
if _cgad < 0{_cgad =0;};_ecde =true ;break ;}else if _cbec >='!'&&_cbec <='u'{_cbec -='!';}else if _cbec =='z'&&_febe -_gaaa ==0{_cgad =4;_febe ++;break ;}else {_cbf .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_be .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_bac [_febe -_gaaa ]=_cbec ;_febe ++;};_dfbg +=_febe ;for _gfbc :=_cgad +1;_gfbc < 5;_gfbc ++{_bac [_gfbc ]=84;
};_aggee :=uint32 (_bac [0])*85*85*85*85+uint32 (_bac [1])*85*85*85+uint32 (_bac [2])*85*85+uint32 (_bac [3])*85+uint32 (_bac [4]);_bgcb :=[]byte {byte ((_aggee >>24)&0xff),byte ((_aggee >>16)&0xff),byte ((_aggee >>8)&0xff),byte (_aggee &0xff)};_efea =append (_efea ,_bgcb [:_cgad ]...);
};_cbf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_cbf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_efea );
return _efea ,nil ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};var _geffg =_df .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");