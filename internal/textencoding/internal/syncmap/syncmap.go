//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func MakeRuneByteMap (length int )*RuneByteMap {_g :=make (map[rune ]byte ,length );return &RuneByteMap {_ag :_g };};type RuneRuneMap struct{_gd map[rune ]rune ;_fc _c .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ad :make (map[rune ]struct{},length )}};
func (_geb *RuneByteMap )Write (r rune ,b byte ){_geb ._ga .Lock ();defer _geb ._ga .Unlock ();_geb ._ag [r ]=b ;};func (_gg *RuneByteMap )Read (r rune )(byte ,bool ){_gg ._ga .RLock ();defer _gg ._ga .RUnlock ();_ea ,_ge :=_gg ._ag [r ];return _ea ,_ge ;
};func (_feb *StringRuneMap )Write (g string ,r rune ){_feb ._cda .Lock ();defer _feb ._cda .Unlock ();_feb ._dafe [g ]=r ;};func (_fb *RuneByteMap )Range (f func (_gag rune ,_ca byte )(_ff bool )){_fb ._ga .RLock ();defer _fb ._ga .RUnlock ();for _fdb ,_bb :=range _fb ._ag {if f (_fdb ,_bb ){break ;
};};};func (_bc *RuneStringMap )Read (r rune )(string ,bool ){_bc ._bf .RLock ();defer _bc ._bf .RUnlock ();_ada ,_ggd :=_bc ._cb [r ];return _ada ,_ggd ;};func (_aag *RuneUint16Map )Delete (r rune ){_aag ._bd .Lock ();defer _aag ._bd .Unlock ();delete (_aag ._bac ,r );
};type RuneByteMap struct{_ag map[rune ]byte ;_ga _c .RWMutex ;};func (_cae *RuneUint16Map )Range (f func (_fbd rune ,_cfc uint16 )(_gcg bool )){_cae ._bd .RLock ();defer _cae ._bd .RUnlock ();for _dfb ,_daf :=range _cae ._bac {if f (_dfb ,_daf ){break ;
};};};func (_fbc *RuneSet )Range (f func (_ab rune )(_gece bool )){_fbc ._fa .RLock ();defer _fbc ._fa .RUnlock ();for _da :=range _fbc ._ad {if f (_da ){break ;};};};func (_eb *ByteRuneMap )Write (b byte ,r rune ){_eb ._f .Lock ();defer _eb ._f .Unlock ();
_eb ._b [b ]=r };type RuneUint16Map struct{_bac map[rune ]uint16 ;_bd _c .RWMutex ;};type RuneStringMap struct{_cb map[rune ]string ;_bf _c .RWMutex ;};func (_adg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_adg ._bd .RLock ();defer _adg ._bd .RUnlock ();
_adad ,_ac :=_adg ._bac [r ];return _adad ,_ac ;};func (_bfd *StringsMap )Write (g1 ,g2 string ){_bfd ._gdfe .Lock ();defer _bfd ._gdfe .Unlock ();_bfd ._ggb [g1 ]=g2 ;};func (_gda *RuneSet )Exists (r rune )bool {_gda ._fa .RLock ();defer _gda ._fa .RUnlock ();
_ ,_gc :=_gda ._ad [r ];return _gc ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};func (_gdf *RuneSet )Length ()int {_gdf ._fa .RLock ();defer _gdf ._fa .RUnlock ();return len (_gdf ._ad )};func NewRuneRuneMap (m map[rune ]rune )*RuneRuneMap {return &RuneRuneMap {_gd :m }};
type StringsTuple struct{Key ,Value string ;};func (_gec *RuneRuneMap )Range (f func (_ggf rune ,_baa rune )(_baag bool )){_gec ._fc .RLock ();defer _gec ._fc .RUnlock ();for _dg ,_cd :=range _gec ._gd {if f (_dg ,_cd ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};
func (_fcec *StringRuneMap )Read (g string )(rune ,bool ){_fcec ._cda .RLock ();defer _fcec ._cda .RUnlock ();_dbb ,_gagg :=_fcec ._dafe [g ];return _dbb ,_gagg ;};func (_fad *RuneStringMap )Range (f func (_bg rune ,_eda string )(_gdff bool )){_fad ._bf .RLock ();
defer _fad ._bf .RUnlock ();for _dfa ,_ae :=range _fad ._cb {if f (_dfa ,_ae ){break ;};};};func (_cg *RuneRuneMap )Read (g rune )(rune ,bool ){_cg ._fc .RLock ();defer _cg ._fc .RUnlock ();_dc ,_db :=_cg ._gd [g ];return _dc ,_db ;};func (_aga *RuneStringMap )Length ()int {_aga ._bf .RLock ();
defer _aga ._bf .RUnlock ();return len (_aga ._cb );};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_dafe :m }};func (_ed *RuneByteMap )Length ()int {_ed ._ga .RLock ();defer _ed ._ga .RUnlock ();return len (_ed ._ag )};
func (_bcd *StringsMap )Range (f func (_agb ,_ffc string )(_de bool )){_bcd ._gdfe .RLock ();defer _bcd ._gdfe .RUnlock ();for _dfbc ,_efd :=range _bcd ._ggb {if f (_dfbc ,_efd ){break ;};};};func (_ebg *ByteRuneMap )Range (f func (_aa byte ,_cf rune )(_dd bool )){_ebg ._f .RLock ();
defer _ebg ._f .RUnlock ();for _ddg ,_fd :=range _ebg ._b {if f (_ddg ,_fd ){break ;};};};func (_ba *RuneRuneMap )Write (g rune ,r rune ){_ba ._fc .Lock ();defer _ba ._fc .Unlock ();_ba ._gd [g ]=r };func (_eae *StringsMap )Read (g string )(string ,bool ){_eae ._gdfe .RLock ();
defer _eae ._gdfe .RUnlock ();_edd ,_ccf :=_eae ._ggb [g ];return _edd ,_ccf ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_bac :make (map[rune ]uint16 ,length )};};func (_dae *RuneUint16Map )RangeDelete (f func (_bce rune ,_edf uint16 )(_fe bool ,_fdf bool )){_dae ._bd .Lock ();
defer _dae ._bd .Unlock ();for _ec ,_bgd :=range _dae ._bac {_bbf ,_eeg :=f (_ec ,_bgd );if _bbf {delete (_dae ._bac ,_ec );};if _eeg {break ;};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_cb :m }};func (_d *ByteRuneMap )Read (b byte )(rune ,bool ){_d ._f .RLock ();
defer _d ._f .RUnlock ();_ee ,_a :=_d ._b [b ];return _ee ,_a ;};func (_ddc *ByteRuneMap )Length ()int {_ddc ._f .RLock ();defer _ddc ._f .RUnlock ();return len (_ddc ._b )};func (_cc *RuneSet )Write (r rune ){_cc ._fa .Lock ();defer _cc ._fa .Unlock ();
_cc ._ad [r ]=struct{}{}};func (_dcg *RuneUint16Map )Write (r rune ,g uint16 ){_dcg ._bd .Lock ();defer _dcg ._bd .Unlock ();_dcg ._bac [r ]=g ;};func (_df *RuneStringMap )Write (r rune ,s string ){_df ._bf .Lock ();defer _df ._bf .Unlock ();_df ._cb [r ]=s ;
};type StringRuneMap struct{_dafe map[string ]rune ;_cda _c .RWMutex ;};func (_eaa *StringRuneMap )Range (f func (_fg string ,_abc rune )(_aaa bool )){_eaa ._cda .RLock ();defer _eaa ._cda .RUnlock ();for _aea ,_adf :=range _eaa ._dafe {if f (_aea ,_adf ){break ;
};};};func (_fae *RuneUint16Map )Length ()int {_fae ._bd .RLock ();defer _fae ._bd .RUnlock ();return len (_fae ._bac );};func (_cab *StringsMap )Copy ()*StringsMap {_cab ._gdfe .RLock ();defer _cab ._gdfe .RUnlock ();_fcb :=map[string ]string {};for _faec ,_gf :=range _cab ._ggb {_fcb [_faec ]=_gf ;
};return &StringsMap {_ggb :_fcb };};type RuneSet struct{_ad map[rune ]struct{};_fa _c .RWMutex ;};type ByteRuneMap struct{_b map[byte ]rune ;_f _c .RWMutex ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_febf :=map[string ]string {};for _ ,_gb :=range tuples {_febf [_gb .Key ]=_gb .Value ;
};return &StringsMap {_ggb :_febf };};func (_cgb *RuneRuneMap )Length ()int {_cgb ._fc .RLock ();defer _cgb ._fc .RUnlock ();return len (_cgb ._gd );};type StringsMap struct{_ggb map[string ]string ;_gdfe _c .RWMutex ;};func (_ef *StringRuneMap )Length ()int {_ef ._cda .RLock ();
defer _ef ._cda .RUnlock ();return len (_ef ._dafe );};