//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _e "sync";func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ba :make (map[rune ]struct{},length )}};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_add :m }};func (_ff *ByteRuneMap )Read (b byte )(rune ,bool ){_ff ._ea .RLock ();
defer _ff ._ea .RUnlock ();_d ,_ce :=_ff ._c [b ];return _d ,_ce ;};func (_g *ByteRuneMap )Write (b byte ,r rune ){_g ._ea .Lock ();defer _g ._ea .Unlock ();_g ._c [b ]=r };func (_gbc *StringsMap )Read (g string )(string ,bool ){_gbc ._bdg .RLock ();defer _gbc ._bdg .RUnlock ();
_ga ,_cgc :=_gbc ._agf [g ];return _ga ,_cgc ;};func (_ge *RuneUint16Map )Length ()int {_ge ._bfe .RLock ();defer _ge ._bfe .RUnlock ();return len (_ge ._eea );};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_ffa :m }};
func (_ag *RuneStringMap )Length ()int {_ag ._adf .RLock ();defer _ag ._adf .RUnlock ();return len (_ag ._add );};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_eea :make (map[rune ]uint16 ,length )};};func (_gde *RuneSet )Exists (r rune )bool {_gde ._adg .RLock ();
defer _gde ._adg .RUnlock ();_ ,_daa :=_gde ._ba [r ];return _daa ;};type StringsMap struct{_agf map[string ]string ;_bdg _e .RWMutex ;};func (_bfc *RuneRuneMap )Length ()int {_bfc ._db .RLock ();defer _bfc ._db .RUnlock ();return len (_bfc ._bd );};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_c :make (map[byte ]rune ,length )}};
func (_ef *RuneUint16Map )Write (r rune ,g uint16 ){_ef ._bfe .Lock ();defer _ef ._bfe .Unlock ();_ef ._eea [r ]=g ;};func (_dcb *RuneSet )Length ()int {_dcb ._adg .RLock ();defer _dcb ._adg .RUnlock ();return len (_dcb ._ba )};func (_fgc *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fgc ._bfe .RLock ();
defer _fgc ._bfe .RUnlock ();_aecc ,_dfc :=_fgc ._eea [r ];return _aecc ,_dfc ;};func (_baf *RuneUint16Map )Delete (r rune ){_baf ._bfe .Lock ();defer _baf ._bfe .Unlock ();delete (_baf ._eea ,r );};type RuneRuneMap struct{_bd map[rune ]rune ;_db _e .RWMutex ;
};func (_ac *RuneStringMap )Range (f func (_ed rune ,_deb string )(_ffb bool )){_ac ._adf .RLock ();defer _ac ._adf .RUnlock ();for _dae ,_fgf :=range _ac ._add {if f (_dae ,_fgf ){break ;};};};func (_dca *StringRuneMap )Range (f func (_bfg string ,_dba rune )(_dff bool )){_dca ._gdca .RLock ();
defer _dca ._gdca .RUnlock ();for _bdc ,_aa :=range _dca ._ffa {if f (_bdc ,_aa ){break ;};};};func (_cef *RuneRuneMap )Write (g rune ,r rune ){_cef ._db .Lock ();defer _cef ._db .Unlock ();_cef ._bd [g ]=r ;};func (_ad *RuneByteMap )Length ()int {_ad ._a .RLock ();
defer _ad ._a .RUnlock ();return len (_ad ._bg )};func (_bgdf *StringRuneMap )Length ()int {_bgdf ._gdca .RLock ();defer _bgdf ._gdca .RUnlock ();return len (_bgdf ._ffa );};func (_aeb *RuneUint16Map )Range (f func (_gdc rune ,_ace uint16 )(_fba bool )){_aeb ._bfe .RLock ();
defer _aeb ._bfe .RUnlock ();for _beb ,_bed :=range _aeb ._eea {if f (_beb ,_bed ){break ;};};};type StringsTuple struct{Key ,Value string ;};func (_gd *ByteRuneMap )Range (f func (_cec byte ,_dg rune )(_ee bool )){_gd ._ea .RLock ();defer _gd ._ea .RUnlock ();
for _cb ,_fe :=range _gd ._c {if f (_cb ,_fe ){break ;};};};func (_gdd *RuneSet )Write (r rune ){_gdd ._adg .Lock ();defer _gdd ._adg .Unlock ();_gdd ._ba [r ]=struct{}{};};func (_bgf *StringsMap )Write (g1 ,g2 string ){_bgf ._bdg .Lock ();defer _bgf ._bdg .Unlock ();
_bgf ._agf [g1 ]=g2 ;};func (_cg *RuneByteMap )Read (r rune )(byte ,bool ){_cg ._a .RLock ();defer _cg ._a .RUnlock ();_bgd ,_gb :=_cg ._bg [r ];return _bgd ,_gb ;};func (_gc *StringRuneMap )Read (g string )(rune ,bool ){_gc ._gdca .RLock ();defer _gc ._gdca .RUnlock ();
_efc ,_fed :=_gc ._ffa [g ];return _efc ,_fed ;};func (_bad *StringRuneMap )Write (g string ,r rune ){_bad ._gdca .Lock ();defer _bad ._gdca .Unlock ();_bad ._ffa [g ]=r ;};func (_df *RuneByteMap )Write (r rune ,b byte ){_df ._a .Lock ();defer _df ._a .Unlock ();
_df ._bg [r ]=b };func (_b *ByteRuneMap )Length ()int {_b ._ea .RLock ();defer _b ._ea .RUnlock ();return len (_b ._c )};func MakeRuneByteMap (length int )*RuneByteMap {_bc :=make (map[rune ]byte ,length );return &RuneByteMap {_bg :_bc };};type StringRuneMap struct{_ffa map[string ]rune ;
_gdca _e .RWMutex ;};type RuneByteMap struct{_bg map[rune ]byte ;_a _e .RWMutex ;};func (_aed *StringsMap )Range (f func (_def ,_ddg string )(_fca bool )){_aed ._bdg .RLock ();defer _aed ._bdg .RUnlock ();for _afd ,_ec :=range _aed ._agf {if f (_afd ,_ec ){break ;
};};};type RuneStringMap struct{_add map[rune ]string ;_adf _e .RWMutex ;};func (_ca *RuneStringMap )Read (r rune )(string ,bool ){_ca ._adf .RLock ();defer _ca ._adf .RUnlock ();_cc ,_aea :=_ca ._add [r ];return _cc ,_aea ;};type ByteRuneMap struct{_c map[byte ]rune ;
_ea _e .RWMutex ;};type RuneUint16Map struct{_eea map[rune ]uint16 ;_bfe _e .RWMutex ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_gcf :=map[string ]string {};for _ ,_bfea :=range tuples {_gcf [_bfea .Key ]=_bfea .Value ;};return &StringsMap {_agf :_gcf };
};func (_cd *RuneRuneMap )Range (f func (_dc rune ,_da rune )(_aec bool )){_cd ._db .RLock ();defer _cd ._db .RUnlock ();for _ffd ,_dbd :=range _cd ._bd {if f (_ffd ,_dbd ){break ;};};};func NewRuneRuneMap (m map[rune ]rune )*RuneRuneMap {return &RuneRuneMap {_bd :m }};
func (_dd *RuneRuneMap )Read (g rune )(rune ,bool ){_dd ._db .RLock ();defer _dd ._db .RUnlock ();_cf ,_bdb :=_dd ._bd [g ];return _cf ,_bdb ;};func (_dag *RuneUint16Map )RangeDelete (f func (_ccg rune ,_fee uint16 )(_cce bool ,_fc bool )){_dag ._bfe .Lock ();
defer _dag ._bfe .Unlock ();for _af ,_ab :=range _dag ._eea {_bebg ,_cba :=f (_af ,_ab );if _bebg {delete (_dag ._eea ,_af );};if _cba {break ;};};};func (_eaa *RuneSet )Range (f func (_be rune )(_eb bool )){_eaa ._adg .RLock ();defer _eaa ._adg .RUnlock ();
for _fb :=range _eaa ._ba {if f (_fb ){break ;};};};func (_bda *StringsMap )Copy ()*StringsMap {_bda ._bdg .RLock ();defer _bda ._bdg .RUnlock ();_agc :=map[string ]string {};for _ebd ,_fac :=range _bda ._agf {_agc [_ebd ]=_fac ;};return &StringsMap {_agf :_agc };
};func (_fa *RuneStringMap )Write (r rune ,s string ){_fa ._adf .Lock ();defer _fa ._adf .Unlock ();_fa ._add [r ]=s ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_c :m }};func (_fec *RuneByteMap )Range (f func (_fg rune ,_de byte )(_ae bool )){_fec ._a .RLock ();
defer _fec ._a .RUnlock ();for _gbd ,_bf :=range _fec ._bg {if f (_gbd ,_bf ){break ;};};};type RuneSet struct{_ba map[rune ]struct{};_adg _e .RWMutex ;};