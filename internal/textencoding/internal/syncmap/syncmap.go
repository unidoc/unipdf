//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";type ByteRuneMap struct{_b map[byte ]rune ;_bc _a .RWMutex ;};func (_gdb *RuneUint16Map )Length ()int {_gdb ._cgd .RLock ();defer _gdb ._cgd .RUnlock ();return len (_gdb ._cea );};func (_ebg *RuneRuneMap )Write (g rune ,r rune ){_ebg ._ad .Lock ();
defer _ebg ._ad .Unlock ();_ebg ._ff [g ]=r ;};func (_eege *StringsMap )Copy ()*StringsMap {_eege ._fg .RLock ();defer _eege ._fg .RUnlock ();_abd :=map[string ]string {};for _fce ,_cde :=range _eege ._ffd {_abd [_fce ]=_cde ;};return &StringsMap {_ffd :_abd };
};func (_fdg *StringsMap )Read (g string )(string ,bool ){_fdg ._fg .RLock ();defer _fdg ._fg .RUnlock ();_ab ,_bgga :=_fdg ._ffd [g ];return _ab ,_bgga ;};func NewRuneRuneMap (m map[rune ]rune )*RuneRuneMap {return &RuneRuneMap {_ff :m }};func (_cb *RuneSet )Exists (r rune )bool {_cb ._eea .RLock ();
defer _cb ._eea .RUnlock ();_ ,_db :=_cb ._fca [r ];return _db ;};func (_bcf *StringsMap )Range (f func (_agd ,_dge string )(_cbf bool )){_bcf ._fg .RLock ();defer _bcf ._fg .RUnlock ();for _gg ,_beb :=range _bcf ._ffd {if f (_gg ,_beb ){break ;};};};func (_bde *RuneRuneMap )Length ()int {_bde ._ad .RLock ();
defer _bde ._ad .RUnlock ();return len (_bde ._ff );};func (_ac *ByteRuneMap )Range (f func (_be byte ,_ea rune )(_ee bool )){_ac ._bc .RLock ();defer _ac ._bc .RUnlock ();for _d ,_fe :=range _ac ._b {if f (_d ,_fe ){break ;};};};func MakeRuneByteMap (length int )*RuneByteMap {_dd :=make (map[rune ]byte ,length );
return &RuneByteMap {_ca :_dd };};func (_ag *RuneRuneMap )Read (g rune )(rune ,bool ){_ag ._ad .RLock ();defer _ag ._ad .RUnlock ();_fff ,_bd :=_ag ._ff [g ];return _fff ,_bd ;};func (_eb *ByteRuneMap )Write (b byte ,r rune ){_eb ._bc .Lock ();defer _eb ._bc .Unlock ();
_eb ._b [b ]=r };func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_cgb :m }};type StringsMap struct{_ffd map[string ]string ;_fg _a .RWMutex ;};func (_dfc *RuneUint16Map )RangeDelete (f func (_ddc rune ,_de uint16 )(_fcg bool ,_egf bool )){_dfc ._cgd .Lock ();
defer _dfc ._cgd .Unlock ();for _ga ,_gd :=range _dfc ._cea {_gbea ,_af :=f (_ga ,_gd );if _gbea {delete (_dfc ._cea ,_ga );};if _af {break ;};};};func (_ec *RuneUint16Map )Write (r rune ,g uint16 ){_ec ._cgd .Lock ();defer _ec ._cgd .Unlock ();_ec ._cea [r ]=g ;
};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_cea :make (map[rune ]uint16 ,length )};};func (_g *ByteRuneMap )Length ()int {_g ._bc .RLock ();defer _g ._bc .RUnlock ();return len (_g ._b )};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};
type RuneSet struct{_fca map[rune ]struct{};_eea _a .RWMutex ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_eba :=map[string ]string {};for _ ,_ece :=range tuples {_eba [_ece .Key ]=_ece .Value ;};return &StringsMap {_ffd :_eba };};func (_bb *RuneUint16Map )Read (r rune )(uint16 ,bool ){_bb ._cgd .RLock ();
defer _bb ._cgd .RUnlock ();_fcc ,_acg :=_bb ._cea [r ];return _fcc ,_acg ;};func (_eeg *RuneUint16Map )Range (f func (_bad rune ,_ge uint16 )(_cdc bool )){_eeg ._cgd .RLock ();defer _eeg ._cgd .RUnlock ();for _fcf ,_gf :=range _eeg ._cea {if f (_fcf ,_gf ){break ;
};};};func (_ae *StringRuneMap )Length ()int {_ae ._dg .RLock ();defer _ae ._dg .RUnlock ();return len (_ae ._acf );};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};type RuneByteMap struct{_ca map[rune ]byte ;
_fd _a .RWMutex ;};func (_ebge *StringRuneMap )Write (g string ,r rune ){_ebge ._dg .Lock ();defer _ebge ._dg .Unlock ();_ebge ._acf [g ]=r ;};type RuneUint16Map struct{_cea map[rune ]uint16 ;_cgd _a .RWMutex ;};func (_fdag *StringRuneMap )Range (f func (_dga string ,_cbc rune )(_cc bool )){_fdag ._dg .RLock ();
defer _fdag ._dg .RUnlock ();for _bfb ,_eegg :=range _fdag ._acf {if f (_bfb ,_eegg ){break ;};};};func (_e *ByteRuneMap )Read (b byte )(rune ,bool ){_e ._bc .RLock ();defer _e ._bc .RUnlock ();_f ,_aa :=_e ._b [b ];return _f ,_aa ;};type StringRuneMap struct{_acf map[string ]rune ;
_dg _a .RWMutex ;};func (_cec *RuneSet )Length ()int {_cec ._eea .RLock ();defer _cec ._eea .RUnlock ();return len (_cec ._fca );};func (_fb *StringRuneMap )Read (g string )(rune ,bool ){_fb ._dg .RLock ();defer _fb ._dg .RUnlock ();_bea ,_bdf :=_fb ._acf [g ];
return _bea ,_bdf ;};func (_bf *RuneRuneMap )Range (f func (_gbb rune ,_aac rune )(_feg bool )){_bf ._ad .RLock ();defer _bf ._ad .RUnlock ();for _df ,_eee :=range _bf ._ff {if f (_df ,_eee ){break ;};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_fca :make (map[rune ]struct{},length )}};
func (_bef *RuneStringMap )Range (f func (_adda rune ,_eef string )(_fee bool )){_bef ._cdg .RLock ();defer _bef ._cdg .RUnlock ();for _age ,_fac :=range _bef ._cgb {if f (_age ,_fac ){break ;};};};type RuneStringMap struct{_cgb map[rune ]string ;_cdg _a .RWMutex ;
};func (_fc *RuneByteMap )Read (r rune )(byte ,bool ){_fc ._fd .RLock ();defer _fc ._fd .RUnlock ();_ce ,_cd :=_fc ._ca [r ];return _ce ,_cd ;};type StringsTuple struct{Key ,Value string ;};func (_fa *RuneStringMap )Write (r rune ,s string ){_fa ._cdg .Lock ();
defer _fa ._cdg .Unlock ();_fa ._cgb [r ]=s ;};func (_gbe *RuneByteMap )Range (f func (_bg rune ,_eg byte )(_ed bool )){_gbe ._fd .RLock ();defer _gbe ._fd .RUnlock ();for _fda ,_bgg :=range _gbe ._ca {if f (_fda ,_bgg ){break ;};};};func (_ebe *StringsMap )Write (g1 ,g2 string ){_ebe ._fg .Lock ();
defer _ebe ._fg .Unlock ();_ebe ._ffd [g1 ]=g2 ;};func (_ef *RuneByteMap )Length ()int {_ef ._fd .RLock ();defer _ef ._fd .RUnlock ();return len (_ef ._ca )};func (_befe *RuneUint16Map )Delete (r rune ){_befe ._cgd .Lock ();defer _befe ._cgd .Unlock ();
delete (_befe ._cea ,r );};func (_gb *RuneByteMap )Write (r rune ,b byte ){_gb ._fd .Lock ();defer _gb ._fd .Unlock ();_gb ._ca [r ]=b };func (_cg *RuneSet )Write (r rune ){_cg ._eea .Lock ();defer _cg ._eea .Unlock ();_cg ._fca [r ]=struct{}{}};func (_bed *RuneStringMap )Length ()int {_bed ._cdg .RLock ();
defer _bed ._cdg .RUnlock ();return len (_bed ._cgb );};func (_dc *RuneSet )Range (f func (_fef rune )(_ead bool )){_dc ._eea .RLock ();defer _dc ._eea .RUnlock ();for _add :=range _dc ._fca {if f (_add ){break ;};};};func (_ba *RuneStringMap )Read (r rune )(string ,bool ){_ba ._cdg .RLock ();
defer _ba ._cdg .RUnlock ();_dbd ,_ada :=_ba ._cgb [r ];return _dbd ,_ada ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_acf :m }};type RuneRuneMap struct{_ff map[rune ]rune ;_ad _a .RWMutex ;};