//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _eb "sync";func (_bg *RuneByteMap )Length ()int {_bg ._d .RLock ();defer _bg ._d .RUnlock ();return len (_bg ._eef )};func (_de *RuneSet )Length ()int {_de ._dc .RLock ();defer _de ._dc .RUnlock ();return len (_de ._eg )};func (_be *RuneRuneMap )Length ()int {_be ._gd .RLock ();
defer _be ._gd .RUnlock ();return len (_be ._edc )};func (_aa *RuneUint16Map )Read (r rune )(uint16 ,bool ){_aa ._cda .RLock ();defer _aa ._cda .RUnlock ();_ea ,_caa :=_aa ._bdf [r ];return _ea ,_caa ;};func (_ab *RuneByteMap )Write (r rune ,b byte ){_ab ._d .Lock ();
defer _ab ._d .Unlock ();_ab ._eef [r ]=b };func (_bea *StringRuneMap )Read (g string )(rune ,bool ){_bea ._bfb .RLock ();defer _bea ._bfb .RUnlock ();_ff ,_gce :=_bea ._gaf [g ];return _ff ,_gce ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_eg :make (map[rune ]struct{},length )}};
func (_cg *RuneUint16Map )RangeDelete (f func (_cbc rune ,_gfa uint16 )(_deb bool ,_baa bool )){_cg ._cda .Lock ();defer _cg ._cda .Unlock ();for _bee ,_cgg :=range _cg ._bdf {_ebb ,_aaf :=f (_bee ,_cgg );if _ebb {delete (_cg ._bdf ,_bee );};if _aaf {break ;
};};};func MakeRuneByteMap (length int )*RuneByteMap {_eec :=make (map[rune ]byte ,length );return &RuneByteMap {_eef :_eec };};func (_dca *RuneSet )Range (f func (_cb rune )(_gbad bool )){_dca ._dc .RLock ();defer _dca ._dc .RUnlock ();for _aeg :=range _dca ._eg {if f (_aeg ){break ;
};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_gaf :m }};func (_ae *ByteRuneMap )Read (b byte )(rune ,bool ){_ae ._a .RLock ();defer _ae ._a .RUnlock ();_b ,_ec :=_ae ._ed [b ];return _b ,_ec ;};func (_gde *RuneSet )Write (r rune ){_gde ._dc .Lock ();
defer _gde ._dc .Unlock ();_gde ._eg [r ]=struct{}{};};func (_bdc *RuneStringMap )Range (f func (_bfd rune ,_aef string )(_ecg bool )){_bdc ._ccb .RLock ();defer _bdc ._ccb .RUnlock ();for _ada ,_aca :=range _bdc ._bf {if f (_ada ,_aca ){break ;};};};func (_cdb *StringsMap )Write (g1 ,g2 string ){_cdb ._efa .Lock ();
defer _cdb ._efa .Unlock ();_cdb ._cca [g1 ]=g2 ;};type RuneUint16Map struct{_bdf map[rune ]uint16 ;_cda _eb .RWMutex ;};type ByteRuneMap struct{_ed map[byte ]rune ;_a _eb .RWMutex ;};func (_bd *ByteRuneMap )Length ()int {_bd ._a .RLock ();defer _bd ._a .RUnlock ();
return len (_bd ._ed )};func (_fdc *RuneUint16Map )Write (r rune ,g uint16 ){_fdc ._cda .Lock ();defer _fdc ._cda .Unlock ();_fdc ._bdf [r ]=g ;};func (_bgg *RuneSet )Exists (r rune )bool {_bgg ._dc .RLock ();defer _bgg ._dc .RUnlock ();_ ,_cdc :=_bgg ._eg [r ];
return _cdc ;};type RuneStringMap struct{_bf map[rune ]string ;_ccb _eb .RWMutex ;};func (_abeg *StringRuneMap )Write (g string ,r rune ){_abeg ._bfb .Lock ();defer _abeg ._bfb .Unlock ();_abeg ._gaf [g ]=r ;};func NewRuneRuneMap (m map[rune ]rune )*RuneRuneMap {return &RuneRuneMap {_edc :m }};
func (_ecb *RuneUint16Map )Delete (r rune ){_ecb ._cda .Lock ();defer _ecb ._cda .Unlock ();delete (_ecb ._bdf ,r );};func (_ca *RuneByteMap )Read (r rune )(byte ,bool ){_ca ._d .RLock ();defer _ca ._d .RUnlock ();_fd ,_ba :=_ca ._eef [r ];return _fd ,_ba ;
};func (_ebf *RuneRuneMap )Range (f func (_fg rune ,_gc rune )(_gbe bool )){_ebf ._gd .RLock ();defer _ebf ._gd .RUnlock ();for _abg ,_gcc :=range _ebf ._edc {if f (_abg ,_gcc ){break ;};};};func (_abe *RuneRuneMap )Write (g rune ,r rune ){_abe ._gd .Lock ();
defer _abe ._gd .Unlock ();_abe ._edc [g ]=r ;};func (_bgc *RuneRuneMap )Read (g rune )(rune ,bool ){_bgc ._gd .RLock ();defer _bgc ._gd .RUnlock ();_af ,_ac :=_bgc ._edc [g ];return _af ,_ac ;};type StringsMap struct{_cca map[string ]string ;_efa _eb .RWMutex ;
};func (_dba *RuneUint16Map )Length ()int {_dba ._cda .RLock ();defer _dba ._cda .RUnlock ();return len (_dba ._bdf );};func (_gf *RuneStringMap )Length ()int {_gf ._ccb .RLock ();defer _gf ._ccb .RUnlock ();return len (_gf ._bf );};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_ed :make (map[byte ]rune ,length )}};
func (_ce *RuneStringMap )Write (r rune ,s string ){_ce ._ccb .Lock ();defer _ce ._ccb .Unlock ();_ce ._bf [r ]=s ;};func (_fdb *StringsMap )Read (g string )(string ,bool ){_fdb ._efa .RLock ();defer _fdb ._efa .RUnlock ();_abf ,_fe :=_fdb ._cca [g ];return _abf ,_fe ;
};func (_c *ByteRuneMap )Write (b byte ,r rune ){_c ._a .Lock ();defer _c ._a .Unlock ();_c ._ed [b ]=r };type StringRuneMap struct{_gaf map[string ]rune ;_bfb _eb .RWMutex ;};func (_ded *StringRuneMap )Range (f func (_ef string ,_cf rune )(_bfda bool )){_ded ._bfb .RLock ();
defer _ded ._bfb .RUnlock ();for _bae ,_gdb :=range _ded ._gaf {if f (_bae ,_gdb ){break ;};};};func (_cdaf *RuneUint16Map )Range (f func (_gfb rune ,_cab uint16 )(_gfg bool )){_cdaf ._cda .RLock ();defer _cdaf ._cda .RUnlock ();for _afd ,_cae :=range _cdaf ._bdf {if f (_afd ,_cae ){break ;
};};};func (_gfbb *StringRuneMap )Length ()int {_gfbb ._bfb .RLock ();defer _gfbb ._bfb .RUnlock ();return len (_gfbb ._gaf );};type RuneSet struct{_eg map[rune ]struct{};_dc _eb .RWMutex ;};type StringsTuple struct{Key ,Value string ;};func (_adac *StringsMap )Copy ()*StringsMap {_adac ._efa .RLock ();
defer _adac ._efa .RUnlock ();_bfbg :=map[string ]string {};for _gg ,_bc :=range _adac ._cca {_bfbg [_gg ]=_bc ;};return &StringsMap {_cca :_bfbg };};func NewStringsMap (tuples []StringsTuple )*StringsMap {_dea :=map[string ]string {};for _ ,_dedf :=range tuples {_dea [_dedf .Key ]=_dedf .Value ;
};return &StringsMap {_cca :_dea };};func (_g *ByteRuneMap )Range (f func (_gb byte ,_f rune )(_fa bool )){_g ._a .RLock ();defer _g ._a .RUnlock ();for _ee ,_gba :=range _g ._ed {if f (_ee ,_gba ){break ;};};};func (_ede *RuneStringMap )Read (r rune )(string ,bool ){_ede ._ccb .RLock ();
defer _ede ._ccb .RUnlock ();_afe ,_abgg :=_ede ._bf [r ];return _afe ,_abgg ;};func (_cdbe *StringsMap )Range (f func (_def ,_deg string )(_ebc bool )){_cdbe ._efa .RLock ();defer _cdbe ._efa .RUnlock ();for _df ,_cfc :=range _cdbe ._cca {if f (_df ,_cfc ){break ;
};};};type RuneRuneMap struct{_edc map[rune ]rune ;_gd _eb .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_ed :m }};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_bf :m }};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_bdf :make (map[rune ]uint16 ,length )};
};func (_ad *RuneByteMap )Range (f func (_cc rune ,_cd byte )(_aee bool )){_ad ._d .RLock ();defer _ad ._d .RUnlock ();for _eeb ,_ga :=range _ad ._eef {if f (_eeb ,_ga ){break ;};};};type RuneByteMap struct{_eef map[rune ]byte ;_d _eb .RWMutex ;};