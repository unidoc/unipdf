//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_e "errors";_g "fmt";_ag "github.com/unidoc/unipdf/v4/common";_ec "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_a "io";);var _ BinaryWriter =&Writer {};func (_dac *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_e .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dac ._gad ._fac +offset ;};if length > 0{_de :=len (_dac ._gad ._cgg );if relative {_de =_dac ._gad ._aab ;};if offset +length > _de {return nil ,_g .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dac ._gad ._aab );
};};if length < 0{_cad :=len (_dac ._gad ._cgg );if relative {_cad =_dac ._gad ._aab ;};length =_cad -offset ;};return &Reader {_gad :readerSource {_cgg :_dac ._gad ._cgg ,_aab :length ,_fac :offset }},nil ;};type BufferedWriter struct{_bg []byte ;_eb uint8 ;
_ge int ;_ece bool ;};func (_ba *BufferedWriter )grow (_fa int ){if _ba ._bg ==nil &&_fa < _d {_ba ._bg =make ([]byte ,_fa ,_d );return ;};_gc :=len (_ba ._bg );if _ba ._eb !=0{_gc ++;};_gd :=cap (_ba ._bg );switch {case _fa <=_gd /2-_gc :_ag .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ba ._bg ),cap (_ba ._bg ),_fa );
_ag .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gd ,_gc );copy (_ba ._bg ,_ba ._bg [_ba .fullOffset ():]);
case _gd > _b -_gd -_fa :_ag .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ddg :=make ([]byte ,2*_gd +_fa );copy (_ddg ,_ba ._bg );_ba ._bg =_ddg ;};_ba ._bg =_ba ._bg [:_gc +_fa ];
};type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;};type BitWriter interface{WriteBit (_fcf int )error ;WriteBits (_efd uint64 ,_fg int )(_cc int ,_eba error );FinishByte ();SkipBits (_cd int )error ;};func (_def *Reader )AbsolutePosition ()int64 {return _def ._ccb +int64 (_def ._gad ._fac )};
func (_fbd *Reader )ReadBits (n byte )(_ac uint64 ,_ecab error ){if n < _fbd ._baa {_cfe :=_fbd ._baa -n ;_ac =uint64 (_fbd ._cgb >>_cfe );_fbd ._cgb &=1<<_cfe -1;_fbd ._baa =_cfe ;return _ac ,nil ;};if n > _fbd ._baa {if _fbd ._baa > 0{_ac =uint64 (_fbd ._cgb );
n -=_fbd ._baa ;};for n >=8{_bdfc ,_dee :=_fbd .readBufferByte ();if _dee !=nil {return 0,_dee ;};_ac =_ac <<8+uint64 (_bdfc );n -=8;};if n > 0{if _fbd ._cgb ,_ecab =_fbd .readBufferByte ();_ecab !=nil {return 0,_ecab ;};_cda :=8-n ;_ac =_ac <<n +uint64 (_fbd ._cgb >>_cda );
_fbd ._cgb &=1<<_cda -1;_fbd ._baa =_cda ;}else {_fbd ._baa =0;};return _ac ,nil ;};_fbd ._baa =0;return uint64 (_fbd ._cgb ),nil ;};func NewReader (data []byte )*Reader {return &Reader {_gad :readerSource {_cgg :data ,_aab :len (data ),_fac :0}};};func (_fce *Reader )readBufferByte ()(byte ,error ){if _fce ._ccb >=int64 (_fce ._gad ._aab ){return 0,_a .EOF ;
};_fce ._aadb =-1;_ebd :=_fce ._gad ._cgg [int64 (_fce ._gad ._fac )+_fce ._ccb ];_fce ._ccb ++;_fce ._cee =int (_ebd );return _ebd ,nil ;};func (_bd *Reader )Length ()uint64 {return uint64 (_bd ._gad ._aab )};var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};
_ _a .Seeker =&Reader {};_ StreamReader =&Reader {};);var _ BinaryWriter =&BufferedWriter {};func (_ebc *Reader )BitPosition ()int {return int (_ebc ._baa )};func (_af *BufferedWriter )Data ()[]byte {return _af ._bg };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ece :true }};
func (_ega *BufferedWriter )writeShiftedBytes (_da []byte )int {for _ ,_bgd :=range _da {_ega .writeByte (_bgd );};return len (_da );};func (_ed *BufferedWriter )FinishByte (){if _ed ._eb ==0{return ;};_ed ._eb =0;_ed ._ge ++;};const (_d =64;_b =int (^uint (0)>>1);
);func (_dc *BufferedWriter )WriteByte (bt byte )error {if _dc ._ge > len (_dc ._bg )-1||(_dc ._ge ==len (_dc ._bg )-1&&_dc ._eb !=0){_dc .expandIfNeeded (1);};_dc .writeByte (bt );return nil ;};func (_eae *Writer )WriteByte (c byte )error {return _eae .writeByte (c )};
type Reader struct{_gad readerSource ;_cgb byte ;_baa byte ;_ccb int64 ;_cee int ;_aadb int ;_ea int64 ;_bae byte ;_fdb byte ;_geda int ;};func (_fcag *Writer )ResetBit (){_fcag ._bcc =0};func (_fcc *BufferedWriter )Write (d []byte )(int ,error ){_fcc .expandIfNeeded (len (d ));
if _fcc ._eb ==0{return _fcc .writeFullBytes (d ),nil ;};return _fcc .writeShiftedBytes (d ),nil ;};func (_ebb *BufferedWriter )writeFullBytes (_dg []byte )int {_gbd :=copy (_ebb ._bg [_ebb .fullOffset ():],_dg );_ebb ._ge +=_gbd ;return _gbd ;};func (_ged *BufferedWriter )Reset (){_ged ._bg =_ged ._bg [:0];
_ged ._ge =0;_ged ._eb =0};func NewWriter (data []byte )*Writer {return &Writer {_edf :data }};func (_faf *Reader )ReadBit ()(_ecg int ,_dgg error ){_cde ,_dgg :=_faf .readBool ();if _dgg !=nil {return 0,_dgg ;};if _cde {_ecg =1;};return _ecg ,nil ;};func (_gdg *Reader )AbsoluteLength ()uint64 {return uint64 (len (_gdg ._gad ._cgg ))};
func (_fbf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fbf ._aadb =-1;_fbf ._baa =0;_fbf ._cgb =0;_fbf ._cee =0;var _dcgd int64 ;switch whence {case _a .SeekStart :_dcgd =offset ;case _a .SeekCurrent :_dcgd =_fbf ._ccb +offset ;case _a .SeekEnd :_dcgd =int64 (_fbf ._gad ._aab )+offset ;
default:return 0,_e .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _dcgd < 0{return 0,_e .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_fbf ._ccb =_dcgd ;_fbf ._baa =0;return _dcgd ,nil ;};func (_bac *BufferedWriter )tryGrowByReslice (_ga int )bool {if _gf :=len (_bac ._bg );_ga <=cap (_bac ._bg )-_gf {_bac ._bg =_bac ._bg [:_gf +_ga ];return true ;};return false ;};func (_fca *Reader )Align ()(_fba byte ){_fba =_fca ._baa ;
_fca ._baa =0;return _fba };func (_ab *Writer )Data ()[]byte {return _ab ._edf };func (_dd *BufferedWriter )expandIfNeeded (_db int ){if !_dd .tryGrowByReslice (_db ){_dd .grow (_db );};};var _ _a .ByteWriter =&BufferedWriter {};func (_gb *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_agc :=int (_gb ._eb )+skip ;if _agc >=0&&_agc < 8{_gb ._eb =uint8 (_agc );return nil ;};_agc =int (_gb ._eb )+_gb ._ge *8+skip ;if _agc < 0{return _ec .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fc :=_agc /8;_be :=_agc %8;_gb ._eb =uint8 (_be );if _bc :=_fc -_gb ._ge ;_bc > 0&&len (_gb ._bg )-1< _fc {if _gb ._eb !=0{_bc ++;};_gb .expandIfNeeded (_bc );};_gb ._ge =_fc ;return nil ;};func (_ecac *Reader )RelativePosition ()int64 {return _ecac ._ccb };
type Writer struct{_edf []byte ;_bcc uint8 ;_cgc int ;_afe bool ;};type readerSource struct{_cgg []byte ;_fac int ;_aab int ;};func (_dge *Writer )Write (p []byte )(int ,error ){if len (p )> _dge .byteCapacity (){return 0,_a .EOF ;};for _ ,_dad :=range p {if _cfa :=_dge .writeByte (_dad );
_cfa !=nil {return 0,_cfa ;};};return len (p ),nil ;};func (_ddb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ddb .writeBit (uint8 (bit ));};return _ec .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_bdd *Reader )Mark (){_bdd ._ea =_bdd ._ccb ;_bdd ._bae =_bdd ._baa ;_bdd ._fdb =_bdd ._cgb ;_bdd ._geda =_bdd ._cee ;};func (_ad *Reader )ReadByte ()(byte ,error ){if _ad ._baa ==0{return _ad .readBufferByte ();};return _ad .readUnalignedByte ();
};func (_aga *BufferedWriter )Len ()int {return _aga .byteCapacity ()};func (_dda *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _dda ._baa !=0{return _dda .ReadBits (_dda ._baa );};return 0,nil ;};func (_fdg *Reader )read (_gcc []byte )(int ,error ){if _fdg ._ccb >=int64 (_fdg ._gad ._aab ){return 0,_a .EOF ;
};_fdg ._aadb =-1;_cca :=copy (_gcc ,_fdg ._gad ._cgg [(int64 (_fdg ._gad ._fac )+_fdg ._ccb ):(_fdg ._gad ._fac +_fdg ._gad ._aab )]);_fdg ._ccb +=int64 (_cca );return _cca ,nil ;};func (_bcaa *BufferedWriter )fullOffset ()int {_cf :=_bcaa ._ge ;if _bcaa ._eb !=0{_cf ++;
};return _cf ;};func (_aa *BufferedWriter )WriteBits (bits uint64 ,number int )(_fd int ,_df error ){const _fb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ec .Errorf (_fb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_bcg :=number /8;if _bcg > 0{_dcg :=number -_bcg *8;for _beg :=_bcg -1;_beg >=0;_beg --{_ae :=byte ((bits >>uint (_beg *8+_dcg ))&0xff);if _df =_aa .WriteByte (_ae );_df !=nil {return _fd ,_ec .Wrapf (_df ,_fb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bcg -_beg +1);
};};number -=_bcg *8;if number ==0{return _bcg ,nil ;};};var _ebg int ;for _aad :=0;_aad < number ;_aad ++{if _aa ._ece {_ebg =int ((bits >>uint (number -1-_aad ))&0x1);}else {_ebg =int (bits &0x1);bits >>=1;};if _df =_aa .WriteBit (_ebg );_df !=nil {return _fd ,_ec .Wrapf (_df ,_fb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_aad );
};};return _bcg ,nil ;};func (_gbb *Writer )writeBit (_ebdd uint8 )error {if len (_gbb ._edf )-1< _gbb ._cgc {return _a .EOF ;};_ceg :=_gbb ._bcc ;if _gbb ._afe {_ceg =7-_gbb ._bcc ;};_gbb ._edf [_gbb ._cgc ]|=byte (uint16 (_ebdd <<_ceg )&0xff);_gbb ._bcc ++;
if _gbb ._bcc ==8{_gbb ._cgc ++;_gbb ._bcc =0;};return nil ;};func (_afd *Writer )UseMSB ()bool {return _afd ._afe };func (_ff *BufferedWriter )byteCapacity ()int {_geg :=len (_ff ._bg )-_ff ._ge ;if _ff ._eb !=0{_geg --;};return _geg ;};var _ _a .Writer =&BufferedWriter {};
func (_ecd *Writer )SkipBits (skip int )error {const _gfd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ffa :=int (_ecd ._bcc )+skip ;if _ffa >=0&&_ffa < 8{_ecd ._bcc =uint8 (_ffa );return nil ;
};_ffa =int (_ecd ._bcc )+_ecd ._cgc *8+skip ;if _ffa < 0{return _ec .Errorf (_gfd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ccaf :=_ffa /8;_dbc :=_ffa %8;_ag .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_ag .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_ecd ._bcc ,_ecd ._cgc ,int (_ecd ._bcc )+(_ecd ._cgc )*8,len (_ecd ._edf ),cap (_ecd ._edf ));
_ag .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ffa ,_dbc );_ecd ._bcc =uint8 (_dbc );if _bcef :=_ccaf -_ecd ._cgc ;
_bcef > 0&&len (_ecd ._edf )-1< _ccaf {_ag .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_bcef );return _ec .Errorf (_gfd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ecd ._cgc =_ccaf ;_ag .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_ecd ._bcc ,_ecd ._cgc );return nil ;};func (_aea *BufferedWriter )writeByte (_gec byte ){switch {case _aea ._eb ==0:_aea ._bg [_aea ._ge ]=_gec ;
_aea ._ge ++;case _aea ._ece :_aea ._bg [_aea ._ge ]|=_gec >>_aea ._eb ;_aea ._ge ++;_aea ._bg [_aea ._ge ]=byte (uint16 (_gec )<<(8-_aea ._eb )&0xff);default:_aea ._bg [_aea ._ge ]|=byte (uint16 (_gec )<<_aea ._eb &0xff);_aea ._ge ++;_aea ._bg [_aea ._ge ]=_gec >>(8-_aea ._eb );
};};func (_dae *Reader )ReadUint32 ()(uint32 ,error ){_ecc :=make ([]byte ,4);_ ,_gca :=_dae .Read (_ecc );if _gca !=nil {return 0,_gca ;};return _f .BigEndian .Uint32 (_ecc ),nil ;};func (_bdf *Reader )Read (p []byte )(_dbb int ,_afg error ){if _bdf ._baa ==0{return _bdf .read (p );
};for ;_dbb < len (p );_dbb ++{if p [_dbb ],_afg =_bdf .readUnalignedByte ();_afg !=nil {return 0,_afg ;};};return _dbb ,nil ;};func (_fcef *Writer )WriteBits (bits uint64 ,number int )(_fgb int ,_ccg error ){const _bb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ec .Errorf (_bb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_ee :=number /8;if _ee > 0{_ecb :=number -_ee *8;for _aee :=_ee -1;_aee >=0;_aee --{_gcd :=byte ((bits >>uint (_aee *8+_ecb ))&0xff);if _ccg =_fcef .WriteByte (_gcd );_ccg !=nil {return _fgb ,_ec .Wrapf (_ccg ,_bb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ee -_aee +1);
};};number -=_ee *8;if number ==0{return _ee ,nil ;};};var _dfdg int ;for _cge :=0;_cge < number ;_cge ++{if _fcef ._afe {_dfdg =int ((bits >>uint (number -1-_cge ))&0x1);}else {_dfdg =int (bits &0x1);bits >>=1;};if _ccg =_fcef .WriteBit (_dfdg );_ccg !=nil {return _fgb ,_ec .Wrapf (_ccg ,_bb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cge );
};};return _ee ,nil ;};func (_efg *Writer )byteCapacity ()int {_edc :=len (_efg ._edf )-_efg ._cgc ;if _efg ._bcc !=0{_edc --;};return _edc ;};func (_ce *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ec .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ce ._bg )-1< _ce ._ge {_ce .expandIfNeeded (1);};_bce :=_ce ._eb ;if _ce ._ece {_bce =7-_ce ._eb ;};_ce ._bg [_ce ._ge ]|=byte (uint16 (bit <<_bce )&0xff);_ce ._eb ++;if _ce ._eb ==8{_ce ._ge ++;_ce ._eb =0;};return nil ;};func (_cdg *Reader )readBool ()(_fbag bool ,_aed error ){if _cdg ._baa ==0{_cdg ._cgb ,_aed =_cdg .readBufferByte ();
if _aed !=nil {return false ,_aed ;};_fbag =(_cdg ._cgb &0x80)!=0;_cdg ._cgb ,_cdg ._baa =_cdg ._cgb &0x7f,7;return _fbag ,nil ;};_cdg ._baa --;_fbag =(_cdg ._cgb &(1<<_cdg ._baa ))!=0;_cdg ._cgb &=1<<_cdg ._baa -1;return _fbag ,nil ;};func (_efde *Reader )ReadBool ()(bool ,error ){return _efde .readBool ()};
type StreamReader interface{_a .Reader ;_a .ByteReader ;_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_dgd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();
AbsolutePosition ()int64 ;};func (_agd *Reader )readUnalignedByte ()(_efdb byte ,_bf error ){_aabb :=_agd ._baa ;_efdb =_agd ._cgb <<(8-_aabb );_agd ._cgb ,_bf =_agd .readBufferByte ();if _bf !=nil {return 0,_bf ;};_efdb |=_agd ._cgb >>_aabb ;_agd ._cgb &=1<<_aabb -1;
return _efdb ,nil ;};func (_daf *Writer )writeByte (_bacd byte )error {if _daf ._cgc > len (_daf ._edf )-1{return _a .EOF ;};if _daf ._cgc ==len (_daf ._edf )-1&&_daf ._bcc !=0{return _a .EOF ;};if _daf ._bcc ==0{_daf ._edf [_daf ._cgc ]=_bacd ;_daf ._cgc ++;
return nil ;};if _daf ._afe {_daf ._edf [_daf ._cgc ]|=_bacd >>_daf ._bcc ;_daf ._cgc ++;_daf ._edf [_daf ._cgc ]=byte (uint16 (_bacd )<<(8-_daf ._bcc )&0xff);}else {_daf ._edf [_daf ._cgc ]|=byte (uint16 (_bacd )<<_daf ._bcc &0xff);_daf ._cgc ++;_daf ._edf [_daf ._cgc ]=_bacd >>(8-_daf ._bcc );
};return nil ;};func (_bcgf *Writer )FinishByte (){if _bcgf ._bcc ==0{return ;};_bcgf ._bcc =0;_bcgf ._cgc ++;};func NewWriterMSB (data []byte )*Writer {return &Writer {_edf :data ,_afe :true }};func (_ef *BufferedWriter )ResetBitIndex (){_ef ._eb =0};
func (_dfd *Reader )Reset (){_dfd ._ccb =_dfd ._ea ;_dfd ._baa =_dfd ._bae ;_dfd ._cgb =_dfd ._fdb ;_dfd ._cee =_dfd ._geda ;};