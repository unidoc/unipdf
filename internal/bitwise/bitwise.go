//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_ga "encoding/binary";_b "errors";_g "fmt";_f "github.com/unidoc/unipdf/v4/common";_aa "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_a "io";);func (_cfa *Writer )FinishByte (){if _cfa ._daa ==0{return ;};_cfa ._daa =0;_cfa ._afe ++;
};var _ _a .Writer =&BufferedWriter {};func (_ca *BufferedWriter )writeShiftedBytes (_bd []byte )int {for _ ,_ded :=range _bd {_ca .writeByte (_ded );};return len (_bd );};func (_fg *BufferedWriter )grow (_ec int ){if _fg ._eg ==nil &&_ec < _bg {_fg ._eg =make ([]byte ,_ec ,_bg );
return ;};_fe :=len (_fg ._eg );if _fg ._c !=0{_fe ++;};_ag :=cap (_fg ._eg );switch {case _ec <=_ag /2-_fe :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_fg ._eg ),cap (_fg ._eg ),_ec );
_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ag ,_fe );copy (_fg ._eg ,_fg ._eg [_fg .fullOffset ():]);
case _ag > _bf -_ag -_ec :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ecg :=make ([]byte ,2*_ag +_ec );copy (_ecg ,_fg ._eg );_fg ._eg =_ecg ;};_fg ._eg =_fg ._eg [:_fe +_ec ];
};func (_badb *Writer )WriteByte (c byte )error {return _badb .writeByte (c )};var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};_ _a .Seeker =&Reader {};_ StreamReader =&Reader {};);type Reader struct{_bbe readerSource ;_gdf byte ;_aga byte ;
_gad int64 ;_fgb int ;_ece int ;_gga int64 ;_aaa byte ;_caa byte ;_efa int ;};func (_ede *Writer )writeBit (_gae uint8 )error {if len (_ede ._gbc )-1< _ede ._afe {return _a .EOF ;};_age :=_ede ._daa ;if _ede ._gbf {_age =7-_ede ._daa ;};_ede ._gbc [_ede ._afe ]|=byte (uint16 (_gae <<_age )&0xff);
_ede ._daa ++;if _ede ._daa ==8{_ede ._afe ++;_ede ._daa =0;};return nil ;};func (_bcg *Reader )read (_fdg []byte )(int ,error ){if _bcg ._gad >=int64 (_bcg ._bbe ._ffd ){return 0,_a .EOF ;};_bcg ._ece =-1;_eae :=copy (_fdg ,_bcg ._bbe ._fce [(int64 (_bcg ._bbe ._ffc )+_bcg ._gad ):(_bcg ._bbe ._ffc +_bcg ._bbe ._ffd )]);
_bcg ._gad +=int64 (_eae );return _eae ,nil ;};type BitWriter interface{WriteBit (_ebg int )error ;WriteBits (_ab uint64 ,_ff int )(_ce int ,_aaf error );FinishByte ();SkipBits (_cgg int )error ;};func (_bcb *BufferedWriter )Write (d []byte )(int ,error ){_bcb .expandIfNeeded (len (d ));
if _bcb ._c ==0{return _bcb .writeFullBytes (d ),nil ;};return _bcb .writeShiftedBytes (d ),nil ;};func (_bcc *Reader )ReadBit ()(_gdg int ,_fge error ){_bae ,_fge :=_bcc .readBool ();if _fge !=nil {return 0,_fge ;};if _bae {_gdg =1;};return _gdg ,nil ;
};func (_egf *BufferedWriter )FinishByte (){if _egf ._c ==0{return ;};_egf ._c =0;_egf ._gb ++;};func (_bec *Writer )byteCapacity ()int {_cef :=len (_bec ._gbc )-_bec ._afe ;if _bec ._daa !=0{_cef --;};return _cef ;};const (_bg =64;_bf =int (^uint (0)>>1);
);var _ _a .ByteWriter =&BufferedWriter {};func (_fa *Reader )Length ()uint64 {return uint64 (_fa ._bbe ._ffd )};var _ BinaryWriter =&BufferedWriter {};func (_gce *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_cg :=int (_gce ._c )+skip ;
if _cg >=0&&_cg < 8{_gce ._c =uint8 (_cg );return nil ;};_cg =int (_gce ._c )+_gce ._gb *8+skip ;if _cg < 0{return _aa .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bc :=_cg /8;_cd :=_cg %8;_gce ._c =uint8 (_cd );if _ae :=_bc -_gce ._gb ;_ae > 0&&len (_gce ._eg )-1< _bc {if _gce ._c !=0{_ae ++;};_gce .expandIfNeeded (_ae );};_gce ._gb =_bc ;return nil ;};func (_gd *BufferedWriter )expandIfNeeded (_da int ){if !_gd .tryGrowByReslice (_da ){_gd .grow (_da );
};};func (_eca *Reader )readBool ()(_cggb bool ,_fdb error ){if _eca ._aga ==0{_eca ._gdf ,_fdb =_eca .readBufferByte ();if _fdb !=nil {return false ,_fdb ;};_cggb =(_eca ._gdf &0x80)!=0;_eca ._gdf ,_eca ._aga =_eca ._gdf &0x7f,7;return _cggb ,nil ;};_eca ._aga --;
_cggb =(_eca ._gdf &(1<<_eca ._aga ))!=0;_eca ._gdf &=1<<_eca ._aga -1;return _cggb ,nil ;};func (_gafdc *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gafdc .writeBit (uint8 (bit ));};return _aa .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;};func (_add *Writer )Data ()[]byte {return _add ._gbc };func (_fb *BufferedWriter )ResetBitIndex (){_fb ._c =0};func (_ffa *Reader )Read (p []byte )(_be int ,_bcfc error ){if _ffa ._aga ==0{return _ffa .read (p );
};for ;_be < len (p );_be ++{if p [_be ],_bcfc =_ffa .readUnalignedByte ();_bcfc !=nil {return 0,_bcfc ;};};return _be ,nil ;};func (_fd *Reader )RelativePosition ()int64 {return _fd ._gad };func (_aee *Reader )Mark (){_aee ._gga =_aee ._gad ;_aee ._aaa =_aee ._aga ;
_aee ._caa =_aee ._gdf ;_aee ._efa =_aee ._fgb ;};func (_gdb *Reader )BitPosition ()int {return int (_gdb ._aga )};func (_cgd *Reader )Align ()(_gdc byte ){_gdc =_cgd ._aga ;_cgd ._aga =0;return _gdc };func (_dbc *Writer )Write (p []byte )(int ,error ){if len (p )> _dbc .byteCapacity (){return 0,_a .EOF ;
};for _ ,_cc :=range p {if _ecb :=_dbc .writeByte (_cc );_ecb !=nil {return 0,_ecb ;};};return len (p ),nil ;};func (_efb *Reader )AbsoluteLength ()uint64 {return uint64 (len (_efb ._bbe ._fce ))};func (_dad *Reader )AbsolutePosition ()int64 {return _dad ._gad +int64 (_dad ._bbe ._ffc )};
func NewReader (data []byte )*Reader {return &Reader {_bbe :readerSource {_fce :data ,_ffd :len (data ),_ffc :0}};};func (_ef *BufferedWriter )Data ()[]byte {return _ef ._eg };func NewWriterMSB (data []byte )*Writer {return &Writer {_gbc :data ,_gbf :true }};
func (_def *BufferedWriter )writeFullBytes (_fcf []byte )int {_gac :=copy (_def ._eg [_def .fullOffset ():],_fcf );_def ._gb +=_gac ;return _gac ;};func (_de *BufferedWriter )WriteByte (bt byte )error {if _de ._gb > len (_de ._eg )-1||(_de ._gb ==len (_de ._eg )-1&&_de ._c !=0){_de .expandIfNeeded (1);
};_de .writeByte (bt );return nil ;};func (_eafd *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _eafd ._aga !=0{return _eafd .ReadBits (_eafd ._aga );};return 0,nil ;};func (_ed *Reader )ReadByte ()(byte ,error ){if _ed ._aga ==0{return _ed .readBufferByte ();
};return _ed .readUnalignedByte ();};func (_baf *Writer )ResetBit (){_baf ._daa =0};type readerSource struct{_fce []byte ;_ffc int ;_ffd int ;};func (_ee *BufferedWriter )byteCapacity ()int {_ba :=len (_ee ._eg )-_ee ._gb ;if _ee ._c !=0{_ba --;};return _ba ;
};type BufferedWriter struct{_eg []byte ;_c uint8 ;_gb int ;_gc bool ;};func (_gcec *Writer )UseMSB ()bool {return _gcec ._gbf };func (_d *BufferedWriter )Len ()int {return _d .byteCapacity ()};func (_geb *Reader )readBufferByte ()(byte ,error ){if _geb ._gad >=int64 (_geb ._bbe ._ffd ){return 0,_a .EOF ;
};_geb ._ece =-1;_bbc :=_geb ._bbe ._fce [int64 (_geb ._bbe ._ffc )+_geb ._gad ];_geb ._gad ++;_geb ._fgb =int (_bbc );return _bbc ,nil ;};func (_fgd *Writer )WriteBits (bits uint64 ,number int )(_cggf int ,_bbde error ){const _gdgg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_aa .Errorf (_gdgg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gdfc :=number /8;if _gdfc > 0{_cea :=number -_gdfc *8;for _bfb :=_gdfc -1;_bfb >=0;_bfb --{_dd :=byte ((bits >>uint (_bfb *8+_cea ))&0xff);if _bbde =_fgd .WriteByte (_dd );_bbde !=nil {return _cggf ,_aa .Wrapf (_bbde ,_gdgg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gdfc -_bfb +1);
};};number -=_gdfc *8;if number ==0{return _gdfc ,nil ;};};var _cfg int ;for _bde :=0;_bde < number ;_bde ++{if _fgd ._gbf {_cfg =int ((bits >>uint (number -1-_bde ))&0x1);}else {_cfg =int (bits &0x1);bits >>=1;};if _bbde =_fgd .WriteBit (_cfg );_bbde !=nil {return _cggf ,_aa .Wrapf (_bbde ,_gdgg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bde );
};};return _gdfc ,nil ;};func (_cge *Reader )readUnalignedByte ()(_bbd byte ,_ebf error ){_ebca :=_cge ._aga ;_bbd =_cge ._gdf <<(8-_ebca );_cge ._gdf ,_ebf =_cge .readBufferByte ();if _ebf !=nil {return 0,_ebf ;};_bbd |=_cge ._gdf >>_ebca ;_cge ._gdf &=1<<_ebca -1;
return _bbd ,nil ;};func (_dg *BufferedWriter )Reset (){_dg ._eg =_dg ._eg [:0];_dg ._gb =0;_dg ._c =0};func (_fef *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fef ._ece =-1;_fef ._aga =0;_fef ._gdf =0;_fef ._fgb =0;var _fcg int64 ;switch whence {case _a .SeekStart :_fcg =offset ;
case _a .SeekCurrent :_fcg =_fef ._gad +offset ;case _a .SeekEnd :_fcg =int64 (_fef ._bbe ._ffd )+offset ;default:return 0,_b .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _fcg < 0{return 0,_b .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fef ._gad =_fcg ;
_fef ._aga =0;return _fcg ,nil ;};func (_ebc *BufferedWriter )tryGrowByReslice (_adg int )bool {if _af :=len (_ebc ._eg );_adg <=cap (_ebc ._eg )-_af {_ebc ._eg =_ebc ._eg [:_af +_adg ];return true ;};return false ;};func (_gccg *BufferedWriter )fullOffset ()int {_deg :=_gccg ._gb ;
if _gccg ._c !=0{_deg ++;};return _deg ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_gc :true }};func (_edc *Writer )SkipBits (skip int )error {const _dcd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_eba :=int (_edc ._daa )+skip ;if _eba >=0&&_eba < 8{_edc ._daa =uint8 (_eba );return nil ;};_eba =int (_edc ._daa )+_edc ._afe *8+skip ;if _eba < 0{return _aa .Errorf (_dcd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ffe :=_eba /8;_gge :=_eba %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_edc ._daa ,_edc ._afe ,int (_edc ._daa )+(_edc ._afe )*8,len (_edc ._gbc ),cap (_edc ._gbc ));
_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_eba ,_gge );_edc ._daa =uint8 (_gge );if _gcg :=_ffe -_edc ._afe ;
_gcg > 0&&len (_edc ._gbc )-1< _ffe {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gcg );return _aa .Errorf (_dcd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_edc ._afe =_ffe ;
_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_edc ._daa ,_edc ._afe );return nil ;};func (_gbed *Reader )ReadUint32 ()(uint32 ,error ){_gccgc :=make ([]byte ,4);
_ ,_dc :=_gbed .Read (_gccgc );if _dc !=nil {return 0,_dc ;};return _ga .BigEndian .Uint32 (_gccgc ),nil ;};type Writer struct{_gbc []byte ;_daa uint8 ;_afe int ;_gbf bool ;};func (_fga *BufferedWriter )writeByte (_eaf byte ){switch {case _fga ._c ==0:_fga ._eg [_fga ._gb ]=_eaf ;
_fga ._gb ++;case _fga ._gc :_fga ._eg [_fga ._gb ]|=_eaf >>_fga ._c ;_fga ._gb ++;_fga ._eg [_fga ._gb ]=byte (uint16 (_eaf )<<(8-_fga ._c )&0xff);default:_fga ._eg [_fga ._gb ]|=byte (uint16 (_eaf )<<_fga ._c &0xff);_fga ._gb ++;_fga ._eg [_fga ._gb ]=_eaf >>(8-_fga ._c );
};};func (_bfc *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _aa .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_bfc ._eg )-1< _bfc ._gb {_bfc .expandIfNeeded (1);};_ea :=_bfc ._c ;if _bfc ._gc {_ea =7-_bfc ._c ;};_bfc ._eg [_bfc ._gb ]|=byte (uint16 (bit <<_ea )&0xff);_bfc ._c ++;if _bfc ._c ==8{_bfc ._gb ++;_bfc ._c =0;};return nil ;};type StreamReader interface{_a .Reader ;
_a .ByteReader ;_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_agd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_bdb *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_b .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_bdb ._bbe ._ffc +offset ;};if length > 0{_gafd :=len (_bdb ._bbe ._fce );if relative {_gafd =_bdb ._bbe ._ffd ;};if offset +length > _gafd {return nil ,_g .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_bdb ._bbe ._ffd );
};};if length < 0{_ceb :=len (_bdb ._bbe ._fce );if relative {_ceb =_bdb ._bbe ._ffd ;};length =_ceb -offset ;};return &Reader {_bbe :readerSource {_fce :_bdb ._bbe ._fce ,_ffd :length ,_ffc :offset }},nil ;};func (_cb *Writer )writeByte (_df byte )error {if _cb ._afe > len (_cb ._gbc )-1{return _a .EOF ;
};if _cb ._afe ==len (_cb ._gbc )-1&&_cb ._daa !=0{return _a .EOF ;};if _cb ._daa ==0{_cb ._gbc [_cb ._afe ]=_df ;_cb ._afe ++;return nil ;};if _cb ._gbf {_cb ._gbc [_cb ._afe ]|=_df >>_cb ._daa ;_cb ._afe ++;_cb ._gbc [_cb ._afe ]=byte (uint16 (_df )<<(8-_cb ._daa )&0xff);
}else {_cb ._gbc [_cb ._afe ]|=byte (uint16 (_df )<<_cb ._daa &0xff);_cb ._afe ++;_cb ._gbc [_cb ._afe ]=_df >>(8-_cb ._daa );};return nil ;};var _ BinaryWriter =&Writer {};func (_ffdf *Reader )ReadBool ()(bool ,error ){return _ffdf .readBool ()};func NewWriter (data []byte )*Writer {return &Writer {_gbc :data }};
func (_gaf *BufferedWriter )WriteBits (bits uint64 ,number int )(_gg int ,_gcc error ){const _ge ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_aa .Errorf (_ge ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_db :=number /8;if _db > 0{_dbe :=number -_db *8;for _fc :=_db -1;_fc >=0;_fc --{_ggb :=byte ((bits >>uint (_fc *8+_dbe ))&0xff);if _gcc =_gaf .WriteByte (_ggb );_gcc !=nil {return _gg ,_aa .Wrapf (_gcc ,_ge ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_db -_fc +1);
};};number -=_db *8;if number ==0{return _db ,nil ;};};var _dbf int ;for _ggd :=0;_ggd < number ;_ggd ++{if _gaf ._gc {_dbf =int ((bits >>uint (number -1-_ggd ))&0x1);}else {_dbf =int (bits &0x1);bits >>=1;};if _gcc =_gaf .WriteBit (_dbf );_gcc !=nil {return _gg ,_aa .Wrapf (_gcc ,_ge ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ggd );
};};return _db ,nil ;};func (_fgea *Reader )ReadBits (n byte )(_bad uint64 ,_eea error ){if n < _fgea ._aga {_gf :=_fgea ._aga -n ;_bad =uint64 (_fgea ._gdf >>_gf );_fgea ._gdf &=1<<_gf -1;_fgea ._aga =_gf ;return _bad ,nil ;};if n > _fgea ._aga {if _fgea ._aga > 0{_bad =uint64 (_fgea ._gdf );
n -=_fgea ._aga ;};for n >=8{_gfa ,_egb :=_fgea .readBufferByte ();if _egb !=nil {return 0,_egb ;};_bad =_bad <<8+uint64 (_gfa );n -=8;};if n > 0{if _fgea ._gdf ,_eea =_fgea .readBufferByte ();_eea !=nil {return 0,_eea ;};_cf :=8-n ;_bad =_bad <<n +uint64 (_fgea ._gdf >>_cf );
_fgea ._gdf &=1<<_cf -1;_fgea ._aga =_cf ;}else {_fgea ._aga =0;};return _bad ,nil ;};_fgea ._aga =0;return uint64 (_fgea ._gdf ),nil ;};func (_dgg *Reader )Reset (){_dgg ._gad =_dgg ._gga ;_dgg ._aga =_dgg ._aaa ;_dgg ._gdf =_dgg ._caa ;_dgg ._fgb =_dgg ._efa ;
};