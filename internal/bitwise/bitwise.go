//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_ce "encoding/binary";_a "errors";_cg "fmt";_f "github.com/unidoc/unipdf/v4/common";_eb "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_e "io";);func NewReader (data []byte )*Reader {return &Reader {_afd :readerSource {_gg :data ,_gf :len (data ),_df :0}};
};func (_ca *BufferedWriter )FinishByte (){if _ca ._b ==0{return ;};_ca ._b =0;_ca ._ec ++;};func (_ffc *BufferedWriter )byteCapacity ()int {_gea :=len (_ffc ._eg )-_ffc ._ec ;if _ffc ._b !=0{_gea --;};return _gea ;};func (_afa *BufferedWriter )expandIfNeeded (_dc int ){if !_afa .tryGrowByReslice (_dc ){_afa .grow (_dc );
};};type readerSource struct{_gg []byte ;_df int ;_gf int ;};func (_ea *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _eb .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ea ._eg )-1< _ea ._ec {_ea .expandIfNeeded (1);};_ee :=_ea ._b ;if _ea ._fe {_ee =7-_ea ._b ;};_ea ._eg [_ea ._ec ]|=byte (uint16 (bit <<_ee )&0xff);_ea ._b ++;if _ea ._b ==8{_ea ._ec ++;_ea ._b =0;};return nil ;};func (_gaa *BufferedWriter )writeShiftedBytes (_dcc []byte )int {for _ ,_bfe :=range _dcc {_gaa .writeByte (_bfe );
};return len (_dcc );};func (_fge *Writer )Data ()[]byte {return _fge ._ffb };func (_cd *BufferedWriter )Write (d []byte )(int ,error ){_cd .expandIfNeeded (len (d ));if _cd ._b ==0{return _cd .writeFullBytes (d ),nil ;};return _cd .writeShiftedBytes (d ),nil ;
};func (_bdg *Reader )Read (p []byte )(_fc int ,_efa error ){if _bdg ._be ==0{return _bdg .read (p );};for ;_fc < len (p );_fc ++{if p [_fc ],_efa =_bdg .readUnalignedByte ();_efa !=nil {return 0,_efa ;};};return _fc ,nil ;};func (_fec *Reader )readBool ()(_bcde bool ,_cec error ){if _fec ._be ==0{_fec ._eff ,_cec =_fec .readBufferByte ();
if _cec !=nil {return false ,_cec ;};_bcde =(_fec ._eff &0x80)!=0;_fec ._eff ,_fec ._be =_fec ._eff &0x7f,7;return _bcde ,nil ;};_fec ._be --;_bcde =(_fec ._eff &(1<<_fec ._be ))!=0;_fec ._eff &=1<<_fec ._be -1;return _bcde ,nil ;};func (_bd *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_a .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_bd ._afd ._df +offset ;};if length > 0{_geb :=len (_bd ._afd ._gg );if relative {_geb =_bd ._afd ._gf ;};if offset +length > _geb {return nil ,_cg .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_bd ._afd ._gf );
};};if length < 0{_fg :=len (_bd ._afd ._gg );if relative {_fg =_bd ._afd ._gf ;};length =_fg -offset ;};return &Reader {_afd :readerSource {_gg :_bd ._afd ._gg ,_gf :length ,_df :offset }},nil ;};func (_gd *BufferedWriter )Data ()[]byte {return _gd ._eg };
func (_ffd *Writer )writeBit (_gc uint8 )error {if len (_ffd ._ffb )-1< _ffd ._agd {return _e .EOF ;};_dfc :=_ffd ._cedg ;if _ffd ._dbae {_dfc =7-_ffd ._cedg ;};_ffd ._ffb [_ffd ._agd ]|=byte (uint16 (_gc <<_dfc )&0xff);_ffd ._cedg ++;if _ffd ._cedg ==8{_ffd ._agd ++;
_ffd ._cedg =0;};return nil ;};func (_cbd *Reader )Length ()uint64 {return uint64 (_cbd ._afd ._gf )};func (_fcc *Reader )ReadBits (n byte )(_cbdc uint64 ,_cdc error ){if n < _fcc ._be {_fegg :=_fcc ._be -n ;_cbdc =uint64 (_fcc ._eff >>_fegg );_fcc ._eff &=1<<_fegg -1;
_fcc ._be =_fegg ;return _cbdc ,nil ;};if n > _fcc ._be {if _fcc ._be > 0{_cbdc =uint64 (_fcc ._eff );n -=_fcc ._be ;};for n >=8{_cbde ,_dcb :=_fcc .readBufferByte ();if _dcb !=nil {return 0,_dcb ;};_cbdc =_cbdc <<8+uint64 (_cbde );n -=8;};if n > 0{if _fcc ._eff ,_cdc =_fcc .readBufferByte ();
_cdc !=nil {return 0,_cdc ;};_eba :=8-n ;_cbdc =_cbdc <<n +uint64 (_fcc ._eff >>_eba );_fcc ._eff &=1<<_eba -1;_fcc ._be =_eba ;}else {_fcc ._be =0;};return _cbdc ,nil ;};_fcc ._be =0;return uint64 (_fcc ._eff ),nil ;};func (_ebdg *Writer )UseMSB ()bool {return _ebdg ._dbae };
func (_dfe *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dfe ._gae =-1;_dfe ._be =0;_dfe ._eff =0;_dfe ._eca =0;var _eae int64 ;switch whence {case _e .SeekStart :_eae =offset ;case _e .SeekCurrent :_eae =_dfe ._ebdc +offset ;case _e .SeekEnd :_eae =int64 (_dfe ._afd ._gf )+offset ;
default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _eae < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_dfe ._ebdc =_eae ;_dfe ._be =0;return _eae ,nil ;};var _ _e .ByteWriter =&BufferedWriter {};func (_dcf *Reader )AbsolutePosition ()int64 {return _dcf ._ebdc +int64 (_dcf ._afd ._df )};func (_bb *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bb ._be !=0{return _bb .ReadBits (_bb ._be );
};return 0,nil ;};func (_aab *BufferedWriter )grow (_ebb int ){if _aab ._eg ==nil &&_ebb < _g {_aab ._eg =make ([]byte ,_ebb ,_g );return ;};_ad :=len (_aab ._eg );if _aab ._b !=0{_ad ++;};_ae :=cap (_aab ._eg );switch {case _ebb <=_ae /2-_ad :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_aab ._eg ),cap (_aab ._eg ),_ebb );
_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ae ,_ad );copy (_aab ._eg ,_aab ._eg [_aab .fullOffset ():]);
case _ae > _ff -_ae -_ebb :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_afb :=make ([]byte ,2*_ae +_ebb );copy (_afb ,_aab ._eg );_aab ._eg =_afb ;};_aab ._eg =_aab ._eg [:_ad +_ebb ];
};func (_afbb *Reader )Reset (){_afbb ._ebdc =_afbb ._acb ;_afbb ._be =_afbb ._cbe ;_afbb ._eff =_afbb ._fea ;_afbb ._eca =_afbb ._aec ;};type BufferedWriter struct{_eg []byte ;_b uint8 ;_ec int ;_fe bool ;};func (_gdg *Writer )WriteByte (c byte )error {return _gdg .writeByte (c )};
func (_fb *Reader )RelativePosition ()int64 {return _fb ._ebdc };type BitWriter interface{WriteBit (_db int )error ;WriteBits (_dba uint64 ,_afc int )(_ag int ,_eea error );FinishByte ();SkipBits (_ffe int )error ;};func (_fgd *Writer )FinishByte (){if _fgd ._cedg ==0{return ;
};_fgd ._cedg =0;_fgd ._agd ++;};func (_bbb *Reader )readUnalignedByte ()(_gac byte ,_dd error ){_bea :=_bbb ._be ;_gac =_bbb ._eff <<(8-_bea );_bbb ._eff ,_dd =_bbb .readBufferByte ();if _dd !=nil {return 0,_dd ;};_gac |=_bbb ._eff >>_bea ;_bbb ._eff &=1<<_bea -1;
return _gac ,nil ;};func (_cb *BufferedWriter )writeFullBytes (_de []byte )int {_ed :=copy (_cb ._eg [_cb .fullOffset ():],_de );_cb ._ec +=_ed ;return _ed ;};func (_af *BufferedWriter )Len ()int {return _af .byteCapacity ()};func (_d *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_fff :=int (_d ._b )+skip ;if _fff >=0&&_fff < 8{_d ._b =uint8 (_fff );return nil ;};_fff =int (_d ._b )+_d ._ec *8+skip ;if _fff < 0{return _eb .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_feg :=_fff /8;_ecd :=_fff %8;_d ._b =uint8 (_ecd );if _ceg :=_feg -_d ._ec ;_ceg > 0&&len (_d ._eg )-1< _feg {if _d ._b !=0{_ceg ++;};_d .expandIfNeeded (_ceg );};_d ._ec =_feg ;return nil ;};func (_bc *BufferedWriter )Reset (){_bc ._eg =_bc ._eg [:0];
_bc ._ec =0;_bc ._b =0};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;Data ()[]byte ;};func (_gag *Reader )ReadUint32 ()(uint32 ,error ){_bcd :=make ([]byte ,4);_ ,_eec :=_gag .Read (_bcd );if _eec !=nil {return 0,_eec ;};return _ce .BigEndian .Uint32 (_bcd ),nil ;
};func (_dae *Reader )BitPosition ()int {return int (_dae ._be )};func (_dg *Writer )SkipBits (skip int )error {const _dfd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ecg :=int (_dg ._cedg )+skip ;
if _ecg >=0&&_ecg < 8{_dg ._cedg =uint8 (_ecg );return nil ;};_ecg =int (_dg ._cedg )+_dg ._agd *8+skip ;if _ecg < 0{return _eb .Errorf (_dfd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_afbd :=_ecg /8;
_ebe :=_ecg %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dg ._cedg ,_dg ._agd ,int (_dg ._cedg )+(_dg ._agd )*8,len (_dg ._ffb ),cap (_dg ._ffb ));
_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ecg ,_ebe );_dg ._cedg =uint8 (_ebe );if _ead :=_afbd -_dg ._agd ;
_ead > 0&&len (_dg ._ffb )-1< _afbd {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ead );return _eb .Errorf (_dfd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dg ._agd =_afbd ;
_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dg ._cedg ,_dg ._agd );return nil ;};var _ BinaryWriter =&Writer {};
func (_gebg *Reader )ReadByte ()(byte ,error ){if _gebg ._be ==0{return _gebg .readBufferByte ();};return _gebg .readUnalignedByte ();};func (_ebd *BufferedWriter )WriteBits (bits uint64 ,number int )(_fa int ,_bf error ){const _da ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_eb .Errorf (_da ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cdg :=number /8;if _cdg > 0{_gda :=number -_cdg *8;for _fd :=_cdg -1;_fd >=0;_fd --{_cdf :=byte ((bits >>uint (_fd *8+_gda ))&0xff);if _bf =_ebd .WriteByte (_cdf );_bf !=nil {return _fa ,_eb .Wrapf (_bf ,_da ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cdg -_fd +1);
};};number -=_cdg *8;if number ==0{return _cdg ,nil ;};};var _aad int ;for _ge :=0;_ge < number ;_ge ++{if _ebd ._fe {_aad =int ((bits >>uint (number -1-_ge ))&0x1);}else {_aad =int (bits &0x1);bits >>=1;};if _bf =_ebd .WriteBit (_aad );_bf !=nil {return _fa ,_eb .Wrapf (_bf ,_da ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ge );
};};return _cdg ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_ffb :data ,_dbae :true }};func (_ecb *Reader )ReadBit ()(_aga int ,_bge error ){_dbe ,_bge :=_ecb .readBool ();if _bge !=nil {return 0,_bge ;};if _dbe {_aga =1;};return _aga ,nil ;
};var _ BinaryWriter =&BufferedWriter {};var _ _e .Writer =&BufferedWriter {};func (_ac *BufferedWriter )WriteByte (bt byte )error {if _ac ._ec > len (_ac ._eg )-1||(_ac ._ec ==len (_ac ._eg )-1&&_ac ._b !=0){_ac .expandIfNeeded (1);};_ac .writeByte (bt );
return nil ;};type Reader struct{_afd readerSource ;_eff byte ;_be byte ;_ebdc int64 ;_eca int ;_gae int ;_acb int64 ;_cbe byte ;_fea byte ;_aec int ;};func (_gdeb *Reader )ReadBool ()(bool ,error ){return _gdeb .readBool ()};func (_dad *Writer )byteCapacity ()int {_fbe :=len (_dad ._ffb )-_dad ._agd ;
if _dad ._cedg !=0{_fbe --;};return _fbe ;};func (_gab *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gab .writeBit (uint8 (bit ));};return _eb .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_ded *Reader )readBufferByte ()(byte ,error ){if _ded ._ebdc >=int64 (_ded ._afd ._gf ){return 0,_e .EOF ;};_ded ._gae =-1;_dccg :=_ded ._afd ._gg [int64 (_ded ._afd ._df )+_ded ._ebdc ];_ded ._ebdc ++;_ded ._eca =int (_dccg );return _dccg ,nil ;
};func (_afea *Reader )AbsoluteLength ()uint64 {return uint64 (len (_afea ._afd ._gg ))};func (_ced *BufferedWriter )writeByte (_cgg byte ){switch {case _ced ._b ==0:_ced ._eg [_ced ._ec ]=_cgg ;_ced ._ec ++;case _ced ._fe :_ced ._eg [_ced ._ec ]|=_cgg >>_ced ._b ;
_ced ._ec ++;_ced ._eg [_ced ._ec ]=byte (uint16 (_cgg )<<(8-_ced ._b )&0xff);default:_ced ._eg [_ced ._ec ]|=byte (uint16 (_cgg )<<_ced ._b &0xff);_ced ._ec ++;_ced ._eg [_ced ._ec ]=_cgg >>(8-_ced ._b );};};func (_ef *BufferedWriter )ResetBitIndex (){_ef ._b =0};
func (_ga *BufferedWriter )fullOffset ()int {_fde :=_ga ._ec ;if _ga ._b !=0{_fde ++;};return _fde ;};func (_ecae *Reader )Align ()(_ada byte ){_ada =_ecae ._be ;_ecae ._be =0;return _ada };type Writer struct{_ffb []byte ;_cedg uint8 ;_agd int ;_dbae bool ;
};var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};_ StreamReader =&Reader {};);func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_fe :true }};func (_eda *Writer )Write (p []byte )(int ,error ){if len (p )> _eda .byteCapacity (){return 0,_e .EOF ;
};for _ ,_ddb :=range p {if _afdf :=_eda .writeByte (_ddb );_afdf !=nil {return 0,_afdf ;};};return len (p ),nil ;};func (_ba *Reader )read (_fef []byte )(int ,error ){if _ba ._ebdc >=int64 (_ba ._afd ._gf ){return 0,_e .EOF ;};_ba ._gae =-1;_dac :=copy (_fef ,_ba ._afd ._gg [(int64 (_ba ._afd ._df )+_ba ._ebdc ):(_ba ._afd ._df +_ba ._afd ._gf )]);
_ba ._ebdc +=int64 (_dac );return _dac ,nil ;};func (_cdb *Reader )Mark (){_cdb ._acb =_cdb ._ebdc ;_cdb ._cbe =_cdb ._be ;_cdb ._fea =_cdb ._eff ;_cdb ._aec =_cdb ._eca ;};func NewWriter (data []byte )*Writer {return &Writer {_ffb :data }};func (_agb *Writer )ResetBit (){_agb ._cedg =0};
func (_bfc *BufferedWriter )tryGrowByReslice (_fded int )bool {if _gad :=len (_bfc ._eg );_fded <=cap (_bfc ._eg )-_gad {_bfc ._eg =_bfc ._eg [:_gad +_fded ];return true ;};return false ;};type StreamReader interface{_e .Reader ;_e .ByteReader ;_e .Seeker ;
Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_efb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};const (_g =64;_ff =int (^uint (0)>>1););
func (_dfg *Writer )writeByte (_fga byte )error {if _dfg ._agd > len (_dfg ._ffb )-1{return _e .EOF ;};if _dfg ._agd ==len (_dfg ._ffb )-1&&_dfg ._cedg !=0{return _e .EOF ;};if _dfg ._cedg ==0{_dfg ._ffb [_dfg ._agd ]=_fga ;_dfg ._agd ++;return nil ;};
if _dfg ._dbae {_dfg ._ffb [_dfg ._agd ]|=_fga >>_dfg ._cedg ;_dfg ._agd ++;_dfg ._ffb [_dfg ._agd ]=byte (uint16 (_fga )<<(8-_dfg ._cedg )&0xff);}else {_dfg ._ffb [_dfg ._agd ]|=byte (uint16 (_fga )<<_dfg ._cedg &0xff);_dfg ._agd ++;_dfg ._ffb [_dfg ._agd ]=_fga >>(8-_dfg ._cedg );
};return nil ;};func (_cc *Writer )WriteBits (bits uint64 ,number int )(_agc int ,_adaf error ){const _afca ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_eb .Errorf (_afca ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_agcd :=number /8;if _agcd > 0{_faa :=number -_agcd *8;for _gef :=_agcd -1;_gef >=0;_gef --{_ab :=byte ((bits >>uint (_gef *8+_faa ))&0xff);if _adaf =_cc .WriteByte (_ab );_adaf !=nil {return _agc ,_eb .Wrapf (_adaf ,_afca ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_agcd -_gef +1);
};};number -=_agcd *8;if number ==0{return _agcd ,nil ;};};var _gfd int ;for _bfd :=0;_bfd < number ;_bfd ++{if _cc ._dbae {_gfd =int ((bits >>uint (number -1-_bfd ))&0x1);}else {_gfd =int (bits &0x1);bits >>=1;};if _adaf =_cc .WriteBit (_gfd );_adaf !=nil {return _agc ,_eb .Wrapf (_adaf ,_afca ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bfd );
};};return _agcd ,nil ;};