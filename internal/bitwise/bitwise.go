//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_g "encoding/binary";_cc "errors";_e "fmt";_a "github.com/unidoc/unipdf/v4/common";_f "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_d "io";);type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;Data ()[]byte ;
};func (_ee *BufferedWriter )Data ()[]byte {return _ee ._ag };func (_bgd *Reader )AbsolutePosition ()int64 {return _bgd ._bfe +int64 (_bgd ._dba ._fbb )};var _ _d .ByteWriter =&BufferedWriter {};func (_adb *BufferedWriter )byteCapacity ()int {_aa :=len (_adb ._ag )-_adb ._de ;
if _adb ._db !=0{_aa --;};return _aa ;};func (_gbe *BufferedWriter )Reset (){_gbe ._ag =_gbe ._ag [:0];_gbe ._de =0;_gbe ._db =0};func (_fgd *Writer )FinishByte (){if _fgd ._ffd ==0{return ;};_fgd ._ffd =0;_fgd ._ba ++;};func (_ac *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_fb :=int (_ac ._db )+skip ;if _fb >=0&&_fb < 8{_ac ._db =uint8 (_fb );return nil ;};_fb =int (_ac ._db )+_ac ._de *8+skip ;if _fb < 0{return _f .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_deb :=_fb /8;_bb :=_fb %8;_ac ._db =uint8 (_bb );if _ce :=_deb -_ac ._de ;_ce > 0&&len (_ac ._ag )-1< _deb {if _ac ._db !=0{_ce ++;};_ac .expandIfNeeded (_ce );};_ac ._de =_deb ;return nil ;};var (_ _d .Reader =&Reader {};_ _d .ByteReader =&Reader {};
_ _d .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_afd *BufferedWriter )writeFullBytes (_aab []byte )int {_bbd :=copy (_afd ._ag [_afd .fullOffset ():],_aab );_afd ._de +=_bbd ;return _bbd ;};const (_b =64;_ge =int (^uint (0)>>1););type BitWriter interface{WriteBit (_dgd int )error ;
WriteBits (_acf uint64 ,_fd int )(_abgb int ,_gf error );FinishByte ();SkipBits (_dbc int )error ;};func (_fdf *Reader )ReadByte ()(byte ,error ){if _fdf ._eca ==0{return _fdf .readBufferByte ();};return _fdf .readUnalignedByte ();};func (_cda *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _cda ._eca !=0{return _cda .ReadBits (_cda ._eca );
};return 0,nil ;};func (_fdb *Reader )ReadBit ()(_ff int ,_fdd error ){_eeb ,_fdd :=_fdb .readBool ();if _fdd !=nil {return 0,_fdd ;};if _eeb {_ff =1;};return _ff ,nil ;};func (_ea *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_cc .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_ea ._dba ._fbb +offset ;};if length > 0{_dfa :=len (_ea ._dba ._aabc );if relative {_dfa =_ea ._dba ._gfa ;};if offset +length > _dfa {return nil ,_e .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_ea ._dba ._gfa );
};};if length < 0{_fa :=len (_ea ._dba ._aabc );if relative {_fa =_ea ._dba ._gfa ;};length =_fa -offset ;};return &Reader {_dba :readerSource {_aabc :_ea ._dba ._aabc ,_gfa :length ,_fbb :offset }},nil ;};func (_eb *BufferedWriter )tryGrowByReslice (_dee int )bool {if _ece :=len (_eb ._ag );
_dee <=cap (_eb ._ag )-_ece {_eb ._ag =_eb ._ag [:_ece +_dee ];return true ;};return false ;};func (_fbd *Reader )ReadBits (n byte )(_bc uint64 ,_cdaa error ){if n < _fbd ._eca {_dc :=_fbd ._eca -n ;_bc =uint64 (_fbd ._ddg >>_dc );_fbd ._ddg &=1<<_dc -1;
_fbd ._eca =_dc ;return _bc ,nil ;};if n > _fbd ._eca {if _fbd ._eca > 0{_bc =uint64 (_fbd ._ddg );n -=_fbd ._eca ;};for n >=8{_ceg ,_dcb :=_fbd .readBufferByte ();if _dcb !=nil {return 0,_dcb ;};_bc =_bc <<8+uint64 (_ceg );n -=8;};if n > 0{if _fbd ._ddg ,_cdaa =_fbd .readBufferByte ();
_cdaa !=nil {return 0,_cdaa ;};_ccb :=8-n ;_bc =_bc <<n +uint64 (_fbd ._ddg >>_ccb );_fbd ._ddg &=1<<_ccb -1;_fbd ._eca =_ccb ;}else {_fbd ._eca =0;};return _bc ,nil ;};_fbd ._eca =0;return uint64 (_fbd ._ddg ),nil ;};func (_dd *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _f .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_dd ._ag )-1< _dd ._de {_dd .expandIfNeeded (1);};_ef :=_dd ._db ;if _dd ._fc {_ef =7-_dd ._db ;};_dd ._ag [_dd ._de ]|=byte (uint16 (bit <<_ef )&0xff);_dd ._db ++;if _dd ._db ==8{_dd ._de ++;_dd ._db =0;};return nil ;};func (_eec *BufferedWriter )expandIfNeeded (_acbe int ){if !_eec .tryGrowByReslice (_acbe ){_eec .grow (_acbe );
};};var _ BinaryWriter =&BufferedWriter {};func (_fad *Writer )Write (p []byte )(int ,error ){if len (p )> _fad .byteCapacity (){return 0,_d .EOF ;};for _ ,_fgdd :=range p {if _gbea :=_fad .writeByte (_fgdd );_gbea !=nil {return 0,_gbea ;};};return len (p ),nil ;
};func (_bba *Reader )readUnalignedByte ()(_adf byte ,_cece error ){_cde :=_bba ._eca ;_adf =_bba ._ddg <<(8-_cde );_bba ._ddg ,_cece =_bba .readBufferByte ();if _cece !=nil {return 0,_cece ;};_adf |=_bba ._ddg >>_cde ;_bba ._ddg &=1<<_cde -1;return _adf ,nil ;
};func (_beg *Reader )AbsoluteLength ()uint64 {return uint64 (len (_beg ._dba ._aabc ))};func (_ab *BufferedWriter )Len ()int {return _ab .byteCapacity ()};func (_agf *BufferedWriter )FinishByte (){if _agf ._db ==0{return ;};_agf ._db =0;_agf ._de ++;};
func (_fdde *Writer )Data ()[]byte {return _fdde ._dbgc };func (_gc *Reader )BitPosition ()int {return int (_gc ._eca )};func NewWriterMSB (data []byte )*Writer {return &Writer {_dbgc :data ,_faf :true }};func (_cfa *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cfa ._ggc =-1;
_cfa ._eca =0;_cfa ._ddg =0;_cfa ._fca =0;var _gbd int64 ;switch whence {case _d .SeekStart :_gbd =offset ;case _d .SeekCurrent :_gbd =_cfa ._bfe +offset ;case _d .SeekEnd :_gbd =int64 (_cfa ._dba ._gfa )+offset ;default:return 0,_cc .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _gbd < 0{return 0,_cc .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cfa ._bfe =_gbd ;
_cfa ._eca =0;return _gbd ,nil ;};func (_ggb *Reader )ReadUint32 ()(uint32 ,error ){_ca :=make ([]byte ,4);_ ,_dce :=_ggb .Read (_ca );if _dce !=nil {return 0,_dce ;};return _g .BigEndian .Uint32 (_ca ),nil ;};func (_fg *Reader )Reset (){_fg ._bfe =_fg ._eege ;
_fg ._eca =_fg ._agc ;_fg ._ddg =_fg ._efb ;_fg ._fca =_fg ._dge ;};var _ _d .Writer =&BufferedWriter {};type readerSource struct{_aabc []byte ;_fbb int ;_gfa int ;};func (_dca *Reader )read (_caa []byte )(int ,error ){if _dca ._bfe >=int64 (_dca ._dba ._gfa ){return 0,_d .EOF ;
};_dca ._ggc =-1;_eae :=copy (_caa ,_dca ._dba ._aabc [(int64 (_dca ._dba ._fbb )+_dca ._bfe ):(_dca ._dba ._fbb +_dca ._dba ._gfa )]);_dca ._bfe +=int64 (_eae );return _eae ,nil ;};func (_cdd *Writer )WriteByte (c byte )error {return _cdd .writeByte (c )};
func (_cab *Reader )readBool ()(_ffc bool ,_aaf error ){if _cab ._eca ==0{_cab ._ddg ,_aaf =_cab .readBufferByte ();if _aaf !=nil {return false ,_aaf ;};_ffc =(_cab ._ddg &0x80)!=0;_cab ._ddg ,_cab ._eca =_cab ._ddg &0x7f,7;return _ffc ,nil ;};_cab ._eca --;
_ffc =(_cab ._ddg &(1<<_cab ._eca ))!=0;_cab ._ddg &=1<<_cab ._eca -1;return _ffc ,nil ;};func (_af *BufferedWriter )Write (d []byte )(int ,error ){_af .expandIfNeeded (len (d ));if _af ._db ==0{return _af .writeFullBytes (d ),nil ;};return _af .writeShiftedBytes (d ),nil ;
};func (_cb *Reader )Read (p []byte )(_ded int ,_dbca error ){if _cb ._eca ==0{return _cb .read (p );};for ;_ded < len (p );_ded ++{if p [_ded ],_dbca =_cb .readUnalignedByte ();_dbca !=nil {return 0,_dbca ;};};return _ded ,nil ;};func (_ae *BufferedWriter )WriteByte (bt byte )error {if _ae ._de > len (_ae ._ag )-1||(_ae ._de ==len (_ae ._ag )-1&&_ae ._db !=0){_ae .expandIfNeeded (1);
};_ae .writeByte (bt );return nil ;};func NewReader (data []byte )*Reader {return &Reader {_dba :readerSource {_aabc :data ,_gfa :len (data ),_fbb :0}};};func (_bec *Reader )Mark (){_bec ._eege =_bec ._bfe ;_bec ._agc =_bec ._eca ;_bec ._efb =_bec ._ddg ;
_bec ._dge =_bec ._fca ;};func (_acfg *Writer )writeByte (_eecd byte )error {if _acfg ._ba > len (_acfg ._dbgc )-1{return _d .EOF ;};if _acfg ._ba ==len (_acfg ._dbgc )-1&&_acfg ._ffd !=0{return _d .EOF ;};if _acfg ._ffd ==0{_acfg ._dbgc [_acfg ._ba ]=_eecd ;
_acfg ._ba ++;return nil ;};if _acfg ._faf {_acfg ._dbgc [_acfg ._ba ]|=_eecd >>_acfg ._ffd ;_acfg ._ba ++;_acfg ._dbgc [_acfg ._ba ]=byte (uint16 (_eecd )<<(8-_acfg ._ffd )&0xff);}else {_acfg ._dbgc [_acfg ._ba ]|=byte (uint16 (_eecd )<<_acfg ._ffd &0xff);
_acfg ._ba ++;_acfg ._dbgc [_acfg ._ba ]=_eecd >>(8-_acfg ._ffd );};return nil ;};func (_ec *BufferedWriter )ResetBitIndex (){_ec ._db =0};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;
ReadBit ()(int ,error );ReadBits (_efd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_ddgb *Writer )ResetBit (){_ddgb ._ffd =0};func (_cfc *Writer )WriteBits (bits uint64 ,number int )(_bcf int ,_bab error ){const _cfb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_f .Errorf (_cfb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_ed :=number /8;if _ed > 0{_gdd :=number -_ed *8;for _abd :=_ed -1;_abd >=0;_abd --{_eced :=byte ((bits >>uint (_abd *8+_gdd ))&0xff);if _bab =_cfc .WriteByte (_eced );_bab !=nil {return _bcf ,_f .Wrapf (_bab ,_cfb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ed -_abd +1);
};};number -=_ed *8;if number ==0{return _ed ,nil ;};};var _dcd int ;for _cgc :=0;_cgc < number ;_cgc ++{if _cfc ._faf {_dcd =int ((bits >>uint (number -1-_cgc ))&0x1);}else {_dcd =int (bits &0x1);bits >>=1;};if _bab =_cfc .WriteBit (_dcd );_bab !=nil {return _bcf ,_f .Wrapf (_bab ,_cfb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cgc );
};};return _ed ,nil ;};type Reader struct{_dba readerSource ;_ddg byte ;_eca byte ;_bfe int64 ;_fca int ;_ggc int ;_eege int64 ;_agc byte ;_efb byte ;_dge int ;};func (_ccf *Writer )UseMSB ()bool {return _ccf ._faf };func (_bde *Reader )Length ()uint64 {return uint64 (_bde ._dba ._gfa )};
func (_dbb *Reader )RelativePosition ()int64 {return _dbb ._bfe };func NewWriter (data []byte )*Writer {return &Writer {_dbgc :data }};func (_aea *BufferedWriter )fullOffset ()int {_cf :=_aea ._de ;if _aea ._db !=0{_cf ++;};return _cf ;};func (_aba *BufferedWriter )writeShiftedBytes (_fcb []byte )int {for _ ,_abg :=range _fcb {_aba .writeByte (_abg );
};return len (_fcb );};func (_dced *Writer )SkipBits (skip int )error {const _gfe ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_dgde :=int (_dced ._ffd )+skip ;if _dgde >=0&&_dgde < 8{_dced ._ffd =uint8 (_dgde );
return nil ;};_dgde =int (_dced ._ffd )+_dced ._ba *8+skip ;if _dgde < 0{return _f .Errorf (_gfe ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_eg :=_dgde /8;_gec :=_dgde %8;_a .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_a .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dced ._ffd ,_dced ._ba ,int (_dced ._ffd )+(_dced ._ba )*8,len (_dced ._dbgc ),cap (_dced ._dbgc ));
_a .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_dgde ,_gec );_dced ._ffd =uint8 (_gec );if _ggbe :=_eg -_dced ._ba ;
_ggbe > 0&&len (_dced ._dbgc )-1< _eg {_a .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ggbe );return _f .Errorf (_gfe ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_dced ._ba =_eg ;_a .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dced ._ffd ,_dced ._ba );return nil ;};func (_cgb *Reader )ReadBool ()(bool ,error ){return _cgb .readBool ()};
func (_gaf *Writer )writeBit (_eebf uint8 )error {if len (_gaf ._dbgc )-1< _gaf ._ba {return _d .EOF ;};_dbf :=_gaf ._ffd ;if _gaf ._faf {_dbf =7-_gaf ._ffd ;};_gaf ._dbgc [_gaf ._ba ]|=byte (uint16 (_eebf <<_dbf )&0xff);_gaf ._ffd ++;if _gaf ._ffd ==8{_gaf ._ba ++;
_gaf ._ffd =0;};return nil ;};func (_df *BufferedWriter )writeByte (_cg byte ){switch {case _df ._db ==0:_df ._ag [_df ._de ]=_cg ;_df ._de ++;case _df ._fc :_df ._ag [_df ._de ]|=_cg >>_df ._db ;_df ._de ++;_df ._ag [_df ._de ]=byte (uint16 (_cg )<<(8-_df ._db )&0xff);
default:_df ._ag [_df ._de ]|=byte (uint16 (_cg )<<_df ._db &0xff);_df ._de ++;_df ._ag [_df ._de ]=_cg >>(8-_df ._db );};};func (_cae *Writer )byteCapacity ()int {_cgf :=len (_cae ._dbgc )-_cae ._ba ;if _cae ._ffd !=0{_cgf --;};return _cgf ;};func (_ga *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ga .writeBit (uint8 (bit ));
};return _f .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_fc :true }};func (_afg *BufferedWriter )grow (_dg int ){if _afg ._ag ==nil &&_dg < _b {_afg ._ag =make ([]byte ,_dg ,_b );
return ;};_cd :=len (_afg ._ag );if _afg ._db !=0{_cd ++;};_dgb :=cap (_afg ._ag );switch {case _dg <=_dgb /2-_cd :_a .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_afg ._ag ),cap (_afg ._ag ),_dg );
_a .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_dgb ,_cd );copy (_afg ._ag ,_afg ._ag [_afg .fullOffset ():]);
case _dgb > _ge -_dgb -_dg :_a .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_eeg :=make ([]byte ,2*_dgb +_dg );copy (_eeg ,_afg ._ag );_afg ._ag =_eeg ;};_afg ._ag =_afg ._ag [:_cd +_dg ];
};type BufferedWriter struct{_ag []byte ;_db uint8 ;_de int ;_fc bool ;};func (_eef *Reader )Align ()(_cff byte ){_cff =_eef ._eca ;_eef ._eca =0;return _cff };var _ BinaryWriter =&Writer {};func (_acb *BufferedWriter )WriteBits (bits uint64 ,number int )(_ad int ,_be error ){const _gba ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_f .Errorf (_gba ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_gd :=number /8;if _gd > 0{_bg :=number -_gd *8;for _bf :=_gd -1;_bf >=0;_bf --{_fe :=byte ((bits >>uint (_bf *8+_bg ))&0xff);if _be =_acb .WriteByte (_fe );_be !=nil {return _ad ,_f .Wrapf (_be ,_gba ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gd -_bf +1);
};};number -=_gd *8;if number ==0{return _gd ,nil ;};};var _cec int ;for _fec :=0;_fec < number ;_fec ++{if _acb ._fc {_cec =int ((bits >>uint (number -1-_fec ))&0x1);}else {_cec =int (bits &0x1);bits >>=1;};if _be =_acb .WriteBit (_cec );_be !=nil {return _ad ,_f .Wrapf (_be ,_gba ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fec );
};};return _gd ,nil ;};type Writer struct{_dbgc []byte ;_ffd uint8 ;_ba int ;_faf bool ;};func (_fbdd *Reader )readBufferByte ()(byte ,error ){if _fbdd ._bfe >=int64 (_fbdd ._dba ._gfa ){return 0,_d .EOF ;};_fbdd ._ggc =-1;_faa :=_fbdd ._dba ._aabc [int64 (_fbdd ._dba ._fbb )+_fbdd ._bfe ];
_fbdd ._bfe ++;_fbdd ._fca =int (_faa );return _faa ,nil ;};