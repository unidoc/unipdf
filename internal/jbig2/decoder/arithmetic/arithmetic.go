//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_f "fmt";_gb "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_bd "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_g "io";_cf "strings";);func New (r *_b .Reader )(*Decoder ,error ){_ea :=&Decoder {_cb :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};
if _ga :=_ea .init ();_ga !=nil {return nil ,_ga ;};return _ea ,nil ;};func (_ff *DecoderStats )setEntry (_agg int ){_cg :=byte (_agg &0x7f);_ff ._fab [_ff ._cfe ]=_cg };func (_ed *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ed ._e =1;
var _gae uint64 ;for _gae =0;_gae < codeLen ;_gae ++{stats .SetIndex (int32 (_ed ._e ));_ceb ,_gbe :=_ed .DecodeBit (stats );if _gbe !=nil {return 0,_gbe ;};_ed ._e =(_ed ._e <<1)|int64 (_ceb );};_gdg :=_ed ._e -(1<<codeLen );return _gdg ,nil ;};func (_cd *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_bc int ;
_ef =_ce [stats .cx ()][0];_ag =int32 (stats .cx ()););defer func (){_cd ._gc ++}();_cd ._bf -=_ef ;if (_cd ._fg >>16)< uint64 (_ef ){_bc =_cd .lpsExchange (stats ,_ag ,_ef );if _gd :=_cd .renormalize ();_gd !=nil {return 0,_gd ;};}else {_cd ._fg -=uint64 (_ef )<<16;
if (_cd ._bf &0x8000)==0{_bc =_cd .mpsExchange (stats ,_ag );if _ca :=_cd .renormalize ();_ca !=nil {return 0,_ca ;};}else {_bc =int (stats .getMps ());};};return _bc ,nil ;};func (_fca *DecoderStats )cx ()byte {return _fca ._fab [_fca ._cfe ]};func (_gbb *DecoderStats )SetIndex (index int32 ){_gbb ._cfe =index };
func (_eg *Decoder )init ()error {_eg ._d =_eg ._cb .AbsolutePosition ();_gfd ,_gbg :=_eg ._cb .ReadByte ();if _gbg !=nil {_gb .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_gbg );
return _gbg ;};_eg ._gf =_gfd ;_eg ._fg =uint64 (_gfd )<<16;if _gbg =_eg .readByte ();_gbg !=nil {return _gbg ;};_eg ._fg <<=7;_eg ._a -=7;_eg ._bf =0x8000;_eg ._gc ++;return nil ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;
_cb *_b .Reader ;_gf uint8 ;_fg uint64 ;_bf uint32 ;_e int64 ;_a int32 ;_gc int32 ;_d int64 ;};func (_cef *DecoderStats )toggleMps (){_cef ._ddg [_cef ._cfe ]^=1};func (_cc *DecoderStats )Overwrite (dNew *DecoderStats ){for _fce :=0;_fce < len (_cc ._fab );
_fce ++{_cc ._fab [_fce ]=dNew ._fab [_fce ];_cc ._ddg [_fce ]=dNew ._ddg [_fce ];};};type DecoderStats struct{_cfe int32 ;_bfc int32 ;_fab []byte ;_ddg []byte ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_cfe :index ,_bfc :contextSize ,_fab :make ([]byte ,contextSize ),_ddg :make ([]byte ,contextSize )};
};func (_gg *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_eb ,_bg int32 ;_af ,_gde ,_gff int ;_gdb error ;);if stats ==nil {stats =NewStats (512,1);};_gg ._e =1;_gde ,_gdb =_gg .decodeIntBit (stats );if _gdb !=nil {return 0,_gdb ;};_af ,_gdb =_gg .decodeIntBit (stats );
if _gdb !=nil {return 0,_gdb ;};if _af ==1{_af ,_gdb =_gg .decodeIntBit (stats );if _gdb !=nil {return 0,_gdb ;};if _af ==1{_af ,_gdb =_gg .decodeIntBit (stats );if _gdb !=nil {return 0,_gdb ;};if _af ==1{_af ,_gdb =_gg .decodeIntBit (stats );if _gdb !=nil {return 0,_gdb ;
};if _af ==1{_af ,_gdb =_gg .decodeIntBit (stats );if _gdb !=nil {return 0,_gdb ;};if _af ==1{_gff =32;_bg =4436;}else {_gff =12;_bg =340;};}else {_gff =8;_bg =84;};}else {_gff =6;_bg =20;};}else {_gff =4;_bg =4;};}else {_gff =2;_bg =0;};for _ad :=0;_ad < _gff ;
_ad ++{_af ,_gdb =_gg .decodeIntBit (stats );if _gdb !=nil {return 0,_gdb ;};_eb =(_eb <<1)|int32 (_af );};_eb +=_bg ;if _gde ==0{return _eb ,nil ;}else if _gde ==1&&_eb > 0{return -_eb ,nil ;};return 0,_bd .ErrOOB ;};func (_ba *DecoderStats )String ()string {_cdg :=&_cf .Builder {};
_cdg .WriteString (_f .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_ba ._fab )));for _edc ,_bgd :=range _ba ._fab {if _bgd !=0{_cdg .WriteString (_f .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_edc ,_bgd ));
};};return _cdg .String ();};func (_ggb *DecoderStats )getMps ()byte {return _ggb ._ddg [_ggb ._cfe ]};func (_gbc *DecoderStats )Reset (){for _bb :=0;_bb < len (_gbc ._fab );_bb ++{_gbc ._fab [_bb ]=0;_gbc ._ddg [_bb ]=0;};};func (_cde *Decoder )decodeIntBit (_fa *DecoderStats )(int ,error ){_fa .SetIndex (int32 (_cde ._e ));
_dc ,_cea :=_cde .DecodeBit (_fa );if _cea !=nil {_gb .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_cea );
return _dc ,_cea ;};if _cde ._e < 256{_cde ._e =((_cde ._e <<uint64 (1))|int64 (_dc ))&0x1ff;}else {_cde ._e =(((_cde ._e <<uint64 (1)|int64 (_dc ))&511)|256)&0x1ff;};return _dc ,nil ;};func (_cfc *Decoder )renormalize ()error {for {if _cfc ._a ==0{if _abd :=_cfc .readByte ();
_abd !=nil {return _abd ;};};_cfc ._bf <<=1;_cfc ._fg <<=1;_cfc ._a --;if (_cfc ._bf &0x8000)!=0{break ;};};_cfc ._fg &=0xffffffff;return nil ;};func (_ebf *Decoder )readByte ()error {if _ebf ._cb .AbsolutePosition ()> _ebf ._d {if _ ,_ab :=_ebf ._cb .Seek (-1,_g .SeekCurrent );
_ab !=nil {return _ab ;};};_ee ,_gcd :=_ebf ._cb .ReadByte ();if _gcd !=nil {return _gcd ;};_ebf ._gf =_ee ;if _ebf ._gf ==0xFF{_fe ,_efg :=_ebf ._cb .ReadByte ();if _efg !=nil {return _efg ;};if _fe > 0x8F{_ebf ._fg +=0xFF00;_ebf ._a =8;if _ ,_gcdf :=_ebf ._cb .Seek (-2,_g .SeekCurrent );
_gcdf !=nil {return _gcdf ;};}else {_ebf ._fg +=uint64 (_fe )<<9;_ebf ._a =7;};}else {_ee ,_gcd =_ebf ._cb .ReadByte ();if _gcd !=nil {return _gcd ;};_ebf ._gf =_ee ;_ebf ._fg +=uint64 (_ebf ._gf )<<8;_ebf ._a =8;};_ebf ._fg &=0xFFFFFFFFFF;return nil ;
};func (_gac *DecoderStats )Copy ()*DecoderStats {_gdbf :=&DecoderStats {_bfc :_gac ._bfc ,_fab :make ([]byte ,_gac ._bfc )};copy (_gdbf ._fab ,_gac ._fab );return _gdbf ;};func (_agb *Decoder )mpsExchange (_ggc *DecoderStats ,_gbgd int32 )int {_dcg :=_ggc ._ddg [_ggc ._cfe ];
if _agb ._bf < _ce [_gbgd ][0]{if _ce [_gbgd ][3]==1{_ggc .toggleMps ();};_ggc .setEntry (int (_ce [_gbgd ][2]));return int (1-_dcg );};_ggc .setEntry (int (_ce [_gbgd ][1]));return int (_dcg );};var (_ce =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_dg *Decoder )lpsExchange (_dd *DecoderStats ,_ge int32 ,_cac uint32 )int {_bde :=_dd .getMps ();if _dg ._bf < _cac {_dd .setEntry (int (_ce [_ge ][1]));_dg ._bf =_cac ;return int (_bde );};if _ce [_ge ][3]==1{_dd .toggleMps ();};_dd .setEntry (int (_ce [_ge ][2]));
_dg ._bf =_cac ;return int (1-_bde );};