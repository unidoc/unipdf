//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_fg "fmt";_b "github.com/unidoc/unipdf/v4/common";_dd "github.com/unidoc/unipdf/v4/internal/bitwise";_c "github.com/unidoc/unipdf/v4/internal/jbig2/internal";_f "io";_g "strings";);func (_gcf *Decoder )lpsExchange (_def *DecoderStats ,_ag int32 ,_aad uint32 )int {_bgd :=_def .getMps ();
if _gcf ._cc < _aad {_def .setEntry (int (_bd [_ag ][1]));_gcf ._cc =_aad ;return int (_bgd );};if _bd [_ag ][3]==1{_def .toggleMps ();};_def .setEntry (int (_bd [_ag ][2]));_gcf ._cc =_aad ;return int (1-_bgd );};func (_ab *Decoder )decodeIntBit (_ga *DecoderStats )(int ,error ){_ga .SetIndex (int32 (_ab ._eae ));
_eac ,_fdf :=_ab .DecodeBit (_ga );if _fdf !=nil {_b .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_fdf );
return _eac ,_fdf ;};if _ab ._eae < 256{_ab ._eae =((_ab ._eae <<uint64 (1))|int64 (_eac ))&0x1ff;}else {_ab ._eae =(((_ab ._eae <<uint64 (1)|int64 (_eac ))&511)|256)&0x1ff;};return _eac ,nil ;};func (_bga *DecoderStats )String ()string {_gbg :=&_g .Builder {};
_fg .Fprintf (_gbg ,"S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_bga ._ecg ));for _eab ,_agf :=range _bga ._ecg {if _agf !=0{_fg .Fprintf (_gbg ,"N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_eab ,_agf );
};};return _gbg .String ();};func (_eg *DecoderStats )Overwrite (dNew *DecoderStats ){for _ddfd :=0;_ddfd < len (_eg ._ecg );_ddfd ++{_eg ._ecg [_ddfd ]=dNew ._ecg [_ddfd ];_eg ._bfe [_ddfd ]=dNew ._bfe [_ddfd ];};};func (_ac *Decoder )mpsExchange (_ece *DecoderStats ,_df int32 )int {_bf :=_ece ._bfe [_ece ._cb ];
if _ac ._cc < _bd [_df ][0]{if _bd [_df ][3]==1{_ece .toggleMps ();};_ece .setEntry (int (_bd [_df ][2]));return int (1-_bf );};_ece .setEntry (int (_bd [_df ][1]));return int (_bf );};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;
_e *_dd .Reader ;_ea uint8 ;_ec uint64 ;_cc uint32 ;_eae int64 ;_ba int32 ;_cg int32 ;_cce int64 ;};func (_fgf *Decoder )init ()error {_fgf ._cce =_fgf ._e .AbsolutePosition ();_bg ,_ecb :=_fgf ._e .ReadByte ();if _ecb !=nil {_b .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_ecb );
return _ecb ;};_fgf ._ea =_bg ;_fgf ._ec =uint64 (_bg )<<16;if _ecb =_fgf .readByte ();_ecb !=nil {return _ecb ;};_fgf ._ec <<=7;_fgf ._ba -=7;_fgf ._cc =0x8000;_fgf ._cg ++;return nil ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_cb :index ,_ad :contextSize ,_ecg :make ([]byte ,contextSize ),_bfe :make ([]byte ,contextSize )};
};func (_gfc *DecoderStats )Reset (){for _dff :=0;_dff < len (_gfc ._ecg );_dff ++{_gfc ._ecg [_dff ]=0;_gfc ._bfe [_dff ]=0;};};func (_gd *DecoderStats )Copy ()*DecoderStats {_ecgc :=&DecoderStats {_ad :_gd ._ad ,_ecg :make ([]byte ,_gd ._ad )};copy (_ecgc ._ecg ,_gd ._ecg );
return _ecgc ;};type DecoderStats struct{_cb int32 ;_ad int32 ;_ecg []byte ;_bfe []byte ;};func (_bbb *DecoderStats )setEntry (_fec int ){_add :=byte (_fec &0x7f);_bbb ._ecg [_bbb ._cb ]=_add };func (_ddf *Decoder )renormalize ()error {for {if _ddf ._ba ==0{if _fgfg :=_ddf .readByte ();
_fgfg !=nil {return _fgfg ;};};_ddf ._cc <<=1;_ddf ._ec <<=1;_ddf ._ba --;if (_ddf ._cc &0x8000)!=0{break ;};};_ddf ._ec &=0xffffffff;return nil ;};func (_gb *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_gb ._eae =1;var _afc uint64 ;
for _afc =0;_afc < codeLen ;_afc ++{stats .SetIndex (int32 (_gb ._eae ));_cfd ,_ecf :=_gb .DecodeBit (stats );if _ecf !=nil {return 0,_ecf ;};_gb ._eae =(_gb ._eae <<1)|int64 (_cfd );};_aa :=_gb ._eae -(1<<codeLen );return _aa ,nil ;};func (_gdd *DecoderStats )cx ()byte {return _gdd ._ecg [_gdd ._cb ]};
func (_a *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_af int ;_ed =_bd [stats .cx ()][0];_bce =int32 (stats .cx ()););defer func (){_a ._cg ++}();_a ._cc -=_ed ;if (_a ._ec >>16)< uint64 (_ed ){_af =_a .lpsExchange (stats ,_bce ,_ed );
if _dg :=_a .renormalize ();_dg !=nil {return 0,_dg ;};}else {_a ._ec -=uint64 (_ed )<<16;if (_a ._cc &0x8000)==0{_af =_a .mpsExchange (stats ,_bce );if _ff :=_a .renormalize ();_ff !=nil {return 0,_ff ;};}else {_af =int (stats .getMps ());};};return _af ,nil ;
};func (_cf *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_da ,_eb int32 ;_cfg ,_dag ,_gc int ;_bb error ;);if stats ==nil {stats =NewStats (512,1);};_cf ._eae =1;_dag ,_bb =_cf .decodeIntBit (stats );if _bb !=nil {return 0,_bb ;};_cfg ,_bb =_cf .decodeIntBit (stats );
if _bb !=nil {return 0,_bb ;};if _cfg ==1{_cfg ,_bb =_cf .decodeIntBit (stats );if _bb !=nil {return 0,_bb ;};if _cfg ==1{_cfg ,_bb =_cf .decodeIntBit (stats );if _bb !=nil {return 0,_bb ;};if _cfg ==1{_cfg ,_bb =_cf .decodeIntBit (stats );if _bb !=nil {return 0,_bb ;
};if _cfg ==1{_cfg ,_bb =_cf .decodeIntBit (stats );if _bb !=nil {return 0,_bb ;};if _cfg ==1{_gc =32;_eb =4436;}else {_gc =12;_eb =340;};}else {_gc =8;_eb =84;};}else {_gc =6;_eb =20;};}else {_gc =4;_eb =4;};}else {_gc =2;_eb =0;};for _fd :=0;_fd < _gc ;
_fd ++{_cfg ,_bb =_cf .decodeIntBit (stats );if _bb !=nil {return 0,_bb ;};_da =(_da <<1)|int32 (_cfg );};_da +=_eb ;if _dag ==0{return _da ,nil ;}else if _dag ==1&&_da > 0{return -_da ,nil ;};return 0,_c .ErrOOB ;};func (_fa *DecoderStats )toggleMps (){_fa ._bfe [_fa ._cb ]^=1};
func New (r *_dd .Reader )(*Decoder ,error ){_dc :=&Decoder {_e :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _bc :=_dc .init ();_bc !=nil {return nil ,_bc ;};return _dc ,nil ;};func (_edb *Decoder )readByte ()error {if _edb ._e .AbsolutePosition ()> _edb ._cce {if _ ,_bdc :=_edb ._e .Seek (-1,_f .SeekCurrent );
_bdc !=nil {return _bdc ;};};_gg ,_gf :=_edb ._e .ReadByte ();if _gf !=nil {return _gf ;};_edb ._ea =_gg ;if _edb ._ea ==0xFF{_ce ,_de :=_edb ._e .ReadByte ();if _de !=nil {return _de ;};if _ce > 0x8F{_edb ._ec +=0xFF00;_edb ._ba =8;if _ ,_fe :=_edb ._e .Seek (-2,_f .SeekCurrent );
_fe !=nil {return _fe ;};}else {_edb ._ec +=uint64 (_ce )<<9;_edb ._ba =7;};}else {_gg ,_gf =_edb ._e .ReadByte ();if _gf !=nil {return _gf ;};_edb ._ea =_gg ;_edb ._ec +=uint64 (_edb ._ea )<<8;_edb ._ba =8;};_edb ._ec &=0xFFFFFFFFFF;return nil ;};func (_gfe *DecoderStats )SetIndex (index int32 ){_gfe ._cb =index };
func (_eabc *DecoderStats )getMps ()byte {return _eabc ._bfe [_eabc ._cb ]};var (_bd =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);