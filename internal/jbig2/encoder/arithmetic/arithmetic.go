//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_c "github.com/unidoc/unipdf/v4/common";_g "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_de "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_e "io";);func (_gc *Encoder )Flush (){_gc ._cdde =0;_gc ._gg =nil ;
_gc ._bd =-1};func (_fbf *codingContext )flipMps (_ca uint32 ){_fbf ._ga [_ca ]=1-_fbf ._ga [_ca ]};func (_cgd *Encoder )Reset (){_cgd ._fge =0x8000;_cgd ._afb =0;_cgd ._dfd =12;_cgd ._bd =-1;_cgd ._dd =0;_cgd ._gb =nil ;_cgd ._gaf =_cdd (_eaga );};func (_cd Class )String ()string {switch _cd {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_bfc *Encoder )code1 (_ggf *codingContext ,_egd uint32 ,_gef uint16 ,_cfg byte ){if _ggf .mps (_egd )==1{_bfc .codeMPS (_ggf ,_egd ,_gef ,_cfg );}else {_bfc .codeLPS (_ggf ,_egd ,_gef ,_cfg );
};};func (_fdc *Encoder )rBlock (){if _fdc ._bd >=0{_fdc .emit ();};_fdc ._bd ++;_fdc ._dd =uint8 (_fdc ._afb >>20);_fdc ._afb &=0xfffff;_fdc ._dfd =7;};func (_eag *Encoder )byteOut (){if _eag ._dd ==0xff{_eag .rBlock ();return ;};if _eag ._afb < 0x8000000{_eag .lBlock ();
return ;};_eag ._dd ++;if _eag ._dd !=0xff{_eag .lBlock ();return ;};_eag ._afb &=0x7ffffff;_eag .rBlock ();};func (_dcda *Encoder )EncodeInteger (proc Class ,value int )(_ggb error ){_c .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ggb =_dcda .encodeInteger (proc ,value );_ggb !=nil {return _de .Wrap (_ggb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_gge *Encoder )encodeIAID (_cbdg ,_dda int )error {if _gge ._gb ==nil {_gge ._gb =_cdd (1<<uint (_cbdg ));
};_bbce :=uint32 (1<<uint32 (_cbdg +1))-1;_dda <<=uint (32-_cbdg );_ddc :=uint32 (1);for _gbdd :=0;_gbdd < _cbdg ;_gbdd ++{_fgd :=_ddc &_bbce ;_gfd :=uint8 ((uint32 (_dda )&0x80000000)>>31);if _cad :=_gge .encodeBit (_gge ._gb ,_fgd ,_gfd );_cad !=nil {return _cad ;
};_ddc =(_ddc <<1)|uint32 (_gfd );_dda <<=1;};return nil ;};func (_aaf *Encoder )code0 (_aeb *codingContext ,_cbg uint32 ,_ff uint16 ,_ddef byte ){if _aeb .mps (_cbg )==0{_aaf .codeMPS (_aeb ,_cbg ,_ff ,_ddef );}else {_aaf .codeLPS (_aeb ,_cbg ,_ff ,_ddef );
};};func (_bbc *Encoder )encodeInteger (_agf Class ,_cbc int )error {const _aafb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _cbc > 2000000000||_cbc < -2000000000{return _de .Errorf (_aafb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cbc );
};_cce :=_bbc ._fcd [_agf ];_fgfb :=uint32 (1);var _bba int ;for ;;_bba ++{if _fb [_bba ]._eb <=_cbc &&_fb [_bba ]._ac >=_cbc {break ;};};if _cbc < 0{_cbc =-_cbc ;};_cbc -=int (_fb [_bba ]._f );_abg :=_fb [_bba ]._b ;for _bdc :=uint8 (0);_bdc < _fb [_bba ]._ee ;
_bdc ++{_afbd :=_abg &1;if _aac :=_bbc .encodeBit (_cce ,_fgfb ,_afbd );_aac !=nil {return _de .Wrap (_aac ,_aafb ,"");};_abg >>=1;if _fgfb &0x100> 0{_fgfb =(((_fgfb <<1)|uint32 (_afbd ))&0x1ff)|0x100;}else {_fgfb =(_fgfb <<1)|uint32 (_afbd );};};_cbc <<=32-_fb [_bba ]._db ;
for _gbb :=uint8 (0);_gbb < _fb [_bba ]._db ;_gbb ++{_afg :=uint8 ((uint32 (_cbc )&0x80000000)>>31);if _dgb :=_bbc .encodeBit (_cce ,_fgfb ,_afg );_dgb !=nil {return _de .Wrap (_dgb ,_aafb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cbc <<=1;if _fgfb &0x100!=0{_fgfb =(((_fgfb <<1)|uint32 (_afg ))&0x1ff)|0x100;}else {_fgfb =(_fgfb <<1)|uint32 (_afg );};};return nil ;};func _cdd (_ag int )*codingContext {return &codingContext {_df :make ([]byte ,_ag ),_ga :make ([]byte ,_ag )};};
type codingContext struct{_df []byte ;_ga []byte ;};func (_edd *Encoder )codeMPS (_ec *codingContext ,_aada uint32 ,_ece uint16 ,_ba byte ){_edd ._fge -=_ece ;if _edd ._fge &0x8000!=0{_edd ._afb +=uint32 (_ece );return ;};if _edd ._fge < _ece {_edd ._fge =_ece ;
}else {_edd ._afb +=uint32 (_ece );};_ec ._df [_aada ]=_gee [_ba ]._afd ;_edd .renormalize ();};func (_gf *Encoder )emit (){if _gf ._cdde ==_cceb {_gf ._gg =append (_gf ._gg ,_gf ._fc );_gf ._fc =make ([]byte ,_cceb );_gf ._cdde =0;};_gf ._fc [_gf ._cdde ]=_gf ._dd ;
_gf ._cdde ++;};func (_gdc *Encoder )encodeOOB (_bgf Class )error {_gdf :=_gdc ._fcd [_bgf ];_ddg :=_gdc .encodeBit (_gdf ,1,1);if _ddg !=nil {return _ddg ;};_ddg =_gdc .encodeBit (_gdf ,3,0);if _ddg !=nil {return _ddg ;};_ddg =_gdc .encodeBit (_gdf ,6,0);
if _ddg !=nil {return _ddg ;};_ddg =_gdc .encodeBit (_gdf ,12,0);if _ddg !=nil {return _ddg ;};return nil ;};func (_cab *Encoder )dataSize ()int {return _cceb *len (_cab ._gg )+_cab ._cdde };type Class int ;func (_dfda *Encoder )setBits (){_bee :=_dfda ._afb +uint32 (_dfda ._fge );
_dfda ._afb |=0xffff;if _dfda ._afb >=_bee {_dfda ._afb -=0x8000;};};var _ _e .WriterTo =&Encoder {};func (_da *Encoder )EncodeBitmap (bm *_g .Bitmap ,duplicateLineRemoval bool )error {_c .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_fd ,_dc uint8 ;_cg ,_bg ,_be uint16 ;_eg ,_caf ,_ge byte ;_dcd ,_cdf ,_cf int ;_ae ,_cdfc []byte ;);for _ab :=0;_ab < bm .Height ;_ab ++{_eg ,_caf =0,0;if _ab >=2{_eg =bm .Data [(_ab -2)*bm .RowStride ];};if _ab >=1{_caf =bm .Data [(_ab -1)*bm .RowStride ];
if duplicateLineRemoval {_cdf =_ab *bm .RowStride ;_ae =bm .Data [_cdf :_cdf +bm .RowStride ];_cf =(_ab -1)*bm .RowStride ;_cdfc =bm .Data [_cf :_cf +bm .RowStride ];if _a .Equal (_ae ,_cdfc ){_dc =_fd ^1;_fd =1;}else {_dc =_fd ;_fd =0;};};};if duplicateLineRemoval {if _cge :=_da .encodeBit (_da ._gaf ,_def ,_dc );
_cge !=nil {return _cge ;};if _fd !=0{continue ;};};_ge =bm .Data [_ab *bm .RowStride ];_cg =uint16 (_eg >>5);_bg =uint16 (_caf >>4);_eg <<=3;_caf <<=4;_be =0;for _dcd =0;_dcd < bm .Width ;_dcd ++{_cc :=uint32 (_cg <<11|_bg <<4|_be );_bdd :=(_ge &0x80)>>7;
_bb :=_da .encodeBit (_da ._gaf ,_cc ,_bdd );if _bb !=nil {return _bb ;};_cg <<=1;_bg <<=1;_be <<=1;_cg |=uint16 ((_eg &0x80)>>7);_bg |=uint16 ((_caf &0x80)>>7);_be |=uint16 (_bdd );_adc :=_dcd %8;_aef :=_dcd /8+1;if _adc ==4&&_ab >=2{_eg =0;if _aef < bm .RowStride {_eg =bm .Data [(_ab -2)*bm .RowStride +_aef ];
};}else {_eg <<=1;};if _adc ==3&&_ab >=1{_caf =0;if _aef < bm .RowStride {_caf =bm .Data [(_ab -1)*bm .RowStride +_aef ];};}else {_caf <<=1;};if _adc ==7{_ge =0;if _aef < bm .RowStride {_ge =bm .Data [_ab *bm .RowStride +_aef ];};}else {_ge <<=1;};_cg &=31;
_bg &=127;_be &=15;};};return nil ;};const (_eaga =65536;_cceb =20*1024;);func (_age *Encoder )encodeBit (_gff *codingContext ,_aca uint32 ,_fbd uint8 )error {const _eff ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_age ._ea ++;if _aca >=uint32 (len (_gff ._df )){return _de .Errorf (_eff ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_aca );
};_aab :=_gff ._df [_aca ];_gde :=_gff .mps (_aca );_fde :=_gee [_aab ]._fcc ;_c .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_age ._ea ,_fbd ,_aab ,_gde ,_fde ,_age ._fge ,_age ._afb ,_age ._dfd ,_age ._dd ,_age ._bd );
if _fbd ==0{_age .code0 (_gff ,_aca ,_fde ,_aab );}else {_age .code1 (_gff ,_aca ,_fde ,_aab );};return nil ;};func (_gbd *Encoder )Init (){_gbd ._gaf =_cdd (_eaga );_gbd ._fge =0x8000;_gbd ._afb =0;_gbd ._dfd =12;_gbd ._bd =-1;_gbd ._dd =0;_gbd ._cdde =0;
_gbd ._fc =make ([]byte ,_cceb );for _ad :=0;_ad < len (_gbd ._fcd );_ad ++{_gbd ._fcd [_ad ]=_cdd (512);};_gbd ._gb =nil ;};var _gee =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_aa *Encoder )Final (){_aa .flush ()};func (_af *codingContext )mps (_fg uint32 )int {return int (_af ._ga [_fg ])};func (_ggg *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ccg error ){_c .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ccg =_ggg .encodeIAID (symbolCodeLength ,value );_ccg !=nil {return _de .Wrap (_ccg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func New ()*Encoder {_bf :=&Encoder {};_bf .Init ();return _bf };func (_cba *Encoder )codeLPS (_geg *codingContext ,_cdc uint32 ,_eac uint16 ,_dcc byte ){_cba ._fge -=_eac ;
if _cba ._fge < _eac {_cba ._afb +=uint32 (_eac );}else {_cba ._fge =_eac ;};if _gee [_dcc ]._dfe ==1{_geg .flipMps (_cdc );};_geg ._df [_cdc ]=_gee [_dcc ]._dac ;_cba .renormalize ();};func (_fbb *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _bec ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _gcc int64 ;for _cag ,_cb :=range _fbb ._gg {_cbd ,_aae :=w .Write (_cb );if _aae !=nil {return 0,_de .Wrapf (_aae ,_bec ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cag );
};_gcc +=int64 (_cbd );};_fbb ._fc =_fbb ._fc [:_fbb ._cdde ];_gbc ,_cda :=w .Write (_fbb ._fc );if _cda !=nil {return 0,_de .Wrap (_cda ,_bec ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_gcc +=int64 (_gbc );return _gcc ,nil ;
};type intEncRangeS struct{_eb ,_ac int ;_b ,_ee uint8 ;_f uint16 ;_db uint8 ;};const _def =0x9b25;type state struct{_fcc uint16 ;_afd ,_dac uint8 ;_dfe uint8 ;};func (_fdb *Encoder )renormalize (){for {_fdb ._fge <<=1;_fdb ._afb <<=1;_fdb ._dfd --;if _fdb ._dfd ==0{_fdb .byteOut ();
};if (_fdb ._fge &0x8000)!=0{break ;};};};func (_ef *Encoder )DataSize ()int {return _ef .dataSize ()};func (_ege *Encoder )flush (){_ege .setBits ();_ege ._afb <<=_ege ._dfd ;_ege .byteOut ();_ege ._afb <<=_ege ._dfd ;_ege .byteOut ();_ege .emit ();if _ege ._dd !=0xff{_ege ._bd ++;
_ege ._dd =0xff;_ege .emit ();};_ege ._bd ++;_ege ._dd =0xac;_ege ._bd ++;_ege .emit ();};func (_ce *Encoder )Refine (iTemp ,iTarget *_g .Bitmap ,ox ,oy int )error {for _eaf :=0;_eaf < iTarget .Height ;_eaf ++{var _ade int ;_fgf :=_eaf +oy ;var (_cga ,_gd ,_cac ,_acd ,_fbc uint16 ;
_ggd ,_fe ,_aad ,_aea ,_gaa byte ;);if _fgf >=1&&(_fgf -1)< iTemp .Height {_ggd =iTemp .Data [(_fgf -1)*iTemp .RowStride ];};if _fgf >=0&&_fgf < iTemp .Height {_fe =iTemp .Data [_fgf *iTemp .RowStride ];};if _fgf >=-1&&_fgf +1< iTemp .Height {_aad =iTemp .Data [(_fgf +1)*iTemp .RowStride ];
};if _eaf >=1{_aea =iTarget .Data [(_eaf -1)*iTarget .RowStride ];};_gaa =iTarget .Data [_eaf *iTarget .RowStride ];_dde :=uint (6+ox );_cga =uint16 (_ggd >>_dde );_gd =uint16 (_fe >>_dde );_cac =uint16 (_aad >>_dde );_acd =uint16 (_aea >>6);_defg :=uint (2-ox );
_ggd <<=_defg ;_fe <<=_defg ;_aad <<=_defg ;_aea <<=2;for _ade =0;_ade < iTarget .Width ;_ade ++{_dg :=(_cga <<10)|(_gd <<7)|(_cac <<4)|(_acd <<1)|_fbc ;_eee :=_gaa >>7;_ceg :=_ce .encodeBit (_ce ._gaf ,uint32 (_dg ),_eee );if _ceg !=nil {return _ceg ;
};_cga <<=1;_gd <<=1;_cac <<=1;_acd <<=1;_cga |=uint16 (_ggd >>7);_gd |=uint16 (_fe >>7);_cac |=uint16 (_aad >>7);_acd |=uint16 (_aea >>7);_fbc =uint16 (_eee );_cfa :=_ade %8;_cfe :=_ade /8+1;if _cfa ==5+ox {_ggd ,_fe ,_aad =0,0,0;if _cfe < iTemp .RowStride &&_fgf >=1&&(_fgf -1)< iTemp .Height {_ggd =iTemp .Data [(_fgf -1)*iTemp .RowStride +_cfe ];
};if _cfe < iTemp .RowStride &&_fgf >=0&&_fgf < iTemp .Height {_fe =iTemp .Data [_fgf *iTemp .RowStride +_cfe ];};if _cfe < iTemp .RowStride &&_fgf >=-1&&(_fgf +1)< iTemp .Height {_aad =iTemp .Data [(_fgf +1)*iTemp .RowStride +_cfe ];};}else {_ggd <<=1;
_fe <<=1;_aad <<=1;};if _cfa ==5&&_eaf >=1{_aea =0;if _cfe < iTarget .RowStride {_aea =iTarget .Data [(_eaf -1)*iTarget .RowStride +_cfe ];};}else {_aea <<=1;};if _cfa ==7{_gaa =0;if _cfe < iTarget .RowStride {_gaa =iTarget .Data [_eaf *iTarget .RowStride +_cfe ];
};}else {_gaa <<=1;};_cga &=7;_gd &=7;_cac &=7;_acd &=7;};};return nil ;};type Encoder struct{_afb uint32 ;_fge uint16 ;_dfd ,_dd uint8 ;_bd int ;_ea int ;_gg [][]byte ;_fc []byte ;_cdde int ;_gaf *codingContext ;_fcd [13]*codingContext ;_gb *codingContext ;
};func (_fee *Encoder )lBlock (){if _fee ._bd >=0{_fee .emit ();};_fee ._bd ++;_fee ._dd =uint8 (_fee ._afb >>19);_fee ._afb &=0x7ffff;_fee ._dfd =8;};func (_bgc *Encoder )EncodeOOB (proc Class )(_dce error ){_c .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _dce =_bgc .encodeOOB (proc );_dce !=nil {return _de .Wrap (_dce ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};var _fb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);