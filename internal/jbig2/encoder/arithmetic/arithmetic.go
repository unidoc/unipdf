//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_ac "github.com/unidoc/unipdf/v4/common";_d "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_f "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_a "io";);func (_eef *Encoder )codeMPS (_fc *codingContext ,_agc uint32 ,_abc uint16 ,_cecb byte ){_eef ._fd -=_abc ;
if _eef ._fd &0x8000!=0{_eef ._ea +=uint32 (_abc );return ;};if _eef ._fd < _abc {_eef ._fd =_abc ;}else {_eef ._ea +=uint32 (_abc );};_fc ._fb [_agc ]=_ebd [_cecb ]._gdf ;_eef .renormalize ();};func (_gbd *Encoder )flush (){_gbd .setBits ();_gbd ._ea <<=_gbd ._gec ;
_gbd .byteOut ();_gbd ._ea <<=_gbd ._gec ;_gbd .byteOut ();_gbd .emit ();if _gbd ._fbf !=0xff{_gbd ._efd ++;_gbd ._fbf =0xff;_gbd .emit ();};_gbd ._efd ++;_gbd ._fbf =0xac;_gbd ._efd ++;_gbd .emit ();};func (_fba *Encoder )Reset (){_fba ._fd =0x8000;_fba ._ea =0;
_fba ._gec =12;_fba ._efd =-1;_fba ._fbf =0;_fba ._ad =nil ;_fba ._ba =_geb (_fca );};func (_bg *Encoder )EncodeInteger (proc Class ,value int )(_dg error ){_ac .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _dg =_bg .encodeInteger (proc ,value );_dg !=nil {return _f .Wrap (_dg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type codingContext struct{_fb []byte ;_da []byte ;};func (_fffe *Encoder )code1 (_gd *codingContext ,_bda uint32 ,_ccc uint16 ,_cae byte ){if _gd .mps (_bda )==1{_fffe .codeMPS (_gd ,_bda ,_ccc ,_cae );
}else {_fffe .codeLPS (_gd ,_bda ,_ccc ,_cae );};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ccg *Encoder )EncodeOOB (proc Class )(_beb error ){_ac .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _beb =_ccg .encodeOOB (proc );_beb !=nil {return _f .Wrap (_beb ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func New ()*Encoder {_ff :=&Encoder {};_ff .Init ();return _ff };func (_gg *Encoder )DataSize ()int {return _gg .dataSize ()};
func (_eb *Encoder )Refine (iTemp ,iTarget *_d .Bitmap ,ox ,oy int )error {for _ffc :=0;_ffc < iTarget .Height ;_ffc ++{var _acb int ;_aga :=_ffc +oy ;var (_fec ,_ab ,_ed ,_ee ,_agf uint16 ;_cda ,_gca ,_ecb ,_fbe ,_cdf byte ;);if _aga >=1&&(_aga -1)< iTemp .Height {_cda =iTemp .Data [(_aga -1)*iTemp .RowStride ];
};if _aga >=0&&_aga < iTemp .Height {_gca =iTemp .Data [_aga *iTemp .RowStride ];};if _aga >=-1&&_aga +1< iTemp .Height {_ecb =iTemp .Data [(_aga +1)*iTemp .RowStride ];};if _ffc >=1{_fbe =iTarget .Data [(_ffc -1)*iTarget .RowStride ];};_cdf =iTarget .Data [_ffc *iTarget .RowStride ];
_ecf :=uint (6+ox );_fec =uint16 (_cda >>_ecf );_ab =uint16 (_gca >>_ecf );_ed =uint16 (_ecb >>_ecf );_ee =uint16 (_fbe >>6);_cee :=uint (2-ox );_cda <<=_cee ;_gca <<=_cee ;_ecb <<=_cee ;_fbe <<=2;for _acb =0;_acb < iTarget .Width ;_acb ++{_dc :=(_fec <<10)|(_ab <<7)|(_ed <<4)|(_ee <<1)|_agf ;
_ffde :=_cdf >>7;_bdc :=_eb .encodeBit (_eb ._ba ,uint32 (_dc ),_ffde );if _bdc !=nil {return _bdc ;};_fec <<=1;_ab <<=1;_ed <<=1;_ee <<=1;_fec |=uint16 (_cda >>7);_ab |=uint16 (_gca >>7);_ed |=uint16 (_ecb >>7);_ee |=uint16 (_fbe >>7);_agf =uint16 (_ffde );
_cgb :=_acb %8;_gcc :=_acb /8+1;if _cgb ==5+ox {_cda ,_gca ,_ecb =0,0,0;if _gcc < iTemp .RowStride &&_aga >=1&&(_aga -1)< iTemp .Height {_cda =iTemp .Data [(_aga -1)*iTemp .RowStride +_gcc ];};if _gcc < iTemp .RowStride &&_aga >=0&&_aga < iTemp .Height {_gca =iTemp .Data [_aga *iTemp .RowStride +_gcc ];
};if _gcc < iTemp .RowStride &&_aga >=-1&&(_aga +1)< iTemp .Height {_ecb =iTemp .Data [(_aga +1)*iTemp .RowStride +_gcc ];};}else {_cda <<=1;_gca <<=1;_ecb <<=1;};if _cgb ==5&&_ffc >=1{_fbe =0;if _gcc < iTarget .RowStride {_fbe =iTarget .Data [(_ffc -1)*iTarget .RowStride +_gcc ];
};}else {_fbe <<=1;};if _cgb ==7{_cdf =0;if _gcc < iTarget .RowStride {_cdf =iTarget .Data [_ffc *iTarget .RowStride +_gcc ];};}else {_cdf <<=1;};_fec &=7;_ab &=7;_ed &=7;_ee &=7;};};return nil ;};func (_cc *Encoder )EncodeBitmap (bm *_d .Bitmap ,duplicateLineRemoval bool )error {_ac .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cba ,_fff uint8 ;_cde ,_cbc ,_cbf uint16 ;_afc ,_cef ,_aed byte ;_bd ,_ffe ,_ga int ;_fa ,_be []byte ;);for _eabd :=0;_eabd < bm .Height ;_eabd ++{_afc ,_cef =0,0;if _eabd >=2{_afc =bm .Data [(_eabd -2)*bm .RowStride ];};if _eabd >=1{_cef =bm .Data [(_eabd -1)*bm .RowStride ];
if duplicateLineRemoval {_ffe =_eabd *bm .RowStride ;_fa =bm .Data [_ffe :_ffe +bm .RowStride ];_ga =(_eabd -1)*bm .RowStride ;_be =bm .Data [_ga :_ga +bm .RowStride ];if _g .Equal (_fa ,_be ){_fff =_cba ^1;_cba =1;}else {_fff =_cba ;_cba =0;};};};if duplicateLineRemoval {if _ffd :=_cc .encodeBit (_cc ._ba ,_af ,_fff );
_ffd !=nil {return _ffd ;};if _cba !=0{continue ;};};_aed =bm .Data [_eabd *bm .RowStride ];_cde =uint16 (_afc >>5);_cbc =uint16 (_cef >>4);_afc <<=3;_cef <<=4;_cbf =0;for _bd =0;_bd < bm .Width ;_bd ++{_gc :=uint32 (_cde <<11|_cbc <<4|_cbf );_ec :=(_aed &0x80)>>7;
_cfe :=_cc .encodeBit (_cc ._ba ,_gc ,_ec );if _cfe !=nil {return _cfe ;};_cde <<=1;_cbc <<=1;_cbf <<=1;_cde |=uint16 ((_afc &0x80)>>7);_cbc |=uint16 ((_cef &0x80)>>7);_cbf |=uint16 (_ec );_ece :=_bd %8;_bfc :=_bd /8+1;if _ece ==4&&_eabd >=2{_afc =0;if _bfc < bm .RowStride {_afc =bm .Data [(_eabd -2)*bm .RowStride +_bfc ];
};}else {_afc <<=1;};if _ece ==3&&_eabd >=1{_cef =0;if _bfc < bm .RowStride {_cef =bm .Data [(_eabd -1)*bm .RowStride +_bfc ];};}else {_cef <<=1;};if _ece ==7{_aed =0;if _bfc < bm .RowStride {_aed =bm .Data [_eabd *bm .RowStride +_bfc ];};}else {_aed <<=1;
};_cde &=31;_cbc &=127;_cbf &=15;};};return nil ;};var _ebd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_eca *Encoder )renormalize (){for {_eca ._fd <<=1;_eca ._ea <<=1;_eca ._gec --;if _eca ._gec ==0{_eca .byteOut ();};if (_eca ._fd &0x8000)!=0{break ;};};};func (_gga *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _bc ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _faf int64 ;for _ecbf ,_cbe :=range _gga ._cec {_ggb ,_edb :=w .Write (_cbe );if _edb !=nil {return 0,_f .Wrapf (_edb ,_bc ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ecbf );
};_faf +=int64 (_ggb );};_gga ._ae =_gga ._ae [:_gga ._eab ];_ffa ,_eg :=w .Write (_gga ._ae );if _eg !=nil {return 0,_f .Wrap (_eg ,_bc ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_faf +=int64 (_ffa );return _faf ,nil ;
};func (_ca *Encoder )Init (){_ca ._ba =_geb (_fca );_ca ._fd =0x8000;_ca ._ea =0;_ca ._gec =12;_ca ._efd =-1;_ca ._fbf =0;_ca ._eab =0;_ca ._ae =make ([]byte ,_fedc );for _fdb :=0;_fdb < len (_ca ._cf );_fdb ++{_ca ._cf [_fdb ]=_geb (512);};_ca ._ad =nil ;
};func (_de *Encoder )codeLPS (_baf *codingContext ,_db uint32 ,_beg uint16 ,_age byte ){_de ._fd -=_beg ;if _de ._fd < _beg {_de ._ea +=uint32 (_beg );}else {_de ._fd =_beg ;};if _ebd [_age ]._gcce ==1{_baf .flipMps (_db );};_baf ._fb [_db ]=_ebd [_age ]._abb ;
_de .renormalize ();};type state struct{_fgbe uint16 ;_gdf ,_abb uint8 ;_gcce uint8 ;};func (_afa *Encoder )lBlock (){if _afa ._efd >=0{_afa .emit ();};_afa ._efd ++;_afa ._fbf =uint8 (_afa ._ea >>19);_afa ._ea &=0x7ffff;_afa ._gec =8;};func (_eag *Encoder )encodeOOB (_gaef Class )error {_fbfc :=_eag ._cf [_gaef ];
_ecec :=_eag .encodeBit (_fbfc ,1,1);if _ecec !=nil {return _ecec ;};_ecec =_eag .encodeBit (_fbfc ,3,0);if _ecec !=nil {return _ecec ;};_ecec =_eag .encodeBit (_fbfc ,6,0);if _ecec !=nil {return _ecec ;};_ecec =_eag .encodeBit (_fbfc ,12,0);if _ecec !=nil {return _ecec ;
};return nil ;};func (_aag *Encoder )setBits (){_eaa :=_aag ._ea +uint32 (_aag ._fd );_aag ._ea |=0xffff;if _aag ._ea >=_eaa {_aag ._ea -=0x8000;};};func (_dad *Encoder )encodeIAID (_dcca ,_gee int )error {if _dad ._ad ==nil {_dad ._ad =_geb (1<<uint (_dcca ));
};_bag :=uint32 (1<<uint32 (_dcca +1))-1;_gee <<=uint (32-_dcca );_aede :=uint32 (1);for _dcce :=0;_dcce < _dcca ;_dcce ++{_ded :=_aede &_bag ;_fef :=uint8 ((uint32 (_gee )&0x80000000)>>31);if _bce :=_dad .encodeBit (_dad ._ad ,_ded ,_fef );_bce !=nil {return _bce ;
};_aede =(_aede <<1)|uint32 (_fef );_gee <<=1;};return nil ;};func (_gb *Encoder )emit (){if _gb ._eab ==_fedc {_gb ._cec =append (_gb ._cec ,_gb ._ae );_gb ._ae =make ([]byte ,_fedc );_gb ._eab =0;};_gb ._ae [_gb ._eab ]=_gb ._fbf ;_gb ._eab ++;};type Class int ;
func (_fgb *Encoder )encodeInteger (_fed Class ,_cbg int )error {const _adg ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _cbg > 2000000000||_cbg < -2000000000{return _f .Errorf (_adg ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cbg );
};_dcd :=_fgb ._cf [_fed ];_ggf :=uint32 (1);var _fae int ;for ;;_fae ++{if _e [_fae ]._dd <=_cbg &&_e [_fae ]._cg >=_cbg {break ;};};if _cbg < 0{_cbg =-_cbg ;};_cbg -=int (_e [_fae ]._ag );_gae :=_e [_fae ]._cb ;for _ffff :=uint8 (0);_ffff < _e [_fae ]._cd ;
_ffff ++{_bbg :=_gae &1;if _fgba :=_fgb .encodeBit (_dcd ,_ggf ,_bbg );_fgba !=nil {return _f .Wrap (_fgba ,_adg ,"");};_gae >>=1;if _ggf &0x100> 0{_ggf =(((_ggf <<1)|uint32 (_bbg ))&0x1ff)|0x100;}else {_ggf =(_ggf <<1)|uint32 (_bbg );};};_cbg <<=32-_e [_fae ]._bf ;
for _adb :=uint8 (0);_adb < _e [_fae ]._bf ;_adb ++{_bdg :=uint8 ((uint32 (_cbg )&0x80000000)>>31);if _ddf :=_fgb .encodeBit (_dcd ,_ggf ,_bdg );_ddf !=nil {return _f .Wrap (_ddf ,_adg ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cbg <<=1;if _ggf &0x100!=0{_ggf =(((_ggf <<1)|uint32 (_bdg ))&0x1ff)|0x100;}else {_ggf =(_ggf <<1)|uint32 (_bdg );};};return nil ;};func (_bed *Encoder )Final (){_bed .flush ()};func (_acg *Encoder )byteOut (){if _acg ._fbf ==0xff{_acg .rBlock ();return ;
};if _acg ._ea < 0x8000000{_acg .lBlock ();return ;};_acg ._fbf ++;if _acg ._fbf !=0xff{_acg .lBlock ();return ;};_acg ._ea &=0x7ffffff;_acg .rBlock ();};func (_cdb *Encoder )code0 (_cbb *codingContext ,_bb uint32 ,_eccb uint16 ,_aa byte ){if _cbb .mps (_bb )==0{_cdb .codeMPS (_cbb ,_bb ,_eccb ,_aa );
}else {_cdb .codeLPS (_cbb ,_bb ,_eccb ,_aa );};};const (_fca =65536;_fedc =20*1024;);var _e =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func _geb (_gf int )*codingContext {return &codingContext {_fb :make ([]byte ,_gf ),_da :make ([]byte ,_gf )};};func (_bfd *Encoder )Flush (){_bfd ._eab =0;_bfd ._cec =nil ;_bfd ._efd =-1};func (_c Class )String ()string {switch _c {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_dcc *Encoder )encodeBit (_dbd *codingContext ,_aad uint32 ,_fbg uint8 )error {const _bcb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_dcc ._ged ++;if _aad >=uint32 (len (_dbd ._fb )){return _f .Errorf (_bcb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_aad );
};_gcf :=_dbd ._fb [_aad ];_gedg :=_dbd .mps (_aad );_fg :=_ebd [_gcf ]._fgbe ;_ac .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dcc ._ged ,_fbg ,_gcf ,_gedg ,_fg ,_dcc ._fd ,_dcc ._ea ,_dcc ._gec ,_dcc ._fbf ,_dcc ._efd );
if _fbg ==0{_dcc .code0 (_dbd ,_aad ,_fg ,_gcf );}else {_dcc .code1 (_dbd ,_aad ,_fg ,_gcf );};return nil ;};var _ _a .WriterTo =&Encoder {};func (_ef *codingContext )flipMps (_fe uint32 ){_ef ._da [_fe ]=1-_ef ._da [_fe ]};type intEncRangeS struct{_dd ,_cg int ;
_cb ,_cd uint8 ;_ag uint16 ;_bf uint8 ;};func (_ce *codingContext )mps (_ge uint32 )int {return int (_ce ._da [_ge ])};func (_ecc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gag error ){_ac .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gag =_ecc .encodeIAID (symbolCodeLength ,value );_gag !=nil {return _f .Wrap (_gag ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};const _af =0x9b25;func (_ada *Encoder )dataSize ()int {return _fedc *len (_ada ._cec )+_ada ._eab };
type Encoder struct{_ea uint32 ;_fd uint16 ;_gec ,_fbf uint8 ;_efd int ;_ged int ;_cec [][]byte ;_ae []byte ;_eab int ;_ba *codingContext ;_cf [13]*codingContext ;_ad *codingContext ;};func (_acgd *Encoder )rBlock (){if _acgd ._efd >=0{_acgd .emit ();};
_acgd ._efd ++;_acgd ._fbf =uint8 (_acgd ._ea >>20);_acgd ._ea &=0xfffff;_acgd ._gec =7;};