//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_ae "github.com/unidoc/unipdf/v4/common";_c "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_gf "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_e "io";);var _gfc =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_b Class )String ()string {switch _b {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_cfc *Encoder )setBits (){_gac :=_cfc ._dd +uint32 (_cfc ._ca );_cfc ._dd |=0xffff;if _cfc ._dd >=_gac {_cfc ._dd -=0x8000;
};};func (_gg *Encoder )DataSize ()int {return _gg .dataSize ()};func (_dfb *Encoder )encodeBit (_gfd *codingContext ,_fcd uint32 ,_deeb uint8 )error {const _aca ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_dfb ._cc ++;if _fcd >=uint32 (len (_gfd ._dg )){return _gf .Errorf (_aca ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fcd );
};_cccf :=_gfd ._dg [_fcd ];_bef :=_gfd .mps (_fcd );_cbe :=_gfc [_cccf ]._fbbeb ;_ae .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dfb ._cc ,_deeb ,_cccf ,_bef ,_cbe ,_dfb ._ca ,_dfb ._dd ,_dfb ._df ,_dfb ._fg ,_dfb ._ea );
if _deeb ==0{_dfb .code0 (_gfd ,_fcd ,_cbe ,_cccf );}else {_dfb .code1 (_gfd ,_fcd ,_cbe ,_cccf );};return nil ;};func (_eef *Encoder )encodeIAID (_ebd ,_gec int )error {if _eef ._fc ==nil {_eef ._fc =_bf (1<<uint (_ebd ));};_acef :=uint32 (1<<uint32 (_ebd +1))-1;
_gec <<=uint (32-_ebd );_edb :=uint32 (1);for _beb :=0;_beb < _ebd ;_beb ++{_fbbe :=_edb &_acef ;_gfdd :=uint8 ((uint32 (_gec )&0x80000000)>>31);if _dea :=_eef .encodeBit (_eef ._fc ,_fbbe ,_gfdd );_dea !=nil {return _dea ;};_edb =(_edb <<1)|uint32 (_gfdd );
_gec <<=1;};return nil ;};func (_cb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gdd error ){_ae .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gdd =_cb .encodeIAID (symbolCodeLength ,value );_gdd !=nil {return _gf .Wrap (_gdd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type Class int ;func (_afc *Encoder )codeMPS (_bfd *codingContext ,_cccg uint32 ,_dbc uint16 ,_fdg byte ){_afc ._ca -=_dbc ;
if _afc ._ca &0x8000!=0{_afc ._dd +=uint32 (_dbc );return ;};if _afc ._ca < _dbc {_afc ._ca =_dbc ;}else {_afc ._dd +=uint32 (_dbc );};_bfd ._dg [_cccg ]=_gfc [_fdg ]._fda ;_afc .renormalize ();};func (_ggb *Encoder )Flush (){_ggb ._fe =0;_ggb ._aeg =nil ;
_ggb ._ea =-1};type Encoder struct{_dd uint32 ;_ca uint16 ;_df ,_fg uint8 ;_ea int ;_cc int ;_aeg [][]byte ;_dc []byte ;_fe int ;_ad *codingContext ;_ec [13]*codingContext ;_fc *codingContext ;};func (_agdb *Encoder )codeLPS (_fde *codingContext ,_ace uint32 ,_aad uint16 ,_gcca byte ){_agdb ._ca -=_aad ;
if _agdb ._ca < _aad {_agdb ._dd +=uint32 (_aad );}else {_agdb ._ca =_aad ;};if _gfc [_gcca ]._gaf ==1{_fde .flipMps (_ace );};_fde ._dg [_ace ]=_gfc [_gcca ]._ddac ;_agdb .renormalize ();};func (_gbe *Encoder )code1 (_fab *codingContext ,_ece uint32 ,_cfba uint16 ,_aa byte ){if _fab .mps (_ece )==1{_gbe .codeMPS (_fab ,_ece ,_cfba ,_aa );
}else {_gbe .codeLPS (_fab ,_ece ,_cfba ,_aa );};};func New ()*Encoder {_fb :=&Encoder {};_fb .Init ();return _fb };func (_ega *Encoder )rBlock (){if _ega ._ea >=0{_ega .emit ();};_ega ._ea ++;_ega ._fg =uint8 (_ega ._dd >>20);_ega ._dd &=0xfffff;_ega ._df =7;
};func _bf (_cd int )*codingContext {return &codingContext {_dg :make ([]byte ,_cd ),_ce :make ([]byte ,_cd )};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_gddf *Encoder )renormalize (){for {_gddf ._ca <<=1;
_gddf ._dd <<=1;_gddf ._df --;if _gddf ._df ==0{_gddf .byteOut ();};if (_gddf ._ca &0x8000)!=0{break ;};};};func (_fbca *Encoder )Reset (){_fbca ._ca =0x8000;_fbca ._dd =0;_fbca ._df =12;_fbca ._ea =-1;_fbca ._fg =0;_fbca ._fc =nil ;_fbca ._ad =_bf (_ccd );
};func (_dfg *Encoder )code0 (_fef *codingContext ,_gcd uint32 ,_agd uint16 ,_bce byte ){if _fef .mps (_gcd )==0{_dfg .codeMPS (_fef ,_gcd ,_agd ,_bce );}else {_dfg .codeLPS (_fef ,_gcd ,_agd ,_bce );};};func (_ab *Encoder )byteOut (){if _ab ._fg ==0xff{_ab .rBlock ();
return ;};if _ab ._dd < 0x8000000{_ab .lBlock ();return ;};_ab ._fg ++;if _ab ._fg !=0xff{_ab .lBlock ();return ;};_ab ._dd &=0x7ffffff;_ab .rBlock ();};const (_ccd =65536;_ff =20*1024;);const _fcf =0x9b25;func (_be *Encoder )Refine (iTemp ,iTarget *_c .Bitmap ,ox ,oy int )error {for _dda :=0;
_dda < iTarget .Height ;_dda ++{var _adb int ;_ag :=_dda +oy ;var (_fd ,_fbb ,_gdc ,_gdfg ,_ebf uint16 ;_fcffb ,_db ,_ccc ,_dge ,_dcc byte ;);if _ag >=1&&(_ag -1)< iTemp .Height {_fcffb =iTemp .Data [(_ag -1)*iTemp .RowStride ];};if _ag >=0&&_ag < iTemp .Height {_db =iTemp .Data [_ag *iTemp .RowStride ];
};if _ag >=-1&&_ag +1< iTemp .Height {_ccc =iTemp .Data [(_ag +1)*iTemp .RowStride ];};if _dda >=1{_dge =iTarget .Data [(_dda -1)*iTarget .RowStride ];};_dcc =iTarget .Data [_dda *iTarget .RowStride ];_ggc :=uint (6+ox );_fd =uint16 (_fcffb >>_ggc );_fbb =uint16 (_db >>_ggc );
_gdc =uint16 (_ccc >>_ggc );_gdfg =uint16 (_dge >>6);_bfa :=uint (2-ox );_fcffb <<=_bfa ;_db <<=_bfa ;_ccc <<=_bfa ;_dge <<=2;for _adb =0;_adb < iTarget .Width ;_adb ++{_bd :=(_fd <<10)|(_fbb <<7)|(_gdc <<4)|(_gdfg <<1)|_ebf ;_bg :=_dcc >>7;_age :=_be .encodeBit (_be ._ad ,uint32 (_bd ),_bg );
if _age !=nil {return _age ;};_fd <<=1;_fbb <<=1;_gdc <<=1;_gdfg <<=1;_fd |=uint16 (_fcffb >>7);_fbb |=uint16 (_db >>7);_gdc |=uint16 (_ccc >>7);_gdfg |=uint16 (_dge >>7);_ebf =uint16 (_bg );_ecc :=_adb %8;_edg :=_adb /8+1;if _ecc ==5+ox {_fcffb ,_db ,_ccc =0,0,0;
if _edg < iTemp .RowStride &&_ag >=1&&(_ag -1)< iTemp .Height {_fcffb =iTemp .Data [(_ag -1)*iTemp .RowStride +_edg ];};if _edg < iTemp .RowStride &&_ag >=0&&_ag < iTemp .Height {_db =iTemp .Data [_ag *iTemp .RowStride +_edg ];};if _edg < iTemp .RowStride &&_ag >=-1&&(_ag +1)< iTemp .Height {_ccc =iTemp .Data [(_ag +1)*iTemp .RowStride +_edg ];
};}else {_fcffb <<=1;_db <<=1;_ccc <<=1;};if _ecc ==5&&_dda >=1{_dge =0;if _edg < iTarget .RowStride {_dge =iTarget .Data [(_dda -1)*iTarget .RowStride +_edg ];};}else {_dge <<=1;};if _ecc ==7{_dcc =0;if _edg < iTarget .RowStride {_dcc =iTarget .Data [_dda *iTarget .RowStride +_edg ];
};}else {_dcc <<=1;};_fd &=7;_fbb &=7;_gdc &=7;_gdfg &=7;};};return nil ;};func (_gc *codingContext )flipMps (_f uint32 ){_gc ._ce [_f ]=1-_gc ._ce [_f ]};func (_ecf *Encoder )Init (){_ecf ._ad =_bf (_ccd );_ecf ._ca =0x8000;_ecf ._dd =0;_ecf ._df =12;
_ecf ._ea =-1;_ecf ._fg =0;_ecf ._fe =0;_ecf ._dc =make ([]byte ,_ff );for _gcc :=0;_gcc < len (_ecf ._ec );_gcc ++{_ecf ._ec [_gcc ]=_bf (512);};_ecf ._fc =nil ;};func (_cba *Encoder )flush (){_cba .setBits ();_cba ._dd <<=_cba ._df ;_cba .byteOut ();
_cba ._dd <<=_cba ._df ;_cba .byteOut ();_cba .emit ();if _cba ._fg !=0xff{_cba ._ea ++;_cba ._fg =0xff;_cba .emit ();};_cba ._ea ++;_cba ._fg =0xac;_cba ._ea ++;_cba .emit ();};func (_dgf *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _fac ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _dgeb int64 ;for _cfb ,_dgb :=range _dgf ._aeg {_geg ,_gb :=w .Write (_dgb );if _gb !=nil {return 0,_gf .Wrapf (_gb ,_fac ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cfb );
};_dgeb +=int64 (_geg );};_dgf ._dc =_dgf ._dc [:_dgf ._fe ];_cecd ,_gee :=w .Write (_dgf ._dc );if _gee !=nil {return 0,_gf .Wrap (_gee ,_fac ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_dgeb +=int64 (_cecd );
return _dgeb ,nil ;};func (_dcf *Encoder )Final (){_dcf .flush ()};func (_de *codingContext )mps (_gdf uint32 )int {return int (_de ._ce [_gdf ])};func (_cg *Encoder )EncodeOOB (proc Class )(_fed error ){_ae .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fed =_cg .encodeOOB (proc );_fed !=nil {return _gf .Wrap (_fed ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};var _d =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_eed *Encoder )encodeOOB (_fgb Class )error {_gcdd :=_eed ._ec [_fgb ];_cdb :=_eed .encodeBit (_gcdd ,1,1);if _cdb !=nil {return _cdb ;};_cdb =_eed .encodeBit (_gcdd ,3,0);if _cdb !=nil {return _cdb ;};_cdb =_eed .encodeBit (_gcdd ,6,0);if _cdb !=nil {return _cdb ;
};_cdb =_eed .encodeBit (_gcdd ,12,0);if _cdb !=nil {return _cdb ;};return nil ;};func (_fgd *Encoder )dataSize ()int {return _ff *len (_fgd ._aeg )+_fgd ._fe };func (_bb *Encoder )EncodeBitmap (bm *_c .Bitmap ,duplicateLineRemoval bool )error {_ae .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_bc ,_fbc uint8 ;_ade ,_cec ,_fa uint16 ;_da ,_def ,_ee byte ;_dee ,_ead ,_ge int ;_cff ,_dcg []byte ;);for _fcff :=0;_fcff < bm .Height ;_fcff ++{_da ,_def =0,0;if _fcff >=2{_da =bm .Data [(_fcff -2)*bm .RowStride ];};if _fcff >=1{_def =bm .Data [(_fcff -1)*bm .RowStride ];
if duplicateLineRemoval {_ead =_fcff *bm .RowStride ;_cff =bm .Data [_ead :_ead +bm .RowStride ];_ge =(_fcff -1)*bm .RowStride ;_dcg =bm .Data [_ge :_ge +bm .RowStride ];if _a .Equal (_cff ,_dcg ){_fbc =_bc ^1;_bc =1;}else {_fbc =_bc ;_bc =0;};};};if duplicateLineRemoval {if _ddd :=_bb .encodeBit (_bb ._ad ,_fcf ,_fbc );
_ddd !=nil {return _ddd ;};if _bc !=0{continue ;};};_ee =bm .Data [_fcff *bm .RowStride ];_ade =uint16 (_da >>5);_cec =uint16 (_def >>4);_da <<=3;_def <<=4;_fa =0;for _dee =0;_dee < bm .Width ;_dee ++{_aegb :=uint32 (_ade <<11|_cec <<4|_fa );_fca :=(_ee &0x80)>>7;
_aee :=_bb .encodeBit (_bb ._ad ,_aegb ,_fca );if _aee !=nil {return _aee ;};_ade <<=1;_cec <<=1;_fa <<=1;_ade |=uint16 ((_da &0x80)>>7);_cec |=uint16 ((_def &0x80)>>7);_fa |=uint16 (_fca );_gdfd :=_dee %8;_eg :=_dee /8+1;if _gdfd ==4&&_fcff >=2{_da =0;
if _eg < bm .RowStride {_da =bm .Data [(_fcff -2)*bm .RowStride +_eg ];};}else {_da <<=1;};if _gdfd ==3&&_fcff >=1{_def =0;if _eg < bm .RowStride {_def =bm .Data [(_fcff -1)*bm .RowStride +_eg ];};}else {_def <<=1;};if _gdfd ==7{_ee =0;if _eg < bm .RowStride {_ee =bm .Data [_fcff *bm .RowStride +_eg ];
};}else {_ee <<=1;};_ade &=31;_cec &=127;_fa &=15;};};return nil ;};func (_gaa *Encoder )lBlock (){if _gaa ._ea >=0{_gaa .emit ();};_gaa ._ea ++;_gaa ._fg =uint8 (_gaa ._dd >>19);_gaa ._dd &=0x7ffff;_gaa ._df =8;};func (_gca *Encoder )emit (){if _gca ._fe ==_ff {_gca ._aeg =append (_gca ._aeg ,_gca ._dc );
_gca ._dc =make ([]byte ,_ff );_gca ._fe =0;};_gca ._dc [_gca ._fe ]=_gca ._fg ;_gca ._fe ++;};func (_fded *Encoder )encodeInteger (_ga Class ,_adbd int )error {const _eda ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _adbd > 2000000000||_adbd < -2000000000{return _gf .Errorf (_eda ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_adbd );
};_fgg :=_fded ._ec [_ga ];_edf :=uint32 (1);var _cbc int ;for ;;_cbc ++{if _d [_cbc ]._cf <=_adbd &&_d [_cbc ]._ed >=_adbd {break ;};};if _adbd < 0{_adbd =-_adbd ;};_adbd -=int (_d [_cbc ]._ac );_ada :=_d [_cbc ]._af ;for _aae :=uint8 (0);_aae < _d [_cbc ]._eb ;
_aae ++{_caa :=_ada &1;if _fcaf :=_fded .encodeBit (_fgg ,_edf ,_caa );_fcaf !=nil {return _gf .Wrap (_fcaf ,_eda ,"");};_ada >>=1;if _edf &0x100> 0{_edf =(((_edf <<1)|uint32 (_caa ))&0x1ff)|0x100;}else {_edf =(_edf <<1)|uint32 (_caa );};};_adbd <<=32-_d [_cbc ]._gd ;
for _gda :=uint8 (0);_gda < _d [_cbc ]._gd ;_gda ++{_aab :=uint8 ((uint32 (_adbd )&0x80000000)>>31);if _cac :=_fded .encodeBit (_fgg ,_edf ,_aab );_cac !=nil {return _gf .Wrap (_cac ,_eda ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_adbd <<=1;if _edf &0x100!=0{_edf =(((_edf <<1)|uint32 (_aab ))&0x1ff)|0x100;}else {_edf =(_edf <<1)|uint32 (_aab );};};return nil ;};type codingContext struct{_dg []byte ;_ce []byte ;};type state struct{_fbbeb uint16 ;_fda ,_ddac uint8 ;_gaf uint8 ;
};type intEncRangeS struct{_cf ,_ed int ;_af ,_eb uint8 ;_ac uint16 ;_gd uint8 ;};func (_ced *Encoder )EncodeInteger (proc Class ,value int )(_bbb error ){_ae .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bbb =_ced .encodeInteger (proc ,value );_bbb !=nil {return _gf .Wrap (_bbb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};var _ _e .WriterTo =&Encoder {};