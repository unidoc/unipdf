//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_c "github.com/unidoc/unipdf/v4/common";_ad "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_ec "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_a "io";);func (_ge *Encoder )DataSize ()int {return _ge .dataSize ()};
func (_acg *Encoder )Reset (){_acg ._eb =0x8000;_acg ._bfd =0;_acg ._eba =12;_acg ._bcg =-1;_acg ._da =0;_acg ._ag =nil ;_acg ._fb =_be (_fbd );};func (_gdd *Encoder )renormalize (){for {_gdd ._eb <<=1;_gdd ._bfd <<=1;_gdd ._eba --;if _gdd ._eba ==0{_gdd .byteOut ();
};if (_gdd ._eb &0x8000)!=0{break ;};};};type Encoder struct{_bfd uint32 ;_eb uint16 ;_eba ,_da uint8 ;_bcg int ;_db int ;_ac [][]byte ;_bcd []byte ;_ebd int ;_fb *codingContext ;_dg [13]*codingContext ;_ag *codingContext ;};const (IAAI Class =iota ;IADH ;
IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ece *Encoder )rBlock (){if _ece ._bcg >=0{_ece .emit ();};_ece ._bcg ++;_ece ._da =uint8 (_ece ._bfd >>20);_ece ._bfd &=0xfffff;_ece ._eba =7;};func (_cc *codingContext )mps (_ffg uint32 )int {return int (_cc ._bc [_ffg ])};
func (_ddcf *Encoder )flush (){_ddcf .setBits ();_ddcf ._bfd <<=_ddcf ._eba ;_ddcf .byteOut ();_ddcf ._bfd <<=_ddcf ._eba ;_ddcf .byteOut ();_ddcf .emit ();if _ddcf ._da !=0xff{_ddcf ._bcg ++;_ddcf ._da =0xff;_ddcf .emit ();};_ddcf ._bcg ++;_ddcf ._da =0xac;
_ddcf ._bcg ++;_ddcf .emit ();};func (_cab *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ea error ){_c .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ea =_cab .encodeIAID (symbolCodeLength ,value );_ea !=nil {return _ec .Wrap (_ea ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type Class int ;type codingContext struct{_ff []byte ;_bc []byte ;};type state struct{_cdc uint16 ;
_dabe ,_fgdg uint8 ;_cecb uint8 ;};func (_ed Class )String ()string {switch _ed {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_gag *Encoder )lBlock (){if _gag ._bcg >=0{_gag .emit ();
};_gag ._bcg ++;_gag ._da =uint8 (_gag ._bfd >>19);_gag ._bfd &=0x7ffff;_gag ._eba =8;};func (_bfdb *Encoder )EncodeOOB (proc Class )(_fc error ){_c .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fc =_bfdb .encodeOOB (proc );_fc !=nil {return _ec .Wrap (_fc ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_ca *Encoder )Init (){_ca ._fb =_be (_fbd );_ca ._eb =0x8000;_ca ._bfd =0;_ca ._eba =12;_ca ._bcg =-1;_ca ._da =0;
_ca ._ebd =0;_ca ._bcd =make ([]byte ,_fff );for _bd :=0;_bd < len (_ca ._dg );_bd ++{_ca ._dg [_bd ]=_be (512);};_ca ._ag =nil ;};func (_dbc *Encoder )Refine (iTemp ,iTarget *_ad .Bitmap ,ox ,oy int )error {for _gc :=0;_gc < iTarget .Height ;_gc ++{var _cd int ;
_ffb :=_gc +oy ;var (_gba ,_ab ,_dd ,_ffef ,_gbae uint16 ;_cca ,_abc ,_bdd ,_daba ,_bed byte ;);if _ffb >=1&&(_ffb -1)< iTemp .Height {_cca =iTemp .Data [(_ffb -1)*iTemp .RowStride ];};if _ffb >=0&&_ffb < iTemp .Height {_abc =iTemp .Data [_ffb *iTemp .RowStride ];
};if _ffb >=-1&&_ffb +1< iTemp .Height {_bdd =iTemp .Data [(_ffb +1)*iTemp .RowStride ];};if _gc >=1{_daba =iTarget .Data [(_gc -1)*iTarget .RowStride ];};_bed =iTarget .Data [_gc *iTarget .RowStride ];_aa :=uint (6+ox );_gba =uint16 (_cca >>_aa );_ab =uint16 (_abc >>_aa );
_dd =uint16 (_bdd >>_aa );_ffef =uint16 (_daba >>6);_gg :=uint (2-ox );_cca <<=_gg ;_abc <<=_gg ;_bdd <<=_gg ;_daba <<=2;for _cd =0;_cd < iTarget .Width ;_cd ++{_ada :=(_gba <<10)|(_ab <<7)|(_dd <<4)|(_ffef <<1)|_gbae ;_fe :=_bed >>7;_ee :=_dbc .encodeBit (_dbc ._fb ,uint32 (_ada ),_fe );
if _ee !=nil {return _ee ;};_gba <<=1;_ab <<=1;_dd <<=1;_ffef <<=1;_gba |=uint16 (_cca >>7);_ab |=uint16 (_abc >>7);_dd |=uint16 (_bdd >>7);_ffef |=uint16 (_daba >>7);_gbae =uint16 (_fe );_cf :=_cd %8;_gf :=_cd /8+1;if _cf ==5+ox {_cca ,_abc ,_bdd =0,0,0;
if _gf < iTemp .RowStride &&_ffb >=1&&(_ffb -1)< iTemp .Height {_cca =iTemp .Data [(_ffb -1)*iTemp .RowStride +_gf ];};if _gf < iTemp .RowStride &&_ffb >=0&&_ffb < iTemp .Height {_abc =iTemp .Data [_ffb *iTemp .RowStride +_gf ];};if _gf < iTemp .RowStride &&_ffb >=-1&&(_ffb +1)< iTemp .Height {_bdd =iTemp .Data [(_ffb +1)*iTemp .RowStride +_gf ];
};}else {_cca <<=1;_abc <<=1;_bdd <<=1;};if _cf ==5&&_gc >=1{_daba =0;if _gf < iTarget .RowStride {_daba =iTarget .Data [(_gc -1)*iTarget .RowStride +_gf ];};}else {_daba <<=1;};if _cf ==7{_bed =0;if _gf < iTarget .RowStride {_bed =iTarget .Data [_gc *iTarget .RowStride +_gf ];
};}else {_bed <<=1;};_gba &=7;_ab &=7;_dd &=7;_ffef &=7;};};return nil ;};func (_bcf *Encoder )dataSize ()int {return _fff *len (_bcf ._ac )+_bcf ._ebd };var _d =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_edae *Encoder )codeLPS (_bad *codingContext ,_gda uint32 ,_ecd uint16 ,_gdg byte ){_edae ._eb -=_ecd ;if _edae ._eb < _ecd {_edae ._bfd +=uint32 (_ecd );}else {_edae ._eb =_ecd ;};if _aeb [_gdg ]._cecb ==1{_bad .flipMps (_gda );};_bad ._ff [_gda ]=_aeb [_gdg ]._fgdg ;
_edae .renormalize ();};func (_gaf *Encoder )encodeIAID (_afg ,_eab int )error {if _gaf ._ag ==nil {_gaf ._ag =_be (1<<uint (_afg ));};_eca :=uint32 (1<<uint32 (_afg +1))-1;_eab <<=uint (32-_afg );_cdg :=uint32 (1);for _agb :=0;_agb < _afg ;_agb ++{_ggbg :=_cdg &_eca ;
_baf :=uint8 ((uint32 (_eab )&0x80000000)>>31);if _bdf :=_gaf .encodeBit (_gaf ._ag ,_ggbg ,_baf );_bdf !=nil {return _bdf ;};_cdg =(_cdg <<1)|uint32 (_baf );_eab <<=1;};return nil ;};func (_ffe *Encoder )EncodeBitmap (bm *_ad .Bitmap ,duplicateLineRemoval bool )error {_c .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cgf ,_bae uint8 ;_agg ,_fbb ,_ce uint16 ;_daa ,_bef ,_bge byte ;_ccb ,_cb ,_gea int ;_afe ,_dc []byte ;);for _cag :=0;_cag < bm .Height ;_cag ++{_daa ,_bef =0,0;if _cag >=2{_daa =bm .Data [(_cag -2)*bm .RowStride ];};if _cag >=1{_bef =bm .Data [(_cag -1)*bm .RowStride ];
if duplicateLineRemoval {_cb =_cag *bm .RowStride ;_afe =bm .Data [_cb :_cb +bm .RowStride ];_gea =(_cag -1)*bm .RowStride ;_dc =bm .Data [_gea :_gea +bm .RowStride ];if _e .Equal (_afe ,_dc ){_bae =_cgf ^1;_cgf =1;}else {_bae =_cgf ;_cgf =0;};};};if duplicateLineRemoval {if _ae :=_ffe .encodeBit (_ffe ._fb ,_bb ,_bae );
_ae !=nil {return _ae ;};if _cgf !=0{continue ;};};_bge =bm .Data [_cag *bm .RowStride ];_agg =uint16 (_daa >>5);_fbb =uint16 (_bef >>4);_daa <<=3;_bef <<=4;_ce =0;for _ccb =0;_ccb < bm .Width ;_ccb ++{_bga :=uint32 (_agg <<11|_fbb <<4|_ce );_ga :=(_bge &0x80)>>7;
_baa :=_ffe .encodeBit (_ffe ._fb ,_bga ,_ga );if _baa !=nil {return _baa ;};_agg <<=1;_fbb <<=1;_ce <<=1;_agg |=uint16 ((_daa &0x80)>>7);_fbb |=uint16 ((_bef &0x80)>>7);_ce |=uint16 (_ga );_bee :=_ccb %8;_agc :=_ccb /8+1;if _bee ==4&&_cag >=2{_daa =0;
if _agc < bm .RowStride {_daa =bm .Data [(_cag -2)*bm .RowStride +_agc ];};}else {_daa <<=1;};if _bee ==3&&_cag >=1{_bef =0;if _agc < bm .RowStride {_bef =bm .Data [(_cag -1)*bm .RowStride +_agc ];};}else {_bef <<=1;};if _bee ==7{_bge =0;if _agc < bm .RowStride {_bge =bm .Data [_cag *bm .RowStride +_agc ];
};}else {_bge <<=1;};_agg &=31;_fbb &=127;_ce &=15;};};return nil ;};const _bb =0x9b25;func (_gbf *Encoder )code0 (_fcc *codingContext ,_eed uint32 ,_ggb uint16 ,_bfc byte ){if _fcc .mps (_eed )==0{_gbf .codeMPS (_fcc ,_eed ,_ggb ,_bfc );}else {_gbf .codeLPS (_fcc ,_eed ,_ggb ,_bfc );
};};func (_fgd *Encoder )encodeBit (_ggc *codingContext ,_gdgg uint32 ,_gdad uint8 )error {const _ddc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_fgd ._db ++;if _gdgg >=uint32 (len (_ggc ._ff )){return _ec .Errorf (_ddc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gdgg );
};_gbg :=_ggc ._ff [_gdgg ];_fgda :=_ggc .mps (_gdgg );_eg :=_aeb [_gbg ]._cdc ;_c .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_fgd ._db ,_gdad ,_gbg ,_fgda ,_eg ,_fgd ._eb ,_fgd ._bfd ,_fgd ._eba ,_fgd ._da ,_fgd ._bcg );
if _gdad ==0{_fgd .code0 (_ggc ,_gdgg ,_eg ,_gbg );}else {_fgd .code1 (_ggc ,_gdgg ,_eg ,_gbg );};return nil ;};func (_eda *Encoder )code1 (_aab *codingContext ,_bedc uint32 ,_bgb uint16 ,_eaf byte ){if _aab .mps (_bedc )==1{_eda .codeMPS (_aab ,_bedc ,_bgb ,_eaf );
}else {_eda .codeLPS (_aab ,_bedc ,_bgb ,_eaf );};};func (_cabb *Encoder )encodeInteger (_age Class ,_gbab int )error {const _bcc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gbab > 2000000000||_gbab < -2000000000{return _ec .Errorf (_bcc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gbab );
};_dce :=_cabb ._dg [_age ];_bfcb :=uint32 (1);var _cbe int ;for ;;_cbe ++{if _d [_cbe ]._cg <=_gbab &&_d [_cbe ]._gb >=_gbab {break ;};};if _gbab < 0{_gbab =-_gbab ;};_gbab -=int (_d [_cbe ]._ba );_gga :=_d [_cbe ]._b ;for _aacc :=uint8 (0);_aacc < _d [_cbe ]._bf ;
_aacc ++{_bfe :=_gga &1;if _ggcb :=_cabb .encodeBit (_dce ,_bfcb ,_bfe );_ggcb !=nil {return _ec .Wrap (_ggcb ,_bcc ,"");};_gga >>=1;if _bfcb &0x100> 0{_bfcb =(((_bfcb <<1)|uint32 (_bfe ))&0x1ff)|0x100;}else {_bfcb =(_bfcb <<1)|uint32 (_bfe );};};_gbab <<=32-_d [_cbe ]._f ;
for _fcb :=uint8 (0);_fcb < _d [_cbe ]._f ;_fcb ++{_dcg :=uint8 ((uint32 (_gbab )&0x80000000)>>31);if _fed :=_cabb .encodeBit (_dce ,_bfcb ,_dcg );_fed !=nil {return _ec .Wrap (_fed ,_bcc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gbab <<=1;if _bfcb &0x100!=0{_bfcb =(((_bfcb <<1)|uint32 (_dcg ))&0x1ff)|0x100;}else {_bfcb =(_bfcb <<1)|uint32 (_dcg );};};return nil ;};func (_dab *Encoder )Flush (){_dab ._ebd =0;_dab ._ac =nil ;_dab ._bcg =-1};var _aeb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
var _ _a .WriterTo =&Encoder {};type intEncRangeS struct{_cg ,_gb int ;_b ,_bf uint8 ;_ba uint16 ;_f uint8 ;};func _be (_bgc int )*codingContext {return &codingContext {_ff :make ([]byte ,_bgc ),_bc :make ([]byte ,_bgc )};};func New ()*Encoder {_cce :=&Encoder {};
_cce .Init ();return _cce };func (_af *codingContext )flipMps (_bg uint32 ){_af ._bc [_bg ]=1-_af ._bc [_bg ]};const (_fbd =65536;_fff =20*1024;);func (_fbe *Encoder )codeMPS (_dge *codingContext ,_aac uint32 ,_dabd uint16 ,_cec byte ){_fbe ._eb -=_dabd ;
if _fbe ._eb &0x8000!=0{_fbe ._bfd +=uint32 (_dabd );return ;};if _fbe ._eb < _dabd {_fbe ._eb =_dabd ;}else {_fbe ._bfd +=uint32 (_dabd );};_dge ._ff [_aac ]=_aeb [_cec ]._dabe ;_fbe .renormalize ();};func (_eceg *Encoder )setBits (){_bea :=_eceg ._bfd +uint32 (_eceg ._eb );
_eceg ._bfd |=0xffff;if _eceg ._bfd >=_bea {_eceg ._bfd -=0x8000;};};func (_fg *Encoder )EncodeInteger (proc Class ,value int )(_ede error ){_c .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ede =_fg .encodeInteger (proc ,value );_ede !=nil {return _ec .Wrap (_ede ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_edd *Encoder )Final (){_edd .flush ()};func (_bgg *Encoder )emit (){if _bgg ._ebd ==_fff {_bgg ._ac =append (_bgg ._ac ,_bgg ._bcd );
_bgg ._bcd =make ([]byte ,_fff );_bgg ._ebd =0;};_bgg ._bcd [_bgg ._ebd ]=_bgg ._da ;_bgg ._ebd ++;};func (_afef *Encoder )byteOut (){if _afef ._da ==0xff{_afef .rBlock ();return ;};if _afef ._bfd < 0x8000000{_afef .lBlock ();return ;};_afef ._da ++;if _afef ._da !=0xff{_afef .lBlock ();
return ;};_afef ._bfd &=0x7ffffff;_afef .rBlock ();};func (_cge *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _bbb ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _afc int64 ;for _ggg ,_ccg :=range _cge ._ac {_fa ,_edf :=w .Write (_ccg );
if _edf !=nil {return 0,_ec .Wrapf (_edf ,_bbb ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ggg );};_afc +=int64 (_fa );};_cge ._bcd =_cge ._bcd [:_cge ._ebd ];
_gcd ,_gce :=w .Write (_cge ._bcd );if _gce !=nil {return 0,_ec .Wrap (_gce ,_bbb ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_afc +=int64 (_gcd );return _afc ,nil ;};func (_gec *Encoder )encodeOOB (_egd Class )error {_eae :=_gec ._dg [_egd ];
_bgf :=_gec .encodeBit (_eae ,1,1);if _bgf !=nil {return _bgf ;};_bgf =_gec .encodeBit (_eae ,3,0);if _bgf !=nil {return _bgf ;};_bgf =_gec .encodeBit (_eae ,6,0);if _bgf !=nil {return _bgf ;};_bgf =_gec .encodeBit (_eae ,12,0);if _bgf !=nil {return _bgf ;
};return nil ;};