//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_a "github.com/unidoc/unipdf/v4/internal/bitwise";_e "github.com/unidoc/unipdf/v4/internal/imageutil";_f "io";);func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _eaf []uint32 ;
_ga :=bitsPerOutputSample ;var _ecef uint32 ;var _ffe uint32 ;_eff :=0;_eced :=0;_fb :=0;for _fb < len (data ){if _eff > 0{_bc :=_eff ;if _ga < _bc {_bc =_ga ;};_ecef =(_ecef <<uint (_bc ))|(_ffe >>uint (bitsPerInputSample -_bc ));_eff -=_bc ;if _eff > 0{_ffe =_ffe <<uint (_bc );
}else {_ffe =0;};_ga -=_bc ;if _ga ==0{_eaf =append (_eaf ,_ecef );_ga =bitsPerOutputSample ;_ecef =0;_eced ++;};}else {_cf :=data [_fb ];_fb ++;_aba :=bitsPerInputSample ;if _ga < _aba {_aba =_ga ;};_eff =bitsPerInputSample -_aba ;_ecef =(_ecef <<uint (_aba ))|(_cf >>uint (_eff ));
if _aba < bitsPerInputSample {_ffe =_cf <<uint (_aba );};_ga -=_aba ;if _ga ==0{_eaf =append (_eaf ,_ecef );_ga =bitsPerOutputSample ;_ecef =0;_eced ++;};};};for _eff >=bitsPerOutputSample {_ace :=_eff ;if _ga < _ace {_ace =_ga ;};_ecef =(_ecef <<uint (_ace ))|(_ffe >>uint (bitsPerInputSample -_ace ));
_eff -=_ace ;if _eff > 0{_ffe =_ffe <<uint (_ace );}else {_ffe =0;};_ga -=_ace ;if _ga ==0{_eaf =append (_eaf ,_ecef );_ga =bitsPerOutputSample ;_ecef =0;_eced ++;};};if _ga > 0&&_ga < bitsPerOutputSample {_ecef <<=uint (_ga );_eaf =append (_eaf ,_ecef );
};return _eaf ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ge []uint32 ;_fg :=bitsPerSample ;var _gf uint32 ;var _dgd byte ;_gb :=0;_fa :=0;_ef :=0;for _ef < len (data ){if _gb > 0{_be :=_gb ;if _fg < _be {_be =_fg ;};_gf =(_gf <<uint (_be ))|uint32 (_dgd >>uint (8-_be ));
_gb -=_be ;if _gb > 0{_dgd =_dgd <<uint (_be );}else {_dgd =0;};_fg -=_be ;if _fg ==0{_ge =append (_ge ,_gf );_fg =bitsPerSample ;_gf =0;_fa ++;};}else {_ae :=data [_ef ];_ef ++;_aa :=8;if _fg < _aa {_aa =_fg ;};_gb =8-_aa ;_gf =(_gf <<uint (_aa ))|uint32 (_ae >>uint (_gb ));
if _aa < 8{_dgd =_ae <<uint (_aa );};_fg -=_aa ;if _fg ==0{_ge =append (_ge ,_gf );_fg =bitsPerSample ;_gf =0;_fa ++;};};};for _gb >=bitsPerSample {_ece :=_gb ;if _fg < _ece {_ece =_fg ;};_gf =(_gf <<uint (_ece ))|uint32 (_dgd >>uint (8-_ece ));_gb -=_ece ;
if _gb > 0{_dgd =_dgd <<uint (_ece );}else {_dgd =0;};_fg -=_ece ;if _fg ==0{_ge =append (_ge ,_gf );_fg =bitsPerSample ;_gf =0;_fa ++;};};return _ge ;};type Writer struct{_gg _e .ImageBase ;_acd *_a .Writer ;_aee ,_ed int ;_gfe bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_ff []uint32 )error ;};type Reader struct{_b _e .ImageBase ;_ea *_a .Reader ;_ab ,_dg ,_g int ;_c bool ;};func (_fe *Reader )ReadSamples (samples []uint32 )(_bd error ){for _ac :=0;_ac < len (samples );_ac ++{samples [_ac ],_bd =_fe .ReadSample ();
if _bd !=nil {return _bd ;};};return nil ;};func (_gbd *Writer )WriteSample (sample uint32 )error {if _ ,_aec :=_gbd ._acd .WriteBits (uint64 (sample ),_gbd ._gg .BitsPerComponent );_aec !=nil {return _aec ;};_gbd ._ed --;if _gbd ._ed ==0{_gbd ._ed =_gbd ._gg .ColorComponents ;
_gbd ._aee ++;};if _gbd ._aee ==_gbd ._gg .Width {if _gbd ._gfe {_gbd ._acd .FinishByte ();};_gbd ._aee =0;};return nil ;};func NewReader (img _e .ImageBase )*Reader {return &Reader {_ea :_a .NewReader (img .Data ),_b :img ,_g :img .ColorComponents ,_c :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_bg *Reader )ReadSample ()(uint32 ,error ){if _bg ._dg ==_bg ._b .Height {return 0,_f .EOF ;};_ec ,_gc :=_bg ._ea .ReadBits (byte (_bg ._b .BitsPerComponent ));if _gc !=nil {return 0,_gc ;};_bg ._g --;if _bg ._g ==0{_bg ._g =_bg ._b .ColorComponents ;
_bg ._ab ++;};if _bg ._ab ==_bg ._b .Width {if _bg ._c {_bg ._ea .ConsumeRemainingBits ();};_bg ._ab =0;_bg ._dg ++;};return uint32 (_ec ),nil ;};func (_bgf *Writer )WriteSamples (samples []uint32 )error {for _eg :=0;_eg < len (samples );_eg ++{if _fff :=_bgf .WriteSample (samples [_eg ]);
_fff !=nil {return _fff ;};};return nil ;};func NewWriter (img _e .ImageBase )*Writer {return &Writer {_acd :_a .NewWriterMSB (img .Data ),_gg :img ,_ed :img .ColorComponents ,_gfe :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleWriter interface{WriteSample (_fc uint32 )error ;WriteSamples (_cg []uint32 )error ;};