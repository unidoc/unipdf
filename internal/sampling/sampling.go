//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_af "github.com/unidoc/unipdf/v3/internal/bitwise";_e "github.com/unidoc/unipdf/v3/internal/imageutil";_f "io";);type SampleWriter interface{WriteSample (_aadc uint32 )error ;WriteSamples (_gga []uint32 )error ;};func (_gb *Reader )ReadSample ()(uint32 ,error ){if _gb ._ad ==_gb ._g .Height {return 0,_f .EOF ;
};_cb ,_ca :=_gb ._c .ReadBits (byte (_gb ._g .BitsPerComponent ));if _ca !=nil {return 0,_ca ;};_gb ._d --;if _gb ._d ==0{_gb ._d =_gb ._g .ColorComponents ;_gb ._b ++;};if _gb ._b ==_gb ._g .Width {if _gb ._aa {_gb ._c .ConsumeRemainingBits ();};_gb ._b =0;
_gb ._ad ++;};return uint32 (_cb ),nil ;};func NewReader (img _e .ImageBase )*Reader {return &Reader {_c :_af .NewReader (img .Data ),_g :img ,_d :img .ColorComponents ,_aa :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Writer struct{_ea _e .ImageBase ;_fa *_af .Writer ;_cbb ,_feb int ;_gf bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ega []uint32 ;_bf :=bitsPerOutputSample ;var _bfg uint32 ;var _ab uint32 ;
_dc :=0;_cac :=0;_ee :=0;for _ee < len (data ){if _dc > 0{_fd :=_dc ;if _bf < _fd {_fd =_bf ;};_bfg =(_bfg <<uint (_fd ))|(_ab >>uint (bitsPerInputSample -_fd ));_dc -=_fd ;if _dc > 0{_ab =_ab <<uint (_fd );}else {_ab =0;};_bf -=_fd ;if _bf ==0{_ega =append (_ega ,_bfg );
_bf =bitsPerOutputSample ;_bfg =0;_cac ++;};}else {_bff :=data [_ee ];_ee ++;_cbf :=bitsPerInputSample ;if _bf < _cbf {_cbf =_bf ;};_dc =bitsPerInputSample -_cbf ;_bfg =(_bfg <<uint (_cbf ))|(_bff >>uint (_dc ));if _cbf < bitsPerInputSample {_ab =_bff <<uint (_cbf );
};_bf -=_cbf ;if _bf ==0{_ega =append (_ega ,_bfg );_bf =bitsPerOutputSample ;_bfg =0;_cac ++;};};};for _dc >=bitsPerOutputSample {_cfa :=_dc ;if _bf < _cfa {_cfa =_bf ;};_bfg =(_bfg <<uint (_cfa ))|(_ab >>uint (bitsPerInputSample -_cfa ));_dc -=_cfa ;
if _dc > 0{_ab =_ab <<uint (_cfa );}else {_ab =0;};_bf -=_cfa ;if _bf ==0{_ega =append (_ega ,_bfg );_bf =bitsPerOutputSample ;_bfg =0;_cac ++;};};if _bf > 0&&_bf < bitsPerOutputSample {_bfg <<=uint (_bf );_ega =append (_ega ,_bfg );};return _ega ;};type Reader struct{_g _e .ImageBase ;
_c *_af .Reader ;_b ,_ad ,_d int ;_aa bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_eg []uint32 )error ;};func NewWriter (img _e .ImageBase )*Writer {return &Writer {_fa :_af .NewWriterMSB (img .Data ),_ea :img ,_feb :img .ColorComponents ,_gf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ef []uint32 ;_bc :=bitsPerSample ;var _de uint32 ;var _efd byte ;_deg :=0;_afd :=0;_cc :=0;for _cc < len (data ){if _deg > 0{_cg :=_deg ;if _bc < _cg {_cg =_bc ;};_de =(_de <<uint (_cg ))|uint32 (_efd >>uint (8-_cg ));
_deg -=_cg ;if _deg > 0{_efd =_efd <<uint (_cg );}else {_efd =0;};_bc -=_cg ;if _bc ==0{_ef =append (_ef ,_de );_bc =bitsPerSample ;_de =0;_afd ++;};}else {_ccg :=data [_cc ];_cc ++;_ff :=8;if _bc < _ff {_ff =_bc ;};_deg =8-_ff ;_de =(_de <<uint (_ff ))|uint32 (_ccg >>uint (_deg ));
if _ff < 8{_efd =_ccg <<uint (_ff );};_bc -=_ff ;if _bc ==0{_ef =append (_ef ,_de );_bc =bitsPerSample ;_de =0;_afd ++;};};};for _deg >=bitsPerSample {_cf :=_deg ;if _bc < _cf {_cf =_bc ;};_de =(_de <<uint (_cf ))|uint32 (_efd >>uint (8-_cf ));_deg -=_cf ;
if _deg > 0{_efd =_efd <<uint (_cf );}else {_efd =0;};_bc -=_cf ;if _bc ==0{_ef =append (_ef ,_de );_bc =bitsPerSample ;_de =0;_afd ++;};};return _ef ;};func (_fb *Writer )WriteSamples (samples []uint32 )error {for _egd :=0;_egd < len (samples );_egd ++{if _cd :=_fb .WriteSample (samples [_egd ]);
_cd !=nil {return _cd ;};};return nil ;};func (_gg *Reader )ReadSamples (samples []uint32 )(_fe error ){for _aad :=0;_aad < len (samples );_aad ++{samples [_aad ],_fe =_gg .ReadSample ();if _fe !=nil {return _fe ;};};return nil ;};func (_dce *Writer )WriteSample (sample uint32 )error {if _ ,_gfb :=_dce ._fa .WriteBits (uint64 (sample ),_dce ._ea .BitsPerComponent );
_gfb !=nil {return _gfb ;};_dce ._feb --;if _dce ._feb ==0{_dce ._feb =_dce ._ea .ColorComponents ;_dce ._cbb ++;};if _dce ._cbb ==_dce ._ea .Width {if _dce ._gf {_dce ._fa .FinishByte ();};_dce ._cbb =0;};return nil ;};