//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_a "github.com/unidoc/unipdf/v4/internal/bitwise";_d "github.com/unidoc/unipdf/v4/internal/imageutil";_f "io";);func (_gg *Reader )ReadSample ()(uint32 ,error ){if _gg ._fd ==_gg ._b .Height {return 0,_f .EOF ;};_ba ,_ag :=_gg ._c .ReadBits (byte (_gg ._b .BitsPerComponent ));
if _ag !=nil {return 0,_ag ;};_gg ._g --;if _gg ._g ==0{_gg ._g =_gg ._b .ColorComponents ;_gg ._de ++;};if _gg ._de ==_gg ._b .Width {if _gg ._cd {_gg ._c .ConsumeRemainingBits ();};_gg ._de =0;_gg ._fd ++;};return uint32 (_ba ),nil ;};type SampleWriter interface{WriteSample (_eb uint32 )error ;
WriteSamples (_ff []uint32 )error ;};type Writer struct{_gf _d .ImageBase ;_baa *_a .Writer ;_bae ,_aac int ;_cda bool ;};func (_df *Reader )ReadSamples (samples []uint32 )(_ab error ){for _agd :=0;_agd < len (samples );_agd ++{samples [_agd ],_ab =_df .ReadSample ();
if _ab !=nil {return _ab ;};};return nil ;};func NewWriter (img _d .ImageBase )*Writer {return &Writer {_baa :_a .NewWriterMSB (img .Data ),_gf :img ,_aac :img .ColorComponents ,_cda :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_cgc *Writer )WriteSample (sample uint32 )error {if _ ,_bg :=_cgc ._baa .WriteBits (uint64 (sample ),_cgc ._gf .BitsPerComponent );_bg !=nil {return _bg ;};_cgc ._aac --;if _cgc ._aac ==0{_cgc ._aac =_cgc ._gf .ColorComponents ;_cgc ._bae ++;};
if _cgc ._bae ==_cgc ._gf .Width {if _cgc ._cda {_cgc ._baa .FinishByte ();};_cgc ._bae =0;};return nil ;};func (_ae *Writer )WriteSamples (samples []uint32 )error {for _ggg :=0;_ggg < len (samples );_ggg ++{if _ee :=_ae .WriteSample (samples [_ggg ]);
_ee !=nil {return _ee ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ggb []uint32 ;_bf :=bitsPerOutputSample ;var _ef uint32 ;var _bc uint32 ;_cg :=0;_gd :=0;_fe :=0;for _fe < len (data ){if _cg > 0{_aa :=_cg ;
if _bf < _aa {_aa =_bf ;};_ef =(_ef <<uint (_aa ))|(_bc >>uint (bitsPerInputSample -_aa ));_cg -=_aa ;if _cg > 0{_bc =_bc <<uint (_aa );}else {_bc =0;};_bf -=_aa ;if _bf ==0{_ggb =append (_ggb ,_ef );_bf =bitsPerOutputSample ;_ef =0;_gd ++;};}else {_fb :=data [_fe ];
_fe ++;_fdg :=bitsPerInputSample ;if _bf < _fdg {_fdg =_bf ;};_cg =bitsPerInputSample -_fdg ;_ef =(_ef <<uint (_fdg ))|(_fb >>uint (_cg ));if _fdg < bitsPerInputSample {_bc =_fb <<uint (_fdg );};_bf -=_fdg ;if _bf ==0{_ggb =append (_ggb ,_ef );_bf =bitsPerOutputSample ;
_ef =0;_gd ++;};};};for _cg >=bitsPerOutputSample {_cc :=_cg ;if _bf < _cc {_cc =_bf ;};_ef =(_ef <<uint (_cc ))|(_bc >>uint (bitsPerInputSample -_cc ));_cg -=_cc ;if _cg > 0{_bc =_bc <<uint (_cc );}else {_bc =0;};_bf -=_cc ;if _bf ==0{_ggb =append (_ggb ,_ef );
_bf =bitsPerOutputSample ;_ef =0;_gd ++;};};if _bf > 0&&_bf < bitsPerOutputSample {_ef <<=uint (_bf );_ggb =append (_ggb ,_ef );};return _ggb ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _cf []uint32 ;_gb :=bitsPerSample ;var _ggc uint32 ;
var _abb byte ;_gc :=0;_af :=0;_be :=0;for _be < len (data ){if _gc > 0{_ce :=_gc ;if _gb < _ce {_ce =_gb ;};_ggc =(_ggc <<uint (_ce ))|uint32 (_abb >>uint (8-_ce ));_gc -=_ce ;if _gc > 0{_abb =_abb <<uint (_ce );}else {_abb =0;};_gb -=_ce ;if _gb ==0{_cf =append (_cf ,_ggc );
_gb =bitsPerSample ;_ggc =0;_af ++;};}else {_def :=data [_be ];_be ++;_ea :=8;if _gb < _ea {_ea =_gb ;};_gc =8-_ea ;_ggc =(_ggc <<uint (_ea ))|uint32 (_def >>uint (_gc ));if _ea < 8{_abb =_def <<uint (_ea );};_gb -=_ea ;if _gb ==0{_cf =append (_cf ,_ggc );
_gb =bitsPerSample ;_ggc =0;_af ++;};};};for _gc >=bitsPerSample {_dbe :=_gc ;if _gb < _dbe {_dbe =_gb ;};_ggc =(_ggc <<uint (_dbe ))|uint32 (_abb >>uint (8-_dbe ));_gc -=_dbe ;if _gc > 0{_abb =_abb <<uint (_dbe );}else {_abb =0;};_gb -=_dbe ;if _gb ==0{_cf =append (_cf ,_ggc );
_gb =bitsPerSample ;_ggc =0;_af ++;};};return _cf ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_db []uint32 )error ;};func NewReader (img _d .ImageBase )*Reader {return &Reader {_c :_a .NewReader (img .Data ),_b :img ,_g :img .ColorComponents ,_cd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_b _d .ImageBase ;_c *_a .Reader ;_de ,_fd ,_g int ;_cd bool ;};