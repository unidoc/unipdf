//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_c "github.com/unidoc/unipdf/v4/internal/bitwise";_ce "github.com/unidoc/unipdf/v4/internal/imageutil";_b "io";);type Writer struct{_fe _ce .ImageBase ;_dff *_c .Writer ;_ef ,_bc int ;_dbc bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gbb []uint32 ;
_bb :=bitsPerSample ;var _db uint32 ;var _fb byte ;_fg :=0;_dcb :=0;_af :=0;for _af < len (data ){if _fg > 0{_gg :=_fg ;if _bb < _gg {_gg =_bb ;};_db =(_db <<uint (_gg ))|uint32 (_fb >>uint (8-_gg ));_fg -=_gg ;if _fg > 0{_fb =_fb <<uint (_gg );}else {_fb =0;
};_bb -=_gg ;if _bb ==0{_gbb =append (_gbb ,_db );_bb =bitsPerSample ;_db =0;_dcb ++;};}else {_fc :=data [_af ];_af ++;_dd :=8;if _bb < _dd {_dd =_bb ;};_fg =8-_dd ;_db =(_db <<uint (_dd ))|uint32 (_fc >>uint (_fg ));if _dd < 8{_fb =_fc <<uint (_dd );};
_bb -=_dd ;if _bb ==0{_gbb =append (_gbb ,_db );_bb =bitsPerSample ;_db =0;_dcb ++;};};};for _fg >=bitsPerSample {_fa :=_fg ;if _bb < _fa {_fa =_bb ;};_db =(_db <<uint (_fa ))|uint32 (_fb >>uint (8-_fa ));_fg -=_fa ;if _fg > 0{_fb =_fb <<uint (_fa );}else {_fb =0;
};_bb -=_fa ;if _bb ==0{_gbb =append (_gbb ,_db );_bb =bitsPerSample ;_db =0;_dcb ++;};};return _gbb ;};func NewReader (img _ce .ImageBase )*Reader {return &Reader {_cc :_c .NewReader (img .Data ),_ceg :img ,_bd :img .ColorComponents ,_ae :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ba []uint32 ;_cg :=bitsPerOutputSample ;var _ga uint32 ;var _df uint32 ;_de :=0;_ee :=0;_ec :=0;for _ec < len (data ){if _de > 0{_gc :=_de ;if _cg < _gc {_gc =_cg ;
};_ga =(_ga <<uint (_gc ))|(_df >>uint (bitsPerInputSample -_gc ));_de -=_gc ;if _de > 0{_df =_df <<uint (_gc );}else {_df =0;};_cg -=_gc ;if _cg ==0{_ba =append (_ba ,_ga );_cg =bitsPerOutputSample ;_ga =0;_ee ++;};}else {_bad :=data [_ec ];_ec ++;_aa :=bitsPerInputSample ;
if _cg < _aa {_aa =_cg ;};_de =bitsPerInputSample -_aa ;_ga =(_ga <<uint (_aa ))|(_bad >>uint (_de ));if _aa < bitsPerInputSample {_df =_bad <<uint (_aa );};_cg -=_aa ;if _cg ==0{_ba =append (_ba ,_ga );_cg =bitsPerOutputSample ;_ga =0;_ee ++;};};};for _de >=bitsPerOutputSample {_fba :=_de ;
if _cg < _fba {_fba =_cg ;};_ga =(_ga <<uint (_fba ))|(_df >>uint (bitsPerInputSample -_fba ));_de -=_fba ;if _de > 0{_df =_df <<uint (_fba );}else {_df =0;};_cg -=_fba ;if _cg ==0{_ba =append (_ba ,_ga );_cg =bitsPerOutputSample ;_ga =0;_ee ++;};};if _cg > 0&&_cg < bitsPerOutputSample {_ga <<=uint (_cg );
_ba =append (_ba ,_ga );};return _ba ;};func NewWriter (img _ce .ImageBase )*Writer {return &Writer {_dff :_c .NewWriterMSB (img .Data ),_fe :img ,_bc :img .ColorComponents ,_dbc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_ceg _ce .ImageBase ;_cc *_c .Reader ;_g ,_e ,_bd int ;_ae bool ;};func (_dfg *Writer )WriteSamples (samples []uint32 )error {for _cb :=0;_cb < len (samples );_cb ++{if _eca :=_dfg .WriteSample (samples [_cb ]);_eca !=nil {return _eca ;
};};return nil ;};func (_fd *Writer )WriteSample (sample uint32 )error {if _ ,_fce :=_fd ._dff .WriteBits (uint64 (sample ),_fd ._fe .BitsPerComponent );_fce !=nil {return _fce ;};_fd ._bc --;if _fd ._bc ==0{_fd ._bc =_fd ._fe .ColorComponents ;_fd ._ef ++;
};if _fd ._ef ==_fd ._fe .Width {if _fd ._dbc {_fd ._dff .FinishByte ();};_fd ._ef =0;};return nil ;};func (_f *Reader )ReadSamples (samples []uint32 )(_gb error ){for _ab :=0;_ab < len (samples );_ab ++{samples [_ab ],_gb =_f .ReadSample ();if _gb !=nil {return _gb ;
};};return nil ;};type SampleWriter interface{WriteSample (_cca uint32 )error ;WriteSamples (_dde []uint32 )error ;};func (_dc *Reader )ReadSample ()(uint32 ,error ){if _dc ._e ==_dc ._ceg .Height {return 0,_b .EOF ;};_bf ,_bg :=_dc ._cc .ReadBits (byte (_dc ._ceg .BitsPerComponent ));
if _bg !=nil {return 0,_bg ;};_dc ._bd --;if _dc ._bd ==0{_dc ._bd =_dc ._ceg .ColorComponents ;_dc ._g ++;};if _dc ._g ==_dc ._ceg .Width {if _dc ._ae {_dc ._cc .ConsumeRemainingBits ();};_dc ._g =0;_dc ._e ++;};return uint32 (_bf ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_a []uint32 )error ;};