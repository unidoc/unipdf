//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_f "github.com/unidoc/unipdf/v3/common";_g "math";);func (_ead Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ead .X ,_ead .Y );};const _ef =1e9;func (_cg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_cg [0],_cg [1]=a ,b ;
_cg [3],_cg [4]=c ,d ;_cg [6],_cg [7]=tx ,ty ;_cg .clampRange ();};func (_eb Matrix )Inverse ()(Matrix ,bool ){_ae ,_eg :=_eb [0],_eb [1];_ddf ,_cge :=_eb [3],_eb [4];_df ,_dfe :=_eb [6],_eb [7];_dg :=_ae *_cge -_eg *_ddf ;if _g .Abs (_dg )< _fgg {return Matrix {},false ;
};_cag ,_ebf :=_cge /_dg ,-_eg /_dg ;_afc ,_ab :=-_ddf /_dg ,_ae /_dg ;_dfc :=-(_cag *_df +_afc *_dfe );_ff :=-(_ebf *_df +_ab *_dfe );return NewMatrix (_cag ,_ebf ,_afc ,_ab ,_dfc ,_ff ),true ;};func (_fe Matrix )Angle ()float64 {_caf :=_g .Atan2 (-_fe [1],_fe [0]);
if _caf < 0.0{_caf +=2*_g .Pi ;};return _caf /_g .Pi *180.0;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_gda Matrix )String ()string {_ce ,_d ,_ed ,_ca ,_caa ,_dd :=_gda [0],_gda [1],_gda [3],_gda [4],_gda [6],_gda [7];
return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ce ,_d ,_ed ,_ca ,_caa ,_dd );};
func (_dc *Matrix )Concat (b Matrix ){*_dc =Matrix {b [0]*_dc [0]+b [1]*_dc [3],b [0]*_dc [1]+b [1]*_dc [4],0,b [3]*_dc [0]+b [4]*_dc [3],b [3]*_dc [1]+b [4]*_dc [4],0,b [6]*_dc [0]+b [7]*_dc [3]+_dc [6],b [6]*_dc [1]+b [7]*_dc [4]+_dc [7],1};_dc .clampRange ();
};type Point struct{X float64 ;Y float64 ;};func (_c Matrix )Identity ()bool {return _c [0]==1&&_c [1]==0&&_c [2]==0&&_c [3]==0&&_c [4]==1&&_c [5]==0&&_c [6]==0&&_c [7]==0&&_c [8]==1;};func (_ga Matrix )ScalingFactorX ()float64 {return _g .Hypot (_ga [0],_ga [1])};
func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_cb *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bgd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cb .transformByMatrix (_bgd );};func (_caae Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_caae .X +t *b .X ,Y :(1-t )*_caae .Y +t *b .Y };
};func (_e Matrix )Round (precision float64 )Matrix {for _bb :=range _e {_e [_bb ]=_g .Round (_e [_bb ]/precision )*precision ;};return _e ;};func (_ag *Matrix )Clone ()Matrix {return NewMatrix (_ag [0],_ag [1],_ag [3],_ag [4],_ag [6],_ag [7])};const _bg =1e-6;
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ad Matrix )Transform (x ,y float64 )(float64 ,float64 ){_be :=x *_ad [0]+y *_ad [3]+_ad [6];
_gcc :=x *_ad [1]+y *_ad [4]+_ad [7];return _be ,_gcc ;};func (_edfa Point )Displace (delta Point )Point {return Point {_edfa .X +delta .X ,_edfa .Y +delta .Y }};func (_af Matrix )Translate (tx ,ty float64 )Matrix {return _af .Mult (TranslationMatrix (tx ,ty ))};
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_ge Matrix )Translation ()(float64 ,float64 ){return _ge [6],_ge [7]};const _ea =1e-10;func (_gc Matrix )Mult (b Matrix )Matrix {_gc .Concat (b );return _gc };type Matrix [9]float64 ;
const _fgg =1.0e-6;func (_edf *Matrix )Shear (x ,y float64 ){_edf .Concat (ShearMatrix (x ,y ))};func (_ada Matrix )ScalingFactorY ()float64 {return _g .Hypot (_ada [3],_ada [4])};func (_gb Point )Distance (b Point )float64 {return _g .Hypot (_gb .X -b .X ,_gb .Y -b .Y )};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func RotationMatrix (angle float64 )Matrix {_gd :=_g .Cos (angle );_aa :=_g .Sin (angle );return NewMatrix (_gd ,_aa ,-_aa ,_gd ,0,0);};func (_gccd *Point )Set (x ,y float64 ){_gccd .X ,_gccd .Y =x ,y };
func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ec :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ec .clampRange ();return _ec ;};func (_ece *Matrix )clampRange (){for _ged ,_fg :=range _ece {if _fg > _ef {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fg ,_ef );
_ece [_ged ]=_ef ;}else if _fg < -_ef {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fg ,-_ef );_ece [_ged ]=-_ef ;};};};func (_gdb Matrix )Rotate (theta float64 )Matrix {return _gdb .Mult (RotationMatrix (theta ))};
func (_aaa Matrix )Scale (xScale ,yScale float64 )Matrix {return _aaa .Mult (ScaleMatrix (xScale ,yScale ));};func (_ffd *Point )transformByMatrix (_egb Matrix ){_ffd .X ,_ffd .Y =_egb .Transform (_ffd .X ,_ffd .Y )};func (_ac Matrix )Singular ()bool {return _g .Abs (_ac [0]*_ac [4]-_ac [1]*_ac [3])< _ea };
func (_cc Matrix )Unrealistic ()bool {_ebe ,_dgd ,_fee ,_gab :=_g .Abs (_cc [0]),_g .Abs (_cc [1]),_g .Abs (_cc [3]),_g .Abs (_cc [4]);_bf :=_ebe > _bg &&_gab > _bg ;_fa :=_dgd > _bg &&_fee > _bg ;return !(_bf ||_fa );};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_bec Point )Rotate (theta float64 )Point {_bba :=_g .Hypot (_bec .X ,_bec .Y );_bfe :=_g .Atan2 (_bec .Y ,_bec .X );_dcf ,_bbg :=_g .Sincos (_bfe +theta /180.0*_g .Pi );return Point {_bba *_bbg ,_bba *_dcf };};