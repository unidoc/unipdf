//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_b "github.com/unidoc/unipdf/v4/common";_e "math";);func (_ebg Matrix )Inverse ()(Matrix ,bool ){_bfa ,_cb :=_ebg [0],_ebg [1];_cbb ,_eed :=_ebg [3],_ebg [4];_bcg ,_fb :=_ebg [6],_ebg [7];_dc :=_bfa *_eed -_cb *_cbb ;
if _e .Abs (_dc )< _gb {return Matrix {},false ;};_bg ,_ff :=_eed /_dc ,-_cb /_dc ;_fbe ,_ed :=-_cbb /_dc ,_bfa /_dc ;_dcb :=-(_bg *_bcg +_fbe *_fb );_eee :=-(_ff *_bcg +_ed *_fb );return NewMatrix (_bg ,_ff ,_fbe ,_ed ,_dcb ,_eee ),true ;};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};type Matrix [9]float64 ;const _bbf =1e9;func (_geg Matrix )Singular ()bool {return _e .Abs (_geg [0]*_geg [4]-_geg [1]*_geg [3])< _dee };func (_ca *Matrix )Shear (x ,y float64 ){_ca .Concat (ShearMatrix (x ,y ))};
func (_ged *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_eedg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ged .transformByMatrix (_eedg );};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};
const _gb =1.0e-6;func (_bd Matrix )ScalingFactorY ()float64 {return _e .Hypot (_bd [3],_bd [4])};func (_g Matrix )Scale (xScale ,yScale float64 )Matrix {return _g .Mult (ScaleMatrix (xScale ,yScale ))};func (_gd Matrix )Unrealistic ()bool {_bde ,_ced ,_eab ,_eeec :=_e .Abs (_gd [0]),_e .Abs (_gd [1]),_e .Abs (_gd [3]),_e .Abs (_gd [4]);
_cee :=_bde > _bdf &&_eeec > _bdf ;_fbc :=_ced > _bdf &&_eab > _bdf ;return !(_cee ||_fbc );};func (_eba Matrix )Mult (b Matrix )Matrix {_eba .Concat (b );return _eba };func RotationMatrix (angle float64 )Matrix {_da :=_e .Cos (angle );_ce :=_e .Sin (angle );
return NewMatrix (_da ,_ce ,-_ce ,_da ,0,0);};func (_ec Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ec .X +t *b .X ,Y :(1-t )*_ec .Y +t *b .Y };};func (_ae Matrix )Translation ()(float64 ,float64 ){return _ae [6],_ae [7]};func (_de Matrix )Rotate (theta float64 )Matrix {return _de .Mult (RotationMatrix (theta ))};
func (_df Matrix )Angle ()float64 {_ef :=_e .Atan2 (-_df [1],_df [0]);if _ef < 0.0{_ef +=2*_e .Pi ;};return _ef /_e .Pi *180.0;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_eb Matrix )Identity ()bool {return _eb [0]==1&&_eb [1]==0&&_eb [2]==0&&_eb [3]==0&&_eb [4]==1&&_eb [5]==0&&_eb [6]==0&&_eb [7]==0&&_eb [8]==1;
};func (_daf *Point )transformByMatrix (_bfb Matrix ){_daf .X ,_daf .Y =_bfb .Transform (_daf .X ,_daf .Y )};func (_gg *Matrix )clampRange (){for _ffb ,_ea :=range _gg {if _ea > _bbf {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ea ,_bbf );
_gg [_ffb ]=_bbf ;}else if _ea < -_bbf {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ea ,-_bbf );_gg [_ffb ]=-_bbf ;};};};func (_gbc Point )Distance (b Point )float64 {return _e .Hypot (_gbc .X -b .X ,_gbc .Y -b .Y )};
const _bdf =1e-6;func (_ge Matrix )Translate (tx ,ty float64 )Matrix {return _ge .Mult (TranslationMatrix (tx ,ty ))};func (_bcb *Point )Set (x ,y float64 ){_bcb .X ,_bcb .Y =x ,y };func (_ebae Point )Displace (delta Point )Point {return Point {_ebae .X +delta .X ,_ebae .Y +delta .Y }};
func (_ade Point )Rotate (theta float64 )Point {_db :=_e .Hypot (_ade .X ,_ade .Y );_cab :=_e .Atan2 (_ade .Y ,_ade .X );_fa ,_aeb :=_e .Sincos (_cab +theta /180.0*_e .Pi );return Point {_db *_aeb ,_db *_fa };};func (_cf Matrix )Transform (x ,y float64 )(float64 ,float64 ){_adb :=x *_cf [0]+y *_cf [3]+_cf [6];
_cd :=x *_cf [1]+y *_cf [4]+_cf [7];return _adb ,_cd ;};func (_dg Matrix )String ()string {_f ,_bb ,_dgg ,_bbb ,_ab ,_ad :=_dg [0],_dg [1],_dg [3],_dg [4],_dg [6],_dg [7];return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_f ,_bb ,_dgg ,_bbb ,_ab ,_ad );
};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ag :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ag .clampRange ();return _ag ;};const _dee =1e-10;func (_bc *Matrix )Concat (b Matrix ){*_bc =Matrix {b [0]*_bc [0]+b [1]*_bc [3],b [0]*_bc [1]+b [1]*_bc [4],0,b [3]*_bc [0]+b [4]*_bc [3],b [3]*_bc [1]+b [4]*_bc [4],0,b [6]*_bc [0]+b [7]*_bc [3]+_bc [6],b [6]*_bc [1]+b [7]*_bc [4]+_bc [7],1};
_bc .clampRange ();};func (_age Matrix )ScalingFactorX ()float64 {return _e .Hypot (_age [0],_age [1])};type Point struct{X float64 ;Y float64 ;};func (_af Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_af .X ,_af .Y );
};func (_eg *Matrix )Clone ()Matrix {return NewMatrix (_eg [0],_eg [1],_eg [3],_eg [4],_eg [6],_eg [7])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_bf Matrix )Round (precision float64 )Matrix {for _d :=range _bf {_bf [_d ]=_e .Round (_bf [_d ]/precision )*precision ;
};return _bf ;};func (_ee *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ee [0],_ee [1]=a ,b ;_ee [3],_ee [4]=c ,d ;_ee [6],_ee [7]=tx ,ty ;_ee .clampRange ();};