//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_c "github.com/unidoc/unipdf/v4/common";_f "math";);const _fca =1e9;func (_afc Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bf :=x *_afc [0]+y *_afc [3]+_afc [6];_cbf :=x *_afc [1]+y *_afc [4]+_afc [7];return _bf ,_cbf ;
};func (_fa Matrix )Singular ()bool {return _f .Abs (_fa [0]*_fa [4]-_fa [1]*_fa [3])< _ag };func (_gf *Matrix )Clone ()Matrix {return NewMatrix (_gf [0],_gf [1],_gf [3],_gf [4],_gf [6],_gf [7])};func RotationMatrix (angle float64 )Matrix {_aa :=_f .Cos (angle );
_cb :=_f .Sin (angle );return NewMatrix (_aa ,_cb ,-_cb ,_aa ,0,0);};func (_cee *Point )Set (x ,y float64 ){_cee .X ,_cee .Y =x ,y };func (_bec Matrix )Mult (b Matrix )Matrix {_bec .Concat (b );return _bec };func (_dgc Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_dgc .X +t *b .X ,Y :(1-t )*_dgc .Y +t *b .Y };
};const _abed =1.0e-6;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fd *Matrix )clampRange (){for _cac ,_cc :=range _fd {if _cc > _fca {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cc ,_fca );
_fd [_cac ]=_fca ;}else if _cc < -_fca {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cc ,-_fca );_fd [_cac ]=-_fca ;};};};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_ab Matrix )Angle ()float64 {_da :=_f .Atan2 (-_ab [1],_ab [0]);if _da < 0.0{_da +=2*_f .Pi ;};return _da /_f .Pi *180.0;};func (_dd *Matrix )Shear (x ,y float64 ){_dd .Concat (ShearMatrix (x ,y ))};func (_gda *Matrix )Concat (b Matrix ){*_gda =Matrix {b [0]*_gda [0]+b [1]*_gda [3],b [0]*_gda [1]+b [1]*_gda [4],0,b [3]*_gda [0]+b [4]*_gda [3],b [3]*_gda [1]+b [4]*_gda [4],0,b [6]*_gda [0]+b [7]*_gda [3]+_gda [6],b [6]*_gda [1]+b [7]*_gda [4]+_gda [7],1};
_gda .clampRange ();};func (_def Matrix )Unrealistic ()bool {_ef ,_ae ,_fae ,_ebb :=_f .Abs (_def [0]),_f .Abs (_def [1]),_f .Abs (_def [3]),_f .Abs (_def [4]);_ebc :=_ef > _fdg &&_ebb > _fdg ;_afe :=_ae > _fdg &&_fae > _fdg ;return !(_ebc ||_afe );};func (_dg Point )Distance (b Point )float64 {return _f .Hypot (_dg .X -b .X ,_dg .Y -b .Y )};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_gge Matrix )ScalingFactorY ()float64 {return _f .Hypot (_gge [3],_gge [4])};func (_afd Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_afd .X ,_afd .Y );
};func (_gdg Matrix )Rotate (theta float64 )Matrix {return _gdg .Mult (RotationMatrix (theta ))};type Matrix [9]float64 ;func (_gg Matrix )String ()string {_af ,_ba ,_eaa ,_gd ,_ca ,_ce :=_gg [0],_gg [1],_gg [3],_gg [4],_gg [6],_gg [7];return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_af ,_ba ,_eaa ,_gd ,_ca ,_ce );
};func (_db Matrix )Translation ()(float64 ,float64 ){return _db [6],_db [7]};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ea :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ea .clampRange ();return _ea ;};func (_ggea Point )Rotate (theta float64 )Point {_fff :=_f .Hypot (_ggea .X ,_ggea .Y );
_gdaf :=_f .Atan2 (_ggea .Y ,_ggea .X );_eab ,_gfb :=_f .Sincos (_gdaf +theta /180.0*_f .Pi );return Point {_fff *_gfb ,_fff *_eab };};func (_abg Matrix )Inverse ()(Matrix ,bool ){_de ,_faf :=_abg [0],_abg [1];_ed ,_cd :=_abg [3],_abg [4];_ee ,_ff :=_abg [6],_abg [7];
_abe :=_de *_cd -_faf *_ed ;if _f .Abs (_abe )< _abed {return Matrix {},false ;};_bg ,_fb :=_cd /_abe ,-_faf /_abe ;_eb ,_fg :=-_ed /_abe ,_de /_abe ;_edf :=-(_bg *_ee +_eb *_ff );_bb :=-(_fb *_ee +_fg *_ff );return NewMatrix (_bg ,_fb ,_eb ,_fg ,_edf ,_bb ),true ;
};func (_a Matrix )Round (precision float64 )Matrix {for _e :=range _a {_a [_e ]=_f .Round (_a [_e ]/precision )*precision ;};return _a ;};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
const _fdg =1e-6;func (_bc Point )Displace (delta Point )Point {return Point {_bc .X +delta .X ,_bc .Y +delta .Y }};func (_aff Matrix )ScalingFactorX ()float64 {return _f .Hypot (_aff [0],_aff [1])};func (_ced Matrix )Scale (xScale ,yScale float64 )Matrix {return _ced .Mult (ScaleMatrix (xScale ,yScale ));
};func (_g Matrix )Identity ()bool {return _g [0]==1&&_g [1]==0&&_g [2]==0&&_g [3]==0&&_g [4]==1&&_g [5]==0&&_g [6]==0&&_g [7]==0&&_g [8]==1;};func (_be *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_be [0],_be [1]=a ,b ;_be [3],_be [4]=c ,d ;_be [6],_be [7]=tx ,ty ;
_be .clampRange ();};func (_fc Matrix )Translate (tx ,ty float64 )Matrix {return _fc .Mult (TranslationMatrix (tx ,ty ))};const _ag =1e-10;func (_ede *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ggg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ede .transformByMatrix (_ggg );
};func (_aef *Point )transformByMatrix (_abf Matrix ){_aef .X ,_aef .Y =_abf .Transform (_aef .X ,_aef .Y )};type Point struct{X float64 ;Y float64 ;};