//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_dg "fmt";_e "github.com/unidoc/unipdf/v3/common";_f "math";);func (_gg *Matrix )Shear (x ,y float64 ){_gg .Concat (ShearMatrix (x ,y ))};const _dggd =1e-6;type Matrix [9]float64 ;func (_ea *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fba :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ea .transformByMatrix (_fba );};func (_bc Matrix )Translation ()(float64 ,float64 ){return _bc [6],_bc [7]};func (_dgg Matrix )Mult (b Matrix )Matrix {_dgg .Concat (b );return _dgg };func (_dd Point )Displace (delta Point )Point {return Point {_dd .X +delta .X ,_dd .Y +delta .Y }};func (_gga Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gga .X +t *b .X ,Y :(1-t )*_gga .Y +t *b .Y };};func (_ece *Point )Set (x ,y float64 ){_ece .X ,_ece .Y =x ,y };func RotationMatrix (angle float64 )Matrix {_a :=_f .Cos (angle );_gf :=_f .Sin (angle );return NewMatrix (_a ,_gf ,-_gf ,_a ,0,0);};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_dc Matrix )Identity ()bool {return _dc [0]==1&&_dc [1]==0&&_dc [2]==0&&_dc [3]==0&&_dc [4]==1&&_dc [5]==0&&_dc [6]==0&&_dc [7]==0&&_dc [8]==1;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_fd :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_fd .clampRange ();return _fd ;};const _gb =1e-10;func (_c *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_c [0],_c [1]=a ,b ;_c [3],_c [4]=c ,d ;_c [6],_c [7]=tx ,ty ;_c .clampRange ();};func (_bcf *Matrix )clampRange (){for _fdd ,_fb :=range _bcf {if _fb > _ffg {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fb ,_ffg );_bcf [_fdd ]=_ffg ;}else if _fb < -_ffg {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fb ,-_ffg );_bcf [_fdd ]=-_ffg ;};};};func (_ab Matrix )Rotate (theta float64 )Matrix {return _ab .Mult (RotationMatrix (theta ))};type Point struct{X float64 ;Y float64 ;};func (_cbdb *Point )transformByMatrix (_dcc Matrix ){_cbdb .X ,_cbdb .Y =_dcc .Transform (_cbdb .X ,_cbdb .Y );};func (_cb Matrix )Translate (tx ,ty float64 )Matrix {return _cb .Mult (TranslationMatrix (tx ,ty ))};func (_dgga Matrix )ScalingFactorX ()float64 {return _f .Hypot (_dgga [0],_dgga [1])};func (_fe Matrix )Scale (xScale ,yScale float64 )Matrix {return _fe .Mult (ScaleMatrix (xScale ,yScale ))};func (_ac Matrix )String ()string {_de ,_eb ,_eg ,_bd ,_ec ,_ff :=_ac [0],_ac [1],_ac [3],_ac [4],_ac [6],_ac [7];return _dg .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_de ,_eb ,_eg ,_bd ,_ec ,_ff );};func (_cc Matrix )Angle ()float64 {_ef :=_f .Atan2 (-_cc [1],_cc [0]);if _ef < 0.0{_ef +=2*_f .Pi ;};return _ef /_f .Pi *180.0;};const _ffg =1e9;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fed Matrix )Unrealistic ()bool {_ge ,_edf ,_geg ,_cf :=_f .Abs (_fed [0]),_f .Abs (_fed [1]),_f .Abs (_fed [3]),_f .Abs (_fed [4]);_cbd :=_ge > _dggd &&_cf > _dggd ;_gff :=_edf > _dggd &&_geg > _dggd ;return !(_cbd ||_gff );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ad *Matrix )Clone ()Matrix {return NewMatrix (_ad [0],_ad [1],_ad [3],_ad [4],_ad [6],_ad [7])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ce Point )Distance (b Point )float64 {return _f .Hypot (_ce .X -b .X ,_ce .Y -b .Y )};func (_cbe Matrix )Singular ()bool {return _f .Abs (_cbe [0]*_cbe [4]-_cbe [1]*_cbe [3])< _gb };func (_efe Matrix )Inverse ()(Matrix ,bool ){_fa ,_cbc :=_efe [0],_efe [1];_adf ,_ba :=_efe [3],_efe [4];_cbce ,_cbg :=_efe [6],_efe [7];_ege :=_fa *_ba -_cbc *_adf ;if _f .Abs (_ege )< _fg {return Matrix {},false ;};_bb ,_fdc :=_ba /_ege ,-_cbc /_ege ;_bcd ,_bac :=-_adf /_ege ,_fa /_ege ;_bcg :=-(_bb *_cbce +_bcd *_cbg );_abf :=-(_fdc *_cbce +_bac *_cbg );return NewMatrix (_bb ,_fdc ,_bcd ,_bac ,_bcg ,_abf ),true ;};func (_cd Point )Rotate (theta float64 )Point {_abfa :=_f .Hypot (_cd .X ,_cd .Y );_eca :=_f .Atan2 (_cd .Y ,_cd .X );_bdb ,_bbc :=_f .Sincos (_eca +theta /180.0*_f .Pi );return Point {_abfa *_bbc ,_abfa *_bdb };};func (_ed Matrix )Transform (x ,y float64 )(float64 ,float64 ){_aa :=x *_ed [0]+y *_ed [3]+_ed [6];_ee :=x *_ed [1]+y *_ed [4]+_ed [7];return _aa ,_ee ;};func (_ga *Matrix )Concat (b Matrix ){*_ga =Matrix {b [0]*_ga [0]+b [1]*_ga [3],b [0]*_ga [1]+b [1]*_ga [4],0,b [3]*_ga [0]+b [4]*_ga [3],b [3]*_ga [1]+b [4]*_ga [4],0,b [6]*_ga [0]+b [7]*_ga [3]+_ga [6],b [6]*_ga [1]+b [7]*_ga [4]+_ga [7],1};_ga .clampRange ();};const _fg =1.0e-6;func (_b Matrix )Round (precision float64 )Matrix {for _g :=range _b {_b [_g ]=_f .Round (_b [_g ]/precision )*precision ;};return _b ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_cg Point )String ()string {return _dg .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_cg .X ,_cg .Y );};func (_acc Matrix )ScalingFactorY ()float64 {return _f .Hypot (_acc [3],_acc [4])};