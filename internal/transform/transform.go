//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_c "github.com/unidoc/unipdf/v4/common";_g "math";);func (_bec *Matrix )Concat (b Matrix ){*_bec =Matrix {b [0]*_bec [0]+b [1]*_bec [3],b [0]*_bec [1]+b [1]*_bec [4],0,b [3]*_bec [0]+b [4]*_bec [3],b [3]*_bec [1]+b [4]*_bec [4],0,b [6]*_bec [0]+b [7]*_bec [3]+_bec [6],b [6]*_bec [1]+b [7]*_bec [4]+_bec [7],1};
_bec .clampRange ();};func (_ff Matrix )Rotate (theta float64 )Matrix {return _ff .Mult (RotationMatrix (theta ))};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_b Matrix )Round (precision float64 )Matrix {for _ad :=range _b {_b [_ad ]=_g .Round (_b [_ad ]/precision )*precision ;};return _b ;};const _af =1e-10;func (_gf Point )Rotate (theta float64 )Point {_eg :=_g .Hypot (_gf .X ,_gf .Y );_gfb :=_g .Atan2 (_gf .Y ,_gf .X );
_cbd ,_dcd :=_g .Sincos (_gfb +theta /180.0*_g .Pi );return Point {_eg *_dcd ,_eg *_cbd };};func (_ag Matrix )Inverse ()(Matrix ,bool ){_cb ,_afc :=_ag [0],_ag [1];_cag ,_cc :=_ag [3],_ag [4];_fge ,_fe :=_ag [6],_ag [7];_ec :=_cb *_cc -_afc *_cag ;if _g .Abs (_ec )< _cd {return Matrix {},false ;
};_fdb ,_ac :=_cc /_ec ,-_afc /_ec ;_aac ,_bf :=-_cag /_ec ,_cb /_ec ;_cf :=-(_fdb *_fge +_aac *_fe );_dg :=-(_ac *_fge +_bf *_fe );return NewMatrix (_fdb ,_ac ,_aac ,_bf ,_cf ,_dg ),true ;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func (_ca Matrix )Transform (x ,y float64 )(float64 ,float64 ){_gg :=x *_ca [0]+y *_ca [3]+_ca [6];_ada :=x *_ca [1]+y *_ca [4]+_ca [7];return _gg ,_ada ;};func (_fab Matrix )ScalingFactorX ()float64 {return _g .Hypot (_fab [0],_fab [1])};func (_d Matrix )String ()string {_gd ,_fd ,_dc ,_adg ,_e ,_ea :=_d [0],_d [1],_d [3],_d [4],_d [6],_d [7];
return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_gd ,_fd ,_dc ,_adg ,_e ,_ea );};
func (_cda *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bfd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cda .transformByMatrix (_bfd );};func (_be *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_be [0],_be [1]=a ,b ;_be [3],_be [4]=c ,d ;_be [6],_be [7]=tx ,ty ;
_be .clampRange ();};func (_aa Matrix )Translation ()(float64 ,float64 ){return _aa [6],_aa [7]};func (_gcf *Matrix )clampRange (){for _eb ,_fdbc :=range _gcf {if _fdbc > _acf {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fdbc ,_acf );
_gcf [_eb ]=_acf ;}else if _fdbc < -_acf {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fdbc ,-_acf );_gcf [_eb ]=-_acf ;};};};func (_ed Matrix )Translate (tx ,ty float64 )Matrix {return _ed .Mult (TranslationMatrix (tx ,ty ))};
func (_bb *Matrix )Clone ()Matrix {return NewMatrix (_bb [0],_bb [1],_bb [3],_bb [4],_bb [6],_bb [7])};func (_fg Matrix )Singular ()bool {return _g .Abs (_fg [0]*_fg [4]-_fg [1]*_fg [3])< _af };func (_ggb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ggb .X +t *b .X ,Y :(1-t )*_ggb .Y +t *b .Y };
};func (_ga Point )Distance (b Point )float64 {return _g .Hypot (_ga .X -b .X ,_ga .Y -b .Y )};func (_db Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_db .X ,_db .Y );};func (_ecg Matrix )Unrealistic ()bool {_ece ,_ba ,_agc ,_de :=_g .Abs (_ecg [0]),_g .Abs (_ecg [1]),_g .Abs (_ecg [3]),_g .Abs (_ecg [4]);
_bag :=_ece > _fac &&_de > _fac ;_edg :=_ba > _fac &&_agc > _fac ;return !(_bag ||_edg );};func (_bgb Matrix )ScalingFactorY ()float64 {return _g .Hypot (_bgb [3],_bgb [4])};func (_afb *Point )Set (x ,y float64 ){_afb .X ,_afb .Y =x ,y };func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};
func (_da Matrix )Scale (xScale ,yScale float64 )Matrix {return _da .Mult (ScaleMatrix (xScale ,yScale ))};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_fa :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_fa .clampRange ();return _fa ;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
const _cd =1.0e-6;func (_dab Matrix )Mult (b Matrix )Matrix {_dab .Concat (b );return _dab };func RotationMatrix (angle float64 )Matrix {_gc :=_g .Cos (angle );_bg :=_g .Sin (angle );return NewMatrix (_gc ,_bg ,-_bg ,_gc ,0,0);};type Point struct{X float64 ;
Y float64 ;};func (_fc *Matrix )Shear (x ,y float64 ){_fc .Concat (ShearMatrix (x ,y ))};type Matrix [9]float64 ;const _acf =1e9;func (_ge Matrix )Angle ()float64 {_eag :=_g .Atan2 (-_ge [1],_ge [0]);if _eag < 0.0{_eag +=2*_g .Pi ;};return _eag /_g .Pi *180.0;
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_fb Matrix )Identity ()bool {return _fb [0]==1&&_fb [1]==0&&_fb [2]==0&&_fb [3]==0&&_fb [4]==1&&_fb [5]==0&&_fb [6]==0&&_fb [7]==0&&_fb [8]==1;};const _fac =1e-6;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func (_bff Point )Displace (delta Point )Point {return Point {_bff .X +delta .X ,_bff .Y +delta .Y }};func (_dga *Point )transformByMatrix (_gcd Matrix ){_dga .X ,_dga .Y =_gcd .Transform (_dga .X ,_dga .Y )};