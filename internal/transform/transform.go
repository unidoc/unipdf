//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_a "github.com/unidoc/unipdf/v4/common";_d "math";);func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ee Matrix )Unrealistic ()bool {_cf ,_efb ,_cae ,_fb :=_d .Abs (_ee [0]),_d .Abs (_ee [1]),_d .Abs (_ee [3]),_d .Abs (_ee [4]);
_faa :=_cf > _dff &&_fb > _dff ;_ag :=_efb > _dff &&_cae > _dff ;return !(_faa ||_ag );};const _efe =1.0e-6;func (_cag Matrix )Translate (tx ,ty float64 )Matrix {return _cag .Mult (TranslationMatrix (tx ,ty ))};const _bca =1e9;func (_ce Matrix )Scale (xScale ,yScale float64 )Matrix {return _ce .Mult (ScaleMatrix (xScale ,yScale ))};
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_dfaa Point )Rotate (theta float64 )Point {_bef :=_d .Hypot (_dfaa .X ,_dfaa .Y );
_ff :=_d .Atan2 (_dfaa .Y ,_dfaa .X );_ecg ,_gf :=_d .Sincos (_ff +theta /180.0*_d .Pi );return Point {_bef *_gf ,_bef *_ecg };};func (_be Matrix )ScalingFactorX ()float64 {return _d .Hypot (_be [0],_be [1])};func (_da Matrix )Round (precision float64 )Matrix {for _b :=range _da {_da [_b ]=_d .Round (_da [_b ]/precision )*precision ;
};return _da ;};func (_bc Matrix )Inverse ()(Matrix ,bool ){_acc ,_gg :=_bc [0],_bc [1];_cd ,_bdc :=_bc [3],_bc [4];_ggg ,_gag :=_bc [6],_bc [7];_eaf :=_acc *_bdc -_gg *_cd ;if _d .Abs (_eaf )< _efe {return Matrix {},false ;};_caga ,_cdd :=_bdc /_eaf ,-_gg /_eaf ;
_gbd ,_af :=-_cd /_eaf ,_acc /_eaf ;_ef :=-(_caga *_ggg +_gbd *_gag );_bce :=-(_cdd *_ggg +_af *_gag );return NewMatrix (_caga ,_cdd ,_gbd ,_af ,_ef ,_bce ),true ;};func (_eag Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_eag .X ,_eag .Y );
};const _dff =1e-6;const _gc =1e-10;type Point struct{X float64 ;Y float64 ;};func RotationMatrix (angle float64 )Matrix {_df :=_d .Cos (angle );_c :=_d .Sin (angle );return NewMatrix (_df ,_c ,-_c ,_df ,0,0);};func (_cb Matrix )String ()string {_ga ,_fd ,_dfa ,_bd ,_fg ,_fc :=_cb [0],_cb [1],_cb [3],_cb [4],_cb [6],_cb [7];
return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ga ,_fd ,_dfa ,_bd ,_fg ,_fc );
};func (_fdf Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_fdf .X +t *b .X ,Y :(1-t )*_fdf .Y +t *b .Y };};func (_fe Matrix )Angle ()float64 {_bg :=_d .Atan2 (-_fe [1],_fe [0]);if _bg < 0.0{_bg +=2*_d .Pi ;};return _bg /_d .Pi *180.0;
};func (_eg Matrix )Singular ()bool {return _d .Abs (_eg [0]*_eg [4]-_eg [1]*_eg [3])< _gc };func (_ba Matrix )Mult (b Matrix )Matrix {_ba .Concat (b );return _ba };func (_ge Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ac :=x *_ge [0]+y *_ge [3]+_ge [6];
_dd :=x *_ge [1]+y *_ge [4]+_ge [7];return _ac ,_dd ;};func (_ec Matrix )Identity ()bool {return _ec [0]==1&&_ec [1]==0&&_ec [2]==0&&_ec [3]==0&&_ec [4]==1&&_ec [5]==0&&_ec [6]==0&&_ec [7]==0&&_ec [8]==1;};func (_bgd *Point )transformByMatrix (_eea Matrix ){_bgd .X ,_bgd .Y =_eea .Transform (_bgd .X ,_bgd .Y )};
func (_daa *Matrix )Shear (x ,y float64 ){_daa .Concat (ShearMatrix (x ,y ))};func (_cc Matrix )ScalingFactorY ()float64 {return _d .Hypot (_cc [3],_cc [4])};func (_ca *Matrix )Concat (b Matrix ){*_ca =Matrix {b [0]*_ca [0]+b [1]*_ca [3],b [0]*_ca [1]+b [1]*_ca [4],0,b [3]*_ca [0]+b [4]*_ca [3],b [3]*_ca [1]+b [4]*_ca [4],0,b [6]*_ca [0]+b [7]*_ca [3]+_ca [6],b [6]*_ca [1]+b [7]*_ca [4]+_ca [7],1};
_ca .clampRange ();};func (_eeg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_gggg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_eeg .transformByMatrix (_gggg );};type Matrix [9]float64 ;func (_fa *Matrix )clampRange (){for _cdg ,_ecc :=range _fa {if _ecc > _bca {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ecc ,_bca );
_fa [_cdg ]=_bca ;}else if _ecc < -_bca {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ecc ,-_bca );_fa [_cdg ]=-_bca ;};};};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_g :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_g .clampRange ();return _g ;};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fda *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fda [0],_fda [1]=a ,b ;_fda [3],_fda [4]=c ,d ;_fda [6],_fda [7]=tx ,ty ;_fda .clampRange ();
};func (_fdb Matrix )Translation ()(float64 ,float64 ){return _fdb [6],_fdb [7]};func (_fcc Point )Distance (b Point )float64 {return _d .Hypot (_fcc .X -b .X ,_fcc .Y -b .Y )};func (_ab *Point )Set (x ,y float64 ){_ab .X ,_ab .Y =x ,y };func (_ea Matrix )Rotate (theta float64 )Matrix {return _ea .Mult (RotationMatrix (theta ))};
func (_gb *Matrix )Clone ()Matrix {return NewMatrix (_gb [0],_gb [1],_gb [3],_gb [4],_gb [6],_gb [7])};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_bb Point )Displace (delta Point )Point {return Point {_bb .X +delta .X ,_bb .Y +delta .Y }};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};