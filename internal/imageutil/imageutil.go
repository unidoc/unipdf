//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_ab "encoding/binary";_a "errors";_ec "fmt";_fb "github.com/unidoc/unipdf/v4/common";_eg "github.com/unidoc/unipdf/v4/internal/bitwise";_e "image";_g "image/color";_f "image/draw";_c "math";);func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_ec .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};var _ _e .Image =&Gray16 {};var _ Image =&Monochrome {};func (_abdc *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_abdc .copy ()}};func (_ffda *Gray2 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_ffda .Width ,Y :_ffda .Height }};
};func (_eacdgd *NRGBA64 )setNRGBA64 (_beec int ,_edeac _g .NRGBA64 ,_egcdb int ){_eacdgd .Data [_beec ]=uint8 (_edeac .R >>8);_eacdgd .Data [_beec +1]=uint8 (_edeac .R &0xff);_eacdgd .Data [_beec +2]=uint8 (_edeac .G >>8);_eacdgd .Data [_beec +3]=uint8 (_edeac .G &0xff);
_eacdgd .Data [_beec +4]=uint8 (_edeac .B >>8);_eacdgd .Data [_beec +5]=uint8 (_edeac .B &0xff);if _egcdb +1< len (_eacdgd .Alpha ){_eacdgd .Alpha [_egcdb ]=uint8 (_edeac .A >>8);_eacdgd .Alpha [_egcdb +1]=uint8 (_edeac .A &0xff);};};func (_bbdg *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_bbdg .Width ||y >=_bbdg .Height {return ;
};_fceg :=Gray4Model .Convert (c ).(_g .Gray );_bbdg .setGray (x ,y ,_fceg );};type Gray interface{GrayAt (_bfbg ,_fagb int )_g .Gray ;SetGray (_accb ,_eafc int ,_gbcea _g .Gray );};func (_adgd *NRGBA32 )Set (x ,y int ,c _g .Color ){_edgd :=y *_adgd .Width +x ;
_gdad :=3*_edgd ;if _gdad +2>=len (_adgd .Data ){return ;};_dggfd :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_adgd .setRGBA (_edgd ,_dggfd );};func (_fbfb *NRGBA64 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fbfb .Width ,Y :_fbfb .Height }};
};func (_dfde *NRGBA16 )Set (x ,y int ,c _g .Color ){_cgbe :=y *_dfde .BytesPerLine +x *3/2;if _cgbe +1>=len (_dfde .Data ){return ;};_acdc :=NRGBA16Model .Convert (c ).(_g .NRGBA );_dfde .setNRGBA (x ,y ,_cgbe ,_acdc );};func (_gegc *Monochrome )setBit (_aad ,_baeg int ){_gegc .Data [_aad +(_baeg >>3)]|=0x80>>uint (_baeg &7);
};func _aaa (_bgbg *Monochrome ,_caabg ,_fgd ,_afdd ,_bcac int ,_beef RasterOperator ,_ecba *Monochrome ,_eafe ,_ggggc int )error {if _bgbg ==nil {return _a .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _beef ==PixDst {return nil ;};switch _beef {case PixClr ,PixSet ,PixNotDst :_eefb (_bgbg ,_caabg ,_fgd ,_afdd ,_bcac ,_beef );return nil ;};if _ecba ==nil {_fb .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _a .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _acde :=_gaed (_bgbg ,_caabg ,_fgd ,_afdd ,_bcac ,_beef ,_ecba ,_eafe ,_ggggc );_acde !=nil {return _acde ;};return nil ;};func (_cec *Monochrome )getBitAt (_cfda ,_aacc int )bool {_gfgg :=_aacc *_cec .BytesPerLine +(_cfda >>3);
_eedc :=_cfda &0x07;_bcgf :=uint (7-_eedc );if _gfgg > len (_cec .Data )-1{return false ;};if (_cec .Data [_gfgg ]>>_bcgf )&0x01>=1{return true ;};return false ;};var _ Image =&NRGBA16 {};func _efg (_bb *Monochrome ,_ddb ,_ba int )(*Monochrome ,error ){if _bb ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ddb <=0||_ba <=0{return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _ddb ==_ba {if _ddb ==1{return _bb .copy (),nil ;};if _ddb ==2||_ddb ==4||_ddb ==8{_afd ,_fbb :=_fd (_bb ,_ddb );
if _fbb !=nil {return nil ,_fbb ;};return _afd ,nil ;};};_dfe :=_ddb *_bb .Width ;_egc :=_ba *_bb .Height ;_dda :=_adb (_dfe ,_egc );_dc :=_dda .BytesPerLine ;var (_dcc ,_eaa ,_ag ,_afdc ,_fda int ;_fab byte ;_da error ;);for _eaa =0;_eaa < _bb .Height ;
_eaa ++{_dcc =_ba *_eaa *_dc ;for _ag =0;_ag < _bb .Width ;_ag ++{if _cd :=_bb .getBitAt (_ag ,_eaa );_cd {_fda =_ddb *_ag ;for _afdc =0;_afdc < _ddb ;_afdc ++{_dda .setIndexedBit (_dcc *8+_fda +_afdc );};};};for _afdc =1;_afdc < _ba ;_afdc ++{_ebd :=_dcc +_afdc *_dc ;
for _ee :=0;_ee < _dc ;_ee ++{if _fab ,_da =_dda .getByte (_dcc +_ee );_da !=nil {return nil ,_da ;};if _da =_dda .setByte (_ebd +_ee ,_fab );_da !=nil {return nil ,_da ;};};};};return _dda ,nil ;};func (_eaeb *Gray16 )GrayAt (x ,y int )_g .Gray {_fecc ,_ :=_eaeb .ColorAt (x ,y );
return _g .Gray {Y :uint8 (_fecc .(_g .Gray16 ).Y >>8)};};func (_edd *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_aedd :=(y *_edd .Width +x )*2;_efcb :=_aedd *3;if _efcb +5>=len (_edd .Data ){return ;};_edd .setNRGBA64 (_efcb ,c ,_aedd );};func _bg (_ebf *Monochrome ,_ggg ...int )(_ega *Monochrome ,_fce error ){if _ebf ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_ggg )==0{return nil ,_a .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_ga :=_bbd ();_ega =_ebf ;for _ ,_bfg :=range _ggg {if _bfg <=0{break ;};_ega ,_fce =_ece (_ega ,_bfg ,_ga );if _fce !=nil {return nil ,_fce ;};};return _ega ,nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_gafe :=y *bytesPerLine +x ;
if _gafe >=len (data ){return _g .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bfd :=data [_gafe ];if len (decode )==2{_bfd =uint8 (uint32 (LinearInterpolate (float64 (_bfd ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_bfd },nil ;};func (_egcg *Gray8 )Base ()*ImageBase {return &_egcg .ImageBase };var _ Gray =&Monochrome {};
func _bdc (_bdbf _g .Gray )_g .Gray {_fegd :=_bdbf .Y >>6;_fegd |=_fegd <<2;_bdbf .Y =_fegd |_fegd <<4;return _bdbf ;};func (_gbee *ImageBase )setEightFullBytes (_cebb int ,_daee uint64 )error {if _cebb +7> len (_gbee .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gbee .Data [_cebb ]=byte ((_daee &0xff00000000000000)>>56);_gbee .Data [_cebb +1]=byte ((_daee &0xff000000000000)>>48);_gbee .Data [_cebb +2]=byte ((_daee &0xff0000000000)>>40);_gbee .Data [_cebb +3]=byte ((_daee &0xff00000000)>>32);_gbee .Data [_cebb +4]=byte ((_daee &0xff000000)>>24);
_gbee .Data [_cebb +5]=byte ((_daee &0xff0000)>>16);_gbee .Data [_cebb +6]=byte ((_daee &0xff00)>>8);_gbee .Data [_cebb +7]=byte (_daee &0xff);return nil ;};func _efff (_dccg ,_cedg Gray ,_ecb _e .Rectangle ){for _ggcgd :=0;_ggcgd < _ecb .Max .X ;_ggcgd ++{for _gceeg :=0;
_gceeg < _ecb .Max .Y ;_gceeg ++{_cedg .SetGray (_ggcgd ,_gceeg ,_dccg .GrayAt (_ggcgd ,_gceeg ));};};};func (_afb *Monochrome )Histogram ()(_gggc [256]int ){for _ ,_ccba :=range _afb .Data {_gggc [0xff]+=int (_gddg [_afb .Data [_ccba ]]);};return _gggc ;
};func (_fde *Monochrome )Set (x ,y int ,c _g .Color ){_egde :=y *_fde .BytesPerLine +x >>3;if _egde > len (_fde .Data )-1{return ;};_ggcg :=_fde .ColorModel ().Convert (c ).(_g .Gray );_fde .setGray (x ,_ggcg ,_egde );};func _gcea (_fdd ,_fcd *Monochrome ,_fg []byte ,_abb int )(_ggf error ){var (_cfe ,_cad ,_edcc ,_abbc ,_aeb ,_gae ,_fca ,_eea int ;
_fe ,_ebb ,_bdd ,_cfee uint32 ;_acc ,_cbe byte ;_eag uint16 ;);_daf :=make ([]byte ,4);_fee :=make ([]byte ,4);for _edcc =0;_edcc < _fdd .Height -1;_edcc ,_abbc =_edcc +2,_abbc +1{_cfe =_edcc *_fdd .BytesPerLine ;_cad =_abbc *_fcd .BytesPerLine ;for _aeb ,_gae =0,0;
_aeb < _abb ;_aeb ,_gae =_aeb +4,_gae +1{for _fca =0;_fca < 4;_fca ++{_eea =_cfe +_aeb +_fca ;if _eea <=len (_fdd .Data )-1&&_eea < _cfe +_fdd .BytesPerLine {_daf [_fca ]=_fdd .Data [_eea ];}else {_daf [_fca ]=0x00;};_eea =_cfe +_fdd .BytesPerLine +_aeb +_fca ;
if _eea <=len (_fdd .Data )-1&&_eea < _cfe +(2*_fdd .BytesPerLine ){_fee [_fca ]=_fdd .Data [_eea ];}else {_fee [_fca ]=0x00;};};_fe =_ab .BigEndian .Uint32 (_daf );_ebb =_ab .BigEndian .Uint32 (_fee );_bdd =_fe &_ebb ;_bdd |=_bdd <<1;_cfee =_fe |_ebb ;
_cfee &=_cfee <<1;_ebb =_bdd |_cfee ;_ebb &=0xaaaaaaaa;_fe =_ebb |(_ebb <<7);_acc =byte (_fe >>24);_cbe =byte ((_fe >>8)&0xff);_eea =_cad +_gae ;if _eea +1==len (_fcd .Data )-1||_eea +1>=_cad +_fcd .BytesPerLine {if _ggf =_fcd .setByte (_eea ,_fg [_acc ]);
_ggf !=nil {return _ec .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_eea );};}else {_eag =(uint16 (_fg [_acc ])<<8)|uint16 (_fg [_cbe ]);if _ggf =_fcd .setTwoBytes (_eea ,_eag );_ggf !=nil {return _ec .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eea );
};_gae ++;};};};return nil ;};func (_fbcg *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_fbcg .BytesPerLine ,_fbcg .Data ,_fbcg .Decode );};func (_bfgb *Gray16 )SetGray (x ,y int ,g _g .Gray ){_edee :=(y *_bfgb .BytesPerLine /2+x )*2;
if _edee +1>=len (_bfgb .Data ){return ;};_bfgb .Data [_edee ]=g .Y ;_bfgb .Data [_edee +1]=g .Y ;};var (MonochromeConverter =ConverterFunc (_cfa );Gray2Converter =ConverterFunc (_egf );Gray4Converter =ConverterFunc (_gcdf );GrayConverter =ConverterFunc (_bgbb );
Gray16Converter =ConverterFunc (_gccd );NRGBA16Converter =ConverterFunc (_aega );NRGBAConverter =ConverterFunc (_afdb );NRGBA64Converter =ConverterFunc (_cdda );RGBAConverter =ConverterFunc (_feecf );CMYKConverter =ConverterFunc (_egac ););func (_gdc *Gray8 )At (x ,y int )_g .Color {_dgca ,_ :=_gdc .ColorAt (x ,y );
return _dgca };func (_bfcf *NRGBA16 )At (x ,y int )_g .Color {_aged ,_ :=_bfcf .ColorAt (x ,y );return _aged };func (_gca *CMYK32 )Base ()*ImageBase {return &_gca .ImageBase };func (_cfbf *Gray4 )setGray (_gaef int ,_aeea int ,_afbb _g .Gray ){_cgdb :=_aeea *_cfbf .BytesPerLine ;
_dga :=_cgdb +(_gaef >>1);if _dga >=len (_cfbf .Data ){return ;};_eeec :=_afbb .Y >>4;_cfbf .Data [_dga ]=(_cfbf .Data [_dga ]&(^(0xf0>>uint (4*(_gaef &1)))))|(_eeec <<uint (4-4*(_gaef &1)));};type CMYK interface{CMYKAt (_eab ,_aae int )_g .CMYK ;SetCMYK (_dfff ,_fcaa int ,_cbac _g .CMYK );
};func (_ddeb *NRGBA64 )Set (x ,y int ,c _g .Color ){_cdcef :=(y *_ddeb .Width +x )*2;_cgbec :=_cdcef *3;if _cgbec +5>=len (_ddeb .Data ){return ;};_eaec :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );_ddeb .setNRGBA64 (_cgbec ,_eaec ,_cdcef );};func _fefb (_ggfdg *_e .NYCbCrA ,_gaea NRGBA ,_gafcd _e .Rectangle ){for _cada :=0;
_cada < _gafcd .Max .X ;_cada ++{for _bfaf :=0;_bfaf < _gafcd .Max .Y ;_bfaf ++{_fbff :=_ggfdg .NYCbCrAAt (_cada ,_bfaf );_gaea .SetNRGBA (_cada ,_bfaf ,_bfc (_fbff ));};};};func _dbd (_ddbg _g .NRGBA )_g .Gray {var _eaae _g .NRGBA ;if _ddbg ==_eaae {return _g .Gray {Y :0xff};
};_ebfg ,_edaf ,_fdb ,_ :=_ddbg .RGBA ();_cce :=(19595*_ebfg +38470*_edaf +7471*_fdb +1<<15)>>24;return _g .Gray {Y :uint8 (_cce )};};func _cdda (_aeffe _e .Image )(Image ,error ){if _bcbac ,_bdead :=_aeffe .(*NRGBA64 );_bdead {return _bcbac .Copy (),nil ;
};_ceeb ,_efbfg ,_bcda :=_ccbc (_aeffe ,2);_fdee ,_fffag :=NewImage (_ceeb .Max .X ,_ceeb .Max .Y ,16,3,nil ,_bcda ,nil );if _fffag !=nil {return nil ,_fffag ;};_ccca (_aeffe ,_fdee ,_ceeb );if len (_bcda )!=0&&!_efbfg {if _gfec :=_dacf (_bcda ,_fdee );
_gfec !=nil {return nil ,_gfec ;};};return _fdee ,nil ;};func _feecf (_cffee _e .Image )(Image ,error ){if _cede ,_fcgg :=_cffee .(*RGBA32 );_fcgg {return _cede .Copy (),nil ;};_gegb ,_bdgf ,_cgadd :=_ccbc (_cffee ,1);_fdgfa :=&RGBA32 {ImageBase :NewImageBase (_gegb .Max .X ,_gegb .Max .Y ,8,3,nil ,_cgadd ,nil )};
_abab (_cffee ,_fdgfa ,_gegb );if len (_cgadd )!=0&&!_bdgf {if _geeb :=_dacf (_cgadd ,_fdgfa );_geeb !=nil {return nil ,_geeb ;};};return _fdgfa ,nil ;};func (_gacdc *NRGBA32 )Validate ()error {if len (_gacdc .Data )!=3*_gacdc .Width *_gacdc .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _cfc (_gfff nrgba64 ,_bddc NRGBA ,_fbec _e .Rectangle ){for _fgfe :=0;_fgfe < _fbec .Max .X ;_fgfe ++{for _eabgd :=0;_eabgd < _fbec .Max .Y ;_eabgd ++{_gbba :=_gfff .NRGBA64At (_fgfe ,_eabgd );_bddc .SetNRGBA (_fgfe ,_eabgd ,_fdfg (_gbba ));
};};};func _gbff (_fdfc _e .Image ,_addbg Image ,_cddd _e .Rectangle ){if _gdfe ,_ebdgg :=_fdfc .(SMasker );_ebdgg &&_gdfe .HasAlpha (){_addbg .(SMasker ).MakeAlpha ();};switch _cfff :=_fdfc .(type ){case Gray :_efea (_cfff ,_addbg .(NRGBA ),_cddd );case NRGBA :_cfbd (_cfff ,_addbg .(NRGBA ),_cddd );
case *_e .NYCbCrA :_fefb (_cfff ,_addbg .(NRGBA ),_cddd );case CMYK :_bfcg (_cfff ,_addbg .(NRGBA ),_cddd );case RGBA :_egdc (_cfff ,_addbg .(NRGBA ),_cddd );case nrgba64 :_cfc (_cfff ,_addbg .(NRGBA ),_cddd );default:_dfef (_fdfc ,_addbg ,_cddd );};};
func _facd (_adfc uint )uint {var _cbdg uint ;for _adfc !=0{_adfc >>=1;_cbdg ++;};return _cbdg -1;};var _ _e .Image =&NRGBA64 {};func (_gbe *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_gbe .BytesPerLine ,_gbe .Data ,_gbe .Decode );
};func (_defcg *NRGBA16 )Base ()*ImageBase {return &_defcg .ImageBase };func (_agg *Gray8 )Histogram ()(_gebff [256]int ){for _fgaf :=0;_fgaf < len (_agg .Data );_fgaf ++{_gebff [_agg .Data [_fgaf ]]++;};return _gebff ;};func _bbed (_ggdb *Monochrome ,_ded ,_dbgf int ,_gadd ,_gega int ,_eecg RasterOperator ){var (_agge bool ;
_baga bool ;_eacb int ;_bcgg int ;_ecbc int ;_gfaga int ;_bcbfc bool ;_baea byte ;);_dbgg :=8-(_ded &7);_dggf :=_egbc [_dbgg ];_ggce :=_ggdb .BytesPerLine *_dbgf +(_ded >>3);if _gadd < _dbgg {_agge =true ;_dggf &=_abbg [8-_dbgg +_gadd ];};if !_agge {_eacb =(_gadd -_dbgg )>>3;
if _eacb !=0{_baga =true ;_bcgg =_ggce +1;};};_ecbc =(_ded +_gadd )&7;if !(_agge ||_ecbc ==0){_bcbfc =true ;_baea =_abbg [_ecbc ];_gfaga =_ggce +1+_eacb ;};var _age ,_bfbgd int ;switch _eecg {case PixClr :for _age =0;_age < _gega ;_age ++{_ggdb .Data [_ggce ]=_feba (_ggdb .Data [_ggce ],0x0,_dggf );
_ggce +=_ggdb .BytesPerLine ;};if _baga {for _age =0;_age < _gega ;_age ++{for _bfbgd =0;_bfbgd < _eacb ;_bfbgd ++{_ggdb .Data [_bcgg +_bfbgd ]=0x0;};_bcgg +=_ggdb .BytesPerLine ;};};if _bcbfc {for _age =0;_age < _gega ;_age ++{_ggdb .Data [_gfaga ]=_feba (_ggdb .Data [_gfaga ],0x0,_baea );
_gfaga +=_ggdb .BytesPerLine ;};};case PixSet :for _age =0;_age < _gega ;_age ++{_ggdb .Data [_ggce ]=_feba (_ggdb .Data [_ggce ],0xff,_dggf );_ggce +=_ggdb .BytesPerLine ;};if _baga {for _age =0;_age < _gega ;_age ++{for _bfbgd =0;_bfbgd < _eacb ;_bfbgd ++{_ggdb .Data [_bcgg +_bfbgd ]=0xff;
};_bcgg +=_ggdb .BytesPerLine ;};};if _bcbfc {for _age =0;_age < _gega ;_age ++{_ggdb .Data [_gfaga ]=_feba (_ggdb .Data [_gfaga ],0xff,_baea );_gfaga +=_ggdb .BytesPerLine ;};};case PixNotDst :for _age =0;_age < _gega ;_age ++{_ggdb .Data [_ggce ]=_feba (_ggdb .Data [_ggce ],^_ggdb .Data [_ggce ],_dggf );
_ggce +=_ggdb .BytesPerLine ;};if _baga {for _age =0;_age < _gega ;_age ++{for _bfbgd =0;_bfbgd < _eacb ;_bfbgd ++{_ggdb .Data [_bcgg +_bfbgd ]=^(_ggdb .Data [_bcgg +_bfbgd ]);};_bcgg +=_ggdb .BytesPerLine ;};};if _bcbfc {for _age =0;_age < _gega ;_age ++{_ggdb .Data [_gfaga ]=_feba (_ggdb .Data [_gfaga ],^_ggdb .Data [_gfaga ],_baea );
_gfaga +=_ggdb .BytesPerLine ;};};};};func (_dbgc *CMYK32 )Validate ()error {if len (_dbgc .Data )!=4*_dbgc .Width *_dbgc .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gbcf *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_gbcf .copy ()}};func (_cdge *RGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func (_bddb *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_bddba :=y *_bddb .Width +x ;_gbeg :=3*_bddba ;
if _gbeg +2>=len (_bddb .Data ){return ;};_bddb .setRGBA (_bddba ,c );};func _eabb (_cdb _g .NRGBA )_g .CMYK {_caad ,_bdgb ,_cfbb ,_ :=_cdb .RGBA ();_ecde ,_fdgfe ,_dfgb ,_bddg :=_g .RGBToCMYK (uint8 (_caad >>8),uint8 (_bdgb >>8),uint8 (_cfbb >>8));return _g .CMYK {C :_ecde ,M :_fdgfe ,Y :_dfgb ,K :_bddg };
};func (_dge *ImageBase )GetAlpha ()[]byte {return _dge .Alpha };func (_agdg *Monochrome )SetGray (x ,y int ,g _g .Gray ){_gbfc :=y *_agdg .BytesPerLine +x >>3;if _gbfc > len (_agdg .Data )-1{return ;};g =_beg (g ,monochromeModel (_agdg .ModelThreshold ));
_agdg .setGray (x ,g ,_gbfc );};func _bfcg (_ddef CMYK ,_ggfb NRGBA ,_dccc _e .Rectangle ){for _gbfccg :=0;_gbfccg < _dccc .Max .X ;_gbfccg ++{for _fdbdg :=0;_fdbdg < _dccc .Max .Y ;_fdbdg ++{_gfbag :=_ddef .CMYKAt (_gbfccg ,_fdbdg );_ggfb .SetNRGBA (_gbfccg ,_fdbdg ,_gace (_gfbag ));
};};};func (_gdag *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_gdag .Width ||y >=_gdag .Height {return ;};g =_aab (g );_gdag .setGray (x ,y ,g );};var _ _e .Image =&Gray8 {};func _fdfg (_adbb _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_adbb .R >>8),G :uint8 (_adbb .G >>8),B :uint8 (_adbb .B >>8),A :uint8 (_adbb .A >>8)};
};func (_efccd *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_efccd .BytesPerLine ,_efccd .Data ,_efccd .Decode );};func _gcff (_cfb ,_aed *Monochrome ,_ggcc []byte ,_ebe int )(_gfab error ){var (_def ,_bfef ,_gac ,_afee ,_agbg ,_eae ,_cba ,_acd int ;
_gfae ,_aeg ,_dae ,_eafg uint32 ;_adde ,_dfa byte ;_cabc uint16 ;);_dff :=make ([]byte ,4);_bga :=make ([]byte ,4);for _gac =0;_gac < _cfb .Height -1;_gac ,_afee =_gac +2,_afee +1{_def =_gac *_cfb .BytesPerLine ;_bfef =_afee *_aed .BytesPerLine ;for _agbg ,_eae =0,0;
_agbg < _ebe ;_agbg ,_eae =_agbg +4,_eae +1{for _cba =0;_cba < 4;_cba ++{_acd =_def +_agbg +_cba ;if _acd <=len (_cfb .Data )-1&&_acd < _def +_cfb .BytesPerLine {_dff [_cba ]=_cfb .Data [_acd ];}else {_dff [_cba ]=0x00;};_acd =_def +_cfb .BytesPerLine +_agbg +_cba ;
if _acd <=len (_cfb .Data )-1&&_acd < _def +(2*_cfb .BytesPerLine ){_bga [_cba ]=_cfb .Data [_acd ];}else {_bga [_cba ]=0x00;};};_gfae =_ab .BigEndian .Uint32 (_dff );_aeg =_ab .BigEndian .Uint32 (_bga );_dae =_gfae &_aeg ;_dae |=_dae <<1;_eafg =_gfae |_aeg ;
_eafg &=_eafg <<1;_aeg =_dae &_eafg ;_aeg &=0xaaaaaaaa;_gfae =_aeg |(_aeg <<7);_adde =byte (_gfae >>24);_dfa =byte ((_gfae >>8)&0xff);_acd =_bfef +_eae ;if _acd +1==len (_aed .Data )-1||_acd +1>=_bfef +_aed .BytesPerLine {if _gfab =_aed .setByte (_acd ,_ggcc [_adde ]);
_gfab !=nil {return _ec .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_acd );};}else {_cabc =(uint16 (_ggcc [_adde ])<<8)|uint16 (_ggcc [_dfa ]);if _gfab =_aed .setTwoBytes (_acd ,_cabc );_gfab !=nil {return _ec .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_acd );
};_eae ++;};};};return nil ;};type Image interface{_f .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_bdcc ,_gcg int )(_g .Color ,error );Validate ()error ;};func (_gece *ImageBase )HasAlpha ()bool {if _gece .Alpha ==nil {return false ;
};for _eeae :=range _gece .Alpha {if _gece .Alpha [_eeae ]!=0xff{return true ;};};return false ;};func _cbf (_dffg RGBA ,_ccb CMYK ,_cdce _e .Rectangle ){for _ceaa :=0;_ceaa < _cdce .Max .X ;_ceaa ++{for _bec :=0;_bec < _cdce .Max .Y ;_bec ++{_bddf :=_dffg .RGBAAt (_ceaa ,_bec );
_ccb .SetCMYK (_ceaa ,_bec ,_baec (_bddf ));};};};func (_aaea *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_aaea .copy ()}};func _ebgf (_eacd _g .Color )_g .Color {_dbb :=_g .GrayModel .Convert (_eacd ).(_g .Gray );return _aab (_dbb )};type NRGBA16 struct{ImageBase };
func init (){_ceda ()};var _ Image =&NRGBA32 {};func (_gcdd *Monochrome )clearBit (_fbgf ,_fcc int ){_gcdd .Data [_fbgf ]&=^(0x80>>uint (_fcc &7))};func _baec (_abdf _g .RGBA )_g .CMYK {_gff ,_adbf ,_agdd ,_bfgg :=_g .RGBToCMYK (_abdf .R ,_abdf .G ,_abdf .B );
return _g .CMYK {C :_gff ,M :_adbf ,Y :_agdd ,K :_bfgg };};func (_dcec *Monochrome )ResolveDecode ()error {if len (_dcec .Decode )!=2{return nil ;};if _dcec .Decode [0]==1&&_dcec .Decode [1]==0{if _bfga :=_dcec .InverseData ();_bfga !=nil {return _bfga ;
};_dcec .Decode =nil ;};return nil ;};func (_accd *ImageBase )MakeAlpha (){_accd .newAlpha ()};func (_gbc *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };func (_dbee *NRGBA64 )Validate ()error {if len (_dbee .Data )!=3*2*_dbee .Width *_dbee .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _degc (_gdgf *Monochrome ,_egagd ,_ecce ,_deab ,_beca int ,_agbf RasterOperator ,_dfgba *Monochrome ,_dfdc ,_bcfe int )error {var (_cbcc bool ;_afca bool ;_ebac int ;_fcfd int ;_ecec int ;_dac bool ;_eceae byte ;_bbcb int ;_ebgfa int ;
_gceg int ;_fbda ,_dbfc int ;);_cbcd :=8-(_egagd &7);_caed :=_egbc [_cbcd ];_bbgc :=_gdgf .BytesPerLine *_ecce +(_egagd >>3);_cagb :=_dfgba .BytesPerLine *_bcfe +(_dfdc >>3);if _deab < _cbcd {_cbcc =true ;_caed &=_abbg [8-_cbcd +_deab ];};if !_cbcc {_ebac =(_deab -_cbcd )>>3;
if _ebac > 0{_afca =true ;_fcfd =_bbgc +1;_ecec =_cagb +1;};};_bbcb =(_egagd +_deab )&7;if !(_cbcc ||_bbcb ==0){_dac =true ;_eceae =_abbg [_bbcb ];_ebgfa =_bbgc +1+_ebac ;_gceg =_cagb +1+_ebac ;};switch _agbf {case PixSrc :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],_dfgba .Data [_cagb ],_caed );
_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]=_dfgba .Data [_ecec +_dbfc ];};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;
};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],_dfgba .Data [_gceg ],_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixNotSrc :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],^_dfgba .Data [_cagb ],_caed );
_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]=^_dfgba .Data [_ecec +_dbfc ];};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;
};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],^_dfgba .Data [_gceg ],_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixSrcOrDst :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],_dfgba .Data [_cagb ]|_gdgf .Data [_bbgc ],_caed );
_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]|=_dfgba .Data [_ecec +_dbfc ];};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;
};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],_dfgba .Data [_gceg ]|_gdgf .Data [_ebgfa ],_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixSrcAndDst :for _fbda =0;_fbda < _beca ;
_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],_dfgba .Data [_cagb ]&_gdgf .Data [_bbgc ],_caed );_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]&=_dfgba .Data [_ecec +_dbfc ];
};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],_dfgba .Data [_gceg ]&_gdgf .Data [_ebgfa ],_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;
};};case PixSrcXorDst :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],_dfgba .Data [_cagb ]^_gdgf .Data [_bbgc ],_caed );_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;
_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]^=_dfgba .Data [_ecec +_dbfc ];};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],_dfgba .Data [_gceg ]^_gdgf .Data [_ebgfa ],_eceae );
_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixNotSrcOrDst :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],^(_dfgba .Data [_cagb ])|_gdgf .Data [_bbgc ],_caed );_bbgc +=_gdgf .BytesPerLine ;
_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]|=^(_dfgba .Data [_ecec +_dbfc ]);};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;};};if _dac {for _fbda =0;
_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],^(_dfgba .Data [_gceg ])|_gdgf .Data [_ebgfa ],_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixNotSrcAndDst :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],^(_dfgba .Data [_cagb ])&_gdgf .Data [_bbgc ],_caed );
_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]&=^_dfgba .Data [_ecec +_dbfc ];};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;
};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],^(_dfgba .Data [_gceg ])&_gdgf .Data [_ebgfa ],_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixSrcOrNotDst :for _fbda =0;
_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],_dfgba .Data [_cagb ]|^(_gdgf .Data [_bbgc ]),_caed );_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;
_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]=_dfgba .Data [_ecec +_dbfc ]|^(_gdgf .Data [_fcfd +_dbfc ]);};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],_dfgba .Data [_gceg ]|^(_gdgf .Data [_ebgfa ]),_eceae );
_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixSrcAndNotDst :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],_dfgba .Data [_cagb ]&^(_gdgf .Data [_bbgc ]),_caed );_bbgc +=_gdgf .BytesPerLine ;
_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]=_dfgba .Data [_ecec +_dbfc ]&^(_gdgf .Data [_fcfd +_dbfc ]);};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;
};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],_dfgba .Data [_gceg ]&^(_gdgf .Data [_ebgfa ]),_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixNotPixSrcOrDst :for _fbda =0;
_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],^(_dfgba .Data [_cagb ]|_gdgf .Data [_bbgc ]),_caed );_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;
_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]=^(_dfgba .Data [_ecec +_dbfc ]|_gdgf .Data [_fcfd +_dbfc ]);};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],^(_dfgba .Data [_gceg ]|_gdgf .Data [_ebgfa ]),_eceae );
_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixNotPixSrcAndDst :for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],^(_dfgba .Data [_cagb ]&_gdgf .Data [_bbgc ]),_caed );_bbgc +=_gdgf .BytesPerLine ;
_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]=^(_dfgba .Data [_ecec +_dbfc ]&_gdgf .Data [_fcfd +_dbfc ]);};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;
};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],^(_dfgba .Data [_gceg ]&_gdgf .Data [_ebgfa ]),_eceae );_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};case PixNotPixSrcXorDst :for _fbda =0;
_fbda < _beca ;_fbda ++{_gdgf .Data [_bbgc ]=_feba (_gdgf .Data [_bbgc ],^(_dfgba .Data [_cagb ]^_gdgf .Data [_bbgc ]),_caed );_bbgc +=_gdgf .BytesPerLine ;_cagb +=_dfgba .BytesPerLine ;};if _afca {for _fbda =0;_fbda < _beca ;_fbda ++{for _dbfc =0;_dbfc < _ebac ;
_dbfc ++{_gdgf .Data [_fcfd +_dbfc ]=^(_dfgba .Data [_ecec +_dbfc ]^_gdgf .Data [_fcfd +_dbfc ]);};_fcfd +=_gdgf .BytesPerLine ;_ecec +=_dfgba .BytesPerLine ;};};if _dac {for _fbda =0;_fbda < _beca ;_fbda ++{_gdgf .Data [_ebgfa ]=_feba (_gdgf .Data [_ebgfa ],^(_dfgba .Data [_gceg ]^_gdgf .Data [_ebgfa ]),_eceae );
_ebgfa +=_gdgf .BytesPerLine ;_gceg +=_dfgba .BytesPerLine ;};};default:_fb .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_agbf );return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _egac (_cgd _e .Image )(Image ,error ){if _edb ,_baa :=_cgd .(*CMYK32 );_baa {return _edb .Copy (),nil ;};_geaaa :=_cgd .Bounds ();_cga ,_ace :=NewImage (_geaaa .Max .X ,_geaaa .Max .Y ,8,4,nil ,nil ,nil );if _ace !=nil {return nil ,_ace ;
};switch _fecb :=_cgd .(type ){case CMYK :_deed (_fecb ,_cga .(CMYK ),_geaaa );case Gray :_bggc (_fecb ,_cga .(CMYK ),_geaaa );case NRGBA :_ffb (_fecb ,_cga .(CMYK ),_geaaa );case RGBA :_cbf (_fecb ,_cga .(CMYK ),_geaaa );default:_dfef (_cgd ,_cga ,_geaaa );
};return _cga ,nil ;};func (_caag *Gray16 )At (x ,y int )_g .Color {_cdf ,_ :=_caag .ColorAt (x ,y );return _cdf };func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_ege :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_ege .Data =make ([]byte ,height *_ege .BytesPerLine );};return _ege ;};func _eef (_dfc _g .Color )_g .Color {_dbaa :=_g .GrayModel .Convert (_dfc ).(_g .Gray );return _bdc (_dbaa )};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;
MakeAlpha ();};var _ Image =&Gray16 {};func _afdb (_bdbd _e .Image )(Image ,error ){if _efeff ,_bafd :=_bdbd .(*NRGBA32 );_bafd {return _efeff .Copy (),nil ;};_gfce ,_dgga ,_agcf :=_ccbc (_bdbd ,1);_gbfcc ,_cbecd :=NewImage (_gfce .Max .X ,_gfce .Max .Y ,8,3,nil ,_agcf ,nil );
if _cbecd !=nil {return nil ,_cbecd ;};_gbff (_bdbd ,_gbfcc ,_gfce );if len (_agcf )!=0&&!_dgga {if _gdbb :=_dacf (_agcf ,_gbfcc );_gdbb !=nil {return nil ,_gdbb ;};};return _gbfcc ,nil ;};func (_febge *RGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtRGBA32 (x ,y ,_febge .Width ,_febge .Data ,_febge .Alpha ,_febge .Decode );
};func _dfefg (_beeae nrgba64 ,_dggfb RGBA ,_dbag _e .Rectangle ){for _cggd :=0;_cggd < _dbag .Max .X ;_cggd ++{for _cgfc :=0;_cgfc < _dbag .Max .Y ;_cgfc ++{_dfdf :=_beeae .NRGBA64At (_cggd ,_cgfc );_dggfb .SetRGBA (_cggd ,_cgfc ,_fbg (_dfdf ));};};};
func (_bgcg *Monochrome )Validate ()error {if len (_bgcg .Data )!=_bgcg .Height *_bgcg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_efbd *Monochrome )setGrayBit (_ccf ,_gccac int ){_efbd .Data [_ccf ]|=0x80>>uint (_gccac &7)};func _dfddg (_beccf _e .Image ,_gaad uint8 )*_e .Gray {_baaa :=_beccf .Bounds ();
_fffe :=_e .NewGray (_baaa );var (_agaf _g .Color ;_abdcd _g .Gray ;);for _aaaa :=0;_aaaa < _baaa .Max .X ;_aaaa ++{for _agef :=0;_agef < _baaa .Max .Y ;_agef ++{_agaf =_beccf .At (_aaaa ,_agef );_fffe .Set (_aaaa ,_agef ,_agaf );_abdcd =_fffe .GrayAt (_aaaa ,_agef );
_fffe .SetGray (_aaaa ,_agef ,_g .Gray {Y :_dacg (_abdcd .Y ,_gaad )});};};return _fffe ;};type Gray4 struct{ImageBase };func _dfef (_beb _e .Image ,_ggd Image ,_efa _e .Rectangle ){for _fef :=0;_fef < _efa .Max .X ;_fef ++{for _gacd :=0;_gacd < _efa .Max .Y ;
_gacd ++{_ccbd :=_beb .At (_fef ,_gacd );_ggd .Set (_fef ,_gacd ,_ccbd );};};};func (_caaf *ImageBase )Pix ()[]byte {return _caaf .Data };func (_facc *NRGBA32 )setRGBA (_dfgd int ,_fbf _g .NRGBA ){_affd :=3*_dfgd ;_facc .Data [_affd ]=_fbf .R ;_facc .Data [_affd +1]=_fbf .G ;
_facc .Data [_affd +2]=_fbf .B ;if _dfgd < len (_facc .Alpha ){_facc .Alpha [_dfgd ]=_fbf .A ;};};func _gaed (_agdf *Monochrome ,_efge ,_deee int ,_aaae ,_eebf int ,_aegdb RasterOperator ,_gede *Monochrome ,_gge ,_dfdd int )error {var _aeee ,_gcgd ,_ddad ,_cadg int ;
if _efge < 0{_gge -=_efge ;_aaae +=_efge ;_efge =0;};if _gge < 0{_efge -=_gge ;_aaae +=_gge ;_gge =0;};_aeee =_efge +_aaae -_agdf .Width ;if _aeee > 0{_aaae -=_aeee ;};_gcgd =_gge +_aaae -_gede .Width ;if _gcgd > 0{_aaae -=_gcgd ;};if _deee < 0{_dfdd -=_deee ;
_eebf +=_deee ;_deee =0;};if _dfdd < 0{_deee -=_dfdd ;_eebf +=_dfdd ;_dfdd =0;};_ddad =_deee +_eebf -_agdf .Height ;if _ddad > 0{_eebf -=_ddad ;};_cadg =_dfdd +_eebf -_gede .Height ;if _cadg > 0{_eebf -=_cadg ;};if _aaae <=0||_eebf <=0{return nil ;};var _aeeab error ;
switch {case _efge &7==0&&_gge &7==0:_aeeab =_cbad (_agdf ,_efge ,_deee ,_aaae ,_eebf ,_aegdb ,_gede ,_gge ,_dfdd );case _efge &7==_gge &7:_aeeab =_degc (_agdf ,_efge ,_deee ,_aaae ,_eebf ,_aegdb ,_gede ,_gge ,_dfdd );default:_aeeab =_ededc (_agdf ,_efge ,_deee ,_aaae ,_eebf ,_aegdb ,_gede ,_gge ,_dfdd );
};if _aeeab !=nil {return _aeeab ;};return nil ;};func _cbad (_bea *Monochrome ,_cbbb ,_befg ,_fabf ,_egec int ,_efbfe RasterOperator ,_cagg *Monochrome ,_cdg ,_baef int )error {var (_afbgg byte ;_eagf int ;_dbdb int ;_gef ,_ebfgd int ;_aeec ,_eded int ;
);_ggfd :=_fabf >>3;_eeg :=_fabf &7;if _eeg > 0{_afbgg =_abbg [_eeg ];};_eagf =_cagg .BytesPerLine *_baef +(_cdg >>3);_dbdb =_bea .BytesPerLine *_befg +(_cbbb >>3);switch _efbfe {case PixSrc :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;
_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]=_cagg .Data [_gef ];_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],_cagg .Data [_gef ],_afbgg );};};case PixNotSrc :for _aeec =0;
_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]=^(_cagg .Data [_gef ]);_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],^_cagg .Data [_gef ],_afbgg );
};};case PixSrcOrDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]|=_cagg .Data [_gef ];_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],_cagg .Data [_gef ]|_bea .Data [_ebfgd ],_afbgg );
};};case PixSrcAndDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]&=_cagg .Data [_gef ];_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],_cagg .Data [_gef ]&_bea .Data [_ebfgd ],_afbgg );
};};case PixSrcXorDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]^=_cagg .Data [_gef ];_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],_cagg .Data [_gef ]^_bea .Data [_ebfgd ],_afbgg );
};};case PixNotSrcOrDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]|=^(_cagg .Data [_gef ]);_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],^(_cagg .Data [_gef ])|_bea .Data [_ebfgd ],_afbgg );
};};case PixNotSrcAndDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]&=^(_cagg .Data [_gef ]);_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],^(_cagg .Data [_gef ])&_bea .Data [_ebfgd ],_afbgg );
};};case PixSrcOrNotDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]=_cagg .Data [_gef ]|^(_bea .Data [_ebfgd ]);_ebfgd ++;
_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],_cagg .Data [_gef ]|^(_bea .Data [_ebfgd ]),_afbgg );};};case PixSrcAndNotDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;
for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]=_cagg .Data [_gef ]&^(_bea .Data [_ebfgd ]);_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],_cagg .Data [_gef ]&^(_bea .Data [_ebfgd ]),_afbgg );};};case PixNotPixSrcOrDst :for _aeec =0;
_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]=^(_cagg .Data [_gef ]|_bea .Data [_ebfgd ]);_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],^(_cagg .Data [_gef ]|_bea .Data [_ebfgd ]),_afbgg );
};};case PixNotPixSrcAndDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]=^(_cagg .Data [_gef ]&_bea .Data [_ebfgd ]);_ebfgd ++;
_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],^(_cagg .Data [_gef ]&_bea .Data [_ebfgd ]),_afbgg );};};case PixNotPixSrcXorDst :for _aeec =0;_aeec < _egec ;_aeec ++{_gef =_eagf +_aeec *_cagg .BytesPerLine ;_ebfgd =_dbdb +_aeec *_bea .BytesPerLine ;
for _eded =0;_eded < _ggfd ;_eded ++{_bea .Data [_ebfgd ]=^(_cagg .Data [_gef ]^_bea .Data [_ebfgd ]);_ebfgd ++;_gef ++;};if _eeg > 0{_bea .Data [_ebfgd ]=_feba (_bea .Data [_ebfgd ],^(_cagg .Data [_gef ]^_bea .Data [_ebfgd ]),_afbgg );};};default:_fb .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_efbfe );
return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_ccbe *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };func (_ddac *Monochrome )copy ()*Monochrome {_bgag :=_adb (_ddac .Width ,_ddac .Height );
_bgag .ModelThreshold =_ddac .ModelThreshold ;_bgag .Data =make ([]byte ,len (_ddac .Data ));copy (_bgag .Data ,_ddac .Data );if len (_ddac .Decode )!=0{_bgag .Decode =make ([]float64 ,len (_ddac .Decode ));copy (_bgag .Decode ,_ddac .Decode );};if len (_ddac .Alpha )!=0{_bgag .Alpha =make ([]byte ,len (_ddac .Alpha ));
copy (_bgag .Alpha ,_ddac .Alpha );};return _bgag ;};func (_fgeca *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_fgeca .copy ()}};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_febg :=y *bytesPerLine +x >>1;
if _febg >=len (data ){return _g .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eeb :=data [_febg ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_eeb =uint8 (uint32 (LinearInterpolate (float64 (_eeb ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_eeb *17&0xff},nil ;};func (_bbge *Gray8 )SetGray (x ,y int ,g _g .Gray ){_ceb :=y *_bbge .BytesPerLine +x ;
if _ceb > len (_bbge .Data )-1{return ;};_bbge .Data [_ceb ]=g .Y ;};var _gddg [256]uint8 ;func _efea (_feab Gray ,_gagc NRGBA ,_begfg _e .Rectangle ){for _eabf :=0;_eabf < _begfg .Max .X ;_eabf ++{for _dafa :=0;_dafa < _begfg .Max .Y ;_dafa ++{_edfb :=_feab .GrayAt (_eabf ,_dafa );
_gagc .SetNRGBA (_eabf ,_dafa ,_dfab (_edfb ));};};};type RGBA interface{RGBAAt (_abcc ,_fabg int )_g .RGBA ;SetRGBA (_fgb ,_bdfd int ,_gcda _g .RGBA );};func (_eafd *Gray4 )Base ()*ImageBase {return &_eafd .ImageBase };func (_ddd *ImageBase )setEightPartlyBytes (_beea ,_ddcf int ,_fgafe uint64 )(_fecdg error ){var (_bgad byte ;
_gbdf int ;);for _faa :=1;_faa <=_ddcf ;_faa ++{_gbdf =64-_faa *8;_bgad =byte (_fgafe >>uint (_gbdf )&0xff);if _fecdg =_ddd .setByte (_beea +_faa -1,_bgad );_fecdg !=nil {return _fecdg ;};};_aege :=_ddd .BytesPerLine *8-_ddd .Width ;if _aege ==0{return nil ;
};_gbdf -=8;_bgad =byte (_fgafe >>uint (_gbdf )&0xff)<<uint (_aege );if _fecdg =_ddd .setByte (_beea +_ddcf ,_bgad );_fecdg !=nil {return _fecdg ;};return nil ;};func _bbd ()(_fae []byte ){_fae =make ([]byte ,256);for _gacb :=0;_gacb < 256;_gacb ++{_fec :=byte (_gacb );
_fae [_fec ]=(_fec &0x01)|((_fec &0x04)>>1)|((_fec &0x10)>>2)|((_fec &0x40)>>3)|((_fec &0x02)<<3)|((_fec &0x08)<<2)|((_fec &0x20)<<1)|(_fec &0x80);};return _fae ;};func (_acce *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_acce .copy ()}};func _dgde (_cfegb int ,_fege int )int {if _cfegb < _fege {return _cfegb ;
};return _fege ;};func (_cedf *Gray2 )Validate ()error {if len (_cedf .Data )!=_cedf .Height *_cedf .BytesPerLine {return ErrInvalidImage ;};return nil ;};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;
PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;
PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func _fbg (_afce _g .NRGBA64 )_g .RGBA {_cbfc ,_bceb ,_fcgd ,_gfg :=_afce .RGBA ();
return _g .RGBA {R :uint8 (_cbfc >>8),G :uint8 (_bceb >>8),B :uint8 (_fcgd >>8),A :uint8 (_gfg >>8)};};type Histogramer interface{Histogram ()[256]int ;};func _aega (_eacdg _e .Image )(Image ,error ){if _gccg ,_bfgf :=_eacdg .(*NRGBA16 );_bfgf {return _gccg .Copy (),nil ;
};_bcc :=_eacdg .Bounds ();_dbc ,_efgaa :=NewImage (_bcc .Max .X ,_bcc .Max .Y ,4,3,nil ,nil ,nil );if _efgaa !=nil {return nil ,_efgaa ;};_gbff (_eacdg ,_dbc ,_bcc );return _dbc ,nil ;};func _gcdf (_fgge _e .Image )(Image ,error ){if _abc ,_aef :=_fgge .(*Gray4 );
_aef {return _abc .Copy (),nil ;};_daff :=_fgge .Bounds ();_fcbc ,_abaca :=NewImage (_daff .Max .X ,_daff .Max .Y ,4,1,nil ,nil ,nil );if _abaca !=nil {return nil ,_abaca ;};_eec (_fgge ,_fcbc ,_daff );return _fcbc ,nil ;};func (_gfaf *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_gfaf .ModelThreshold )};
var _ RGBA =&RGBA32 {};func _aab (_cadd _g .Gray )_g .Gray {_cadd .Y >>=4;_cadd .Y |=_cadd .Y <<4;return _cadd };func _cfa (_fga _e .Image )(Image ,error ){if _gaag ,_dfb :=_fga .(*Monochrome );_dfb {return _gaag ,nil ;};_baeb :=_fga .Bounds ();var _efga Gray ;
switch _cccd :=_fga .(type ){case Gray :_efga =_cccd ;case NRGBA :_efga =&Gray8 {ImageBase :NewImageBase (_baeb .Max .X ,_baeb .Max .Y ,8,1,nil ,nil ,nil )};_ccdf (_efga ,_cccd ,_baeb );case nrgba64 :_efga =&Gray8 {ImageBase :NewImageBase (_baeb .Max .X ,_baeb .Max .Y ,8,1,nil ,nil ,nil )};
_gacbc (_efga ,_cccd ,_baeb );default:_dffe ,_bbf :=GrayConverter .Convert (_fga );if _bbf !=nil {return nil ,_bbf ;};_efga =_dffe .(Gray );};_bbaf ,_eeea :=NewImage (_baeb .Max .X ,_baeb .Max .Y ,1,1,nil ,nil ,nil );if _eeea !=nil {return nil ,_eeea ;
};_cdd :=_bbaf .(*Monochrome );_cccb :=AutoThresholdTriangle (GrayHistogram (_efga ));for _addc :=0;_addc < _baeb .Max .X ;_addc ++{for _cfdf :=0;_cfdf < _baeb .Max .Y ;_cfdf ++{_cdec :=_beg (_efga .GrayAt (_addc ,_cfdf ),monochromeModel (_cccb ));_cdd .SetGray (_addc ,_cfdf ,_cdec );
};};return _bbaf ,nil ;};var _ _e .Image =&NRGBA32 {};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _aaa (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _abab (_fbfc _e .Image ,_dgaa Image ,_cacaa _e .Rectangle ){if _ggec ,_gfgdf :=_fbfc .(SMasker );
_gfgdf &&_ggec .HasAlpha (){_dgaa .(SMasker ).MakeAlpha ();};switch _bdag :=_fbfc .(type ){case Gray :_eacg (_bdag ,_dgaa .(RGBA ),_cacaa );case NRGBA :_abacd (_bdag ,_dgaa .(RGBA ),_cacaa );case *_e .NYCbCrA :_gage (_bdag ,_dgaa .(RGBA ),_cacaa );case CMYK :_dgfc (_bdag ,_dgaa .(RGBA ),_cacaa );
case RGBA :_faaa (_bdag ,_dgaa .(RGBA ),_cacaa );case nrgba64 :_dfefg (_bdag ,_dgaa .(RGBA ),_cacaa );default:_dfef (_fbfc ,_dgaa ,_cacaa );};};func (_cffe *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _bdae bool ;_cbb :=scale ;if scale < 1{_cbb =1/scale ;
_bdae =true ;};_eff :=NextPowerOf2 (uint (_cbb ));if InDelta (float64 (_eff ),_cbb ,0.001){if _bdae {return _cffe .ReduceBinary (_cbb );};return _cffe .ExpandBinary (int (_eff ));};_dbff :=int (_c .RoundToEven (float64 (_cffe .Width )*scale ));_aegd :=int (_c .RoundToEven (float64 (_cffe .Height )*scale ));
return _cffe .ScaleLow (_dbff ,_aegd );};func (_cadb *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_cadb .Width ,_cadb .Data ,_cadb .Alpha ,_cadb .Decode );};func _fdc (_bfeb _g .RGBA )_g .Gray {_abbd :=(19595*uint32 (_bfeb .R )+38470*uint32 (_bfeb .G )+7471*uint32 (_bfeb .B )+1<<7)>>16;
return _g .Gray {Y :uint8 (_abbd )};};type RasterOperator int ;type Gray16 struct{ImageBase };func _dce (_gggd _g .NRGBA )_g .Gray {_aac ,_eggg ,_befe ,_ :=_gggd .RGBA ();_bfb :=(19595*_aac +38470*_eggg +7471*_befe +1<<15)>>24;return _g .Gray {Y :uint8 (_bfb )};
};func (_ffcf *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_gfgf ,_ :=ColorAtNRGBA32 (x ,y ,_ffcf .Width ,_ffcf .Data ,_ffcf .Alpha ,_ffcf .Decode );return _gfgf ;};func _dg (_fbe ,_gfd *Monochrome )(_gd error ){_bc :=_gfd .BytesPerLine ;_ecc :=_fbe .BytesPerLine ;
var (_bca byte ;_edc uint16 ;_bf ,_dbf ,_fdg ,_caa ,_bfe int ;);for _fdg =0;_fdg < _gfd .Height ;_fdg ++{_bf =_fdg *_bc ;_dbf =2*_fdg *_ecc ;for _caa =0;_caa < _bc ;_caa ++{_bca =_gfd .Data [_bf +_caa ];_edc =_bce [_bca ];_bfe =_dbf +_caa *2;if _fbe .BytesPerLine !=_gfd .BytesPerLine *2&&(_caa +1)*2> _fbe .BytesPerLine {_gd =_fbe .setByte (_bfe ,byte (_edc >>8));
}else {_gd =_fbe .setTwoBytes (_bfe ,_edc );};if _gd !=nil {return _gd ;};};for _caa =0;_caa < _ecc ;_caa ++{_bfe =_dbf +_ecc +_caa ;_bca =_fbe .Data [_dbf +_caa ];if _gd =_fbe .setByte (_bfe ,_bca );_gd !=nil {return _gd ;};};};return nil ;};func _efc (_ddcg _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_ddcg .Y }};
type monochromeModel uint8 ;var _ _e .Image =&NRGBA16 {};func ImgToGray (i _e .Image )*_e .Gray {if _cfgdd ,_fecdge :=i .(*_e .Gray );_fecdge {return _cfgdd ;};_cgac :=i .Bounds ();_beag :=_e .NewGray (_cgac );for _abdfc :=0;_abdfc < _cgac .Max .X ;_abdfc ++{for _dfgc :=0;
_dfgc < _cgac .Max .Y ;_dfgc ++{_dfcb :=i .At (_abdfc ,_dfgc );_beag .Set (_abdfc ,_dfgc ,_dfcb );};};return _beag ;};func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};func (_gbfec *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _aaa (_gbfec ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_ddcb *Monochrome )Base ()*ImageBase {return &_ddcb .ImageBase };func (_dfbf *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_dfbf .copy ()}};func _bggd (_daecc _g .Color )_g .Color {_ceec :=_g .NRGBAModel .Convert (_daecc ).(_g .NRGBA );return _gceaec (_ceec );
};func _dfac (_fff NRGBA ,_dcde Gray ,_adfg _e .Rectangle ){for _ddeca :=0;_ddeca < _adfg .Max .X ;_ddeca ++{for _gfcf :=0;_gfcf < _adfg .Max .Y ;_gfcf ++{_efda :=_dce (_fff .NRGBAAt (_ddeca ,_gfcf ));_dcde .SetGray (_ddeca ,_gfcf ,_efda );};};};var _ Image =&NRGBA64 {};
func (_fbafb *RGBA32 )RGBAAt (x ,y int )_g .RGBA {_afcc ,_ :=ColorAtRGBA32 (x ,y ,_fbafb .Width ,_fbafb .Data ,_fbafb .Alpha ,_fbafb .Decode );return _afcc ;};func (_fdea *Gray2 )Base ()*ImageBase {return &_fdea .ImageBase };func _ebea (_cff _g .RGBA )_g .NRGBA {switch _cff .A {case 0xff:return _g .NRGBA {R :_cff .R ,G :_cff .G ,B :_cff .B ,A :0xff};
case 0x00:return _g .NRGBA {};default:_daag ,_edac ,_faee ,_bgc :=_cff .RGBA ();_daag =(_daag *0xffff)/_bgc ;_edac =(_edac *0xffff)/_bgc ;_faee =(_faee *0xffff)/_bgc ;return _g .NRGBA {R :uint8 (_daag >>8),G :uint8 (_edac >>8),B :uint8 (_faee >>8),A :uint8 (_bgc >>8)};
};};func (_ecge *Gray4 )At (x ,y int )_g .Color {_fada ,_ :=_ecge .ColorAt (x ,y );return _fada };func (_gedb *Gray4 )Histogram ()(_cbeb [256]int ){for _eeac :=0;_eeac < _gedb .Width ;_eeac ++{for _fcfg :=0;_fcfg < _gedb .Height ;_fcfg ++{_cbeb [_gedb .GrayAt (_eeac ,_fcfg ).Y ]++;
};};return _cbeb ;};func _feba (_adec ,_gbbd ,_cffb byte )byte {return (_adec &^(_cffb ))|(_gbbd &_cffb )};func (_fgec monochromeModel )Convert (c _g .Color )_g .Color {_bacg :=_g .GrayModel .Convert (c ).(_g .Gray );return _beg (_bacg ,_fgec );};func (_ebdg *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ebdg .Width ,_ebdg .BytesPerLine ,_ebdg .Data ,_ebdg .Alpha ,_ebdg .Decode );
};func (_gdf *ImageBase )copy ()ImageBase {_dcca :=*_gdf ;_dcca .Data =make ([]byte ,len (_gdf .Data ));copy (_dcca .Data ,_gdf .Data );return _dcca ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_ecbd :=y *width +x ;
_eece :=3*_ecbd ;if _eece +2>=len (data ){return _g .NRGBA {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eecc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _ecbd {_eecc =alpha [_ecbd ];};_cgbg ,_gddb ,_bfdd :=data [_eece ],data [_eece +1],data [_eece +2];if len (decode )==6{_eead :=LinearInterpolate (float64 (_cgbg ),0,255.0,decode [0],decode [1]);_gedc :=LinearInterpolate (float64 (_gddb ),0,255.0,decode [2],decode [3]);
_feec :=LinearInterpolate (float64 (_bfdd ),0,255.0,decode [4],decode [5]);if _eead <=1.0&&_gedc <=1.0&&_feec <=1.0{_eead *=255.0;_gedc *=255.0;_feec *=255.0;};_cgbg =uint8 (_eead )&0xff;_gddb =uint8 (_gedc )&0xff;_bfdd =uint8 (_feec )&0xff;};return _g .NRGBA {R :_cgbg ,G :_gddb ,B :_bfdd ,A :_eecc },nil ;
};func _ff (_gfe int )[]uint {var _bbb []uint ;_gfb :=_gfe ;_cfd :=_gfb /8;if _cfd !=0{for _cb :=0;_cb < _cfd ;_cb ++{_bbb =append (_bbb ,8);};_gg :=_gfb %8;_gfb =0;if _gg !=0{_gfb =_gg ;};};_fad :=_gfb /4;if _fad !=0{for _cbd :=0;_cbd < _fad ;_cbd ++{_bbb =append (_bbb ,4);
};_cde :=_gfb %4;_gfb =0;if _cde !=0{_gfb =_cde ;};};_efd :=_gfb /2;if _efd !=0{for _dcd :=0;_dcd < _efd ;_dcd ++{_bbb =append (_bbb ,2);};};return _bbb ;};var _ _e .Image =&Gray4 {};func GrayHistogram (g Gray )(_bcgfg [256]int ){switch _bdagb :=g .(type ){case Histogramer :return _bdagb .Histogram ();
case _e .Image :_afcf :=_bdagb .Bounds ();for _bfdf :=0;_bfdf < _afcf .Max .X ;_bfdf ++{for _dgcb :=0;_dgcb < _afcf .Max .Y ;_dgcb ++{_bcgfg [g .GrayAt (_bfdf ,_dgcb ).Y ]++;};};return _bcgfg ;default:return [256]int {};};};func (_gdg *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_gdg .copy ()}};
func (_fggd *Gray4 )GrayAt (x ,y int )_g .Gray {_fade ,_ :=ColorAtGray4BPC (x ,y ,_fggd .BytesPerLine ,_fggd .Data ,_fggd .Decode );return _fade ;};func _ccca (_dede _e .Image ,_bcfb Image ,_gbcd _e .Rectangle ){if _eeef ,_dbce :=_dede .(SMasker );_dbce &&_eeef .HasAlpha (){_bcfb .(SMasker ).MakeAlpha ();
};_dfef (_dede ,_bcfb ,_gbcd );};func (_gceae *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_gceae .BytesPerLine ,_gceae .Data ,_gceae .Decode );};func (_cgaf *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_aabg ,_ :=ColorAtNRGBA64 (x ,y ,_cgaf .Width ,_cgaf .Data ,_cgaf .Alpha ,_cgaf .Decode );
return _aabg ;};func (_begb *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func _dfdb (_gbcb *_e .Gray16 ,_gfafd uint8 )*_e .Gray {_fcbaa :=_gbcb .Bounds ();_fdbf :=_e .NewGray (_fcbaa );for _gegaa :=0;_gegaa < _fcbaa .Dx ();_gegaa ++{for _bccf :=0;
_bccf < _fcbaa .Dy ();_bccf ++{_abcg :=_gbcb .Gray16At (_gegaa ,_bccf );_fdbf .SetGray (_gegaa ,_bccf ,_g .Gray {Y :_dacg (uint8 (_abcg .Y /256),_gfafd )});};};return _fdbf ;};func (_fcdaf *Monochrome )IsUnpadded ()bool {return (_fcdaf .Width *_fcdaf .Height )==len (_fcdaf .Data );
};func _egdc (_dgef RGBA ,_debd NRGBA ,_bgab _e .Rectangle ){for _dgbd :=0;_dgbd < _bgab .Max .X ;_dgbd ++{for _cbgf :=0;_cbgf < _bgab .Max .Y ;_cbgf ++{_ecefd :=_dgef .RGBAAt (_dgbd ,_cbgf );_debd .SetNRGBA (_dgbd ,_cbgf ,_ebea (_ecefd ));};};};type colorConverter struct{_bcd func (_egag _e .Image )(Image ,error );
};func AutoThresholdTriangle (histogram [256]int )uint8 {var _gagf ,_fdgga ,_dcfc ,_feag int ;for _egda :=0;_egda < len (histogram );_egda ++{if histogram [_egda ]> 0{_gagf =_egda ;break ;};};if _gagf > 0{_gagf --;};for _ebcb :=255;_ebcb > 0;_ebcb --{if histogram [_ebcb ]> 0{_feag =_ebcb ;
break ;};};if _feag < 255{_feag ++;};for _eabgb :=0;_eabgb < 256;_eabgb ++{if histogram [_eabgb ]> _fdgga {_dcfc =_eabgb ;_fdgga =histogram [_eabgb ];};};var _fcagc bool ;if (_dcfc -_gagf )< (_feag -_dcfc ){_fcagc =true ;var _bcfg int ;_cbdgg :=255;for _bcfg < _cbdgg {_ebcbf :=histogram [_bcfg ];
histogram [_bcfg ]=histogram [_cbdgg ];histogram [_cbdgg ]=_ebcbf ;_bcfg ++;_cbdgg --;};_gagf =255-_feag ;_dcfc =255-_dcfc ;};if _gagf ==_dcfc {return uint8 (_gagf );};_bgcd :=float64 (histogram [_dcfc ]);_fbcdg :=float64 (_gagf -_dcfc );_ccea :=_c .Sqrt (_bgcd *_bgcd +_fbcdg *_fbcdg );
_bgcd /=_ccea ;_fbcdg /=_ccea ;_ccea =_bgcd *float64 (_gagf )+_fbcdg *float64 (histogram [_gagf ]);_bcag :=_gagf ;var _aggc float64 ;for _cgff :=_gagf +1;_cgff <=_dcfc ;_cgff ++{_cbgfg :=_bgcd *float64 (_cgff )+_fbcdg *float64 (histogram [_cgff ])-_ccea ;
if _cbgfg > _aggc {_bcag =_cgff ;_aggc =_cbgfg ;};};_bcag --;if _fcagc {var _fbaa int ;_aabf :=255;for _fbaa < _aabf {_bgee :=histogram [_fbaa ];histogram [_fbaa ]=histogram [_aabf ];histogram [_aabf ]=_bgee ;_fbaa ++;_aabf --;};return uint8 (255-_bcag );
};return uint8 (_bcag );};func _ede ()(_agd [256]uint16 ){for _gce :=0;_gce < 256;_gce ++{if _gce &0x01!=0{_agd [_gce ]|=0x3;};if _gce &0x02!=0{_agd [_gce ]|=0xc;};if _gce &0x04!=0{_agd [_gce ]|=0x30;};if _gce &0x08!=0{_agd [_gce ]|=0xc0;};if _gce &0x10!=0{_agd [_gce ]|=0x300;
};if _gce &0x20!=0{_agd [_gce ]|=0xc00;};if _gce &0x40!=0{_agd [_gce ]|=0x3000;};if _gce &0x80!=0{_agd [_gce ]|=0xc000;};};return _agd ;};type NRGBA64 struct{ImageBase };type monochromeThresholdConverter struct{Threshold uint8 ;};func (_ffbg *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_ffbg .BytesPerLine ,_ffbg .Data ,_ffbg .Decode );
};var (Gray2Model =_g .ModelFunc (_eef );Gray4Model =_g .ModelFunc (_ebgf );NRGBA16Model =_g .ModelFunc (_bggd ););func (_acg *NRGBA16 )setNRGBA (_efae ,_ebece ,_bffa int ,_deec _g .NRGBA ){if _efae *3%2==0{_acg .Data [_bffa ]=(_deec .R >>4)<<4|(_deec .G >>4);
_acg .Data [_bffa +1]=(_deec .B >>4)<<4|(_acg .Data [_bffa +1]&0xf);}else {_acg .Data [_bffa ]=(_acg .Data [_bffa ]&0xf0)|(_deec .R >>4);_acg .Data [_bffa +1]=(_deec .G >>4)<<4|(_deec .B >>4);};if _acg .Alpha !=nil {_daec :=_ebece *BytesPerLine (_acg .Width ,4,1);
if _daec < len (_acg .Alpha ){if _efae %2==0{_acg .Alpha [_daec ]=(_deec .A >>uint (4))<<uint (4)|(_acg .Alpha [_bffa ]&0xf);}else {_acg .Alpha [_daec ]=(_acg .Alpha [_daec ]&0xf0)|(_deec .A >>uint (4));};};};};func (_dgda *Gray8 )GrayAt (x ,y int )_g .Gray {_ffdaf ,_ :=ColorAtGray8BPC (x ,y ,_dgda .BytesPerLine ,_dgda .Data ,_dgda .Decode );
return _ffdaf ;};func _gage (_faca *_e .NYCbCrA ,_egge RGBA ,_fbcb _e .Rectangle ){for _cfaa :=0;_cfaa < _fbcb .Max .X ;_cfaa ++{for _acfc :=0;_acfc < _fbcb .Max .Y ;_acfc ++{_abdb :=_faca .NYCbCrAAt (_cfaa ,_acfc );_egge .SetRGBA (_cfaa ,_acfc ,_gcaf (_abdb ));
};};};func (_gda *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_cfg ,_ :=ColorAtCMYK (x ,y ,_gda .Width ,_gda .Data ,_gda .Decode );return _cfg ;};func (_baba *ImageBase )setEightBytes (_fbad int ,_cffc uint64 )error {_gag :=_baba .BytesPerLine -(_fbad %_baba .BytesPerLine );
if _baba .BytesPerLine !=_baba .Width >>3{_gag --;};if _gag >=8{return _baba .setEightFullBytes (_fbad ,_cffc );};return _baba .setEightPartlyBytes (_fbad ,_gag ,_cffc );};func _ffg (_dbbg *_e .Gray ,_agf uint8 )*_e .Gray {_acaf :=_dbbg .Bounds ();_agbfb :=_e .NewGray (_acaf );
for _abcd :=0;_abcd < _acaf .Dx ();_abcd ++{for _cedff :=0;_cedff < _acaf .Dy ();_cedff ++{_bgba :=_dbbg .GrayAt (_abcd ,_cedff );_agbfb .SetGray (_abcd ,_cedff ,_g .Gray {Y :_dacg (_bgba .Y ,_agf )});};};return _agbfb ;};func _gccd (_agc _e .Image )(Image ,error ){if _gebe ,_fbba :=_agc .(*Gray16 );
_fbba {return _gebe .Copy (),nil ;};_dcf :=_agc .Bounds ();_ebec ,_adab :=NewImage (_dcf .Max .X ,_dcf .Max .Y ,16,1,nil ,nil ,nil );if _adab !=nil {return nil ,_adab ;};_eec (_agc ,_ebec ,_dcf );return _ebec ,nil ;};func _badc (_addfg CMYK ,_abbcb Gray ,_ebdc _e .Rectangle ){for _bgff :=0;
_bgff < _ebdc .Max .X ;_bgff ++{for _fbeaa :=0;_fbeaa < _ebdc .Max .Y ;_fbeaa ++{_cafg :=_gcee (_addfg .CMYKAt (_bgff ,_fbeaa ));_abbcb .SetGray (_bgff ,_fbeaa ,_cafg );};};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_fgc :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _fgc ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ddfe :=width *colorComponents *bitsPerComponent ;_eggc :=_fgc *8;_agbb :=8-(_eggc -_ddfe );_fagg :=_eg .NewReader (data );_afeea :=_fgc -1;_geag :=make ([]byte ,_afeea );_ffeb :=make ([]byte ,height *_fgc );
_ecgb :=_eg .NewWriterMSB (_ffeb );var _dag uint64 ;var _edcf error ;for _efag :=0;_efag < height ;_efag ++{_ ,_edcf =_fagg .Read (_geag );if _edcf !=nil {return nil ,_edcf ;};_ ,_edcf =_ecgb .Write (_geag );if _edcf !=nil {return nil ,_edcf ;};_dag ,_edcf =_fagg .ReadBits (byte (_agbb ));
if _edcf !=nil {return nil ,_edcf ;};_ ,_edcf =_ecgb .WriteBits (_dag ,_agbb );if _edcf !=nil {return nil ,_edcf ;};_ecgb .FinishByte ();};return _ffeb ,nil ;};func (_gebg *Gray8 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_gebg .Width ,Y :_gebg .Height }};
};func (_geg *Monochrome )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_geg .Width ,Y :_geg .Height }};};func (_cdbf *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };func (_bbc *Monochrome )InverseData ()error {return _bbc .RasterOperation (0,0,_bbc .Width ,_bbc .Height ,PixNotDst ,nil ,0,0);
};type RGBA32 struct{ImageBase };func (_addcd *Gray4 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_addcd .Width ,Y :_addcd .Height }};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_ec .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ Gray =&Gray4 {};func ImgToBinary (i _e .Image ,threshold uint8 )*_e .Gray {switch _ggac :=i .(type ){case *_e .Gray :if _aaf (_ggac ){return _ggac ;};return _ffg (_ggac ,threshold );case *_e .Gray16 :return _dfdb (_ggac ,threshold );default:return _dfddg (_ggac ,threshold );
};};func (_efbf *ImageBase )setFourBytes (_ddcgc int ,_cbba uint32 )error {if _ddcgc +3> len (_efbf .Data )-1{return _ec .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_ddcgc );
};_efbf .Data [_ddcgc ]=byte ((_cbba &0xff000000)>>24);_efbf .Data [_ddcgc +1]=byte ((_cbba &0xff0000)>>16);_efbf .Data [_ddcgc +2]=byte ((_cbba &0xff00)>>8);_efbf .Data [_ddcgc +3]=byte (_cbba &0xff);return nil ;};func (_bacc *CMYK32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bacc .Width ,Y :_bacc .Height }};
};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_deb :=y *bytesPerLine +x >>2;if _deb >=len (data ){return _g .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_faec :=data [_deb ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_faec =uint8 (uint32 (LinearInterpolate (float64 (_faec ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_faec *85},nil ;};func (_ecea *Gray4 )ColorModel ()_g .Model {return Gray4Model };
func _gcee (_gaeb _g .CMYK )_g .Gray {_caab ,_egdg ,_eaaef :=_g .CMYKToRGB (_gaeb .C ,_gaeb .M ,_gaeb .Y ,_gaeb .K );_gbce :=(19595*uint32 (_caab )+38470*uint32 (_egdg )+7471*uint32 (_eaaef )+1<<7)>>16;return _g .Gray {Y :uint8 (_gbce )};};type NRGBA32 struct{ImageBase };
func _beg (_dgc _g .Gray ,_bgb monochromeModel )_g .Gray {if _dgc .Y > uint8 (_bgb ){return _g .Gray {Y :_c .MaxUint8 };};return _g .Gray {};};type ColorConverter interface{Convert (_faf _e .Image )(Image ,error );};func _gc (_edf ,_ada *Monochrome )(_cc error ){_be :=_ada .BytesPerLine ;
_df :=_edf .BytesPerLine ;_cab :=_ada .BytesPerLine *4-_edf .BytesPerLine ;var (_fa ,_eaf byte ;_cca uint32 ;_bcb ,_de ,_dd ,_ce ,_bd ,_gea ,_gee int ;);for _dd =0;_dd < _ada .Height ;_dd ++{_bcb =_dd *_be ;_de =4*_dd *_df ;for _ce =0;_ce < _be ;_ce ++{_fa =_ada .Data [_bcb +_ce ];
_cca =_cg [_fa ];_gea =_de +_ce *4;if _cab !=0&&(_ce +1)*4> _edf .BytesPerLine {for _bd =_cab ;_bd > 0;_bd --{_eaf =byte ((_cca >>uint (_bd *8))&0xff);_gee =_gea +(_cab -_bd );if _cc =_edf .setByte (_gee ,_eaf );_cc !=nil {return _cc ;};};}else if _cc =_edf .setFourBytes (_gea ,_cca );
_cc !=nil {return _cc ;};if _cc =_edf .setFourBytes (_de +_ce *4,_cg [_ada .Data [_bcb +_ce ]]);_cc !=nil {return _cc ;};};for _bd =1;_bd < 4;_bd ++{for _ce =0;_ce < _df ;_ce ++{if _cc =_edf .setByte (_de +_bd *_df +_ce ,_edf .Data [_de +_ce ]);_cc !=nil {return _cc ;
};};};};return nil ;};func (_daad *Gray4 )Validate ()error {if len (_daad .Data )!=_daad .Height *_daad .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _deed (_bda ,_fbea CMYK ,_dgg _e .Rectangle ){for _cfba :=0;_cfba < _dgg .Max .X ;_cfba ++{for _gab :=0;
_gab < _dgg .Max .Y ;_gab ++{_fbea .SetCMYK (_cfba ,_gab ,_bda .CMYKAt (_cfba ,_gab ));};};};func _bcae ()(_egg [256]uint64 ){for _gcf :=0;_gcf < 256;_gcf ++{if _gcf &0x01!=0{_egg [_gcf ]|=0xff;};if _gcf &0x02!=0{_egg [_gcf ]|=0xff00;};if _gcf &0x04!=0{_egg [_gcf ]|=0xff0000;
};if _gcf &0x08!=0{_egg [_gcf ]|=0xff000000;};if _gcf &0x10!=0{_egg [_gcf ]|=0xff00000000;};if _gcf &0x20!=0{_egg [_gcf ]|=0xff0000000000;};if _gcf &0x40!=0{_egg [_gcf ]|=0xff000000000000;};if _gcf &0x80!=0{_egg [_gcf ]|=0xff00000000000000;};};return _egg ;
};func (_fbafd *Gray2 )At (x ,y int )_g .Color {_edba ,_ :=_fbafd .ColorAt (x ,y );return _edba };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_bade :=y *bytesPerLine +x >>3;if _bade >=len (data ){return _g .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gaf :=data [_bade ]>>uint (7-(x &7))&1;if len (decode )==2{_gaf =uint8 (LinearInterpolate (float64 (_gaf ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_gaf *255},nil ;};func (_dadc *monochromeThresholdConverter )Convert (img _e .Image )(Image ,error ){if _fcdad ,_gcca :=img .(*Monochrome );
_gcca {return _fcdad .Copy (),nil ;};_bdab :=img .Bounds ();_edag ,_gbfe :=NewImage (_bdab .Max .X ,_bdab .Max .Y ,1,1,nil ,nil ,nil );if _gbfe !=nil {return nil ,_gbfe ;};_edag .(*Monochrome ).ModelThreshold =_dadc .Threshold ;for _ebee :=0;_ebee < _bdab .Max .X ;
_ebee ++{for _ddg :=0;_ddg < _bdab .Max .Y ;_ddg ++{_dceg :=img .At (_ebee ,_ddg );_edag .Set (_ebee ,_ddg ,_dceg );};};return _edag ,nil ;};func (_acbb *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_dea :=_facd (uint (factor ));if !IsPowerOf2 (uint (factor )){_dea ++;
};_dafc :=make ([]int ,_dea );for _bbfc :=range _dafc {_dafc [_bbfc ]=4;};_fdgg ,_cgde :=_bg (_acbb ,_dafc ...);if _cgde !=nil {return nil ,_cgde ;};return _fdgg ,nil ;};func _eefb (_gdfb *Monochrome ,_acf ,_ead ,_bddee ,_ggbc int ,_cbfb RasterOperator ){if _acf < 0{_bddee +=_acf ;
_acf =0;};_aaee :=_acf +_bddee -_gdfb .Width ;if _aaee > 0{_bddee -=_aaee ;};if _ead < 0{_ggbc +=_ead ;_ead =0;};_bfaa :=_ead +_ggbc -_gdfb .Height ;if _bfaa > 0{_ggbc -=_bfaa ;};if _bddee <=0||_ggbc <=0{return ;};if (_acf &7)==0{_dbac (_gdfb ,_acf ,_ead ,_bddee ,_ggbc ,_cbfb );
}else {_bbed (_gdfb ,_acf ,_ead ,_bddee ,_ggbc ,_cbfb );};};var _ NRGBA =&NRGBA32 {};func _eb (_d *Monochrome ,_ef int ,_adg []uint )(*Monochrome ,error ){_db :=_ef *_d .Width ;_ed :=_ef *_d .Height ;_af :=_adb (_db ,_ed );for _afc ,_ea :=range _adg {var _ca error ;
switch _ea {case 2:_ca =_dg (_af ,_d );case 4:_ca =_gc (_af ,_d );case 8:_ca =_ccd (_af ,_d );};if _ca !=nil {return nil ,_ca ;};if _afc !=len (_adg )-1{_d =_af .copy ();};};return _af ,nil ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func (_dcg *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_aea :=y *_dcg .BytesPerLine +x *3/2;if _aea +1>=len (_dcg .Data ){return ;};c =_gceaec (c );_dcg .setNRGBA (x ,y ,_aea ,c );};func (_fcdcd *RGBA32 )At (x ,y int )_g .Color {_egdf ,_ :=_fcdcd .ColorAt (x ,y );
return _egdf };func (_fbgc *Gray8 )Validate ()error {if len (_fbgc .Data )!=_fbgc .Height *_fbgc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_bcebc *Gray16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bcebc .Width ,Y :_bcebc .Height }};
};func (_gafd *RGBA32 )Set (x ,y int ,c _g .Color ){_adgda :=y *_gafd .Width +x ;_ddecc :=3*_adgda ;if _ddecc +2>=len (_gafd .Data ){return ;};_gbbcf :=_g .RGBAModel .Convert (c ).(_g .RGBA );_gafd .setRGBA (_adgda ,_gbbcf );};func _cfbd (_cbed ,_fggc NRGBA ,_ddecb _e .Rectangle ){for _dgfb :=0;
_dgfb < _ddecb .Max .X ;_dgfb ++{for _cfbe :=0;_cfbe < _ddecb .Max .Y ;_cfbe ++{_fggc .SetNRGBA (_dgfb ,_cfbe ,_cbed .NRGBAAt (_dgfb ,_cfbe ));};};};var _ _e .Image =&Gray2 {};const (_eegf shift =iota ;_fcdca ;);func FromGoImage (i _e .Image )(Image ,error ){switch _dcfd :=i .(type ){case Image :return _dcfd .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_e .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_e .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
func _ccbc (_dbbd _e .Image ,_efgaf int )(_e .Rectangle ,bool ,[]byte ){_gege :=_dbbd .Bounds ();var (_fafc bool ;_defe []byte ;);switch _gfdf :=_dbbd .(type ){case SMasker :_fafc =_gfdf .HasAlpha ();case NRGBA ,RGBA ,*_e .RGBA64 ,nrgba64 ,*_e .NYCbCrA :_defe =make ([]byte ,_gege .Max .X *_gege .Max .Y *_efgaf );
case *_e .Paletted :if !_gfdf .Opaque (){_defe =make ([]byte ,_gege .Max .X *_gege .Max .Y *_efgaf );};};return _gege ,_fafc ,_defe ;};func _gace (_acbg _g .CMYK )_g .NRGBA {_abf ,_agad ,_agaa :=_g .CMYKToRGB (_acbg .C ,_acbg .M ,_acbg .Y ,_acbg .K );return _g .NRGBA {R :_abf ,G :_agad ,B :_agaa ,A :0xff};
};func (_bdaa colorConverter )Convert (src _e .Image )(Image ,error ){return _bdaa ._bcd (src )};func (_bgac *Gray2 )ColorModel ()_g .Model {return Gray2Model };var _ Image =&RGBA32 {};func (_bbac *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_ec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _fd (_bbac ,factor );};func (_defd *NRGBA64 )Base ()*ImageBase {return &_defd .ImageBase };func _egae (_aeda int ,_dbe int )error {return _ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_aeda ,_dbe );
};func (_befd *NRGBA32 )At (x ,y int )_g .Color {_acfa ,_ :=_befd .ColorAt (x ,y );return _acfa };type NRGBA interface{NRGBAAt (_egcd ,_fede int )_g .NRGBA ;SetNRGBA (_fabcg ,_dead int ,_cbg _g .NRGBA );};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_gdgc :=y *bytesPerLine +x *3/2;
if _gdgc +1>=len (data ){return _g .NRGBA {},_egae (x ,y );};const (_aeeg =0xf;_fabgc =uint8 (0xff););_efab :=_fabgc ;if alpha !=nil {_becc :=y *BytesPerLine (width ,4,1);if _becc < len (alpha ){if x %2==0{_efab =(alpha [_becc ]>>uint (4))&_aeeg ;}else {_efab =alpha [_becc ]&_aeeg ;
};_efab |=_efab <<4;};};var _bebd ,_cbcce ,_dage uint8 ;if x *3%2==0{_bebd =(data [_gdgc ]>>uint (4))&_aeeg ;_cbcce =data [_gdgc ]&_aeeg ;_dage =(data [_gdgc +1]>>uint (4))&_aeeg ;}else {_bebd =data [_gdgc ]&_aeeg ;_cbcce =(data [_gdgc +1]>>uint (4))&_aeeg ;
_dage =data [_gdgc +1]&_aeeg ;};if len (decode )==6{_bebd =uint8 (uint32 (LinearInterpolate (float64 (_bebd ),0,15,decode [0],decode [1]))&0xf);_cbcce =uint8 (uint32 (LinearInterpolate (float64 (_cbcce ),0,15,decode [2],decode [3]))&0xf);_dage =uint8 (uint32 (LinearInterpolate (float64 (_dage ),0,15,decode [4],decode [5]))&0xf);
};return _g .NRGBA {R :(_bebd <<4)|(_bebd &0xf),G :(_cbcce <<4)|(_cbcce &0xf),B :(_dage <<4)|(_dage &0xf),A :_efab },nil ;};func (_gec *Monochrome )GrayAt (x ,y int )_g .Gray {_fdbc ,_ :=ColorAtGray1BPC (x ,y ,_gec .BytesPerLine ,_gec .Data ,_gec .Decode );
return _fdbc ;};var _ Image =&Gray8 {};func (_abccd *NRGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_abccd .Width ,Y :_abccd .Height }};};func (_dca *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_dca .Width ||y >=_dca .Height {return ;
};_dbgd :=Gray2Model .Convert (c ).(_g .Gray );_cgfb :=y *_dca .BytesPerLine ;_fgg :=_cgfb +(x >>2);_fed :=_dbgd .Y >>6;_dca .Data [_fgg ]=(_dca .Data [_fgg ]&(^(0xc0>>uint (2*((x )&3)))))|(_fed <<uint (6-2*(x &3)));};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ec .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_fcga :=(y *width +x )*2;_ccfg :=_fcga *3;if _ccfg +5>=len (data ){return _g .NRGBA64 {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _gedd =0xffff;_fdae :=uint16 (_gedd );if alpha !=nil &&len (alpha )> _fcga +1{_fdae =uint16 (alpha [_fcga ])<<8|uint16 (alpha [_fcga +1]);};_bcddf :=uint16 (data [_ccfg ])<<8|uint16 (data [_ccfg +1]);_fbfd :=uint16 (data [_ccfg +2])<<8|uint16 (data [_ccfg +3]);
_efbe :=uint16 (data [_ccfg +4])<<8|uint16 (data [_ccfg +5]);if len (decode )==6{_bcddf =uint16 (uint64 (LinearInterpolate (float64 (_bcddf ),0,65535,decode [0],decode [1]))&_gedd );_fbfd =uint16 (uint64 (LinearInterpolate (float64 (_fbfd ),0,65535,decode [2],decode [3]))&_gedd );
_efbe =uint16 (uint64 (LinearInterpolate (float64 (_efbe ),0,65535,decode [4],decode [5]))&_gedd );};return _g .NRGBA64 {R :_bcddf ,G :_fbfd ,B :_efbe ,A :_fdae },nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};var _ _e .Image =&Monochrome {};func _gcaf (_bdf _g .NYCbCrA )_g .RGBA {_ggge ,_egb ,_fdf ,_feaa :=_bfc (_bdf ).RGBA ();return _g .RGBA {R :uint8 (_ggge >>8),G :uint8 (_egb >>8),B :uint8 (_fdf >>8),A :uint8 (_feaa >>8)};};func _aba (_ac ,_gbg *Monochrome ,_gcb []byte ,_bbe int )(_ceg error ){var (_cda ,_agb ,_cbc ,_gggg ,_bba ,_abd ,_aa ,_cac int ;
_daa ,_bffd uint32 ;_adf ,_gdd byte ;_cgf uint16 ;);_edg :=make ([]byte ,4);_bcg :=make ([]byte ,4);for _cbc =0;_cbc < _ac .Height -1;_cbc ,_gggg =_cbc +2,_gggg +1{_cda =_cbc *_ac .BytesPerLine ;_agb =_gggg *_gbg .BytesPerLine ;for _bba ,_abd =0,0;_bba < _bbe ;
_bba ,_abd =_bba +4,_abd +1{for _aa =0;_aa < 4;_aa ++{_cac =_cda +_bba +_aa ;if _cac <=len (_ac .Data )-1&&_cac < _cda +_ac .BytesPerLine {_edg [_aa ]=_ac .Data [_cac ];}else {_edg [_aa ]=0x00;};_cac =_cda +_ac .BytesPerLine +_bba +_aa ;if _cac <=len (_ac .Data )-1&&_cac < _cda +(2*_ac .BytesPerLine ){_bcg [_aa ]=_ac .Data [_cac ];
}else {_bcg [_aa ]=0x00;};};_daa =_ab .BigEndian .Uint32 (_edg );_bffd =_ab .BigEndian .Uint32 (_bcg );_bffd |=_daa ;_bffd |=_bffd <<1;_bffd &=0xaaaaaaaa;_daa =_bffd |(_bffd <<7);_adf =byte (_daa >>24);_gdd =byte ((_daa >>8)&0xff);_cac =_agb +_abd ;if _cac +1==len (_gbg .Data )-1||_cac +1>=_agb +_gbg .BytesPerLine {_gbg .Data [_cac ]=_gcb [_adf ];
}else {_cgf =(uint16 (_gcb [_adf ])<<8)|uint16 (_gcb [_gdd ]);if _ceg =_gbg .setTwoBytes (_cac ,_cgf );_ceg !=nil {return _ec .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cac );
};_abd ++;};};};return nil ;};func _gacbc (_efb Gray ,_cgc nrgba64 ,_ddag _e .Rectangle ){for _gaab :=0;_gaab < _ddag .Max .X ;_gaab ++{for _caf :=0;_caf < _ddag .Max .Y ;_caf ++{_ffc :=_eabg (_cgc .NRGBA64At (_gaab ,_caf ));_efb .SetGray (_gaab ,_caf ,_ffc );
};};};var _ NRGBA =&NRGBA16 {};func _ceda (){for _fabe :=0;_fabe < 256;_fabe ++{_gddg [_fabe ]=uint8 (_fabe &0x1)+(uint8 (_fabe >>1)&0x1)+(uint8 (_fabe >>2)&0x1)+(uint8 (_fabe >>3)&0x1)+(uint8 (_fabe >>4)&0x1)+(uint8 (_fabe >>5)&0x1)+(uint8 (_fabe >>6)&0x1)+(uint8 (_fabe >>7)&0x1);
};};func _egf (_abe _e .Image )(Image ,error ){if _fgf ,_cag :=_abe .(*Gray2 );_cag {return _fgf .Copy (),nil ;};_aedf :=_abe .Bounds ();_cee ,_gdaa :=NewImage (_aedf .Max .X ,_aedf .Max .Y ,2,1,nil ,nil ,nil );if _gdaa !=nil {return nil ,_gdaa ;};_eec (_abe ,_cee ,_aedf );
return _cee ,nil ;};func (_cefa *NRGBA16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cefa .Width ,Y :_cefa .Height }};};func _ffb (_efdb NRGBA ,_fcge CMYK ,_dcb _e .Rectangle ){for _cea :=0;_cea < _dcb .Max .X ;_cea ++{for _faeb :=0;
_faeb < _dcb .Max .Y ;_faeb ++{_ddf :=_efdb .NRGBAAt (_cea ,_faeb );_fcge .SetCMYK (_cea ,_faeb ,_eabb (_ddf ));};};};func InDelta (expected ,current ,delta float64 )bool {_adae :=expected -current ;if _adae <=-delta ||_adae >=delta {return false ;};return true ;
};func _eec (_eced _e .Image ,_bcbf Image ,_edgb _e .Rectangle ){switch _gad :=_eced .(type ){case Gray :_efff (_gad ,_bcbf .(Gray ),_edgb );case NRGBA :_dfac (_gad ,_bcbf .(Gray ),_edgb );case CMYK :_badc (_gad ,_bcbf .(Gray ),_edgb );case RGBA :_aceb (_gad ,_bcbf .(Gray ),_edgb );
default:_dfef (_eced ,_bcbf ,_edgb );};};func _aceb (_geee RGBA ,_ffe Gray ,_bcdd _e .Rectangle ){for _adag :=0;_adag < _bcdd .Max .X ;_adag ++{for _gcaa :=0;_gcaa < _bcdd .Max .Y ;_gcaa ++{_agcc :=_fdc (_geee .RGBAAt (_adag ,_gcaa ));_ffe .SetGray (_adag ,_gcaa ,_agcc );
};};};func (_efe *Gray16 )Set (x ,y int ,c _g .Color ){_baf :=(y *_efe .BytesPerLine /2+x )*2;if _baf +1>=len (_efe .Data ){return ;};_ddgf :=_g .Gray16Model .Convert (c ).(_g .Gray16 );_efe .Data [_baf ],_efe .Data [_baf +1]=uint8 (_ddgf .Y >>8),uint8 (_ddgf .Y &0xff);
};type Gray8 struct{ImageBase };func _daed (_gba _g .NRGBA )_g .RGBA {_ced ,_fcag ,_bffc ,_ecef :=_gba .RGBA ();return _g .RGBA {R :uint8 (_ced >>8),G :uint8 (_fcag >>8),B :uint8 (_bffc >>8),A :uint8 (_ecef >>8)};};func (_fbaf *Monochrome )At (x ,y int )_g .Color {_fabc ,_ :=_fbaf .ColorAt (x ,y );
return _fabc };var _ _e .Image =&RGBA32 {};func _fcda (_fge _g .CMYK )_g .RGBA {_ecd ,_fadg ,_ddbga :=_g .CMYKToRGB (_fge .C ,_fge .M ,_fge .Y ,_fge .K );return _g .RGBA {R :_ecd ,G :_fadg ,B :_ddbga ,A :0xff};};func (_baag *RGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_baag .Width ,Y :_baag .Height }};
};func (_ecf *NRGBA32 )Base ()*ImageBase {return &_ecf .ImageBase };func (_beaa *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_addd ,_ :=ColorAtNRGBA16 (x ,y ,_beaa .Width ,_beaa .BytesPerLine ,_beaa .Data ,_beaa .Alpha ,_beaa .Decode );return _addd ;};func (_bed *Gray2 )GrayAt (x ,y int )_g .Gray {_facf ,_ :=ColorAtGray2BPC (x ,y ,_bed .BytesPerLine ,_bed .Data ,_bed .Decode );
return _facf ;};func _adb (_afdg ,_add int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_afdg ,_add ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_ffec *ImageBase )setByte (_gdbd int ,_ggfa byte )error {if _gdbd > len (_ffec .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ffec .Data [_gdbd ]=_ggfa ;return nil ;};func ConverterFunc (converterFunc func (_dfeb _e .Image )(Image ,error ))ColorConverter {return colorConverter {_bcd :converterFunc };};func _dacf (_degcb []byte ,_ededd Image )error {_fafg :=true ;for _bdga :=0;
_bdga < len (_degcb );_bdga ++{if _degcb [_bdga ]!=0xff{_fafg =false ;break ;};};if _fafg {switch _eeab :=_ededd .(type ){case *NRGBA32 :_eeab .Alpha =nil ;case *NRGBA64 :_eeab .Alpha =nil ;default:return _ec .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_ededd );
};};return nil ;};func (_bgf *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_bgd :=4*(y *_bgf .Width +x );if _bgd +3>=len (_bgf .Data ){return ;};_bgf .Data [_bgd ]=c .C ;_bgf .Data [_bgd +1]=c .M ;_bgf .Data [_bgd +2]=c .Y ;_bgf .Data [_bgd +3]=c .K ;};func (_cgbda *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_cgbda .Width ,_cgbda .Data ,_cgbda .Alpha ,_cgbda .Decode );
};func IsGrayImgBlackAndWhite (i *_e .Gray )bool {return _aaf (i )};var _ Gray =&Gray8 {};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _faaa (_fcea ,_ebgb RGBA ,_cffce _e .Rectangle ){for _edccc :=0;_edccc < _cffce .Max .X ;_edccc ++{for _eggb :=0;
_eggb < _cffce .Max .Y ;_eggb ++{_ebgb .SetRGBA (_edccc ,_eggb ,_fcea .RGBAAt (_edccc ,_eggb ));};};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _c .Abs (xmax -xmin )< 0.000001{return ymin ;};_ffbb :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );
return _ffbb ;};func _ccdf (_fafb Gray ,_fdab NRGBA ,_eba _e .Rectangle ){for _ebg :=0;_ebg < _eba .Max .X ;_ebg ++{for _fdga :=0;_fdga < _eba .Max .Y ;_fdga ++{_ddff :=_dbd (_fdab .NRGBAAt (_ebg ,_fdga ));_fafb .SetGray (_ebg ,_fdga ,_ddff );};};};func _ece (_cgb *Monochrome ,_ggc int ,_eda []byte )(_afe *Monochrome ,_fag error ){const _bae ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _cgb ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _ggc < 1||_ggc > 4{return nil ,_a .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _cgb .Height <=1{return nil ,_a .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_afe =_adb (_cgb .Width /2,_cgb .Height /2);
if _eda ==nil {_eda =_bbd ();};_gfa :=_dgde (_cgb .BytesPerLine ,2*_afe .BytesPerLine );switch _ggc {case 1:_fag =_aba (_cgb ,_afe ,_eda ,_gfa );case 2:_fag =_gcea (_cgb ,_afe ,_eda ,_gfa );case 3:_fag =_gcff (_cgb ,_afe ,_eda ,_gfa );case 4:_fag =_cegg (_cgb ,_afe ,_eda ,_gfa );
};if _fag !=nil {return nil ,_fag ;};return _afe ,nil ;};func _bbcea (_gdgfg uint8 )bool {if _gdgfg ==0||_gdgfg ==255{return true ;};return false ;};func _dgfc (_dgge CMYK ,_edad RGBA ,_dbaf _e .Rectangle ){for _dbcd :=0;_dbcd < _dbaf .Max .X ;_dbcd ++{for _egagf :=0;
_egagf < _dbaf .Max .Y ;_egagf ++{_bcddd :=_dgge .CMYKAt (_dbcd ,_egagf );_edad .SetRGBA (_dbcd ,_egagf ,_fcda (_bcddd ));};};};func _bgbb (_cbfg _e .Image )(Image ,error ){if _ddec ,_effg :=_cbfg .(*Gray8 );_effg {return _ddec .Copy (),nil ;};_bab :=_cbfg .Bounds ();
_fcdc ,_adbe :=NewImage (_bab .Max .X ,_bab .Max .Y ,8,1,nil ,nil ,nil );if _adbe !=nil {return nil ,_adbe ;};_eec (_cbfg ,_fcdc ,_bab );return _fcdc ,nil ;};func (_gfba *ImageBase )getByte (_fbbaa int )(byte ,error ){if _fbbaa > len (_gfba .Data )-1||_fbbaa < 0{return 0,_ec .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_fbbaa );
};return _gfba .Data [_fbbaa ],nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_gdb *Monochrome )setGray (_feb int ,_dcea _g .Gray ,_aca int ){if _dcea .Y ==0{_gdb .clearBit (_aca ,_feb );}else {_gdb .setGrayBit (_aca ,_feb );
};};type nrgba64 interface{NRGBA64At (_bfgd ,_ddga int )_g .NRGBA64 ;SetNRGBA64 (_bddbd ,_gbfcg int ,_ebfe _g .NRGBA64 );};func (_acdb *Gray16 )Histogram ()(_befcc [256]int ){for _ebgd :=0;_ebgd < _acdb .Width ;_ebgd ++{for _gfggc :=0;_gfggc < _acdb .Height ;
_gfggc ++{_befcc [_acdb .GrayAt (_ebgd ,_gfggc ).Y ]++;};};return _befcc ;};func _ededc (_dbfa *Monochrome ,_gfea ,_cgba ,_aeed ,_aabb int ,_bdde RasterOperator ,_fbga *Monochrome ,_cgg ,_fffa int )error {var (_gdbc bool ;_bgfb bool ;_caca byte ;_cfef int ;
_afbga int ;_bge int ;_gabcg int ;_afg bool ;_dab int ;_adc int ;_fgdf int ;_efef bool ;_eaef byte ;_egdb int ;_fcce int ;_dcdf int ;_gedg byte ;_cgbd int ;_gfdb int ;_abfa uint ;_degcd uint ;_gaga byte ;_fbcd shift ;_edbg bool ;_fgeb bool ;_cace ,_bgdf int ;
);if _cgg &7!=0{_gfdb =8-(_cgg &7);};if _gfea &7!=0{_afbga =8-(_gfea &7);};if _gfdb ==0&&_afbga ==0{_gaga =_egbc [0];}else {if _afbga > _gfdb {_abfa =uint (_afbga -_gfdb );}else {_abfa =uint (8-(_gfdb -_afbga ));};_degcd =8-_abfa ;_gaga =_egbc [_abfa ];
};if (_gfea &7)!=0{_gdbc =true ;_cfef =8-(_gfea &7);_caca =_egbc [_cfef ];_bge =_dbfa .BytesPerLine *_cgba +(_gfea >>3);_gabcg =_fbga .BytesPerLine *_fffa +(_cgg >>3);_cgbd =8-(_cgg &7);if _cfef > _cgbd {_fbcd =_eegf ;if _aeed >=_gfdb {_edbg =true ;};}else {_fbcd =_fcdca ;
};};if _aeed < _cfef {_bgfb =true ;_caca &=_abbg [8-_cfef +_aeed ];};if !_bgfb {_dab =(_aeed -_cfef )>>3;if _dab !=0{_afg =true ;_adc =_dbfa .BytesPerLine *_cgba +((_gfea +_afbga )>>3);_fgdf =_fbga .BytesPerLine *_fffa +((_cgg +_afbga )>>3);};};_egdb =(_gfea +_aeed )&7;
if !(_bgfb ||_egdb ==0){_efef =true ;_eaef =_abbg [_egdb ];_fcce =_dbfa .BytesPerLine *_cgba +((_gfea +_afbga )>>3)+_dab ;_dcdf =_fbga .BytesPerLine *_fffa +((_cgg +_afbga )>>3)+_dab ;if _egdb > int (_degcd ){_fgeb =true ;};};switch _bdde {case PixSrc :if _gdbc {for _cace =0;
_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],_gedg ,_caca );
_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]=_gedg ;
};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],_gedg ,_eaef );
_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;};};case PixNotSrc :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );
};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],^_gedg ,_caca );_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );
_dbfa .Data [_adc +_bgdf ]=^_gedg ;};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );
};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],^_gedg ,_eaef );_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;};};case PixSrcOrDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );
};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],_gedg |_dbfa .Data [_bge ],_caca );_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;
_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]|=_gedg ;};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;
_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],_gedg |_dbfa .Data [_fcce ],_eaef );_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;
};};case PixSrcAndDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],_gedg &_dbfa .Data [_bge ],_caca );
_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]&=_gedg ;
};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],_gedg &_dbfa .Data [_fcce ],_eaef );
_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;};};case PixSrcXorDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );
};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],_gedg ^_dbfa .Data [_bge ],_caca );_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;
_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]^=_gedg ;};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;
_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],_gedg ^_dbfa .Data [_fcce ],_eaef );_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;
};};case PixNotSrcOrDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],^_gedg |_dbfa .Data [_bge ],_caca );
_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]|=^_gedg ;
};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],^_gedg |_dbfa .Data [_fcce ],_eaef );
_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;};};case PixNotSrcAndDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );
};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],^_gedg &_dbfa .Data [_bge ],_caca );_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;
_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]&=^_gedg ;};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;
_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],^_gedg &_dbfa .Data [_fcce ],_eaef );_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;
};};case PixSrcOrNotDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],_gedg |^_dbfa .Data [_bge ],_caca );
_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]=_gedg |^_dbfa .Data [_adc +_bgdf ];
};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],_gedg |^_dbfa .Data [_fcce ],_eaef );
_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;};};case PixSrcAndNotDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );
};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],_gedg &^_dbfa .Data [_bge ],_caca );_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;
_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]=_gedg &^_dbfa .Data [_adc +_bgdf ];};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;
_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],_gedg &^_dbfa .Data [_fcce ],_eaef );_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],^(_gedg |_dbfa .Data [_bge ]),_caca );
_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]=^(_gedg |_dbfa .Data [_adc +_bgdf ]);
};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],^(_gedg |_dbfa .Data [_fcce ]),_eaef );
_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;};};case PixNotPixSrcAndDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );
};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],^(_gedg &_dbfa .Data [_bge ]),_caca );_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;
_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );_dbfa .Data [_adc +_bgdf ]=^(_gedg &_dbfa .Data [_adc +_bgdf ]);};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;
_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],^(_gedg &_dbfa .Data [_fcce ]),_eaef );_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;
};};case PixNotPixSrcXorDst :if _gdbc {for _cace =0;_cace < _aabb ;_cace ++{if _fbcd ==_eegf {_gedg =_fbga .Data [_gabcg ]<<_abfa ;if _edbg {_gedg =_feba (_gedg ,_fbga .Data [_gabcg +1]>>_degcd ,_gaga );};}else {_gedg =_fbga .Data [_gabcg ]>>_degcd ;};
_dbfa .Data [_bge ]=_feba (_dbfa .Data [_bge ],^(_gedg ^_dbfa .Data [_bge ]),_caca );_bge +=_dbfa .BytesPerLine ;_gabcg +=_fbga .BytesPerLine ;};};if _afg {for _cace =0;_cace < _aabb ;_cace ++{for _bgdf =0;_bgdf < _dab ;_bgdf ++{_gedg =_feba (_fbga .Data [_fgdf +_bgdf ]<<_abfa ,_fbga .Data [_fgdf +_bgdf +1]>>_degcd ,_gaga );
_dbfa .Data [_adc +_bgdf ]=^(_gedg ^_dbfa .Data [_adc +_bgdf ]);};_adc +=_dbfa .BytesPerLine ;_fgdf +=_fbga .BytesPerLine ;};};if _efef {for _cace =0;_cace < _aabb ;_cace ++{_gedg =_fbga .Data [_dcdf ]<<_abfa ;if _fgeb {_gedg =_feba (_gedg ,_fbga .Data [_dcdf +1]>>_degcd ,_gaga );
};_dbfa .Data [_fcce ]=_feba (_dbfa .Data [_fcce ],^(_gedg ^_dbfa .Data [_fcce ]),_eaef );_fcce +=_dbfa .BytesPerLine ;_dcdf +=_fbga .BytesPerLine ;};};default:_fb .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_bdde );
return _a .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func (_efdbf *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_efdbf .copy ()}};
func _fd (_ge *Monochrome ,_ae int )(*Monochrome ,error ){if _ge ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ae ==1{return _ge .copy (),nil ;};if !IsPowerOf2 (uint (_ae )){return nil ,_ec .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ae );
};_gfc :=_ff (_ae );return _eb (_ge ,_ae ,_gfc );};func (_gbgf *Monochrome )setIndexedBit (_aec int ){_gbgf .Data [(_aec >>3)]|=0x80>>uint (_aec &7)};var (_abbg =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_egbc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func (_gdab *Monochrome )AddPadding ()(_dec error ){if _dfbe :=((_gdab .Width *_gdab .Height )+7)>>3;len (_gdab .Data )< _dfbe {return _ec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_gdab .Data ),_dfbe );
};_ddfb :=_gdab .Width %8;if _ddfb ==0{return nil ;};_eabbf :=_gdab .Width /8;_bad :=_eg .NewReader (_gdab .Data );_dffd :=make ([]byte ,_gdab .Height *_gdab .BytesPerLine );_abac :=_eg .NewWriterMSB (_dffd );_bde :=make ([]byte ,_eabbf );var (_cbae int ;
_ebbc uint64 ;);for _cbae =0;_cbae < _gdab .Height ;_cbae ++{if _ ,_dec =_bad .Read (_bde );_dec !=nil {return _dec ;};if _ ,_dec =_abac .Write (_bde );_dec !=nil {return _dec ;};if _ebbc ,_dec =_bad .ReadBits (byte (_ddfb ));_dec !=nil {return _dec ;};
if _dec =_abac .WriteByte (byte (_ebbc )<<uint (8-_ddfb ));_dec !=nil {return _dec ;};};_gdab .Data =_abac .Data ();return nil ;};var ErrInvalidImage =_a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_aeff *Gray16 )Validate ()error {if len (_aeff .Data )!=_aeff .Height *_aeff .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_bbec *CMYK32 )Set (x ,y int ,c _g .Color ){_fcg :=4*(y *_bbec .Width +x );if _fcg +3>=len (_bbec .Data ){return ;
};_abbf :=_g .CMYKModel .Convert (c ).(_g .CMYK );_bbec .Data [_fcg ]=_abbf .C ;_bbec .Data [_fcg +1]=_abbf .M ;_bbec .Data [_fcg +2]=_abbf .Y ;_bbec .Data [_fcg +3]=_abbf .K ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;
Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};var _ Gray =&Gray2 {};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_dgd :=4*(y *width +x );if _dgd +3>=len (data ){return _g .CMYK {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_dgd ]&0xff;M :=data [_dgd +1]&0xff;Y :=data [_dgd +2]&0xff;K :=data [_dgd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _ccd (_bef ,_ddc *Monochrome )(_bff error ){_gb :=_ddc .BytesPerLine ;
_bcba :=_bef .BytesPerLine ;var _fc ,_fcf ,_bee ,_gfdg ,_afa int ;for _bee =0;_bee < _ddc .Height ;_bee ++{_fc =_bee *_gb ;_fcf =8*_bee *_bcba ;for _gfdg =0;_gfdg < _gb ;_gfdg ++{if _bff =_bef .setEightBytes (_fcf +_gfdg *8,_fdgf [_ddc .Data [_fc +_gfdg ]]);
_bff !=nil {return _bff ;};};for _afa =1;_afa < 8;_afa ++{for _gfdg =0;_gfdg < _bcba ;_gfdg ++{if _bff =_bef .setByte (_fcf +_afa *_bcba +_gfdg ,_bef .Data [_fcf +_gfdg ]);_bff !=nil {return _bff ;};};};};return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_agdgb :=(y *bytesPerLine /2+x )*2;
if _agdgb +1>=len (data ){return _g .Gray16 {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cedc :=uint16 (data [_agdgb ])<<8|uint16 (data [_agdgb +1]);if len (decode )==2{_cedc =uint16 (uint64 (LinearInterpolate (float64 (_cedc ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_cedc },nil ;};func _abacd (_dcgg NRGBA ,_abbb RGBA ,_fedg _e .Rectangle ){for _fcbd :=0;
_fcbd < _fedg .Max .X ;_fcbd ++{for _geed :=0;_geed < _fedg .Max .Y ;_geed ++{_ecfc :=_dcgg .NRGBAAt (_fcbd ,_geed );_abbb .SetRGBA (_fcbd ,_geed ,_daed (_ecfc ));};};};func _bggc (_aag Gray ,_dcbf CMYK ,_egcf _e .Rectangle ){for _cbec :=0;_cbec < _egcf .Max .X ;
_cbec ++{for _bbaa :=0;_bbaa < _egcf .Max .Y ;_bbaa ++{_gbb :=_aag .GrayAt (_cbec ,_bbaa );_dcbf .SetCMYK (_cbec ,_bbaa ,_efc (_gbb ));};};};var _ Image =&Gray2 {};func (_bffcf *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_a .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_bdea :=_adb (width ,height );_gbbc :=make ([]int ,height );_gceec :=make ([]int ,width );_addb :=float64 (_bffcf .Width )/float64 (width );_cdca :=float64 (_bffcf .Height )/float64 (height );for _gggb :=0;_gggb < height ;_gggb ++{_gbbc [_gggb ]=int (_c .Min (_cdca *float64 (_gggb )+0.5,float64 (_bffcf .Height -1)));
};for _facg :=0;_facg < width ;_facg ++{_gceec [_facg ]=int (_c .Min (_addb *float64 (_facg )+0.5,float64 (_bffcf .Width -1)));};_ggfc :=-1;_bag :=byte (0);for _cfeg :=0;_cfeg < height ;_cfeg ++{_addg :=_gbbc [_cfeg ]*_bffcf .BytesPerLine ;_ffd :=_cfeg *_bdea .BytesPerLine ;
for _bbg :=0;_bbg < width ;_bbg ++{_aebe :=_gceec [_bbg ];if _aebe !=_ggfc {_bag =_bffcf .getBit (_addg ,_aebe );if _bag !=0{_bdea .setBit (_ffd ,_bbg );};_ggfc =_aebe ;}else {if _bag !=0{_bdea .setBit (_ffd ,_bbg );};};};};return _bdea ,nil ;};func (_dacc *RGBA32 )SetRGBA (x ,y int ,c _g .RGBA ){_abaa :=y *_dacc .Width +x ;
_bdabe :=3*_abaa ;if _bdabe +2>=len (_dacc .Data ){return ;};_dacc .setRGBA (_abaa ,c );};func (_gdba *RGBA32 )Base ()*ImageBase {return &_gdba .ImageBase };func _gceaec (_begf _g .NRGBA )_g .NRGBA {_begf .R =_begf .R >>4|(_begf .R >>4)<<4;_begf .G =_begf .G >>4|(_begf .G >>4)<<4;
_begf .B =_begf .B >>4|(_begf .B >>4)<<4;return _begf ;};func (_gcfa *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_gcfa .copy ()}};var (_bce =_ede ();_cg =_gbd ();_fdgf =_bcae (););type Gray2 struct{ImageBase };func _aaf (_aeeee *_e .Gray )bool {for _abec :=0;
_abec < len (_aeeee .Pix );_abec ++{if !_bbcea (_aeeee .Pix [_abec ]){return false ;};};return true ;};func (_efaa *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_cgbf :=_bdc (gray );_fbbe :=y *_efaa .BytesPerLine ;_efcc :=_fbbe +(x >>2);if _efcc >=len (_efaa .Data ){return ;
};_geb :=_cgbf .Y >>6;_efaa .Data [_efcc ]=(_efaa .Data [_efcc ]&(^(0xc0>>uint (2*((x )&3)))))|(_geb <<uint (6-2*(x &3)));};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .RGBA ,error ){_efeae :=y *width +x ;_gbda :=3*_efeae ;
if _gbda +2>=len (data ){return _g .RGBA {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cgab :=uint8 (0xff);if alpha !=nil &&len (alpha )> _efeae {_cgab =alpha [_efeae ];};_gacc ,_ggad ,_geagd :=data [_gbda ],data [_gbda +1],data [_gbda +2];if len (decode )==6{_gacc =uint8 (uint32 (LinearInterpolate (float64 (_gacc ),0,255,decode [0],decode [1]))&0xff);
_ggad =uint8 (uint32 (LinearInterpolate (float64 (_ggad ),0,255,decode [2],decode [3]))&0xff);_geagd =uint8 (uint32 (LinearInterpolate (float64 (_geagd ),0,255,decode [4],decode [5]))&0xff);};return _g .RGBA {R :_gacc ,G :_ggad ,B :_geagd ,A :_cgab },nil ;
};func _eacg (_fbdb Gray ,_accdc RGBA ,_eccc _e .Rectangle ){for _gebffg :=0;_gebffg < _eccc .Max .X ;_gebffg ++{for _cbcg :=0;_cbcg < _eccc .Max .Y ;_cbcg ++{_bfda :=_fbdb .GrayAt (_gebffg ,_cbcg );_accdc .SetRGBA (_gebffg ,_cbcg ,_gabc (_bfda ));};};
};func (_feef *ImageBase )setTwoBytes (_cfdc int ,_gafg uint16 )error {if _cfdc +1> len (_feef .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_feef .Data [_cfdc ]=byte ((_gafg &0xff00)>>8);
_feef .Data [_cfdc +1]=byte (_gafg &0xff);return nil ;};type CMYK32 struct{ImageBase };func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_agadd :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _degg Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_degg =&Monochrome {ImageBase :_agadd ,ModelThreshold :0x0f};case 2:_degg =&Gray2 {ImageBase :_agadd };case 4:_degg =&Gray4 {ImageBase :_agadd };case 8:_degg =&Gray8 {ImageBase :_agadd };
case 16:_degg =&Gray16 {ImageBase :_agadd };};case 3:switch bitsPerComponent {case 4:_degg =&NRGBA16 {ImageBase :_agadd };case 8:_degg =&NRGBA32 {ImageBase :_agadd };case 16:_degg =&NRGBA64 {ImageBase :_agadd };};case 4:_degg =&CMYK32 {ImageBase :_agadd };
};if _degg ==nil {return nil ,ErrInvalidImage ;};return _degg ,nil ;};func (_abg *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };func (_gdee *RGBA32 )setRGBA (_acba int ,_fbfa _g .RGBA ){_cfdg :=3*_acba ;_gdee .Data [_cfdg ]=_fbfa .R ;_gdee .Data [_cfdg +1]=_fbfa .G ;
_gdee .Data [_cfdg +2]=_fbfa .B ;if _acba < len (_gdee .Alpha ){_gdee .Alpha [_acba ]=_fbfa .A ;};};func (_bdb *Monochrome )getBit (_gfgd ,_gbfg int )uint8 {return _bdb .Data [_gfgd +(_gbfg >>3)]>>uint (7-(_gbfg &7))&1;};var _ Image =&Gray4 {};func (_cddf *NRGBA64 )At (x ,y int )_g .Color {_aaab ,_ :=_cddf .ColorAt (x ,y );
return _aaab };func (_ecg *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_ecg .ImageBase .copy (),ModelThreshold :_ecg .ModelThreshold };};func (_deg *Gray8 )Set (x ,y int ,c _g .Color ){_dbda :=y *_deg .BytesPerLine +x ;if _dbda > len (_deg .Data )-1{return ;
};_gebf :=_g .GrayModel .Convert (c );_deg .Data [_dbda ]=_gebf .(_g .Gray ).Y ;};func _dacg (_ebff ,_eegb uint8 )uint8 {if _ebff < _eegb {return 255;};return 0;};var _ Gray =&Gray16 {};func (_eee *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_eee .Width ,_eee .Data ,_eee .Decode );
};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_gf :=BytesPerLine (width ,8,1);if len (data )< _gf *height {return nil ,nil ;};_egd :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_ad ,_cf :=MonochromeConverter .Convert (_egd );
if _cf !=nil {return nil ,_cf ;};return _ad .Base ().Data ,nil ;};func _dbac (_fdbd *Monochrome ,_egaf ,_cafa int ,_bebb ,_bdeaf int ,_cdcf RasterOperator ){var (_dcbe int ;_fcfa byte ;_ggbe ,_dgdc int ;_fgca int ;);_cgfe :=_bebb >>3;_aff :=_bebb &7;if _aff > 0{_fcfa =_abbg [_aff ];
};_dcbe =_fdbd .BytesPerLine *_cafa +(_egaf >>3);switch _cdcf {case PixClr :for _ggbe =0;_ggbe < _bdeaf ;_ggbe ++{_fgca =_dcbe +_ggbe *_fdbd .BytesPerLine ;for _dgdc =0;_dgdc < _cgfe ;_dgdc ++{_fdbd .Data [_fgca ]=0x0;_fgca ++;};if _aff > 0{_fdbd .Data [_fgca ]=_feba (_fdbd .Data [_fgca ],0x0,_fcfa );
};};case PixSet :for _ggbe =0;_ggbe < _bdeaf ;_ggbe ++{_fgca =_dcbe +_ggbe *_fdbd .BytesPerLine ;for _dgdc =0;_dgdc < _cgfe ;_dgdc ++{_fdbd .Data [_fgca ]=0xff;_fgca ++;};if _aff > 0{_fdbd .Data [_fgca ]=_feba (_fdbd .Data [_fgca ],0xff,_fcfa );};};case PixNotDst :for _ggbe =0;
_ggbe < _bdeaf ;_ggbe ++{_fgca =_dcbe +_ggbe *_fdbd .BytesPerLine ;for _dgdc =0;_dgdc < _cgfe ;_dgdc ++{_fdbd .Data [_fgca ]=^_fdbd .Data [_fgca ];_fgca ++;};if _aff > 0{_fdbd .Data [_fgca ]=_feba (_fdbd .Data [_fgca ],^_fdbd .Data [_fgca ],_fcfa );};};
};};var _ Image =&CMYK32 {};func (_cdc *CMYK32 )At (x ,y int )_g .Color {_gaa ,_ :=_cdc .ColorAt (x ,y );return _gaa };func _bfc (_ged _g .NYCbCrA )_g .NRGBA {_fcb :=int32 (_ged .Y )*0x10101;_feg :=int32 (_ged .Cb )-128;_eac :=int32 (_ged .Cr )-128;_aacd :=_fcb +91881*_eac ;
if uint32 (_aacd )&0xff000000==0{_aacd >>=8;}else {_aacd =^(_aacd >>31)&0xffff;};_edbc :=_fcb -22554*_feg -46802*_eac ;if uint32 (_edbc )&0xff000000==0{_edbc >>=8;}else {_edbc =^(_edbc >>31)&0xffff;};_efgd :=_fcb +116130*_feg ;if uint32 (_efgd )&0xff000000==0{_efgd >>=8;
}else {_efgd =^(_efgd >>31)&0xffff;};return _g .NRGBA {R :uint8 (_aacd >>8),G :uint8 (_edbc >>8),B :uint8 (_efgd >>8),A :_ged .A };};func (_defc *ImageBase )newAlpha (){_gfcc :=BytesPerLine (_defc .Width ,_defc .BitsPerComponent ,1);_defc .Alpha =make ([]byte ,_defc .Height *_gfcc );
};func (_ddbc *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };func _dfg (_gfag ,_ddcd int ,_fba []byte )*Monochrome {_cae :=_adb (_gfag ,_ddcd );_cae .Data =_fba ;return _cae ;};func _dfab (_aee _g .Gray )_g .NRGBA {return _g .NRGBA {R :_aee .Y ,G :_aee .Y ,B :_aee .Y ,A :0xff}};
func _eabg (_gcd _g .NRGBA64 )_g .Gray {var _dgf _g .NRGBA64 ;if _gcd ==_dgf {return _g .Gray {Y :0xff};};_fea ,_faba ,_deea ,_ :=_gcd .RGBA ();_eeaf :=(19595*_fea +38470*_faba +7471*_deea +1<<15)>>24;return _g .Gray {Y :uint8 (_eeaf )};};func _cegg (_geaa ,_fbc *Monochrome ,_bfa []byte ,_bac int )(_bfad error ){var (_daac ,_ade ,_acb ,_aga ,_bdg ,_dba ,_gbf ,_gcc int ;
_gde ,_dbg uint32 ;_bgg ,_eed byte ;_fbbf uint16 ;);_eede :=make ([]byte ,4);_dad :=make ([]byte ,4);for _acb =0;_acb < _geaa .Height -1;_acb ,_aga =_acb +2,_aga +1{_daac =_acb *_geaa .BytesPerLine ;_ade =_aga *_fbc .BytesPerLine ;for _bdg ,_dba =0,0;_bdg < _bac ;
_bdg ,_dba =_bdg +4,_dba +1{for _gbf =0;_gbf < 4;_gbf ++{_gcc =_daac +_bdg +_gbf ;if _gcc <=len (_geaa .Data )-1&&_gcc < _daac +_geaa .BytesPerLine {_eede [_gbf ]=_geaa .Data [_gcc ];}else {_eede [_gbf ]=0x00;};_gcc =_daac +_geaa .BytesPerLine +_bdg +_gbf ;
if _gcc <=len (_geaa .Data )-1&&_gcc < _daac +(2*_geaa .BytesPerLine ){_dad [_gbf ]=_geaa .Data [_gcc ];}else {_dad [_gbf ]=0x00;};};_gde =_ab .BigEndian .Uint32 (_eede );_dbg =_ab .BigEndian .Uint32 (_dad );_dbg &=_gde ;_dbg &=_dbg <<1;_dbg &=0xaaaaaaaa;
_gde =_dbg |(_dbg <<7);_bgg =byte (_gde >>24);_eed =byte ((_gde >>8)&0xff);_gcc =_ade +_dba ;if _gcc +1==len (_fbc .Data )-1||_gcc +1>=_ade +_fbc .BytesPerLine {_fbc .Data [_gcc ]=_bfa [_bgg ];if _bfad =_fbc .setByte (_gcc ,_bfa [_bgg ]);_bfad !=nil {return _ec .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gcc );
};}else {_fbbf =(uint16 (_bfa [_bgg ])<<8)|uint16 (_bfa [_eed ]);if _bfad =_fbc .setTwoBytes (_gcc ,_fbbf );_bfad !=nil {return _ec .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gcc );
};_dba ++;};};};return nil ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ec .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_ebc *NRGBA16 )Validate ()error {if len (_ebc .Data )!=3*_ebc .Width *_ebc .Height /2{return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gacbf *Gray2 )Histogram ()(_fcba [256]int ){for _cegb :=0;_cegb < _gacbf .Width ;_cegb ++{for _addf :=0;_addf < _gacbf .Height ;_addf ++{_fcba [_gacbf .GrayAt (_cegb ,_addf ).Y ]++;};};return _fcba ;};func _gabc (_cadf _g .Gray )_g .RGBA {return _g .RGBA {R :_cadf .Y ,G :_cadf .Y ,B :_cadf .Y ,A :0xff}};
func _gbd ()(_ddca [256]uint32 ){for _fac :=0;_fac < 256;_fac ++{if _fac &0x01!=0{_ddca [_fac ]|=0xf;};if _fac &0x02!=0{_ddca [_fac ]|=0xf0;};if _fac &0x04!=0{_ddca [_fac ]|=0xf00;};if _fac &0x08!=0{_ddca [_fac ]|=0xf000;};if _fac &0x10!=0{_ddca [_fac ]|=0xf0000;
};if _fac &0x20!=0{_ddca [_fac ]|=0xf00000;};if _fac &0x40!=0{_ddca [_fac ]|=0xf000000;};if _fac &0x80!=0{_ddca [_fac ]|=0xf0000000;};};return _ddca ;};type shift int ;func (_ceaaf *Gray16 )Base ()*ImageBase {return &_ceaaf .ImageBase };func (_aeege *RGBA32 )Validate ()error {if len (_aeege .Data )!=3*_aeege .Width *_aeege .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_facd (n )+1);};