//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_be "encoding/binary";_e "errors";_beg "fmt";_ec "github.com/unidoc/unipdf/v4/common";_c "github.com/unidoc/unipdf/v4/internal/bitwise";_ge "image";_g "image/color";_fc "image/draw";_b "math";);type RasterOperator int ;func (_faf *Gray16 )Histogram ()(_eecf [256]int ){for _bbge :=0;
_bbge < _faf .Width ;_bbge ++{for _cdad :=0;_cdad < _faf .Height ;_cdad ++{_eecf [_faf .GrayAt (_bbge ,_cdad ).Y ]++;};};return _eecf ;};func (_bebcd *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_beg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _fa (_bebcd ,factor );};func _aaed (_aacb *Monochrome ,_fbdg ,_gcbb int ,_cbbg ,_cdff int ,_agb RasterOperator ,_ceeg *Monochrome ,_agbd ,_fedb int )error {var _gegef ,_deacg ,_abg ,_befb int ;if _fbdg < 0{_agbd -=_fbdg ;_cbbg +=_fbdg ;_fbdg =0;
};if _agbd < 0{_fbdg -=_agbd ;_cbbg +=_agbd ;_agbd =0;};_gegef =_fbdg +_cbbg -_aacb .Width ;if _gegef > 0{_cbbg -=_gegef ;};_deacg =_agbd +_cbbg -_ceeg .Width ;if _deacg > 0{_cbbg -=_deacg ;};if _gcbb < 0{_fedb -=_gcbb ;_cdff +=_gcbb ;_gcbb =0;};if _fedb < 0{_gcbb -=_fedb ;
_cdff +=_fedb ;_fedb =0;};_abg =_gcbb +_cdff -_aacb .Height ;if _abg > 0{_cdff -=_abg ;};_befb =_fedb +_cdff -_ceeg .Height ;if _befb > 0{_cdff -=_befb ;};if _cbbg <=0||_cdff <=0{return nil ;};var _fcca error ;switch {case _fbdg &7==0&&_agbd &7==0:_fcca =_aabd (_aacb ,_fbdg ,_gcbb ,_cbbg ,_cdff ,_agb ,_ceeg ,_agbd ,_fedb );
case _fbdg &7==_agbd &7:_fcca =_geeb (_aacb ,_fbdg ,_gcbb ,_cbbg ,_cdff ,_agb ,_ceeg ,_agbd ,_fedb );default:_fcca =_eebbb (_aacb ,_fbdg ,_gcbb ,_cbbg ,_cdff ,_agb ,_ceeg ,_agbd ,_fedb );};if _fcca !=nil {return _fcca ;};return nil ;};func _baac (_fgd _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_fgd .Y }};
func _eabd (_bbd _g .Color )_g .Color {_dbd :=_g .GrayModel .Convert (_bbd ).(_g .Gray );return _cbeg (_dbd )};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_ega *Monochrome )AddPadding ()(_eecb error ){if _gcad :=((_ega .Width *_ega .Height )+7)>>3;
len (_ega .Data )< _gcad {return _beg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_ega .Data ),_gcad );
};_adee :=_ega .Width %8;if _adee ==0{return nil ;};_efba :=_ega .Width /8;_fge :=_c .NewReader (_ega .Data );_ffa :=make ([]byte ,_ega .Height *_ega .BytesPerLine );_bgga :=_c .NewWriterMSB (_ffa );_gfd :=make ([]byte ,_efba );var (_egad int ;_dgeg uint64 ;
);for _egad =0;_egad < _ega .Height ;_egad ++{if _ ,_eecb =_fge .Read (_gfd );_eecb !=nil {return _eecb ;};if _ ,_eecb =_bgga .Write (_gfd );_eecb !=nil {return _eecb ;};if _dgeg ,_eecb =_fge .ReadBits (byte (_adee ));_eecb !=nil {return _eecb ;};if _eecb =_bgga .WriteByte (byte (_dgeg )<<uint (8-_adee ));
_eecb !=nil {return _eecb ;};};_ega .Data =_bgga .Data ();return nil ;};func _cffd (_gebc _g .Gray ,_bfbc monochromeModel )_g .Gray {if _gebc .Y > uint8 (_bfbc ){return _g .Gray {Y :_b .MaxUint8 };};return _g .Gray {};};func _bda (_ebd ,_aace *Monochrome ,_dgb []byte ,_bbg int )(_cbf error ){var (_fad ,_fbe ,_ebc ,_aff ,_aecb ,_egf ,_aae ,_fddc int ;
_bbf ,_cfe ,_acba ,_adb uint32 ;_gbbg ,_gcg byte ;_egg uint16 ;);_acf :=make ([]byte ,4);_dace :=make ([]byte ,4);for _ebc =0;_ebc < _ebd .Height -1;_ebc ,_aff =_ebc +2,_aff +1{_fad =_ebc *_ebd .BytesPerLine ;_fbe =_aff *_aace .BytesPerLine ;for _aecb ,_egf =0,0;
_aecb < _bbg ;_aecb ,_egf =_aecb +4,_egf +1{for _aae =0;_aae < 4;_aae ++{_fddc =_fad +_aecb +_aae ;if _fddc <=len (_ebd .Data )-1&&_fddc < _fad +_ebd .BytesPerLine {_acf [_aae ]=_ebd .Data [_fddc ];}else {_acf [_aae ]=0x00;};_fddc =_fad +_ebd .BytesPerLine +_aecb +_aae ;
if _fddc <=len (_ebd .Data )-1&&_fddc < _fad +(2*_ebd .BytesPerLine ){_dace [_aae ]=_ebd .Data [_fddc ];}else {_dace [_aae ]=0x00;};};_bbf =_be .BigEndian .Uint32 (_acf );_cfe =_be .BigEndian .Uint32 (_dace );_acba =_bbf &_cfe ;_acba |=_acba <<1;_adb =_bbf |_cfe ;
_adb &=_adb <<1;_cfe =_acba |_adb ;_cfe &=0xaaaaaaaa;_bbf =_cfe |(_cfe <<7);_gbbg =byte (_bbf >>24);_gcg =byte ((_bbf >>8)&0xff);_fddc =_fbe +_egf ;if _fddc +1==len (_aace .Data )-1||_fddc +1>=_fbe +_aace .BytesPerLine {if _cbf =_aace .setByte (_fddc ,_dgb [_gbbg ]);
_cbf !=nil {return _beg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fddc );};}else {_egg =(uint16 (_dgb [_gbbg ])<<8)|uint16 (_dgb [_gcg ]);if _cbf =_aace .setTwoBytes (_fddc ,_egg );_cbf !=nil {return _beg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fddc );
};_egf ++;};};};return nil ;};func (_efgf *Gray2 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_efgf .Width ,Y :_efgf .Height }};};func (_fgac *Gray16 )Validate ()error {if len (_fgac .Data )!=_fgac .Height *_fgac .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _cgbb (_aca *Monochrome ,_ggaf ...int )(_daa *Monochrome ,_fdg error ){if _aca ==nil {return nil ,_e .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_ggaf )==0{return nil ,_e .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_eeb :=_ced ();_daa =_aca ;for _ ,_ddb :=range _ggaf {if _ddb <=0{break ;};_daa ,_fdg =_ggd (_daa ,_ddb ,_eeb );if _fdg !=nil {return nil ,_fdg ;};};return _daa ,nil ;};func (_abdd *NRGBA64 )Validate ()error {if len (_abdd .Data )!=3*2*_abdd .Width *_abdd .Height {return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type Gray8 struct{ImageBase };func (_fcfb *NRGBA16 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_fcfb .Width ,Y :_fcfb .Height }};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _aeeee (_bgbc _ge .Image )(Image ,error ){if _efcc ,_eaab :=_bgbc .(*NRGBA32 );
_eaab {return _efcc .Copy (),nil ;};_gebbc ,_gebed ,_egbd :=_eaff (_bgbc ,1);_gbdd ,_edbb :=NewImage (_gebbc .Max .X ,_gebbc .Max .Y ,8,3,nil ,_egbd ,nil );if _edbb !=nil {return nil ,_edbb ;};_adae (_bgbc ,_gbdd ,_gebbc );if len (_egbd )!=0&&!_gebed {if _fbga :=_cfac (_egbd ,_gbdd );
_fbga !=nil {return nil ,_fbga ;};};return _gbdd ,nil ;};func _faab (_fagg _ge .Image ,_ebccb Image ,_bgaa _ge .Rectangle ){if _effa ,_gdfb :=_fagg .(SMasker );_gdfb &&_effa .HasAlpha (){_ebccb .(SMasker ).MakeAlpha ();};_ede (_fagg ,_ebccb ,_bgaa );};
func (_bbfe *Monochrome )setGray (_agf int ,_aeg _g .Gray ,_gfc int ){if _aeg .Y ==0{_bbfe .clearBit (_gfc ,_agf );}else {_bbfe .setGrayBit (_gfc ,_agf );};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;
PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;
PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);var _acdc [256]uint8 ;
func _aabd (_aecbf *Monochrome ,_eagb ,_bcdee ,_dcgd ,_cfdf int ,_cedg RasterOperator ,_bfbe *Monochrome ,_cdadc ,_bgfbe int )error {var (_dfdc byte ;_bca int ;_bfbff int ;_bbeg ,_bbea int ;_dcdg ,_agfa int ;);_egga :=_dcgd >>3;_bacc :=_dcgd &7;if _bacc > 0{_dfdc =_fbfg [_bacc ];
};_bca =_bfbe .BytesPerLine *_bgfbe +(_cdadc >>3);_bfbff =_aecbf .BytesPerLine *_bcdee +(_eagb >>3);switch _cedg {case PixSrc :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;
_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]=_bfbe .Data [_bbeg ];_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],_bfbe .Data [_bbeg ],_dfdc );};};case PixNotSrc :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;
_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]=^(_bfbe .Data [_bbeg ]);_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],^_bfbe .Data [_bbeg ],_dfdc );};};case PixSrcOrDst :for _dcdg =0;
_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]|=_bfbe .Data [_bbeg ];_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],_bfbe .Data [_bbeg ]|_aecbf .Data [_bbea ],_dfdc );
};};case PixSrcAndDst :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]&=_bfbe .Data [_bbeg ];_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],_bfbe .Data [_bbeg ]&_aecbf .Data [_bbea ],_dfdc );
};};case PixSrcXorDst :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]^=_bfbe .Data [_bbeg ];_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],_bfbe .Data [_bbeg ]^_aecbf .Data [_bbea ],_dfdc );
};};case PixNotSrcOrDst :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]|=^(_bfbe .Data [_bbeg ]);_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],^(_bfbe .Data [_bbeg ])|_aecbf .Data [_bbea ],_dfdc );
};};case PixNotSrcAndDst :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]&=^(_bfbe .Data [_bbeg ]);_bbea ++;_bbeg ++;};
if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],^(_bfbe .Data [_bbeg ])&_aecbf .Data [_bbea ],_dfdc );};};case PixSrcOrNotDst :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;
for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]=_bfbe .Data [_bbeg ]|^(_aecbf .Data [_bbea ]);_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],_bfbe .Data [_bbeg ]|^(_aecbf .Data [_bbea ]),_dfdc );};};case PixSrcAndNotDst :for _dcdg =0;
_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]=_bfbe .Data [_bbeg ]&^(_aecbf .Data [_bbea ]);_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],_bfbe .Data [_bbeg ]&^(_aecbf .Data [_bbea ]),_dfdc );
};};case PixNotPixSrcOrDst :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]=^(_bfbe .Data [_bbeg ]|_aecbf .Data [_bbea ]);
_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],^(_bfbe .Data [_bbeg ]|_aecbf .Data [_bbea ]),_dfdc );};};case PixNotPixSrcAndDst :for _dcdg =0;_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;
for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]=^(_bfbe .Data [_bbeg ]&_aecbf .Data [_bbea ]);_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],^(_bfbe .Data [_bbeg ]&_aecbf .Data [_bbea ]),_dfdc );};};case PixNotPixSrcXorDst :for _dcdg =0;
_dcdg < _cfdf ;_dcdg ++{_bbeg =_bca +_dcdg *_bfbe .BytesPerLine ;_bbea =_bfbff +_dcdg *_aecbf .BytesPerLine ;for _agfa =0;_agfa < _egga ;_agfa ++{_aecbf .Data [_bbea ]=^(_bfbe .Data [_bbeg ]^_aecbf .Data [_bbea ]);_bbea ++;_bbeg ++;};if _bacc > 0{_aecbf .Data [_bbea ]=_bbgb (_aecbf .Data [_bbea ],^(_bfbe .Data [_bbeg ]^_aecbf .Data [_bbea ]),_dfdc );
};};default:_ec .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_cedg );return _e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _bdb (_gdbf _g .NRGBA64 )_g .Gray {var _eda _g .NRGBA64 ;if _gdbf ==_eda {return _g .Gray {Y :0xff};};_gaa ,_def ,_dagc ,_ :=_gdbf .RGBA ();_cege :=(19595*_gaa +38470*_def +7471*_dagc +1<<15)>>24;return _g .Gray {Y :uint8 (_cege )};
};var _ _ge .Image =&Gray8 {};func (_bcba *RGBA32 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_bcba .Width ,Y :_bcba .Height }};};var _ Image =&Gray16 {};type Histogramer interface{Histogram ()[256]int ;};func _gac (_dgc ,_ggf CMYK ,_gbbf _ge .Rectangle ){for _dbc :=0;
_dbc < _gbbf .Max .X ;_dbc ++{for _dga :=0;_dga < _gbbf .Max .Y ;_dga ++{_ggf .SetCMYK (_dbc ,_dga ,_dgc .CMYKAt (_dbc ,_dga ));};};};func (_cfeg *Monochrome )ResolveDecode ()error {if len (_cfeg .Decode )!=2{return nil ;};if _cfeg .Decode [0]==1&&_cfeg .Decode [1]==0{if _gcac :=_cfeg .InverseData ();
_gcac !=nil {return _gcac ;};_cfeg .Decode =nil ;};return nil ;};func _geb (_gdgd _g .NYCbCrA )_g .RGBA {_aba ,_cbc ,_bfca ,_fegc :=_bbfc (_gdgd ).RGBA ();return _g .RGBA {R :uint8 (_aba >>8),G :uint8 (_cbc >>8),B :uint8 (_bfca >>8),A :uint8 (_fegc >>8)};
};type shift int ;func (_babg *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gae (_babg ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _gae (_acfd *Monochrome ,_edbd ,_fdb ,_aead ,_cdbc int ,_abcc RasterOperator ,_fgde *Monochrome ,_gebcb ,_dfgbe int )error {if _acfd ==nil {return _e .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _abcc ==PixDst {return nil ;};switch _abcc {case PixClr ,PixSet ,PixNotDst :_decc (_acfd ,_edbd ,_fdb ,_aead ,_cdbc ,_abcc );return nil ;};if _fgde ==nil {_ec .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _e .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _fdbb :=_aaed (_acfd ,_edbd ,_fdb ,_aead ,_cdbc ,_abcc ,_fgde ,_gebcb ,_dfgbe );_fdbb !=nil {return _fdbb ;};return nil ;};type Gray16 struct{ImageBase };
func _acg ()(_bfc [256]uint32 ){for _ad :=0;_ad < 256;_ad ++{if _ad &0x01!=0{_bfc [_ad ]|=0xf;};if _ad &0x02!=0{_bfc [_ad ]|=0xf0;};if _ad &0x04!=0{_bfc [_ad ]|=0xf00;};if _ad &0x08!=0{_bfc [_ad ]|=0xf000;};if _ad &0x10!=0{_bfc [_ad ]|=0xf0000;};if _ad &0x20!=0{_bfc [_ad ]|=0xf00000;
};if _ad &0x40!=0{_bfc [_ad ]|=0xf000000;};if _ad &0x80!=0{_bfc [_ad ]|=0xf0000000;};};return _bfc ;};func (_gbgb *RGBA32 )At (x ,y int )_g .Color {_baec ,_ :=_gbgb .ColorAt (x ,y );return _baec };func _gbef (_dcae _g .CMYK )_g .Gray {_deeg ,_bac ,_bcbc :=_g .CMYKToRGB (_dcae .C ,_dcae .M ,_dcae .Y ,_dcae .K );
_bfg :=(19595*uint32 (_deeg )+38470*uint32 (_bac )+7471*uint32 (_bcbc )+1<<7)>>16;return _g .Gray {Y :uint8 (_bfg )};};func (_caee *ImageBase )copy ()ImageBase {_fcbd :=*_caee ;_fcbd .Data =make ([]byte ,len (_caee .Data ));copy (_fcbd .Data ,_caee .Data );
return _fcbd ;};type NRGBA16 struct{ImageBase };func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_gd :=BytesPerLine (width ,8,1);if len (data )< _gd *height {return nil ,nil ;};_cd :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};
_ce ,_a :=MonochromeConverter .Convert (_cd );if _a !=nil {return nil ,_a ;};return _ce .Base ().Data ,nil ;};func (_bfdd *Gray2 )ColorModel ()_g .Model {return Gray2Model };func _cad (_ead _g .RGBA )_g .Gray {_ceae :=(19595*uint32 (_ead .R )+38470*uint32 (_ead .G )+7471*uint32 (_ead .B )+1<<7)>>16;
return _g .Gray {Y :uint8 (_ceae )};};type CMYK32 struct{ImageBase };func (_ecc *RGBA32 )Set (x ,y int ,c _g .Color ){_bdfbf :=y *_ecc .Width +x ;_fcbg :=3*_bdfbf ;if _fcbg +2>=len (_ecc .Data ){return ;};_fbda :=_g .RGBAModel .Convert (c ).(_g .RGBA );
_ecc .setRGBA (_bdfbf ,_fbda );};func _aggd (_dbbd _ge .Image )(Image ,error ){if _dcag ,_acgg :=_dbbd .(*RGBA32 );_acgg {return _dcag .Copy (),nil ;};_aagbc ,_ecge ,_bbcg :=_eaff (_dbbd ,1);_bdea :=&RGBA32 {ImageBase :NewImageBase (_aagbc .Max .X ,_aagbc .Max .Y ,8,3,nil ,_bbcg ,nil )};
_bbggf (_dbbd ,_bdea ,_aagbc );if len (_bbcg )!=0&&!_ecge {if _dfdb :=_cfac (_bbcg ,_bdea );_dfdb !=nil {return nil ,_dfdb ;};};return _bdea ,nil ;};func _ggd (_fba *Monochrome ,_cbg int ,_ed []byte )(_aeb *Monochrome ,_dffc error ){const _dfd ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _fba ==nil {return nil ,_e .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _cbg < 1||_cbg > 4{return nil ,_e .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _fba .Height <=1{return nil ,_e .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_aeb =_aee (_fba .Width /2,_fba .Height /2);
if _ed ==nil {_ed =_ced ();};_feb :=_gfcg (_fba .BytesPerLine ,2*_aeb .BytesPerLine );switch _cbg {case 1:_dffc =_aec (_fba ,_aeb ,_ed ,_feb );case 2:_dffc =_bda (_fba ,_aeb ,_ed ,_feb );case 3:_dffc =_fabe (_fba ,_aeb ,_ed ,_feb );case 4:_dffc =_dea (_fba ,_aeb ,_ed ,_feb );
};if _dffc !=nil {return nil ,_dffc ;};return _aeb ,nil ;};var _ _ge .Image =&NRGBA64 {};func (_bdbc monochromeModel )Convert (c _g .Color )_g .Color {_adca :=_g .GrayModel .Convert (c ).(_g .Gray );return _cffd (_adca ,_bdbc );};func (_fbgc *Monochrome )IsUnpadded ()bool {return (_fbgc .Width *_fbgc .Height )==len (_fbgc .Data )};
func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};func (_bbae *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _gaf bool ;_dfbb :=scale ;if scale < 1{_dfbb =1/scale ;_gaf =true ;};_dfff :=NextPowerOf2 (uint (_dfbb ));
if InDelta (float64 (_dfff ),_dfbb ,0.001){if _gaf {return _bbae .ReduceBinary (_dfbb );};return _bbae .ExpandBinary (int (_dfff ));};_bfde :=int (_b .RoundToEven (float64 (_bbae .Width )*scale ));_bfbb :=int (_b .RoundToEven (float64 (_bbae .Height )*scale ));
return _bbae .ScaleLow (_bfde ,_bfbb );};const (_afab shift =iota ;_dgab ;);func (_ggce *RGBA32 )SetRGBA (x ,y int ,c _g .RGBA ){_dggb :=y *_ggce .Width +x ;_cgcc :=3*_dggb ;if _cgcc +2>=len (_ggce .Data ){return ;};_ggce .setRGBA (_dggb ,c );};func (_fgcb *ImageBase )setEightPartlyBytes (_dcff ,_abe int ,_ecee uint64 )(_aeag error ){var (_bdc byte ;
_beaaf int ;);for _gec :=1;_gec <=_abe ;_gec ++{_beaaf =64-_gec *8;_bdc =byte (_ecee >>uint (_beaaf )&0xff);if _aeag =_fgcb .setByte (_dcff +_gec -1,_bdc );_aeag !=nil {return _aeag ;};};_fdaeg :=_fgcb .BytesPerLine *8-_fgcb .Width ;if _fdaeg ==0{return nil ;
};_beaaf -=8;_bdc =byte (_ecee >>uint (_beaaf )&0xff)<<uint (_fdaeg );if _aeag =_fgcb .setByte (_dcff +_abe ,_bdc );_aeag !=nil {return _aeag ;};return nil ;};func (_ebgg *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_ebgg .BytesPerLine ,_ebgg .Data ,_ebgg .Decode );
};func _feff (_cefa ,_ffbc uint8 )uint8 {if _cefa < _ffbc {return 255;};return 0;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _dgdf ,_ceee ,_gfac ,_ddgab int ;for _fdcg :=0;_fdcg < len (histogram );_fdcg ++{if histogram [_fdcg ]> 0{_dgdf =_fdcg ;
break ;};};if _dgdf > 0{_dgdf --;};for _gbee :=255;_gbee > 0;_gbee --{if histogram [_gbee ]> 0{_ddgab =_gbee ;break ;};};if _ddgab < 255{_ddgab ++;};for _dbf :=0;_dbf < 256;_dbf ++{if histogram [_dbf ]> _ceee {_gfac =_dbf ;_ceee =histogram [_dbf ];};};
var _eebbf bool ;if (_gfac -_dgdf )< (_ddgab -_gfac ){_eebbf =true ;var _gdace int ;_dddg :=255;for _gdace < _dddg {_ffgd :=histogram [_gdace ];histogram [_gdace ]=histogram [_dddg ];histogram [_dddg ]=_ffgd ;_gdace ++;_dddg --;};_dgdf =255-_ddgab ;_gfac =255-_gfac ;
};if _dgdf ==_gfac {return uint8 (_dgdf );};_cfbb :=float64 (histogram [_gfac ]);_cded :=float64 (_dgdf -_gfac );_egfc :=_b .Sqrt (_cfbb *_cfbb +_cded *_cded );_cfbb /=_egfc ;_cded /=_egfc ;_egfc =_cfbb *float64 (_dgdf )+_cded *float64 (histogram [_dgdf ]);
_bfcb :=_dgdf ;var _fcbdb float64 ;for _bgcb :=_dgdf +1;_bgcb <=_gfac ;_bgcb ++{_ccdc :=_cfbb *float64 (_bgcb )+_cded *float64 (histogram [_bgcb ])-_egfc ;if _ccdc > _fcbdb {_bfcb =_bgcb ;_fcbdb =_ccdc ;};};_bfcb --;if _eebbf {var _gacc int ;_dgag :=255;
for _gacc < _dgag {_cfcfa :=histogram [_gacc ];histogram [_gacc ]=histogram [_dgag ];histogram [_dgag ]=_cfcfa ;_gacc ++;_dgag --;};return uint8 (255-_bfcb );};return uint8 (_bfcb );};type monochromeModel uint8 ;func (_fadf *Gray8 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_fadf .Width ,Y :_fadf .Height }};
};func _ecb (){for _bgfb :=0;_bgfb < 256;_bgfb ++{_acdc [_bgfb ]=uint8 (_bgfb &0x1)+(uint8 (_bgfb >>1)&0x1)+(uint8 (_bgfb >>2)&0x1)+(uint8 (_bgfb >>3)&0x1)+(uint8 (_bgfb >>4)&0x1)+(uint8 (_bgfb >>5)&0x1)+(uint8 (_bgfb >>6)&0x1)+(uint8 (_bgfb >>7)&0x1);
};};func (_cdc *CMYK32 )Base ()*ImageBase {return &_cdc .ImageBase };func (_cacb *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };func (_cff *Monochrome )InverseData ()error {return _cff .RasterOperation (0,0,_cff .Width ,_cff .Height ,PixNotDst ,nil ,0,0);
};func (_babbb *RGBA32 )setRGBA (_agga int ,_eaeb _g .RGBA ){_eggg :=3*_agga ;_babbb .Data [_eggg ]=_eaeb .R ;_babbb .Data [_eggg +1]=_eaeb .G ;_babbb .Data [_eggg +2]=_eaeb .B ;if _agga < len (_babbb .Alpha ){_babbb .Alpha [_agga ]=_eaeb .A ;};};func _bgdg (_bfbbe uint )uint {var _edef uint ;
for _bfbbe !=0{_bfbbe >>=1;_edef ++;};return _edef -1;};func _cbeg (_gbfd _g .Gray )_g .Gray {_dafg :=_gbfd .Y >>6;_dafg |=_dafg <<2;_gbfd .Y =_dafg |_dafg <<4;return _gbfd ;};func (_abcg *NRGBA16 )Set (x ,y int ,c _g .Color ){_agdgc :=y *_abcg .BytesPerLine +x *3/2;
if _agdgc +1>=len (_abcg .Data ){return ;};_fecg :=NRGBA16Model .Convert (c ).(_g .NRGBA );_abcg .setNRGBA (x ,y ,_agdgc ,_fecg );};func (_cfggg *ImageBase )GetAlpha ()[]byte {return _cfggg .Alpha };func init (){_ecb ()};func _bddcaf (_fcef nrgba64 ,_ggae RGBA ,_bfef _ge .Rectangle ){for _addc :=0;
_addc < _bfef .Max .X ;_addc ++{for _fbdb :=0;_fbdb < _bfef .Max .Y ;_fbdb ++{_dcga :=_fcef .NRGBA64At (_addc ,_fbdb );_ggae .SetRGBA (_addc ,_fbdb ,_fabd (_dcga ));};};};type Image interface{_fc .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_eegd ,_fdaa int )(_g .Color ,error );
Validate ()error ;};func (_bfeg *RGBA32 )Validate ()error {if len (_bfeg .Data )!=3*_bfeg .Width *_bfeg .Height {return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_eebb :=y *bytesPerLine +x >>1;if _eebb >=len (data ){return _g .Gray {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cfff :=data [_eebb ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_cfff =uint8 (uint32 (LinearInterpolate (float64 (_cfff ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_cfff *17&0xff},nil ;};func (_efga *Monochrome )getBit (_eacg ,_cecf int )uint8 {return _efga .Data [_eacg +(_cecf >>3)]>>uint (7-(_cecf &7))&1;
};var _ Image =&Gray4 {};func (_dagd *RGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };var _ _ge .Image =&Gray2 {};func (_afd *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_e .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_edd :=_aee (width ,height );_edc :=make ([]int ,height );_bgef :=make ([]int ,width );_dcc :=float64 (_afd .Width )/float64 (width );_cfab :=float64 (_afd .Height )/float64 (height );for _dabg :=0;_dabg < height ;_dabg ++{_edc [_dabg ]=int (_b .Min (_cfab *float64 (_dabg )+0.5,float64 (_afd .Height -1)));
};for _fadd :=0;_fadd < width ;_fadd ++{_bgef [_fadd ]=int (_b .Min (_dcc *float64 (_fadd )+0.5,float64 (_afd .Width -1)));};_affg :=-1;_gebg :=byte (0);for _dfe :=0;_dfe < height ;_dfe ++{_cede :=_edc [_dfe ]*_afd .BytesPerLine ;_ffd :=_dfe *_edd .BytesPerLine ;
for _fef :=0;_fef < width ;_fef ++{_ebcc :=_bgef [_fef ];if _ebcc !=_affg {_gebg =_afd .getBit (_cede ,_ebcc );if _gebg !=0{_edd .setBit (_ffd ,_fef );};_affg =_ebcc ;}else {if _gebg !=0{_edd .setBit (_ffd ,_fef );};};};};return _edd ,nil ;};func _adf (_fecc Gray ,_ebdb NRGBA ,_dec _ge .Rectangle ){for _cfgd :=0;
_cfgd < _dec .Max .X ;_cfgd ++{for _ade :=0;_ade < _dec .Max .Y ;_ade ++{_gdce :=_dcg (_ebdb .NRGBAAt (_cfgd ,_ade ));_fecc .SetGray (_cfgd ,_ade ,_gdce );};};};func (_caeb *ImageBase )setTwoBytes (_fadde int ,_cffb uint16 )error {if _fadde +1> len (_caeb .Data )-1{return _e .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_caeb .Data [_fadde ]=byte ((_cffb &0xff00)>>8);_caeb .Data [_fadde +1]=byte (_cffb &0xff);return nil ;};func (_eadb *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_eadb .copy ()}};var _ Image =&NRGBA64 {};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_beg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _bde (_ddg ,_ff int ,_fce []byte )*Monochrome {_deg :=_aee (_ddg ,_ff );_deg .Data =_fce ;return _deg ;};func (_gfdc *Gray2 )Base ()*ImageBase {return &_gfdc .ImageBase };var _ Image =&CMYK32 {};func (_fdfg *Monochrome )Base ()*ImageBase {return &_fdfg .ImageBase };
func (_ggcd *Monochrome )getBitAt (_ffb ,_ceaf int )bool {_cagb :=_ceaf *_ggcd .BytesPerLine +(_ffb >>3);_adgc :=_ffb &0x07;_ddbdg :=uint (7-_adgc );if _cagb > len (_ggcd .Data )-1{return false ;};if (_ggcd .Data [_cagb ]>>_ddbdg )&0x01>=1{return true ;
};return false ;};var _ Gray =&Monochrome {};func (_bfcd *CMYK32 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_bfcd .Width ,Y :_bfcd .Height }};};func _cfc (_adc _g .CMYK )_g .RGBA {_gcd ,_abd ,_acad :=_g .CMYKToRGB (_adc .C ,_adc .M ,_adc .Y ,_adc .K );
return _g .RGBA {R :_gcd ,G :_abd ,B :_acad ,A :0xff};};type NRGBA interface{NRGBAAt (_dabf ,_cdee int )_g .NRGBA ;SetNRGBA (_ffga ,_bfga int ,_bddd _g .NRGBA );};func _cgab (_fcec _ge .Image )(Image ,error ){if _gdefc ,_defc :=_fcec .(*Gray8 );_defc {return _gdefc .Copy (),nil ;
};_aeff :=_fcec .Bounds ();_acbf ,_geada :=NewImage (_aeff .Max .X ,_aeff .Max .Y ,8,1,nil ,nil ,nil );if _geada !=nil {return nil ,_geada ;};_ccca (_fcec ,_acbf ,_aeff );return _acbf ,nil ;};func (_ccfd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ccfd .copy ()}};
func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gaba :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_gaba .Data =make ([]byte ,height *_gaba .BytesPerLine );};return _gaba ;};func _bdd ()(_caa [256]uint64 ){for _cge :=0;_cge < 256;_cge ++{if _cge &0x01!=0{_caa [_cge ]|=0xff;};if _cge &0x02!=0{_caa [_cge ]|=0xff00;};if _cge &0x04!=0{_caa [_cge ]|=0xff0000;
};if _cge &0x08!=0{_caa [_cge ]|=0xff000000;};if _cge &0x10!=0{_caa [_cge ]|=0xff00000000;};if _cge &0x20!=0{_caa [_cge ]|=0xff0000000000;};if _cge &0x40!=0{_caa [_cge ]|=0xff000000000000;};if _cge &0x80!=0{_caa [_cge ]|=0xff00000000000000;};};return _caa ;
};var _ Image =&Gray2 {};func _fa (_d *Monochrome ,_aa int )(*Monochrome ,error ){if _d ==nil {return nil ,_e .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _aa ==1{return _d .copy (),nil ;};if !IsPowerOf2 (uint (_aa )){return nil ,_beg .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_aa );
};_ee :=_ddf (_aa );return _cb (_d ,_aa ,_ee );};func (_aaac *NRGBA64 )Set (x ,y int ,c _g .Color ){_bbgfa :=(y *_aaac .Width +x )*2;_eeec :=_bbgfa *3;if _eeec +5>=len (_aaac .Data ){return ;};_fgeg :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );_aaac .setNRGBA64 (_eeec ,_fgeg ,_bbgfa );
};func _debb (_gbe NRGBA ,_baab CMYK ,_gbg _ge .Rectangle ){for _fea :=0;_fea < _gbg .Max .X ;_fea ++{for _fca :=0;_fca < _gbg .Max .Y ;_fca ++{_gbcc :=_gbe .NRGBAAt (_fea ,_fca );_baab .SetCMYK (_fea ,_fca ,_abc (_gbcc ));};};};func _cbbe (_eggc _g .Color )_g .Color {_fgbf :=_g .NRGBAModel .Convert (_eggc ).(_g .NRGBA );
return _eace (_fgbf );};func (_ddde *Monochrome )SetGray (x ,y int ,g _g .Gray ){_aebb :=y *_ddde .BytesPerLine +x >>3;if _aebb > len (_ddde .Data )-1{return ;};g =_cffd (g ,monochromeModel (_ddde .ModelThreshold ));_ddde .setGray (x ,g ,_aebb );};func _bfff (_fegf _ge .Image )(Image ,error ){if _bdgc ,_ccae :=_fegf .(*Gray2 );
_ccae {return _bdgc .Copy (),nil ;};_ggdc :=_fegf .Bounds ();_bad ,_age :=NewImage (_ggdc .Max .X ,_ggdc .Max .Y ,2,1,nil ,nil ,nil );if _age !=nil {return nil ,_age ;};_ccca (_fegf ,_bad ,_ggdc );return _bad ,nil ;};func _abc (_gbce _g .NRGBA )_g .CMYK {_gceg ,_gbcf ,_cdcg ,_ :=_gbce .RGBA ();
_abb ,_gca ,_bbagf ,_gdbc :=_g .RGBToCMYK (uint8 (_gceg >>8),uint8 (_gbcf >>8),uint8 (_cdcg >>8));return _g .CMYK {C :_abb ,M :_gca ,Y :_bbagf ,K :_gdbc };};func _beaa ()(_ga [256]uint16 ){for _gga :=0;_gga < 256;_gga ++{if _gga &0x01!=0{_ga [_gga ]|=0x3;
};if _gga &0x02!=0{_ga [_gga ]|=0xc;};if _gga &0x04!=0{_ga [_gga ]|=0x30;};if _gga &0x08!=0{_ga [_gga ]|=0xc0;};if _gga &0x10!=0{_ga [_gga ]|=0x300;};if _gga &0x20!=0{_ga [_gga ]|=0xc00;};if _gga &0x40!=0{_ga [_gga ]|=0x3000;};if _gga &0x80!=0{_ga [_gga ]|=0xc000;
};};return _ga ;};func (_afag *Gray16 )At (x ,y int )_g .Color {_afgd ,_ :=_afag .ColorAt (x ,y );return _afgd };var (MonochromeConverter =ConverterFunc (_bcbg );Gray2Converter =ConverterFunc (_bfff );Gray4Converter =ConverterFunc (_cbd );GrayConverter =ConverterFunc (_cgab );
Gray16Converter =ConverterFunc (_egbe );NRGBA16Converter =ConverterFunc (_ccfff );NRGBAConverter =ConverterFunc (_aeeee );NRGBA64Converter =ConverterFunc (_efcf );RGBAConverter =ConverterFunc (_aggd );CMYKConverter =ConverterFunc (_bff ););type Gray2 struct{ImageBase };
func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_gcbe *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_gcbe .Width ||y >=_gcbe .Height {return ;};_gefe :=Gray2Model .Convert (c ).(_g .Gray );
_cde :=y *_gcbe .BytesPerLine ;_cacf :=_cde +(x >>2);_gcdc :=_gefe .Y >>6;_gcbe .Data [_cacf ]=(_gcbe .Data [_cacf ]&(^(0xc0>>uint (2*((x )&3)))))|(_gcdc <<uint (6-2*(x &3)));};func (_aegg *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };func _eagc (_cebe ,_fgbg Gray ,_cbdg _ge .Rectangle ){for _faaa :=0;
_faaa < _cbdg .Max .X ;_faaa ++{for _afaa :=0;_afaa < _cbdg .Max .Y ;_afaa ++{_fgbg .SetGray (_faaa ,_afaa ,_cebe .GrayAt (_faaa ,_afaa ));};};};func (_ddgg *Gray16 )GrayAt (x ,y int )_g .Gray {_bgbg ,_ :=_ddgg .ColorAt (x ,y );return _g .Gray {Y :uint8 (_bgbg .(_g .Gray16 ).Y >>8)};
};func (_becf *ImageBase )setByte (_fcba int ,_deag byte )error {if _fcba > len (_becf .Data )-1{return _e .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_becf .Data [_fcba ]=_deag ;return nil ;};func (_gab *Gray8 )SetGray (x ,y int ,g _g .Gray ){_baag :=y *_gab .BytesPerLine +x ;
if _baag > len (_gab .Data )-1{return ;};_gab .Data [_baag ]=g .Y ;};func (_cedb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_cedb .copy ()}};func _aec (_dbgb ,_gbb *Monochrome ,_cf []byte ,_dac int )(_aea error ){var (_cab ,_aecg ,_fceg ,_cgf ,_dgd ,_dbb ,_caf ,_fbg int ;
_fgbd ,_bece uint32 ;_afe ,_cgec byte ;_becg uint16 ;);_bfa :=make ([]byte ,4);_fbaf :=make ([]byte ,4);for _fceg =0;_fceg < _dbgb .Height -1;_fceg ,_cgf =_fceg +2,_cgf +1{_cab =_fceg *_dbgb .BytesPerLine ;_aecg =_cgf *_gbb .BytesPerLine ;for _dgd ,_dbb =0,0;
_dgd < _dac ;_dgd ,_dbb =_dgd +4,_dbb +1{for _caf =0;_caf < 4;_caf ++{_fbg =_cab +_dgd +_caf ;if _fbg <=len (_dbgb .Data )-1&&_fbg < _cab +_dbgb .BytesPerLine {_bfa [_caf ]=_dbgb .Data [_fbg ];}else {_bfa [_caf ]=0x00;};_fbg =_cab +_dbgb .BytesPerLine +_dgd +_caf ;
if _fbg <=len (_dbgb .Data )-1&&_fbg < _cab +(2*_dbgb .BytesPerLine ){_fbaf [_caf ]=_dbgb .Data [_fbg ];}else {_fbaf [_caf ]=0x00;};};_fgbd =_be .BigEndian .Uint32 (_bfa );_bece =_be .BigEndian .Uint32 (_fbaf );_bece |=_fgbd ;_bece |=_bece <<1;_bece &=0xaaaaaaaa;
_fgbd =_bece |(_bece <<7);_afe =byte (_fgbd >>24);_cgec =byte ((_fgbd >>8)&0xff);_fbg =_aecg +_dbb ;if _fbg +1==len (_gbb .Data )-1||_fbg +1>=_aecg +_gbb .BytesPerLine {_gbb .Data [_fbg ]=_cf [_afe ];}else {_becg =(uint16 (_cf [_afe ])<<8)|uint16 (_cf [_cgec ]);
if _aea =_gbb .setTwoBytes (_fbg ,_becg );_aea !=nil {return _beg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fbg );
};_dbb ++;};};};return nil ;};func _gdcb (_ebcg _g .RGBA )_g .NRGBA {switch _ebcg .A {case 0xff:return _g .NRGBA {R :_ebcg .R ,G :_ebcg .G ,B :_ebcg .B ,A :0xff};case 0x00:return _g .NRGBA {};default:_ccgf ,_cbfe ,_abde ,_cce :=_ebcg .RGBA ();_ccgf =(_ccgf *0xffff)/_cce ;
_cbfe =(_cbfe *0xffff)/_cce ;_abde =(_abde *0xffff)/_cce ;return _g .NRGBA {R :uint8 (_ccgf >>8),G :uint8 (_cbfe >>8),B :uint8 (_abde >>8),A :uint8 (_cce >>8)};};};var _ NRGBA =&NRGBA16 {};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};var _ Gray =&Gray8 {};
func _ebf (_ba ,_gee *Monochrome )(_cg error ){_ccb :=_gee .BytesPerLine ;_ca :=_ba .BytesPerLine ;var _bebe ,_ea ,_gcf ,_bec ,_af int ;for _gcf =0;_gcf < _gee .Height ;_gcf ++{_bebe =_gcf *_ccb ;_ea =8*_gcf *_ca ;for _bec =0;_bec < _ccb ;_bec ++{if _cg =_ba .setEightBytes (_ea +_bec *8,_ddee [_gee .Data [_bebe +_bec ]]);
_cg !=nil {return _cg ;};};for _af =1;_af < 8;_af ++{for _bec =0;_bec < _ca ;_bec ++{if _cg =_ba .setByte (_ea +_af *_ca +_bec ,_ba .Data [_ea +_bec ]);_cg !=nil {return _cg ;};};};};return nil ;};func _eace (_ccff _g .NRGBA )_g .NRGBA {_ccff .R =_ccff .R >>4|(_ccff .R >>4)<<4;
_ccff .G =_ccff .G >>4|(_ccff .G >>4)<<4;_ccff .B =_ccff .B >>4|(_ccff .B >>4)<<4;return _ccff ;};func (_bagd *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_bagd .Width ||y >=_bagd .Height {return ;};_fbb :=Gray4Model .Convert (c ).(_g .Gray );_bagd .setGray (x ,y ,_fbb );
};func (_geg *Monochrome )setIndexedBit (_fgdc int ){_geg .Data [(_fgdc >>3)]|=0x80>>uint (_fgdc &7)};func (_aagf *NRGBA16 )Base ()*ImageBase {return &_aagf .ImageBase };func (_edce *NRGBA16 )setNRGBA (_ggacc ,_cfga ,_egcc int ,_bddcf _g .NRGBA ){if _ggacc *3%2==0{_edce .Data [_egcc ]=(_bddcf .R >>4)<<4|(_bddcf .G >>4);
_edce .Data [_egcc +1]=(_bddcf .B >>4)<<4|(_edce .Data [_egcc +1]&0xf);}else {_edce .Data [_egcc ]=(_edce .Data [_egcc ]&0xf0)|(_bddcf .R >>4);_edce .Data [_egcc +1]=(_bddcf .G >>4)<<4|(_bddcf .B >>4);};if _edce .Alpha !=nil {_gccg :=_cfga *BytesPerLine (_edce .Width ,4,1);
if _gccg < len (_edce .Alpha ){if _ggacc %2==0{_edce .Alpha [_gccg ]=(_bddcf .A >>uint (4))<<uint (4)|(_edce .Alpha [_egcc ]&0xf);}else {_edce .Alpha [_gccg ]=(_edce .Alpha [_gccg ]&0xf0)|(_bddcf .A >>uint (4));};};};};func (_fcaf *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };
func _feed (_efed int ,_dccd int )error {return _beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_efed ,_dccd );
};func ImgToGray (i _ge .Image )*_ge .Gray {if _gede ,_afcc :=i .(*_ge .Gray );_afcc {return _gede ;};_dae :=i .Bounds ();_bddb :=_ge .NewGray (_dae );for _dgbf :=0;_dgbf < _dae .Max .X ;_dgbf ++{for _cefd :=0;_cefd < _dae .Max .Y ;_cefd ++{_efgcb :=i .At (_dgbf ,_cefd );
_bddb .Set (_dgbf ,_cefd ,_efgcb );};};return _bddb ;};func (_edcb *Gray4 )ColorModel ()_g .Model {return Gray4Model };func (_bgc *Gray4 )setGray (_dbca int ,_eece int ,_cdfe _g .Gray ){_ddac :=_eece *_bgc .BytesPerLine ;_bead :=_ddac +(_dbca >>1);if _bead >=len (_bgc .Data ){return ;
};_ggb :=_cdfe .Y >>4;_bgc .Data [_bead ]=(_bgc .Data [_bead ]&(^(0xf0>>uint (4*(_dbca &1)))))|(_ggb <<uint (4-4*(_dbca &1)));};func (_bfddb *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_cfcg :=(y *_bfddb .Width +x )*2;_gagd :=_cfcg *3;if _gagd +5>=len (_bfddb .Data ){return ;
};_bfddb .setNRGBA64 (_gagd ,c ,_cfcg );};func _eeda (_fggf ,_gacec RGBA ,_gad _ge .Rectangle ){for _dfac :=0;_dfac < _gad .Max .X ;_dfac ++{for _deff :=0;_deff < _gad .Max .Y ;_deff ++{_gacec .SetRGBA (_dfac ,_deff ,_fggf .RGBAAt (_dfac ,_deff ));};};
};func (_agdd *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_agdd .BytesPerLine ,_agdd .Data ,_agdd .Decode );};func _bgge (_gfcb CMYK ,_gfbb NRGBA ,_agfe _ge .Rectangle ){for _dfdgf :=0;_dfdgf < _agfe .Max .X ;_dfdgf ++{for _fcad :=0;
_fcad < _agfe .Max .Y ;_fcad ++{_abeb :=_gfcb .CMYKAt (_dfdgf ,_fcad );_gfbb .SetNRGBA (_dfdgf ,_fcad ,_acfea (_abeb ));};};};func _efcd (_bgdd Gray ,_gade RGBA ,_cabf _ge .Rectangle ){for _eggd :=0;_eggd < _cabf .Max .X ;_eggd ++{for _ddeb :=0;_ddeb < _cabf .Max .Y ;
_ddeb ++{_fafa :=_bgdd .GrayAt (_eggd ,_ddeb );_gade .SetRGBA (_eggd ,_ddeb ,_cba (_fafa ));};};};func (_eadg *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_dcfg ,_ :=ColorAtNRGBA16 (x ,y ,_eadg .Width ,_eadg .BytesPerLine ,_eadg .Data ,_eadg .Alpha ,_eadg .Decode );
return _dcfg ;};func _dca (_gged Gray ,_efg CMYK ,_bbb _ge .Rectangle ){for _fdgb :=0;_fdgb < _bbb .Max .X ;_fdgb ++{for _fee :=0;_fee < _bbb .Max .Y ;_fee ++{_bcc :=_gged .GrayAt (_fdgb ,_fee );_efg .SetCMYK (_fdgb ,_fee ,_baac (_bcc ));};};};func _cfcf (_fffee CMYK ,_aebbc Gray ,_dgg _ge .Rectangle ){for _aeed :=0;
_aeed < _dgg .Max .X ;_aeed ++{for _adbe :=0;_adbe < _dgg .Max .Y ;_adbe ++{_aaeg :=_gbef (_fffee .CMYKAt (_aeed ,_adbe ));_aebbc .SetGray (_aeed ,_adbe ,_aaeg );};};};func (_cgbc *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_cgbc .Width ,_cgbc .Data ,_cgbc .Alpha ,_cgbc .Decode );
};func _aee (_gcc ,_gcfe int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_gcc ,_gcfe ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func FromGoImage (i _ge .Image )(Image ,error ){switch _becfc :=i .(type ){case Image :return _becfc .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_ge .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_ge .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};
};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_ecg :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _adbc Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_adbc =&Monochrome {ImageBase :_ecg ,ModelThreshold :0x0f};
case 2:_adbc =&Gray2 {ImageBase :_ecg };case 4:_adbc =&Gray4 {ImageBase :_ecg };case 8:_adbc =&Gray8 {ImageBase :_ecg };case 16:_adbc =&Gray16 {ImageBase :_ecg };};case 3:switch bitsPerComponent {case 4:_adbc =&NRGBA16 {ImageBase :_ecg };case 8:_adbc =&NRGBA32 {ImageBase :_ecg };
case 16:_adbc =&NRGBA64 {ImageBase :_ecg };};case 4:_adbc =&CMYK32 {ImageBase :_ecg };};if _adbc ==nil {return nil ,ErrInvalidImage ;};return _adbc ,nil ;};func (_ccag *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_ccag .ImageBase .copy (),ModelThreshold :_ccag .ModelThreshold };
};func _fcgg (_cgeb *_ge .NYCbCrA ,_gegc RGBA ,_ccbeg _ge .Rectangle ){for _bdaf :=0;_bdaf < _ccbeg .Max .X ;_bdaf ++{for _aggg :=0;_aggg < _ccbeg .Max .Y ;_aggg ++{_afcf :=_cgeb .NYCbCrAAt (_bdaf ,_aggg );_gegc .SetRGBA (_bdaf ,_aggg ,_geb (_afcf ));};
};};func _fab (_aac *Monochrome ,_bd ,_bef int )(*Monochrome ,error ){if _aac ==nil {return nil ,_e .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _bd <=0||_bef <=0{return nil ,_e .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _bd ==_bef {if _bd ==1{return _aac .copy (),nil ;};if _bd ==2||_bd ==4||_bd ==8{_dff ,_fdd :=_fa (_aac ,_bd );if _fdd !=nil {return nil ,_fdd ;};return _dff ,nil ;};};_fdf :=_bd *_aac .Width ;_gce :=_bef *_aac .Height ;_eeg :=_aee (_fdf ,_gce );_fec :=_eeg .BytesPerLine ;
var (_dbg ,_dge ,_beba ,_dged ,_bb int ;_gdc byte ;_fgg error ;);for _dge =0;_dge < _aac .Height ;_dge ++{_dbg =_bef *_dge *_fec ;for _beba =0;_beba < _aac .Width ;_beba ++{if _bdg :=_aac .getBitAt (_beba ,_dge );_bdg {_bb =_bd *_beba ;for _dged =0;_dged < _bd ;
_dged ++{_eeg .setIndexedBit (_dbg *8+_bb +_dged );};};};for _dged =1;_dged < _bef ;_dged ++{_ae :=_dbg +_dged *_fec ;for _bf :=0;_bf < _fec ;_bf ++{if _gdc ,_fgg =_eeg .getByte (_dbg +_bf );_fgg !=nil {return nil ,_fgg ;};if _fgg =_eeg .setByte (_ae +_bf ,_gdc );
_fgg !=nil {return nil ,_fgg ;};};};};return _eeg ,nil ;};func _dfbe (_cfead CMYK ,_cgegd RGBA ,_gdac _ge .Rectangle ){for _cbga :=0;_cbga < _gdac .Max .X ;_cbga ++{for _ddfe :=0;_ddfe < _gdac .Max .Y ;_ddfe ++{_ffdb :=_cfead .CMYKAt (_cbga ,_ddfe );_cgegd .SetRGBA (_cbga ,_ddfe ,_cfc (_ffdb ));
};};};func _fabd (_ded _g .NRGBA64 )_g .RGBA {_fbgf ,_eada ,_bbgf ,_bfd :=_ded .RGBA ();return _g .RGBA {R :uint8 (_fbgf >>8),G :uint8 (_eada >>8),B :uint8 (_bbgf >>8),A :uint8 (_bfd >>8)};};func _cfac (_fbacg []byte ,_cebc Image )error {_ffbd :=true ;
for _afc :=0;_afc < len (_fbacg );_afc ++{if _fbacg [_afc ]!=0xff{_ffbd =false ;break ;};};if _ffbd {switch _eggb :=_cebc .(type ){case *NRGBA32 :_eggb .Alpha =nil ;case *NRGBA64 :_eggb .Alpha =nil ;default:return _beg .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_cebc );
};};return nil ;};func (_bacde *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };type CMYK interface{CMYKAt (_ebde ,_acfe int )_g .CMYK ;SetCMYK (_eff ,_eaa int ,_bgb _g .CMYK );};func (_eabf *NRGBA16 )At (x ,y int )_g .Color {_edaa ,_ :=_eabf .ColorAt (x ,y );
return _edaa };var _ Gray =&Gray4 {};func _bbe (_dgafc _g .Color )_g .Color {_ffcg :=_g .GrayModel .Convert (_dgafc ).(_g .Gray );return _efbc (_ffcg );};func _adae (_bbad _ge .Image ,_fdaf Image ,_dgcg _ge .Rectangle ){if _bfcac ,_egef :=_bbad .(SMasker );
_egef &&_bfcac .HasAlpha (){_fdaf .(SMasker ).MakeAlpha ();};switch _aecf :=_bbad .(type ){case Gray :_ebccc (_aecf ,_fdaf .(NRGBA ),_dgcg );case NRGBA :_cdegc (_aecf ,_fdaf .(NRGBA ),_dgcg );case *_ge .NYCbCrA :_eafb (_aecf ,_fdaf .(NRGBA ),_dgcg );case CMYK :_bgge (_aecf ,_fdaf .(NRGBA ),_dgcg );
case RGBA :_efcb (_aecf ,_fdaf .(NRGBA ),_dgcg );case nrgba64 :_fcfa (_aecf ,_fdaf .(NRGBA ),_dgcg );default:_ede (_bbad ,_fdaf ,_dgcg );};};func (_ege *CMYK32 )At (x ,y int )_g .Color {_gda ,_ :=_ege .ColorAt (x ,y );return _gda };func _cdegc (_bgbe ,_deagf NRGBA ,_bbac _ge .Rectangle ){for _ddcc :=0;
_ddcc < _bbac .Max .X ;_ddcc ++{for _eadf :=0;_eadf < _bbac .Max .Y ;_eadf ++{_deagf .SetNRGBA (_ddcc ,_eadf ,_bgbe .NRGBAAt (_ddcc ,_eadf ));};};};func _fac (_gedc _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_gedc .R >>8),G :uint8 (_gedc .G >>8),B :uint8 (_gedc .B >>8),A :uint8 (_gedc .A >>8)};
};func (_fedf *ImageBase )Pix ()[]byte {return _fedf .Data };func (_efgb *NRGBA32 )Base ()*ImageBase {return &_efgb .ImageBase };type Gray interface{GrayAt (_faba ,_ccab int )_g .Gray ;SetGray (_dabc ,_edb int ,_fdae _g .Gray );};type Gray4 struct{ImageBase };
var _ Gray =&Gray2 {};func (_bcbd *ImageBase )MakeAlpha (){_bcbd .newAlpha ()};func _bbgb (_fbfd ,_faca ,_aecc byte )byte {return (_fbfd &^(_aecc ))|(_faca &_aecc )};func (_dddc *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_dddc .BytesPerLine ,_dddc .Data ,_dddc .Decode );
};var _ _ge .Image =&Gray4 {};func (_gdgg *Gray16 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_gdgg .Width ,Y :_gdgg .Height }};};var _ RGBA =&RGBA32 {};func (_edfg *NRGBA64 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_edfg .Width ,Y :_edfg .Height }};
};func (_edcd *Monochrome )Histogram ()(_bce [256]int ){for _ ,_cda :=range _edcd .Data {_bce [0xff]+=int (_acdc [_edcd .Data [_cda ]]);};return _bce ;};func _gbf (_bbaf _g .RGBA )_g .CMYK {_gacb ,_acee ,_bdae ,_bag :=_g .RGBToCMYK (_bbaf .R ,_bbaf .G ,_bbaf .B );
return _g .CMYK {C :_gacb ,M :_acee ,Y :_bdae ,K :_bag };};func _ddf (_gbc int )[]uint {var _dfg []uint ;_gef :=_gbc ;_gdg :=_gef /8;if _gdg !=0{for _bfb :=0;_bfb < _gdg ;_bfb ++{_dfg =append (_dfg ,8);};_feg :=_gef %8;_gef =0;if _feg !=0{_gef =_feg ;};
};_fgb :=_gef /4;if _fgb !=0{for _efb :=0;_efb < _fgb ;_efb ++{_dfg =append (_dfg ,4);};_cag :=_gef %4;_gef =0;if _cag !=0{_gef =_cag ;};};_bbc :=_gef /2;if _bbc !=0{for _cgb :=0;_cgb < _bbc ;_cgb ++{_dfg =append (_dfg ,2);};};return _dfg ;};func (_bcde *Monochrome )setBit (_fbee ,_fcde int ){_bcde .Data [_fbee +(_fcde >>3)]|=0x80>>uint (_fcde &7);
};func (_gfdd *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_gfdd .BytesPerLine ,_gfdd .Data ,_gfdd .Decode );};var _ _ge .Image =&Gray16 {};func (_afb *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_afb .copy ()}};func (_cgdf *Gray4 )GrayAt (x ,y int )_g .Gray {_bcge ,_ :=ColorAtGray4BPC (x ,y ,_cgdf .BytesPerLine ,_cgdf .Data ,_cgdf .Decode );
return _bcge ;};func _cbd (_dafag _ge .Image )(Image ,error ){if _gaga ,_fde :=_dafag .(*Gray4 );_fde {return _gaga .Copy (),nil ;};_fga :=_dafag .Bounds ();_fcab ,_agdg :=NewImage (_fga .Max .X ,_fga .Max .Y ,4,1,nil ,nil ,nil );if _agdg !=nil {return nil ,_agdg ;
};_ccca (_dafag ,_fcab ,_fga );return _fcab ,nil ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;
case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};
case 4:return CMYKConverter ,nil ;};return nil ,_beg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};type RGBA interface{RGBAAt (_aafb ,_feab int )_g .RGBA ;SetRGBA (_cgcfe ,_gebb int ,_dfbf _g .RGBA );};func (_gdcf *RGBA32 )RGBAAt (x ,y int )_g .RGBA {_efeda ,_ :=ColorAtRGBA32 (x ,y ,_gdcf .Width ,_gdcf .Data ,_gdcf .Alpha ,_gdcf .Decode );return _efeda ;
};func (_aeffg *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_aeffg .copy ()}};var _ Image =&RGBA32 {};func ImgToBinary (i _ge .Image ,threshold uint8 )*_ge .Gray {switch _aggag :=i .(type ){case *_ge .Gray :if _cefdc (_aggag ){return _aggag ;};return _befcc (_aggag ,threshold );
case *_ge .Gray16 :return _geba (_aggag ,threshold );default:return _cacbf (_aggag ,threshold );};};func (_eef *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };var _ Image =&Monochrome {};func _cacbf (_cffc _ge .Image ,_efdd uint8 )*_ge .Gray {_dbgg :=_cffc .Bounds ();
_gceee :=_ge .NewGray (_dbgg );var (_fbgfg _g .Color ;_ccbf _g .Gray ;);for _gfbe :=0;_gfbe < _dbgg .Max .X ;_gfbe ++{for _daec :=0;_daec < _dbgg .Max .Y ;_daec ++{_fbgfg =_cffc .At (_gfbe ,_daec );_gceee .Set (_gfbe ,_daec ,_fbgfg );_ccbf =_gceee .GrayAt (_gfbe ,_daec );
_gceee .SetGray (_gfbe ,_daec ,_g .Gray {Y :_feff (_ccbf .Y ,_efdd )});};};return _gceee ;};func (_bcf *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_facc :=y *_bcf .BytesPerLine +x *3/2;if _facc +1>=len (_bcf .Data ){return ;};c =_eace (c );_bcf .setNRGBA (x ,y ,_facc ,c );
};func _befcc (_agfea *_ge .Gray ,_afef uint8 )*_ge .Gray {_fffg :=_agfea .Bounds ();_feae :=_ge .NewGray (_fffg );for _egbc :=0;_egbc < _fffg .Dx ();_egbc ++{for _dagb :=0;_dagb < _fffg .Dy ();_dagb ++{_cgfc :=_agfea .GrayAt (_egbc ,_dagb );_feae .SetGray (_egbc ,_dagb ,_g .Gray {Y :_feff (_cgfc .Y ,_afef )});
};};return _feae ;};func _efbc (_baed _g .Gray )_g .Gray {_baed .Y >>=4;_baed .Y |=_baed .Y <<4;return _baed };func (_bdbe *ImageBase )HasAlpha ()bool {if _bdbe .Alpha ==nil {return false ;};for _cbagf :=range _bdbe .Alpha {if _bdbe .Alpha [_cbagf ]!=0xff{return true ;
};};return false ;};func _ccfff (_cgdg _ge .Image )(Image ,error ){if _dgef ,_geab :=_cgdg .(*NRGBA16 );_geab {return _dgef .Copy (),nil ;};_fdbd :=_cgdg .Bounds ();_acgd ,_gebe :=NewImage (_fdbd .Max .X ,_fdbd .Max .Y ,4,3,nil ,nil ,nil );if _gebe !=nil {return nil ,_gebe ;
};_adae (_cgdg ,_acgd ,_fdbd );return _acgd ,nil ;};func (_cfdg *NRGBA16 )Validate ()error {if len (_cfdg .Data )!=3*_cfdg .Width *_cfdg .Height /2{return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _gdgba (_gdbfd RGBA ,_bfcf Gray ,_cabg _ge .Rectangle ){for _dgedf :=0;_dgedf < _cabg .Max .X ;_dgedf ++{for _gbac :=0;_gbac < _cabg .Max .Y ;_gbac ++{_cbdcc :=_cad (_gdbfd .RGBAAt (_dgedf ,_gbac ));_bfcf .SetGray (_dgedf ,_gbac ,_cbdcc );
};};};func _acbd (_efeg *Monochrome ,_cdea ,_gdfg int ,_aeee ,_gdd int ,_cddb RasterOperator ){var (_acbg bool ;_fcgf bool ;_dafb int ;_cgeg int ;_ggcg int ;_aega int ;_gdea bool ;_aegaa byte ;);_agcb :=8-(_cdea &7);_dbbgf :=_bebea [_agcb ];_eed :=_efeg .BytesPerLine *_gdfg +(_cdea >>3);
if _aeee < _agcb {_acbg =true ;_dbbgf &=_fbfg [8-_agcb +_aeee ];};if !_acbg {_dafb =(_aeee -_agcb )>>3;if _dafb !=0{_fcgf =true ;_cgeg =_eed +1;};};_ggcg =(_cdea +_aeee )&7;if !(_acbg ||_ggcg ==0){_gdea =true ;_aegaa =_fbfg [_ggcg ];_aega =_eed +1+_dafb ;
};var _bbfa ,_caag int ;switch _cddb {case PixClr :for _bbfa =0;_bbfa < _gdd ;_bbfa ++{_efeg .Data [_eed ]=_bbgb (_efeg .Data [_eed ],0x0,_dbbgf );_eed +=_efeg .BytesPerLine ;};if _fcgf {for _bbfa =0;_bbfa < _gdd ;_bbfa ++{for _caag =0;_caag < _dafb ;_caag ++{_efeg .Data [_cgeg +_caag ]=0x0;
};_cgeg +=_efeg .BytesPerLine ;};};if _gdea {for _bbfa =0;_bbfa < _gdd ;_bbfa ++{_efeg .Data [_aega ]=_bbgb (_efeg .Data [_aega ],0x0,_aegaa );_aega +=_efeg .BytesPerLine ;};};case PixSet :for _bbfa =0;_bbfa < _gdd ;_bbfa ++{_efeg .Data [_eed ]=_bbgb (_efeg .Data [_eed ],0xff,_dbbgf );
_eed +=_efeg .BytesPerLine ;};if _fcgf {for _bbfa =0;_bbfa < _gdd ;_bbfa ++{for _caag =0;_caag < _dafb ;_caag ++{_efeg .Data [_cgeg +_caag ]=0xff;};_cgeg +=_efeg .BytesPerLine ;};};if _gdea {for _bbfa =0;_bbfa < _gdd ;_bbfa ++{_efeg .Data [_aega ]=_bbgb (_efeg .Data [_aega ],0xff,_aegaa );
_aega +=_efeg .BytesPerLine ;};};case PixNotDst :for _bbfa =0;_bbfa < _gdd ;_bbfa ++{_efeg .Data [_eed ]=_bbgb (_efeg .Data [_eed ],^_efeg .Data [_eed ],_dbbgf );_eed +=_efeg .BytesPerLine ;};if _fcgf {for _bbfa =0;_bbfa < _gdd ;_bbfa ++{for _caag =0;_caag < _dafb ;
_caag ++{_efeg .Data [_cgeg +_caag ]=^(_efeg .Data [_cgeg +_caag ]);};_cgeg +=_efeg .BytesPerLine ;};};if _gdea {for _bbfa =0;_bbfa < _gdd ;_bbfa ++{_efeg .Data [_aega ]=_bbgb (_efeg .Data [_aega ],^_efeg .Data [_aega ],_aegaa );_aega +=_efeg .BytesPerLine ;
};};};};func _bbggf (_dgfa _ge .Image ,_ggfe Image ,_fceb _ge .Rectangle ){if _eegfg ,_baeb :=_dgfa .(SMasker );_baeb &&_eegfg .HasAlpha (){_ggfe .(SMasker ).MakeAlpha ();};switch _caea :=_dgfa .(type ){case Gray :_efcd (_caea ,_ggfe .(RGBA ),_fceb );case NRGBA :_faabd (_caea ,_ggfe .(RGBA ),_fceb );
case *_ge .NYCbCrA :_fcgg (_caea ,_ggfe .(RGBA ),_fceb );case CMYK :_dfbe (_caea ,_ggfe .(RGBA ),_fceb );case RGBA :_eeda (_caea ,_ggfe .(RGBA ),_fceb );case nrgba64 :_bddcaf (_caea ,_ggfe .(RGBA ),_fceb );default:_ede (_dgfa ,_ggfe ,_fceb );};};var (_bgdc =_beaa ();
_dad =_acg ();_ddee =_bdd (););func _dfb (_fbd _g .Gray )_g .NRGBA {return _g .NRGBA {R :_fbd .Y ,G :_fbd .Y ,B :_fbd .Y ,A :0xff}};var (Gray2Model =_g .ModelFunc (_eabd );Gray4Model =_g .ModelFunc (_bbe );NRGBA16Model =_g .ModelFunc (_cbbe ););func _cba (_eeef _g .Gray )_g .RGBA {return _g .RGBA {R :_eeef .Y ,G :_eeef .Y ,B :_eeef .Y ,A :0xff}};
var _ _ge .Image =&NRGBA16 {};func _fcfa (_begae nrgba64 ,_cbagg NRGBA ,_ffeb _ge .Rectangle ){for _edfgg :=0;_edfgg < _ffeb .Max .X ;_edfgg ++{for _bcbcd :=0;_bcbcd < _ffeb .Max .Y ;_bcbcd ++{_eedb :=_begae .NRGBA64At (_edfgg ,_bcbcd );_cbagg .SetNRGBA (_edfgg ,_bcbcd ,_fac (_eedb ));
};};};var _ _ge .Image =&Monochrome {};func (_ddaa *Monochrome )Set (x ,y int ,c _g .Color ){_dgaf :=y *_ddaa .BytesPerLine +x >>3;if _dgaf > len (_ddaa .Data )-1{return ;};_gcea :=_ddaa .ColorModel ().Convert (c ).(_g .Gray );_ddaa .setGray (x ,_gcea ,_dgaf );
};func (_gfe *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_edfd ,_ :=ColorAtNRGBA32 (x ,y ,_gfe .Width ,_gfe .Data ,_gfe .Alpha ,_gfe .Decode );return _edfd ;};func _efcb (_gfef RGBA ,_fdge NRGBA ,_aebf _ge .Rectangle ){for _ageb :=0;_ageb < _aebf .Max .X ;
_ageb ++{for _fdef :=0;_fdef < _aebf .Max .Y ;_fdef ++{_cdfef :=_gfef .RGBAAt (_ageb ,_fdef );_fdge .SetNRGBA (_ageb ,_fdef ,_gdcb (_cdfef ));};};};func (_abf *ImageBase )getByte (_bfdgg int )(byte ,error ){if _bfdgg > len (_abf .Data )-1||_bfdgg < 0{return 0,_beg .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_bfdgg );
};return _abf .Data [_bfdgg ],nil ;};func _eaff (_cfed _ge .Image ,_dcca int )(_ge .Rectangle ,bool ,[]byte ){_eabc :=_cfed .Bounds ();var (_babb bool ;_fegb []byte ;);switch _gegf :=_cfed .(type ){case SMasker :_babb =_gegf .HasAlpha ();case NRGBA ,RGBA ,*_ge .RGBA64 ,nrgba64 ,*_ge .NYCbCrA :_fegb =make ([]byte ,_eabc .Max .X *_eabc .Max .Y *_dcca );
case *_ge .Paletted :if !_gegf .Opaque (){_fegb =make ([]byte ,_eabc .Max .X *_eabc .Max .Y *_dcca );};};return _eabc ,_babb ,_fegb ;};func (_ccde *NRGBA64 )At (x ,y int )_g .Color {_cbgb ,_ :=_ccde .ColorAt (x ,y );return _cbgb };func (_dfgfc *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_dfgfc .Width ,_dfgfc .Data ,_dfgfc .Decode );
};func _eebbb (_cccg *Monochrome ,_bcdb ,_dggg ,_abea ,_dcb int ,_gfbc RasterOperator ,_gcda *Monochrome ,_acae ,_abdee int )error {var (_edg bool ;_ebgd bool ;_dced byte ;_deab int ;_eeag int ;_eae int ;_bacf int ;_fedd bool ;_gcgb int ;_dgega int ;_fdgd int ;
_cgee bool ;_acef byte ;_fbdf int ;_dcbd int ;_edga int ;_fedc byte ;_deda int ;_acac int ;_accd uint ;_cfcb uint ;_gbbd byte ;_fbbc shift ;_ddfc bool ;_accde bool ;_dcee ,_facd int ;);if _acae &7!=0{_acac =8-(_acae &7);};if _bcdb &7!=0{_eeag =8-(_bcdb &7);
};if _acac ==0&&_eeag ==0{_gbbd =_bebea [0];}else {if _eeag > _acac {_accd =uint (_eeag -_acac );}else {_accd =uint (8-(_acac -_eeag ));};_cfcb =8-_accd ;_gbbd =_bebea [_accd ];};if (_bcdb &7)!=0{_edg =true ;_deab =8-(_bcdb &7);_dced =_bebea [_deab ];_eae =_cccg .BytesPerLine *_dggg +(_bcdb >>3);
_bacf =_gcda .BytesPerLine *_abdee +(_acae >>3);_deda =8-(_acae &7);if _deab > _deda {_fbbc =_afab ;if _abea >=_acac {_ddfc =true ;};}else {_fbbc =_dgab ;};};if _abea < _deab {_ebgd =true ;_dced &=_fbfg [8-_deab +_abea ];};if !_ebgd {_gcgb =(_abea -_deab )>>3;
if _gcgb !=0{_fedd =true ;_dgega =_cccg .BytesPerLine *_dggg +((_bcdb +_eeag )>>3);_fdgd =_gcda .BytesPerLine *_abdee +((_acae +_eeag )>>3);};};_fbdf =(_bcdb +_abea )&7;if !(_ebgd ||_fbdf ==0){_cgee =true ;_acef =_fbfg [_fbdf ];_dcbd =_cccg .BytesPerLine *_dggg +((_bcdb +_eeag )>>3)+_gcgb ;
_edga =_gcda .BytesPerLine *_abdee +((_acae +_eeag )>>3)+_gcgb ;if _fbdf > int (_cfcb ){_accde =true ;};};switch _gfbc {case PixSrc :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );
};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],_fedc ,_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );
_cccg .Data [_dgega +_facd ]=_fedc ;};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );
};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],_fedc ,_acef );_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixNotSrc :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );
};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],^_fedc ,_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );
_cccg .Data [_dgega +_facd ]=^_fedc ;};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );
};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],^_fedc ,_acef );_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixSrcOrDst :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );
};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],_fedc |_cccg .Data [_eae ],_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;
_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]|=_fedc ;};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;
if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],_fedc |_cccg .Data [_dcbd ],_acef );_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixSrcAndDst :if _edg {for _dcee =0;
_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],_fedc &_cccg .Data [_eae ],_dced );
_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]&=_fedc ;
};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],_fedc &_cccg .Data [_dcbd ],_acef );
_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixSrcXorDst :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );};
}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],_fedc ^_cccg .Data [_eae ],_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;
_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]^=_fedc ;};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;
if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],_fedc ^_cccg .Data [_dcbd ],_acef );_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixNotSrcOrDst :if _edg {for _dcee =0;
_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],^_fedc |_cccg .Data [_eae ],_dced );
_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]|=^_fedc ;
};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],^_fedc |_cccg .Data [_dcbd ],_acef );
_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixNotSrcAndDst :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );
};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],^_fedc &_cccg .Data [_eae ],_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;
_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]&=^_fedc ;};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;
if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],^_fedc &_cccg .Data [_dcbd ],_acef );_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixSrcOrNotDst :if _edg {for _dcee =0;
_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],_fedc |^_cccg .Data [_eae ],_dced );
_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]=_fedc |^_cccg .Data [_dgega +_facd ];
};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],_fedc |^_cccg .Data [_dcbd ],_acef );
_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixSrcAndNotDst :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );
};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],_fedc &^_cccg .Data [_eae ],_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;
_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]=_fedc &^_cccg .Data [_dgega +_facd ];};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;
_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],_fedc &^_cccg .Data [_dcbd ],_acef );_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],^(_fedc |_cccg .Data [_eae ]),_dced );
_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]=^(_fedc |_cccg .Data [_dgega +_facd ]);
};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],^(_fedc |_cccg .Data [_dcbd ]),_acef );
_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};case PixNotPixSrcAndDst :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );
};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],^(_fedc &_cccg .Data [_eae ]),_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;
_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );_cccg .Data [_dgega +_facd ]=^(_fedc &_cccg .Data [_dgega +_facd ]);};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};
if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],^(_fedc &_cccg .Data [_dcbd ]),_acef );_dcbd +=_cccg .BytesPerLine ;
_edga +=_gcda .BytesPerLine ;};};case PixNotPixSrcXorDst :if _edg {for _dcee =0;_dcee < _dcb ;_dcee ++{if _fbbc ==_afab {_fedc =_gcda .Data [_bacf ]<<_accd ;if _ddfc {_fedc =_bbgb (_fedc ,_gcda .Data [_bacf +1]>>_cfcb ,_gbbd );};}else {_fedc =_gcda .Data [_bacf ]>>_cfcb ;
};_cccg .Data [_eae ]=_bbgb (_cccg .Data [_eae ],^(_fedc ^_cccg .Data [_eae ]),_dced );_eae +=_cccg .BytesPerLine ;_bacf +=_gcda .BytesPerLine ;};};if _fedd {for _dcee =0;_dcee < _dcb ;_dcee ++{for _facd =0;_facd < _gcgb ;_facd ++{_fedc =_bbgb (_gcda .Data [_fdgd +_facd ]<<_accd ,_gcda .Data [_fdgd +_facd +1]>>_cfcb ,_gbbd );
_cccg .Data [_dgega +_facd ]=^(_fedc ^_cccg .Data [_dgega +_facd ]);};_dgega +=_cccg .BytesPerLine ;_fdgd +=_gcda .BytesPerLine ;};};if _cgee {for _dcee =0;_dcee < _dcb ;_dcee ++{_fedc =_gcda .Data [_edga ]<<_accd ;if _accde {_fedc =_bbgb (_fedc ,_gcda .Data [_edga +1]>>_cfcb ,_gbbd );
};_cccg .Data [_dcbd ]=_bbgb (_cccg .Data [_dcbd ],^(_fedc ^_cccg .Data [_dcbd ]),_acef );_dcbd +=_cccg .BytesPerLine ;_edga +=_gcda .BytesPerLine ;};};default:_ec .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_gfbc );
return _e .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _cdeg (_geeg *Monochrome ,_acca ,_ccf int ,_dggga ,_ggfa int ,_egcg RasterOperator ){var (_bffe int ;
_ebfg byte ;_dggd ,_cgcf int ;_gbff int ;);_ffgb :=_dggga >>3;_ecad :=_dggga &7;if _ecad > 0{_ebfg =_fbfg [_ecad ];};_bffe =_geeg .BytesPerLine *_ccf +(_acca >>3);switch _egcg {case PixClr :for _dggd =0;_dggd < _ggfa ;_dggd ++{_gbff =_bffe +_dggd *_geeg .BytesPerLine ;
for _cgcf =0;_cgcf < _ffgb ;_cgcf ++{_geeg .Data [_gbff ]=0x0;_gbff ++;};if _ecad > 0{_geeg .Data [_gbff ]=_bbgb (_geeg .Data [_gbff ],0x0,_ebfg );};};case PixSet :for _dggd =0;_dggd < _ggfa ;_dggd ++{_gbff =_bffe +_dggd *_geeg .BytesPerLine ;for _cgcf =0;
_cgcf < _ffgb ;_cgcf ++{_geeg .Data [_gbff ]=0xff;_gbff ++;};if _ecad > 0{_geeg .Data [_gbff ]=_bbgb (_geeg .Data [_gbff ],0xff,_ebfg );};};case PixNotDst :for _dggd =0;_dggd < _ggfa ;_dggd ++{_gbff =_bffe +_dggd *_geeg .BytesPerLine ;for _cgcf =0;_cgcf < _ffgb ;
_cgcf ++{_geeg .Data [_gbff ]=^_geeg .Data [_gbff ];_gbff ++;};if _ecad > 0{_geeg .Data [_gbff ]=_bbgb (_geeg .Data [_gbff ],^_geeg .Data [_gbff ],_ebfg );};};};};func (_aegb *ImageBase )setEightFullBytes (_daab int ,_agec uint64 )error {if _daab +7> len (_aegb .Data )-1{return _e .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aegb .Data [_daab ]=byte ((_agec &0xff00000000000000)>>56);_aegb .Data [_daab +1]=byte ((_agec &0xff000000000000)>>48);_aegb .Data [_daab +2]=byte ((_agec &0xff0000000000)>>40);_aegb .Data [_daab +3]=byte ((_agec &0xff00000000)>>32);_aegb .Data [_daab +4]=byte ((_agec &0xff000000)>>24);
_aegb .Data [_daab +5]=byte ((_agec &0xff0000)>>16);_aegb .Data [_daab +6]=byte ((_agec &0xff00)>>8);_aegb .Data [_daab +7]=byte (_agec &0xff);return nil ;};func (_baf *Gray2 )At (x ,y int )_g .Color {_fgfe ,_ :=_baf .ColorAt (x ,y );return _fgfe };func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .RGBA ,error ){_bdfbe :=y *width +x ;
_gfde :=3*_bdfbe ;if _gfde +2>=len (data ){return _g .RGBA {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fbgg :=uint8 (0xff);if alpha !=nil &&len (alpha )> _bdfbe {_fbgg =alpha [_bdfbe ];};_bgded ,_ffcga ,_ecbd :=data [_gfde ],data [_gfde +1],data [_gfde +2];if len (decode )==6{_bgded =uint8 (uint32 (LinearInterpolate (float64 (_bgded ),0,255,decode [0],decode [1]))&0xff);
_ffcga =uint8 (uint32 (LinearInterpolate (float64 (_ffcga ),0,255,decode [2],decode [3]))&0xff);_ecbd =uint8 (uint32 (LinearInterpolate (float64 (_ecbd ),0,255,decode [4],decode [5]))&0xff);};return _g .RGBA {R :_bgded ,G :_ffcga ,B :_ecbd ,A :_fbgg },nil ;
};func (_cdgg *Monochrome )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_cdgg .Width ,Y :_cdgg .Height }};};func _geba (_fcfe *_ge .Gray16 ,_bdab uint8 )*_ge .Gray {_agfd :=_fcfe .Bounds ();_adedb :=_ge .NewGray (_agfd );for _dbeb :=0;
_dbeb < _agfd .Dx ();_dbeb ++{for _bfbcc :=0;_bfbcc < _agfd .Dy ();_bfbcc ++{_ggcgf :=_fcfe .Gray16At (_dbeb ,_bfbcc );_adedb .SetGray (_dbeb ,_bfbcc ,_g .Gray {Y :_feff (uint8 (_ggcgf .Y /256),_bdab )});};};return _adedb ;};func (_agc *Gray8 )GrayAt (x ,y int )_g .Gray {_gafg ,_ :=ColorAtGray8BPC (x ,y ,_agc .BytesPerLine ,_agc .Data ,_agc .Decode );
return _gafg ;};func (_addg *Monochrome )setGrayBit (_cbag ,_cgea int ){_addg .Data [_cbag ]|=0x80>>uint (_cgea &7)};func _cb (_eg *Monochrome ,_gea int ,_gdf []uint )(*Monochrome ,error ){_ece :=_gea *_eg .Width ;_aag :=_gea *_eg .Height ;_fd :=_aee (_ece ,_aag );
for _fag ,_de :=range _gdf {var _aagb error ;switch _de {case 2:_aagb =_dg (_fd ,_eg );case 4:_aagb =_eec (_fd ,_eg );case 8:_aagb =_ebf (_fd ,_eg );};if _aagb !=nil {return nil ,_aagb ;};if _fag !=len (_gdf )-1{_eg =_fd .copy ();};};return _fd ,nil ;};
func (_ddc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ddc .copy ()}};var (_fbfg =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_bebea =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_gfdg *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_cdga :=y *_gfdg .Width +x ;
_dffcf :=3*_cdga ;if _dffcf +2>=len (_gfdg .Data ){return ;};_gfdg .setRGBA (_cdga ,c );};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _b .Abs (xmax -xmin )< 0.000001{return ymin ;};_bgdf :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );
return _bgdf ;};func (_bcbe *Monochrome )clearBit (_fgc ,_adfe int ){_bcbe .Data [_fgc ]&=^(0x80>>uint (_adfe &7))};func (_eebe *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_dgcca :=_cbeg (gray );_ccc :=y *_eebe .BytesPerLine ;_ffbf :=_ccc +(x >>2);if _ffbf >=len (_eebe .Data ){return ;
};_feeg :=_dgcca .Y >>6;_eebe .Data [_ffbf ]=(_eebe .Data [_ffbf ]&(^(0xc0>>uint (2*((x )&3)))))|(_feeg <<uint (6-2*(x &3)));};func _dg (_dd ,_bea *Monochrome )(_dda error ){_dde :=_bea .BytesPerLine ;_da :=_dd .BytesPerLine ;var (_beb byte ;_eb uint16 ;
_db ,_ceb ,_bg ,_bgd ,_fb int ;);for _bg =0;_bg < _bea .Height ;_bg ++{_db =_bg *_dde ;_ceb =2*_bg *_da ;for _bgd =0;_bgd < _dde ;_bgd ++{_beb =_bea .Data [_db +_bgd ];_eb =_bgdc [_beb ];_fb =_ceb +_bgd *2;if _dd .BytesPerLine !=_bea .BytesPerLine *2&&(_bgd +1)*2> _dd .BytesPerLine {_dda =_dd .setByte (_fb ,byte (_eb >>8));
}else {_dda =_dd .setTwoBytes (_fb ,_eb );};if _dda !=nil {return _dda ;};};for _bgd =0;_bgd < _da ;_bgd ++{_fb =_ceb +_da +_bgd ;_beb =_dd .Data [_ceb +_bgd ];if _dda =_dd .setByte (_fb ,_beb );_dda !=nil {return _dda ;};};};return nil ;};func _ced ()(_gf []byte ){_gf =make ([]byte ,256);
for _cfa :=0;_cfa < 256;_cfa ++{_ggc :=byte (_cfa );_gf [_ggc ]=(_ggc &0x01)|((_ggc &0x04)>>1)|((_ggc &0x10)>>2)|((_ggc &0x40)>>3)|((_ggc &0x02)<<3)|((_ggc &0x08)<<2)|((_ggc &0x20)<<1)|(_ggc &0x80);};return _gf ;};type RGBA32 struct{ImageBase };func (_eba *Monochrome )At (x ,y int )_g .Color {_gbd ,_ :=_eba .ColorAt (x ,y );
return _gbd };func (_aded *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_aded .copy ()}};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_beg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_accg *Gray4 )Validate ()error {if len (_accg .Data )!=_accg .Height *_accg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_egc *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_feca ,_ :=ColorAtCMYK (x ,y ,_egc .Width ,_egc .Data ,_egc .Decode );
return _feca ;};func (_baeg *NRGBA32 )Set (x ,y int ,c _g .Color ){_cffe :=y *_baeg .Width +x ;_cfabd :=3*_cffe ;if _cfabd +2>=len (_baeg .Data ){return ;};_gfg :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_baeg .setRGBA (_cffe ,_gfg );};func (_dgea *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_dgea .BytesPerLine ,_dgea .Data ,_dgea .Decode );
};func (_afge *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_dag :=4*(y *_afge .Width +x );if _dag +3>=len (_afge .Data ){return ;};_afge .Data [_dag ]=c .C ;_afge .Data [_dag +1]=c .M ;_afge .Data [_dag +2]=c .Y ;_afge .Data [_dag +3]=c .K ;};type ImageBase struct{Width ,Height int ;
BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_gfcd *ImageBase )newAlpha (){_ggeb :=BytesPerLine (_gfcd .Width ,_gfcd .BitsPerComponent ,1);_gfcd .Alpha =make ([]byte ,_gfcd .Height *_ggeb );};func _bge (_fda _g .NRGBA )_g .Gray {_bgf ,_fgga ,_gde ,_ :=_fda .RGBA ();
_cacg :=(19595*_bgf +38470*_fgga +7471*_gde +1<<15)>>24;return _g .Gray {Y :uint8 (_cacg )};};func (_bcb *CMYK32 )Validate ()error {if len (_bcb .Data )!=4*_bcb .Width *_bcb .Height {return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ggdb *Gray8 )Histogram ()(_cfgg [256]int ){for _bbbg :=0;_bbbg < len (_ggdb .Data );_bbbg ++{_cfgg [_ggdb .Data [_bbbg ]]++;};return _cfgg ;};func (_bbgg *CMYK32 )Set (x ,y int ,c _g .Color ){_bdf :=4*(y *_bbgg .Width +x );if _bdf +3>=len (_bbgg .Data ){return ;
};_faa :=_g .CMYKModel .Convert (c ).(_g .CMYK );_bbgg .Data [_bdf ]=_faa .C ;_bbgg .Data [_bdf +1]=_faa .M ;_bbgg .Data [_bdf +2]=_faa .Y ;_bbgg .Data [_bdf +3]=_faa .K ;};type ColorConverter interface{Convert (_ccd _ge .Image )(Image ,error );};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_dfea :=(y *bytesPerLine /2+x )*2;
if _dfea +1>=len (data ){return _g .Gray16 {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ada :=uint16 (data [_dfea ])<<8|uint16 (data [_dfea +1]);if len (decode )==2{_ada =uint16 (uint64 (LinearInterpolate (float64 (_ada ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_ada },nil ;};func _cefdc (_fdfe *_ge .Gray )bool {for _aaff :=0;
_aaff < len (_fdfe .Pix );_aaff ++{if !_cfec (_fdfe .Pix [_aaff ]){return false ;};};return true ;};func _dea (_eecc ,_dfa *Monochrome ,_dee []byte ,_efd int )(_fcd error ){var (_efdc ,_ag ,_ddgaf ,_cgdb ,_deac ,_afg ,_bc ,_dgf int ;_bba ,_fbc uint32 ;
_dab ,_befc byte ;_ebg uint16 ;);_ebgf :=make ([]byte ,4);_cca :=make ([]byte ,4);for _ddgaf =0;_ddgaf < _eecc .Height -1;_ddgaf ,_cgdb =_ddgaf +2,_cgdb +1{_efdc =_ddgaf *_eecc .BytesPerLine ;_ag =_cgdb *_dfa .BytesPerLine ;for _deac ,_afg =0,0;_deac < _efd ;
_deac ,_afg =_deac +4,_afg +1{for _bc =0;_bc < 4;_bc ++{_dgf =_efdc +_deac +_bc ;if _dgf <=len (_eecc .Data )-1&&_dgf < _efdc +_eecc .BytesPerLine {_ebgf [_bc ]=_eecc .Data [_dgf ];}else {_ebgf [_bc ]=0x00;};_dgf =_efdc +_eecc .BytesPerLine +_deac +_bc ;
if _dgf <=len (_eecc .Data )-1&&_dgf < _efdc +(2*_eecc .BytesPerLine ){_cca [_bc ]=_eecc .Data [_dgf ];}else {_cca [_bc ]=0x00;};};_bba =_be .BigEndian .Uint32 (_ebgf );_fbc =_be .BigEndian .Uint32 (_cca );_fbc &=_bba ;_fbc &=_fbc <<1;_fbc &=0xaaaaaaaa;
_bba =_fbc |(_fbc <<7);_dab =byte (_bba >>24);_befc =byte ((_bba >>8)&0xff);_dgf =_ag +_afg ;if _dgf +1==len (_dfa .Data )-1||_dgf +1>=_ag +_dfa .BytesPerLine {_dfa .Data [_dgf ]=_dee [_dab ];if _fcd =_dfa .setByte (_dgf ,_dee [_dab ]);_fcd !=nil {return _beg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_dgf );
};}else {_ebg =(uint16 (_dee [_dab ])<<8)|uint16 (_dee [_befc ]);if _fcd =_dfa .setTwoBytes (_dgf ,_ebg );_fcd !=nil {return _beg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_dgf );
};_afg ++;};};};return nil ;};func (_agd *Gray4 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_agd .Width ,Y :_agd .Height }};};func _ccac (_dgde RGBA ,_ddbf CMYK ,_bfbf _ge .Rectangle ){for _ffc :=0;_ffc < _bfbf .Max .X ;_ffc ++{for _ebb :=0;
_ebb < _bfbf .Max .Y ;_ebb ++{_gdb :=_dgde .RGBAAt (_ffc ,_ebb );_ddbf .SetCMYK (_ffc ,_ebb ,_gbf (_gdb ));};};};type nrgba64 interface{NRGBA64At (_aaae ,_cef int )_g .NRGBA64 ;SetNRGBA64 (_gbcea ,_gcbcf int ,_agff _g .NRGBA64 );};var _ Image =&Gray8 {};
func _efcf (_efbf _ge .Image )(Image ,error ){if _cbaf ,_bfbbc :=_efbf .(*NRGBA64 );_bfbbc {return _cbaf .Copy (),nil ;};_fagf ,_eacc ,_adge :=_eaff (_efbf ,2);_ffgg ,_cgfg :=NewImage (_fagf .Max .X ,_fagf .Max .Y ,16,3,nil ,_adge ,nil );if _cgfg !=nil {return nil ,_cgfg ;
};_faab (_efbf ,_ffgg ,_fagf );if len (_adge )!=0&&!_eacc {if _ffe :=_cfac (_adge ,_ffgg );_ffe !=nil {return nil ,_ffe ;};};return _ffgg ,nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};var _ _ge .Image =&RGBA32 {};var _ _ge .Image =&NRGBA32 {};
func _acfea (_bbag _g .CMYK )_g .NRGBA {_cfge ,_dfc ,_ccg :=_g .CMYKToRGB (_bbag .C ,_bbag .M ,_bbag .Y ,_bbag .K );return _g .NRGBA {R :_cfge ,G :_dfc ,B :_ccg ,A :0xff};};func InDelta (expected ,current ,delta float64 )bool {_baabd :=expected -current ;
if _baabd <=-delta ||_baabd >=delta {return false ;};return true ;};func _eafb (_affe *_ge .NYCbCrA ,_bgde NRGBA ,_geged _ge .Rectangle ){for _eced :=0;_eced < _geged .Max .X ;_eced ++{for _beef :=0;_beef < _geged .Max .Y ;_beef ++{_acbdf :=_affe .NYCbCrAAt (_eced ,_beef );
_bgde .SetNRGBA (_eced ,_beef ,_bbfc (_acbdf ));};};};var _ Image =&NRGBA16 {};var _ Image =&NRGBA32 {};func _ebccc (_ddfcg Gray ,_fcae NRGBA ,_efgc _ge .Rectangle ){for _babf :=0;_babf < _efgc .Max .X ;_babf ++{for _afagb :=0;_afagb < _efgc .Max .Y ;_afagb ++{_gcdae :=_ddfcg .GrayAt (_babf ,_afagb );
_fcae .SetNRGBA (_babf ,_afagb ,_dfb (_gcdae ));};};};func (_cabe *Gray16 )SetGray (x ,y int ,g _g .Gray ){_gbcee :=(y *_cabe .BytesPerLine /2+x )*2;if _gbcee +1>=len (_cabe .Data ){return ;};_cabe .Data [_gbcee ]=g .Y ;_cabe .Data [_gbcee +1]=g .Y ;};
func (_edag *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_edag .Width ,_edag .Data ,_edag .Alpha ,_edag .Decode );};func (_bacfb *NRGBA32 )setRGBA (_ddade int ,_deca _g .NRGBA ){_bgdcb :=3*_ddade ;_bacfb .Data [_bgdcb ]=_deca .R ;
_bacfb .Data [_bgdcb +1]=_deca .G ;_bacfb .Data [_bgdcb +2]=_deca .B ;if _ddade < len (_bacfb .Alpha ){_bacfb .Alpha [_ddade ]=_deca .A ;};};var ErrInvalidImage =_e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gae (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _bbfc (_adgd _g .NYCbCrA )_g .NRGBA {_daf :=int32 (_adgd .Y )*0x10101;_cgbd :=int32 (_adgd .Cb )-128;
_bcg :=int32 (_adgd .Cr )-128;_befa :=_daf +91881*_bcg ;if uint32 (_befa )&0xff000000==0{_befa >>=8;}else {_befa =^(_befa >>31)&0xffff;};_gced :=_daf -22554*_cgbd -46802*_bcg ;if uint32 (_gced )&0xff000000==0{_gced >>=8;}else {_gced =^(_gced >>31)&0xffff;
};_dbbg :=_daf +116130*_cgbd ;if uint32 (_dbbg )&0xff000000==0{_dbbg >>=8;}else {_dbbg =^(_dbbg >>31)&0xffff;};return _g .NRGBA {R :uint8 (_befa >>8),G :uint8 (_gced >>8),B :uint8 (_dbbg >>8),A :_adgd .A };};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_baegb :=(y *width +x )*2;
_cgg :=_baegb *3;if _cgg +5>=len (data ){return _g .NRGBA64 {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _afbc =0xffff;_cdfg :=uint16 (_afbc );if alpha !=nil &&len (alpha )> _baegb +1{_cdfg =uint16 (alpha [_baegb ])<<8|uint16 (alpha [_baegb +1]);};_begf :=uint16 (data [_cgg ])<<8|uint16 (data [_cgg +1]);_dcgc :=uint16 (data [_cgg +2])<<8|uint16 (data [_cgg +3]);
_aabg :=uint16 (data [_cgg +4])<<8|uint16 (data [_cgg +5]);if len (decode )==6{_begf =uint16 (uint64 (LinearInterpolate (float64 (_begf ),0,65535,decode [0],decode [1]))&_afbc );_dcgc =uint16 (uint64 (LinearInterpolate (float64 (_dcgc ),0,65535,decode [2],decode [3]))&_afbc );
_aabg =uint16 (uint64 (LinearInterpolate (float64 (_aabg ),0,65535,decode [4],decode [5]))&_afbc );};return _g .NRGBA64 {R :_begf ,G :_dcgc ,B :_aabg ,A :_cdfg },nil ;};func _egbe (_afbf _ge .Image )(Image ,error ){if _gcdf ,_acaa :=_afbf .(*Gray16 );_acaa {return _gcdf .Copy (),nil ;
};_baba :=_afbf .Bounds ();_fcece ,_ggba :=NewImage (_baba .Max .X ,_baba .Max .Y ,16,1,nil ,nil ,nil );if _ggba !=nil {return nil ,_ggba ;};_ccca (_afbf ,_fcece ,_baba );return _fcece ,nil ;};func _decc (_beag *Monochrome ,_gfa ,_ggbd ,_gbba ,_ccgfa int ,_bcdbd RasterOperator ){if _gfa < 0{_gbba +=_gfa ;
_gfa =0;};_cace :=_gfa +_gbba -_beag .Width ;if _cace > 0{_gbba -=_cace ;};if _ggbd < 0{_ccgfa +=_ggbd ;_ggbd =0;};_gaef :=_ggbd +_ccgfa -_beag .Height ;if _gaef > 0{_ccgfa -=_gaef ;};if _gbba <=0||_ccgfa <=0{return ;};if (_gfa &7)==0{_cdeg (_beag ,_gfa ,_ggbd ,_gbba ,_ccgfa ,_bcdbd );
}else {_acbd (_beag ,_gfa ,_ggbd ,_gbba ,_ccgfa ,_bcdbd );};};func (_faga *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func _fabe (_ggac ,_baa *Monochrome ,_bgg []byte ,_cdb int )(_cbe error ){var (_fdfa ,_bee ,_add ,_bddf ,_ddga ,_cdg ,_gge ,_aaf int ;
_cea ,_cgd ,_fecd ,_cac uint32 ;_dfdf ,_deb byte ;_aage uint16 ;);_ceg :=make ([]byte ,4);_eee :=make ([]byte ,4);for _add =0;_add < _ggac .Height -1;_add ,_bddf =_add +2,_bddf +1{_fdfa =_add *_ggac .BytesPerLine ;_bee =_bddf *_baa .BytesPerLine ;for _ddga ,_cdg =0,0;
_ddga < _cdb ;_ddga ,_cdg =_ddga +4,_cdg +1{for _gge =0;_gge < 4;_gge ++{_aaf =_fdfa +_ddga +_gge ;if _aaf <=len (_ggac .Data )-1&&_aaf < _fdfa +_ggac .BytesPerLine {_ceg [_gge ]=_ggac .Data [_aaf ];}else {_ceg [_gge ]=0x00;};_aaf =_fdfa +_ggac .BytesPerLine +_ddga +_gge ;
if _aaf <=len (_ggac .Data )-1&&_aaf < _fdfa +(2*_ggac .BytesPerLine ){_eee [_gge ]=_ggac .Data [_aaf ];}else {_eee [_gge ]=0x00;};};_cea =_be .BigEndian .Uint32 (_ceg );_cgd =_be .BigEndian .Uint32 (_eee );_fecd =_cea &_cgd ;_fecd |=_fecd <<1;_cac =_cea |_cgd ;
_cac &=_cac <<1;_cgd =_fecd &_cac ;_cgd &=0xaaaaaaaa;_cea =_cgd |(_cgd <<7);_dfdf =byte (_cea >>24);_deb =byte ((_cea >>8)&0xff);_aaf =_bee +_cdg ;if _aaf +1==len (_baa .Data )-1||_aaf +1>=_bee +_baa .BytesPerLine {if _cbe =_baa .setByte (_aaf ,_bgg [_dfdf ]);
_cbe !=nil {return _beg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_aaf );};}else {_aage =(uint16 (_bgg [_dfdf ])<<8)|uint16 (_bgg [_deb ]);if _cbe =_baa .setTwoBytes (_aaf ,_aage );_cbe !=nil {return _beg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_aaf );
};_cdg ++;};};};return nil ;};func _gfcg (_dffa int ,_bfdf int )int {if _dffa < _bfdf {return _dffa ;};return _bfdf ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_bgcf :=y *bytesPerLine +x *3/2;
if _bgcf +1>=len (data ){return _g .NRGBA {},_feed (x ,y );};const (_egadb =0xf;_gbfb =uint8 (0xff););_ccbec :=_gbfb ;if alpha !=nil {_gabg :=y *BytesPerLine (width ,4,1);if _gabg < len (alpha ){if x %2==0{_ccbec =(alpha [_gabg ]>>uint (4))&_egadb ;}else {_ccbec =alpha [_gabg ]&_egadb ;
};_ccbec |=_ccbec <<4;};};var _afdd ,_bbga ,_fbbd uint8 ;if x *3%2==0{_afdd =(data [_bgcf ]>>uint (4))&_egadb ;_bbga =data [_bgcf ]&_egadb ;_fbbd =(data [_bgcf +1]>>uint (4))&_egadb ;}else {_afdd =data [_bgcf ]&_egadb ;_bbga =(data [_bgcf +1]>>uint (4))&_egadb ;
_fbbd =data [_bgcf +1]&_egadb ;};if len (decode )==6{_afdd =uint8 (uint32 (LinearInterpolate (float64 (_afdd ),0,15,decode [0],decode [1]))&0xf);_bbga =uint8 (uint32 (LinearInterpolate (float64 (_bbga ),0,15,decode [2],decode [3]))&0xf);_fbbd =uint8 (uint32 (LinearInterpolate (float64 (_fbbd ),0,15,decode [4],decode [5]))&0xf);
};return _g .NRGBA {R :(_afdd <<4)|(_afdd &0xf),G :(_bbga <<4)|(_bbga &0xf),B :(_fbbd <<4)|(_fbbd &0xf),A :_ccbec },nil ;};func _ede (_bccb _ge .Image ,_acfg Image ,_eac _ge .Rectangle ){for _cfea :=0;_cfea < _eac .Max .X ;_cfea ++{for _fcg :=0;_fcg < _eac .Max .Y ;
_fcg ++{_adg :=_bccb .At (_cfea ,_fcg );_acfg .Set (_cfea ,_fcg ,_adg );};};};type NRGBA64 struct{ImageBase };func (_cced *Gray2 )GrayAt (x ,y int )_g .Gray {_eggf ,_ :=ColorAtGray2BPC (x ,y ,_cced .BytesPerLine ,_cced .Data ,_cced .Decode );return _eggf ;
};func (_fae *Gray2 )Validate ()error {if len (_fae .Data )!=_fae .Height *_fae .BytesPerLine {return ErrInvalidImage ;};return nil ;};type colorConverter struct{_ace func (_eea _ge .Image )(Image ,error );};func (_acde *ImageBase )setFourBytes (_fdca int ,_fdag uint32 )error {if _fdca +3> len (_acde .Data )-1{return _beg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_fdca );
};_acde .Data [_fdca ]=byte ((_fdag &0xff000000)>>24);_acde .Data [_fdca +1]=byte ((_fdag &0xff0000)>>16);_acde .Data [_fdca +2]=byte ((_fdag &0xff00)>>8);_acde .Data [_fdca +3]=byte (_fdag &0xff);return nil ;};func (_cbff *RGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtRGBA32 (x ,y ,_cbff .Width ,_cbff .Data ,_cbff .Alpha ,_cbff .Decode );
};func (_effe *NRGBA32 )At (x ,y int )_g .Color {_bega ,_ :=_effe .ColorAt (x ,y );return _bega };func _ddbd (_fadb _g .NRGBA )_g .RGBA {_fcb ,_fcee ,_bebc ,_gdab :=_fadb .RGBA ();return _g .RGBA {R :uint8 (_fcb >>8),G :uint8 (_fcee >>8),B :uint8 (_bebc >>8),A :uint8 (_gdab >>8)};
};func (_bdfb *Gray8 )Base ()*ImageBase {return &_bdfb .ImageBase };func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_bgdg (n )+1);};func GrayHistogram (g Gray )(_decad [256]int ){switch _acdd :=g .(type ){case Histogramer :return _acdd .Histogram ();
case _ge .Image :_bgff :=_acdd .Bounds ();for _fgcf :=0;_fgcf < _bgff .Max .X ;_fgcf ++{for _gebcd :=0;_gebcd < _bgff .Max .Y ;_gebcd ++{_decad [g .GrayAt (_fgcf ,_gebcd ).Y ]++;};};return _decad ;default:return [256]int {};};};func (_baca *Gray16 )Set (x ,y int ,c _g .Color ){_dede :=(y *_baca .BytesPerLine /2+x )*2;
if _dede +1>=len (_baca .Data ){return ;};_bddca :=_g .Gray16Model .Convert (c ).(_g .Gray16 );_baca .Data [_dede ],_baca .Data [_dede +1]=uint8 (_bddca .Y >>8),uint8 (_bddca .Y &0xff);};func _dcg (_aef _g .NRGBA )_g .Gray {var _cdcb _g .NRGBA ;if _aef ==_cdcb {return _g .Gray {Y :0xff};
};_ccaa ,_gag ,_aeab ,_ :=_aef .RGBA ();_bege :=(19595*_ccaa +38470*_gag +7471*_aeab +1<<15)>>24;return _g .Gray {Y :uint8 (_bege )};};func (_bdfd *Monochrome )Validate ()error {if len (_bdfd .Data )!=_bdfd .Height *_bdfd .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_ccagb :=y *bytesPerLine +x >>3;if _ccagb >=len (data ){return _g .Gray {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bab :=data [_ccagb ]>>uint (7-(x &7))&1;if len (decode )==2{_bab =uint8 (LinearInterpolate (float64 (_bab ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_bab *255},nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_bae :=4*(y *width +x );
if _bae +3>=len (data ){return _g .CMYK {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_bae ]&0xff;M :=data [_bae +1]&0xff;Y :=data [_bae +2]&0xff;K :=data [_bae +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};type NRGBA32 struct{ImageBase };
func (_caef colorConverter )Convert (src _ge .Image )(Image ,error ){return _caef ._ace (src )};func _geeb (_debf *Monochrome ,_dacf ,_efbac ,_efee ,_gfb int ,_gdaf RasterOperator ,_dacg *Monochrome ,_bdfe ,_dfbbc int )error {var (_fgfa bool ;_eegf bool ;
_dcged int ;_cbbb int ;_afgf int ;_gdbcd bool ;_gbea byte ;_ecdb int ;_cfgf int ;_feee int ;_deagg ,_cbeb int ;);_agg :=8-(_dacf &7);_cgecb :=_bebea [_agg ];_gcdb :=_debf .BytesPerLine *_efbac +(_dacf >>3);_bfda :=_dacg .BytesPerLine *_dfbbc +(_bdfe >>3);
if _efee < _agg {_fgfa =true ;_cgecb &=_fbfg [8-_agg +_efee ];};if !_fgfa {_dcged =(_efee -_agg )>>3;if _dcged > 0{_eegf =true ;_cbbb =_gcdb +1;_afgf =_bfda +1;};};_ecdb =(_dacf +_efee )&7;if !(_fgfa ||_ecdb ==0){_gdbcd =true ;_gbea =_fbfg [_ecdb ];_cfgf =_gcdb +1+_dcged ;
_feee =_bfda +1+_dcged ;};switch _gdaf {case PixSrc :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],_dacg .Data [_bfda ],_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;
_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]=_dacg .Data [_afgf +_cbeb ];};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],_dacg .Data [_feee ],_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixNotSrc :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],^_dacg .Data [_bfda ],_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;
};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]=^_dacg .Data [_afgf +_cbeb ];};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],^_dacg .Data [_feee ],_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixSrcOrDst :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],_dacg .Data [_bfda ]|_debf .Data [_gcdb ],_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;
};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]|=_dacg .Data [_afgf +_cbeb ];};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],_dacg .Data [_feee ]|_debf .Data [_cfgf ],_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixSrcAndDst :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],_dacg .Data [_bfda ]&_debf .Data [_gcdb ],_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;
};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]&=_dacg .Data [_afgf +_cbeb ];};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],_dacg .Data [_feee ]&_debf .Data [_cfgf ],_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixSrcXorDst :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],_dacg .Data [_bfda ]^_debf .Data [_gcdb ],_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;
};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]^=_dacg .Data [_afgf +_cbeb ];};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],_dacg .Data [_feee ]^_debf .Data [_cfgf ],_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixNotSrcOrDst :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],^(_dacg .Data [_bfda ])|_debf .Data [_gcdb ],_cgecb );_gcdb +=_debf .BytesPerLine ;
_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]|=^(_dacg .Data [_afgf +_cbeb ]);};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;
_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],^(_dacg .Data [_feee ])|_debf .Data [_cfgf ],_gbea );_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixNotSrcAndDst :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],^(_dacg .Data [_bfda ])&_debf .Data [_gcdb ],_cgecb );
_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]&=^_dacg .Data [_afgf +_cbeb ];};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;
};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],^(_dacg .Data [_feee ])&_debf .Data [_cfgf ],_gbea );_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixSrcOrNotDst :for _deagg =0;
_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],_dacg .Data [_bfda ]|^(_debf .Data [_gcdb ]),_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;
_cbeb ++{_debf .Data [_cbbb +_cbeb ]=_dacg .Data [_afgf +_cbeb ]|^(_debf .Data [_cbbb +_cbeb ]);};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],_dacg .Data [_feee ]|^(_debf .Data [_cfgf ]),_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixSrcAndNotDst :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],_dacg .Data [_bfda ]&^(_debf .Data [_gcdb ]),_cgecb );_gcdb +=_debf .BytesPerLine ;
_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]=_dacg .Data [_afgf +_cbeb ]&^(_debf .Data [_cbbb +_cbeb ]);};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;
};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],_dacg .Data [_feee ]&^(_debf .Data [_cfgf ]),_gbea );_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixNotPixSrcOrDst :for _deagg =0;
_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],^(_dacg .Data [_bfda ]|_debf .Data [_gcdb ]),_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;
_cbeb ++{_debf .Data [_cbbb +_cbeb ]=^(_dacg .Data [_afgf +_cbeb ]|_debf .Data [_cbbb +_cbeb ]);};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],^(_dacg .Data [_feee ]|_debf .Data [_cfgf ]),_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixNotPixSrcAndDst :for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],^(_dacg .Data [_bfda ]&_debf .Data [_gcdb ]),_cgecb );_gcdb +=_debf .BytesPerLine ;
_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;_cbeb ++{_debf .Data [_cbbb +_cbeb ]=^(_dacg .Data [_afgf +_cbeb ]&_debf .Data [_cbbb +_cbeb ]);};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;
};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],^(_dacg .Data [_feee ]&_debf .Data [_cfgf ]),_gbea );_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};case PixNotPixSrcXorDst :for _deagg =0;
_deagg < _gfb ;_deagg ++{_debf .Data [_gcdb ]=_bbgb (_debf .Data [_gcdb ],^(_dacg .Data [_bfda ]^_debf .Data [_gcdb ]),_cgecb );_gcdb +=_debf .BytesPerLine ;_bfda +=_dacg .BytesPerLine ;};if _eegf {for _deagg =0;_deagg < _gfb ;_deagg ++{for _cbeb =0;_cbeb < _dcged ;
_cbeb ++{_debf .Data [_cbbb +_cbeb ]=^(_dacg .Data [_afgf +_cbeb ]^_debf .Data [_cbbb +_cbeb ]);};_cbbb +=_debf .BytesPerLine ;_afgf +=_dacg .BytesPerLine ;};};if _gdbcd {for _deagg =0;_deagg < _gfb ;_deagg ++{_debf .Data [_cfgf ]=_bbgb (_debf .Data [_cfgf ],^(_dacg .Data [_feee ]^_debf .Data [_cfgf ]),_gbea );
_cfgf +=_debf .BytesPerLine ;_feee +=_dacg .BytesPerLine ;};};default:_ec .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_gdaf );return _e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_gff *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_eab :=_bgdg (uint (factor ));if !IsPowerOf2 (uint (factor )){_eab ++;};_gdgb :=make ([]int ,_eab );for _gbfe :=range _gdgb {_gdgb [_gbfe ]=4;};_bbbd ,_dafa :=_cgbb (_gff ,_gdgb ...);
if _dafa !=nil {return nil ,_dafa ;};return _bbbd ,nil ;};func _debg (_fdcf Gray ,_adff nrgba64 ,_fgf _ge .Rectangle ){for _cec :=0;_cec < _fgf .Max .X ;_cec ++{for _bacd :=0;_bacd < _fgf .Max .Y ;_bacd ++{_dfaf :=_bdb (_adff .NRGBA64At (_cec ,_bacd ));
_fdcf .SetGray (_cec ,_bacd ,_dfaf );};};};func (_cbb *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_cbb .copy ()}};func (_dbbe *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_dbbe .Width ,_dbbe .BytesPerLine ,_dbbe .Data ,_dbbe .Alpha ,_dbbe .Decode );
};func _bff (_gcb _ge .Image )(Image ,error ){if _gbca ,_gedb :=_gcb .(*CMYK32 );_gedb {return _gbca .Copy (),nil ;};_cfd :=_gcb .Bounds ();_eaf ,_cae :=NewImage (_cfd .Max .X ,_cfd .Max .Y ,8,4,nil ,nil ,nil );if _cae !=nil {return nil ,_cae ;};switch _eca :=_gcb .(type ){case CMYK :_gac (_eca ,_eaf .(CMYK ),_cfd );
case Gray :_dca (_eca ,_eaf .(CMYK ),_cfd );case NRGBA :_debb (_eca ,_eaf .(CMYK ),_cfd );case RGBA :_ccac (_eca ,_eaf .(CMYK ),_cfd );default:_ede (_gcb ,_eaf ,_cfd );};return _eaf ,nil ;};func _faabd (_dba NRGBA ,_bgfba RGBA ,_badb _ge .Rectangle ){for _egd :=0;
_egd < _badb .Max .X ;_egd ++{for _gace :=0;_gace < _badb .Max .Y ;_gace ++{_ddda :=_dba .NRGBAAt (_egd ,_gace );_bgfba .SetRGBA (_egd ,_gace ,_ddbd (_ddda ));};};};var _ NRGBA =&NRGBA32 {};func (_fdfga *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_dcdc ,_ :=ColorAtNRGBA64 (x ,y ,_fdfga .Width ,_fdfga .Data ,_fdfga .Alpha ,_fdfga .Decode );
return _dcdc ;};func (_ebcf *RGBA32 )Base ()*ImageBase {return &_ebcf .ImageBase };func _ccca (_dded _ge .Image ,_acbfg Image ,_fefe _ge .Rectangle ){switch _fcafa :=_dded .(type ){case Gray :_eagc (_fcafa ,_acbfg .(Gray ),_fefe );case NRGBA :_dfdg (_fcafa ,_acbfg .(Gray ),_fefe );
case CMYK :_cfcf (_fcafa ,_acbfg .(Gray ),_fefe );case RGBA :_gdgba (_fcafa ,_acbfg .(Gray ),_fefe );default:_ede (_dded ,_acbfg ,_fefe );};};func (_efgae *ImageBase )setEightBytes (_gbbe int ,_cgc uint64 )error {_bcgd :=_efgae .BytesPerLine -(_gbbe %_efgae .BytesPerLine );
if _efgae .BytesPerLine !=_efgae .Width >>3{_bcgd --;};if _bcgd >=8{return _efgae .setEightFullBytes (_gbbe ,_cgc );};return _efgae .setEightPartlyBytes (_gbbe ,_bcgd ,_cgc );};func (_fege *Monochrome )copy ()*Monochrome {_cdgb :=_aee (_fege .Width ,_fege .Height );
_cdgb .ModelThreshold =_fege .ModelThreshold ;_cdgb .Data =make ([]byte ,len (_fege .Data ));copy (_cdgb .Data ,_fege .Data );if len (_fege .Decode )!=0{_cdgb .Decode =make ([]float64 ,len (_fege .Decode ));copy (_cdgb .Decode ,_fege .Decode );};if len (_fege .Alpha )!=0{_cdgb .Alpha =make ([]byte ,len (_fege .Alpha ));
copy (_cdgb .Alpha ,_fege .Alpha );};return _cdgb ;};func (_eacd *Gray4 )Histogram ()(_fcbf [256]int ){for _cga :=0;_cga < _eacd .Width ;_cga ++{for _aaa :=0;_aaa < _eacd .Height ;_aaa ++{_fcbf [_eacd .GrayAt (_cga ,_aaa ).Y ]++;};};return _fcbf ;};func (_ggfg *Gray8 )At (x ,y int )_g .Color {_acfc ,_ :=_ggfg .ColorAt (x ,y );
return _acfc };func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_beg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_aad *NRGBA32 )Validate ()error {if len (_aad .Data )!=3*_aad .Width *_aad .Height {return _e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Gray =&Gray16 {};func ConverterFunc (converterFunc func (_bfe _ge .Image )(Image ,error ))ColorConverter {return colorConverter {_ace :converterFunc };};func IsGrayImgBlackAndWhite (i *_ge .Gray )bool {return _cefdc (i )};func (_ffab *Monochrome )GrayAt (x ,y int )_g .Gray {_bcd ,_ :=ColorAtGray1BPC (x ,y ,_ffab .BytesPerLine ,_ffab .Data ,_ffab .Decode );
return _bcd ;};func (_eade *Gray8 )Set (x ,y int ,c _g .Color ){_faag :=y *_eade .BytesPerLine +x ;if _faag > len (_eade .Data )-1{return ;};_affdb :=_g .GrayModel .Convert (c );_eade .Data [_faag ]=_affdb .(_g .Gray ).Y ;};type SMasker interface{HasAlpha ()bool ;
GetAlpha ()[]byte ;MakeAlpha ();};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_ddbb :=y *bytesPerLine +x ;if _ddbb >=len (data ){return _g .Gray {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gefa :=data [_ddbb ];if len (decode )==2{_gefa =uint8 (uint32 (LinearInterpolate (float64 (_gefa ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_gefa },nil ;};func (_cfee *Gray4 )At (x ,y int )_g .Color {_bebca ,_ :=_cfee .ColorAt (x ,y );
return _bebca };func (_bcbgd *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_bcbgd .ModelThreshold )};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_edeg :=y *width +x ;_egab :=3*_edeg ;if _egab +2>=len (data ){return _g .NRGBA {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fccaf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _edeg {_fccaf =alpha [_edeg ];};_beaae ,_adffb ,_dfee :=data [_egab ],data [_egab +1],data [_egab +2];if len (decode )==6{_cbaa :=LinearInterpolate (float64 (_beaae ),0,255.0,decode [0],decode [1]);
_cabed :=LinearInterpolate (float64 (_adffb ),0,255.0,decode [2],decode [3]);_bga :=LinearInterpolate (float64 (_dfee ),0,255.0,decode [4],decode [5]);if _cbaa <=1.0&&_cabed <=1.0&&_bga <=1.0{_cbaa *=255.0;_cabed *=255.0;_bga *=255.0;};_beaae =uint8 (_cbaa )&0xff;
_adffb =uint8 (_cabed )&0xff;_dfee =uint8 (_bga )&0xff;};return _g .NRGBA {R :_beaae ,G :_adffb ,B :_dfee ,A :_fccaf },nil ;};func (_ab *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ab .copy ()}};func _bcbg (_dabb _ge .Image )(Image ,error ){if _gcee ,_eag :=_dabb .(*Monochrome );
_eag {return _gcee ,nil ;};_bed :=_dabb .Bounds ();var _bfdg Gray ;switch _efc :=_dabb .(type ){case Gray :_bfdg =_efc ;case NRGBA :_bfdg =&Gray8 {ImageBase :NewImageBase (_bed .Max .X ,_bed .Max .Y ,8,1,nil ,nil ,nil )};_adf (_bfdg ,_efc ,_bed );case nrgba64 :_bfdg =&Gray8 {ImageBase :NewImageBase (_bed .Max .X ,_bed .Max .Y ,8,1,nil ,nil ,nil )};
_debg (_bfdg ,_efc ,_bed );default:_ccgfb ,_gcfa :=GrayConverter .Convert (_dabb );if _gcfa !=nil {return nil ,_gcfa ;};_bfdg =_ccgfb .(Gray );};_ffg ,_aab :=NewImage (_bed .Max .X ,_bed .Max .Y ,1,1,nil ,nil ,nil );if _aab !=nil {return nil ,_aab ;};_fcac :=_ffg .(*Monochrome );
_dgcc :=AutoThresholdTriangle (GrayHistogram (_bfdg ));for _acgc :=0;_acgc < _bed .Max .X ;_acgc ++{for _fbf :=0;_fbf < _bed .Max .Y ;_fbf ++{_gccc :=_cffd (_bfdg .GrayAt (_acgc ,_fbf ),monochromeModel (_dgcc ));_fcac .SetGray (_acgc ,_fbf ,_gccc );};};
return _ffg ,nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_edf :=y *bytesPerLine +x >>2;if _edf >=len (data ){return _g .Gray {},_beg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_acc :=data [_edf ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_acc =uint8 (uint32 (LinearInterpolate (float64 (_acc ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_acc *85},nil ;};func (_adec *Gray8 )Validate ()error {if len (_adec .Data )!=_adec .Height *_adec .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_bfdac *NRGBA32 )Bounds ()_ge .Rectangle {return _ge .Rectangle {Max :_ge .Point {X :_bfdac .Width ,Y :_bfdac .Height }};};func (_affd *Gray2 )Histogram ()(_dcf [256]int ){for _dbe :=0;_dbe < _affd .Width ;_dbe ++{for _eded :=0;_eded < _affd .Height ;
_eded ++{_dcf [_affd .GrayAt (_dbe ,_eded ).Y ]++;};};return _dcf ;};func (_bbcf *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_bbcf .Width ||y >=_bbcf .Height {return ;};g =_efbc (g );_bbcf .setGray (x ,y ,g );};func (_fffe *Gray4 )Base ()*ImageBase {return &_fffe .ImageBase };
func (_bgce *NRGBA64 )Base ()*ImageBase {return &_bgce .ImageBase };func _eec (_df ,_ged *Monochrome )(_fg error ){_gg :=_ged .BytesPerLine ;_egb :=_df .BytesPerLine ;_dc :=_ged .BytesPerLine *4-_df .BytesPerLine ;var (_fdc ,_gc byte ;_ac uint32 ;_gead ,_acb ,_ef ,_gb ,_cc ,_fe ,_cee int ;
);for _ef =0;_ef < _ged .Height ;_ef ++{_gead =_ef *_gg ;_acb =4*_ef *_egb ;for _gb =0;_gb < _gg ;_gb ++{_fdc =_ged .Data [_gead +_gb ];_ac =_dad [_fdc ];_fe =_acb +_gb *4;if _dc !=0&&(_gb +1)*4> _df .BytesPerLine {for _cc =_dc ;_cc > 0;_cc --{_gc =byte ((_ac >>uint (_cc *8))&0xff);
_cee =_fe +(_dc -_cc );if _fg =_df .setByte (_cee ,_gc );_fg !=nil {return _fg ;};};}else if _fg =_df .setFourBytes (_fe ,_ac );_fg !=nil {return _fg ;};if _fg =_df .setFourBytes (_acb +_gb *4,_dad [_ged .Data [_gead +_gb ]]);_fg !=nil {return _fg ;};};
for _cc =1;_cc < 4;_cc ++{for _gb =0;_gb < _egb ;_gb ++{if _fg =_df .setByte (_acb +_cc *_egb +_gb ,_df .Data [_acb +_gb ]);_fg !=nil {return _fg ;};};};};return nil ;};func (_cdf *monochromeThresholdConverter )Convert (img _ge .Image )(Image ,error ){if _acd ,_gba :=img .(*Monochrome );
_gba {return _acd .Copy (),nil ;};_fff :=img .Bounds ();_ccdb ,_ccdf :=NewImage (_fff .Max .X ,_fff .Max .Y ,1,1,nil ,nil ,nil );if _ccdf !=nil {return nil ,_ccdf ;};_ccdb .(*Monochrome ).ModelThreshold =_cdf .Threshold ;for _afa :=0;_afa < _fff .Max .X ;
_afa ++{for _bggb :=0;_bggb < _fff .Max .Y ;_bggb ++{_fdcb :=img .At (_afa ,_bggb );_ccdb .Set (_afa ,_bggb ,_fdcb );};};return _ccdb ,nil ;};func (_bfeb *NRGBA64 )setNRGBA64 (_bbcb int ,_cffg _g .NRGBA64 ,_gfee int ){_bfeb .Data [_bbcb ]=uint8 (_cffg .R >>8);
_bfeb .Data [_bbcb +1]=uint8 (_cffg .R &0xff);_bfeb .Data [_bbcb +2]=uint8 (_cffg .G >>8);_bfeb .Data [_bbcb +3]=uint8 (_cffg .G &0xff);_bfeb .Data [_bbcb +4]=uint8 (_cffg .B >>8);_bfeb .Data [_bbcb +5]=uint8 (_cffg .B &0xff);if _gfee +1< len (_bfeb .Alpha ){_bfeb .Alpha [_gfee ]=uint8 (_cffg .A >>8);
_bfeb .Alpha [_gfee +1]=uint8 (_cffg .A &0xff);};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_cega :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _cega ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_fggab :=width *colorComponents *bitsPerComponent ;_acadc :=_cega *8;_cdd :=8-(_acadc -_fggab );_ggg :=_c .NewReader (data );_egfb :=_cega -1;_aeeb :=make ([]byte ,_egfb );_gege :=make ([]byte ,height *_cega );_ecd :=_c .NewWriterMSB (_gege );var _fccg uint64 ;
var _ddacf error ;for _bdfdb :=0;_bdfdb < height ;_bdfdb ++{_ ,_ddacf =_ggg .Read (_aeeb );if _ddacf !=nil {return nil ,_ddacf ;};_ ,_ddacf =_ecd .Write (_aeeb );if _ddacf !=nil {return nil ,_ddacf ;};_fccg ,_ddacf =_ggg .ReadBits (byte (_cdd ));if _ddacf !=nil {return nil ,_ddacf ;
};_ ,_ddacf =_ecd .WriteBits (_fccg ,_cdd );if _ddacf !=nil {return nil ,_ddacf ;};_ecd .FinishByte ();};return _gege ,nil ;};func _cfec (_aabe uint8 )bool {if _aabe ==0||_aabe ==255{return true ;};return false ;};func _dfdg (_fcdc NRGBA ,_bcee Gray ,_aabc _ge .Rectangle ){for _dadf :=0;
_dadf < _aabc .Max .X ;_dadf ++{for _dffd :=0;_dffd < _aabc .Max .Y ;_dffd ++{_fdad :=_bge (_fcdc .NRGBAAt (_dadf ,_dffd ));_bcee .SetGray (_dadf ,_dffd ,_fdad );};};};func (_cbdc *Gray16 )Base ()*ImageBase {return &_cbdc .ImageBase };