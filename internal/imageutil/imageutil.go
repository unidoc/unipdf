//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_gc "encoding/binary";_a "errors";_f "fmt";_ee "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_e "image";_c "image/color";_cc "image/draw";_g "math";);func (_edcc *Gray8 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray8BPC (x ,y ,_edcc .BytesPerLine ,_edcc .Data ,_edcc .Decode );
};func _gcb (_acga Gray ,_eceg NRGBA ,_ddf _e .Rectangle ){for _cgcc :=0;_cgcc < _ddf .Max .X ;_cgcc ++{for _ffc :=0;_ffc < _ddf .Max .Y ;_ffc ++{_ead :=_eegb (_eceg .NRGBAAt (_cgcc ,_ffc ));_acga .SetGray (_cgcc ,_ffc ,_ead );};};};func FromGoImage (i _e .Image )(Image ,error ){switch _aabg :=i .(type ){case Image :return _aabg .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_e .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_e .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
func (_egad *Gray4 )Validate ()error {if len (_egad .Data )!=_egad .Height *_egad .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gfc (_eacga *Monochrome ,_gfa int ,_edfa []byte )(_fdg *Monochrome ,_bfe error ){const _gfag ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _eacga ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _gfa < 1||_gfa > 4{return nil ,_a .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _eacga .Height <=1{return nil ,_a .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_fdg =_efc (_eacga .Width /2,_eacga .Height /2);
if _edfa ==nil {_edfa =_bgg ();};_acb :=_aeab (_eacga .BytesPerLine ,2*_fdg .BytesPerLine );switch _gfa {case 1:_bfe =_dac (_eacga ,_fdg ,_edfa ,_acb );case 2:_bfe =_afd (_eacga ,_fdg ,_edfa ,_acb );case 3:_bfe =_acc (_eacga ,_fdg ,_edfa ,_acb );case 4:_bfe =_bgc (_eacga ,_fdg ,_edfa ,_acb );
};if _bfe !=nil {return nil ,_bfe ;};return _fdg ,nil ;};func _bge (_cceb *Monochrome ,_ca ,_fgg int )(*Monochrome ,error ){if _cceb ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ca <=0||_fgg <=0{return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _ca ==_fgg {if _ca ==1{return _cceb .copy (),nil ;};if _ca ==2||_ca ==4||_ca ==8{_ce ,_gf :=_eed (_cceb ,_ca );
if _gf !=nil {return nil ,_gf ;};return _ce ,nil ;};};_da :=_ca *_cceb .Width ;_ada :=_fgg *_cceb .Height ;_dee :=_efc (_da ,_ada );_fcg :=_dee .BytesPerLine ;var (_dfg ,_eb ,_dc ,_eeb ,_edf int ;_gaf byte ;_ddd error ;);for _eb =0;_eb < _cceb .Height ;
_eb ++{_dfg =_fgg *_eb *_fcg ;for _dc =0;_dc < _cceb .Width ;_dc ++{if _bfa :=_cceb .getBitAt (_dc ,_eb );_bfa {_edf =_ca *_dc ;for _eeb =0;_eeb < _ca ;_eeb ++{_dee .setIndexedBit (_dfg *8+_edf +_eeb );};};};for _eeb =1;_eeb < _fgg ;_eeb ++{_edd :=_dfg +_eeb *_fcg ;
for _bde :=0;_bde < _fcg ;_bde ++{if _gaf ,_ddd =_dee .getByte (_dfg +_bde );_ddd !=nil {return nil ,_ddd ;};if _ddd =_dee .setByte (_edd +_bde ,_gaf );_ddd !=nil {return nil ,_ddd ;};};};};return _dee ,nil ;};func (_gegb *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_dcba :=_beac (uint (factor ));
if !IsPowerOf2 (uint (factor )){_dcba ++;};_adf :=make ([]int ,_dcba );for _abd :=range _adf {_adf [_abd ]=4;};_bbb ,_aae :=_ec (_gegb ,_adf ...);if _aae !=nil {return nil ,_aae ;};return _bbb ,nil ;};func (_beb *CMYK32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtCMYK (x ,y ,_beb .Width ,_beb .Data ,_beb .Decode );
};type colorConverter struct{_gdda func (_dfgb _e .Image )(Image ,error );};func _dfc (_cegc _c .NYCbCrA )_c .NRGBA {_bcb :=int32 (_cegc .Y )*0x10101;_baf :=int32 (_cegc .Cb )-128;_gad :=int32 (_cegc .Cr )-128;_aba :=_bcb +91881*_gad ;if uint32 (_aba )&0xff000000==0{_aba >>=8;
}else {_aba =^(_aba >>31)&0xffff;};_eedb :=_bcb -22554*_baf -46802*_gad ;if uint32 (_eedb )&0xff000000==0{_eedb >>=8;}else {_eedb =^(_eedb >>31)&0xffff;};_ageg :=_bcb +116130*_baf ;if uint32 (_ageg )&0xff000000==0{_ageg >>=8;}else {_ageg =^(_ageg >>31)&0xffff;
};return _c .NRGBA {R :uint8 (_aba >>8),G :uint8 (_eedb >>8),B :uint8 (_ageg >>8),A :_cegc .A };};func (_dgfg *NRGBA32 )setRGBA (_dacg int ,_ccfde _c .NRGBA ){_gecd :=3*_dacg ;_dgfg .Data [_gecd ]=_ccfde .R ;_dgfg .Data [_gecd +1]=_ccfde .G ;_dgfg .Data [_gecd +2]=_ccfde .B ;
if _dacg < len (_dgfg .Alpha ){_dgfg .Alpha [_dacg ]=_ccfde .A ;};};type Gray2 struct{ImageBase };func (_eefg *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_eefg .copy ()}};func (_ecdg *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_ecdg .copy ()}};
func _ffe (_ddb _c .Gray )_c .CMYK {return _c .CMYK {K :0xff-_ddb .Y }};func (_cdcb *Gray8 )Set (x ,y int ,c _c .Color ){_adec :=y *_cdcb .BytesPerLine +x ;if _adec > len (_cdcb .Data )-1{return ;};_abefg :=_c .GrayModel .Convert (c );_cdcb .Data [_adec ]=_abefg .(_c .Gray ).Y ;
};func (_dgeg *Gray4 )ColorModel ()_c .Model {return Gray4Model };func _bgcd (_fggc _e .Image )(Image ,error ){if _effdc ,_cgae :=_fggc .(*NRGBA32 );_cgae {return _effdc .Copy (),nil ;};_bgfad ,_agcec ,_daag :=_fcgfa (_fggc ,1);_bcae ,_cdbe :=NewImage (_bgfad .Max .X ,_bgfad .Max .Y ,8,3,nil ,_daag ,nil );
if _cdbe !=nil {return nil ,_cdbe ;};_ffgab (_fggc ,_bcae ,_bgfad );if len (_daag )!=0&&!_agcec {if _afef :=_gfea (_daag ,_bcae );_afef !=nil {return nil ,_afef ;};};return _bcae ,nil ;};func (_acd *ImageBase )setTwoBytes (_fba int ,_dggf uint16 )error {if _fba +1> len (_acd .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_acd .Data [_fba ]=byte ((_dggf &0xff00)>>8);_acd .Data [_fba +1]=byte (_dggf &0xff);return nil ;};func (_cgd *CMYK32 )Base ()*ImageBase {return &_cgd .ImageBase };var (Gray2Model =_c .ModelFunc (_afgc );Gray4Model =_c .ModelFunc (_gfe );NRGBA16Model =_c .ModelFunc (_ddfcf );
);func (_afae *ImageBase )setFourBytes (_dfeg int ,_bggf uint32 )error {if _dfeg +3> len (_afae .Data )-1{return _f .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_dfeg );
};_afae .Data [_dfeg ]=byte ((_bggf &0xff000000)>>24);_afae .Data [_dfeg +1]=byte ((_bggf &0xff0000)>>16);_afae .Data [_dfeg +2]=byte ((_bggf &0xff00)>>8);_afae .Data [_dfeg +3]=byte (_bggf &0xff);return nil ;};func _efc (_aca ,_cgc int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_aca ,_cgc ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};var (MonochromeConverter =ConverterFunc (_eega );Gray2Converter =ConverterFunc (_afe );Gray4Converter =ConverterFunc (_cdcg );GrayConverter =ConverterFunc (_edaf );Gray16Converter =ConverterFunc (_fcgf );NRGBA16Converter =ConverterFunc (_fcda );NRGBAConverter =ConverterFunc (_bgcd );
NRGBA64Converter =ConverterFunc (_fbgc );RGBAConverter =ConverterFunc (_gdge );CMYKConverter =ConverterFunc (_cffc ););func (_gga *Monochrome )setGray (_abdf int ,_gfad _c .Gray ,_ceed int ){if _gfad .Y ==0{_gga .clearBit (_ceed ,_abdf );}else {_gga .setGrayBit (_ceed ,_abdf );
};};func _dafd (_cgdd nrgba64 ,_fbf NRGBA ,_gdff _e .Rectangle ){for _gcacc :=0;_gcacc < _gdff .Max .X ;_gcacc ++{for _edeb :=0;_edeb < _gdff .Max .Y ;_edeb ++{_ffce :=_cgdd .NRGBA64At (_gcacc ,_edeb );_fbf .SetNRGBA (_gcacc ,_edeb ,_fgee (_ffce ));};};
};func (_eeg *CMYK32 )Validate ()error {if len (_eeg .Data )!=4*_eeg .Width *_eeg .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fecc *Monochrome )clearBit (_baad ,_gee int ){_fecc .Data [_baad ]&=^(0x80>>uint (_gee &7))};func (_ggeag *NRGBA64 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_ggeag .Width ,Y :_ggeag .Height }};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _cfabd ,_dacd ,_bbee ,_eadeb int ;
for _eaade :=0;_eaade < len (histogram );_eaade ++{if histogram [_eaade ]> 0{_cfabd =_eaade ;break ;};};if _cfabd > 0{_cfabd --;};for _adebd :=255;_adebd > 0;_adebd --{if histogram [_adebd ]> 0{_eadeb =_adebd ;break ;};};if _eadeb < 255{_eadeb ++;};for _cdfdf :=0;
_cdfdf < 256;_cdfdf ++{if histogram [_cdfdf ]> _dacd {_bbee =_cdfdf ;_dacd =histogram [_cdfdf ];};};var _cacd bool ;if (_bbee -_cfabd )< (_eadeb -_bbee ){_cacd =true ;var _gfgcc int ;_daefg :=255;for _gfgcc < _daefg {_gbcd :=histogram [_gfgcc ];histogram [_gfgcc ]=histogram [_daefg ];
histogram [_daefg ]=_gbcd ;_gfgcc ++;_daefg --;};_cfabd =255-_eadeb ;_bbee =255-_bbee ;};if _cfabd ==_bbee {return uint8 (_cfabd );};_dfbg :=float64 (histogram [_bbee ]);_gafc :=float64 (_cfabd -_bbee );_ggdab :=_g .Sqrt (_dfbg *_dfbg +_gafc *_gafc );_dfbg /=_ggdab ;
_gafc /=_ggdab ;_ggdab =_dfbg *float64 (_cfabd )+_gafc *float64 (histogram [_cfabd ]);_gcfe :=_cfabd ;var _bfbc float64 ;for _bfaf :=_cfabd +1;_bfaf <=_bbee ;_bfaf ++{_bfcbd :=_dfbg *float64 (_bfaf )+_gafc *float64 (histogram [_bfaf ])-_ggdab ;if _bfcbd > _bfbc {_gcfe =_bfaf ;
_bfbc =_bfcbd ;};};_gcfe --;if _cacd {var _cfdg int ;_cbae :=255;for _cfdg < _cbae {_beed :=histogram [_cfdg ];histogram [_cfdg ]=histogram [_cbae ];histogram [_cbae ]=_beed ;_cfdg ++;_cbae --;};return uint8 (255-_gcfe );};return uint8 (_gcfe );};func _ffab (_gefa *Monochrome ,_deafa ,_ccfeg ,_gbgd ,_bfbf int ,_fdca RasterOperator ,_bega *Monochrome ,_gcbg ,_add int )error {var (_gbgf byte ;
_effb int ;_ffdgc int ;_bebe ,_fceb int ;_gbeef ,_aede int ;);_dbfa :=_gbgd >>3;_gbfa :=_gbgd &7;if _gbfa > 0{_gbgf =_dcec [_gbfa ];};_effb =_bega .BytesPerLine *_add +(_gcbg >>3);_ffdgc =_gefa .BytesPerLine *_ccfeg +(_deafa >>3);switch _fdca {case PixSrc :for _gbeef =0;
_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]=_bega .Data [_bebe ];_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],_bega .Data [_bebe ],_gbgf );
};};case PixNotSrc :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]=^(_bega .Data [_bebe ]);_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],^_bega .Data [_bebe ],_gbgf );
};};case PixSrcOrDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]|=_bega .Data [_bebe ];_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],_bega .Data [_bebe ]|_gefa .Data [_fceb ],_gbgf );
};};case PixSrcAndDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]&=_bega .Data [_bebe ];_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],_bega .Data [_bebe ]&_gefa .Data [_fceb ],_gbgf );
};};case PixSrcXorDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]^=_bega .Data [_bebe ];_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],_bega .Data [_bebe ]^_gefa .Data [_fceb ],_gbgf );
};};case PixNotSrcOrDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]|=^(_bega .Data [_bebe ]);_fceb ++;_bebe ++;
};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],^(_bega .Data [_bebe ])|_gefa .Data [_fceb ],_gbgf );};};case PixNotSrcAndDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;
for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]&=^(_bega .Data [_bebe ]);_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],^(_bega .Data [_bebe ])&_gefa .Data [_fceb ],_gbgf );};};case PixSrcOrNotDst :for _gbeef =0;
_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]=_bega .Data [_bebe ]|^(_gefa .Data [_fceb ]);_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],_bega .Data [_bebe ]|^(_gefa .Data [_fceb ]),_gbgf );
};};case PixSrcAndNotDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]=_bega .Data [_bebe ]&^(_gefa .Data [_fceb ]);
_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],_bega .Data [_bebe ]&^(_gefa .Data [_fceb ]),_gbgf );};};case PixNotPixSrcOrDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;
for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]=^(_bega .Data [_bebe ]|_gefa .Data [_fceb ]);_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],^(_bega .Data [_bebe ]|_gefa .Data [_fceb ]),_gbgf );};};case PixNotPixSrcAndDst :for _gbeef =0;
_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]=^(_bega .Data [_bebe ]&_gefa .Data [_fceb ]);_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],^(_bega .Data [_bebe ]&_gefa .Data [_fceb ]),_gbgf );
};};case PixNotPixSrcXorDst :for _gbeef =0;_gbeef < _bfbf ;_gbeef ++{_bebe =_effb +_gbeef *_bega .BytesPerLine ;_fceb =_ffdgc +_gbeef *_gefa .BytesPerLine ;for _aede =0;_aede < _dbfa ;_aede ++{_gefa .Data [_fceb ]=^(_bega .Data [_bebe ]^_gefa .Data [_fceb ]);
_fceb ++;_bebe ++;};if _gbfa > 0{_gefa .Data [_fceb ]=_eaadc (_gefa .Data [_fceb ],^(_bega .Data [_bebe ]^_gefa .Data [_fceb ]),_gbgf );};};default:_ee .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_fdca );
return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_bbba *NRGBA32 )Set (x ,y int ,c _c .Color ){_edcfe :=y *_bbba .Width +x ;_agd :=3*_edcfe ;
if _agd +2>=len (_bbba .Data ){return ;};_eedef :=_c .NRGBAModel .Convert (c ).(_c .NRGBA );_bbba .setRGBA (_edcfe ,_eedef );};func _ddfcf (_bacc _c .Color )_c .Color {_ffgef :=_c .NRGBAModel .Convert (_bacc ).(_c .NRGBA );return _cfeca (_ffgef );};func _gcf (_fbg _c .Gray ,_gdgb monochromeModel )_c .Gray {if _fbg .Y > uint8 (_gdgb ){return _c .Gray {Y :_g .MaxUint8 };
};return _c .Gray {};};func (_fdcf *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_a .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_eee :=_efc (width ,height );_cbbb :=make ([]int ,height );_dgca :=make ([]int ,width );_eafd :=float64 (_fdcf .Width )/float64 (width );_gge :=float64 (_fdcf .Height )/float64 (height );for _aea :=0;_aea < height ;_aea ++{_cbbb [_aea ]=int (_g .Min (_gge *float64 (_aea )+0.5,float64 (_fdcf .Height -1)));
};for _dccc :=0;_dccc < width ;_dccc ++{_dgca [_dccc ]=int (_g .Min (_eafd *float64 (_dccc )+0.5,float64 (_fdcf .Width -1)));};_geaa :=-1;_cffcf :=byte (0);for _fagb :=0;_fagb < height ;_fagb ++{_caff :=_cbbb [_fagb ]*_fdcf .BytesPerLine ;_gef :=_fagb *_eee .BytesPerLine ;
for _afgf :=0;_afgf < width ;_afgf ++{_cbdg :=_dgca [_afgf ];if _cbdg !=_geaa {_cffcf =_fdcf .getBit (_caff ,_cbdg );if _cffcf !=0{_eee .setBit (_gef ,_afgf );};_geaa =_cbdg ;}else {if _cffcf !=0{_eee .setBit (_gef ,_afgf );};};};};return _eee ,nil ;};
func (_bba *ImageBase )newAlpha (){_egbb :=BytesPerLine (_bba .Width ,_bba .BitsPerComponent ,1);_bba .Alpha =make ([]byte ,_bba .Height *_egbb );};func (_aebg *NRGBA32 )Base ()*ImageBase {return &_aebg .ImageBase };func _aabc (_daba _e .Image ,_acbee Image ,_gfga _e .Rectangle ){switch _cabc :=_daba .(type ){case Gray :_ecac (_cabc ,_acbee .(Gray ),_gfga );
case NRGBA :_cbfdg (_cabc ,_acbee .(Gray ),_gfga );case CMYK :_dccce (_cabc ,_acbee .(Gray ),_gfga );case RGBA :_bcca (_cabc ,_acbee .(Gray ),_gfga );default:_aec (_daba ,_acbee ,_gfga );};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};func _ddda (_feeg *Monochrome ,_aac ,_eebd ,_bcgg ,_ccafc int ,_eedg RasterOperator ,_bcff *Monochrome ,_bbf ,_bdag int )error {var (_baadf bool ;_cfg bool ;_dcead byte ;_bdgde int ;_addg int ;_ccbg int ;_agcf int ;_ddbe bool ;_gaff int ;_cggg int ;_dabg int ;
_dfaa bool ;_ccbga byte ;_deab int ;_agcg int ;_dfgc int ;_beab byte ;_cccd int ;_ecgc int ;_gefed uint ;_cdd uint ;_eedbd byte ;_dddf shift ;_fcea bool ;_dead bool ;_gcad ,_ddbf int ;);if _bbf &7!=0{_ecgc =8-(_bbf &7);};if _aac &7!=0{_addg =8-(_aac &7);
};if _ecgc ==0&&_addg ==0{_eedbd =_gfff [0];}else {if _addg > _ecgc {_gefed =uint (_addg -_ecgc );}else {_gefed =uint (8-(_ecgc -_addg ));};_cdd =8-_gefed ;_eedbd =_gfff [_gefed ];};if (_aac &7)!=0{_baadf =true ;_bdgde =8-(_aac &7);_dcead =_gfff [_bdgde ];
_ccbg =_feeg .BytesPerLine *_eebd +(_aac >>3);_agcf =_bcff .BytesPerLine *_bdag +(_bbf >>3);_cccd =8-(_bbf &7);if _bdgde > _cccd {_dddf =_ecdd ;if _bcgg >=_ecgc {_fcea =true ;};}else {_dddf =_fgea ;};};if _bcgg < _bdgde {_cfg =true ;_dcead &=_dcec [8-_bdgde +_bcgg ];
};if !_cfg {_gaff =(_bcgg -_bdgde )>>3;if _gaff !=0{_ddbe =true ;_cggg =_feeg .BytesPerLine *_eebd +((_aac +_addg )>>3);_dabg =_bcff .BytesPerLine *_bdag +((_bbf +_addg )>>3);};};_deab =(_aac +_bcgg )&7;if !(_cfg ||_deab ==0){_dfaa =true ;_ccbga =_dcec [_deab ];
_agcg =_feeg .BytesPerLine *_eebd +((_aac +_addg )>>3)+_gaff ;_dfgc =_bcff .BytesPerLine *_bdag +((_bbf +_addg )>>3)+_gaff ;if _deab > int (_cdd ){_dead =true ;};};switch _eedg {case PixSrc :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;
if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],_beab ,_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;
_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]=_beab ;};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;
};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],_beab ,_ccbga );_agcg +=_feeg .BytesPerLine ;
_dfgc +=_bcff .BytesPerLine ;};};case PixNotSrc :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;
};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],^_beab ,_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );
_feeg .Data [_cggg +_ddbf ]=^_beab ;};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );
};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],^_beab ,_ccbga );_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;};};case PixSrcOrDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;
if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],_beab |_feeg .Data [_ccbg ],_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;
};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]|=_beab ;};_cggg +=_feeg .BytesPerLine ;
_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],_beab |_feeg .Data [_agcg ],_ccbga );
_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;};};case PixSrcAndDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );
};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],_beab &_feeg .Data [_ccbg ],_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;
_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]&=_beab ;};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;
_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],_beab &_feeg .Data [_agcg ],_ccbga );_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;
};};case PixSrcXorDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],_beab ^_feeg .Data [_ccbg ],_dcead );
_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]^=_beab ;
};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],_beab ^_feeg .Data [_agcg ],_ccbga );
_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;};};case PixNotSrcOrDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );
};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],^_beab |_feeg .Data [_ccbg ],_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;
_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]|=^_beab ;};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;
_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],^_beab |_feeg .Data [_agcg ],_ccbga );_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;
};};case PixNotSrcAndDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],^_beab &_feeg .Data [_ccbg ],_dcead );
_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]&=^_beab ;
};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],^_beab &_feeg .Data [_agcg ],_ccbga );
_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;};};case PixSrcOrNotDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );
};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],_beab |^_feeg .Data [_ccbg ],_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;
_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]=_beab |^_feeg .Data [_cggg +_ddbf ];};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;
_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],_beab |^_feeg .Data [_agcg ],_ccbga );_agcg +=_feeg .BytesPerLine ;
_dfgc +=_bcff .BytesPerLine ;};};case PixSrcAndNotDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;
};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],_beab &^_feeg .Data [_ccbg ],_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );
_feeg .Data [_cggg +_ddbf ]=_beab &^_feeg .Data [_cggg +_ddbf ];};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );
};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],_beab &^_feeg .Data [_agcg ],_ccbga );_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;};};case PixNotPixSrcOrDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;
if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],^(_beab |_feeg .Data [_ccbg ]),_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;
};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]=^(_beab |_feeg .Data [_cggg +_ddbf ]);
};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],^(_beab |_feeg .Data [_agcg ]),_ccbga );
_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;};};case PixNotPixSrcAndDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );
};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],^(_beab &_feeg .Data [_ccbg ]),_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;
_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );_feeg .Data [_cggg +_ddbf ]=^(_beab &_feeg .Data [_cggg +_ddbf ]);};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};
if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],^(_beab &_feeg .Data [_agcg ]),_ccbga );_agcg +=_feeg .BytesPerLine ;
_dfgc +=_bcff .BytesPerLine ;};};case PixNotPixSrcXorDst :if _baadf {for _gcad =0;_gcad < _ccafc ;_gcad ++{if _dddf ==_ecdd {_beab =_bcff .Data [_agcf ]<<_gefed ;if _fcea {_beab =_eaadc (_beab ,_bcff .Data [_agcf +1]>>_cdd ,_eedbd );};}else {_beab =_bcff .Data [_agcf ]>>_cdd ;
};_feeg .Data [_ccbg ]=_eaadc (_feeg .Data [_ccbg ],^(_beab ^_feeg .Data [_ccbg ]),_dcead );_ccbg +=_feeg .BytesPerLine ;_agcf +=_bcff .BytesPerLine ;};};if _ddbe {for _gcad =0;_gcad < _ccafc ;_gcad ++{for _ddbf =0;_ddbf < _gaff ;_ddbf ++{_beab =_eaadc (_bcff .Data [_dabg +_ddbf ]<<_gefed ,_bcff .Data [_dabg +_ddbf +1]>>_cdd ,_eedbd );
_feeg .Data [_cggg +_ddbf ]=^(_beab ^_feeg .Data [_cggg +_ddbf ]);};_cggg +=_feeg .BytesPerLine ;_dabg +=_bcff .BytesPerLine ;};};if _dfaa {for _gcad =0;_gcad < _ccafc ;_gcad ++{_beab =_bcff .Data [_dfgc ]<<_gefed ;if _dead {_beab =_eaadc (_beab ,_bcff .Data [_dfgc +1]>>_cdd ,_eedbd );
};_feeg .Data [_agcg ]=_eaadc (_feeg .Data [_agcg ],^(_beab ^_feeg .Data [_agcg ]),_ccbga );_agcg +=_feeg .BytesPerLine ;_dfgc +=_bcff .BytesPerLine ;};};default:_ee .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_eedg );
return _a .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _gdf (_fdcd _c .CMYK )_c .Gray {_eef ,_dba ,_bgfa :=_c .CMYKToRGB (_fdcd .C ,_fdcd .M ,_fdcd .Y ,_fdcd .K );
_gbee :=(19595*uint32 (_eef )+38470*uint32 (_dba )+7471*uint32 (_bgfa )+1<<7)>>16;return _c .Gray {Y :uint8 (_gbee )};};type Image interface{_cc .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dbbf ,_edbf int )(_c .Color ,error );Validate ()error ;
};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_daca :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _daca ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_agf :=width *colorComponents *bitsPerComponent ;
_deeb :=_daca *8;_cfae :=8-(_deeb -_agf );_ebfc :=_b .NewReader (data );_gacd :=_daca -1;_afb :=make ([]byte ,_gacd );_fgdf :=make ([]byte ,height *_daca );_dcdb :=_b .NewWriterMSB (_fgdf );var _bfea uint64 ;var _gaegg error ;for _acfe :=0;_acfe < height ;
_acfe ++{_ ,_gaegg =_ebfc .Read (_afb );if _gaegg !=nil {return nil ,_gaegg ;};_ ,_gaegg =_dcdb .Write (_afb );if _gaegg !=nil {return nil ,_gaegg ;};_bfea ,_gaegg =_ebfc .ReadBits (byte (_cfae ));if _gaegg !=nil {return nil ,_gaegg ;};_ ,_gaegg =_dcdb .WriteBits (_bfea ,_cfae );
if _gaegg !=nil {return nil ,_gaegg ;};_dcdb .FinishByte ();};return _fgdf ,nil ;};func _egbd (_fadb _c .RGBA )_c .CMYK {_fdee ,_ffge ,_eebf ,_eabb :=_c .RGBToCMYK (_fadb .R ,_fadb .G ,_fadb .B );return _c .CMYK {C :_fdee ,M :_ffge ,Y :_eebf ,K :_eabb };
};func _ecac (_daa ,_cgac Gray ,_bcbb _e .Rectangle ){for _afac :=0;_afac < _bcbb .Max .X ;_afac ++{for _ffgf :=0;_ffgf < _bcbb .Max .Y ;_ffgf ++{_cgac .SetGray (_afac ,_ffgf ,_daa .GrayAt (_afac ,_ffgf ));};};};func (_cecg *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _eed (_cecg ,factor );};func (_cbfb *NRGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA32 (x ,y ,_cbfb .Width ,_cbfb .Data ,_cbfb .Alpha ,_cbfb .Decode );};func (_fgdfd *NRGBA32 )SetNRGBA (x ,y int ,c _c .NRGBA ){_fbca :=y *_fgdfd .Width +x ;
_geeg :=3*_fbca ;if _geeg +2>=len (_fgdfd .Data ){return ;};_fgdfd .setRGBA (_fbca ,c );};func (_dfff *ImageBase )setEightFullBytes (_fegf int ,_fgeef uint64 )error {if _fegf +7> len (_dfff .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dfff .Data [_fegf ]=byte ((_fgeef &0xff00000000000000)>>56);_dfff .Data [_fegf +1]=byte ((_fgeef &0xff000000000000)>>48);_dfff .Data [_fegf +2]=byte ((_fgeef &0xff0000000000)>>40);_dfff .Data [_fegf +3]=byte ((_fgeef &0xff00000000)>>32);_dfff .Data [_fegf +4]=byte ((_fgeef &0xff000000)>>24);
_dfff .Data [_fegf +5]=byte ((_fgeef &0xff0000)>>16);_dfff .Data [_fegf +6]=byte ((_fgeef &0xff00)>>8);_dfff .Data [_fegf +7]=byte (_fgeef &0xff);return nil ;};func (_faab *Monochrome )ColorModel ()_c .Model {return MonochromeModel (_faab .ModelThreshold )};
type CMYK32 struct{ImageBase };func (_dadbe *Gray4 )GrayAt (x ,y int )_c .Gray {_cbcg ,_ :=ColorAtGray4BPC (x ,y ,_dadbe .BytesPerLine ,_dadbe .Data ,_dadbe .Decode );return _cbcg ;};func (_ddgb *NRGBA16 )Validate ()error {if len (_ddgb .Data )!=3*_ddgb .Width *_ddgb .Height /2{return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ _e .Image =&Gray8 {};func _afd (_gdb ,_fggf *Monochrome ,_fda []byte ,_aebf int )(_edeg error ){var (_gda ,_cec ,_ace ,_gag ,_eca ,_fgff ,_agaf ,_deb int ;_abc ,_cbd ,_dgg ,_abe uint32 ;_cee ,_dddd byte ;_bcg uint16 ;);_bdd :=make ([]byte ,4);
_gae :=make ([]byte ,4);for _ace =0;_ace < _gdb .Height -1;_ace ,_gag =_ace +2,_gag +1{_gda =_ace *_gdb .BytesPerLine ;_cec =_gag *_fggf .BytesPerLine ;for _eca ,_fgff =0,0;_eca < _aebf ;_eca ,_fgff =_eca +4,_fgff +1{for _agaf =0;_agaf < 4;_agaf ++{_deb =_gda +_eca +_agaf ;
if _deb <=len (_gdb .Data )-1&&_deb < _gda +_gdb .BytesPerLine {_bdd [_agaf ]=_gdb .Data [_deb ];}else {_bdd [_agaf ]=0x00;};_deb =_gda +_gdb .BytesPerLine +_eca +_agaf ;if _deb <=len (_gdb .Data )-1&&_deb < _gda +(2*_gdb .BytesPerLine ){_gae [_agaf ]=_gdb .Data [_deb ];
}else {_gae [_agaf ]=0x00;};};_abc =_gc .BigEndian .Uint32 (_bdd );_cbd =_gc .BigEndian .Uint32 (_gae );_dgg =_abc &_cbd ;_dgg |=_dgg <<1;_abe =_abc |_cbd ;_abe &=_abe <<1;_cbd =_dgg |_abe ;_cbd &=0xaaaaaaaa;_abc =_cbd |(_cbd <<7);_cee =byte (_abc >>24);
_dddd =byte ((_abc >>8)&0xff);_deb =_cec +_fgff ;if _deb +1==len (_fggf .Data )-1||_deb +1>=_cec +_fggf .BytesPerLine {if _edeg =_fggf .setByte (_deb ,_fda [_cee ]);_edeg !=nil {return _f .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_deb );};
}else {_bcg =(uint16 (_fda [_cee ])<<8)|uint16 (_fda [_dddd ]);if _edeg =_fggf .setTwoBytes (_deb ,_bcg );_edeg !=nil {return _f .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_deb );
};_fgff ++;};};};return nil ;};func (_adfe *Gray16 )Base ()*ImageBase {return &_adfe .ImageBase };func _acc (_cfe ,_dbg *Monochrome ,_cbc []byte ,_efg int )(_dddc error ){var (_febg ,_edec ,_eag ,_dbe ,_geb ,_cece ,_dgc ,_fadg int ;_acg ,_bdee ,_ccg ,_fag uint32 ;
_gab ,_gea byte ;_bga uint16 ;);_fca :=make ([]byte ,4);_dgcc :=make ([]byte ,4);for _eag =0;_eag < _cfe .Height -1;_eag ,_dbe =_eag +2,_dbe +1{_febg =_eag *_cfe .BytesPerLine ;_edec =_dbe *_dbg .BytesPerLine ;for _geb ,_cece =0,0;_geb < _efg ;_geb ,_cece =_geb +4,_cece +1{for _dgc =0;
_dgc < 4;_dgc ++{_fadg =_febg +_geb +_dgc ;if _fadg <=len (_cfe .Data )-1&&_fadg < _febg +_cfe .BytesPerLine {_fca [_dgc ]=_cfe .Data [_fadg ];}else {_fca [_dgc ]=0x00;};_fadg =_febg +_cfe .BytesPerLine +_geb +_dgc ;if _fadg <=len (_cfe .Data )-1&&_fadg < _febg +(2*_cfe .BytesPerLine ){_dgcc [_dgc ]=_cfe .Data [_fadg ];
}else {_dgcc [_dgc ]=0x00;};};_acg =_gc .BigEndian .Uint32 (_fca );_bdee =_gc .BigEndian .Uint32 (_dgcc );_ccg =_acg &_bdee ;_ccg |=_ccg <<1;_fag =_acg |_bdee ;_fag &=_fag <<1;_bdee =_ccg &_fag ;_bdee &=0xaaaaaaaa;_acg =_bdee |(_bdee <<7);_gab =byte (_acg >>24);
_gea =byte ((_acg >>8)&0xff);_fadg =_edec +_cece ;if _fadg +1==len (_dbg .Data )-1||_fadg +1>=_edec +_dbg .BytesPerLine {if _dddc =_dbg .setByte (_fadg ,_cbc [_gab ]);_dddc !=nil {return _f .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fadg );
};}else {_bga =(uint16 (_cbc [_gab ])<<8)|uint16 (_cbc [_gea ]);if _dddc =_dbg .setTwoBytes (_fadg ,_bga );_dddc !=nil {return _f .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fadg );
};_cece ++;};};};return nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_cdded :=y *width +x ;_bad :=3*_cdded ;if _bad +2>=len (data ){return _c .NRGBA {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ffda :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cdded {_ffda =alpha [_cdded ];};_adfea ,_effd ,_gbba :=data [_bad ],data [_bad +1],data [_bad +2];if len (decode )==6{_adfea =uint8 (uint32 (LinearInterpolate (float64 (_adfea ),0,255,decode [0],decode [1]))&0xff);
_effd =uint8 (uint32 (LinearInterpolate (float64 (_effd ),0,255,decode [2],decode [3]))&0xff);_gbba =uint8 (uint32 (LinearInterpolate (float64 (_gbba ),0,255,decode [4],decode [5]))&0xff);};return _c .NRGBA {R :_adfea ,G :_effd ,B :_gbba ,A :_ffda },nil ;
};type monochromeModel uint8 ;type shift int ;func (_cdga *Gray16 )Set (x ,y int ,c _c .Color ){_cdbc :=(y *_cdga .BytesPerLine /2+x )*2;if _cdbc +1>=len (_cdga .Data ){return ;};_ddg :=_c .Gray16Model .Convert (c ).(_c .Gray16 );_cdga .Data [_cdbc ],_cdga .Data [_cdbc +1]=uint8 (_ddg .Y >>8),uint8 (_ddg .Y &0xff);
};func (_fdd *monochromeThresholdConverter )Convert (img _e .Image )(Image ,error ){if _efa ,_edgc :=img .(*Monochrome );_edgc {return _efa .Copy (),nil ;};_fbe :=img .Bounds ();_acce ,_cbfg :=NewImage (_fbe .Max .X ,_fbe .Max .Y ,1,1,nil ,nil ,nil );if _cbfg !=nil {return nil ,_cbfg ;
};_acce .(*Monochrome ).ModelThreshold =_fdd .Threshold ;for _gcgd :=0;_gcgd < _fbe .Max .X ;_gcgd ++{for _bbede :=0;_bbede < _fbe .Max .Y ;_bbede ++{_dbfe :=img .At (_gcgd ,_bbede );_acce .Set (_gcgd ,_bbede ,_dbfe );};};return _acce ,nil ;};func (_fcff *Monochrome )InverseData ()error {return _fcff .RasterOperation (0,0,_fcff .Width ,_fcff .Height ,PixNotDst ,nil ,0,0);
};func (_affa *NRGBA16 )Set (x ,y int ,c _c .Color ){_bdfcc :=y *_affa .BytesPerLine +x *3/2;if _bdfcc +1>=len (_affa .Data ){return ;};_acgaf :=NRGBA16Model .Convert (c ).(_c .NRGBA );_affa .setNRGBA (x ,y ,_bdfcc ,_acgaf );};func _eegb (_ecc _c .NRGBA )_c .Gray {var _bbg _c .NRGBA ;
if _ecc ==_bbg {return _c .Gray {Y :0xff};};_abf ,_fae ,_fdc ,_ :=_ecc .RGBA ();_acbe :=(19595*_abf +38470*_fae +7471*_fdc +1<<15)>>24;return _c .Gray {Y :uint8 (_acbe )};};func _de (_ea ,_fd *Monochrome )(_eac error ){_cb :=_fd .BytesPerLine ;_edb :=_ea .BytesPerLine ;
_cce :=_fd .BytesPerLine *4-_ea .BytesPerLine ;var (_ad ,_eaf byte ;_ggd uint32 ;_bf ,_dd ,_feb ,_fc ,_gd ,_fab ,_abb int ;);for _feb =0;_feb < _fd .Height ;_feb ++{_bf =_feb *_cb ;_dd =4*_feb *_edb ;for _fc =0;_fc < _cb ;_fc ++{_ad =_fd .Data [_bf +_fc ];
_ggd =_eae [_ad ];_fab =_dd +_fc *4;if _cce !=0&&(_fc +1)*4> _ea .BytesPerLine {for _gd =_cce ;_gd > 0;_gd --{_eaf =byte ((_ggd >>uint (_gd *8))&0xff);_abb =_fab +(_cce -_gd );if _eac =_ea .setByte (_abb ,_eaf );_eac !=nil {return _eac ;};};}else if _eac =_ea .setFourBytes (_fab ,_ggd );
_eac !=nil {return _eac ;};if _eac =_ea .setFourBytes (_dd +_fc *4,_eae [_fd .Data [_bf +_fc ]]);_eac !=nil {return _eac ;};};for _gd =1;_gd < 4;_gd ++{for _fc =0;_fc < _edb ;_fc ++{if _eac =_ea .setByte (_dd +_gd *_edb +_fc ,_ea .Data [_dd +_fc ]);_eac !=nil {return _eac ;
};};};};return nil ;};func ConverterFunc (converterFunc func (_dgf _e .Image )(Image ,error ))ColorConverter {return colorConverter {_gdda :converterFunc };};type NRGBA32 struct{ImageBase };func (_eaa *Gray4 )Base ()*ImageBase {return &_eaa .ImageBase };
func init (){_bdfd ()};func _bafg (_caffe ,_gegda NRGBA ,_dgccc _e .Rectangle ){for _ebff :=0;_ebff < _dgccc .Max .X ;_ebff ++{for _ecgg :=0;_ecgg < _dgccc .Max .Y ;_ecgg ++{_gegda .SetNRGBA (_ebff ,_ecgg ,_caffe .NRGBAAt (_ebff ,_ecgg ));};};};func _gcgb (_dab Gray ,_ccd nrgba64 ,_fcfd _e .Rectangle ){for _bddf :=0;
_bddf < _fcfd .Max .X ;_bddf ++{for _efca :=0;_efca < _fcfd .Max .Y ;_efca ++{_daf :=_fdf (_ccd .NRGBA64At (_bddf ,_efca ));_dab .SetGray (_bddf ,_efca ,_daf );};};};var _ _e .Image =&NRGBA64 {};func (_dbbg *Gray4 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray4BPC (x ,y ,_dbbg .BytesPerLine ,_dbbg .Data ,_dbbg .Decode );
};var _ Gray =&Monochrome {};func MonochromeModel (threshold uint8 )_c .Model {return monochromeModel (threshold )};func (_gfee *Gray16 )Validate ()error {if len (_gfee .Data )!=_gfee .Height *_gfee .BytesPerLine {return ErrInvalidImage ;};return nil ;
};func (_dbbd *ImageBase )copy ()ImageBase {_dde :=*_dbbd ;_dde .Data =make ([]byte ,len (_dbbd .Data ));copy (_dde .Data ,_dbbd .Data );return _dde ;};func (_afeg *Gray4 )At (x ,y int )_c .Color {_eceb ,_ :=_afeg .ColorAt (x ,y );return _eceb };func (_bbeg *CMYK32 )CMYKAt (x ,y int )_c .CMYK {_dadb ,_ :=ColorAtCMYK (x ,y ,_bbeg .Width ,_bbeg .Data ,_bbeg .Decode );
return _dadb ;};func (_eade *Gray2 )Set (x ,y int ,c _c .Color ){if x >=_eade .Width ||y >=_eade .Height {return ;};_ecaf :=Gray2Model .Convert (c ).(_c .Gray );_gaab :=y *_eade .BytesPerLine ;_ccfe :=_gaab +(x >>2);_cbe :=_ecaf .Y >>6;_eade .Data [_ccfe ]=(_eade .Data [_ccfe ]&(^(0xc0>>uint (2*((x )&3)))))|(_cbe <<uint (6-2*(x &3)));
};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_fgecb :=y *bytesPerLine +x *3/2;if _fgecb +1>=len (data ){return _c .NRGBA {},_eegd (x ,y );};const (_bbde =0xf;_gafa =uint8 (0xff););_ggec :=_gafa ;
if alpha !=nil {_gdfeb :=y *BytesPerLine (width ,4,1);if _gdfeb < len (alpha ){if x %2==0{_ggec =(alpha [_gdfeb ]>>uint (4))&_bbde ;}else {_ggec =alpha [_gdfeb ]&_bbde ;};_ggec |=_ggec <<4;};};var _dcdd ,_dfebb ,_fcfbf uint8 ;if x *3%2==0{_dcdd =(data [_fgecb ]>>uint (4))&_bbde ;
_dfebb =data [_fgecb ]&_bbde ;_fcfbf =(data [_fgecb +1]>>uint (4))&_bbde ;}else {_dcdd =data [_fgecb ]&_bbde ;_dfebb =(data [_fgecb +1]>>uint (4))&_bbde ;_fcfbf =data [_fgecb +1]&_bbde ;};if len (decode )==6{_dcdd =uint8 (uint32 (LinearInterpolate (float64 (_dcdd ),0,15,decode [0],decode [1]))&0xf);
_dfebb =uint8 (uint32 (LinearInterpolate (float64 (_dfebb ),0,15,decode [2],decode [3]))&0xf);_fcfbf =uint8 (uint32 (LinearInterpolate (float64 (_fcfbf ),0,15,decode [4],decode [5]))&0xf);};return _c .NRGBA {R :(_dcdd <<4)|(_dcdd &0xf),G :(_dfebb <<4)|(_dfebb &0xf),B :(_fcfbf <<4)|(_fcfbf &0xf),A :_ggec },nil ;
};func (_gdfe *ImageBase )MakeAlpha (){_gdfe .newAlpha ()};func ImgToGray (i _e .Image )*_e .Gray {if _adgf ,_fcgb :=i .(*_e .Gray );_fcgb {return _adgf ;};_gbdff :=i .Bounds ();_eddaf :=_e .NewGray (_gbdff );for _bffc :=0;_bffc < _gbdff .Max .X ;_bffc ++{for _dgcd :=0;
_dgcd < _gbdff .Max .Y ;_dgcd ++{_beeg :=i .At (_bffc ,_dgcd );_eddaf .Set (_bffc ,_dgcd ,_beeg );};};return _eddaf ;};func (_cbgb *Gray4 )setGray (_fcc int ,_dccg int ,_dffa _c .Gray ){_bbgc :=_dccg *_cbgb .BytesPerLine ;_bdac :=_bbgc +(_fcc >>1);if _bdac >=len (_cbgb .Data ){return ;
};_gbcg :=_dffa .Y >>4;_cbgb .Data [_bdac ]=(_cbgb .Data [_bdac ]&(^(0xf0>>uint (4*(_fcc &1)))))|(_gbcg <<uint (4-4*(_fcc &1)));};func _bgc (_eea ,_cggb *Monochrome ,_ecg []byte ,_cca int )(_dff error ){var (_bfg ,_eebc ,_aad ,_fcae ,_dga ,_dggg ,_deba ,_bcc int ;
_bca ,_fde uint32 ;_cdf ,_ba byte ;_fec uint16 ;);_ffdfc :=make ([]byte ,4);_ceb :=make ([]byte ,4);for _aad =0;_aad < _eea .Height -1;_aad ,_fcae =_aad +2,_fcae +1{_bfg =_aad *_eea .BytesPerLine ;_eebc =_fcae *_cggb .BytesPerLine ;for _dga ,_dggg =0,0;
_dga < _cca ;_dga ,_dggg =_dga +4,_dggg +1{for _deba =0;_deba < 4;_deba ++{_bcc =_bfg +_dga +_deba ;if _bcc <=len (_eea .Data )-1&&_bcc < _bfg +_eea .BytesPerLine {_ffdfc [_deba ]=_eea .Data [_bcc ];}else {_ffdfc [_deba ]=0x00;};_bcc =_bfg +_eea .BytesPerLine +_dga +_deba ;
if _bcc <=len (_eea .Data )-1&&_bcc < _bfg +(2*_eea .BytesPerLine ){_ceb [_deba ]=_eea .Data [_bcc ];}else {_ceb [_deba ]=0x00;};};_bca =_gc .BigEndian .Uint32 (_ffdfc );_fde =_gc .BigEndian .Uint32 (_ceb );_fde &=_bca ;_fde &=_fde <<1;_fde &=0xaaaaaaaa;
_bca =_fde |(_fde <<7);_cdf =byte (_bca >>24);_ba =byte ((_bca >>8)&0xff);_bcc =_eebc +_dggg ;if _bcc +1==len (_cggb .Data )-1||_bcc +1>=_eebc +_cggb .BytesPerLine {_cggb .Data [_bcc ]=_ecg [_cdf ];if _dff =_cggb .setByte (_bcc ,_ecg [_cdf ]);_dff !=nil {return _f .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_bcc );
};}else {_fec =(uint16 (_ecg [_cdf ])<<8)|uint16 (_ecg [_ba ]);if _dff =_cggb .setTwoBytes (_bcc ,_fec );_dff !=nil {return _f .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bcc );
};_dggg ++;};};};return nil ;};var _ _e .Image =&NRGBA32 {};var _ NRGBA =&NRGBA16 {};func (_fegb *Gray4 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fegb .Width ,Y :_fegb .Height }};};func _aga ()(_be [256]uint32 ){for _fcf :=0;_fcf < 256;
_fcf ++{if _fcf &0x01!=0{_be [_fcf ]|=0xf;};if _fcf &0x02!=0{_be [_fcf ]|=0xf0;};if _fcf &0x04!=0{_be [_fcf ]|=0xf00;};if _fcf &0x08!=0{_be [_fcf ]|=0xf000;};if _fcf &0x10!=0{_be [_fcf ]|=0xf0000;};if _fcf &0x20!=0{_be [_fcf ]|=0xf00000;};if _fcf &0x40!=0{_be [_fcf ]|=0xf000000;
};if _fcf &0x80!=0{_be [_fcf ]|=0xf0000000;};};return _be ;};func _befba (_edge *_e .Gray )bool {for _cgdac :=0;_cgdac < len (_edge .Pix );_cgdac ++{if !_gagg (_edge .Pix [_cgdac ]){return false ;};};return true ;};func _eaadc (_gbfc ,_abdfg ,_gcbb byte )byte {return (_gbfc &^(_gcbb ))|(_abdfg &_gcbb )};
type Gray interface{GrayAt (_gfce ,_edg int )_c .Gray ;SetGray (_gcdf ,_gaa int ,_bgde _c .Gray );};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_abbc :=y *bytesPerLine +x >>1;if _abbc >=len (data ){return _c .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ccaa :=data [_abbc ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ccaa =uint8 (uint32 (LinearInterpolate (float64 (_ccaa ),0,15,decode [0],decode [1]))&0xf);};return _c .Gray {Y :_ccaa *17&0xff},nil ;};func (_gaec *Monochrome )IsUnpadded ()bool {return (_gaec .Width *_gaec .Height )==len (_gaec .Data )};
func (_ddab *NRGBA32 )NRGBAAt (x ,y int )_c .NRGBA {_cgec ,_ :=ColorAtNRGBA32 (x ,y ,_ddab .Width ,_ddab .Data ,_ddab .Alpha ,_ddab .Decode );return _cgec ;};func (_deaf *Monochrome )copy ()*Monochrome {_ccfg :=_efc (_deaf .Width ,_deaf .Height );_ccfg .ModelThreshold =_deaf .ModelThreshold ;
_ccfg .Data =make ([]byte ,len (_deaf .Data ));copy (_ccfg .Data ,_deaf .Data );if len (_deaf .Decode )!=0{_ccfg .Decode =make ([]float64 ,len (_deaf .Decode ));copy (_ccfg .Decode ,_deaf .Decode );};if len (_deaf .Alpha )!=0{_ccfg .Alpha =make ([]byte ,len (_deaf .Alpha ));
copy (_ccfg .Alpha ,_deaf .Alpha );};return _ccfg ;};func _gdge (_efbb _e .Image )(Image ,error ){if _eeefg ,_bbcf :=_efbb .(*RGBA32 );_bbcf {return _eeefg .Copy (),nil ;};_egdd ,_dfcc ,_ggac :=_fcgfa (_efbb ,1);_gfgb :=&RGBA32 {ImageBase :NewImageBase (_egdd .Max .X ,_egdd .Max .Y ,8,3,nil ,_ggac ,nil )};
_fcdc (_efbb ,_gfgb ,_egdd );if len (_ggac )!=0&&!_dfcc {if _cdcd :=_gfea (_ggac ,_gfgb );_cdcd !=nil {return nil ,_cdcd ;};};return _gfgb ,nil ;};func (_ebaf *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ebaf .copy ()}};func (_eeae *RGBA32 )Set (x ,y int ,c _c .Color ){_bgfd :=y *_eeae .Width +x ;
_beba :=3*_bgfd ;if _beba +2>=len (_eeae .Data ){return ;};_gddaf :=_c .RGBAModel .Convert (c ).(_c .RGBA );_eeae .setRGBA (_bgfd ,_gddaf );};func (_gfg *Monochrome )setGrayBit (_dge ,_dgb int ){_gfg .Data [_dge ]|=0x80>>uint (_dgb &7)};func _cbb (_cbba _c .RGBA )_c .Gray {_dgfc :=(19595*uint32 (_cbba .R )+38470*uint32 (_cbba .G )+7471*uint32 (_cbba .B )+1<<7)>>16;
return _c .Gray {Y :uint8 (_dgfc )};};func _cbfdg (_ecce NRGBA ,_ffdg Gray ,_ffec _e .Rectangle ){for _eddb :=0;_eddb < _ffec .Max .X ;_eddb ++{for _gbeg :=0;_gbeg < _ffec .Max .Y ;_gbeg ++{_gfgf :=_bae (_ecce .NRGBAAt (_eddb ,_gbeg ));_ffdg .SetGray (_eddb ,_gbeg ,_gfgf );
};};};type Gray4 struct{ImageBase };var ErrInvalidImage =_a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_ceee *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gddg (_ceee ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_dbfb *Monochrome )Validate ()error {if len (_dbfb .Data )!=_dbfb .Height *_dbfb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _fdegg (_dfaaa nrgba64 ,_gfde RGBA ,_afaf _e .Rectangle ){for _fgcc :=0;_fgcc < _afaf .Max .X ;_fgcc ++{for _fadgd :=0;_fadgd < _afaf .Max .Y ;_fadgd ++{_gggf :=_dfaaa .NRGBA64At (_fgcc ,_fadgd );_gfde .SetRGBA (_fgcc ,_fadgd ,_abea (_gggf ));
};};};type RasterOperator int ;func (_fffd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_fffd .copy ()}};func (_bgef *Gray16 )SetGray (x ,y int ,g _c .Gray ){_efgb :=(y *_bgef .BytesPerLine /2+x )*2;if _efgb +1>=len (_bgef .Data ){return ;};_bgef .Data [_efgb ]=g .Y ;
_bgef .Data [_efgb +1]=g .Y ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_ccaf :=y *bytesPerLine +x >>2;if _ccaf >=len (data ){return _c .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ffga :=data [_ccaf ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ffga =uint8 (uint32 (LinearInterpolate (float64 (_ffga ),0,3.0,decode [0],decode [1]))&3);};return _c .Gray {Y :_ffga *85},nil ;};func (_fea *RGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fea .Width ,Y :_fea .Height }};
};type Gray8 struct{ImageBase };func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .RGBA ,error ){_abfa :=y *width +x ;_cbed :=3*_abfa ;if _cbed +2>=len (data ){return _c .RGBA {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dfaag :=uint8 (0xff);if alpha !=nil &&len (alpha )> _abfa {_dfaag =alpha [_abfa ];};_cdff ,_eeeb ,_agbe :=data [_cbed ],data [_cbed +1],data [_cbed +2];if len (decode )==6{_cdff =uint8 (uint32 (LinearInterpolate (float64 (_cdff ),0,255,decode [0],decode [1]))&0xff);
_eeeb =uint8 (uint32 (LinearInterpolate (float64 (_eeeb ),0,255,decode [2],decode [3]))&0xff);_agbe =uint8 (uint32 (LinearInterpolate (float64 (_agbe ),0,255,decode [4],decode [5]))&0xff);};return _c .RGBA {R :_cdff ,G :_eeeb ,B :_agbe ,A :_dfaag },nil ;
};var _ _e .Image =&RGBA32 {};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_edba :=y *bytesPerLine +x >>3;if _edba >=len (data ){return _c .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gbbe :=data [_edba ]>>uint (7-(x &7))&1;if len (decode )==2{_gbbe =uint8 (LinearInterpolate (float64 (_gbbe ),0.0,1.0,decode [0],decode [1]))&1;};return _c .Gray {Y :_gbbe *255},nil ;};func (_gagcf *Gray2 )GrayAt (x ,y int )_c .Gray {_dcea ,_ :=ColorAtGray2BPC (x ,y ,_gagcf .BytesPerLine ,_gagcf .Data ,_gagcf .Decode );
return _dcea ;};func _dccce (_dgde CMYK ,_cdbd Gray ,_gbga _e .Rectangle ){for _abga :=0;_abga < _gbga .Max .X ;_abga ++{for _geeb :=0;_geeb < _gbga .Max .Y ;_geeb ++{_adc :=_gdf (_dgde .CMYKAt (_abga ,_geeb ));_cdbd .SetGray (_abga ,_geeb ,_adc );};};
};func _bgfe (_bcac *Monochrome ,_ggdg ,_aedbc ,_cad ,_gddf int ,_afca RasterOperator ,_deed *Monochrome ,_dcde ,_edbdd int )error {var (_dbcc bool ;_gbdde bool ;_cead int ;_eagc int ;_eaee int ;_ccdg bool ;_cccb byte ;_cbgf int ;_cfc int ;_fcef int ;_ggcfb ,_aebfe int ;
);_dfag :=8-(_ggdg &7);_dfeb :=_gfff [_dfag ];_aafe :=_bcac .BytesPerLine *_aedbc +(_ggdg >>3);_gdbd :=_deed .BytesPerLine *_edbdd +(_dcde >>3);if _cad < _dfag {_dbcc =true ;_dfeb &=_dcec [8-_dfag +_cad ];};if !_dbcc {_cead =(_cad -_dfag )>>3;if _cead > 0{_gbdde =true ;
_eagc =_aafe +1;_eaee =_gdbd +1;};};_cbgf =(_ggdg +_cad )&7;if !(_dbcc ||_cbgf ==0){_ccdg =true ;_cccb =_dcec [_cbgf ];_cfc =_aafe +1+_cead ;_fcef =_gdbd +1+_cead ;};switch _afca {case PixSrc :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],_deed .Data [_gdbd ],_dfeb );
_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]=_deed .Data [_eaee +_aebfe ];};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;
};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],_deed .Data [_fcef ],_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixNotSrc :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],^_deed .Data [_gdbd ],_dfeb );
_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]=^_deed .Data [_eaee +_aebfe ];};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;
};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],^_deed .Data [_fcef ],_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixSrcOrDst :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],_deed .Data [_gdbd ]|_bcac .Data [_aafe ],_dfeb );
_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]|=_deed .Data [_eaee +_aebfe ];};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;
};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],_deed .Data [_fcef ]|_bcac .Data [_cfc ],_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixSrcAndDst :for _ggcfb =0;_ggcfb < _gddf ;
_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],_deed .Data [_gdbd ]&_bcac .Data [_aafe ],_dfeb );_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]&=_deed .Data [_eaee +_aebfe ];
};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],_deed .Data [_fcef ]&_bcac .Data [_cfc ],_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;
};};case PixSrcXorDst :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],_deed .Data [_gdbd ]^_bcac .Data [_aafe ],_dfeb );_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;
_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]^=_deed .Data [_eaee +_aebfe ];};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],_deed .Data [_fcef ]^_bcac .Data [_cfc ],_cccb );
_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixNotSrcOrDst :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],^(_deed .Data [_gdbd ])|_bcac .Data [_aafe ],_dfeb );_aafe +=_bcac .BytesPerLine ;
_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]|=^(_deed .Data [_eaee +_aebfe ]);};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;};};if _ccdg {for _ggcfb =0;
_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],^(_deed .Data [_fcef ])|_bcac .Data [_cfc ],_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixNotSrcAndDst :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],^(_deed .Data [_gdbd ])&_bcac .Data [_aafe ],_dfeb );
_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]&=^_deed .Data [_eaee +_aebfe ];};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;
};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],^(_deed .Data [_fcef ])&_bcac .Data [_cfc ],_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixSrcOrNotDst :for _ggcfb =0;_ggcfb < _gddf ;
_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],_deed .Data [_gdbd ]|^(_bcac .Data [_aafe ]),_dfeb );_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;
_aebfe ++{_bcac .Data [_eagc +_aebfe ]=_deed .Data [_eaee +_aebfe ]|^(_bcac .Data [_eagc +_aebfe ]);};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],_deed .Data [_fcef ]|^(_bcac .Data [_cfc ]),_cccb );
_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixSrcAndNotDst :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],_deed .Data [_gdbd ]&^(_bcac .Data [_aafe ]),_dfeb );_aafe +=_bcac .BytesPerLine ;
_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]=_deed .Data [_eaee +_aebfe ]&^(_bcac .Data [_eagc +_aebfe ]);};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;
};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],_deed .Data [_fcef ]&^(_bcac .Data [_cfc ]),_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixNotPixSrcOrDst :for _ggcfb =0;
_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],^(_deed .Data [_gdbd ]|_bcac .Data [_aafe ]),_dfeb );_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;
_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]=^(_deed .Data [_eaee +_aebfe ]|_bcac .Data [_eagc +_aebfe ]);};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],^(_deed .Data [_fcef ]|_bcac .Data [_cfc ]),_cccb );
_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixNotPixSrcAndDst :for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],^(_deed .Data [_gdbd ]&_bcac .Data [_aafe ]),_dfeb );_aafe +=_bcac .BytesPerLine ;
_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]=^(_deed .Data [_eaee +_aebfe ]&_bcac .Data [_eagc +_aebfe ]);};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;
};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],^(_deed .Data [_fcef ]&_bcac .Data [_cfc ]),_cccb );_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};case PixNotPixSrcXorDst :for _ggcfb =0;
_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_aafe ]=_eaadc (_bcac .Data [_aafe ],^(_deed .Data [_gdbd ]^_bcac .Data [_aafe ]),_dfeb );_aafe +=_bcac .BytesPerLine ;_gdbd +=_deed .BytesPerLine ;};if _gbdde {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{for _aebfe =0;
_aebfe < _cead ;_aebfe ++{_bcac .Data [_eagc +_aebfe ]=^(_deed .Data [_eaee +_aebfe ]^_bcac .Data [_eagc +_aebfe ]);};_eagc +=_bcac .BytesPerLine ;_eaee +=_deed .BytesPerLine ;};};if _ccdg {for _ggcfb =0;_ggcfb < _gddf ;_ggcfb ++{_bcac .Data [_cfc ]=_eaadc (_bcac .Data [_cfc ],^(_deed .Data [_fcef ]^_bcac .Data [_cfc ]),_cccb );
_cfc +=_bcac .BytesPerLine ;_fcef +=_deed .BytesPerLine ;};};default:_ee .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_afca );return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _abbg (_fbc _c .CMYK )_c .RGBA {_aff ,_eeda ,_cdgd :=_c .CMYKToRGB (_fbc .C ,_fbc .M ,_fbc .Y ,_fbc .K );return _c .RGBA {R :_aff ,G :_eeda ,B :_cdgd ,A :0xff};};func _fgee (_aedb _c .NRGBA64 )_c .NRGBA {return _c .NRGBA {R :uint8 (_aedb .R >>8),G :uint8 (_aedb .G >>8),B :uint8 (_aedb .B >>8),A :uint8 (_aedb .A >>8)};
};func _cffc (_fge _e .Image )(Image ,error ){if _afg ,_ceg :=_fge .(*CMYK32 );_ceg {return _afg .Copy (),nil ;};_gbdd :=_fge .Bounds ();_ggf ,_caa :=NewImage (_gbdd .Max .X ,_gbdd .Max .Y ,8,4,nil ,nil ,nil );if _caa !=nil {return nil ,_caa ;};switch _debd :=_fge .(type ){case CMYK :_cae (_debd ,_ggf .(CMYK ),_gbdd );
case Gray :_gaga (_debd ,_ggf .(CMYK ),_gbdd );case NRGBA :_agg (_debd ,_ggf .(CMYK ),_gbdd );case RGBA :_cebb (_debd ,_ggf .(CMYK ),_gbdd );default:_aec (_fge ,_ggf ,_gbdd );};return _ggf ,nil ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _g .Abs (xmax -xmin )< 0.000001{return ymin ;
};_cedb :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _cedb ;};func _ec (_eedc *Monochrome ,_gdc ...int )(_bb *Monochrome ,_dad error ){if _eedc ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_gdc )==0{return nil ,_a .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_ced :=_bgg ();_bb =_eedc ;for _ ,_gbd :=range _gdc {if _gbd <=0{break ;};_bb ,_dad =_gfc (_bb ,_gbd ,_ced );if _dad !=nil {return nil ,_dad ;};};return _bb ,nil ;};func (_cfec *Gray16 )Histogram ()(_fedb [256]int ){for _fabd :=0;_fabd < _cfec .Width ;
_fabd ++{for _bebb :=0;_bebb < _cfec .Height ;_bebb ++{_fedb [_cfec .GrayAt (_fabd ,_bebb ).Y ]++;};};return _fedb ;};func (_fffb *Gray8 )Histogram ()(_acgd [256]int ){for _agc :=0;_agc < len (_fffb .Data );_agc ++{_acgd [_fffb .Data [_agc ]]++;};return _acgd ;
};func (_dafce *Gray2 )Histogram ()(_fbb [256]int ){for _dced :=0;_dced < _dafce .Width ;_dced ++{for _ffgc :=0;_ffgc < _dafce .Height ;_ffgc ++{_fbb [_dafce .GrayAt (_dced ,_ffgc ).Y ]++;};};return _fbb ;};func (_egbbf *NRGBA16 )SetNRGBA (x ,y int ,c _c .NRGBA ){_aecbd :=y *_egbbf .BytesPerLine +x *3/2;
if _aecbd +1>=len (_egbbf .Data ){return ;};c =_cfeca (c );_egbbf .setNRGBA (x ,y ,_aecbd ,c );};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func InDelta (expected ,current ,delta float64 )bool {_bdfa :=expected -current ;if _bdfa <=-delta ||_bdfa >=delta {return false ;
};return true ;};func (_bec *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _dbb bool ;_cga :=scale ;if scale < 1{_cga =1/scale ;_dbb =true ;};_dadf :=NextPowerOf2 (uint (_cga ));if InDelta (float64 (_dadf ),_cga ,0.001){if _dbb {return _bec .ReduceBinary (_cga );
};return _bec .ExpandBinary (int (_dadf ));};_bdb :=int (_g .RoundToEven (float64 (_bec .Width )*scale ));_ebac :=int (_g .RoundToEven (float64 (_bec .Height )*scale ));return _bec .ScaleLow (_bdb ,_ebac );};type RGBA32 struct{ImageBase };func (_abdg *Gray2 )Base ()*ImageBase {return &_abdg .ImageBase };
const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;
PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;
PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);var _ _e .Image =&Gray4 {};func _bae (_gcgc _c .NRGBA )_c .Gray {_adg ,_bfae ,_ffg ,_ :=_gcgc .RGBA ();_faa :=(19595*_adg +38470*_bfae +7471*_ffg +1<<15)>>24;return _c .Gray {Y :uint8 (_faa )};
};func (_ccc *Monochrome )Set (x ,y int ,c _c .Color ){_afa :=y *_ccc .BytesPerLine +x >>3;if _afa > len (_ccc .Data )-1{return ;};_afcb :=_ccc .ColorModel ().Convert (c ).(_c .Gray );_ccc .setGray (x ,_afcb ,_afa );};var _ Gray =&Gray8 {};func (_dege *Monochrome )SetGray (x ,y int ,g _c .Gray ){_becb :=y *_dege .BytesPerLine +x >>3;
if _becb > len (_dege .Data )-1{return ;};g =_gcf (g ,monochromeModel (_dege .ModelThreshold ));_dege .setGray (x ,g ,_becb );};var (_cgfg =_dfge ();_eae =_aga ();_dg =_beg (););var _ _e .Image =&Monochrome {};func (_eagf *Gray16 )GrayAt (x ,y int )_c .Gray {_cef ,_ :=_eagf .ColorAt (x ,y );
return _c .Gray {Y :uint8 (_cef .(_c .Gray16 ).Y >>8)};};var _ Image =&Gray16 {};func _dfge ()(_edee [256]uint16 ){for _faf :=0;_faf < 256;_faf ++{if _faf &0x01!=0{_edee [_faf ]|=0x3;};if _faf &0x02!=0{_edee [_faf ]|=0xc;};if _faf &0x04!=0{_edee [_faf ]|=0x30;
};if _faf &0x08!=0{_edee [_faf ]|=0xc0;};if _faf &0x10!=0{_edee [_faf ]|=0x300;};if _faf &0x20!=0{_edee [_faf ]|=0xc00;};if _faf &0x40!=0{_edee [_faf ]|=0x3000;};if _faf &0x80!=0{_edee [_faf ]|=0xc000;};};return _edee ;};func (_cdgc *Gray8 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cdgc .Width ,Y :_cdgc .Height }};
};func (_bbed *CMYK32 )SetCMYK (x ,y int ,c _c .CMYK ){_ffb :=4*(y *_bbed .Width +x );if _ffb +3>=len (_bbed .Data ){return ;};_bbed .Data [_ffb ]=c .C ;_bbed .Data [_ffb +1]=c .M ;_bbed .Data [_ffb +2]=c .Y ;_bbed .Data [_ffb +3]=c .K ;};var _ _e .Image =&Gray16 {};
func _afe (_cagf _e .Image )(Image ,error ){if _gfgc ,_bfde :=_cagf .(*Gray2 );_bfde {return _gfgc .Copy (),nil ;};_ebdb :=_cagf .Bounds ();_ggg ,_gbea :=NewImage (_ebdb .Max .X ,_ebdb .Max .Y ,2,1,nil ,nil ,nil );if _gbea !=nil {return nil ,_gbea ;};_aabc (_cagf ,_ggg ,_ebdb );
return _ggg ,nil ;};func (_gdba *Monochrome )At (x ,y int )_c .Color {_ebd ,_ :=_gdba .ColorAt (x ,y );return _ebd };func (_fdad *Gray8 )Validate ()error {if len (_fdad .Data )!=_fdad .Height *_fdad .BytesPerLine {return ErrInvalidImage ;};return nil ;
};func _edaf (_dcbf _e .Image )(Image ,error ){if _gcae ,_bab :=_dcbf .(*Gray8 );_bab {return _gcae .Copy (),nil ;};_gcfc :=_dcbf .Bounds ();_eeff ,_edfc :=NewImage (_gcfc .Max .X ,_gcfc .Max .Y ,8,1,nil ,nil ,nil );if _edfc !=nil {return nil ,_edfc ;};
_aabc (_dcbf ,_eeff ,_gcfc );return _eeff ,nil ;};func (_bfac *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_bfac .copy ()}};var _ Image =&NRGBA16 {};func (_cbfe *RGBA32 )RGBAAt (x ,y int )_c .RGBA {_cgfgf ,_ :=ColorAtRGBA32 (x ,y ,_cbfe .Width ,_cbfe .Data ,_cbfe .Alpha ,_cbfe .Decode );
return _cgfgf ;};func (_fffa *Gray16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fffa .Width ,Y :_fffa .Height }};};func _bgdf (_bdf _c .Gray )_c .NRGBA {return _c .NRGBA {R :_bdf .Y ,G :_bdf .Y ,B :_bdf .Y ,A :0xff}};func (_adbe *Monochrome )ResolveDecode ()error {if len (_adbe .Decode )!=2{return nil ;
};if _adbe .Decode [0]==1&&_adbe .Decode [1]==0{if _beae :=_adbe .InverseData ();_beae !=nil {return _beae ;};_adbe .Decode =nil ;};return nil ;};func (_fggfa *NRGBA16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA16 (x ,y ,_fggfa .Width ,_fggfa .BytesPerLine ,_fggfa .Data ,_fggfa .Alpha ,_fggfa .Decode );
};func (_eeba *CMYK32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_eeba .Width ,Y :_eeba .Height }};};func (_cfcb *NRGBA32 )Validate ()error {if len (_cfcb .Data )!=3*_cfcb .Width *_cfcb .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_cd :=BytesPerLine (width ,8,1);if len (data )< _cd *height {return nil ,nil ;};_ae :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_cdc ,_ag :=MonochromeConverter .Convert (_ae );
if _ag !=nil {return nil ,_ag ;};return _cdc .Base ().Data ,nil ;};func _fcd (_eacg ,_edbd *Monochrome )(_ef error ){_ade :=_edbd .BytesPerLine ;_cf :=_eacg .BytesPerLine ;var _cff ,_ccef ,_ede ,_eede ,_cgg int ;for _ede =0;_ede < _edbd .Height ;_ede ++{_cff =_ede *_ade ;
_ccef =8*_ede *_cf ;for _eede =0;_eede < _ade ;_eede ++{if _ef =_eacg .setEightBytes (_ccef +_eede *8,_dg [_edbd .Data [_cff +_eede ]]);_ef !=nil {return _ef ;};};for _cgg =1;_cgg < 8;_cgg ++{for _eede =0;_eede < _cf ;_eede ++{if _ef =_eacg .setByte (_ccef +_cgg *_cf +_eede ,_eacg .Data [_ccef +_eede ]);
_ef !=nil {return _ef ;};};};};return nil ;};func _gagg (_abbe uint8 )bool {if _abbe ==0||_abbe ==255{return true ;};return false ;};func (_accc *Monochrome )GrayAt (x ,y int )_c .Gray {_gefe ,_ :=ColorAtGray1BPC (x ,y ,_accc .BytesPerLine ,_accc .Data ,_accc .Decode );
return _gefe ;};func (_bcge *Monochrome )Base ()*ImageBase {return &_bcge .ImageBase };func _fce (_fcde int )[]uint {var _gca []uint ;_gb :=_fcde ;_ac :=_gb /8;if _ac !=0{for _ggc :=0;_ggc < _ac ;_ggc ++{_gca =append (_gca ,8);};_cba :=_gb %8;_gb =0;if _cba !=0{_gb =_cba ;
};};_fee :=_gb /4;if _fee !=0{for _ffdf :=0;_ffdf < _fee ;_ffdf ++{_gca =append (_gca ,4);};_egg :=_gb %4;_gb =0;if _egg !=0{_gb =_egg ;};};_bfc :=_gb /2;if _bfc !=0{for _gcg :=0;_gcg < _bfc ;_gcg ++{_gca =append (_gca ,2);};};return _gca ;};var _ Image =&Gray4 {};
func (_dgga *Gray8 )SetGray (x ,y int ,g _c .Gray ){_fbef :=y *_dgga .BytesPerLine +x ;if _fbef > len (_dgga .Data )-1{return ;};_dgga .Data [_fbef ]=g .Y ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _fcda (_def _e .Image )(Image ,error ){if _bgece ,_ffcb :=_def .(*NRGBA16 );
_ffcb {return _bgece .Copy (),nil ;};_aacc :=_def .Bounds ();_faga ,_dfaae :=NewImage (_aacc .Max .X ,_aacc .Max .Y ,4,3,nil ,nil ,nil );if _dfaae !=nil {return nil ,_dfaae ;};_ffgab (_def ,_faga ,_aacc );return _faga ,nil ;};func _bcbg (_fcce *Monochrome ,_edcf ,_eaga int ,_aaeb ,_fded int ,_caadc RasterOperator ,_aaa *Monochrome ,_bacb ,_ebee int )error {var _dgdec ,_aabfg ,_afcbf ,_dbgc int ;
if _edcf < 0{_bacb -=_edcf ;_aaeb +=_edcf ;_edcf =0;};if _bacb < 0{_edcf -=_bacb ;_aaeb +=_bacb ;_bacb =0;};_dgdec =_edcf +_aaeb -_fcce .Width ;if _dgdec > 0{_aaeb -=_dgdec ;};_aabfg =_bacb +_aaeb -_aaa .Width ;if _aabfg > 0{_aaeb -=_aabfg ;};if _eaga < 0{_ebee -=_eaga ;
_fded +=_eaga ;_eaga =0;};if _ebee < 0{_eaga -=_ebee ;_fded +=_ebee ;_ebee =0;};_afcbf =_eaga +_fded -_fcce .Height ;if _afcbf > 0{_fded -=_afcbf ;};_dbgc =_ebee +_fded -_aaa .Height ;if _dbgc > 0{_fded -=_dbgc ;};if _aaeb <=0||_fded <=0{return nil ;};
var _aface error ;switch {case _edcf &7==0&&_bacb &7==0:_aface =_ffab (_fcce ,_edcf ,_eaga ,_aaeb ,_fded ,_caadc ,_aaa ,_bacb ,_ebee );case _edcf &7==_bacb &7:_aface =_bgfe (_fcce ,_edcf ,_eaga ,_aaeb ,_fded ,_caadc ,_aaa ,_bacb ,_ebee );default:_aface =_ddda (_fcce ,_edcf ,_eaga ,_aaeb ,_fded ,_caadc ,_aaa ,_bacb ,_ebee );
};if _aface !=nil {return _aface ;};return nil ;};const (_ecdd shift =iota ;_fgea ;);func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_dbca :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _dgaf Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_dgaf =&Monochrome {ImageBase :_dbca ,ModelThreshold :0x0f};case 2:_dgaf =&Gray2 {ImageBase :_dbca };case 4:_dgaf =&Gray4 {ImageBase :_dbca };case 8:_dgaf =&Gray8 {ImageBase :_dbca };
case 16:_dgaf =&Gray16 {ImageBase :_dbca };};case 3:switch bitsPerComponent {case 4:_dgaf =&NRGBA16 {ImageBase :_dbca };case 8:_dgaf =&NRGBA32 {ImageBase :_dbca };case 16:_dgaf =&NRGBA64 {ImageBase :_dbca };};case 4:_dgaf =&CMYK32 {ImageBase :_dbca };};
if _dgaf ==nil {return nil ,ErrInvalidImage ;};return _dgaf ,nil ;};func _dac (_fad ,_bdg *Monochrome ,_caf []byte ,_aeb int )(_bfd error ){var (_gfb ,_fcfc ,_aefa ,_ebg ,_dgd ,_ebb ,_bce ,_decc int ;_cab ,_gcd uint32 ;_dadc ,_aa byte ;_ge uint16 ;);_fcec :=make ([]byte ,4);
_dcb :=make ([]byte ,4);for _aefa =0;_aefa < _fad .Height -1;_aefa ,_ebg =_aefa +2,_ebg +1{_gfb =_aefa *_fad .BytesPerLine ;_fcfc =_ebg *_bdg .BytesPerLine ;for _dgd ,_ebb =0,0;_dgd < _aeb ;_dgd ,_ebb =_dgd +4,_ebb +1{for _bce =0;_bce < 4;_bce ++{_decc =_gfb +_dgd +_bce ;
if _decc <=len (_fad .Data )-1&&_decc < _gfb +_fad .BytesPerLine {_fcec [_bce ]=_fad .Data [_decc ];}else {_fcec [_bce ]=0x00;};_decc =_gfb +_fad .BytesPerLine +_dgd +_bce ;if _decc <=len (_fad .Data )-1&&_decc < _gfb +(2*_fad .BytesPerLine ){_dcb [_bce ]=_fad .Data [_decc ];
}else {_dcb [_bce ]=0x00;};};_cab =_gc .BigEndian .Uint32 (_fcec );_gcd =_gc .BigEndian .Uint32 (_dcb );_gcd |=_cab ;_gcd |=_gcd <<1;_gcd &=0xaaaaaaaa;_cab =_gcd |(_gcd <<7);_dadc =byte (_cab >>24);_aa =byte ((_cab >>8)&0xff);_decc =_fcfc +_ebb ;if _decc +1==len (_bdg .Data )-1||_decc +1>=_fcfc +_bdg .BytesPerLine {_bdg .Data [_decc ]=_caf [_dadc ];
}else {_ge =(uint16 (_caf [_dadc ])<<8)|uint16 (_caf [_aa ]);if _bfd =_bdg .setTwoBytes (_decc ,_ge );_bfd !=nil {return _f .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_decc );
};_ebb ++;};};};return nil ;};func _eegd (_edfd int ,_baff int )error {return _f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_edfd ,_baff );
};func _dace (_abef _c .NYCbCrA )_c .RGBA {_ffae ,_fga ,_cgbc ,_agac :=_dfc (_abef ).RGBA ();return _c .RGBA {R :uint8 (_ffae >>8),G :uint8 (_fga >>8),B :uint8 (_cgbc >>8),A :uint8 (_agac >>8)};};func _df (_fg *Monochrome ,_af int ,_ab []uint )(*Monochrome ,error ){_cdg :=_af *_fg .Width ;
_bc :=_af *_fg .Height ;_db :=_efc (_cdg ,_bc );for _aef ,_fa :=range _ab {var _age error ;switch _fa {case 2:_age =_dfa (_db ,_fg );case 4:_age =_de (_db ,_fg );case 8:_age =_fcd (_db ,_fg );};if _age !=nil {return nil ,_age ;};if _aef !=len (_ab )-1{_fg =_db .copy ();
};};return _db ,nil ;};func _cfeca (_deafd _c .NRGBA )_c .NRGBA {_deafd .R =_deafd .R >>4|(_deafd .R >>4)<<4;_deafd .G =_deafd .G >>4|(_deafd .G >>4)<<4;_deafd .B =_deafd .B >>4|(_deafd .B >>4)<<4;return _deafd ;};func (_edbc *Monochrome )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_edbc .Width ,Y :_edbc .Height }};
};func _aec (_fff _e .Image ,_gdd Image ,_eege _e .Rectangle ){for _abcg :=0;_abcg < _eege .Max .X ;_abcg ++{for _ege :=0;_ege < _eege .Max .Y ;_ege ++{_cag :=_fff .At (_abcg ,_ege );_gdd .Set (_abcg ,_ege ,_cag );};};};type NRGBA interface{NRGBAAt (_dcff ,_bee int )_c .NRGBA ;
SetNRGBA (_beag ,_fbeb int ,_eddf _c .NRGBA );};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_gdae :=y *bytesPerLine +x ;if _gdae >=len (data ){return _c .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_abda :=data [_gdae ];if len (decode )==2{_abda =uint8 (uint32 (LinearInterpolate (float64 (_abda ),0,255,decode [0],decode [1]))&0xff);};return _c .Gray {Y :_abda },nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_c .CMYK ,error ){_afc :=4*(y *width +x );
if _afc +3>=len (data ){return _c .CMYK {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_afc ]&0xff;M :=data [_afc +1]&0xff;Y :=data [_afc +2]&0xff;K :=data [_afc +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _c .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _fcgf (_dfef _e .Image )(Image ,error ){if _cgfgd ,_ebdd :=_dfef .(*Gray16 );
_ebdd {return _cgfgd .Copy (),nil ;};_cfea :=_dfef .Bounds ();_eebee ,_abff :=NewImage (_cfea .Max .X ,_cfea .Max .Y ,16,1,nil ,nil ,nil );if _abff !=nil {return nil ,_abff ;};_aabc (_dfef ,_eebee ,_cfea );return _eebee ,nil ;};func (_cge *ImageBase )setByte (_bcfc int ,_egff byte )error {if _bcfc > len (_cge .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cge .Data [_bcfc ]=_egff ;return nil ;};var _ Image =&Gray8 {};func (_baa monochromeModel )Convert (c _c .Color )_c .Color {_dae :=_c .GrayModel .Convert (c ).(_c .Gray );return _gcf (_dae ,_baa );};func _abea (_fgfd _c .NRGBA64 )_c .RGBA {_fgab ,_ffgg ,_bdfb ,_debg :=_fgfd .RGBA ();
return _c .RGBA {R :uint8 (_fgab >>8),G :uint8 (_ffgg >>8),B :uint8 (_bdfb >>8),A :uint8 (_debg >>8)};};func (_ddddc *Monochrome )AddPadding ()(_bgae error ){if _gbddf :=((_ddddc .Width *_ddddc .Height )+7)>>3;len (_ddddc .Data )< _gbddf {return _f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_ddddc .Data ),_gbddf );
};_ggda :=_ddddc .Width %8;if _ggda ==0{return nil ;};_gbc :=_ddddc .Width /8;_cdce :=_b .NewReader (_ddddc .Data );_fffg :=make ([]byte ,_ddddc .Height *_ddddc .BytesPerLine );_eccf :=_b .NewWriterMSB (_fffg );_ecgf :=make ([]byte ,_gbc );var (_edbg int ;
_cbga uint64 ;);for _edbg =0;_edbg < _ddddc .Height ;_edbg ++{if _ ,_bgae =_cdce .Read (_ecgf );_bgae !=nil {return _bgae ;};if _ ,_bgae =_eccf .Write (_ecgf );_bgae !=nil {return _bgae ;};if _cbga ,_bgae =_cdce .ReadBits (byte (_ggda ));_bgae !=nil {return _bgae ;
};if _bgae =_eccf .WriteByte (byte (_cbga )<<uint (8-_ggda ));_bgae !=nil {return _bgae ;};};_ddddc .Data =_eccf .Data ();return nil ;};var _ Image =&Gray2 {};func (_gcab *RGBA32 )At (x ,y int )_c .Color {_cebe ,_ :=_gcab .ColorAt (x ,y );return _cebe };
var _ Image =&NRGBA32 {};func (_acca *ImageBase )setEightBytes (_bdfg int ,_ccbe uint64 )error {_eaad :=_acca .BytesPerLine -(_bdfg %_acca .BytesPerLine );if _acca .BytesPerLine !=_acca .Width >>3{_eaad --;};if _eaad >=8{return _acca .setEightFullBytes (_bdfg ,_ccbe );
};return _acca .setEightPartlyBytes (_bdfg ,_eaad ,_ccbe );};func (_ecddg *NRGBA16 )Base ()*ImageBase {return &_ecddg .ImageBase };func _gagc (_ccfd _c .RGBA )_c .NRGBA {switch _ccfd .A {case 0xff:return _c .NRGBA {R :_ccfd .R ,G :_ccfd .G ,B :_ccfd .B ,A :0xff};
case 0x00:return _c .NRGBA {};default:_ece ,_eabd ,_fafa ,_gac :=_ccfd .RGBA ();_ece =(_ece *0xffff)/_gac ;_eabd =(_eabd *0xffff)/_gac ;_fafa =(_fafa *0xffff)/_gac ;return _c .NRGBA {R :uint8 (_ece >>8),G :uint8 (_eabd >>8),B :uint8 (_fafa >>8),A :uint8 (_gac >>8)};
};};func (_fdefb *RGBA32 )Base ()*ImageBase {return &_fdefb .ImageBase };func (_fgb *NRGBA16 )ColorModel ()_c .Model {return NRGBA16Model };func (_dafe *RGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtRGBA32 (x ,y ,_dafe .Width ,_dafe .Data ,_dafe .Alpha ,_dafe .Decode );
};func _fdce (_ebe _c .CMYK )_c .NRGBA {_eabe ,_ebc ,_dda :=_c .CMYKToRGB (_ebe .C ,_ebe .M ,_ebe .Y ,_ebe .K );return _c .NRGBA {R :_eabe ,G :_ebc ,B :_dda ,A :0xff};};func (_gaeg *ImageBase )Pix ()[]byte {return _gaeg .Data };func (_bff *Gray2 )SetGray (x ,y int ,gray _c .Gray ){_eegbe :=_acf (gray );
_afcc :=y *_bff .BytesPerLine ;_cgfb :=_afcc +(x >>2);if _cgfb >=len (_bff .Data ){return ;};_dadd :=_eegbe .Y >>6;_bff .Data [_cgfb ]=(_bff .Data [_cgfb ]&(^(0xc0>>uint (2*((x )&3)))))|(_dadd <<uint (6-2*(x &3)));};type Histogramer interface{Histogram ()[256]int ;
};func _bade (_bbda *_e .NYCbCrA ,_ffba NRGBA ,_bdagc _e .Rectangle ){for _edaff :=0;_edaff < _bdagc .Max .X ;_edaff ++{for _fgc :=0;_fgc < _bdagc .Max .Y ;_fgc ++{_dfb :=_bbda .NYCbCrAAt (_edaff ,_fgc );_ffba .SetNRGBA (_edaff ,_fgc ,_dfc (_dfb ));};};
};func (_aabe *ImageBase )GetAlpha ()[]byte {return _aabe .Alpha };func (_gafaa *NRGBA64 )setNRGBA64 (_gegd int ,_ffecg _c .NRGBA64 ,_bbedd int ){_gafaa .Data [_gegd ]=uint8 (_ffecg .R >>8);_gafaa .Data [_gegd +1]=uint8 (_ffecg .R &0xff);_gafaa .Data [_gegd +2]=uint8 (_ffecg .G >>8);
_gafaa .Data [_gegd +3]=uint8 (_ffecg .G &0xff);_gafaa .Data [_gegd +4]=uint8 (_ffecg .B >>8);_gafaa .Data [_gegd +5]=uint8 (_ffecg .B &0xff);if _bbedd +1< len (_gafaa .Alpha ){_gafaa .Alpha [_bbedd ]=uint8 (_ffecg .A >>8);_gafaa .Alpha [_bbedd +1]=uint8 (_ffecg .A &0xff);
};};func _beaa (_cfd *Monochrome ,_bcad ,_debgd ,_febf ,_febfd int ,_aaag RasterOperator ){if _bcad < 0{_febf +=_bcad ;_bcad =0;};_adbcc :=_bcad +_febf -_cfd .Width ;if _adbcc > 0{_febf -=_adbcc ;};if _debgd < 0{_febfd +=_debgd ;_debgd =0;};_eead :=_debgd +_febfd -_cfd .Height ;
if _eead > 0{_febfd -=_eead ;};if _febf <=0||_febfd <=0{return ;};if (_bcad &7)==0{_dbac (_cfd ,_bcad ,_debgd ,_febf ,_febfd ,_aaag );}else {_fgdg (_cfd ,_bcad ,_debgd ,_febf ,_febfd ,_aaag );};};func _fgeb (_fcb _c .NRGBA )_c .CMYK {_gbb ,_cbf ,_bac ,_ :=_fcb .RGBA ();
_aaga ,_ecd ,_ccf ,_gage :=_c .RGBToCMYK (uint8 (_gbb >>8),uint8 (_cbf >>8),uint8 (_bac >>8));return _c .CMYK {C :_aaga ,M :_ecd ,Y :_ccf ,K :_gage };};func (_dgdf *NRGBA16 )At (x ,y int )_c .Color {_gba ,_ :=_dgdf .ColorAt (x ,y );return _gba };type ImageBase struct{Width ,Height int ;
BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};var _ NRGBA =&NRGBA32 {};func (_ddgba *NRGBA16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_ddgba .Width ,Y :_ddgba .Height }};};func (_dffb *Gray2 )ColorModel ()_c .Model {return Gray2Model };
func (_gdca *RGBA32 )setRGBA (_affc int ,_cfdc _c .RGBA ){_edfca :=3*_affc ;_gdca .Data [_edfca ]=_cfdc .R ;_gdca .Data [_edfca +1]=_cfdc .G ;_gdca .Data [_edfca +2]=_cfdc .B ;if _affc < len (_gdca .Alpha ){_gdca .Alpha [_affc ]=_cfdc .A ;};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_beac (n )+1);};func _ffgab (_bebc _e .Image ,_ddbb Image ,_caag _e .Rectangle ){if _fbaa ,_fagf :=_bebc .(SMasker );_fagf &&_fbaa .HasAlpha (){_ddbb .(SMasker ).MakeAlpha ();};switch _eccg :=_bebc .(type ){case Gray :_bddg (_eccg ,_ddbb .(NRGBA ),_caag );
case NRGBA :_bafg (_eccg ,_ddbb .(NRGBA ),_caag );case *_e .NYCbCrA :_bade (_eccg ,_ddbb .(NRGBA ),_caag );case CMYK :_fgffb (_eccg ,_ddbb .(NRGBA ),_caag );case RGBA :_egfcd (_eccg ,_ddbb .(NRGBA ),_caag );case nrgba64 :_dafd (_eccg ,_ddbb .(NRGBA ),_caag );
default:_aec (_bebc ,_ddbb ,_caag );};};func _afgc (_dbc _c .Color )_c .Color {_egc :=_c .GrayModel .Convert (_dbc ).(_c .Gray );return _acf (_egc )};func _cbea (_dcab *_e .Gray16 ,_cfb uint8 )*_e .Gray {_dfdf :=_dcab .Bounds ();_fabe :=_e .NewGray (_dfdf );
for _bceb :=0;_bceb < _dfdf .Dx ();_bceb ++{for _dfca :=0;_dfca < _dfdf .Dy ();_dfca ++{_aefd :=_dcab .Gray16At (_bceb ,_dfca );_fabe .SetGray (_bceb ,_dfca ,_c .Gray {Y :_gcda (uint8 (_aefd .Y /256),_cfb )});};};return _fabe ;};func _eba (_dea ,_cgb int ,_dec []byte )*Monochrome {_agb :=_efc (_dea ,_cgb );
_agb .Data =_dec ;return _agb ;};var _ Gray =&Gray4 {};func (_effe *ImageBase )setEightPartlyBytes (_dbd ,_ggddf int ,_gafg uint64 )(_gdcd error ){var (_dcbb byte ;_dca int ;);for _ebf :=1;_ebf <=_ggddf ;_ebf ++{_dca =64-_ebf *8;_dcbb =byte (_gafg >>uint (_dca )&0xff);
if _gdcd =_effe .setByte (_dbd +_ebf -1,_dcbb );_gdcd !=nil {return _gdcd ;};};_cbgc :=_effe .BytesPerLine *8-_effe .Width ;if _cbgc ==0{return nil ;};_dca -=8;_dcbb =byte (_gafg >>uint (_dca )&0xff)<<uint (_cbgc );if _gdcd =_effe .setByte (_dbd +_ggddf ,_dcbb );
_gdcd !=nil {return _gdcd ;};return nil ;};func _cdcg (_ffggg _e .Image )(Image ,error ){if _bccd ,_fcecd :=_ffggg .(*Gray4 );_fcecd {return _bccd .Copy (),nil ;};_bdgd :=_ffggg .Bounds ();_agaa ,_cbce :=NewImage (_bdgd .Max .X ,_bdgd .Max .Y ,4,1,nil ,nil ,nil );
if _cbce !=nil {return nil ,_cbce ;};_aabc (_ffggg ,_agaa ,_bdgd );return _agaa ,nil ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_bcggb *NRGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bcggb .Width ,Y :_bcggb .Height }};};func _eecg (_ceeb NRGBA ,_bace RGBA ,_febd _e .Rectangle ){for _fdaf :=0;_fdaf < _febd .Max .X ;_fdaf ++{for _gbdf :=0;_gbdf < _febd .Max .Y ;
_gbdf ++{_aacb :=_ceeb .NRGBAAt (_fdaf ,_gbdf );_bace .SetRGBA (_fdaf ,_gbdf ,_dggb (_aacb ));};};};func (_daed *Gray16 )ColorModel ()_c .Model {return _c .Gray16Model };func (_cdcf *Gray2 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cdcf .Width ,Y :_cdcf .Height }};
};func (_adaa *Gray8 )ColorModel ()_c .Model {return _c .GrayModel };func _eega (_egf _e .Image )(Image ,error ){if _fdec ,_dcd :=_egf .(*Monochrome );_dcd {return _fdec ,nil ;};_cbfd :=_egf .Bounds ();var _deg Gray ;switch _efe :=_egf .(type ){case Gray :_deg =_efe ;
case NRGBA :_deg =&Gray8 {ImageBase :NewImageBase (_cbfd .Max .X ,_cbfd .Max .Y ,8,1,nil ,nil ,nil )};_gcb (_deg ,_efe ,_cbfd );case nrgba64 :_deg =&Gray8 {ImageBase :NewImageBase (_cbfd .Max .X ,_cbfd .Max .Y ,8,1,nil ,nil ,nil )};_gcgb (_deg ,_efe ,_cbfd );
default:_ffaeg ,_eegbc :=GrayConverter .Convert (_egf );if _eegbc !=nil {return nil ,_eegbc ;};_deg =_ffaeg .(Gray );};_acef ,_egd :=NewImage (_cbfd .Max .X ,_cbfd .Max .Y ,1,1,nil ,nil ,nil );if _egd !=nil {return nil ,_egd ;};_decce :=_acef .(*Monochrome );
_gce :=AutoThresholdTriangle (GrayHistogram (_deg ));for _cede :=0;_cede < _cbfd .Max .X ;_cede ++{for _eec :=0;_eec < _cbfd .Max .Y ;_eec ++{_ega :=_gcf (_deg .GrayAt (_cede ,_eec ),monochromeModel (_gce ));_decce .SetGray (_cede ,_eec ,_ega );};};return _acef ,nil ;
};type NRGBA64 struct{ImageBase };func _dffc (_caad _c .Gray )_c .RGBA {return _c .RGBA {R :_caad .Y ,G :_caad .Y ,B :_caad .Y ,A :0xff}};func _dffbb (_ggad ,_bced RGBA ,_aafc _e .Rectangle ){for _abaa :=0;_abaa < _aafc .Max .X ;_abaa ++{for _abag :=0;
_abag < _aafc .Max .Y ;_abag ++{_bced .SetRGBA (_abaa ,_abag ,_ggad .RGBAAt (_abaa ,_abag ));};};};var _ Image =&NRGBA64 {};func GrayHistogram (g Gray )(_bfdb [256]int ){switch _cafc :=g .(type ){case Histogramer :return _cafc .Histogram ();case _e .Image :_acgc :=_cafc .Bounds ();
for _cacdf :=0;_cacdf < _acgc .Max .X ;_cacdf ++{for _fdae :=0;_fdae < _acgc .Max .Y ;_fdae ++{_bfdb [g .GrayAt (_cacdf ,_fdae ).Y ]++;};};return _bfdb ;default:return [256]int {};};};func _beac (_agbf uint )uint {var _eeaf uint ;for _agbf !=0{_agbf >>=1;
_eeaf ++;};return _eeaf -1;};func _cae (_edfe ,_cecec CMYK ,_dgdc _e .Rectangle ){for _cac :=0;_cac < _dgdc .Max .X ;_cac ++{for _accb :=0;_accb < _dgdc .Max .Y ;_accb ++{_cecec .SetCMYK (_cac ,_accb ,_edfe .CMYKAt (_cac ,_accb ));};};};func _acf (_cfaa _c .Gray )_c .Gray {_ffcf :=_cfaa .Y >>6;
_ffcf |=_ffcf <<2;_cfaa .Y =_ffcf |_ffcf <<4;return _cfaa ;};func (_dfgba *RGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };func (_ccge *NRGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };var _ _e .Image =&NRGBA16 {};func (_baac *NRGBA32 )At (x ,y int )_c .Color {_daad ,_ :=_baac .ColorAt (x ,y );
return _daad };func (_egcd *NRGBA64 )SetNRGBA64 (x ,y int ,c _c .NRGBA64 ){_eefaf :=(y *_egcd .Width +x )*2;_bfec :=_eefaf *3;if _bfec +5>=len (_egcd .Data ){return ;};_egcd .setNRGBA64 (_bfec ,c ,_eefaf );};func (_bcbe *Monochrome )getBitAt (_edfb ,_fcfb int )bool {_bedg :=_fcfb *_bcbe .BytesPerLine +(_edfb >>3);
_ged :=_edfb &0x07;_dega :=uint (7-_ged );if _bedg > len (_bcbe .Data )-1{return false ;};if (_bcbe .Data [_bedg ]>>_dega )&0x01>=1{return true ;};return false ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func _dbac (_baadb *Monochrome ,_aeca ,_adeb int ,_aeg ,_effa int ,_cdge RasterOperator ){var (_baba int ;
_baef byte ;_beaeg ,_cdde int ;_agegc int ;);_bcbc :=_aeg >>3;_bgeb :=_aeg &7;if _bgeb > 0{_baef =_dcec [_bgeb ];};_baba =_baadb .BytesPerLine *_adeb +(_aeca >>3);switch _cdge {case PixClr :for _beaeg =0;_beaeg < _effa ;_beaeg ++{_agegc =_baba +_beaeg *_baadb .BytesPerLine ;
for _cdde =0;_cdde < _bcbc ;_cdde ++{_baadb .Data [_agegc ]=0x0;_agegc ++;};if _bgeb > 0{_baadb .Data [_agegc ]=_eaadc (_baadb .Data [_agegc ],0x0,_baef );};};case PixSet :for _beaeg =0;_beaeg < _effa ;_beaeg ++{_agegc =_baba +_beaeg *_baadb .BytesPerLine ;
for _cdde =0;_cdde < _bcbc ;_cdde ++{_baadb .Data [_agegc ]=0xff;_agegc ++;};if _bgeb > 0{_baadb .Data [_agegc ]=_eaadc (_baadb .Data [_agegc ],0xff,_baef );};};case PixNotDst :for _beaeg =0;_beaeg < _effa ;_beaeg ++{_agegc =_baba +_beaeg *_baadb .BytesPerLine ;
for _cdde =0;_cdde < _bcbc ;_cdde ++{_baadb .Data [_agegc ]=^_baadb .Data [_agegc ];_agegc ++;};if _bgeb > 0{_baadb .Data [_agegc ]=_eaadc (_baadb .Data [_agegc ],^_baadb .Data [_agegc ],_baef );};};};};func (_edfg *NRGBA16 )setNRGBA (_cacc ,_edea ,_cgag int ,_cdfd _c .NRGBA ){if _cacc *3%2==0{_edfg .Data [_cgag ]=(_cdfd .R >>4)<<4|(_cdfd .G >>4);
_edfg .Data [_cgag +1]=(_cdfd .B >>4)<<4|(_edfg .Data [_cgag +1]&0xf);}else {_edfg .Data [_cgag ]=(_edfg .Data [_cgag ]&0xf0)|(_cdfd .R >>4);_edfg .Data [_cgag +1]=(_cdfd .G >>4)<<4|(_cdfd .B >>4);};if _edfg .Alpha !=nil {_aecc :=_edea *BytesPerLine (_edfg .Width ,4,1);
if _aecc < len (_edfg .Alpha ){if _cacc %2==0{_edfg .Alpha [_aecc ]=(_cdfd .A >>uint (4))<<uint (4)|(_edfg .Alpha [_cgag ]&0xf);}else {_edfg .Alpha [_aecc ]=(_edfg .Alpha [_aecc ]&0xf0)|(_cdfd .A >>uint (4));};};};};func (_fgd *Monochrome )setBit (_gbf ,_dacf int ){_fgd .Data [_gbf +(_dacf >>3)]|=0x80>>uint (_dacf &7)};
func _eed (_ff *Monochrome ,_bd int )(*Monochrome ,error ){if _ff ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _bd ==1{return _ff .copy (),nil ;};if !IsPowerOf2 (uint (_bd )){return nil ,_f .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bd );
};_fe :=_fce (_bd );return _df (_ff ,_bd ,_fe );};func _agg (_gbe NRGBA ,_ccgg CMYK ,_ffa _e .Rectangle ){for _egb :=0;_egb < _ffa .Max .X ;_egb ++{for _eab :=0;_eab < _ffa .Max .Y ;_eab ++{_gdaf :=_gbe .NRGBAAt (_egb ,_eab );_ccgg .SetCMYK (_egb ,_eab ,_fgeb (_gdaf ));
};};};func _egfcd (_faeb RGBA ,_fdeb NRGBA ,_dgaa _e .Rectangle ){for _ddgf :=0;_ddgf < _dgaa .Max .X ;_ddgf ++{for _cceba :=0;_cceba < _dgaa .Max .Y ;_cceba ++{_ecdab :=_faeb .RGBAAt (_ddgf ,_cceba );_fdeb .SetNRGBA (_ddgf ,_cceba ,_gagc (_ecdab ));};
};};func (_beaaf *RGBA32 )Validate ()error {if len (_beaaf .Data )!=3*_beaaf .Width *_beaaf .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gbg *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_gbg .ImageBase .copy (),ModelThreshold :_gbg .ModelThreshold };};func (_cfab *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_cfab .copy ()}};func (_daef *Gray8 )GrayAt (x ,y int )_c .Gray {_ddc ,_ :=ColorAtGray8BPC (x ,y ,_daef .BytesPerLine ,_daef .Data ,_daef .Decode );
return _ddc ;};func _beg ()(_ggdd [256]uint64 ){for _aed :=0;_aed < 256;_aed ++{if _aed &0x01!=0{_ggdd [_aed ]|=0xff;};if _aed &0x02!=0{_ggdd [_aed ]|=0xff00;};if _aed &0x04!=0{_ggdd [_aed ]|=0xff0000;};if _aed &0x08!=0{_ggdd [_aed ]|=0xff000000;};if _aed &0x10!=0{_ggdd [_aed ]|=0xff00000000;
};if _aed &0x20!=0{_ggdd [_aed ]|=0xff0000000000;};if _aed &0x40!=0{_ggdd [_aed ]|=0xff000000000000;};if _aed &0x80!=0{_ggdd [_aed ]|=0xff00000000000000;};};return _ggdd ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};var _ RGBA =&RGBA32 {};func (_aggd *Monochrome )getBit (_agbb ,_bdae int )uint8 {return _aggd .Data [_agbb +(_bdae >>3)]>>uint (7-(_bdae &7))&1;};var _cea [256]uint8 ;func (_eccfc *NRGBA64 )Set (x ,y int ,c _c .Color ){_begc :=(y *_eccfc .Width +x )*2;
_fegc :=_begc *3;if _fegc +5>=len (_eccfc .Data ){return ;};_gcac :=_c .NRGBA64Model .Convert (c ).(_c .NRGBA64 );_eccfc .setNRGBA64 (_fegc ,_gcac ,_begc );};func _dfa (_dbf ,_bg *Monochrome )(_cg error ){_cgf :=_bg .BytesPerLine ;_bgd :=_dbf .BytesPerLine ;
var (_eg byte ;_ffd uint16 ;_fgf ,_bgf ,_gg ,_ga ,_ed int ;);for _gg =0;_gg < _bg .Height ;_gg ++{_fgf =_gg *_cgf ;_bgf =2*_gg *_bgd ;for _ga =0;_ga < _cgf ;_ga ++{_eg =_bg .Data [_fgf +_ga ];_ffd =_cgfg [_eg ];_ed =_bgf +_ga *2;if _dbf .BytesPerLine !=_bg .BytesPerLine *2&&(_ga +1)*2> _dbf .BytesPerLine {_cg =_dbf .setByte (_ed ,byte (_ffd >>8));
}else {_cg =_dbf .setTwoBytes (_ed ,_ffd );};if _cg !=nil {return _cg ;};};for _ga =0;_ga < _bgd ;_ga ++{_ed =_bgf +_bgd +_ga ;_eg =_dbf .Data [_bgf +_ga ];if _cg =_dbf .setByte (_ed ,_eg );_cg !=nil {return _cg ;};};};return nil ;};func (_ddcg *NRGBA64 )Base ()*ImageBase {return &_ddcg .ImageBase };
func _gfe (_bbc _c .Color )_c .Color {_dbfee :=_c .GrayModel .Convert (_bbc ).(_c .Gray );return _ddfc (_dbfee );};type RGBA interface{RGBAAt (_faabg ,_ebfa int )_c .RGBA ;SetRGBA (_fdceb ,_gfge int ,_cagfa _c .RGBA );};var _ Gray =&Gray2 {};func (_bcf colorConverter )Convert (src _e .Image )(Image ,error ){return _bcf ._gdda (src )};
func _adfd (_gedb *_e .NYCbCrA ,_ebfe RGBA ,_bggd _e .Rectangle ){for _agea :=0;_agea < _bggd .Max .X ;_agea ++{for _gffa :=0;_gffa < _bggd .Max .Y ;_gffa ++{_bfcb :=_gedb .NYCbCrAAt (_agea ,_gffa );_ebfe .SetRGBA (_agea ,_gffa ,_dace (_bfcb ));};};};func _fcdc (_ebfag _e .Image ,_fddd Image ,_ccgf _e .Rectangle ){if _bdfde ,_ffca :=_ebfag .(SMasker );
_ffca &&_bdfde .HasAlpha (){_fddd .(SMasker ).MakeAlpha ();};switch _bggg :=_ebfag .(type ){case Gray :_gfcb (_bggg ,_fddd .(RGBA ),_ccgf );case NRGBA :_eecg (_bggg ,_fddd .(RGBA ),_ccgf );case *_e .NYCbCrA :_adfd (_bggg ,_fddd .(RGBA ),_ccgf );case CMYK :_cgea (_bggg ,_fddd .(RGBA ),_ccgf );
case RGBA :_dffbb (_bggg ,_fddd .(RGBA ),_ccgf );case nrgba64 :_fdegg (_bggg ,_fddd .(RGBA ),_ccgf );default:_aec (_ebfag ,_fddd ,_ccgf );};};type CMYK interface{CMYKAt (_fgfc ,_dddg int )_c .CMYK ;SetCMYK (_fb ,_feg int ,_aag _c .CMYK );};func (_bdfc *Gray4 )SetGray (x ,y int ,g _c .Gray ){if x >=_bdfc .Width ||y >=_bdfc .Height {return ;
};g =_ddfc (g );_bdfc .setGray (x ,y ,g );};func _gddg (_ebfd *Monochrome ,_dgbc ,_bgec ,_dbae ,_dcbe int ,_ebdf RasterOperator ,_egfc *Monochrome ,_fgeeg ,_abbce int )error {if _ebfd ==nil {return _a .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _ebdf ==PixDst {return nil ;};switch _ebdf {case PixClr ,PixSet ,PixNotDst :_beaa (_ebfd ,_dgbc ,_bgec ,_dbae ,_dcbe ,_ebdf );return nil ;};if _egfc ==nil {_ee .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _a .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _fgec :=_bcbg (_ebfd ,_dgbc ,_bgec ,_dbae ,_dcbe ,_ebdf ,_egfc ,_fgeeg ,_abbce );_fgec !=nil {return _fgec ;};return nil ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA64 ,error ){_efgc :=(y *width +x )*2;_edbbg :=_efgc *3;if _edbbg +5>=len (data ){return _c .NRGBA64 {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _dbcb =0xffff;_aeea :=uint16 (_dbcb );if alpha !=nil &&len (alpha )> _efgc +1{_aeea =uint16 (alpha [_efgc ])<<8|uint16 (alpha [_efgc +1]);};_ccde :=uint16 (data [_edbbg ])<<8|uint16 (data [_edbbg +1]);_gdac :=uint16 (data [_edbbg +2])<<8|uint16 (data [_edbbg +3]);
_bfdfd :=uint16 (data [_edbbg +4])<<8|uint16 (data [_edbbg +5]);if len (decode )==6{_ccde =uint16 (uint64 (LinearInterpolate (float64 (_ccde ),0,65535,decode [0],decode [1]))&_dbcb );_gdac =uint16 (uint64 (LinearInterpolate (float64 (_gdac ),0,65535,decode [2],decode [3]))&_dbcb );
_bfdfd =uint16 (uint64 (LinearInterpolate (float64 (_bfdfd ),0,65535,decode [4],decode [5]))&_dbcb );};return _c .NRGBA64 {R :_ccde ,G :_gdac ,B :_bfdfd ,A :_aeea },nil ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_f .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};type nrgba64 interface{NRGBA64At (_caaa ,_caaaa int )_c .NRGBA64 ;SetNRGBA64 (_eaec ,_afbe int ,_cgdc _c .NRGBA64 );};func _bdfd (){for _eedbc :=0;_eedbc < 256;_eedbc ++{_cea [_eedbc ]=uint8 (_eedbc &0x1)+(uint8 (_eedbc >>1)&0x1)+(uint8 (_eedbc >>2)&0x1)+(uint8 (_eedbc >>3)&0x1)+(uint8 (_eedbc >>4)&0x1)+(uint8 (_eedbc >>5)&0x1)+(uint8 (_eedbc >>6)&0x1)+(uint8 (_eedbc >>7)&0x1);
};};func (_edga *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_edga .copy ()}};func (_efcg *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_efcg .copy ()}};func (_ddff *Gray2 )Validate ()error {if len (_ddff .Data )!=_ddff .Height *_ddff .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _dggb (_gbde _c .NRGBA )_c .RGBA {_gfbb ,_bfdf ,_aab ,_cbg :=_gbde .RGBA ();return _c .RGBA {R :uint8 (_gfbb >>8),G :uint8 (_bfdf >>8),B :uint8 (_aab >>8),A :uint8 (_cbg >>8)};};func (_bgb *Monochrome )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray1BPC (x ,y ,_bgb .BytesPerLine ,_bgb .Data ,_bgb .Decode );
};func (_ceba *Gray2 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray2BPC (x ,y ,_ceba .BytesPerLine ,_ceba .Data ,_ceba .Decode );};var _ Image =&Monochrome {};func (_ddde *CMYK32 )At (x ,y int )_c .Color {_adbc ,_ :=_ddde .ColorAt (x ,y );return _adbc };
var _ Image =&RGBA32 {};func (_debdd *NRGBA16 )NRGBAAt (x ,y int )_c .NRGBA {_edff ,_ :=ColorAtNRGBA16 (x ,y ,_debdd .Width ,_debdd .BytesPerLine ,_debdd .Data ,_debdd .Alpha ,_debdd .Decode );return _edff ;};func _gaga (_edbb Gray ,_dag CMYK ,_eff _e .Rectangle ){for _cffa :=0;
_cffa < _eff .Max .X ;_cffa ++{for _cabb :=0;_cabb < _eff .Max .Y ;_cabb ++{_debc :=_edbb .GrayAt (_cffa ,_cabb );_dag .SetCMYK (_cffa ,_cabb ,_ffe (_debc ));};};};func (_aabf *Gray2 )At (x ,y int )_c .Color {_dcfa ,_ :=_aabf .ColorAt (x ,y );return _dcfa };
var _ Gray =&Gray16 {};func _cgea (_cccc CMYK ,_ffgfa RGBA ,_gedd _e .Rectangle ){for _gcge :=0;_gcge < _gedd .Max .X ;_gcge ++{for _befb :=0;_befb < _gedd .Max .Y ;_befb ++{_fbcge :=_cccc .CMYKAt (_gcge ,_befb );_ffgfa .SetRGBA (_gcge ,_befb ,_abbg (_fbcge ));
};};};func _fbgc (_ebdfd _e .Image )(Image ,error ){if _fbab ,_edgaa :=_ebdfd .(*NRGBA64 );_edgaa {return _fbab .Copy (),nil ;};_gfac ,_egdf ,_faae :=_fcgfa (_ebdfd ,2);_cada ,_eggb :=NewImage (_gfac .Max .X ,_gfac .Max .Y ,16,3,nil ,_faae ,nil );if _eggb !=nil {return nil ,_eggb ;
};_ebda (_ebdfd ,_cada ,_gfac );if len (_faae )!=0&&!_egdf {if _eaba :=_gfea (_faae ,_cada );_eaba !=nil {return nil ,_eaba ;};};return _cada ,nil ;};func _ddfc (_cbbg _c .Gray )_c .Gray {_cbbg .Y >>=4;_cbbg .Y |=_cbbg .Y <<4;return _cbbg };func _ebda (_gggd _e .Image ,_fbbe Image ,_fbcg _e .Rectangle ){if _bdaa ,_ggab :=_gggd .(SMasker );
_ggab &&_bdaa .HasAlpha (){_fbbe .(SMasker ).MakeAlpha ();};_aec (_gggd ,_fbbe ,_fbcg );};func (_dbgf *RGBA32 )SetRGBA (x ,y int ,c _c .RGBA ){_agee :=y *_dbgf .Width +x ;_fdbb :=3*_agee ;if _fdbb +2>=len (_dbgf .Data ){return ;};_dbgf .setRGBA (_agee ,c );
};func (_fdag *NRGBA64 )NRGBA64At (x ,y int )_c .NRGBA64 {_bacd ,_ :=ColorAtNRGBA64 (x ,y ,_fdag .Width ,_fdag .Data ,_fdag .Alpha ,_fdag .Decode );return _bacd ;};func (_fbgd *Gray16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray16BPC (x ,y ,_fbgd .BytesPerLine ,_fbgd .Data ,_fbgd .Decode );
};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );
case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_f .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray16 ,error ){_bgfb :=(y *bytesPerLine /2+x )*2;if _bgfb +1>=len (data ){return _c .Gray16 {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ddca :=uint16 (data [_bgfb ])<<8|uint16 (data [_bgfb +1]);if len (decode )==2{_ddca =uint16 (uint64 (LinearInterpolate (float64 (_ddca ),0,65535,decode [0],decode [1])));};return _c .Gray16 {Y :_ddca },nil ;};func (_fedg *Gray4 )Histogram ()(_ggcf [256]int ){for _gcbe :=0;
_gcbe < _fedg .Width ;_gcbe ++{for _faad :=0;_faad < _fedg .Height ;_faad ++{_ggcf [_fedg .GrayAt (_gcbe ,_faad ).Y ]++;};};return _ggcf ;};func _gfea (_bdge []byte ,_gceb Image )error {_cegb :=true ;for _cbcgg :=0;_cbcgg < len (_bdge );_cbcgg ++{if _bdge [_cbcgg ]!=0xff{_cegb =false ;
break ;};};if _cegb {switch _cacg :=_gceb .(type ){case *NRGBA32 :_cacg .Alpha =nil ;case *NRGBA64 :_cacg .Alpha =nil ;default:return _f .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_gceb );
};};return nil ;};func _gcda (_abfc ,_eebce uint8 )uint8 {if _abfc < _eebce {return 255;};return 0;};func (_fdb *CMYK32 )ColorModel ()_c .Model {return _c .CMYKModel };func ImgToBinary (i _e .Image ,threshold uint8 )*_e .Gray {switch _cgbf :=i .(type ){case *_e .Gray :if _befba (_cgbf ){return _cgbf ;
};return _cgdg (_cgbf ,threshold );case *_e .Gray16 :return _cbea (_cgbf ,threshold );default:return _eged (_cgbf ,threshold );};};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_deef :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_deef .Data =make ([]byte ,height *_deef .BytesPerLine );};return _deef ;};type Gray16 struct{ImageBase };var (_dcec =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_gfff =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);var _ _e .Image =&Gray2 {};
func (_aedg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_aedg .copy ()}};func _bddg (_aabeg Gray ,_dbbb NRGBA ,_aefg _e .Rectangle ){for _ddae :=0;_ddae < _aefg .Max .X ;_ddae ++{for _abdab :=0;_abdab < _aefg .Max .Y ;_abdab ++{_effg :=_aabeg .GrayAt (_ddae ,_abdab );
_dbbb .SetNRGBA (_ddae ,_abdab ,_bgdf (_effg ));};};};func _fgdg (_bgbd *Monochrome ,_cefc ,_fegfb int ,_deag ,_aabd int ,_aagb RasterOperator ){var (_dgbd bool ;_gefb bool ;_edda int ;_aace int ;_afff int ;_ccafa int ;_ccag bool ;_adae byte ;);_bfgf :=8-(_cefc &7);
_efb :=_gfff [_bfgf ];_fbcc :=_bgbd .BytesPerLine *_fegfb +(_cefc >>3);if _deag < _bfgf {_dgbd =true ;_efb &=_dcec [8-_bfgf +_deag ];};if !_dgbd {_edda =(_deag -_bfgf )>>3;if _edda !=0{_gefb =true ;_aace =_fbcc +1;};};_afff =(_cefc +_deag )&7;if !(_dgbd ||_afff ==0){_ccag =true ;
_adae =_dcec [_afff ];_ccafa =_fbcc +1+_edda ;};var _bef ,_acfd int ;switch _aagb {case PixClr :for _bef =0;_bef < _aabd ;_bef ++{_bgbd .Data [_fbcc ]=_eaadc (_bgbd .Data [_fbcc ],0x0,_efb );_fbcc +=_bgbd .BytesPerLine ;};if _gefb {for _bef =0;_bef < _aabd ;
_bef ++{for _acfd =0;_acfd < _edda ;_acfd ++{_bgbd .Data [_aace +_acfd ]=0x0;};_aace +=_bgbd .BytesPerLine ;};};if _ccag {for _bef =0;_bef < _aabd ;_bef ++{_bgbd .Data [_ccafa ]=_eaadc (_bgbd .Data [_ccafa ],0x0,_adae );_ccafa +=_bgbd .BytesPerLine ;};
};case PixSet :for _bef =0;_bef < _aabd ;_bef ++{_bgbd .Data [_fbcc ]=_eaadc (_bgbd .Data [_fbcc ],0xff,_efb );_fbcc +=_bgbd .BytesPerLine ;};if _gefb {for _bef =0;_bef < _aabd ;_bef ++{for _acfd =0;_acfd < _edda ;_acfd ++{_bgbd .Data [_aace +_acfd ]=0xff;
};_aace +=_bgbd .BytesPerLine ;};};if _ccag {for _bef =0;_bef < _aabd ;_bef ++{_bgbd .Data [_ccafa ]=_eaadc (_bgbd .Data [_ccafa ],0xff,_adae );_ccafa +=_bgbd .BytesPerLine ;};};case PixNotDst :for _bef =0;_bef < _aabd ;_bef ++{_bgbd .Data [_fbcc ]=_eaadc (_bgbd .Data [_fbcc ],^_bgbd .Data [_fbcc ],_efb );
_fbcc +=_bgbd .BytesPerLine ;};if _gefb {for _bef =0;_bef < _aabd ;_bef ++{for _acfd =0;_acfd < _edda ;_acfd ++{_bgbd .Data [_aace +_acfd ]=^(_bgbd .Data [_aace +_acfd ]);};_aace +=_bgbd .BytesPerLine ;};};if _ccag {for _bef =0;_bef < _aabd ;_bef ++{_bgbd .Data [_ccafa ]=_eaadc (_bgbd .Data [_ccafa ],^_bgbd .Data [_ccafa ],_adae );
_ccafa +=_bgbd .BytesPerLine ;};};};};func (_adb *CMYK32 )Set (x ,y int ,c _c .Color ){_cbac :=4*(y *_adb .Width +x );if _cbac +3>=len (_adb .Data ){return ;};_gff :=_c .CMYKModel .Convert (c ).(_c .CMYK );_adb .Data [_cbac ]=_gff .C ;_adb .Data [_cbac +1]=_gff .M ;
_adb .Data [_cbac +2]=_gff .Y ;_adb .Data [_cbac +3]=_gff .K ;};func _bgg ()(_fed []byte ){_fed =make ([]byte ,256);for _cdb :=0;_cdb < 256;_cdb ++{_ccb :=byte (_cdb );_fed [_ccb ]=(_ccb &0x01)|((_ccb &0x04)>>1)|((_ccb &0x10)>>2)|((_ccb &0x40)>>3)|((_ccb &0x02)<<3)|((_ccb &0x08)<<2)|((_ccb &0x20)<<1)|(_ccb &0x80);
};return _fed ;};func (_dcg *ImageBase )HasAlpha ()bool {if _dcg .Alpha ==nil {return false ;};for _efef :=range _dcg .Alpha {if _dcg .Alpha [_efef ]!=0xff{return true ;};};return false ;};func (_eafg *NRGBA64 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA64 (x ,y ,_eafg .Width ,_eafg .Data ,_eafg .Alpha ,_eafg .Decode );
};func (_gbce *NRGBA64 )At (x ,y int )_c .Color {_geac ,_ :=_gbce .ColorAt (x ,y );return _geac };func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gddg (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func IsGrayImgBlackAndWhite (i *_e .Gray )bool {return _befba (i )};var _ Image =&CMYK32 {};func (_bcbd *Monochrome )setIndexedBit (_dfe int ){_bcbd .Data [(_dfe >>3)]|=0x80>>uint (_dfe &7)};func _eged (_gfdf _e .Image ,_dbbbf uint8 )*_e .Gray {_ebbd :=_gfdf .Bounds ();
_ecee :=_e .NewGray (_ebbd );var (_bag _c .Color ;_bcbeg _c .Gray ;);for _edbe :=0;_edbe < _ebbd .Max .X ;_edbe ++{for _dcdf :=0;_dcdf < _ebbd .Max .Y ;_dcdf ++{_bag =_gfdf .At (_edbe ,_dcdf );_ecee .Set (_edbe ,_dcdf ,_bag );_bcbeg =_ecee .GrayAt (_edbe ,_dcdf );
_ecee .SetGray (_edbe ,_dcdf ,_c .Gray {Y :_gcda (_bcbeg .Y ,_dbbbf )});};};return _ecee ;};func (_bcd *NRGBA64 )Validate ()error {if len (_bcd .Data )!=3*2*_bcd .Width *_bcd .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_aebd *Gray8 )At (x ,y int )_c .Color {_bfb ,_ :=_aebd .ColorAt (x ,y );return _bfb };func _aeab (_ecb int ,_afdf int )int {if _ecb < _afdf {return _ecb ;};return _afdf ;};type ColorConverter interface{Convert (_cfa _e .Image )(Image ,error );
};func (_gagcg *ImageBase )getByte (_adce int )(byte ,error ){if _adce > len (_gagcg .Data )-1||_adce < 0{return 0,_f .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_adce );
};return _gagcg .Data [_adce ],nil ;};func _fgffb (_bfgb CMYK ,_agfe NRGBA ,_dbgb _e .Rectangle ){for _bbab :=0;_bbab < _dbgb .Max .X ;_bbab ++{for _cfgb :=0;_cfgb < _dbgb .Max .Y ;_cfgb ++{_fdcdd :=_bfgb .CMYKAt (_bbab ,_cfgb );_agfe .SetNRGBA (_bbab ,_cfgb ,_fdce (_fdcdd ));
};};};func (_aee *Gray4 )Set (x ,y int ,c _c .Color ){if x >=_aee .Width ||y >=_aee .Height {return ;};_fggg :=Gray4Model .Convert (c ).(_c .Gray );_aee .setGray (x ,y ,_fggg );};func (_beca *NRGBA64 )ColorModel ()_c .Model {return _c .NRGBA64Model };func _bcca (_cgaf RGBA ,_ffgfd Gray ,_cgdf _e .Rectangle ){for _aefac :=0;
_aefac < _cgdf .Max .X ;_aefac ++{for _aaf :=0;_aaf < _cgdf .Max .Y ;_aaf ++{_bdga :=_cbb (_cgaf .RGBAAt (_aefac ,_aaf ));_ffgfd .SetGray (_aefac ,_aaf ,_bdga );};};};func (_edc *Monochrome )Histogram ()(_ggea [256]int ){for _ ,_fagbd :=range _edc .Data {_ggea [0xff]+=int (_cea [_edc .Data [_fagbd ]]);
};return _ggea ;};func _cebb (_ceeg RGBA ,_cdbb CMYK ,_gdg _e .Rectangle ){for _caba :=0;_caba < _gdg .Max .X ;_caba ++{for _bea :=0;_bea < _gdg .Max .Y ;_bea ++{_fecg :=_ceeg .RGBAAt (_caba ,_bea );_cdbb .SetCMYK (_caba ,_bea ,_egbd (_fecg ));};};};func (_fcece *Gray8 )Base ()*ImageBase {return &_fcece .ImageBase };
func _fdf (_caaf _c .NRGBA64 )_c .Gray {var _adgb _c .NRGBA64 ;if _caaf ==_adgb {return _c .Gray {Y :0xff};};_aefc ,_dce ,_caed ,_ :=_caaf .RGBA ();_fdef :=(19595*_aefc +38470*_dce +7471*_caed +1<<15)>>24;return _c .Gray {Y :uint8 (_fdef )};};func _cgdg (_fcac *_e .Gray ,_cbgfd uint8 )*_e .Gray {_dfdfg :=_fcac .Bounds ();
_fdcae :=_e .NewGray (_dfdfg );for _abbf :=0;_abbf < _dfdfg .Dx ();_abbf ++{for _gdbb :=0;_gdbb < _dfdfg .Dy ();_gdbb ++{_dabag :=_fcac .GrayAt (_abbf ,_gdbb );_fdcae .SetGray (_abbf ,_gdbb ,_c .Gray {Y :_gcda (_dabag .Y ,_cbgfd )});};};return _fdcae ;
};func (_deec *Gray16 )At (x ,y int )_c .Color {_gcdc ,_ :=_deec .ColorAt (x ,y );return _gcdc };func _gfcb (_aage Gray ,_cafd RGBA ,_eeaef _e .Rectangle ){for _cgda :=0;_cgda < _eeaef .Max .X ;_cgda ++{for _egfcc :=0;_egfcc < _eeaef .Max .Y ;_egfcc ++{_gcfa :=_aage .GrayAt (_cgda ,_egfcc );
_cafd .SetRGBA (_cgda ,_egfcc ,_dffc (_gcfa ));};};};func _fcgfa (_dbab _e .Image ,_fede int )(_e .Rectangle ,bool ,[]byte ){_afea :=_dbab .Bounds ();var (_cdbdc bool ;_ddcf []byte ;);switch _fecb :=_dbab .(type ){case SMasker :_cdbdc =_fecb .HasAlpha ();
case NRGBA ,RGBA ,*_e .RGBA64 ,nrgba64 ,*_e .NYCbCrA :_ddcf =make ([]byte ,_afea .Max .X *_afea .Max .Y *_fede );case *_e .Paletted :var _gdga bool ;for _ ,_gdfa :=range _fecb .Palette {_edad ,_fcbb ,_eddba ,_ffff :=_gdfa .RGBA ();if _edad ==0&&_fcbb ==0&&_eddba ==0&&_ffff !=0{_gdga =true ;
break ;};};if _gdga {_ddcf =make ([]byte ,_afea .Max .X *_afea .Max .Y *_fede );};};return _afea ,_cdbdc ,_ddcf ;};type NRGBA16 struct{ImageBase };