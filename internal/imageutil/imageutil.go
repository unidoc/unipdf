//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_ed "encoding/binary";_d "errors";_dd "fmt";_fa "github.com/unidoc/unipdf/v4/common";_fe "github.com/unidoc/unipdf/v4/internal/bitwise";_g "image";_f "image/color";_e "image/draw";_db "math";);var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_bbacb *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_bbacb .copy ()}};func _eaf (_gc ,_ge *Monochrome )(_eebd error ){_bbg :=_ge .BytesPerLine ;_cad :=_gc .BytesPerLine ;var _cae ,_dde ,_ffd ,_ega ,_gcc int ;for _ffd =0;_ffd < _ge .Height ;
_ffd ++{_cae =_ffd *_bbg ;_dde =8*_ffd *_cad ;for _ega =0;_ega < _bbg ;_ega ++{if _eebd =_gc .setEightBytes (_dde +_ega *8,_gdb [_ge .Data [_cae +_ega ]]);_eebd !=nil {return _eebd ;};};for _gcc =1;_gcc < 8;_gcc ++{for _ega =0;_ega < _cad ;_ega ++{if _eebd =_gc .setByte (_dde +_gcc *_cad +_ega ,_gc .Data [_dde +_ega ]);
_eebd !=nil {return _eebd ;};};};};return nil ;};func (_ggcd *Gray4 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_ggcd .Width ,Y :_ggcd .Height }};};func (_afaac *NRGBA32 )ColorModel ()_f .Model {return _f .NRGBAModel };var _fcge [256]uint8 ;
func (_bda *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _ebdd bool ;_cfb :=scale ;if scale < 1{_cfb =1/scale ;_ebdd =true ;};_cbaf :=NextPowerOf2 (uint (_cfb ));if InDelta (float64 (_cbaf ),_cfb ,0.001){if _ebdd {return _bda .ReduceBinary (_cfb );
};return _bda .ExpandBinary (int (_cbaf ));};_gcfe :=int (_db .RoundToEven (float64 (_bda .Width )*scale ));_cbf :=int (_db .RoundToEven (float64 (_bda .Height )*scale ));return _bda .ScaleLow (_gcfe ,_cbf );};type NRGBA interface{NRGBAAt (_gdfca ,_dcab int )_f .NRGBA ;
SetNRGBA (_ceef ,_ffdg int ,_aeab _f .NRGBA );};func _dagb (_dfdd *Monochrome ,_fffg ,_beecc ,_dcce ,_gdaa int ,_bfbf RasterOperator ,_adgg *Monochrome ,_egd ,_gbcbf int )error {var (_ddbgd bool ;_dffb bool ;_fdff byte ;_daecf int ;_ecd int ;_dfec int ;
_dddf int ;_bbad bool ;_dcbc int ;_cbeg int ;_ggbg int ;_eceb bool ;_feeb byte ;_dbaa int ;_bae int ;_afda int ;_eadc byte ;_ebf int ;_afbe int ;_abed uint ;_dgff uint ;_eeec byte ;_adbd shift ;_bgbb bool ;_efgfd bool ;_bbfe ,_cceac int ;);if _egd &7!=0{_afbe =8-(_egd &7);
};if _fffg &7!=0{_ecd =8-(_fffg &7);};if _afbe ==0&&_ecd ==0{_eeec =_aabf [0];}else {if _ecd > _afbe {_abed =uint (_ecd -_afbe );}else {_abed =uint (8-(_afbe -_ecd ));};_dgff =8-_abed ;_eeec =_aabf [_abed ];};if (_fffg &7)!=0{_ddbgd =true ;_daecf =8-(_fffg &7);
_fdff =_aabf [_daecf ];_dfec =_dfdd .BytesPerLine *_beecc +(_fffg >>3);_dddf =_adgg .BytesPerLine *_gbcbf +(_egd >>3);_ebf =8-(_egd &7);if _daecf > _ebf {_adbd =_ageee ;if _dcce >=_afbe {_bgbb =true ;};}else {_adbd =_feeg ;};};if _dcce < _daecf {_dffb =true ;
_fdff &=_aggg [8-_daecf +_dcce ];};if !_dffb {_dcbc =(_dcce -_daecf )>>3;if _dcbc !=0{_bbad =true ;_cbeg =_dfdd .BytesPerLine *_beecc +((_fffg +_ecd )>>3);_ggbg =_adgg .BytesPerLine *_gbcbf +((_egd +_ecd )>>3);};};_dbaa =(_fffg +_dcce )&7;if !(_dffb ||_dbaa ==0){_eceb =true ;
_feeb =_aggg [_dbaa ];_bae =_dfdd .BytesPerLine *_beecc +((_fffg +_ecd )>>3)+_dcbc ;_afda =_adgg .BytesPerLine *_gbcbf +((_egd +_ecd )>>3)+_dcbc ;if _dbaa > int (_dgff ){_efgfd =true ;};};switch _bfbf {case PixSrc :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;
_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],_eadc ,_fdff );_dfec +=_dfdd .BytesPerLine ;
_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]=_eadc ;
};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],_eadc ,_feeb );
_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;};};case PixNotSrc :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );};
}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],^_eadc ,_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );
_dfdd .Data [_cbeg +_cceac ]=^_eadc ;};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );
};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],^_eadc ,_feeb );_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;};};case PixSrcOrDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );
};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],_eadc |_dfdd .Data [_dfec ],_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;
_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]|=_eadc ;};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;
_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],_eadc |_dfdd .Data [_bae ],_feeb );_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;
};};case PixSrcAndDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],_eadc &_dfdd .Data [_dfec ],_fdff );
_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]&=_eadc ;
};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],_eadc &_dfdd .Data [_bae ],_feeb );
_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;};};case PixSrcXorDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );
};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],_eadc ^_dfdd .Data [_dfec ],_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;
_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]^=_eadc ;};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;
_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],_eadc ^_dfdd .Data [_bae ],_feeb );_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;
};};case PixNotSrcOrDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],^_eadc |_dfdd .Data [_dfec ],_fdff );
_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]|=^_eadc ;
};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],^_eadc |_dfdd .Data [_bae ],_feeb );
_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;};};case PixNotSrcAndDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );
};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],^_eadc &_dfdd .Data [_dfec ],_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;
_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]&=^_eadc ;};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;
_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],^_eadc &_dfdd .Data [_bae ],_feeb );_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;
};};case PixSrcOrNotDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],_eadc |^_dfdd .Data [_dfec ],_fdff );
_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]=_eadc |^_dfdd .Data [_cbeg +_cceac ];
};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],_eadc |^_dfdd .Data [_bae ],_feeb );
_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;};};case PixSrcAndNotDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );
};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],_eadc &^_dfdd .Data [_dfec ],_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;
_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]=_eadc &^_dfdd .Data [_cbeg +_cceac ];};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};
};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],_eadc &^_dfdd .Data [_bae ],_feeb );_bae +=_dfdd .BytesPerLine ;
_afda +=_adgg .BytesPerLine ;};};case PixNotPixSrcOrDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;
};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],^(_eadc |_dfdd .Data [_dfec ]),_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );
_dfdd .Data [_cbeg +_cceac ]=^(_eadc |_dfdd .Data [_cbeg +_cceac ]);};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );
};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],^(_eadc |_dfdd .Data [_bae ]),_feeb );_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;};};case PixNotPixSrcAndDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;
if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],^(_eadc &_dfdd .Data [_dfec ]),_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;
};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]=^(_eadc &_dfdd .Data [_cbeg +_cceac ]);
};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],^(_eadc &_dfdd .Data [_bae ]),_feeb );
_bae +=_dfdd .BytesPerLine ;_afda +=_adgg .BytesPerLine ;};};case PixNotPixSrcXorDst :if _ddbgd {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{if _adbd ==_ageee {_eadc =_adgg .Data [_dddf ]<<_abed ;if _bgbb {_eadc =_fddd (_eadc ,_adgg .Data [_dddf +1]>>_dgff ,_eeec );
};}else {_eadc =_adgg .Data [_dddf ]>>_dgff ;};_dfdd .Data [_dfec ]=_fddd (_dfdd .Data [_dfec ],^(_eadc ^_dfdd .Data [_dfec ]),_fdff );_dfec +=_dfdd .BytesPerLine ;_dddf +=_adgg .BytesPerLine ;};};if _bbad {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{for _cceac =0;
_cceac < _dcbc ;_cceac ++{_eadc =_fddd (_adgg .Data [_ggbg +_cceac ]<<_abed ,_adgg .Data [_ggbg +_cceac +1]>>_dgff ,_eeec );_dfdd .Data [_cbeg +_cceac ]=^(_eadc ^_dfdd .Data [_cbeg +_cceac ]);};_cbeg +=_dfdd .BytesPerLine ;_ggbg +=_adgg .BytesPerLine ;
};};if _eceb {for _bbfe =0;_bbfe < _gdaa ;_bbfe ++{_eadc =_adgg .Data [_afda ]<<_abed ;if _efgfd {_eadc =_fddd (_eadc ,_adgg .Data [_afda +1]>>_dgff ,_eeec );};_dfdd .Data [_bae ]=_fddd (_dfdd .Data [_bae ],^(_eadc ^_dfdd .Data [_bae ]),_feeb );_bae +=_dfdd .BytesPerLine ;
_afda +=_adgg .BytesPerLine ;};};default:_fa .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_bfbf );return _d .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");
};return nil ;};func _cced (_aabg _f .NRGBA )_f .NRGBA {_aabg .R =_aabg .R >>4|(_aabg .R >>4)<<4;_aabg .G =_aabg .G >>4|(_aabg .G >>4)<<4;_aabg .B =_aabg .B >>4|(_aabg .B >>4)<<4;return _aabg ;};func (_dbaf *ImageBase )GetAlpha ()[]byte {return _dbaf .Alpha };
func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_dd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_eced *RGBA32 )SetRGBA (x ,y int ,c _f .RGBA ){_fabg :=y *_eced .Width +x ;_dgda :=3*_fabg ;if _dgda +2>=len (_eced .Data ){return ;};_eced .setRGBA (_fabg ,c );};func _gggg (_bega _f .CMYK )_f .NRGBA {_bgea ,_ccbe ,_cgda :=_f .CMYKToRGB (_bega .C ,_bega .M ,_bega .Y ,_bega .K );
return _f .NRGBA {R :_bgea ,G :_ccbe ,B :_cgda ,A :0xff};};func _gbf (_gbe *Monochrome ,_eef ,_gbg int )(*Monochrome ,error ){if _gbe ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _eef <=0||_gbg <=0{return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _eef ==_gbg {if _eef ==1{return _gbe .copy (),nil ;};
if _eef ==2||_eef ==4||_eef ==8{_gbd ,_beg :=_eb (_gbe ,_eef );if _beg !=nil {return nil ,_beg ;};return _gbd ,nil ;};};_bf :=_eef *_gbe .Width ;_dee :=_gbg *_gbe .Height ;_ddg :=_dbeb (_bf ,_dee );_ddc :=_ddg .BytesPerLine ;var (_dbb ,_agd ,_ece ,_deab ,_afac int ;
_bge byte ;_bfg error ;);for _agd =0;_agd < _gbe .Height ;_agd ++{_dbb =_gbg *_agd *_ddc ;for _ece =0;_ece < _gbe .Width ;_ece ++{if _efa :=_gbe .getBitAt (_ece ,_agd );_efa {_afac =_eef *_ece ;for _deab =0;_deab < _eef ;_deab ++{_ddg .setIndexedBit (_dbb *8+_afac +_deab );
};};};for _deab =1;_deab < _gbg ;_deab ++{_bba :=_dbb +_deab *_ddc ;for _bfd :=0;_bfd < _ddc ;_bfd ++{if _bge ,_bfg =_ddg .getByte (_dbb +_bfd );_bfg !=nil {return nil ,_bfg ;};if _bfg =_ddg .setByte (_bba +_bfd ,_bge );_bfg !=nil {return nil ,_bfg ;};
};};};return _ddg ,nil ;};func (_geb *ImageBase )Pix ()[]byte {return _geb .Data };func _acegf (_bafg _g .Image )(Image ,error ){if _ffeb ,_afga :=_bafg .(*NRGBA16 );_afga {return _ffeb .Copy (),nil ;};_ddceb :=_bafg .Bounds ();_fccc ,_ddab :=NewImage (_ddceb .Max .X ,_ddceb .Max .Y ,4,3,nil ,nil ,nil );
if _ddab !=nil {return nil ,_ddab ;};_bgac (_bafg ,_fccc ,_ddceb );return _fccc ,nil ;};var _ Image =&RGBA32 {};func (_eagcf *Gray4 )ColorModel ()_f .Model {return Gray4Model };func _eacg (_cbcb []byte ,_bgee Image )error {_ggfd :=true ;for _ggde :=0;_ggde < len (_cbcb );
_ggde ++{if _cbcb [_ggde ]!=0xff{_ggfd =false ;break ;};};if _ggfd {switch _afdf :=_bgee .(type ){case *NRGBA32 :_afdf .Alpha =nil ;case *NRGBA64 :_afdf .Alpha =nil ;default:return _dd .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_bgee );
};};return nil ;};func (_gacc *NRGBA32 )At (x ,y int )_f .Color {_deac ,_ :=_gacc .ColorAt (x ,y );return _deac };var _ Gray =&Monochrome {};func _dddfc (_ggcb *_g .NYCbCrA ,_fade NRGBA ,_gbcc _g .Rectangle ){for _bdgb :=0;_bdgb < _gbcc .Max .X ;_bdgb ++{for _bdad :=0;
_bdad < _gbcc .Max .Y ;_bdad ++{_deace :=_ggcb .NYCbCrAAt (_bdgb ,_bdad );_fade .SetNRGBA (_bdgb ,_bdad ,_edd (_deace ));};};};func (_deeg *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_deeg .copy ()}};func _cebb (_dfge *Monochrome ,_adg ,_cagb ,_dddg ,_eagb int ,_dag RasterOperator ,_cgfa *Monochrome ,_adafb ,_cbfb int )error {if _dfge ==nil {return _d .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _dag ==PixDst {return nil ;};switch _dag {case PixClr ,PixSet ,PixNotDst :_bfce (_dfge ,_adg ,_cagb ,_dddg ,_eagb ,_dag );return nil ;};if _cgfa ==nil {_fa .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _d .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _fcbg :=_cgef (_dfge ,_adg ,_cagb ,_dddg ,_eagb ,_dag ,_cgfa ,_adafb ,_cbfb );_fcbg !=nil {return _fcbg ;};return nil ;};func (_fgdd *RGBA32 )setRGBA (_bdeg int ,_dcfe _f .RGBA ){_geed :=3*_bdeg ;
_fgdd .Data [_geed ]=_dcfe .R ;_fgdd .Data [_geed +1]=_dcfe .G ;_fgdd .Data [_geed +2]=_dcfe .B ;if _bdeg < len (_fgdd .Alpha ){_fgdd .Alpha [_bdeg ]=_dcfe .A ;};};func (_bcgc *Monochrome )InverseData ()error {return _bcgc .RasterOperation (0,0,_bcgc .Width ,_bcgc .Height ,PixNotDst ,nil ,0,0);
};func (_aaged *Gray8 )Base ()*ImageBase {return &_aaged .ImageBase };func ImgToBinary (i _g .Image ,threshold uint8 )*_g .Gray {switch _baff :=i .(type ){case *_g .Gray :if _baaf (_baff ){return _baff ;};return _acca (_baff ,threshold );case *_g .Gray16 :return _ggfab (_baff ,threshold );
default:return _gfgd (_baff ,threshold );};};func _cace (_ddd _f .RGBA )_f .Gray {_dgeb :=(19595*uint32 (_ddd .R )+38470*uint32 (_ddd .G )+7471*uint32 (_ddd .B )+1<<7)>>16;return _f .Gray {Y :uint8 (_dgeb )};};var _ _g .Image =&Monochrome {};func _gca (_fdgb Gray ,_cbad NRGBA ,_gdg _g .Rectangle ){for _fabc :=0;
_fabc < _gdg .Max .X ;_fabc ++{for _edc :=0;_edc < _gdg .Max .Y ;_edc ++{_gbgc :=_gad (_cbad .NRGBAAt (_fabc ,_edc ));_fdgb .SetGray (_fabc ,_edc ,_gbgc );};};};func _gdd ()(_gf [256]uint64 ){for _dgb :=0;_dgb < 256;_dgb ++{if _dgb &0x01!=0{_gf [_dgb ]|=0xff;
};if _dgb &0x02!=0{_gf [_dgb ]|=0xff00;};if _dgb &0x04!=0{_gf [_dgb ]|=0xff0000;};if _dgb &0x08!=0{_gf [_dgb ]|=0xff000000;};if _dgb &0x10!=0{_gf [_dgb ]|=0xff00000000;};if _dgb &0x20!=0{_gf [_dgb ]|=0xff0000000000;};if _dgb &0x40!=0{_gf [_dgb ]|=0xff000000000000;
};if _dgb &0x80!=0{_gf [_dgb ]|=0xff00000000000000;};};return _gf ;};func _bcf (_cdee _g .Image )(Image ,error ){if _eagc ,_dfac :=_cdee .(*Monochrome );_dfac {return _eagc ,nil ;};_edef :=_cdee .Bounds ();var _gdc Gray ;switch _adc :=_cdee .(type ){case Gray :_gdc =_adc ;
case NRGBA :_gdc =&Gray8 {ImageBase :NewImageBase (_edef .Max .X ,_edef .Max .Y ,8,1,nil ,nil ,nil )};_gca (_gdc ,_adc ,_edef );case nrgba64 :_gdc =&Gray8 {ImageBase :NewImageBase (_edef .Max .X ,_edef .Max .Y ,8,1,nil ,nil ,nil )};_fbc (_gdc ,_adc ,_edef );
default:_cgdc ,_gaff :=GrayConverter .Convert (_cdee );if _gaff !=nil {return nil ,_gaff ;};_gdc =_cgdc .(Gray );};_dddc ,_feb :=NewImage (_edef .Max .X ,_edef .Max .Y ,1,1,nil ,nil ,nil );if _feb !=nil {return nil ,_feb ;};_ecbe :=_dddc .(*Monochrome );
_ffdc :=AutoThresholdTriangle (GrayHistogram (_gdc ));for _deea :=0;_deea < _edef .Max .X ;_deea ++{for _cec :=0;_cec < _edef .Max .Y ;_cec ++{_ggc :=_ggcg (_gdc .GrayAt (_deea ,_cec ),monochromeModel (_ffdc ));_ecbe .SetGray (_deea ,_cec ,_ggc );};};return _dddc ,nil ;
};func (_ddcc *Monochrome )Set (x ,y int ,c _f .Color ){_caeb :=y *_ddcc .BytesPerLine +x >>3;if _caeb > len (_ddcc .Data )-1{return ;};_fgb :=_ddcc .ColorModel ().Convert (c ).(_f .Gray );_ddcc .setGray (x ,_fgb ,_caeb );};var _ Image =&Gray4 {};func _fga (_bdbe _f .NYCbCrA )_f .RGBA {_fgc ,_fdbg ,_cadg ,_cdbb :=_edd (_bdbe ).RGBA ();
return _f .RGBA {R :uint8 (_fgc >>8),G :uint8 (_fdbg >>8),B :uint8 (_cadg >>8),A :uint8 (_cdbb >>8)};};func (_ddfeg *Gray2 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray2BPC (x ,y ,_ddfeg .BytesPerLine ,_ddfeg .Data ,_ddfeg .Decode );};func (_eadcb *NRGBA32 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_eadcb .Width ,Y :_eadcb .Height }};
};func (_fge *NRGBA16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA16 (x ,y ,_fge .Width ,_fge .BytesPerLine ,_fge .Data ,_fge .Alpha ,_fge .Decode );};func (_dbgb *Monochrome )ColorModel ()_f .Model {return MonochromeModel (_dbgb .ModelThreshold )};
func (_ddce *CMYK32 )Validate ()error {if len (_ddce .Data )!=4*_ddce .Width *_ddce .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_acc *ImageBase )setEightFullBytes (_aedb int ,_gfdab uint64 )error {if _aedb +7> len (_acc .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_acc .Data [_aedb ]=byte ((_gfdab &0xff00000000000000)>>56);
_acc .Data [_aedb +1]=byte ((_gfdab &0xff000000000000)>>48);_acc .Data [_aedb +2]=byte ((_gfdab &0xff0000000000)>>40);_acc .Data [_aedb +3]=byte ((_gfdab &0xff00000000)>>32);_acc .Data [_aedb +4]=byte ((_gfdab &0xff000000)>>24);_acc .Data [_aedb +5]=byte ((_gfdab &0xff0000)>>16);
_acc .Data [_aedb +6]=byte ((_gfdab &0xff00)>>8);_acc .Data [_aedb +7]=byte (_gfdab &0xff);return nil ;};const (_ageee shift =iota ;_feeg ;);type NRGBA64 struct{ImageBase };func _cadb (_aeae _f .NRGBA64 )_f .RGBA {_gged ,_ffdf ,_geec ,_aebfg :=_aeae .RGBA ();
return _f .RGBA {R :uint8 (_gged >>8),G :uint8 (_ffdf >>8),B :uint8 (_geec >>8),A :uint8 (_aebfg >>8)};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_cbfd :=y *bytesPerLine +x ;if _cbfd >=len (data ){return _f .Gray {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dfcff :=data [_cbfd ];if len (decode )==2{_dfcff =uint8 (uint32 (LinearInterpolate (float64 (_dfcff ),0,255,decode [0],decode [1]))&0xff);};return _f .Gray {Y :_dfcff },nil ;};func _gfca (_faegb ,_dfee uint8 )uint8 {if _faegb < _dfee {return 255;};return 0;
};func (_gfdg *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_gfdg .copy ()}};func _cgef (_bac *Monochrome ,_fef ,_bfcf int ,_adge ,_edac int ,_gccg RasterOperator ,_bgcg *Monochrome ,_dbae ,_cffc int )error {var _bggg ,_fagc ,_egcd ,_affa int ;if _fef < 0{_dbae -=_fef ;
_adge +=_fef ;_fef =0;};if _dbae < 0{_fef -=_dbae ;_adge +=_dbae ;_dbae =0;};_bggg =_fef +_adge -_bac .Width ;if _bggg > 0{_adge -=_bggg ;};_fagc =_dbae +_adge -_bgcg .Width ;if _fagc > 0{_adge -=_fagc ;};if _bfcf < 0{_cffc -=_bfcf ;_edac +=_bfcf ;_bfcf =0;
};if _cffc < 0{_bfcf -=_cffc ;_edac +=_cffc ;_cffc =0;};_egcd =_bfcf +_edac -_bac .Height ;if _egcd > 0{_edac -=_egcd ;};_affa =_cffc +_edac -_bgcg .Height ;if _affa > 0{_edac -=_affa ;};if _adge <=0||_edac <=0{return nil ;};var _fgae error ;switch {case _fef &7==0&&_dbae &7==0:_fgae =_dda (_bac ,_fef ,_bfcf ,_adge ,_edac ,_gccg ,_bgcg ,_dbae ,_cffc );
case _fef &7==_dbae &7:_fgae =_eaa (_bac ,_fef ,_bfcf ,_adge ,_edac ,_gccg ,_bgcg ,_dbae ,_cffc );default:_fgae =_dagb (_bac ,_fef ,_bfcf ,_adge ,_edac ,_gccg ,_bgcg ,_dbae ,_cffc );};if _fgae !=nil {return _fgae ;};return nil ;};func (_edec *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_edec .copy ()}};
type Gray interface{GrayAt (_acfg ,_fgac int )_f .Gray ;SetGray (_ffgd ,_dec int ,_gdba _f .Gray );};func (_dgec *Monochrome )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_dgec .Width ,Y :_dgec .Height }};};func (_agbe *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_agbe .copy ()}};
func (_bbdg *Gray4 )SetGray (x ,y int ,g _f .Gray ){if x >=_bbdg .Width ||y >=_bbdg .Height {return ;};g =_afff (g );_bbdg .setGray (x ,y ,g );};func _eecc (_gcccc _f .NRGBA64 )_f .NRGBA {return _f .NRGBA {R :uint8 (_gcccc .R >>8),G :uint8 (_gcccc .G >>8),B :uint8 (_gcccc .B >>8),A :uint8 (_gcccc .A >>8)};
};func _aae (_bbf _f .CMYK )_f .RGBA {_cfdb ,_bbga ,_fab :=_f .CMYKToRGB (_bbf .C ,_bbf .M ,_bbf .Y ,_bbf .K );return _f .RGBA {R :_cfdb ,G :_bbga ,B :_fab ,A :0xff};};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_dd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _db .Abs (xmax -xmin )< 0.000001{return ymin ;};_cceb :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _cceb ;};func _dbg (_bef ,_gaf *Monochrome ,_acf []byte ,_aca int )(_gcb error ){var (_ddcf ,_bcg ,_fdf ,_feg ,_fdfb ,_agb ,_efb ,_ad int ;
_dff ,_dbbc uint32 ;_eecd ,_dfa byte ;_abf uint16 ;);_ced :=make ([]byte ,4);_cdd :=make ([]byte ,4);for _fdf =0;_fdf < _bef .Height -1;_fdf ,_feg =_fdf +2,_feg +1{_ddcf =_fdf *_bef .BytesPerLine ;_bcg =_feg *_gaf .BytesPerLine ;for _fdfb ,_agb =0,0;_fdfb < _aca ;
_fdfb ,_agb =_fdfb +4,_agb +1{for _efb =0;_efb < 4;_efb ++{_ad =_ddcf +_fdfb +_efb ;if _ad <=len (_bef .Data )-1&&_ad < _ddcf +_bef .BytesPerLine {_ced [_efb ]=_bef .Data [_ad ];}else {_ced [_efb ]=0x00;};_ad =_ddcf +_bef .BytesPerLine +_fdfb +_efb ;if _ad <=len (_bef .Data )-1&&_ad < _ddcf +(2*_bef .BytesPerLine ){_cdd [_efb ]=_bef .Data [_ad ];
}else {_cdd [_efb ]=0x00;};};_dff =_ed .BigEndian .Uint32 (_ced );_dbbc =_ed .BigEndian .Uint32 (_cdd );_dbbc |=_dff ;_dbbc |=_dbbc <<1;_dbbc &=0xaaaaaaaa;_dff =_dbbc |(_dbbc <<7);_eecd =byte (_dff >>24);_dfa =byte ((_dff >>8)&0xff);_ad =_bcg +_agb ;if _ad +1==len (_gaf .Data )-1||_ad +1>=_bcg +_gaf .BytesPerLine {_gaf .Data [_ad ]=_acf [_eecd ];
}else {_abf =(uint16 (_acf [_eecd ])<<8)|uint16 (_acf [_dfa ]);if _gcb =_gaf .setTwoBytes (_ad ,_abf );_gcb !=nil {return _dd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ad );
};_agb ++;};};};return nil ;};func (_edbf *NRGBA64 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA64 (x ,y ,_edbf .Width ,_edbf .Data ,_edbf .Alpha ,_edbf .Decode );};func (_fcb *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_d .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_dcd :=_dbeb (width ,height );_bege :=make ([]int ,height );_gbead :=make ([]int ,width );_afge :=float64 (_fcb .Width )/float64 (width );_egae :=float64 (_fcb .Height )/float64 (height );for _afacg :=0;_afacg < height ;_afacg ++{_bege [_afacg ]=int (_db .Min (_egae *float64 (_afacg )+0.5,float64 (_fcb .Height -1)));
};for _cfaa :=0;_cfaa < width ;_cfaa ++{_gbead [_cfaa ]=int (_db .Min (_afge *float64 (_cfaa )+0.5,float64 (_fcb .Width -1)));};_fcff :=-1;_afca :=byte (0);for _bcbd :=0;_bcbd < height ;_bcbd ++{_adcg :=_bege [_bcbd ]*_fcb .BytesPerLine ;_cgb :=_bcbd *_dcd .BytesPerLine ;
for _eebg :=0;_eebg < width ;_eebg ++{_ggf :=_gbead [_eebg ];if _ggf !=_fcff {_afca =_fcb .getBit (_adcg ,_ggf );if _afca !=0{_dcd .setBit (_cgb ,_eebg );};_fcff =_ggf ;}else {if _afca !=0{_dcd .setBit (_cgb ,_eebg );};};};};return _dcd ,nil ;};const (PixSrc RasterOperator =0xc;
PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;
PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;
PixMask =PixSrcAndDst ;);func _ebg (_ddf ,_cde *Monochrome )(_eea error ){_dea :=_cde .BytesPerLine ;_fed :=_ddf .BytesPerLine ;_cf :=_cde .BytesPerLine *4-_ddf .BytesPerLine ;var (_afd ,_fc byte ;_gd uint32 ;_fb ,_ca ,_bea ,_ec ,_eeb ,_dbe ,_afag int ;
);for _bea =0;_bea < _cde .Height ;_bea ++{_fb =_bea *_dea ;_ca =4*_bea *_fed ;for _ec =0;_ec < _dea ;_ec ++{_afd =_cde .Data [_fb +_ec ];_gd =_dgg [_afd ];_dbe =_ca +_ec *4;if _cf !=0&&(_ec +1)*4> _ddf .BytesPerLine {for _eeb =_cf ;_eeb > 0;_eeb --{_fc =byte ((_gd >>uint (_eeb *8))&0xff);
_afag =_dbe +(_cf -_eeb );if _eea =_ddf .setByte (_afag ,_fc );_eea !=nil {return _eea ;};};}else if _eea =_ddf .setFourBytes (_dbe ,_gd );_eea !=nil {return _eea ;};if _eea =_ddf .setFourBytes (_ca +_ec *4,_dgg [_cde .Data [_fb +_ec ]]);_eea !=nil {return _eea ;
};};for _eeb =1;_eeb < 4;_eeb ++{for _ec =0;_ec < _fed ;_ec ++{if _eea =_ddf .setByte (_ca +_eeb *_fed +_ec ,_ddf .Data [_ca +_ec ]);_eea !=nil {return _eea ;};};};};return nil ;};func (_cecb *Monochrome )Base ()*ImageBase {return &_cecb .ImageBase };func (_gfe *Monochrome )setGray (_bggb int ,_geeg _f .Gray ,_deeaf int ){if _geeg .Y ==0{_gfe .clearBit (_deeaf ,_bggb );
}else {_gfe .setGrayBit (_deeaf ,_bggb );};};func _eb (_ae *Monochrome ,_dg int )(*Monochrome ,error ){if _ae ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _dg ==1{return _ae .copy (),nil ;
};if !IsPowerOf2 (uint (_dg )){return nil ,_dd .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dg );};_c :=_cdb (_dg );
return _cd (_ae ,_dg ,_c );};type Gray4 struct{ImageBase };func (_faddb *RGBA32 )ColorModel ()_f .Model {return _f .NRGBAModel };func init (){_cfca ()};func _bfdc (_ead _f .RGBA )_f .CMYK {_afg ,_gada ,_ffgea ,_ceg :=_f .RGBToCMYK (_ead .R ,_ead .G ,_ead .B );
return _f .CMYK {C :_afg ,M :_gada ,Y :_ffgea ,K :_ceg };};func (_agge *RGBA32 )Base ()*ImageBase {return &_agge .ImageBase };type NRGBA16 struct{ImageBase };func (_cbae *RGBA32 )At (x ,y int )_f .Color {_ffebf ,_ :=_cbae .ColorAt (x ,y );return _ffebf };
var _ Gray =&Gray8 {};func (_ddgb *Gray4 )Base ()*ImageBase {return &_ddgb .ImageBase };func AutoThresholdTriangle (histogram [256]int )uint8 {var _bbbdg ,_beeec ,_ccc ,_fffb int ;for _aaff :=0;_aaff < len (histogram );_aaff ++{if histogram [_aaff ]> 0{_bbbdg =_aaff ;
break ;};};if _bbbdg > 0{_bbbdg --;};for _efaba :=255;_efaba > 0;_efaba --{if histogram [_efaba ]> 0{_fffb =_efaba ;break ;};};if _fffb < 255{_fffb ++;};for _ebde :=0;_ebde < 256;_ebde ++{if histogram [_ebde ]> _beeec {_ccc =_ebde ;_beeec =histogram [_ebde ];
};};var _cbea bool ;if (_ccc -_bbbdg )< (_fffb -_ccc ){_cbea =true ;var _dadg int ;_eadca :=255;for _dadg < _eadca {_faegg :=histogram [_dadg ];histogram [_dadg ]=histogram [_eadca ];histogram [_eadca ]=_faegg ;_dadg ++;_eadca --;};_bbbdg =255-_fffb ;_ccc =255-_ccc ;
};if _bbbdg ==_ccc {return uint8 (_bbbdg );};_ceda :=float64 (histogram [_ccc ]);_dgbb :=float64 (_bbbdg -_ccc );_cda :=_db .Sqrt (_ceda *_ceda +_dgbb *_dgbb );_ceda /=_cda ;_dgbb /=_cda ;_cda =_ceda *float64 (_bbbdg )+_dgbb *float64 (histogram [_bbbdg ]);
_fdbge :=_bbbdg ;var _abab float64 ;for _fgefg :=_bbbdg +1;_fgefg <=_ccc ;_fgefg ++{_bdbf :=_ceda *float64 (_fgefg )+_dgbb *float64 (histogram [_fgefg ])-_cda ;if _bdbf > _abab {_fdbge =_fgefg ;_abab =_bdbf ;};};_fdbge --;if _cbea {var _fecef int ;_fdaad :=255;
for _fecef < _fdaad {_fddc :=histogram [_fecef ];histogram [_fecef ]=histogram [_fdaad ];histogram [_fdaad ]=_fddc ;_fecef ++;_fdaad --;};return uint8 (255-_fdbge );};return uint8 (_fdbge );};func _gefg ()(_bdb []byte ){_bdb =make ([]byte ,256);for _cgg :=0;
_cgg < 256;_cgg ++{_bed :=byte (_cgg );_bdb [_bed ]=(_bed &0x01)|((_bed &0x04)>>1)|((_bed &0x10)>>2)|((_bed &0x40)>>3)|((_bed &0x02)<<3)|((_bed &0x08)<<2)|((_bed &0x20)<<1)|(_bed &0x80);};return _bdb ;};func (_ddge *ImageBase )setByte (_eab int ,_daab byte )error {if _eab > len (_ddge .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ddge .Data [_eab ]=_daab ;return nil ;};func (_dgaa *Gray8 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_dgaa .Width ,Y :_dgaa .Height }};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_afccb :=y *bytesPerLine +x >>3;
if _afccb >=len (data ){return _f .Gray {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_acfa :=data [_afccb ]>>uint (7-(x &7))&1;if len (decode )==2{_acfa =uint8 (LinearInterpolate (float64 (_acfa ),0.0,1.0,decode [0],decode [1]))&1;};return _f .Gray {Y :_acfa *255},nil ;};func (_gfc *NRGBA16 )Set (x ,y int ,c _f .Color ){_bfecc :=y *_gfc .BytesPerLine +x *3/2;
if _bfecc +1>=len (_gfc .Data ){return ;};_dcag :=NRGBA16Model .Convert (c ).(_f .NRGBA );_gfc .setNRGBA (x ,y ,_bfecc ,_dcag );};func _dgfb (_faf _g .Image )(Image ,error ){if _eeccb ,_ggfe :=_faf .(*Gray2 );_ggfe {return _eeccb .Copy (),nil ;};_cddd :=_faf .Bounds ();
_fagaf ,_bbd :=NewImage (_cddd .Max .X ,_cddd .Max .Y ,2,1,nil ,nil ,nil );if _bbd !=nil {return nil ,_bbd ;};_bcgb (_faf ,_fagaf ,_cddd );return _fagaf ,nil ;};func (_ccbb *Gray2 )Set (x ,y int ,c _f .Color ){if x >=_ccbb .Width ||y >=_ccbb .Height {return ;
};_gcfg :=Gray2Model .Convert (c ).(_f .Gray );_cbfe :=y *_ccbb .BytesPerLine ;_egfa :=_cbfe +(x >>2);_bfgb :=_gcfg .Y >>6;_ccbb .Data [_egfa ]=(_ccbb .Data [_egfa ]&(^(0xc0>>uint (2*((x )&3)))))|(_bfgb <<uint (6-2*(x &3)));};func (_eca *Monochrome )copy ()*Monochrome {_gcd :=_dbeb (_eca .Width ,_eca .Height );
_gcd .ModelThreshold =_eca .ModelThreshold ;_gcd .Data =make ([]byte ,len (_eca .Data ));copy (_gcd .Data ,_eca .Data );if len (_eca .Decode )!=0{_gcd .Decode =make ([]float64 ,len (_eca .Decode ));copy (_gcd .Decode ,_eca .Decode );};if len (_eca .Alpha )!=0{_gcd .Alpha =make ([]byte ,len (_eca .Alpha ));
copy (_gcd .Alpha ,_eca .Alpha );};return _gcd ;};func (_gccda *CMYK32 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_gccda .Width ,Y :_gccda .Height }};};func _bfcd (_cdg _f .RGBA )_f .NRGBA {switch _cdg .A {case 0xff:return _f .NRGBA {R :_cdg .R ,G :_cdg .G ,B :_cdg .B ,A :0xff};
case 0x00:return _f .NRGBA {};default:_aeac ,_ceba ,_affb ,_dbc :=_cdg .RGBA ();_aeac =(_aeac *0xffff)/_dbc ;_ceba =(_ceba *0xffff)/_dbc ;_affb =(_affb *0xffff)/_dbc ;return _f .NRGBA {R :uint8 (_aeac >>8),G :uint8 (_ceba >>8),B :uint8 (_affb >>8),A :uint8 (_dbc >>8)};
};};func _fbbg (_bccg nrgba64 ,_dafc RGBA ,_cbega _g .Rectangle ){for _cefb :=0;_cefb < _cbega .Max .X ;_cefb ++{for _eafbd :=0;_eafbd < _cbega .Max .Y ;_eafbd ++{_aeag :=_bccg .NRGBA64At (_cefb ,_eafbd );_dafc .SetRGBA (_cefb ,_eafbd ,_cadb (_aeag ));
};};};type monochromeThresholdConverter struct{Threshold uint8 ;};type monochromeModel uint8 ;func (_daf *Gray4 )At (x ,y int )_f .Color {_egb ,_ :=_daf .ColorAt (x ,y );return _egb };func (_ccaee *NRGBA32 )Validate ()error {if len (_ccaee .Data )!=3*_ccaee .Width *_ccaee .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _ecdg (_cgcg int ,_edbb int )error {return _dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_cgcg ,_edbb );
};func (_eaee *Gray4 )setGray (_gff int ,_bcba int ,_cebe _f .Gray ){_adag :=_bcba *_eaee .BytesPerLine ;_bdca :=_adag +(_gff >>1);if _bdca >=len (_eaee .Data ){return ;};_afce :=_cebe .Y >>4;_eaee .Data [_bdca ]=(_eaee .Data [_bdca ]&(^(0xf0>>uint (4*(_gff &1)))))|(_afce <<uint (4-4*(_gff &1)));
};func _dbeb (_aa ,_gdf int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_aa ,_gdf ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func _daa (_dgcg _g .Image )(Image ,error ){if _gfb ,_fgde :=_dgcg .(*Gray8 );_fgde {return _gfb .Copy (),nil ;
};_fcfg :=_dgcg .Bounds ();_efac ,_bgaa :=NewImage (_fcfg .Max .X ,_fcfg .Max .Y ,8,1,nil ,nil ,nil );if _bgaa !=nil {return nil ,_bgaa ;};_bcgb (_dgcg ,_efac ,_fcfg );return _efac ,nil ;};var _ _g .Image =&Gray4 {};var _ Image =&NRGBA64 {};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_f .CMYK ,error ){_bgg :=4*(y *width +x );
if _bgg +3>=len (data ){return _f .CMYK {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_bgg ]&0xff;M :=data [_bgg +1]&0xff;Y :=data [_bgg +2]&0xff;K :=data [_bgg +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _f .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _ggfab (_fbbbg *_g .Gray16 ,_eeeb uint8 )*_g .Gray {_bdgc :=_fbbbg .Bounds ();
_gebb :=_g .NewGray (_bdgc );for _gdef :=0;_gdef < _bdgc .Dx ();_gdef ++{for _dbgd :=0;_dbgd < _bdgc .Dy ();_dbgd ++{_aggc :=_fbbbg .Gray16At (_gdef ,_dbgd );_gebb .SetGray (_gdef ,_dbgd ,_f .Gray {Y :_gfca (uint8 (_aggc .Y /256),_eeeb )});};};return _gebb ;
};func (_dbde *ImageBase )newAlpha (){_begcf :=BytesPerLine (_dbde .Width ,_dbde .BitsPerComponent ,1);_dbde .Alpha =make ([]byte ,_dbde .Height *_begcf );};func (_eccf *NRGBA64 )Validate ()error {if len (_eccf .Data )!=3*2*_eccf .Width *_eccf .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fcbe *NRGBA16 )NRGBAAt (x ,y int )_f .NRGBA {_gfed ,_ :=ColorAtNRGBA16 (x ,y ,_fcbe .Width ,_fcbe .BytesPerLine ,_fcbe .Data ,_fcbe .Alpha ,_fcbe .Decode );return _gfed ;};func _ddcd (_bcga _f .Gray )_f .Gray {_efgc :=_bcga .Y >>6;
_efgc |=_efgc <<2;_bcga .Y =_efgc |_efgc <<4;return _bcga ;};var _ Image =&Gray16 {};func (_bgef *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_edff :=_geaa (uint (factor ));if !IsPowerOf2 (uint (factor )){_edff ++;};_cbg :=make ([]int ,_edff );
for _fbea :=range _cbg {_cbg [_fbea ]=4;};_acd ,_dfed :=_fcg (_bgef ,_cbg ...);if _dfed !=nil {return nil ,_dfed ;};return _acd ,nil ;};func _gga (_edb _f .CMYK )_f .Gray {_fdaa ,_cbcd ,_bcc :=_f .CMYKToRGB (_edb .C ,_edb .M ,_edb .Y ,_edb .K );_dgde :=(19595*uint32 (_fdaa )+38470*uint32 (_cbcd )+7471*uint32 (_bcc )+1<<7)>>16;
return _f .Gray {Y :uint8 (_dgde )};};func (_cegb *Monochrome )getBit (_ffeg ,_gfeg int )uint8 {return _cegb .Data [_ffeg +(_gfeg >>3)]>>uint (7-(_gfeg &7))&1;};func (_cgefg *NRGBA32 )setRGBA (_bfcfe int ,_dfdff _f .NRGBA ){_bged :=3*_bfcfe ;_cgefg .Data [_bged ]=_dfdff .R ;
_cgefg .Data [_bged +1]=_dfdff .G ;_cgefg .Data [_bged +2]=_dfdff .B ;if _bfcfe < len (_cgefg .Alpha ){_cgefg .Alpha [_bfcfe ]=_dfdff .A ;};};var _ _g .Image =&Gray16 {};func (_dcb *Gray8 )SetGray (x ,y int ,g _f .Gray ){_fdd :=y *_dcb .BytesPerLine +x ;
if _fdd > len (_dcb .Data )-1{return ;};_dcb .Data [_fdd ]=g .Y ;};func (_ggd *Gray8 )At (x ,y int )_f .Color {_cfda ,_ :=_ggd .ColorAt (x ,y );return _cfda };func _baaf (_aeaeg *_g .Gray )bool {for _cdgf :=0;_cdgf < len (_aeaeg .Pix );_cdgf ++{if !_ffde (_aeaeg .Pix [_cdgf ]){return false ;
};};return true ;};func (_fdaaf *ImageBase )setEightBytes (_afgeb int ,_aeeg uint64 )error {_ebgb :=_fdaaf .BytesPerLine -(_afgeb %_fdaaf .BytesPerLine );if _fdaaf .BytesPerLine !=_fdaaf .Width >>3{_ebgb --;};if _ebgb >=8{return _fdaaf .setEightFullBytes (_afgeb ,_aeeg );
};return _fdaaf .setEightPartlyBytes (_afgeb ,_ebgb ,_aeeg );};func (_bgag *Gray2 )At (x ,y int )_f .Color {_fadb ,_ :=_bgag .ColorAt (x ,y );return _fadb };func (_bbb *NRGBA16 )Validate ()error {if len (_bbb .Data )!=3*_bbb .Width *_bbb .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type colorConverter struct{_gdaf func (_ddfg _g .Image )(Image ,error );};func _gceg (_afcc _f .NRGBA )_f .RGBA {_ddea ,_efeb ,_aed ,_ged :=_afcc .RGBA ();return _f .RGBA {R :uint8 (_ddea >>8),G :uint8 (_efeb >>8),B :uint8 (_aed >>8),A :uint8 (_ged >>8)};
};func (_ageg *CMYK32 )ColorModel ()_f .Model {return _f .CMYKModel };type ColorConverter interface{Convert (_aad _g .Image )(Image ,error );};func _ggadg (_bdfa _g .Image ,_fggf Image ,_abca _g .Rectangle ){if _eadce ,_cfac :=_bdfa .(SMasker );_cfac &&_eadce .HasAlpha (){_fggf .(SMasker ).MakeAlpha ();
};_agee (_bdfa ,_fggf ,_abca );};func _bcad (_ddbbda ,_cfbb RGBA ,_eadbe _g .Rectangle ){for _ccbeg :=0;_ccbeg < _eadbe .Max .X ;_ccbeg ++{for _bbed :=0;_bbed < _eadbe .Max .Y ;_bbed ++{_cfbb .SetRGBA (_ccbeg ,_bbed ,_ddbbda .RGBAAt (_ccbeg ,_bbed ));};
};};func (_bgagd *NRGBA64 )setNRGBA64 (_bgadf int ,_gdcaa _f .NRGBA64 ,_gcdb int ){_bgagd .Data [_bgadf ]=uint8 (_gdcaa .R >>8);_bgagd .Data [_bgadf +1]=uint8 (_gdcaa .R &0xff);_bgagd .Data [_bgadf +2]=uint8 (_gdcaa .G >>8);_bgagd .Data [_bgadf +3]=uint8 (_gdcaa .G &0xff);
_bgagd .Data [_bgadf +4]=uint8 (_gdcaa .B >>8);_bgagd .Data [_bgadf +5]=uint8 (_gdcaa .B &0xff);if _gcdb +1< len (_bgagd .Alpha ){_bgagd .Alpha [_gcdb ]=uint8 (_gdcaa .A >>8);_bgagd .Alpha [_gcdb +1]=uint8 (_gdcaa .A &0xff);};};func (_ebbf *Gray8 )ColorModel ()_f .Model {return _f .GrayModel };
func (_adbf *Gray2 )Base ()*ImageBase {return &_adbf .ImageBase };func _cdc (_adcc _f .Color )_f .Color {_dgge :=_f .GrayModel .Convert (_adcc ).(_f .Gray );return _afff (_dgge );};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;
Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func InDelta (expected ,current ,delta float64 )bool {_ggfg :=expected -current ;if _ggfg <=-delta ||_ggfg >=delta {return false ;};return true ;};func (_ccff *Gray16 )At (x ,y int )_f .Color {_fdbc ,_ :=_ccff .ColorAt (x ,y );
return _fdbc };func _efbb (_bgad _g .Image ,_cgge int )(_g .Rectangle ,bool ,[]byte ){_fegfb :=_bgad .Bounds ();var (_cbff bool ;_ccgc []byte ;);switch _fbd :=_bgad .(type ){case SMasker :_cbff =_fbd .HasAlpha ();case NRGBA ,RGBA ,*_g .RGBA64 ,nrgba64 ,*_g .NYCbCrA :_ccgc =make ([]byte ,_fegfb .Max .X *_fegfb .Max .Y *_cgge );
case *_g .Paletted :if !_fbd .Opaque (){_ccgc =make ([]byte ,_fegfb .Max .X *_fegfb .Max .Y *_cgge );};};return _fegfb ,_cbff ,_ccgc ;};func (_ccf *Gray16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray16BPC (x ,y ,_ccf .BytesPerLine ,_ccf .Data ,_ccf .Decode );
};func (_agec *ImageBase )MakeAlpha (){_agec .newAlpha ()};var _ Gray =&Gray4 {};func _dega (_eedf Gray ,_gdcag NRGBA ,_dbged _g .Rectangle ){for _cbeb :=0;_cbeb < _dbged .Max .X ;_cbeb ++{for _gcdg :=0;_gcdg < _dbged .Max .Y ;_gcdg ++{_beee :=_eedf .GrayAt (_cbeb ,_gcdg );
_gdcag .SetNRGBA (_cbeb ,_gcdg ,_gabc (_beee ));};};};func (_ffff *Monochrome )Validate ()error {if len (_ffff .Data )!=_ffff .Height *_ffff .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_dd .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_eded *ImageBase )getByte (_cgbd int )(byte ,error ){if _cgbd > len (_eded .Data )-1||_cgbd < 0{return 0,_dd .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_cgbd );
};return _eded .Data [_cgbd ],nil ;};func _cbdf (_faad _g .Image )(Image ,error ){if _egeb ,_degb :=_faad .(*Gray4 );_degb {return _egeb .Copy (),nil ;};_ecad :=_faad .Bounds ();_bfdce ,_ddfec :=NewImage (_ecad .Max .X ,_ecad .Max .Y ,4,1,nil ,nil ,nil );
if _ddfec !=nil {return nil ,_ddfec ;};_bcgb (_faad ,_bfdce ,_ecad );return _bfdce ,nil ;};var _ Image =&Gray2 {};type Gray8 struct{ImageBase };var (_aggg =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_aabf =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_edcg :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _edcg ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_abee :=width *colorComponents *bitsPerComponent ;
_dded :=_edcg *8;_eaff :=8-(_dded -_abee );_bded :=_fe .NewReader (data );_ggff :=_edcg -1;_gecbc :=make ([]byte ,_ggff );_ggdf :=make ([]byte ,height *_edcg );_ffc :=_fe .NewWriterMSB (_ggdf );var _add uint64 ;var _cdcbf error ;for _abeg :=0;_abeg < height ;
_abeg ++{_ ,_cdcbf =_bded .Read (_gecbc );if _cdcbf !=nil {return nil ,_cdcbf ;};_ ,_cdcbf =_ffc .Write (_gecbc );if _cdcbf !=nil {return nil ,_cdcbf ;};_add ,_cdcbf =_bded .ReadBits (byte (_eaff ));if _cdcbf !=nil {return nil ,_cdcbf ;};_ ,_cdcbf =_ffc .WriteBits (_add ,_eaff );
if _cdcbf !=nil {return nil ,_cdcbf ;};_ffc .FinishByte ();};return _ggdf ,nil ;};func _gede (_aada ,_fdfa Gray ,_dada _g .Rectangle ){for _fcd :=0;_fcd < _dada .Max .X ;_fcd ++{for _efc :=0;_efc < _dada .Max .Y ;_efc ++{_fdfa .SetGray (_fcd ,_efc ,_aada .GrayAt (_fcd ,_efc ));
};};};func FromGoImage (i _g .Image )(Image ,error ){switch _eefg :=i .(type ){case Image :return _eefg .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_g .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_g .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_dfab *Gray4 )Histogram ()(_gcbg [256]int ){for _cbbg :=0;_cbbg < _dfab .Width ;_cbbg ++{for _afee :=0;_afee < _dfab .Height ;_afee ++{_gcbg [_dfab .GrayAt (_cbbg ,_afee ).Y ]++;
};};return _gcbg ;};func (_eceg *NRGBA32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA32 (x ,y ,_eceg .Width ,_eceg .Data ,_eceg .Alpha ,_eceg .Decode );};func MonochromeModel (threshold uint8 )_f .Model {return monochromeModel (threshold )};
func (_dfef *Gray2 )GrayAt (x ,y int )_f .Gray {_aead ,_ :=ColorAtGray2BPC (x ,y ,_dfef .BytesPerLine ,_dfef .Data ,_dfef .Decode );return _aead ;};type RGBA32 struct{ImageBase };func (_dgee *Monochrome )setIndexedBit (_gbc int ){_dgee .Data [(_gbc >>3)]|=0x80>>uint (_gbc &7)};
func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_cebee :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _egg Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_egg =&Monochrome {ImageBase :_cebee ,ModelThreshold :0x0f};
case 2:_egg =&Gray2 {ImageBase :_cebee };case 4:_egg =&Gray4 {ImageBase :_cebee };case 8:_egg =&Gray8 {ImageBase :_cebee };case 16:_egg =&Gray16 {ImageBase :_cebee };};case 3:switch bitsPerComponent {case 4:_egg =&NRGBA16 {ImageBase :_cebee };case 8:_egg =&NRGBA32 {ImageBase :_cebee };
case 16:_egg =&NRGBA64 {ImageBase :_cebee };};case 4:_egg =&CMYK32 {ImageBase :_cebee };};if _egg ==nil {return nil ,ErrInvalidImage ;};return _egg ,nil ;};type NRGBA32 struct{ImageBase };var _ _g .Image =&NRGBA16 {};func (_eeag *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_dd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _eb (_eeag ,factor );};func (_acdf *ImageBase )setEightPartlyBytes (_fcgdb ,_bcge int ,_cgc uint64 )(_ffbg error ){var (_cedg byte ;_defeg int ;);for _gdfbe :=1;_gdfbe <=_bcge ;_gdfbe ++{_defeg =64-_gdfbe *8;_cedg =byte (_cgc >>uint (_defeg )&0xff);
if _ffbg =_acdf .setByte (_fcgdb +_gdfbe -1,_cedg );_ffbg !=nil {return _ffbg ;};};_bfa :=_acdf .BytesPerLine *8-_acdf .Width ;if _bfa ==0{return nil ;};_defeg -=8;_cedg =byte (_cgc >>uint (_defeg )&0xff)<<uint (_bfa );if _ffbg =_acdf .setByte (_fcgdb +_bcge ,_cedg );
_ffbg !=nil {return _ffbg ;};return nil ;};func (_cbb *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cbb .copy ()}};func (_cfe *Gray16 )Histogram ()(_agbc [256]int ){for _aef :=0;_aef < _cfe .Width ;_aef ++{for _dfeg :=0;_dfeg < _cfe .Height ;_dfeg ++{_agbc [_cfe .GrayAt (_aef ,_dfeg ).Y ]++;
};};return _agbc ;};func (_abe *Gray16 )Set (x ,y int ,c _f .Color ){_aade :=(y *_abe .BytesPerLine /2+x )*2;if _aade +1>=len (_abe .Data ){return ;};_cfc :=_f .Gray16Model .Convert (c ).(_f .Gray16 );_abe .Data [_aade ],_abe .Data [_aade +1]=uint8 (_cfc .Y >>8),uint8 (_cfc .Y &0xff);
};func (_cfa *CMYK32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtCMYK (x ,y ,_cfa .Width ,_cfa .Data ,_cfa .Decode );};var (_cc =_aeb ();_dgg =_cge ();_gdb =_gdd (););func (_fdc *Gray8 )Histogram ()(_efbeg [256]int ){for _ggfa :=0;_ggfa < len (_fdc .Data );
_ggfa ++{_efbeg [_fdc .Data [_ggfa ]]++;};return _efbeg ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_dfd :=y *bytesPerLine +x >>1;if _dfd >=len (data ){return _f .Gray {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bcbb :=data [_dfd ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bcbb =uint8 (uint32 (LinearInterpolate (float64 (_bcbb ),0,15,decode [0],decode [1]))&0xf);};return _f .Gray {Y :_bcbb *17&0xff},nil ;};func _ggab (_daca _g .Image )(Image ,error ){if _gcdd ,_bcbc :=_daca .(*NRGBA64 );
_bcbc {return _gcdd .Copy (),nil ;};_fegae ,_dgbe ,_gfcc :=_efbb (_daca ,2);_ggdg ,_gfg :=NewImage (_fegae .Max .X ,_fegae .Max .Y ,16,3,nil ,_gfcc ,nil );if _gfg !=nil {return nil ,_gfg ;};_ggadg (_daca ,_ggdg ,_fegae );if len (_gfcc )!=0&&!_dgbe {if _geg :=_eacg (_gfcc ,_ggdg );
_geg !=nil {return nil ,_geg ;};};return _ggdg ,nil ;};func (_dcdd *Gray2 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_dcdd .Width ,Y :_dcdd .Height }};};func (_def *CMYK32 )At (x ,y int )_f .Color {_bee ,_ :=_def .ColorAt (x ,y );
return _bee };func _gebf (_fcfgb _f .Color )_f .Color {_cdfdf :=_f .NRGBAModel .Convert (_fcfgb ).(_f .NRGBA );return _cced (_cdfdf );};func (_ggbc *Monochrome )GrayAt (x ,y int )_f .Gray {_cef ,_ :=ColorAtGray1BPC (x ,y ,_ggbc .BytesPerLine ,_ggbc .Data ,_ggbc .Decode );
return _cef ;};func _eebb (_dfe ,_gccc int ,_eag []byte )*Monochrome {_gbea :=_dbeb (_dfe ,_gccc );_gbea .Data =_eag ;return _gbea ;};func (_decb monochromeModel )Convert (c _f .Color )_f .Color {_bedc :=_f .GrayModel .Convert (c ).(_f .Gray );return _ggcg (_bedc ,_decb );
};var _ Image =&NRGBA16 {};func (_dcdc *RGBA32 )Set (x ,y int ,c _f .Color ){_geca :=y *_dcdc .Width +x ;_agbd :=3*_geca ;if _agbd +2>=len (_dcdc .Data ){return ;};_faac :=_f .RGBAModel .Convert (c ).(_f .RGBA );_dcdc .setRGBA (_geca ,_faac );};var _ Image =&Monochrome {};
var _ _g .Image =&NRGBA32 {};type CMYK32 struct{ImageBase };func (_dgfc *ImageBase )copy ()ImageBase {_eefca :=*_dgfc ;_eefca .Data =make ([]byte ,len (_dgfc .Data ));copy (_eefca .Data ,_dgfc .Data );return _eefca ;};func _dcfd (_eggb *_g .NYCbCrA ,_dffbd RGBA ,_acad _g .Rectangle ){for _bdedd :=0;
_bdedd < _acad .Max .X ;_bdedd ++{for _cbac :=0;_cbac < _acad .Max .Y ;_cbac ++{_egabb :=_eggb .NYCbCrAAt (_bdedd ,_cbac );_dffbd .SetRGBA (_bdedd ,_cbac ,_fga (_egabb ));};};};func _ggcg (_adaf _f .Gray ,_becfb monochromeModel )_f .Gray {if _adaf .Y > uint8 (_becfb ){return _f .Gray {Y :_db .MaxUint8 };
};return _f .Gray {};};func _gccd (_gdbb *Monochrome ,_fbb int ,_faeg []byte )(_cb *Monochrome ,_ac error ){const _fda ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _gdbb ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _fbb < 1||_fbb > 4{return nil ,_d .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _gdbb .Height <=1{return nil ,_d .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_cb =_dbeb (_gdbb .Width /2,_gdbb .Height /2);if _faeg ==nil {_faeg =_gefg ();};_bbac :=_fgacc (_gdbb .BytesPerLine ,2*_cb .BytesPerLine );switch _fbb {case 1:_ac =_dbg (_gdbb ,_cb ,_faeg ,_bbac );case 2:_ac =_cca (_gdbb ,_cb ,_faeg ,_bbac );case 3:_ac =_fbbb (_gdbb ,_cb ,_faeg ,_bbac );
case 4:_ac =_aeaa (_gdbb ,_cb ,_faeg ,_bbac );};if _ac !=nil {return nil ,_ac ;};return _cb ,nil ;};func _dgf (_bfge _f .NRGBA64 )_f .Gray {var _bec _f .NRGBA64 ;if _bfge ==_bec {return _f .Gray {Y :0xff};};_afdg ,_edeg ,_ffa ,_ :=_bfge .RGBA ();_dga :=(19595*_afdg +38470*_edeg +7471*_ffa +1<<15)>>24;
return _f .Gray {Y :uint8 (_dga )};};func _afff (_baad _f .Gray )_f .Gray {_baad .Y >>=4;_baad .Y |=_baad .Y <<4;return _baad };func _fbbb (_fdb ,_eefc *Monochrome ,_aff []byte ,_efg int )(_caeg error ){var (_eda ,_bgd ,_fegf ,_bfe ,_fbbf ,_dfc ,_egf ,_aebf int ;
_dace ,_ebaa ,_bgb ,_age uint32 ;_ebb ,_egc byte ;_fad uint16 ;);_gg :=make ([]byte ,4);_fdg :=make ([]byte ,4);for _fegf =0;_fegf < _fdb .Height -1;_fegf ,_bfe =_fegf +2,_bfe +1{_eda =_fegf *_fdb .BytesPerLine ;_bgd =_bfe *_eefc .BytesPerLine ;for _fbbf ,_dfc =0,0;
_fbbf < _efg ;_fbbf ,_dfc =_fbbf +4,_dfc +1{for _egf =0;_egf < 4;_egf ++{_aebf =_eda +_fbbf +_egf ;if _aebf <=len (_fdb .Data )-1&&_aebf < _eda +_fdb .BytesPerLine {_gg [_egf ]=_fdb .Data [_aebf ];}else {_gg [_egf ]=0x00;};_aebf =_eda +_fdb .BytesPerLine +_fbbf +_egf ;
if _aebf <=len (_fdb .Data )-1&&_aebf < _eda +(2*_fdb .BytesPerLine ){_fdg [_egf ]=_fdb .Data [_aebf ];}else {_fdg [_egf ]=0x00;};};_dace =_ed .BigEndian .Uint32 (_gg );_ebaa =_ed .BigEndian .Uint32 (_fdg );_bgb =_dace &_ebaa ;_bgb |=_bgb <<1;_age =_dace |_ebaa ;
_age &=_age <<1;_ebaa =_bgb &_age ;_ebaa &=0xaaaaaaaa;_dace =_ebaa |(_ebaa <<7);_ebb =byte (_dace >>24);_egc =byte ((_dace >>8)&0xff);_aebf =_bgd +_dfc ;if _aebf +1==len (_eefc .Data )-1||_aebf +1>=_bgd +_eefc .BytesPerLine {if _caeg =_eefc .setByte (_aebf ,_aff [_ebb ]);
_caeg !=nil {return _dd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_aebf );};}else {_fad =(uint16 (_aff [_ebb ])<<8)|uint16 (_aff [_egc ]);if _caeg =_eefc .setTwoBytes (_aebf ,_fad );_caeg !=nil {return _dd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_aebf );
};_dfc ++;};};};return nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_deeac :=y *bytesPerLine +x >>2;if _deeac >=len (data ){return _f .Gray {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eegg :=data [_deeac ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_eegg =uint8 (uint32 (LinearInterpolate (float64 (_eegg ),0,3.0,decode [0],decode [1]))&3);};return _f .Gray {Y :_eegg *85},nil ;};func _ccde (_aabc RGBA ,_agce Gray ,_acac _g .Rectangle ){for _cfgc :=0;
_cfgc < _acac .Max .X ;_cfgc ++{for _dgfbe :=0;_dgfbe < _acac .Max .Y ;_dgfbe ++{_ccae :=_cace (_aabc .RGBAAt (_cfgc ,_dgfbe ));_agce .SetGray (_cfgc ,_dgfbe ,_ccae );};};};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_adae :=y *bytesPerLine +x *3/2;
if _adae +1>=len (data ){return _f .NRGBA {},_ecdg (x ,y );};const (_dgfa =0xf;_ffbb =uint8 (0xff););_bgagf :=_ffbb ;if alpha !=nil {_ddec :=y *BytesPerLine (width ,4,1);if _ddec < len (alpha ){if x %2==0{_bgagf =(alpha [_ddec ]>>uint (4))&_dgfa ;}else {_bgagf =alpha [_ddec ]&_dgfa ;
};_bgagf |=_bgagf <<4;};};var _dbge ,_gfbg ,_gcag uint8 ;if x *3%2==0{_dbge =(data [_adae ]>>uint (4))&_dgfa ;_gfbg =data [_adae ]&_dgfa ;_gcag =(data [_adae +1]>>uint (4))&_dgfa ;}else {_dbge =data [_adae ]&_dgfa ;_gfbg =(data [_adae +1]>>uint (4))&_dgfa ;
_gcag =data [_adae +1]&_dgfa ;};if len (decode )==6{_dbge =uint8 (uint32 (LinearInterpolate (float64 (_dbge ),0,15,decode [0],decode [1]))&0xf);_gfbg =uint8 (uint32 (LinearInterpolate (float64 (_gfbg ),0,15,decode [2],decode [3]))&0xf);_gcag =uint8 (uint32 (LinearInterpolate (float64 (_gcag ),0,15,decode [4],decode [5]))&0xf);
};return _f .NRGBA {R :(_dbge <<4)|(_dbge &0xf),G :(_gfbg <<4)|(_gfbg &0xf),B :(_gcag <<4)|(_gcag &0xf),A :_bgagf },nil ;};func _gabc (_aege _f .Gray )_f .NRGBA {return _f .NRGBA {R :_aege .Y ,G :_aege .Y ,B :_aege .Y ,A :0xff}};func (_abff *Monochrome )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray1BPC (x ,y ,_abff .BytesPerLine ,_abff .Data ,_abff .Decode );
};var _ Image =&Gray8 {};func (_cdfd *Gray16 )GrayAt (x ,y int )_f .Gray {_dgfe ,_ :=_cdfd .ColorAt (x ,y );return _f .Gray {Y :uint8 (_dgfe .(_f .Gray16 ).Y >>8)};};func _ebfb (_fefd _g .Image )(Image ,error ){if _cdfc ,_eaga :=_fefd .(*NRGBA32 );_eaga {return _cdfc .Copy (),nil ;
};_aeba ,_ebcg ,_fcfag :=_efbb (_fefd ,1);_eeggf ,_bfaa :=NewImage (_aeba .Max .X ,_aeba .Max .Y ,8,3,nil ,_fcfag ,nil );if _bfaa !=nil {return nil ,_bfaa ;};_bgac (_fefd ,_eeggf ,_aeba );if len (_fcfag )!=0&&!_ebcg {if _efcd :=_eacg (_fcfag ,_eeggf );
_efcd !=nil {return nil ,_efcd ;};};return _eeggf ,nil ;};func (_decc *Gray16 )Base ()*ImageBase {return &_decc .ImageBase };func (_fedb *Gray4 )GrayAt (x ,y int )_f .Gray {_gdad ,_ :=ColorAtGray4BPC (x ,y ,_fedb .BytesPerLine ,_fedb .Data ,_fedb .Decode );
return _gdad ;};func _ebd (_dge ,_affg CMYK ,_ege _g .Rectangle ){for _baa :=0;_baa < _ege .Max .X ;_baa ++{for _gde :=0;_gde < _ege .Max .Y ;_gde ++{_affg .SetCMYK (_baa ,_gde ,_dge .CMYKAt (_baa ,_gde ));};};};func _bcfdf (_ebeb _g .Image )(Image ,error ){if _fbf ,_dbbf :=_ebeb .(*RGBA32 );
_dbbf {return _fbf .Copy (),nil ;};_bddd ,_bbbd ,_bfged :=_efbb (_ebeb ,1);_gaccb :=&RGBA32 {ImageBase :NewImageBase (_bddd .Max .X ,_bddd .Max .Y ,8,3,nil ,_bfged ,nil )};_ebea (_ebeb ,_gaccb ,_bddd );if len (_bfged )!=0&&!_bbbd {if _ecfc :=_eacg (_bfged ,_gaccb );
_ecfc !=nil {return nil ,_ecfc ;};};return _gaccb ,nil ;};func (_aeda *NRGBA32 )Set (x ,y int ,c _f .Color ){_bebe :=y *_aeda .Width +x ;_fec :=3*_bebe ;if _fec +2>=len (_aeda .Data ){return ;};_daea :=_f .NRGBAModel .Convert (c ).(_f .NRGBA );_aeda .setRGBA (_bebe ,_daea );
};func _dda (_fcbff *Monochrome ,_gcfgg ,_acb ,_fega ,_acdb int ,_aebb RasterOperator ,_aec *Monochrome ,_gccgc ,_aadd int )error {var (_bgcc byte ;_fdcf int ;_caac int ;_ecac ,_bbab int ;_bagg ,_cagd int ;);_fba :=_fega >>3;_afaa :=_fega &7;if _afaa > 0{_bgcc =_aggg [_afaa ];
};_fdcf =_aec .BytesPerLine *_aadd +(_gccgc >>3);_caac =_fcbff .BytesPerLine *_acb +(_gcfgg >>3);switch _aebb {case PixSrc :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;
_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]=_aec .Data [_ecac ];_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],_aec .Data [_ecac ],_bgcc );};};case PixNotSrc :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;
_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]=^(_aec .Data [_ecac ]);_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],^_aec .Data [_ecac ],_bgcc );};};case PixSrcOrDst :for _bagg =0;
_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]|=_aec .Data [_ecac ];_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],_aec .Data [_ecac ]|_fcbff .Data [_bbab ],_bgcc );
};};case PixSrcAndDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]&=_aec .Data [_ecac ];_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],_aec .Data [_ecac ]&_fcbff .Data [_bbab ],_bgcc );
};};case PixSrcXorDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]^=_aec .Data [_ecac ];_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],_aec .Data [_ecac ]^_fcbff .Data [_bbab ],_bgcc );
};};case PixNotSrcOrDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]|=^(_aec .Data [_ecac ]);_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],^(_aec .Data [_ecac ])|_fcbff .Data [_bbab ],_bgcc );
};};case PixNotSrcAndDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]&=^(_aec .Data [_ecac ]);_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],^(_aec .Data [_ecac ])&_fcbff .Data [_bbab ],_bgcc );
};};case PixSrcOrNotDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]=_aec .Data [_ecac ]|^(_fcbff .Data [_bbab ]);_bbab ++;
_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],_aec .Data [_ecac ]|^(_fcbff .Data [_bbab ]),_bgcc );};};case PixSrcAndNotDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;
for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]=_aec .Data [_ecac ]&^(_fcbff .Data [_bbab ]);_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],_aec .Data [_ecac ]&^(_fcbff .Data [_bbab ]),_bgcc );};};case PixNotPixSrcOrDst :for _bagg =0;
_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]=^(_aec .Data [_ecac ]|_fcbff .Data [_bbab ]);_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],^(_aec .Data [_ecac ]|_fcbff .Data [_bbab ]),_bgcc );
};};case PixNotPixSrcAndDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]=^(_aec .Data [_ecac ]&_fcbff .Data [_bbab ]);
_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],^(_aec .Data [_ecac ]&_fcbff .Data [_bbab ]),_bgcc );};};case PixNotPixSrcXorDst :for _bagg =0;_bagg < _acdb ;_bagg ++{_ecac =_fdcf +_bagg *_aec .BytesPerLine ;_bbab =_caac +_bagg *_fcbff .BytesPerLine ;
for _cagd =0;_cagd < _fba ;_cagd ++{_fcbff .Data [_bbab ]=^(_aec .Data [_ecac ]^_fcbff .Data [_bbab ]);_bbab ++;_ecac ++;};if _afaa > 0{_fcbff .Data [_bbab ]=_fddd (_fcbff .Data [_bbab ],^(_aec .Data [_ecac ]^_fcbff .Data [_bbab ]),_bgcc );};};default:_fa .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_aebb );
return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func _fbc (_fag Gray ,_ada nrgba64 ,_daed _g .Rectangle ){for _acab :=0;_acab < _daed .Max .X ;
_acab ++{for _ggag :=0;_ggag < _daed .Max .Y ;_ggag ++{_fbe :=_dgf (_ada .NRGBA64At (_acab ,_ggag ));_fag .SetGray (_acab ,_ggag ,_fbe );};};};type RasterOperator int ;func _bfce (_feff *Monochrome ,_afcff ,_geaf ,_cdfg ,_bgbg int ,_ggcddg RasterOperator ){if _afcff < 0{_cdfg +=_afcff ;
_afcff =0;};_gdcb :=_afcff +_cdfg -_feff .Width ;if _gdcb > 0{_cdfg -=_gdcb ;};if _geaf < 0{_bgbg +=_geaf ;_geaf =0;};_dede :=_geaf +_bgbg -_feff .Height ;if _dede > 0{_bgbg -=_dede ;};if _cdfg <=0||_bgbg <=0{return ;};if (_afcff &7)==0{_cecg (_feff ,_afcff ,_geaf ,_cdfg ,_bgbg ,_ggcddg );
}else {_ccba (_feff ,_afcff ,_geaf ,_cdfg ,_bgbg ,_ggcddg );};};func (_aaed *Monochrome )ResolveDecode ()error {if len (_aaed .Decode )!=2{return nil ;};if _aaed .Decode [0]==1&&_aaed .Decode [1]==0{if _gdca :=_aaed .InverseData ();_gdca !=nil {return _gdca ;
};_aaed .Decode =nil ;};return nil ;};func _cecg (_fdcc *Monochrome ,_acgb ,_cbgc int ,_dddgc ,_ffdb int ,_egba RasterOperator ){var (_fadd int ;_deca byte ;_acbc ,_bdfg int ;_aaeg int ;);_abaa :=_dddgc >>3;_gded :=_dddgc &7;if _gded > 0{_deca =_aggg [_gded ];
};_fadd =_fdcc .BytesPerLine *_cbgc +(_acgb >>3);switch _egba {case PixClr :for _acbc =0;_acbc < _ffdb ;_acbc ++{_aaeg =_fadd +_acbc *_fdcc .BytesPerLine ;for _bdfg =0;_bdfg < _abaa ;_bdfg ++{_fdcc .Data [_aaeg ]=0x0;_aaeg ++;};if _gded > 0{_fdcc .Data [_aaeg ]=_fddd (_fdcc .Data [_aaeg ],0x0,_deca );
};};case PixSet :for _acbc =0;_acbc < _ffdb ;_acbc ++{_aaeg =_fadd +_acbc *_fdcc .BytesPerLine ;for _bdfg =0;_bdfg < _abaa ;_bdfg ++{_fdcc .Data [_aaeg ]=0xff;_aaeg ++;};if _gded > 0{_fdcc .Data [_aaeg ]=_fddd (_fdcc .Data [_aaeg ],0xff,_deca );};};case PixNotDst :for _acbc =0;
_acbc < _ffdb ;_acbc ++{_aaeg =_fadd +_acbc *_fdcc .BytesPerLine ;for _bdfg =0;_bdfg < _abaa ;_bdfg ++{_fdcc .Data [_aaeg ]=^_fdcc .Data [_aaeg ];_aaeg ++;};if _gded > 0{_fdcc .Data [_aaeg ]=_fddd (_fdcc .Data [_aaeg ],^_fdcc .Data [_aaeg ],_deca );};};
};};func _ffbe (_afa ,_ag *Monochrome )(_ce error ){_bg :=_ag .BytesPerLine ;_ee :=_afa .BytesPerLine ;var (_ga byte ;_gab uint16 ;_fae ,_cg ,_ea ,_da ,_ded int ;);for _ea =0;_ea < _ag .Height ;_ea ++{_fae =_ea *_bg ;_cg =2*_ea *_ee ;for _da =0;_da < _bg ;
_da ++{_ga =_ag .Data [_fae +_da ];_gab =_cc [_ga ];_ded =_cg +_da *2;if _afa .BytesPerLine !=_ag .BytesPerLine *2&&(_da +1)*2> _afa .BytesPerLine {_ce =_afa .setByte (_ded ,byte (_gab >>8));}else {_ce =_afa .setTwoBytes (_ded ,_gab );};if _ce !=nil {return _ce ;
};};for _da =0;_da < _ee ;_da ++{_ded =_cg +_ee +_da ;_ga =_afa .Data [_cg +_da ];if _ce =_afa .setByte (_ded ,_ga );_ce !=nil {return _ce ;};};};return nil ;};func IsGrayImgBlackAndWhite (i *_g .Gray )bool {return _baaf (i )};var _ Image =&NRGBA32 {};
func (_adba *ImageBase )setTwoBytes (_fcfgc int ,_fea uint16 )error {if _fcfgc +1> len (_adba .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_adba .Data [_fcfgc ]=byte ((_fea &0xff00)>>8);
_adba .Data [_fcfgc +1]=byte (_fea &0xff);return nil ;};type shift int ;func (_dcge *RGBA32 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_dcge .Width ,Y :_dcge .Height }};};func _aab (_eegd _f .Color )_f .Color {_bfea :=_f .GrayModel .Convert (_eegd ).(_f .Gray );
return _ddcd (_bfea );};type RGBA interface{RGBAAt (_egfb ,_febd int )_f .RGBA ;SetRGBA (_efab ,_cdbe int ,_gfa _f .RGBA );};var _ RGBA =&RGBA32 {};func (_ddcef *CMYK32 )SetCMYK (x ,y int ,c _f .CMYK ){_bcb :=4*(y *_ddcef .Width +x );if _bcb +3>=len (_ddcef .Data ){return ;
};_ddcef .Data [_bcb ]=c .C ;_ddcef .Data [_bcb +1]=c .M ;_ddcef .Data [_bcb +2]=c .Y ;_ddcef .Data [_bcb +3]=c .K ;};func (_adf *RGBA32 )RGBAAt (x ,y int )_f .RGBA {_gbccc ,_ :=ColorAtRGBA32 (x ,y ,_adf .Width ,_adf .Data ,_adf .Alpha ,_adf .Decode );
return _gbccc ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;
case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};
return nil ,_dd .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _ceed (_gdfb NRGBA ,_eccc Gray ,_bcbbe _g .Rectangle ){for _dfgf :=0;_dfgf < _bcbbe .Max .X ;_dfgf ++{for _aebg :=0;_aebg < _bcbbe .Max .Y ;_aebg ++{_bff :=_gea (_gdfb .NRGBAAt (_dfgf ,_aebg ));_eccc .SetGray (_dfgf ,_aebg ,_bff );};};};func (_afef *NRGBA16 )Base ()*ImageBase {return &_afef .ImageBase };
func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .RGBA ,error ){_ebae :=y *width +x ;_aabd :=3*_ebae ;if _aabd +2>=len (data ){return _f .RGBA {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bccdd :=uint8 (0xff);if alpha !=nil &&len (alpha )> _ebae {_bccdd =alpha [_ebae ];};_dcaf ,_gfdad ,_ggabg :=data [_aabd ],data [_aabd +1],data [_aabd +2];if len (decode )==6{_dcaf =uint8 (uint32 (LinearInterpolate (float64 (_dcaf ),0,255,decode [0],decode [1]))&0xff);
_gfdad =uint8 (uint32 (LinearInterpolate (float64 (_gfdad ),0,255,decode [2],decode [3]))&0xff);_ggabg =uint8 (uint32 (LinearInterpolate (float64 (_ggabg ),0,255,decode [4],decode [5]))&0xff);};return _f .RGBA {R :_dcaf ,G :_gfdad ,B :_ggabg ,A :_bccdd },nil ;
};func (_egge *NRGBA16 )SetNRGBA (x ,y int ,c _f .NRGBA ){_bdcc :=y *_egge .BytesPerLine +x *3/2;if _bdcc +1>=len (_egge .Data ){return ;};c =_cced (c );_egge .setNRGBA (x ,y ,_bdcc ,c );};func (_dbbb *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_dbbb .copy ()}};
func (_bceg *NRGBA64 )ColorModel ()_f .Model {return _f .NRGBA64Model };var _ _g .Image =&NRGBA64 {};func _ccba (_ceddf *Monochrome ,_efed ,_beda int ,_dbf ,_cegbf int ,_befe RasterOperator ){var (_dacb bool ;_ceac bool ;_degbe int ;_gdfc int ;_ccaa int ;
_fedg int ;_fbaa bool ;_gfbe byte ;);_fdfdb :=8-(_efed &7);_dgbag :=_aabf [_fdfdb ];_efaf :=_ceddf .BytesPerLine *_beda +(_efed >>3);if _dbf < _fdfdb {_dacb =true ;_dgbag &=_aggg [8-_fdfdb +_dbf ];};if !_dacb {_degbe =(_dbf -_fdfdb )>>3;if _degbe !=0{_ceac =true ;
_gdfc =_efaf +1;};};_ccaa =(_efed +_dbf )&7;if !(_dacb ||_ccaa ==0){_fbaa =true ;_gfbe =_aggg [_ccaa ];_fedg =_efaf +1+_degbe ;};var _edea ,_geff int ;switch _befe {case PixClr :for _edea =0;_edea < _cegbf ;_edea ++{_ceddf .Data [_efaf ]=_fddd (_ceddf .Data [_efaf ],0x0,_dgbag );
_efaf +=_ceddf .BytesPerLine ;};if _ceac {for _edea =0;_edea < _cegbf ;_edea ++{for _geff =0;_geff < _degbe ;_geff ++{_ceddf .Data [_gdfc +_geff ]=0x0;};_gdfc +=_ceddf .BytesPerLine ;};};if _fbaa {for _edea =0;_edea < _cegbf ;_edea ++{_ceddf .Data [_fedg ]=_fddd (_ceddf .Data [_fedg ],0x0,_gfbe );
_fedg +=_ceddf .BytesPerLine ;};};case PixSet :for _edea =0;_edea < _cegbf ;_edea ++{_ceddf .Data [_efaf ]=_fddd (_ceddf .Data [_efaf ],0xff,_dgbag );_efaf +=_ceddf .BytesPerLine ;};if _ceac {for _edea =0;_edea < _cegbf ;_edea ++{for _geff =0;_geff < _degbe ;
_geff ++{_ceddf .Data [_gdfc +_geff ]=0xff;};_gdfc +=_ceddf .BytesPerLine ;};};if _fbaa {for _edea =0;_edea < _cegbf ;_edea ++{_ceddf .Data [_fedg ]=_fddd (_ceddf .Data [_fedg ],0xff,_gfbe );_fedg +=_ceddf .BytesPerLine ;};};case PixNotDst :for _edea =0;
_edea < _cegbf ;_edea ++{_ceddf .Data [_efaf ]=_fddd (_ceddf .Data [_efaf ],^_ceddf .Data [_efaf ],_dgbag );_efaf +=_ceddf .BytesPerLine ;};if _ceac {for _edea =0;_edea < _cegbf ;_edea ++{for _geff =0;_geff < _degbe ;_geff ++{_ceddf .Data [_gdfc +_geff ]=^(_ceddf .Data [_gdfc +_geff ]);
};_gdfc +=_ceddf .BytesPerLine ;};};if _fbaa {for _edea =0;_edea < _cegbf ;_edea ++{_ceddf .Data [_fedg ]=_fddd (_ceddf .Data [_fedg ],^_ceddf .Data [_fedg ],_gfbe );_fedg +=_ceddf .BytesPerLine ;};};};};var _ _g .Image =&Gray2 {};func (_bdbg *NRGBA32 )NRGBAAt (x ,y int )_f .NRGBA {_bfab ,_ :=ColorAtNRGBA32 (x ,y ,_bdbg .Width ,_bdbg .Data ,_bdbg .Alpha ,_bdbg .Decode );
return _bfab ;};var (MonochromeConverter =ConverterFunc (_bcf );Gray2Converter =ConverterFunc (_dgfb );Gray4Converter =ConverterFunc (_cbdf );GrayConverter =ConverterFunc (_daa );Gray16Converter =ConverterFunc (_dgae );NRGBA16Converter =ConverterFunc (_acegf );
NRGBAConverter =ConverterFunc (_ebfb );NRGBA64Converter =ConverterFunc (_ggab );RGBAConverter =ConverterFunc (_bcfdf );CMYKConverter =ConverterFunc (_dfaa ););func (_dbeaa *Gray16 )ColorModel ()_f .Model {return _f .Gray16Model };func _bgac (_bbcc _g .Image ,_agbg Image ,_eafcb _g .Rectangle ){if _bedce ,_abeb :=_bbcc .(SMasker );
_abeb &&_bedce .HasAlpha (){_agbg .(SMasker ).MakeAlpha ();};switch _beaf :=_bbcc .(type ){case Gray :_dega (_beaf ,_agbg .(NRGBA ),_eafcb );case NRGBA :_aece (_beaf ,_agbg .(NRGBA ),_eafcb );case *_g .NYCbCrA :_dddfc (_beaf ,_agbg .(NRGBA ),_eafcb );case CMYK :_gacb (_beaf ,_agbg .(NRGBA ),_eafcb );
case RGBA :_debc (_beaf ,_agbg .(NRGBA ),_eafcb );case nrgba64 :_bdff (_beaf ,_agbg .(NRGBA ),_eafcb );default:_agee (_bbcc ,_agbg ,_eafcb );};};func (_ggcdd *Gray8 )Set (x ,y int ,c _f .Color ){_gaee :=y *_ggcdd .BytesPerLine +x ;if _gaee > len (_ggcdd .Data )-1{return ;
};_ddbb :=_f .GrayModel .Convert (c );_ggcdd .Data [_gaee ]=_ddbb .(_f .Gray ).Y ;};func _cge ()(_dc [256]uint32 ){for _bcd :=0;_bcd < 256;_bcd ++{if _bcd &0x01!=0{_dc [_bcd ]|=0xf;};if _bcd &0x02!=0{_dc [_bcd ]|=0xf0;};if _bcd &0x04!=0{_dc [_bcd ]|=0xf00;
};if _bcd &0x08!=0{_dc [_bcd ]|=0xf000;};if _bcd &0x10!=0{_dc [_bcd ]|=0xf0000;};if _bcd &0x20!=0{_dc [_bcd ]|=0xf00000;};if _bcd &0x40!=0{_dc [_bcd ]|=0xf000000;};if _bcd &0x80!=0{_dc [_bcd ]|=0xf0000000;};};return _dc ;};func (_cbcf *NRGBA16 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_cbcf .Width ,Y :_cbcf .Height }};
};func (_gaeb *Monochrome )setGrayBit (_aebc ,_ebaad int ){_gaeb .Data [_aebc ]|=0x80>>uint (_ebaad &7)};var _ Gray =&Gray2 {};func (_afcb *Gray4 )Set (x ,y int ,c _f .Color ){if x >=_afcb .Width ||y >=_afcb .Height {return ;};_ddbf :=Gray4Model .Convert (c ).(_f .Gray );
_afcb .setGray (x ,y ,_ddbf );};func (_dfaf *ImageBase )HasAlpha ()bool {if _dfaf .Alpha ==nil {return false ;};for _bce :=range _dfaf .Alpha {if _dfaf .Alpha [_bce ]!=0xff{return true ;};};return false ;};func _fddd (_fadba ,_caga ,_bdef byte )byte {return (_fadba &^(_bdef ))|(_caga &_bdef )};
func (_ebfe *NRGBA64 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_ebfe .Width ,Y :_ebfe .Height }};};type CMYK interface{CMYKAt (_ccd ,_dfg int )_f .CMYK ;SetCMYK (_bca ,_gbgf int ,_dfgc _f .CMYK );};var _ Image =&CMYK32 {};func (_acfe *Gray16 )SetGray (x ,y int ,g _f .Gray ){_bdbd :=(y *_acfe .BytesPerLine /2+x )*2;
if _bdbd +1>=len (_acfe .Data ){return ;};_acfe .Data [_bdbd ]=g .Y ;_acfe .Data [_bdbd +1]=g .Y ;};func (_face *RGBA32 )Validate ()error {if len (_face .Data )!=3*_face .Width *_face .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _fcg (_caf *Monochrome ,_dce ...int )(_afe *Monochrome ,_eec error ){if _caf ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};
if len (_dce )==0{return nil ,_d .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_eba :=_gefg ();_afe =_caf ;for _ ,_aea :=range _dce {if _aea <=0{break ;};_afe ,_eec =_gccd (_afe ,_aea ,_eba );if _eec !=nil {return nil ,_eec ;};};return _afe ,nil ;};func _dfaa (_cfdc _g .Image )(Image ,error ){if _ggg ,_aeaf :=_cfdc .(*CMYK32 );
_aeaf {return _ggg .Copy (),nil ;};_bgc :=_cfdc .Bounds ();_eac ,_gda :=NewImage (_bgc .Max .X ,_bgc .Max .Y ,8,4,nil ,nil ,nil );if _gda !=nil {return nil ,_gda ;};switch _agg :=_cfdc .(type ){case CMYK :_ebd (_agg ,_eac .(CMYK ),_bgc );case Gray :_dfgb (_agg ,_eac .(CMYK ),_bgc );
case NRGBA :_edgd (_agg ,_eac .(CMYK ),_bgc );case RGBA :_efe (_agg ,_eac .(CMYK ),_bgc );default:_agee (_cfdc ,_eac ,_bgc );};return _eac ,nil ;};func _gfgd (_egad _g .Image ,_cggee uint8 )*_g .Gray {_cedac :=_egad .Bounds ();_degd :=_g .NewGray (_cedac );
var (_ebda _f .Color ;_fbba _f .Gray ;);for _addc :=0;_addc < _cedac .Max .X ;_addc ++{for _cggb :=0;_cggb < _cedac .Max .Y ;_cggb ++{_ebda =_egad .At (_addc ,_cggb );_degd .Set (_addc ,_cggb ,_ebda );_fbba =_degd .GrayAt (_addc ,_cggb );_degd .SetGray (_addc ,_cggb ,_f .Gray {Y :_gfca (_fbba .Y ,_cggee )});
};};return _degd ;};func _bcgb (_ggad _g .Image ,_efgcc Image ,_aacc _g .Rectangle ){switch _gdbae :=_ggad .(type ){case Gray :_gede (_gdbae ,_efgcc .(Gray ),_aacc );case NRGBA :_ceed (_gdbae ,_efgcc .(Gray ),_aacc );case CMYK :_afde (_gdbae ,_efgcc .(Gray ),_aacc );
case RGBA :_ccde (_gdbae ,_efgcc .(Gray ),_aacc );default:_agee (_ggad ,_efgcc ,_aacc );};};func _ebea (_debd _g .Image ,_dedg Image ,_gdea _g .Rectangle ){if _gabg ,_dgedd :=_debd .(SMasker );_dgedd &&_gabg .HasAlpha (){_dedg .(SMasker ).MakeAlpha ();
};switch _daac :=_debd .(type ){case Gray :_edfd (_daac ,_dedg .(RGBA ),_gdea );case NRGBA :_cbba (_daac ,_dedg .(RGBA ),_gdea );case *_g .NYCbCrA :_dcfd (_daac ,_dedg .(RGBA ),_gdea );case CMYK :_dgdd (_daac ,_dedg .(RGBA ),_gdea );case RGBA :_bcad (_daac ,_dedg .(RGBA ),_gdea );
case nrgba64 :_fbbg (_daac ,_dedg .(RGBA ),_gdea );default:_agee (_debd ,_dedg ,_gdea );};};func _bdff (_cdbc nrgba64 ,_fbeaa NRGBA ,_cfbe _g .Rectangle ){for _dgcf :=0;_dgcf < _cfbe .Max .X ;_dgcf ++{for _gegb :=0;_gegb < _cfbe .Max .Y ;_gegb ++{_befd :=_cdbc .NRGBA64At (_dgcf ,_gegb );
_fbeaa .SetNRGBA (_dgcf ,_gegb ,_eecc (_befd ));};};};func (_gecb *ImageBase )setFourBytes (_cdgb int ,_fbcf uint32 )error {if _cdgb +3> len (_gecb .Data )-1{return _dd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_cdgb );
};_gecb .Data [_cdgb ]=byte ((_fbcf &0xff000000)>>24);_gecb .Data [_cdgb +1]=byte ((_fbcf &0xff0000)>>16);_gecb .Data [_cdgb +2]=byte ((_fbcf &0xff00)>>8);_gecb .Data [_cdgb +3]=byte (_fbcf &0xff);return nil ;};func (_ecga *NRGBA32 )Base ()*ImageBase {return &_ecga .ImageBase };
func (_ggce *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ggce .copy ()}};func (_daeb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_daeb .copy ()}};func (_fccg *NRGBA64 )NRGBA64At (x ,y int )_f .NRGBA64 {_cfec ,_ :=ColorAtNRGBA64 (x ,y ,_fccg .Width ,_fccg .Data ,_fccg .Alpha ,_fccg .Decode );
return _cfec ;};var _ _g .Image =&RGBA32 {};type Image interface{_e .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_aaf ,_edbe int )(_f .Color ,error );Validate ()error ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _cebb (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func _aeb ()(_bgeb [256]uint16 ){for _bc :=0;_bc < 256;_bc ++{if _bc &0x01!=0{_bgeb [_bc ]|=0x3;};if _bc &0x02!=0{_bgeb [_bc ]|=0xc;};if _bc &0x04!=0{_bgeb [_bc ]|=0x30;};if _bc &0x08!=0{_bgeb [_bc ]|=0xc0;};if _bc &0x10!=0{_bgeb [_bc ]|=0x300;};if _bc &0x20!=0{_bgeb [_bc ]|=0xc00;
};if _bc &0x40!=0{_bgeb [_bc ]|=0x3000;};if _bc &0x80!=0{_bgeb [_bc ]|=0xc000;};};return _bgeb ;};func _gad (_ebag _f .NRGBA )_f .Gray {var _ccb _f .NRGBA ;if _ebag ==_ccb {return _f .Gray {Y :0xff};};_agf ,_aadc ,_ebe ,_ :=_ebag .RGBA ();_acg :=(19595*_agf +38470*_aadc +7471*_ebe +1<<15)>>24;
return _f .Gray {Y :uint8 (_acg )};};var (Gray2Model =_f .ModelFunc (_aab );Gray4Model =_f .ModelFunc (_cdc );NRGBA16Model =_f .ModelFunc (_gebf ););func (_cbe *Gray2 )Validate ()error {if len (_cbe .Data )!=_cbe .Height *_cbe .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_cfgd *RGBA32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtRGBA32 (x ,y ,_cfgd .Width ,_cfgd .Data ,_cfgd .Alpha ,_cfgd .Decode );
};func (_bagc *Gray8 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray8BPC (x ,y ,_bagc .BytesPerLine ,_bagc .Data ,_bagc .Decode );};func (_fcea *CMYK32 )Set (x ,y int ,c _f .Color ){_afcf :=4*(y *_fcea .Width +x );if _afcf +3>=len (_fcea .Data ){return ;
};_fg :=_f .CMYKModel .Convert (c ).(_f .CMYK );_fcea .Data [_afcf ]=_fg .C ;_fcea .Data [_afcf +1]=_fg .M ;_fcea .Data [_afcf +2]=_fg .Y ;_fcea .Data [_afcf +3]=_fg .K ;};func _cdb (_dac int )[]uint {var _bfc []uint ;_dae :=_dac ;_beag :=_dae /8;if _beag !=0{for _fd :=0;
_fd < _beag ;_fd ++{_bfc =append (_bfc ,8);};_cfg :=_dae %8;_dae =0;if _cfg !=0{_dae =_cfg ;};};_fac :=_dae /4;if _fac !=0{for _ab :=0;_ab < _fac ;_ab ++{_bfc =append (_bfc ,4);};_dbea :=_dae %4;_dae =0;if _dbea !=0{_dae =_dbea ;};};_deb :=_dae /2;if _deb !=0{for _ddfe :=0;
_ddfe < _deb ;_ddfe ++{_bfc =append (_bfc ,2);};};return _bfc ;};func (_cece *Gray2 )ColorModel ()_f .Model {return Gray2Model };func (_edcb *NRGBA32 )SetNRGBA (x ,y int ,c _f .NRGBA ){_fgef :=y *_edcb .Width +x ;_ceff :=3*_fgef ;if _ceff +2>=len (_edcb .Data ){return ;
};_edcb .setRGBA (_fgef ,c );};type nrgba64 interface{NRGBA64At (_bcae ,_gbb int )_f .NRGBA64 ;SetNRGBA64 (_bad ,_adcgg int ,_dcdde _f .NRGBA64 );};func (_bgfe *NRGBA16 )At (x ,y int )_f .Color {_ddccb ,_ :=_bgfe .ColorAt (x ,y );return _ddccb };func _eaeg (_ddeg _f .Gray )_f .RGBA {return _f .RGBA {R :_ddeg .Y ,G :_ddeg .Y ,B :_ddeg .Y ,A :0xff}};
func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_b :=BytesPerLine (width ,8,1);if len (data )< _b *height {return nil ,nil ;};_df :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_be ,_eg :=MonochromeConverter .Convert (_df );
if _eg !=nil {return nil ,_eg ;};return _be .Base ().Data ,nil ;};func _gacb (_dgea CMYK ,_cgbbc NRGBA ,_adafg _g .Rectangle ){for _bcfd :=0;_bcfd < _adafg .Max .X ;_bcfd ++{for _cada :=0;_cada < _adafg .Max .Y ;_cada ++{_adacb :=_dgea .CMYKAt (_bcfd ,_cada );
_cgbbc .SetNRGBA (_bcfd ,_cada ,_gggg (_adacb ));};};};func (_eaed *Monochrome )Histogram ()(_acegb [256]int ){for _ ,_begc :=range _eaed .Data {_acegb [0xff]+=int (_fcge [_eaed .Data [_begc ]]);};return _acegb ;};func (_eae *CMYK32 )Base ()*ImageBase {return &_eae .ImageBase };
func _dgdd (_bbedg CMYK ,_ffcf RGBA ,_gfaf _g .Rectangle ){for _efacb :=0;_efacb < _gfaf .Max .X ;_efacb ++{for _bdfd :=0;_bdfd < _gfaf .Max .Y ;_bdfd ++{_gdfbf :=_bbedg .CMYKAt (_efacb ,_bdfd );_ffcf .SetRGBA (_efacb ,_bdfd ,_aae (_gdfbf ));};};};func (_bdde *NRGBA16 )ColorModel ()_f .Model {return NRGBA16Model };
func (_gddg *Monochrome )getBitAt (_baf ,_agda int )bool {_cgbb :=_agda *_gddg .BytesPerLine +(_baf >>3);_dcc :=_baf &0x07;_aaa :=uint (7-_dcc );if _cgbb > len (_gddg .Data )-1{return false ;};if (_gddg .Data [_cgbb ]>>_aaa )&0x01>=1{return true ;};return false ;
};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_cfgf :=y *width +x ;_agcc :=3*_cfgf ;if _agcc +2>=len (data ){return _f .NRGBA {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fadc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cfgf {_fadc =alpha [_cfgf ];};_dagg ,_gcee ,_cbbe :=data [_agcc ],data [_agcc +1],data [_agcc +2];if len (decode )==6{_bddf :=LinearInterpolate (float64 (_dagg ),0,255.0,decode [0],decode [1]);_fbac :=LinearInterpolate (float64 (_gcee ),0,255.0,decode [2],decode [3]);
_eefge :=LinearInterpolate (float64 (_cbbe ),0,255.0,decode [4],decode [5]);if _bddf <=1.0&&_fbac <=1.0&&_eefge <=1.0{_bddf *=255.0;_fbac *=255.0;_eefge *=255.0;};_dagg =uint8 (_bddf )&0xff;_gcee =uint8 (_fbac )&0xff;_cbbe =uint8 (_eefge )&0xff;};return _f .NRGBA {R :_dagg ,G :_gcee ,B :_cbbe ,A :_fadc },nil ;
};func (_fcbf *Gray2 )Histogram ()(_ddbg [256]int ){for _adcf :=0;_adcf < _fcbf .Width ;_adcf ++{for _dfcf :=0;_dfcf < _fcbf .Height ;_dfcf ++{_ddbg [_fcbf .GrayAt (_adcf ,_dfcf ).Y ]++;};};return _ddbg ;};func ImgToGray (i _g .Image )*_g .Gray {if _cdbdd ,_feca :=i .(*_g .Gray );
_feca {return _cdbdd ;};_ecdb :=i .Bounds ();_ddcec :=_g .NewGray (_ecdb );for _gdgf :=0;_gdgf < _ecdb .Max .X ;_gdgf ++{for _bfee :=0;_bfee < _ecdb .Max .Y ;_bfee ++{_degf :=i .At (_gdgf ,_bfee );_ddcec .Set (_gdgf ,_bfee ,_degf );};};return _ddcec ;};
func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_adac :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_adac .Data =make ([]byte ,height *_adac .BytesPerLine );};return _adac ;};func _debc (_caacg RGBA ,_cdbda NRGBA ,_agag _g .Rectangle ){for _gfaa :=0;_gfaa < _agag .Max .X ;_gfaa ++{for _fegb :=0;_fegb < _agag .Max .Y ;_fegb ++{_edfe :=_caacg .RGBAAt (_gfaa ,_fegb );
_cdbda .SetNRGBA (_gfaa ,_fegb ,_bfcd (_edfe ));};};};func _efe (_gge RGBA ,_afbf CMYK ,_dged _g .Rectangle ){for _cdbd :=0;_cdbd < _dged .Max .X ;_cdbd ++{for _bdc :=0;_bdc < _dged .Max .Y ;_bdc ++{_cac :=_gge .RGBAAt (_cdbd ,_bdc );_afbf .SetCMYK (_cdbd ,_bdc ,_bfdc (_cac ));
};};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_geaa (n )+1);};func (_cfgg *Monochrome )AddPadding ()(_bgga error ){if _bdba :=((_cfgg .Width *_cfgg .Height )+7)>>3;len (_cfgg .Data )< _bdba {return _dd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_cfgg .Data ),_bdba );
};_faa :=_cfgg .Width %8;if _faa ==0{return nil ;};_cgfc :=_cfgg .Width /8;_aceg :=_fe .NewReader (_cfgg .Data );_dgc :=make ([]byte ,_cfgg .Height *_cfgg .BytesPerLine );_aage :=_fe .NewWriterMSB (_dgc );_fcc :=make ([]byte ,_cgfc );var (_efd int ;_gae uint64 ;
);for _efd =0;_efd < _cfgg .Height ;_efd ++{if _ ,_bgga =_aceg .Read (_fcc );_bgga !=nil {return _bgga ;};if _ ,_bgga =_aage .Write (_fcc );_bgga !=nil {return _bgga ;};if _gae ,_bgga =_aceg .ReadBits (byte (_faa ));_bgga !=nil {return _bgga ;};if _bgga =_aage .WriteByte (byte (_gae )<<uint (8-_faa ));
_bgga !=nil {return _bgga ;};};_cfgg .Data =_aage .Data ();return nil ;};func (_bccd *Gray16 )Validate ()error {if len (_bccd .Data )!=_bccd .Height *_bccd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA64 ,error ){_bbca :=(y *width +x )*2;
_addg :=_bbca *3;if _addg +5>=len (data ){return _f .NRGBA64 {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _gbgb =0xffff;_eadb :=uint16 (_gbgb );if alpha !=nil &&len (alpha )> _bbca +1{_eadb =uint16 (alpha [_bbca ])<<8|uint16 (alpha [_bbca +1]);};_egebc :=uint16 (data [_addg ])<<8|uint16 (data [_addg +1]);_fccgb :=uint16 (data [_addg +2])<<8|uint16 (data [_addg +3]);
_aagb :=uint16 (data [_addg +4])<<8|uint16 (data [_addg +5]);if len (decode )==6{_egebc =uint16 (uint64 (LinearInterpolate (float64 (_egebc ),0,65535,decode [0],decode [1]))&_gbgb );_fccgb =uint16 (uint64 (LinearInterpolate (float64 (_fccgb ),0,65535,decode [2],decode [3]))&_gbgb );
_aagb =uint16 (uint64 (LinearInterpolate (float64 (_aagb ),0,65535,decode [4],decode [5]))&_gbgb );};return _f .NRGBA64 {R :_egebc ,G :_fccgb ,B :_aagb ,A :_eadb },nil ;};func (_dacg *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dacg .ImageBase .copy (),ModelThreshold :_dacg .ModelThreshold };
};func (_dfedb *NRGBA64 )Set (x ,y int ,c _f .Color ){_becd :=(y *_dfedb .Width +x )*2;_eadcc :=_becd *3;if _eadcc +5>=len (_dfedb .Data ){return ;};_fbg :=_f .NRGBA64Model .Convert (c ).(_f .NRGBA64 );_dfedb .setNRGBA64 (_eadcc ,_fbg ,_becd );};type Monochrome struct{ImageBase ;
ModelThreshold uint8 ;};func (_dgba *CMYK32 )CMYKAt (x ,y int )_f .CMYK {_gcba ,_ :=ColorAtCMYK (x ,y ,_dgba .Width ,_dgba .Data ,_dgba .Decode );return _gcba ;};func (_gcf colorConverter )Convert (src _g .Image )(Image ,error ){return _gcf ._gdaf (src )};
func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func GrayHistogram (g Gray )(_bgcf [256]int ){switch _fbgd :=g .(type ){case Histogramer :return _fbgd .Histogram ();case _g .Image :_eeea :=_fbgd .Bounds ();for _gafd :=0;_gafd < _eeea .Max .X ;
_gafd ++{for _aadea :=0;_aadea < _eeea .Max .Y ;_aadea ++{_bgcf [g .GrayAt (_gafd ,_aadea ).Y ]++;};};return _bgcf ;default:return [256]int {};};};func _edd (_defa _f .NYCbCrA )_f .NRGBA {_deda :=int32 (_defa .Y )*0x10101;_caa :=int32 (_defa .Cb )-128;
_fgd :=int32 (_defa .Cr )-128;_gabca :=_deda +91881*_fgd ;if uint32 (_gabca )&0xff000000==0{_gabca >>=8;}else {_gabca =^(_gabca >>31)&0xffff;};_faee :=_deda -22554*_caa -46802*_fgd ;if uint32 (_faee )&0xff000000==0{_faee >>=8;}else {_faee =^(_faee >>31)&0xffff;
};_ecbc :=_deda +116130*_caa ;if uint32 (_ecbc )&0xff000000==0{_ecbc >>=8;}else {_ecbc =^(_ecbc >>31)&0xffff;};return _f .NRGBA {R :uint8 (_gabca >>8),G :uint8 (_faee >>8),B :uint8 (_ecbc >>8),A :_defa .A };};func (_cegf *Monochrome )setBit (_eada ,_gfdd int ){_cegf .Data [_eada +(_gfdd >>3)]|=0x80>>uint (_gfdd &7);
};func (_gac *Monochrome )At (x ,y int )_f .Color {_becf ,_ :=_gac .ColorAt (x ,y );return _becf };func _fgacc (_cfeg int ,_bfec int )int {if _cfeg < _bfec {return _cfeg ;};return _bfec ;};var _ _g .Image =&Gray8 {};type Gray16 struct{ImageBase };func (_acec *Gray4 )Validate ()error {if len (_acec .Data )!=_acec .Height *_acec .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _acca (_fafe *_g .Gray ,_gebe uint8 )*_g .Gray {_ggee :=_fafe .Bounds ();_cggf :=_g .NewGray (_ggee );for _abeec :=0;_abeec < _ggee .Dx ();_abeec ++{for _cdce :=0;_cdce < _ggee .Dy ();_cdce ++{_cbdd :=_fafe .GrayAt (_abeec ,_cdce );
_cggf .SetGray (_abeec ,_cdce ,_f .Gray {Y :_gfca (_cbdd .Y ,_gebe )});};};return _cggf ;};type Histogramer interface{Histogram ()[256]int ;};func (_fgba *Gray8 )GrayAt (x ,y int )_f .Gray {_bbacc ,_ :=ColorAtGray8BPC (x ,y ,_fgba .BytesPerLine ,_fgba .Data ,_fgba .Decode );
return _bbacc ;};func _dgae (_agc _g .Image )(Image ,error ){if _eead ,_daaa :=_agc .(*Gray16 );_daaa {return _eead .Copy (),nil ;};_bdf :=_agc .Bounds ();_gfbc ,_dbd :=NewImage (_bdf .Max .X ,_bdf .Max .Y ,16,1,nil ,nil ,nil );if _dbd !=nil {return nil ,_dbd ;
};_bcgb (_agc ,_gfbc ,_bdf );return _gfbc ,nil ;};func _gea (_fff _f .NRGBA )_f .Gray {_ggb ,_cedd ,_ecg ,_ :=_fff .RGBA ();_cfge :=(19595*_ggb +38470*_cedd +7471*_ecg +1<<15)>>24;return _f .Gray {Y :uint8 (_cfge )};};func _agee (_edf _g .Image ,_gfda Image ,_ddfb _g .Rectangle ){for _fgg :=0;
_fgg < _ddfb .Max .X ;_fgg ++{for _fbbbc :=0;_fbbbc < _ddfb .Max .Y ;_fbbbc ++{_gce :=_edf .At (_fgg ,_fbbbc );_gfda .Set (_fgg ,_fbbbc ,_gce );};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _ffde (_ggeg uint8 )bool {if _ggeg ==0||_ggeg ==255{return true ;};return false ;};func _afde (_cdcb CMYK ,_bfca Gray ,_bfcae _g .Rectangle ){for _ebdc :=0;_ebdc < _bfcae .Max .X ;_ebdc ++{for _eccd :=0;_eccd < _bfcae .Max .Y ;_eccd ++{_gbgd :=_gga (_cdcb .CMYKAt (_ebdc ,_eccd ));
_bfca .SetGray (_ebdc ,_eccd ,_gbgd );};};};func (_caaf *Gray4 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray4BPC (x ,y ,_caaf .BytesPerLine ,_caaf .Data ,_caaf .Decode );};func _geaa (_aafe uint )uint {var _bgeg uint ;for _aafe !=0{_aafe >>=1;
_bgeg ++;};return _bgeg -1;};func _cca (_bga ,_aag *Monochrome ,_bd []byte ,_efaa int )(_cedb error ){var (_bbc ,_dbead ,_bfb ,_aeg ,_ace ,_adb ,_ccg ,_gef int ;_faege ,_ede ,_dffa ,_afea uint32 ;_fce ,_afc byte ;_cfgb uint16 ;);_cba :=make ([]byte ,4);
_edg :=make ([]byte ,4);for _bfb =0;_bfb < _bga .Height -1;_bfb ,_aeg =_bfb +2,_aeg +1{_bbc =_bfb *_bga .BytesPerLine ;_dbead =_aeg *_aag .BytesPerLine ;for _ace ,_adb =0,0;_ace < _efaa ;_ace ,_adb =_ace +4,_adb +1{for _ccg =0;_ccg < 4;_ccg ++{_gef =_bbc +_ace +_ccg ;
if _gef <=len (_bga .Data )-1&&_gef < _bbc +_bga .BytesPerLine {_cba [_ccg ]=_bga .Data [_gef ];}else {_cba [_ccg ]=0x00;};_gef =_bbc +_bga .BytesPerLine +_ace +_ccg ;if _gef <=len (_bga .Data )-1&&_gef < _bbc +(2*_bga .BytesPerLine ){_edg [_ccg ]=_bga .Data [_gef ];
}else {_edg [_ccg ]=0x00;};};_faege =_ed .BigEndian .Uint32 (_cba );_ede =_ed .BigEndian .Uint32 (_edg );_dffa =_faege &_ede ;_dffa |=_dffa <<1;_afea =_faege |_ede ;_afea &=_afea <<1;_ede =_dffa |_afea ;_ede &=0xaaaaaaaa;_faege =_ede |(_ede <<7);_fce =byte (_faege >>24);
_afc =byte ((_faege >>8)&0xff);_gef =_dbead +_adb ;if _gef +1==len (_aag .Data )-1||_gef +1>=_dbead +_aag .BytesPerLine {if _cedb =_aag .setByte (_gef ,_bd [_fce ]);_cedb !=nil {return _dd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gef );
};}else {_cfgb =(uint16 (_bd [_fce ])<<8)|uint16 (_bd [_afc ]);if _cedb =_aag .setTwoBytes (_gef ,_cfgb );_cedb !=nil {return _dd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gef );
};_adb ++;};};};return nil ;};func _aece (_fcdg ,_bfdf NRGBA ,_fgea _g .Rectangle ){for _fde :=0;_fde < _fgea .Max .X ;_fde ++{for _febb :=0;_febb < _fgea .Max .Y ;_febb ++{_bfdf .SetNRGBA (_fde ,_febb ,_fcdg .NRGBAAt (_fde ,_febb ));};};};func _cfca (){for _fedf :=0;
_fedf < 256;_fedf ++{_fcge [_fedf ]=uint8 (_fedf &0x1)+(uint8 (_fedf >>1)&0x1)+(uint8 (_fedf >>2)&0x1)+(uint8 (_fedf >>3)&0x1)+(uint8 (_fedf >>4)&0x1)+(uint8 (_fedf >>5)&0x1)+(uint8 (_fedf >>6)&0x1)+(uint8 (_fedf >>7)&0x1);};};func (_egab *monochromeThresholdConverter )Convert (img _g .Image )(Image ,error ){if _eed ,_fdfd :=img .(*Monochrome );
_fdfd {return _eed .Copy (),nil ;};_gccf :=img .Bounds ();_dcg ,_edfa :=NewImage (_gccf .Max .X ,_gccf .Max .Y ,1,1,nil ,nil ,nil );if _edfa !=nil {return nil ,_edfa ;};_dcg .(*Monochrome ).ModelThreshold =_egab .Threshold ;for _cbd :=0;_cbd < _gccf .Max .X ;
_cbd ++{for _cab :=0;_cab < _gccf .Max .Y ;_cab ++{_agdb :=img .At (_cbd ,_cab );_dcg .Set (_cbd ,_cab ,_agdb );};};return _dcg ,nil ;};var _ NRGBA =&NRGBA32 {};func _aeaa (_bdd ,_ceb *Monochrome ,_bbe []byte ,_fedd int )(_dab error ){var (_gec ,_ffe ,_facb ,_ade ,_fca ,_cgf ,_ecb ,_gee int ;
_daec ,_ddgf uint32 ;_afb ,_cfd byte ;_ecf uint16 ;);_gece :=make ([]byte ,4);_efbe :=make ([]byte ,4);for _facb =0;_facb < _bdd .Height -1;_facb ,_ade =_facb +2,_ade +1{_gec =_facb *_bdd .BytesPerLine ;_ffe =_ade *_ceb .BytesPerLine ;for _fca ,_cgf =0,0;
_fca < _fedd ;_fca ,_cgf =_fca +4,_cgf +1{for _ecb =0;_ecb < 4;_ecb ++{_gee =_gec +_fca +_ecb ;if _gee <=len (_bdd .Data )-1&&_gee < _gec +_bdd .BytesPerLine {_gece [_ecb ]=_bdd .Data [_gee ];}else {_gece [_ecb ]=0x00;};_gee =_gec +_bdd .BytesPerLine +_fca +_ecb ;
if _gee <=len (_bdd .Data )-1&&_gee < _gec +(2*_bdd .BytesPerLine ){_efbe [_ecb ]=_bdd .Data [_gee ];}else {_efbe [_ecb ]=0x00;};};_daec =_ed .BigEndian .Uint32 (_gece );_ddgf =_ed .BigEndian .Uint32 (_efbe );_ddgf &=_daec ;_ddgf &=_ddgf <<1;_ddgf &=0xaaaaaaaa;
_daec =_ddgf |(_ddgf <<7);_afb =byte (_daec >>24);_cfd =byte ((_daec >>8)&0xff);_gee =_ffe +_cgf ;if _gee +1==len (_ceb .Data )-1||_gee +1>=_ffe +_ceb .BytesPerLine {_ceb .Data [_gee ]=_bbe [_afb ];if _dab =_ceb .setByte (_gee ,_bbe [_afb ]);_dab !=nil {return _dd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gee );
};}else {_ecf =(uint16 (_bbe [_afb ])<<8)|uint16 (_bbe [_cfd ]);if _dab =_ceb .setTwoBytes (_gee ,_ecf );_dab !=nil {return _dd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gee );
};_cgf ++;};};};return nil ;};func _gdde (_agfc _f .Gray )_f .CMYK {return _f .CMYK {K :0xff-_agfc .Y }};func _cff (_aeed _f .NRGBA )_f .CMYK {_ffge ,_efgf ,_ecbb ,_ :=_aeed .RGBA ();_aga ,_gabef ,_cbc ,_bgcd :=_f .RGBToCMYK (uint8 (_ffge >>8),uint8 (_efgf >>8),uint8 (_ecbb >>8));
return _f .CMYK {C :_aga ,M :_gabef ,Y :_cbc ,K :_bgcd };};func ConverterFunc (converterFunc func (_eeg _g .Image )(Image ,error ))ColorConverter {return colorConverter {_gdaf :converterFunc };};func _cbba (_gcab NRGBA ,_egac RGBA ,_bcbe _g .Rectangle ){for _cggc :=0;
_cggc < _bcbe .Max .X ;_cggc ++{for _cfgga :=0;_cfgga < _bcbe .Max .Y ;_cfgga ++{_dcaa :=_gcab .NRGBAAt (_cggc ,_cfgga );_egac .SetRGBA (_cggc ,_cfgga ,_gceg (_dcaa ));};};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray16 ,error ){_bccf :=(y *bytesPerLine /2+x )*2;
if _bccf +1>=len (data ){return _f .Gray16 {},_dd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_deed :=uint16 (data [_bccf ])<<8|uint16 (data [_bccf +1]);if len (decode )==2{_deed =uint16 (uint64 (LinearInterpolate (float64 (_deed ),0,65535,decode [0],decode [1])));};return _f .Gray16 {Y :_deed },nil ;};func (_baac *NRGBA64 )SetNRGBA64 (x ,y int ,c _f .NRGBA64 ){_baef :=(y *_baac .Width +x )*2;
_cefg :=_baef *3;if _cefg +5>=len (_baac .Data ){return ;};_baac .setNRGBA64 (_cefg ,c ,_baef );};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};var _ Gray =&Gray16 {};func (_bccda *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _cebb (_bccda ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_beb *Gray8 )Validate ()error {if len (_beb .Data )!=_beb .Height *_beb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_efdg *NRGBA64 )Base ()*ImageBase {return &_efdg .ImageBase };func (_effe *NRGBA64 )At (x ,y int )_f .Color {_bbfb ,_ :=_effe .ColorAt (x ,y );
return _bbfb };func _edfd (_fggb Gray ,_fbae RGBA ,_cdeed _g .Rectangle ){for _ddbd :=0;_ddbd < _cdeed .Max .X ;_ddbd ++{for _cadgg :=0;_cadgg < _cdeed .Max .Y ;_cadgg ++{_abcg :=_fggb .GrayAt (_ddbd ,_cadgg );_fbae .SetRGBA (_ddbd ,_cadgg ,_eaeg (_abcg ));
};};};func _dfgb (_ecc Gray ,_cgd CMYK ,_fcfa _g .Rectangle ){for _gfd :=0;_gfd < _fcfa .Max .X ;_gfd ++{for _bag :=0;_bag < _fcfa .Max .Y ;_bag ++{_gbed :=_ecc .GrayAt (_gfd ,_bag );_cgd .SetCMYK (_gfd ,_bag ,_gdde (_gbed ));};};};func (_cag *Monochrome )IsUnpadded ()bool {return (_cag .Width *_cag .Height )==len (_cag .Data )};
func (_bde *Gray16 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_bde .Width ,Y :_bde .Height }};};type Gray2 struct{ImageBase };func (_cee *Monochrome )SetGray (x ,y int ,g _f .Gray ){_eafc :=y *_cee .BytesPerLine +x >>3;if _eafc > len (_cee .Data )-1{return ;
};g =_ggcg (g ,monochromeModel (_cee .ModelThreshold ));_cee .setGray (x ,g ,_eafc );};func (_cegg *NRGBA16 )setNRGBA (_afdaf ,_bcdg ,_eaeb int ,_eabe _f .NRGBA ){if _afdaf *3%2==0{_cegg .Data [_eaeb ]=(_eabe .R >>4)<<4|(_eabe .G >>4);_cegg .Data [_eaeb +1]=(_eabe .B >>4)<<4|(_cegg .Data [_eaeb +1]&0xf);
}else {_cegg .Data [_eaeb ]=(_cegg .Data [_eaeb ]&0xf0)|(_eabe .R >>4);_cegg .Data [_eaeb +1]=(_eabe .G >>4)<<4|(_eabe .B >>4);};if _cegg .Alpha !=nil {_ebgg :=_bcdg *BytesPerLine (_cegg .Width ,4,1);if _ebgg < len (_cegg .Alpha ){if _afdaf %2==0{_cegg .Alpha [_ebgg ]=(_eabe .A >>uint (4))<<uint (4)|(_cegg .Alpha [_eaeb ]&0xf);
}else {_cegg .Alpha [_ebgg ]=(_cegg .Alpha [_ebgg ]&0xf0)|(_eabe .A >>uint (4));};};};};var _ NRGBA =&NRGBA16 {};func _cd (_ff *Monochrome ,_bb int ,_ba []uint )(*Monochrome ,error ){_ef :=_bb *_ff .Width ;_af :=_bb *_ff .Height ;_ffb :=_dbeb (_ef ,_af );
for _gb ,_aee :=range _ba {var _de error ;switch _aee {case 2:_de =_ffbe (_ffb ,_ff );case 4:_de =_ebg (_ffb ,_ff );case 8:_de =_eaf (_ffb ,_ff );};if _de !=nil {return nil ,_de ;};if _gb !=len (_ba )-1{_ff =_ffb .copy ();};};return _ffb ,nil ;};func (_acda *Gray2 )SetGray (x ,y int ,gray _f .Gray ){_dbeg :=_ddcd (gray );
_beec :=y *_acda .BytesPerLine ;_deg :=_beec +(x >>2);if _deg >=len (_acda .Data ){return ;};_fgf :=_dbeg .Y >>6;_acda .Data [_deg ]=(_acda .Data [_deg ]&(^(0xc0>>uint (2*((x )&3)))))|(_fgf <<uint (6-2*(x &3)));};func (_eebgc *Monochrome )clearBit (_bcfg ,_bdg int ){_eebgc .Data [_bcfg ]&=^(0x80>>uint (_bdg &7))};
func _eaa (_dca *Monochrome ,_gddf ,_gbcb ,_begb ,_ebc int ,_afbg RasterOperator ,_egec *Monochrome ,_dfdf ,_eebe int )error {var (_acee bool ;_cbbd bool ;_cacd int ;_fee int ;_bbgd int ;_eecb bool ;_aba byte ;_eafe int ;_fabd int ;_cdff int ;_aegb ,_cgefc int ;
);_cfbd :=8-(_gddf &7);_efebf :=_aabf [_cfbd ];_edffa :=_dca .BytesPerLine *_gbcb +(_gddf >>3);_fceb :=_egec .BytesPerLine *_eebe +(_dfdf >>3);if _begb < _cfbd {_acee =true ;_efebf &=_aggg [8-_cfbd +_begb ];};if !_acee {_cacd =(_begb -_cfbd )>>3;if _cacd > 0{_cbbd =true ;
_fee =_edffa +1;_bbgd =_fceb +1;};};_eafe =(_gddf +_begb )&7;if !(_acee ||_eafe ==0){_eecb =true ;_aba =_aggg [_eafe ];_fabd =_edffa +1+_cacd ;_cdff =_fceb +1+_cacd ;};switch _afbg {case PixSrc :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],_egec .Data [_fceb ],_efebf );
_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]=_egec .Data [_bbgd +_cgefc ];};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;
};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],_egec .Data [_cdff ],_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixNotSrc :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],^_egec .Data [_fceb ],_efebf );
_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]=^_egec .Data [_bbgd +_cgefc ];};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;
};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],^_egec .Data [_cdff ],_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixSrcOrDst :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],_egec .Data [_fceb ]|_dca .Data [_edffa ],_efebf );
_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]|=_egec .Data [_bbgd +_cgefc ];};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;
};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],_egec .Data [_cdff ]|_dca .Data [_fabd ],_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixSrcAndDst :for _aegb =0;_aegb < _ebc ;
_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],_egec .Data [_fceb ]&_dca .Data [_edffa ],_efebf );_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]&=_egec .Data [_bbgd +_cgefc ];
};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],_egec .Data [_cdff ]&_dca .Data [_fabd ],_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;
};};case PixSrcXorDst :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],_egec .Data [_fceb ]^_dca .Data [_edffa ],_efebf );_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;
_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]^=_egec .Data [_bbgd +_cgefc ];};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],_egec .Data [_cdff ]^_dca .Data [_fabd ],_aba );
_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixNotSrcOrDst :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],^(_egec .Data [_fceb ])|_dca .Data [_edffa ],_efebf );_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;
};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]|=^(_egec .Data [_bbgd +_cgefc ]);};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],^(_egec .Data [_cdff ])|_dca .Data [_fabd ],_aba );
_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixNotSrcAndDst :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],^(_egec .Data [_fceb ])&_dca .Data [_edffa ],_efebf );_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;
};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]&=^_egec .Data [_bbgd +_cgefc ];};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],^(_egec .Data [_cdff ])&_dca .Data [_fabd ],_aba );
_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixSrcOrNotDst :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],_egec .Data [_fceb ]|^(_dca .Data [_edffa ]),_efebf );_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;
};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]=_egec .Data [_bbgd +_cgefc ]|^(_dca .Data [_fee +_cgefc ]);};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;
_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],_egec .Data [_cdff ]|^(_dca .Data [_fabd ]),_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixSrcAndNotDst :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],_egec .Data [_fceb ]&^(_dca .Data [_edffa ]),_efebf );
_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]=_egec .Data [_bbgd +_cgefc ]&^(_dca .Data [_fee +_cgefc ]);};_fee +=_dca .BytesPerLine ;
_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],_egec .Data [_cdff ]&^(_dca .Data [_fabd ]),_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixNotPixSrcOrDst :for _aegb =0;
_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],^(_egec .Data [_fceb ]|_dca .Data [_edffa ]),_efebf );_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;
_cgefc ++{_dca .Data [_fee +_cgefc ]=^(_egec .Data [_bbgd +_cgefc ]|_dca .Data [_fee +_cgefc ]);};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],^(_egec .Data [_cdff ]|_dca .Data [_fabd ]),_aba );
_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixNotPixSrcAndDst :for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],^(_egec .Data [_fceb ]&_dca .Data [_edffa ]),_efebf );_edffa +=_dca .BytesPerLine ;
_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]=^(_egec .Data [_bbgd +_cgefc ]&_dca .Data [_fee +_cgefc ]);};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;
};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],^(_egec .Data [_cdff ]&_dca .Data [_fabd ]),_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;};};case PixNotPixSrcXorDst :for _aegb =0;_aegb < _ebc ;
_aegb ++{_dca .Data [_edffa ]=_fddd (_dca .Data [_edffa ],^(_egec .Data [_fceb ]^_dca .Data [_edffa ]),_efebf );_edffa +=_dca .BytesPerLine ;_fceb +=_egec .BytesPerLine ;};if _cbbd {for _aegb =0;_aegb < _ebc ;_aegb ++{for _cgefc =0;_cgefc < _cacd ;_cgefc ++{_dca .Data [_fee +_cgefc ]=^(_egec .Data [_bbgd +_cgefc ]^_dca .Data [_fee +_cgefc ]);
};_fee +=_dca .BytesPerLine ;_bbgd +=_egec .BytesPerLine ;};};if _eecb {for _aegb =0;_aegb < _ebc ;_aegb ++{_dca .Data [_fabd ]=_fddd (_dca .Data [_fabd ],^(_egec .Data [_cdff ]^_dca .Data [_fabd ]),_aba );_fabd +=_dca .BytesPerLine ;_cdff +=_egec .BytesPerLine ;
};};default:_fa .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_afbg );return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _edgd (_bgf NRGBA ,_cea CMYK ,_defe _g .Rectangle ){for _gabe :=0;_gabe < _defe .Max .X ;_gabe ++{for _ffg :=0;_ffg < _defe .Max .Y ;_ffg ++{_dgd :=_bgf .NRGBAAt (_gabe ,_ffg );_cea .SetCMYK (_gabe ,_ffg ,_cff (_dgd ));};};};