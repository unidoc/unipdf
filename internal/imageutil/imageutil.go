//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_bb "encoding/binary";_a "errors";_bc "fmt";_fg "github.com/unidoc/unipdf/v4/common";_e "github.com/unidoc/unipdf/v4/internal/bitwise";_be "image";_f "image/color";_d "image/draw";_b "math";);func _eafe (_aggf _f .Color )_f .Color {_aeadc :=_f .NRGBAModel .Convert (_aggf ).(_f .NRGBA );
return _cced (_aeadc );};func (_acdf *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_acdf .copy ()}};func _bef (_bf ,_gfa *Monochrome )(_cg error ){_da :=_gfa .BytesPerLine ;_bg :=_bf .BytesPerLine ;var (_ga byte ;_ba uint16 ;_df ,_fcf ,_ed ,_fggg ,_cce int ;
);for _ed =0;_ed < _gfa .Height ;_ed ++{_df =_ed *_da ;_fcf =2*_ed *_bg ;for _fggg =0;_fggg < _da ;_fggg ++{_ga =_gfa .Data [_df +_fggg ];_ba =_baa [_ga ];_cce =_fcf +_fggg *2;if _bf .BytesPerLine !=_gfa .BytesPerLine *2&&(_fggg +1)*2> _bf .BytesPerLine {_cg =_bf .setByte (_cce ,byte (_ba >>8));
}else {_cg =_bf .setTwoBytes (_cce ,_ba );};if _cg !=nil {return _cg ;};};for _fggg =0;_fggg < _bg ;_fggg ++{_cce =_fcf +_bg +_fggg ;_ga =_bf .Data [_fcf +_fggg ];if _cg =_bf .setByte (_cce ,_ga );_cg !=nil {return _cg ;};};};return nil ;};func ImgToGray (i _be .Image )*_be .Gray {if _cdfc ,_dbfg :=i .(*_be .Gray );
_dbfg {return _cdfc ;};_gbgd :=i .Bounds ();_ddgdd :=_be .NewGray (_gbgd );for _ebac :=0;_ebac < _gbgd .Max .X ;_ebac ++{for _dfge :=0;_dfge < _gbgd .Max .Y ;_dfge ++{_ggedf :=i .At (_ebac ,_dfge );_ddgdd .Set (_ebac ,_dfge ,_ggedf );};};return _ddgdd ;
};func _bbf ()(_dfga [256]uint64 ){for _ag :=0;_ag < 256;_ag ++{if _ag &0x01!=0{_dfga [_ag ]|=0xff;};if _ag &0x02!=0{_dfga [_ag ]|=0xff00;};if _ag &0x04!=0{_dfga [_ag ]|=0xff0000;};if _ag &0x08!=0{_dfga [_ag ]|=0xff000000;};if _ag &0x10!=0{_dfga [_ag ]|=0xff00000000;
};if _ag &0x20!=0{_dfga [_ag ]|=0xff0000000000;};if _ag &0x40!=0{_dfga [_ag ]|=0xff000000000000;};if _ag &0x80!=0{_dfga [_ag ]|=0xff00000000000000;};};return _dfga ;};type shift int ;func (_abfc *ImageBase )Pix ()[]byte {return _abfc .Data };func (_deaec *ImageBase )setTwoBytes (_gfe int ,_aedc uint16 )error {if _gfe +1> len (_deaec .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_deaec .Data [_gfe ]=byte ((_aedc &0xff00)>>8);_deaec .Data [_gfe +1]=byte (_aedc &0xff);return nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_gdfdg :=y *bytesPerLine +x >>1;if _gdfdg >=len (data ){return _f .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_baed :=data [_gdfdg ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_baed =uint8 (uint32 (LinearInterpolate (float64 (_baed ),0,15,decode [0],decode [1]))&0xf);};return _f .Gray {Y :_baed *17&0xff},nil ;};func _bebc (_fbae ,_bcea ,_gdbe byte )byte {return (_fbae &^(_gdbe ))|(_bcea &_gdbe )};
func _dgb (_eccg *Monochrome ,_gcc int ,_daa []byte )(_cd *Monochrome ,_afac error ){const _aea ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _eccg ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _gcc < 1||_gcc > 4{return nil ,_a .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _eccg .Height <=1{return nil ,_a .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_cd =_aad (_eccg .Width /2,_eccg .Height /2);if _daa ==nil {_daa =_bagb ();};_fcdd :=_gced (_eccg .BytesPerLine ,2*_cd .BytesPerLine );switch _gcc {case 1:_afac =_bdgf (_eccg ,_cd ,_daa ,_fcdd );case 2:_afac =_acf (_eccg ,_cd ,_daa ,_fcdd );case 3:_afac =_ceb (_eccg ,_cd ,_daa ,_fcdd );
case 4:_afac =_afb (_eccg ,_cd ,_daa ,_fcdd );};if _afac !=nil {return nil ,_afac ;};return _cd ,nil ;};func _bgeed (_edcb _be .Image )(Image ,error ){if _ccegc ,_ecde :=_edcb .(*NRGBA32 );_ecde {return _ccegc .Copy (),nil ;};_ggddb ,_dcgca ,_gebe :=_dgdbdd (_edcb ,1);
_fbgdc ,_bebf :=NewImage (_ggddb .Max .X ,_ggddb .Max .Y ,8,3,nil ,_gebe ,nil );if _bebf !=nil {return nil ,_bebf ;};_bcfg (_edcb ,_fbgdc ,_ggddb );if len (_gebe )!=0&&!_dcgca {if _fafe :=_eda (_gebe ,_fbgdc );_fafe !=nil {return nil ,_fafe ;};};return _fbgdc ,nil ;
};func (_adcg *NRGBA16 )Validate ()error {if len (_adcg .Data )!=3*_adcg .Width *_adcg .Height /2{return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_faa *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_faa .ImageBase .copy (),ModelThreshold :_faa .ModelThreshold };};func (_fbf *CMYK32 )Base ()*ImageBase {return &_fbf .ImageBase };func _cgff (_gcabc _be .Image )(Image ,error ){if _baeg ,_bggd :=_gcabc .(*RGBA32 );
_bggd {return _baeg .Copy (),nil ;};_bdbb ,_efga ,_dgce :=_dgdbdd (_gcabc ,1);_bfee :=&RGBA32 {ImageBase :NewImageBase (_bdbb .Max .X ,_bdbb .Max .Y ,8,3,nil ,_dgce ,nil )};_ggda (_gcabc ,_bfee ,_bdbb );if len (_dgce )!=0&&!_efga {if _cggf :=_eda (_dgce ,_bfee );
_cggf !=nil {return nil ,_cggf ;};};return _bfee ,nil ;};func _dage (_fce _f .NRGBA64 )_f .Gray {var _cdb _f .NRGBA64 ;if _fce ==_cdb {return _f .Gray {Y :0xff};};_gcee ,_bdeg ,_cbd ,_ :=_fce .RGBA ();_fafa :=(19595*_gcee +38470*_bdeg +7471*_cbd +1<<15)>>24;
return _f .Gray {Y :uint8 (_fafa )};};func (_daag *Monochrome )ResolveDecode ()error {if len (_daag .Decode )!=2{return nil ;};if _daag .Decode [0]==1&&_daag .Decode [1]==0{if _bbd :=_daag .InverseData ();_bbd !=nil {return _bbd ;};_daag .Decode =nil ;
};return nil ;};func (_cdgd *Monochrome )setGray (_fba int ,_eddf _f .Gray ,_ccab int ){if _eddf .Y ==0{_cdgd .clearBit (_ccab ,_fba );}else {_cdgd .setGrayBit (_ccab ,_fba );};};func _cdfd (_baefe *_be .Gray16 ,_fdef uint8 )*_be .Gray {_eecg :=_baefe .Bounds ();
_eaaf :=_be .NewGray (_eecg );for _dfd :=0;_dfd < _eecg .Dx ();_dfd ++{for _abba :=0;_abba < _eecg .Dy ();_abba ++{_gbgc :=_baefe .Gray16At (_dfd ,_abba );_eaaf .SetGray (_dfd ,_abba ,_f .Gray {Y :_gfbdf (uint8 (_gbgc .Y /256),_fdef )});};};return _eaaf ;
};func (_ddgd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ddgd .copy ()}};type Gray2 struct{ImageBase };func (_egcb *Monochrome )getBit (_afed ,_cfbe int )uint8 {return _egcb .Data [_afed +(_cfbe >>3)]>>uint (7-(_cfbe &7))&1;};func (_aafa *Gray2 )At (x ,y int )_f .Color {_dfb ,_ :=_aafa .ColorAt (x ,y );
return _dfb };type CMYK32 struct{ImageBase };func (_baec *Gray2 )Base ()*ImageBase {return &_baec .ImageBase };func _ccf (_bbcd _f .NRGBA )_f .RGBA {_gea ,_gead ,_fggb ,_add :=_bbcd .RGBA ();return _f .RGBA {R :uint8 (_gea >>8),G :uint8 (_gead >>8),B :uint8 (_fggb >>8),A :uint8 (_add >>8)};
};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_gafd :=y *bytesPerLine +x >>3;if _gafd >=len (data ){return _f .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gffb :=data [_gafd ]>>uint (7-(x &7))&1;if len (decode )==2{_gffb =uint8 (LinearInterpolate (float64 (_gffb ),0.0,1.0,decode [0],decode [1]))&1;};return _f .Gray {Y :_gffb *255},nil ;};type monochromeModel uint8 ;var _ _be .Image =&NRGBA32 {};func (_egce *Monochrome )GrayAt (x ,y int )_f .Gray {_fbdb ,_ :=ColorAtGray1BPC (x ,y ,_egce .BytesPerLine ,_egce .Data ,_egce .Decode );
return _fbdb ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray16 ,error ){_aeeb :=(y *bytesPerLine /2+x )*2;if _aeeb +1>=len (data ){return _f .Gray16 {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gaabc :=uint16 (data [_aeeb ])<<8|uint16 (data [_aeeb +1]);if len (decode )==2{_gaabc =uint16 (uint64 (LinearInterpolate (float64 (_gaabc ),0,65535,decode [0],decode [1])));};return _f .Gray16 {Y :_gaabc },nil ;};var _ Image =&CMYK32 {};func _egg (_dcgc _f .RGBA )_f .Gray {_afe :=(19595*uint32 (_dcgc .R )+38470*uint32 (_dcgc .G )+7471*uint32 (_dcgc .B )+1<<7)>>16;
return _f .Gray {Y :uint8 (_afe )};};func (_dgdbe *RGBA32 )Validate ()error {if len (_dgdbe .Data )!=3*_dgdbe .Width *_dgdbe .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _aadc (_baf RGBA ,_ggff CMYK ,_fcgd _be .Rectangle ){for _bafa :=0;_bafa < _fcgd .Max .X ;_bafa ++{for _cdgb :=0;_cdgb < _fcgd .Max .Y ;_cdgb ++{_bbg :=_baf .RGBAAt (_bafa ,_cdgb );_ggff .SetCMYK (_bafa ,_cdgb ,_ccgb (_bbg ));};};};
func _bfc (_ca *Monochrome ,_ab ,_ee int )(*Monochrome ,error ){if _ca ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ab <=0||_ee <=0{return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _ab ==_ee {if _ab ==1{return _ca .copy (),nil ;};if _ab ==2||_ab ==4||_ab ==8{_efbd ,_bfca :=_gb (_ca ,_ab );if _bfca !=nil {return nil ,_bfca ;};return _efbd ,nil ;};};_ae :=_ab *_ca .Width ;_bgc :=_ee *_ca .Height ;_dg :=_aad (_ae ,_bgc );_bd :=_dg .BytesPerLine ;
var (_abg ,_fb ,_cab ,_ggd ,_adb int ;_dca byte ;_fbe error ;);for _fb =0;_fb < _ca .Height ;_fb ++{_abg =_ee *_fb *_bd ;for _cab =0;_cab < _ca .Width ;_cab ++{if _bag :=_ca .getBitAt (_cab ,_fb );_bag {_adb =_ab *_cab ;for _ggd =0;_ggd < _ab ;_ggd ++{_dg .setIndexedBit (_abg *8+_adb +_ggd );
};};};for _ggd =1;_ggd < _ee ;_ggd ++{_bega :=_abg +_ggd *_bd ;for _gab :=0;_gab < _bd ;_gab ++{if _dca ,_fbe =_dg .getByte (_abg +_gab );_fbe !=nil {return nil ,_fbe ;};if _fbe =_dg .setByte (_bega +_gab ,_dca );_fbe !=nil {return nil ,_fbe ;};};};};return _dg ,nil ;
};func (_gged *Gray2 )Histogram ()(_aeg [256]int ){for _gcd :=0;_gcd < _gged .Width ;_gcd ++{for _gddf :=0;_gddf < _gged .Height ;_gddf ++{_aeg [_gged .GrayAt (_gcd ,_gddf ).Y ]++;};};return _aeg ;};type NRGBA interface{NRGBAAt (_facf ,_bbeg int )_f .NRGBA ;
SetNRGBA (_acda ,_egad int ,_cgae _f .NRGBA );};func _cgef (_dff _f .Gray )_f .NRGBA {return _f .NRGBA {R :_dff .Y ,G :_dff .Y ,B :_dff .Y ,A :0xff}};type RGBA interface{RGBAAt (_addca ,_ebeg int )_f .RGBA ;SetRGBA (_ddgf ,_cadf int ,_ffea _f .RGBA );};
func (_acd *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_acd .copy ()}};func _age (_gaf int )[]uint {var _dde []uint ;_fge :=_gaf ;_ggf :=_fge /8;if _ggf !=0{for _fga :=0;_fga < _ggf ;_fga ++{_dde =append (_dde ,8);};_eeg :=_fge %8;_fge =0;if _eeg !=0{_fge =_eeg ;
};};_bdg :=_fge /4;if _bdg !=0{for _fe :=0;_fe < _bdg ;_fe ++{_dde =append (_dde ,4);};_fa :=_fge %4;_fge =0;if _fa !=0{_fge =_fa ;};};_edc :=_fge /2;if _edc !=0{for _aag :=0;_aag < _edc ;_aag ++{_dde =append (_dde ,2);};};return _dde ;};func (_bagbc *CMYK32 )At (x ,y int )_f .Color {_fec ,_ :=_bagbc .ColorAt (x ,y );
return _fec };func _gcg (_baae _f .NRGBA )_f .CMYK {_afbd ,_dgge ,_cffa ,_ :=_baae .RGBA ();_fdg ,_dabd ,_bcbg ,_bba :=_f .RGBToCMYK (uint8 (_afbd >>8),uint8 (_dgge >>8),uint8 (_cffa >>8));return _f .CMYK {C :_fdg ,M :_dabd ,Y :_bcbg ,K :_bba };};func _gbd (_dadf _f .NRGBA64 )_f .NRGBA {return _f .NRGBA {R :uint8 (_dadf .R >>8),G :uint8 (_dadf .G >>8),B :uint8 (_dadf .B >>8),A :uint8 (_dadf .A >>8)};
};func (_aae *monochromeThresholdConverter )Convert (img _be .Image )(Image ,error ){if _ddce ,_abed :=img .(*Monochrome );_abed {return _ddce .Copy (),nil ;};_defe :=img .Bounds ();_acab ,_ffae :=NewImage (_defe .Max .X ,_defe .Max .Y ,1,1,nil ,nil ,nil );
if _ffae !=nil {return nil ,_ffae ;};_acab .(*Monochrome ).ModelThreshold =_aae .Threshold ;for _ceee :=0;_ceee < _defe .Max .X ;_ceee ++{for _ffe :=0;_ffe < _defe .Max .Y ;_ffe ++{_ceda :=img .At (_ceee ,_ffe );_acab .Set (_ceee ,_ffe ,_ceda );};};return _acab ,nil ;
};func _bdgf (_edb ,_ced *Monochrome ,_egc []byte ,_afg int )(_caa error ){var (_ea ,_dga ,_afc ,_bae ,_cff ,_dace ,_gfc ,_gac int ;_ada ,_fef uint32 ;_bdgd ,_cge byte ;_cgg uint16 ;);_bgg :=make ([]byte ,4);_cde :=make ([]byte ,4);for _afc =0;_afc < _edb .Height -1;
_afc ,_bae =_afc +2,_bae +1{_ea =_afc *_edb .BytesPerLine ;_dga =_bae *_ced .BytesPerLine ;for _cff ,_dace =0,0;_cff < _afg ;_cff ,_dace =_cff +4,_dace +1{for _gfc =0;_gfc < 4;_gfc ++{_gac =_ea +_cff +_gfc ;if _gac <=len (_edb .Data )-1&&_gac < _ea +_edb .BytesPerLine {_bgg [_gfc ]=_edb .Data [_gac ];
}else {_bgg [_gfc ]=0x00;};_gac =_ea +_edb .BytesPerLine +_cff +_gfc ;if _gac <=len (_edb .Data )-1&&_gac < _ea +(2*_edb .BytesPerLine ){_cde [_gfc ]=_edb .Data [_gac ];}else {_cde [_gfc ]=0x00;};};_ada =_bb .BigEndian .Uint32 (_bgg );_fef =_bb .BigEndian .Uint32 (_cde );
_fef |=_ada ;_fef |=_fef <<1;_fef &=0xaaaaaaaa;_ada =_fef |(_fef <<7);_bdgd =byte (_ada >>24);_cge =byte ((_ada >>8)&0xff);_gac =_dga +_dace ;if _gac +1==len (_ced .Data )-1||_gac +1>=_dga +_ced .BytesPerLine {_ced .Data [_gac ]=_egc [_bdgd ];}else {_cgg =(uint16 (_egc [_bdgd ])<<8)|uint16 (_egc [_cge ]);
if _caa =_ced .setTwoBytes (_gac ,_cgg );_caa !=nil {return _bc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gac );
};_dace ++;};};};return nil ;};func _feba (_abfb _f .Gray ,_befa monochromeModel )_f .Gray {if _abfb .Y > uint8 (_befa ){return _f .Gray {Y :_b .MaxUint8 };};return _f .Gray {};};func _ggae (_deaa _f .Color )_f .Color {_cead :=_f .GrayModel .Convert (_deaa ).(_f .Gray );
return _bafg (_cead );};func (_dgda *RGBA32 )Base ()*ImageBase {return &_dgda .ImageBase };func (_dfcfg *Gray2 )Set (x ,y int ,c _f .Color ){if x >=_dfcfg .Width ||y >=_dfcfg .Height {return ;};_gccd :=Gray2Model .Convert (c ).(_f .Gray );_eca :=y *_dfcfg .BytesPerLine ;
_dagcd :=_eca +(x >>2);_fgb :=_gccd .Y >>6;_dfcfg .Data [_dagcd ]=(_dfcfg .Data [_dagcd ]&(^(0xc0>>uint (2*((x )&3)))))|(_fgb <<uint (6-2*(x &3)));};func (_bcbe colorConverter )Convert (src _be .Image )(Image ,error ){return _bcbe ._edbc (src )};func _faff (_ede *Monochrome ,_aabcc ,_ccde ,_ccbf ,_ffcc int ,_bedc RasterOperator ){if _aabcc < 0{_ccbf +=_aabcc ;
_aabcc =0;};_daae :=_aabcc +_ccbf -_ede .Width ;if _daae > 0{_ccbf -=_daae ;};if _ccde < 0{_ffcc +=_ccde ;_ccde =0;};_ffcf :=_ccde +_ffcc -_ede .Height ;if _ffcf > 0{_ffcc -=_ffcf ;};if _ccbf <=0||_ffcc <=0{return ;};if (_aabcc &7)==0{_fgdb (_ede ,_aabcc ,_ccde ,_ccbf ,_ffcc ,_bedc );
}else {_bcac (_ede ,_aabcc ,_ccde ,_ccbf ,_ffcc ,_bedc );};};func (_cfdb *NRGBA32 )SetNRGBA (x ,y int ,c _f .NRGBA ){_ecff :=y *_cfdb .Width +x ;_gfecg :=3*_ecff ;if _gfecg +2>=len (_cfdb .Data ){return ;};_cfdb .setRGBA (_ecff ,c );};func _geff (_bgf *Monochrome ,_fdec ,_ecdf ,_gdgf ,_efce int ,_gaff RasterOperator ,_bgab *Monochrome ,_cgba ,_fcee int )error {var (_fgaea byte ;
_ccda int ;_fdfc int ;_faccd ,_bbea int ;_deaae ,_bfeb int ;);_gaffc :=_gdgf >>3;_effgb :=_gdgf &7;if _effgb > 0{_fgaea =_ebfd [_effgb ];};_ccda =_bgab .BytesPerLine *_fcee +(_cgba >>3);_fdfc =_bgf .BytesPerLine *_ecdf +(_fdec >>3);switch _gaff {case PixSrc :for _deaae =0;
_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]=_bgab .Data [_faccd ];_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],_bgab .Data [_faccd ],_fgaea );
};};case PixNotSrc :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]=^(_bgab .Data [_faccd ]);_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],^_bgab .Data [_faccd ],_fgaea );
};};case PixSrcOrDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]|=_bgab .Data [_faccd ];_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],_bgab .Data [_faccd ]|_bgf .Data [_bbea ],_fgaea );
};};case PixSrcAndDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]&=_bgab .Data [_faccd ];_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],_bgab .Data [_faccd ]&_bgf .Data [_bbea ],_fgaea );
};};case PixSrcXorDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]^=_bgab .Data [_faccd ];_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],_bgab .Data [_faccd ]^_bgf .Data [_bbea ],_fgaea );
};};case PixNotSrcOrDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]|=^(_bgab .Data [_faccd ]);_bbea ++;_faccd ++;
};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],^(_bgab .Data [_faccd ])|_bgf .Data [_bbea ],_fgaea );};};case PixNotSrcAndDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;
for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]&=^(_bgab .Data [_faccd ]);_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],^(_bgab .Data [_faccd ])&_bgf .Data [_bbea ],_fgaea );};};case PixSrcOrNotDst :for _deaae =0;
_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]=_bgab .Data [_faccd ]|^(_bgf .Data [_bbea ]);_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],_bgab .Data [_faccd ]|^(_bgf .Data [_bbea ]),_fgaea );
};};case PixSrcAndNotDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]=_bgab .Data [_faccd ]&^(_bgf .Data [_bbea ]);
_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],_bgab .Data [_faccd ]&^(_bgf .Data [_bbea ]),_fgaea );};};case PixNotPixSrcOrDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;
for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]=^(_bgab .Data [_faccd ]|_bgf .Data [_bbea ]);_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],^(_bgab .Data [_faccd ]|_bgf .Data [_bbea ]),_fgaea );};};case PixNotPixSrcAndDst :for _deaae =0;
_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]=^(_bgab .Data [_faccd ]&_bgf .Data [_bbea ]);_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],^(_bgab .Data [_faccd ]&_bgf .Data [_bbea ]),_fgaea );
};};case PixNotPixSrcXorDst :for _deaae =0;_deaae < _efce ;_deaae ++{_faccd =_ccda +_deaae *_bgab .BytesPerLine ;_bbea =_fdfc +_deaae *_bgf .BytesPerLine ;for _bfeb =0;_bfeb < _gaffc ;_bfeb ++{_bgf .Data [_bbea ]=^(_bgab .Data [_faccd ]^_bgf .Data [_bbea ]);
_bbea ++;_faccd ++;};if _effgb > 0{_bgf .Data [_bbea ]=_bebc (_bgf .Data [_bbea ],^(_bgab .Data [_faccd ]^_bgf .Data [_bbea ]),_fgaea );};};default:_fg .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_gaff );
return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func _fcde (_febe *Monochrome ,_cgegc ,_cegc ,_ggea ,_gfbd int ,_egdg RasterOperator ,_beeb *Monochrome ,_dccf ,_gcbf int )error {if _febe ==nil {return _a .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _egdg ==PixDst {return nil ;};switch _egdg {case PixClr ,PixSet ,PixNotDst :_faff (_febe ,_cgegc ,_cegc ,_ggea ,_gfbd ,_egdg );return nil ;};if _beeb ==nil {_fg .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _a .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _cfag :=_efge (_febe ,_cgegc ,_cegc ,_ggea ,_gfbd ,_egdg ,_beeb ,_dccf ,_gcbf );_cfag !=nil {return _cfag ;};return nil ;};func (_fdc *CMYK32 )Set (x ,y int ,c _f .Color ){_fefa :=4*(y *_fdc .Width +x );
if _fefa +3>=len (_fdc .Data ){return ;};_bggb :=_f .CMYKModel .Convert (c ).(_f .CMYK );_fdc .Data [_fefa ]=_bggb .C ;_fdc .Data [_fefa +1]=_bggb .M ;_fdc .Data [_fefa +2]=_bggb .Y ;_fdc .Data [_fefa +3]=_bggb .K ;};func _ccdc (_abff _be .Image )(Image ,error ){if _bca ,_deae :=_abff .(*Gray2 );
_deae {return _bca .Copy (),nil ;};_eab :=_abff .Bounds ();_ebae ,_cagd :=NewImage (_eab .Max .X ,_eab .Max .Y ,2,1,nil ,nil ,nil );if _cagd !=nil {return nil ,_cagd ;};_eead (_abff ,_ebae ,_eab );return _ebae ,nil ;};func _aac (_cgee _f .CMYK )_f .Gray {_cgcb ,_dgf ,_acfd :=_f .CMYKToRGB (_cgee .C ,_cgee .M ,_cgee .Y ,_cgee .K );
_cbg :=(19595*uint32 (_cgcb )+38470*uint32 (_dgf )+7471*uint32 (_acfd )+1<<7)>>16;return _f .Gray {Y :uint8 (_cbg )};};func _gaggg (_fdbe *_be .NYCbCrA ,_afce NRGBA ,_egee _be .Rectangle ){for _acdae :=0;_acdae < _egee .Max .X ;_acdae ++{for _gbdb :=0;
_gbdb < _egee .Max .Y ;_gbdb ++{_gcbbg :=_fdbe .NYCbCrAAt (_acdae ,_gbdb );_afce .SetNRGBA (_acdae ,_gbdb ,_begc (_gcbbg ));};};};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_cacc :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _adgcg Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_adgcg =&Monochrome {ImageBase :_cacc ,ModelThreshold :0x0f};case 2:_adgcg =&Gray2 {ImageBase :_cacc };case 4:_adgcg =&Gray4 {ImageBase :_cacc };case 8:_adgcg =&Gray8 {ImageBase :_cacc };
case 16:_adgcg =&Gray16 {ImageBase :_cacc };};case 3:switch bitsPerComponent {case 4:_adgcg =&NRGBA16 {ImageBase :_cacc };case 8:_adgcg =&NRGBA32 {ImageBase :_cacc };case 16:_adgcg =&NRGBA64 {ImageBase :_cacc };};case 4:_adgcg =&CMYK32 {ImageBase :_cacc };
};if _adgcg ==nil {return nil ,ErrInvalidImage ;};return _adgcg ,nil ;};func (_dfbc *RGBA32 )RGBAAt (x ,y int )_f .RGBA {_bbee ,_ :=ColorAtRGBA32 (x ,y ,_dfbc .Width ,_dfbc .Data ,_dfbc .Alpha ,_dfbc .Decode );return _bbee ;};func (_ccaa *Gray16 )Base ()*ImageBase {return &_ccaa .ImageBase };
func _fcce (_agd _f .CMYK )_f .RGBA {_ebg ,_cgeg ,_edcc :=_f .CMYKToRGB (_agd .C ,_agd .M ,_agd .Y ,_agd .K );return _f .RGBA {R :_ebg ,G :_cgeg ,B :_edcc ,A :0xff};};func (_eabd *NRGBA16 )Set (x ,y int ,c _f .Color ){_dfac :=y *_eabd .BytesPerLine +x *3/2;
if _dfac +1>=len (_eabd .Data ){return ;};_gbfd :=NRGBA16Model .Convert (c ).(_f .NRGBA );_eabd .setNRGBA (x ,y ,_dfac ,_gbfd );};func _fbbb (_eef _f .Gray )_f .CMYK {return _f .CMYK {K :0xff-_eef .Y }};func _ebgg (_aeeeg _be .Image ,_gceb uint8 )*_be .Gray {_eade :=_aeeeg .Bounds ();
_bgfa :=_be .NewGray (_eade );var (_cbgb _f .Color ;_acaf _f .Gray ;);for _dffac :=0;_dffac < _eade .Max .X ;_dffac ++{for _degb :=0;_degb < _eade .Max .Y ;_degb ++{_cbgb =_aeeeg .At (_dffac ,_degb );_bgfa .Set (_dffac ,_degb ,_cbgb );_acaf =_bgfa .GrayAt (_dffac ,_degb );
_bgfa .SetGray (_dffac ,_degb ,_f .Gray {Y :_gfbdf (_acaf .Y ,_gceb )});};};return _bgfa ;};func (_fbcb *Gray2 )SetGray (x ,y int ,gray _f .Gray ){_ffge :=_bafg (gray );_gbf :=y *_fbcb .BytesPerLine ;_dfee :=_gbf +(x >>2);if _dfee >=len (_fbcb .Data ){return ;
};_egeg :=_ffge .Y >>6;_fbcb .Data [_dfee ]=(_fbcb .Data [_dfee ]&(^(0xc0>>uint (2*((x )&3)))))|(_egeg <<uint (6-2*(x &3)));};func init (){_bedf ()};func (_edgg *Gray2 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray2BPC (x ,y ,_edgg .BytesPerLine ,_edgg .Data ,_edgg .Decode );
};func (_fddd *ImageBase )copy ()ImageBase {_caf :=*_fddd ;_caf .Data =make ([]byte ,len (_fddd .Data ));copy (_caf .Data ,_fddd .Data );return _caf ;};func (_gaeg *Monochrome )Validate ()error {if len (_gaeg .Data )!=_gaeg .Height *_gaeg .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_fdfb *Gray4 )ColorModel ()_f .Model {return Gray4Model };func (_dacf *NRGBA64 )Validate ()error {if len (_dacf .Data )!=3*2*_dacf .Width *_dacf .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type Histogramer interface{Histogram ()[256]int ;};func (_caae *Gray4 )setGray (_geg int ,_eggd int ,_ccbc _f .Gray ){_gffd :=_eggd *_caae .BytesPerLine ;_dbbg :=_gffd +(_geg >>1);if _dbbg >=len (_caae .Data ){return ;};_faebf :=_ccbc .Y >>4;
_caae .Data [_dbbg ]=(_caae .Data [_dbbg ]&(^(0xf0>>uint (4*(_geg &1)))))|(_faebf <<uint (4-4*(_geg &1)));};var _ Image =&NRGBA32 {};func (_fcec *Monochrome )Base ()*ImageBase {return &_fcec .ImageBase };var (_ebfd =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};
_edgc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_fgdc *NRGBA64 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_fgdc .Width ,Y :_fgdc .Height }};};func (_gabe *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fcde (_gabe ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};var _ _be .Image =&Gray8 {};func _fdff (_bgcc uint8 )bool {if _bgcc ==0||_bgcc ==255{return true ;};return false ;};func _aa ()(_effe [256]uint16 ){for _ggc :=0;_ggc < 256;_ggc ++{if _ggc &0x01!=0{_effe [_ggc ]|=0x3;};if _ggc &0x02!=0{_effe [_ggc ]|=0xc;
};if _ggc &0x04!=0{_effe [_ggc ]|=0x30;};if _ggc &0x08!=0{_effe [_ggc ]|=0xc0;};if _ggc &0x10!=0{_effe [_ggc ]|=0x300;};if _ggc &0x20!=0{_effe [_ggc ]|=0xc00;};if _ggc &0x40!=0{_effe [_ggc ]|=0x3000;};if _ggc &0x80!=0{_effe [_ggc ]|=0xc000;};};return _effe ;
};func (_bafc *Gray4 )Base ()*ImageBase {return &_bafc .ImageBase };func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_cccg :=y *bytesPerLine +x >>2;if _cccg >=len (data ){return _f .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_efec :=data [_cccg ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_efec =uint8 (uint32 (LinearInterpolate (float64 (_efec ),0,3.0,decode [0],decode [1]))&3);};return _f .Gray {Y :_efec *85},nil ;};func (_fdgb *Monochrome )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray1BPC (x ,y ,_fdgb .BytesPerLine ,_fdgb .Data ,_fdgb .Decode );
};type NRGBA64 struct{ImageBase };var _ Gray =&Gray8 {};func (_edg *Monochrome )SetGray (x ,y int ,g _f .Gray ){_fbg :=y *_edg .BytesPerLine +x >>3;if _fbg > len (_edg .Data )-1{return ;};g =_feba (g ,monochromeModel (_edg .ModelThreshold ));_edg .setGray (x ,g ,_fbg );
};func _gb (_ff *Monochrome ,_dd int )(*Monochrome ,error ){if _ff ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _dd ==1{return _ff .copy (),nil ;};if !IsPowerOf2 (uint (_dd )){return nil ,_bc .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dd );
};_cb :=_age (_dd );return _gf (_ff ,_dd ,_cb );};func _ccgb (_cbfc _f .RGBA )_f .CMYK {_dacdf ,_ecea ,_dfag ,_cfg :=_f .RGBToCMYK (_cbfc .R ,_cbfc .G ,_cbfc .B );return _f .CMYK {C :_dacdf ,M :_ecea ,Y :_dfag ,K :_cfg };};type SMasker interface{HasAlpha ()bool ;
GetAlpha ()[]byte ;MakeAlpha ();};func (_fca *Monochrome )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_fca .Width ,Y :_fca .Height }};};var _ Gray =&Gray4 {};func (_affe *Gray4 )Set (x ,y int ,c _f .Color ){if x >=_affe .Width ||y >=_affe .Height {return ;
};_fbed :=Gray4Model .Convert (c ).(_f .Gray );_affe .setGray (x ,y ,_fbed );};func _efge (_cdfg *Monochrome ,_adge ,_acdb int ,_gad ,_ebgd int ,_gfec RasterOperator ,_adca *Monochrome ,_geab ,_ecbg int )error {var _cfdf ,_cfgd ,_bfcc ,_aedce int ;if _adge < 0{_geab -=_adge ;
_gad +=_adge ;_adge =0;};if _geab < 0{_adge -=_geab ;_gad +=_geab ;_geab =0;};_cfdf =_adge +_gad -_cdfg .Width ;if _cfdf > 0{_gad -=_cfdf ;};_cfgd =_geab +_gad -_adca .Width ;if _cfgd > 0{_gad -=_cfgd ;};if _acdb < 0{_ecbg -=_acdb ;_ebgd +=_acdb ;_acdb =0;
};if _ecbg < 0{_acdb -=_ecbg ;_ebgd +=_ecbg ;_ecbg =0;};_bfcc =_acdb +_ebgd -_cdfg .Height ;if _bfcc > 0{_ebgd -=_bfcc ;};_aedce =_ecbg +_ebgd -_adca .Height ;if _aedce > 0{_ebgd -=_aedce ;};if _gad <=0||_ebgd <=0{return nil ;};var _eegbe error ;switch {case _adge &7==0&&_geab &7==0:_eegbe =_geff (_cdfg ,_adge ,_acdb ,_gad ,_ebgd ,_gfec ,_adca ,_geab ,_ecbg );
case _adge &7==_geab &7:_eegbe =_fbgf (_cdfg ,_adge ,_acdb ,_gad ,_ebgd ,_gfec ,_adca ,_geab ,_ecbg );default:_eegbe =_bagf (_cdfg ,_adge ,_acdb ,_gad ,_ebgd ,_gfec ,_adca ,_geab ,_ecbg );};if _eegbe !=nil {return _eegbe ;};return nil ;};func (_fgaae *NRGBA64 )NRGBA64At (x ,y int )_f .NRGBA64 {_ddfbda ,_ :=ColorAtNRGBA64 (x ,y ,_fgaae .Width ,_fgaae .Data ,_fgaae .Alpha ,_fgaae .Decode );
return _ddfbda ;};func _ecabd (_ceaa ,_dceg RGBA ,_dgfg _be .Rectangle ){for _deb :=0;_deb < _dgfg .Max .X ;_deb ++{for _dcca :=0;_dcca < _dgfg .Max .Y ;_dcca ++{_dceg .SetRGBA (_deb ,_dcca ,_ceaa .RGBAAt (_deb ,_dcca ));};};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_bc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_bafae *RGBA32 )At (x ,y int )_f .Color {_adce ,_ :=_bafae .ColorAt (x ,y );return _adce };type colorConverter struct{_edbc func (_adf _be .Image )(Image ,error );};func (_efd *Gray4 )At (x ,y int )_f .Color {_bfb ,_ :=_efd .ColorAt (x ,y );return _bfb };
func (_cda *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cda .copy ()}};func (_cbb *NRGBA16 )NRGBAAt (x ,y int )_f .NRGBA {_gfce ,_ :=ColorAtNRGBA16 (x ,y ,_cbb .Width ,_cbb .BytesPerLine ,_cbb .Data ,_cbb .Alpha ,_cbb .Decode );return _gfce ;};func (_gdb *Monochrome )setIndexedBit (_gba int ){_gdb .Data [(_gba >>3)]|=0x80>>uint (_gba &7)};
func (_gbed *ImageBase )getByte (_cebd int )(byte ,error ){if _cebd > len (_gbed .Data )-1||_cebd < 0{return 0,_bc .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_cebd );
};return _gbed .Data [_cebd ],nil ;};func _fde (_aff NRGBA ,_gcfa CMYK ,_def _be .Rectangle ){for _gaea :=0;_gaea < _def .Max .X ;_gaea ++{for _bcb :=0;_bcb < _def .Max .Y ;_bcb ++{_fag :=_aff .NRGBAAt (_gaea ,_bcb );_gcfa .SetCMYK (_gaea ,_bcb ,_gcg (_fag ));
};};};func _ccbb (_bce CMYK ,_eeffd Gray ,_agb _be .Rectangle ){for _aeac :=0;_aeac < _agb .Max .X ;_aeac ++{for _bedeb :=0;_bedeb < _agb .Max .Y ;_bedeb ++{_fbde :=_aac (_bce .CMYKAt (_aeac ,_bedeb ));_eeffd .SetGray (_aeac ,_bedeb ,_fbde );};};};func (_cfa *Monochrome )InverseData ()error {return _cfa .RasterOperation (0,0,_cfa .Width ,_cfa .Height ,PixNotDst ,nil ,0,0);
};func (_dbff *NRGBA16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA16 (x ,y ,_dbff .Width ,_dbff .BytesPerLine ,_dbff .Data ,_dbff .Alpha ,_dbff .Decode );};func _dgdbdd (_acce _be .Image ,_egdb int )(_be .Rectangle ,bool ,[]byte ){_bec :=_acce .Bounds ();
var (_bgdg bool ;_fegcaf []byte ;);switch _ddgb :=_acce .(type ){case SMasker :_bgdg =_ddgb .HasAlpha ();case NRGBA ,RGBA ,*_be .RGBA64 ,nrgba64 ,*_be .NYCbCrA :_fegcaf =make ([]byte ,_bec .Max .X *_bec .Max .Y *_egdb );case *_be .Paletted :if !_ddgb .Opaque (){_fegcaf =make ([]byte ,_bec .Max .X *_bec .Max .Y *_egdb );
};};return _bec ,_bgdg ,_fegcaf ;};func (_eae *Gray2 )GrayAt (x ,y int )_f .Gray {_abce ,_ :=ColorAtGray2BPC (x ,y ,_eae .BytesPerLine ,_eae .Data ,_eae .Decode );return _abce ;};func _gfbdf (_ffac ,_cbbc uint8 )uint8 {if _ffac < _cbbc {return 255;};return 0;
};type Gray8 struct{ImageBase };func _bagb ()(_fda []byte ){_fda =make ([]byte ,256);for _ccef :=0;_ccef < 256;_ccef ++{_gaa :=byte (_ccef );_fda [_gaa ]=(_gaa &0x01)|((_gaa &0x04)>>1)|((_gaa &0x10)>>2)|((_gaa &0x40)>>3)|((_gaa &0x02)<<3)|((_gaa &0x08)<<2)|((_gaa &0x20)<<1)|(_gaa &0x80);
};return _fda ;};func _fff (_cagc _be .Image )(Image ,error ){if _bea ,_ecbd :=_cagc .(*CMYK32 );_ecbd {return _bea .Copy (),nil ;};_dgg :=_cagc .Bounds ();_ebbe ,_dcd :=NewImage (_dgg .Max .X ,_dgg .Max .Y ,8,4,nil ,nil ,nil );if _dcd !=nil {return nil ,_dcd ;
};switch _dfc :=_cagc .(type ){case CMYK :_cdg (_dfc ,_ebbe .(CMYK ),_dgg );case Gray :_dfgf (_dfc ,_ebbe .(CMYK ),_dgg );case NRGBA :_fde (_dfc ,_ebbe .(CMYK ),_dgg );case RGBA :_aadc (_dfc ,_ebbe .(CMYK ),_dgg );default:_egf (_cagc ,_ebbe ,_dgg );};return _ebbe ,nil ;
};func (_dgfd *NRGBA16 )At (x ,y int )_f .Color {_fecee ,_ :=_dgfd .ColorAt (x ,y );return _fecee };var _ _be .Image =&Monochrome {};var _ Gray =&Monochrome {};func (_gca *ImageBase )MakeAlpha (){_gca .newAlpha ()};type Gray16 struct{ImageBase };var _ _be .Image =&NRGBA16 {};
type CMYK interface{CMYKAt (_bde ,_gbc int )_f .CMYK ;SetCMYK (_ddd ,_fea int ,_edd _f .CMYK );};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_aaee (n )+1);};func (_gdae *Gray4 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_gdae .Width ,Y :_gdae .Height }};
};func (_ddcf *Gray16 )Histogram ()(_fffe [256]int ){for _ggdc :=0;_ggdc < _ddcf .Width ;_ggdc ++{for _ecg :=0;_ecg < _ddcf .Height ;_ecg ++{_fffe [_ddcf .GrayAt (_ggdc ,_ecg ).Y ]++;};};return _fffe ;};func _de (_cee ,_dc *Monochrome )(_ddc error ){_cf :=_dc .BytesPerLine ;
_bfg :=_cee .BytesPerLine ;_aca :=_dc .BytesPerLine *4-_cee .BytesPerLine ;var (_ebc ,_gg byte ;_ec uint32 ;_cfe ,_gc ,_bge ,_eg ,_eff ,_ebb ,_ge int ;);for _bge =0;_bge < _dc .Height ;_bge ++{_cfe =_bge *_cf ;_gc =4*_bge *_bfg ;for _eg =0;_eg < _cf ;_eg ++{_ebc =_dc .Data [_cfe +_eg ];
_ec =_gcf [_ebc ];_ebb =_gc +_eg *4;if _aca !=0&&(_eg +1)*4> _cee .BytesPerLine {for _eff =_aca ;_eff > 0;_eff --{_gg =byte ((_ec >>uint (_eff *8))&0xff);_ge =_ebb +(_aca -_eff );if _ddc =_cee .setByte (_ge ,_gg );_ddc !=nil {return _ddc ;};};}else if _ddc =_cee .setFourBytes (_ebb ,_ec );
_ddc !=nil {return _ddc ;};if _ddc =_cee .setFourBytes (_gc +_eg *4,_gcf [_dc .Data [_cfe +_eg ]]);_ddc !=nil {return _ddc ;};};for _eff =1;_eff < 4;_eff ++{for _eg =0;_eg < _bfg ;_eg ++{if _ddc =_cee .setByte (_gc +_eff *_bfg +_eg ,_cee .Data [_gc +_eg ]);
_ddc !=nil {return _ddc ;};};};};return nil ;};func _fgdb (_bffda *Monochrome ,_ccfb ,_ddb int ,_ccgg ,_cceg int ,_acg RasterOperator ){var (_agfa int ;_ddceg byte ;_ddfbd ,_fdddc int ;_eafg int ;);_dae :=_ccgg >>3;_ggfb :=_ccgg &7;if _ggfb > 0{_ddceg =_ebfd [_ggfb ];
};_agfa =_bffda .BytesPerLine *_ddb +(_ccfb >>3);switch _acg {case PixClr :for _ddfbd =0;_ddfbd < _cceg ;_ddfbd ++{_eafg =_agfa +_ddfbd *_bffda .BytesPerLine ;for _fdddc =0;_fdddc < _dae ;_fdddc ++{_bffda .Data [_eafg ]=0x0;_eafg ++;};if _ggfb > 0{_bffda .Data [_eafg ]=_bebc (_bffda .Data [_eafg ],0x0,_ddceg );
};};case PixSet :for _ddfbd =0;_ddfbd < _cceg ;_ddfbd ++{_eafg =_agfa +_ddfbd *_bffda .BytesPerLine ;for _fdddc =0;_fdddc < _dae ;_fdddc ++{_bffda .Data [_eafg ]=0xff;_eafg ++;};if _ggfb > 0{_bffda .Data [_eafg ]=_bebc (_bffda .Data [_eafg ],0xff,_ddceg );
};};case PixNotDst :for _ddfbd =0;_ddfbd < _cceg ;_ddfbd ++{_eafg =_agfa +_ddfbd *_bffda .BytesPerLine ;for _fdddc =0;_fdddc < _dae ;_fdddc ++{_bffda .Data [_eafg ]=^_bffda .Data [_eafg ];_eafg ++;};if _ggfb > 0{_bffda .Data [_eafg ]=_bebc (_bffda .Data [_eafg ],^_bffda .Data [_eafg ],_ddceg );
};};};};func (_fdge *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_fdge .copy ()}};func (_cdcf *NRGBA64 )SetNRGBA64 (x ,y int ,c _f .NRGBA64 ){_ecgc :=(y *_cdcf .Width +x )*2;_aegd :=_ecgc *3;if _aegd +5>=len (_cdcf .Data ){return ;};_cdcf .setNRGBA64 (_aegd ,c ,_ecgc );
};func (_cecf *NRGBA32 )setRGBA (_bgggb int ,_gcab _f .NRGBA ){_cegcc :=3*_bgggb ;_cecf .Data [_cegcc ]=_gcab .R ;_cecf .Data [_cegcc +1]=_gcab .G ;_cecf .Data [_cegcc +2]=_gcab .B ;if _bgggb < len (_cecf .Alpha ){_cecf .Alpha [_bgggb ]=_gcab .A ;};};func (_aabc *ImageBase )GetAlpha ()[]byte {return _aabc .Alpha };
func _bcac (_bcff *Monochrome ,_fbedb ,_bcbc int ,_gfbe ,_cffc int ,_abgde RasterOperator ){var (_bgef bool ;_fegca bool ;_acbc int ;_gage int ;_agbcb int ;_gegf int ;_cgbc bool ;_bfgb byte ;);_dbde :=8-(_fbedb &7);_bgfd :=_edgc [_dbde ];_acade :=_bcff .BytesPerLine *_bcbc +(_fbedb >>3);
if _gfbe < _dbde {_bgef =true ;_bgfd &=_ebfd [8-_dbde +_gfbe ];};if !_bgef {_acbc =(_gfbe -_dbde )>>3;if _acbc !=0{_fegca =true ;_gage =_acade +1;};};_agbcb =(_fbedb +_gfbe )&7;if !(_bgef ||_agbcb ==0){_cgbc =true ;_bfgb =_ebfd [_agbcb ];_gegf =_acade +1+_acbc ;
};var _efac ,_gdaeg int ;switch _abgde {case PixClr :for _efac =0;_efac < _cffc ;_efac ++{_bcff .Data [_acade ]=_bebc (_bcff .Data [_acade ],0x0,_bgfd );_acade +=_bcff .BytesPerLine ;};if _fegca {for _efac =0;_efac < _cffc ;_efac ++{for _gdaeg =0;_gdaeg < _acbc ;
_gdaeg ++{_bcff .Data [_gage +_gdaeg ]=0x0;};_gage +=_bcff .BytesPerLine ;};};if _cgbc {for _efac =0;_efac < _cffc ;_efac ++{_bcff .Data [_gegf ]=_bebc (_bcff .Data [_gegf ],0x0,_bfgb );_gegf +=_bcff .BytesPerLine ;};};case PixSet :for _efac =0;_efac < _cffc ;
_efac ++{_bcff .Data [_acade ]=_bebc (_bcff .Data [_acade ],0xff,_bgfd );_acade +=_bcff .BytesPerLine ;};if _fegca {for _efac =0;_efac < _cffc ;_efac ++{for _gdaeg =0;_gdaeg < _acbc ;_gdaeg ++{_bcff .Data [_gage +_gdaeg ]=0xff;};_gage +=_bcff .BytesPerLine ;
};};if _cgbc {for _efac =0;_efac < _cffc ;_efac ++{_bcff .Data [_gegf ]=_bebc (_bcff .Data [_gegf ],0xff,_bfgb );_gegf +=_bcff .BytesPerLine ;};};case PixNotDst :for _efac =0;_efac < _cffc ;_efac ++{_bcff .Data [_acade ]=_bebc (_bcff .Data [_acade ],^_bcff .Data [_acade ],_bgfd );
_acade +=_bcff .BytesPerLine ;};if _fegca {for _efac =0;_efac < _cffc ;_efac ++{for _gdaeg =0;_gdaeg < _acbc ;_gdaeg ++{_bcff .Data [_gage +_gdaeg ]=^(_bcff .Data [_gage +_gdaeg ]);};_gage +=_bcff .BytesPerLine ;};};if _cgbc {for _efac =0;_efac < _cffc ;
_efac ++{_bcff .Data [_gegf ]=_bebc (_bcff .Data [_gegf ],^_bcff .Data [_gegf ],_bfgb );_gegf +=_bcff .BytesPerLine ;};};};};var _ _be .Image =&Gray16 {};func (_fdaf *RGBA32 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_fdaf .Width ,Y :_fdaf .Height }};
};func (_fdd *CMYK32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtCMYK (x ,y ,_fdd .Width ,_fdd .Data ,_fdd .Decode );};func (_dddd *ImageBase )setEightPartlyBytes (_fece ,_bbcb int ,_bfge uint64 )(_acfde error ){var (_cadc byte ;_gcca int ;);
for _afca :=1;_afca <=_bbcb ;_afca ++{_gcca =64-_afca *8;_cadc =byte (_bfge >>uint (_gcca )&0xff);if _acfde =_dddd .setByte (_fece +_afca -1,_cadc );_acfde !=nil {return _acfde ;};};_bdc :=_dddd .BytesPerLine *8-_dddd .Width ;if _bdc ==0{return nil ;};
_gcca -=8;_cadc =byte (_bfge >>uint (_gcca )&0xff)<<uint (_bdc );if _acfde =_dddd .setByte (_fece +_bbcb ,_cadc );_acfde !=nil {return _acfde ;};return nil ;};func (_ebbc *Gray2 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_ebbc .Width ,Y :_ebbc .Height }};
};func _bedf (){for _caeg :=0;_caeg < 256;_caeg ++{_cbc [_caeg ]=uint8 (_caeg &0x1)+(uint8 (_caeg >>1)&0x1)+(uint8 (_caeg >>2)&0x1)+(uint8 (_caeg >>3)&0x1)+(uint8 (_caeg >>4)&0x1)+(uint8 (_caeg >>5)&0x1)+(uint8 (_caeg >>6)&0x1)+(uint8 (_caeg >>7)&0x1);
};};func _afb (_acc ,_ege *Monochrome ,_gdc []byte ,_afbg int )(_fd error ){var (_bga ,_faf ,_fee ,_cdf ,_gccb ,_acfc ,_gfb ,_deg int ;_gdfd ,_ccea uint32 ;_bdf ,_gec byte ;_ece uint16 ;);_ccdb :=make ([]byte ,4);_bed :=make ([]byte ,4);for _fee =0;_fee < _acc .Height -1;
_fee ,_cdf =_fee +2,_cdf +1{_bga =_fee *_acc .BytesPerLine ;_faf =_cdf *_ege .BytesPerLine ;for _gccb ,_acfc =0,0;_gccb < _afbg ;_gccb ,_acfc =_gccb +4,_acfc +1{for _gfb =0;_gfb < 4;_gfb ++{_deg =_bga +_gccb +_gfb ;if _deg <=len (_acc .Data )-1&&_deg < _bga +_acc .BytesPerLine {_ccdb [_gfb ]=_acc .Data [_deg ];
}else {_ccdb [_gfb ]=0x00;};_deg =_bga +_acc .BytesPerLine +_gccb +_gfb ;if _deg <=len (_acc .Data )-1&&_deg < _bga +(2*_acc .BytesPerLine ){_bed [_gfb ]=_acc .Data [_deg ];}else {_bed [_gfb ]=0x00;};};_gdfd =_bb .BigEndian .Uint32 (_ccdb );_ccea =_bb .BigEndian .Uint32 (_bed );
_ccea &=_gdfd ;_ccea &=_ccea <<1;_ccea &=0xaaaaaaaa;_gdfd =_ccea |(_ccea <<7);_bdf =byte (_gdfd >>24);_gec =byte ((_gdfd >>8)&0xff);_deg =_faf +_acfc ;if _deg +1==len (_ege .Data )-1||_deg +1>=_faf +_ege .BytesPerLine {_ege .Data [_deg ]=_gdc [_bdf ];if _fd =_ege .setByte (_deg ,_gdc [_bdf ]);
_fd !=nil {return _bc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_deg );};}else {_ece =(uint16 (_gdc [_bdf ])<<8)|uint16 (_gdc [_gec ]);if _fd =_ege .setTwoBytes (_deg ,_ece );_fd !=nil {return _bc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_deg );
};_acfc ++;};};};return nil ;};func _adaf (_deaad RGBA ,_geea Gray ,_cggg _be .Rectangle ){for _dfffe :=0;_dfffe < _cggg .Max .X ;_dfffe ++{for _bbb :=0;_bbb < _cggg .Max .Y ;_bbb ++{_effg :=_egg (_deaad .RGBAAt (_dfffe ,_bbb ));_geea .SetGray (_dfffe ,_bbb ,_effg );
};};};func _ggddf (_bgdag Gray ,_bcbgf RGBA ,_eabf _be .Rectangle ){for _cbcf :=0;_cbcf < _eabf .Max .X ;_cbcf ++{for _bedg :=0;_bedg < _eabf .Max .Y ;_bedg ++{_ggecg :=_bgdag .GrayAt (_cbcf ,_bedg );_bcbgf .SetRGBA (_cbcf ,_bedg ,_ddcc (_ggecg ));};};
};func _cbff (_fagb _f .CMYK )_f .NRGBA {_fgac ,_cacg ,_fcga :=_f .CMYKToRGB (_fagb .C ,_fagb .M ,_fagb .Y ,_fagb .K );return _f .NRGBA {R :_fgac ,G :_cacg ,B :_fcga ,A :0xff};};func _abe (_gbg _be .Image )(Image ,error ){if _gcb ,_efg :=_gbg .(*Monochrome );
_efg {return _gcb ,nil ;};_adff :=_gbg .Bounds ();var _adgc Gray ;switch _cfge :=_gbg .(type ){case Gray :_adgc =_cfge ;case NRGBA :_adgc =&Gray8 {ImageBase :NewImageBase (_adff .Max .X ,_adff .Max .Y ,8,1,nil ,nil ,nil )};_gacc (_adgc ,_cfge ,_adff );
case nrgba64 :_adgc =&Gray8 {ImageBase :NewImageBase (_adff .Max .X ,_adff .Max .Y ,8,1,nil ,nil ,nil )};_fbdc (_adgc ,_cfge ,_adff );default:_dbbag ,_defa :=GrayConverter .Convert (_gbg );if _defa !=nil {return nil ,_defa ;};_adgc =_dbbag .(Gray );};_cabd ,_caea :=NewImage (_adff .Max .X ,_adff .Max .Y ,1,1,nil ,nil ,nil );
if _caea !=nil {return nil ,_caea ;};_ebga :=_cabd .(*Monochrome );_egcc :=AutoThresholdTriangle (GrayHistogram (_adgc ));for _bgee :=0;_bgee < _adff .Max .X ;_bgee ++{for _bgd :=0;_bgd < _adff .Max .Y ;_bgd ++{_bdga :=_feba (_adgc .GrayAt (_bgee ,_bgd ),monochromeModel (_egcc ));
_ebga .SetGray (_bgee ,_bgd ,_bdga );};};return _cabd ,nil ;};func _gced (_egbc int ,_bfbd int )int {if _egbc < _bfbd {return _egbc ;};return _bfbd ;};func _fbgfd (_bfbg nrgba64 ,_cccf NRGBA ,_bacd _be .Rectangle ){for _ceeb :=0;_ceeb < _bacd .Max .X ;
_ceeb ++{for _aafcb :=0;_aafcb < _bacd .Max .Y ;_aafcb ++{_dcgb :=_bfbg .NRGBA64At (_ceeb ,_aafcb );_cccf .SetNRGBA (_ceeb ,_aafcb ,_gbd (_dcgb ));};};};func _fbgf (_gfeg *Monochrome ,_fbbc ,_ggdd ,_bdgda ,_feaf int ,_aaa RasterOperator ,_aefb *Monochrome ,_fgcfa ,_ecga int )error {var (_feagf bool ;
_cdge bool ;_gebd int ;_fcae int ;_ebaa int ;_dcde bool ;_acad byte ;_cdc int ;_ddcd int ;_agbc int ;_faae ,_gccf int ;);_ebfe :=8-(_fbbc &7);_cga :=_edgc [_ebfe ];_facd :=_gfeg .BytesPerLine *_ggdd +(_fbbc >>3);_daff :=_aefb .BytesPerLine *_ecga +(_fgcfa >>3);
if _bdgda < _ebfe {_feagf =true ;_cga &=_ebfd [8-_ebfe +_bdgda ];};if !_feagf {_gebd =(_bdgda -_ebfe )>>3;if _gebd > 0{_cdge =true ;_fcae =_facd +1;_ebaa =_daff +1;};};_cdc =(_fbbc +_bdgda )&7;if !(_feagf ||_cdc ==0){_dcde =true ;_acad =_ebfd [_cdc ];_ddcd =_facd +1+_gebd ;
_agbc =_daff +1+_gebd ;};switch _aaa {case PixSrc :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],_aefb .Data [_daff ],_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;};if _cdge {for _faae =0;_faae < _feaf ;
_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]=_aefb .Data [_ebaa +_gccf ];};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],_aefb .Data [_agbc ],_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixNotSrc :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],^_aefb .Data [_daff ],_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;};
if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]=^_aefb .Data [_ebaa +_gccf ];};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],^_aefb .Data [_agbc ],_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixSrcOrDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],_aefb .Data [_daff ]|_gfeg .Data [_facd ],_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;
};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]|=_aefb .Data [_ebaa +_gccf ];};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],_aefb .Data [_agbc ]|_gfeg .Data [_ddcd ],_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixSrcAndDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],_aefb .Data [_daff ]&_gfeg .Data [_facd ],_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;
};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]&=_aefb .Data [_ebaa +_gccf ];};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],_aefb .Data [_agbc ]&_gfeg .Data [_ddcd ],_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixSrcXorDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],_aefb .Data [_daff ]^_gfeg .Data [_facd ],_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;
};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]^=_aefb .Data [_ebaa +_gccf ];};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],_aefb .Data [_agbc ]^_gfeg .Data [_ddcd ],_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixNotSrcOrDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],^(_aefb .Data [_daff ])|_gfeg .Data [_facd ],_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;
};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]|=^(_aefb .Data [_ebaa +_gccf ]);};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],^(_aefb .Data [_agbc ])|_gfeg .Data [_ddcd ],_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixNotSrcAndDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],^(_aefb .Data [_daff ])&_gfeg .Data [_facd ],_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;
};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]&=^_aefb .Data [_ebaa +_gccf ];};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],^(_aefb .Data [_agbc ])&_gfeg .Data [_ddcd ],_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixSrcOrNotDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],_aefb .Data [_daff ]|^(_gfeg .Data [_facd ]),_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;
};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]=_aefb .Data [_ebaa +_gccf ]|^(_gfeg .Data [_fcae +_gccf ]);};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;
_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],_aefb .Data [_agbc ]|^(_gfeg .Data [_ddcd ]),_acad );_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixSrcAndNotDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],_aefb .Data [_daff ]&^(_gfeg .Data [_facd ]),_cga );
_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]=_aefb .Data [_ebaa +_gccf ]&^(_gfeg .Data [_fcae +_gccf ]);};_fcae +=_gfeg .BytesPerLine ;
_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],_aefb .Data [_agbc ]&^(_gfeg .Data [_ddcd ]),_acad );_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixNotPixSrcOrDst :for _faae =0;
_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],^(_aefb .Data [_daff ]|_gfeg .Data [_facd ]),_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;
_gccf ++{_gfeg .Data [_fcae +_gccf ]=^(_aefb .Data [_ebaa +_gccf ]|_gfeg .Data [_fcae +_gccf ]);};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],^(_aefb .Data [_agbc ]|_gfeg .Data [_ddcd ]),_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixNotPixSrcAndDst :for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],^(_aefb .Data [_daff ]&_gfeg .Data [_facd ]),_cga );_facd +=_gfeg .BytesPerLine ;
_daff +=_aefb .BytesPerLine ;};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;_gccf ++{_gfeg .Data [_fcae +_gccf ]=^(_aefb .Data [_ebaa +_gccf ]&_gfeg .Data [_fcae +_gccf ]);};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;
};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],^(_aefb .Data [_agbc ]&_gfeg .Data [_ddcd ]),_acad );_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};case PixNotPixSrcXorDst :for _faae =0;
_faae < _feaf ;_faae ++{_gfeg .Data [_facd ]=_bebc (_gfeg .Data [_facd ],^(_aefb .Data [_daff ]^_gfeg .Data [_facd ]),_cga );_facd +=_gfeg .BytesPerLine ;_daff +=_aefb .BytesPerLine ;};if _cdge {for _faae =0;_faae < _feaf ;_faae ++{for _gccf =0;_gccf < _gebd ;
_gccf ++{_gfeg .Data [_fcae +_gccf ]=^(_aefb .Data [_ebaa +_gccf ]^_gfeg .Data [_fcae +_gccf ]);};_fcae +=_gfeg .BytesPerLine ;_ebaa +=_aefb .BytesPerLine ;};};if _dcde {for _faae =0;_faae < _feaf ;_faae ++{_gfeg .Data [_ddcd ]=_bebc (_gfeg .Data [_ddcd ],^(_aefb .Data [_agbc ]^_gfeg .Data [_ddcd ]),_acad );
_ddcd +=_gfeg .BytesPerLine ;_agbc +=_aefb .BytesPerLine ;};};default:_fg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_aaa );return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_ded *ImageBase )setEightFullBytes (_abd int ,_ebdd uint64 )error {if _abd +7> len (_ded .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ded .Data [_abd ]=byte ((_ebdd &0xff00000000000000)>>56);
_ded .Data [_abd +1]=byte ((_ebdd &0xff000000000000)>>48);_ded .Data [_abd +2]=byte ((_ebdd &0xff0000000000)>>40);_ded .Data [_abd +3]=byte ((_ebdd &0xff00000000)>>32);_ded .Data [_abd +4]=byte ((_ebdd &0xff000000)>>24);_ded .Data [_abd +5]=byte ((_ebdd &0xff0000)>>16);
_ded .Data [_abd +6]=byte ((_ebdd &0xff00)>>8);_ded .Data [_abd +7]=byte (_ebdd &0xff);return nil ;};func (_bffb *RGBA32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtRGBA32 (x ,y ,_bffb .Width ,_bffb .Data ,_bffb .Alpha ,_bffb .Decode );};var _ Gray =&Gray16 {};
func (_adag *NRGBA64 )Base ()*ImageBase {return &_adag .ImageBase };func (_cefa *NRGBA16 )Base ()*ImageBase {return &_cefa .ImageBase };var _ Image =&Gray16 {};func _dcc (_gacg _f .RGBA )_f .NRGBA {switch _gacg .A {case 0xff:return _f .NRGBA {R :_gacg .R ,G :_gacg .G ,B :_gacg .B ,A :0xff};
case 0x00:return _f .NRGBA {};default:_fgeg ,_aab ,_fed ,_eaf :=_gacg .RGBA ();_fgeg =(_fgeg *0xffff)/_eaf ;_aab =(_aab *0xffff)/_eaf ;_fed =(_fed *0xffff)/_eaf ;return _f .NRGBA {R :uint8 (_fgeg >>8),G :uint8 (_aab >>8),B :uint8 (_fed >>8),A :uint8 (_eaf >>8)};
};};func (_gggd *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_gggd .copy ()}};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};var (MonochromeConverter =ConverterFunc (_abe );Gray2Converter =ConverterFunc (_ccdc );Gray4Converter =ConverterFunc (_cbda );
GrayConverter =ConverterFunc (_bffd );Gray16Converter =ConverterFunc (_dece );NRGBA16Converter =ConverterFunc (_agea );NRGBAConverter =ConverterFunc (_bgeed );NRGBA64Converter =ConverterFunc (_ebba );RGBAConverter =ConverterFunc (_cgff );CMYKConverter =ConverterFunc (_fff );
);func (_ddge *Gray16 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_ddge .Width ,Y :_ddge .Height }};};type Gray4 struct{ImageBase };func _aad (_ega ,_dbb int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_ega ,_dbb ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func (_bgabab *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bgabab .copy ()}};func _gbdba (_fdfe CMYK ,_eedcb RGBA ,_gddd _be .Rectangle ){for _edfb :=0;_edfb < _gddd .Max .X ;_edfb ++{for _ecdfg :=0;_ecdfg < _gddd .Max .Y ;_ecdfg ++{_dccg :=_fdfe .CMYKAt (_edfb ,_ecdfg );
_eedcb .SetRGBA (_edfb ,_ecdfg ,_fcce (_dccg ));};};};func _eead (_beda _be .Image ,_dbbb Image ,_bbed _be .Rectangle ){switch _feg :=_beda .(type ){case Gray :_fdb (_feg ,_dbbb .(Gray ),_bbed );case NRGBA :_gdff (_feg ,_dbbb .(Gray ),_bbed );case CMYK :_ccbb (_feg ,_dbbb .(Gray ),_bbed );
case RGBA :_adaf (_feg ,_dbbb .(Gray ),_bbed );default:_egf (_beda ,_dbbb ,_bbed );};};func _fbdc (_cfb Gray ,_bede nrgba64 ,_dcfg _be .Rectangle ){for _afad :=0;_afad < _dcfg .Max .X ;_afad ++{for _gfg :=0;_gfg < _dcfg .Max .Y ;_gfg ++{_daab :=_dage (_bede .NRGBA64At (_afad ,_gfg ));
_cfb .SetGray (_afad ,_gfg ,_daab );};};};var _ NRGBA =&NRGBA32 {};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fcde (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_dffa *NRGBA64 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dffa .Width ,_dffa .Data ,_dffa .Alpha ,_dffa .Decode );
};type NRGBA16 struct{ImageBase };func _bafg (_effeb _f .Gray )_f .Gray {_beff :=_effeb .Y >>6;_beff |=_beff <<2;_effeb .Y =_beff |_beff <<4;return _effeb ;};func (_abcg *Gray4 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray4BPC (x ,y ,_abcg .BytesPerLine ,_abcg .Data ,_abcg .Decode );
};type RasterOperator int ;func (_fdgc *Gray16 )At (x ,y int )_f .Color {_egde ,_ :=_fdgc .ColorAt (x ,y );return _egde };var (Gray2Model =_f .ModelFunc (_ggae );Gray4Model =_f .ModelFunc (_cfbd );NRGBA16Model =_f .ModelFunc (_eafe ););type NRGBA32 struct{ImageBase };
func _eedc (_bfbb RGBA ,_eec NRGBA ,_dcec _be .Rectangle ){for _fcgg :=0;_fcgg < _dcec .Max .X ;_fcgg ++{for _ebfdc :=0;_ebfdc < _dcec .Max .Y ;_ebfdc ++{_dbdd :=_bfbb .RGBAAt (_fcgg ,_ebfdc );_eec .SetNRGBA (_fcgg ,_ebfdc ,_dcc (_dbdd ));};};};func (_bfccf *NRGBA32 )ColorModel ()_f .Model {return _f .NRGBAModel };
func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA64 ,error ){_efgb :=(y *width +x )*2;_egda :=_efgb *3;if _egda +5>=len (data ){return _f .NRGBA64 {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _faga =0xffff;_dcae :=uint16 (_faga );if alpha !=nil &&len (alpha )> _efgb +1{_dcae =uint16 (alpha [_efgb ])<<8|uint16 (alpha [_efgb +1]);};_deed :=uint16 (data [_egda ])<<8|uint16 (data [_egda +1]);_ddea :=uint16 (data [_egda +2])<<8|uint16 (data [_egda +3]);
_befd :=uint16 (data [_egda +4])<<8|uint16 (data [_egda +5]);if len (decode )==6{_deed =uint16 (uint64 (LinearInterpolate (float64 (_deed ),0,65535,decode [0],decode [1]))&_faga );_ddea =uint16 (uint64 (LinearInterpolate (float64 (_ddea ),0,65535,decode [2],decode [3]))&_faga );
_befd =uint16 (uint64 (LinearInterpolate (float64 (_befd ),0,65535,decode [4],decode [5]))&_faga );};return _f .NRGBA64 {R :_deed ,G :_ddea ,B :_befd ,A :_dcae },nil ;};func (_cdd *ImageBase )setFourBytes (_dgaa int ,_bffe uint32 )error {if _dgaa +3> len (_cdd .Data )-1{return _bc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_dgaa );
};_cdd .Data [_dgaa ]=byte ((_bffe &0xff000000)>>24);_cdd .Data [_dgaa +1]=byte ((_bffe &0xff0000)>>16);_cdd .Data [_dgaa +2]=byte ((_bffe &0xff00)>>8);_cdd .Data [_dgaa +3]=byte (_bffe &0xff);return nil ;};func _cbda (_fgf _be .Image )(Image ,error ){if _fbbgf ,_fbac :=_fgf .(*Gray4 );
_fbac {return _fbbgf .Copy (),nil ;};_aadb :=_fgf .Bounds ();_bcfe ,_aada :=NewImage (_aadb .Max .X ,_aadb .Max .Y ,4,1,nil ,nil ,nil );if _aada !=nil {return nil ,_aada ;};_eead (_fgf ,_bcfe ,_aadb );return _bcfe ,nil ;};func (_cgbd *Gray8 )ColorModel ()_f .Model {return _f .GrayModel };
func _bcfg (_cfbeg _be .Image ,_ccceb Image ,_ddbe _be .Rectangle ){if _gafdb ,_caef :=_cfbeg .(SMasker );_caef &&_gafdb .HasAlpha (){_ccceb .(SMasker ).MakeAlpha ();};switch _edfg :=_cfbeg .(type ){case Gray :_acga (_edfg ,_ccceb .(NRGBA ),_ddbe );case NRGBA :_cfda (_edfg ,_ccceb .(NRGBA ),_ddbe );
case *_be .NYCbCrA :_gaggg (_edfg ,_ccceb .(NRGBA ),_ddbe );case CMYK :_ecba (_edfg ,_ccceb .(NRGBA ),_ddbe );case RGBA :_eedc (_edfg ,_ccceb .(NRGBA ),_ddbe );case nrgba64 :_fbgfd (_edfg ,_ccceb .(NRGBA ),_ddbe );default:_egf (_cfbeg ,_ccceb ,_ddbe );
};};func _cfda (_abgfd ,_efbda NRGBA ,_ebdb _be .Rectangle ){for _ccbba :=0;_ccbba < _ebdb .Max .X ;_ccbba ++{for _feagg :=0;_feagg < _ebdb .Max .Y ;_feagg ++{_efbda .SetNRGBA (_ccbba ,_feagg ,_abgfd .NRGBAAt (_ccbba ,_feagg ));};};};func (_bbe *Gray16 )Set (x ,y int ,c _f .Color ){_gdaef :=(y *_bbe .BytesPerLine /2+x )*2;
if _gdaef +1>=len (_bbe .Data ){return ;};_eafb :=_f .Gray16Model .Convert (c ).(_f .Gray16 );_bbe .Data [_gdaef ],_bbe .Data [_gdaef +1]=uint8 (_eafb .Y >>8),uint8 (_eafb .Y &0xff);};type Gray interface{GrayAt (_fgaeb ,_fbc int )_f .Gray ;SetGray (_bdgfc ,_fecb int ,_agde _f .Gray );
};var (_baa =_aa ();_gcf =_afa ();_ecc =_bbf (););func _gdfc (_gef _f .NYCbCrA )_f .RGBA {_gff ,_fgea ,_bcbf ,_ggg :=_begc (_gef ).RGBA ();return _f .RGBA {R :uint8 (_gff >>8),G :uint8 (_fgea >>8),B :uint8 (_bcbf >>8),A :uint8 (_ggg >>8)};};func (_fged *ImageBase )newAlpha (){_abfg :=BytesPerLine (_fged .Width ,_fged .BitsPerComponent ,1);
_fged .Alpha =make ([]byte ,_fged .Height *_abfg );};func (_fafd *Monochrome )Set (x ,y int ,c _f .Color ){_eega :=y *_fafd .BytesPerLine +x >>3;if _eega > len (_fafd .Data )-1{return ;};_abef :=_fafd .ColorModel ().Convert (c ).(_f .Gray );_fafd .setGray (x ,_abef ,_eega );
};func (_efc *Gray8 )At (x ,y int )_f .Color {_egcbe ,_ :=_efc .ColorAt (x ,y );return _egcbe };func _fae (_cbe ,_cea int ,_bgcg []byte )*Monochrome {_gae :=_aad (_cbe ,_cea );_gae .Data =_bgcg ;return _gae ;};func _begc (_fac _f .NYCbCrA )_f .NRGBA {_ddf :=int32 (_fac .Y )*0x10101;
_bbce :=int32 (_fac .Cb )-128;_fdf :=int32 (_fac .Cr )-128;_bdgc :=_ddf +91881*_fdf ;if uint32 (_bdgc )&0xff000000==0{_bdgc >>=8;}else {_bdgc =^(_bdgc >>31)&0xffff;};_fgcd :=_ddf -22554*_bbce -46802*_fdf ;if uint32 (_fgcd )&0xff000000==0{_fgcd >>=8;}else {_fgcd =^(_fgcd >>31)&0xffff;
};_dfe :=_ddf +116130*_bbce ;if uint32 (_dfe )&0xff000000==0{_dfe >>=8;}else {_dfe =^(_dfe >>31)&0xffff;};return _f .NRGBA {R :uint8 (_bdgc >>8),G :uint8 (_fgcd >>8),B :uint8 (_dfe >>8),A :_fac .A };};func _dece (_gfac _be .Image )(Image ,error ){if _eeec ,_dfgb :=_gfac .(*Gray16 );
_dfgb {return _eeec .Copy (),nil ;};_bad :=_gfac .Bounds ();_eged ,_gddc :=NewImage (_bad .Max .X ,_bad .Max .Y ,16,1,nil ,nil ,nil );if _gddc !=nil {return nil ,_gddc ;};_eead (_gfac ,_eged ,_bad );return _eged ,nil ;};func (_ggag *Monochrome )setBit (_eceab ,_gag int ){_ggag .Data [_eceab +(_gag >>3)]|=0x80>>uint (_gag &7);
};func (_ddeg *NRGBA32 )Validate ()error {if len (_ddeg .Data )!=3*_ddeg .Width *_ddeg .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_faaf *Gray4 )GrayAt (x ,y int )_f .Gray {_cdgg ,_ :=ColorAtGray4BPC (x ,y ,_faaf .BytesPerLine ,_faaf .Data ,_faaf .Decode );return _cdgg ;};func _baaf (_gge *Monochrome ,_dag ...int )(_ffc *Monochrome ,_fcd error ){if _gge ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_dag )==0{return nil ,_a .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_ggb :=_bagb ();_ffc =_gge ;for _ ,_ddg :=range _dag {if _ddg <=0{break ;};_ffc ,_fcd =_dgb (_ffc ,_ddg ,_ggb );if _fcd !=nil {return nil ,_fcd ;};};return _ffc ,nil ;};func (_ebe *Gray8 )GrayAt (x ,y int )_f .Gray {_defg ,_ :=ColorAtGray8BPC (x ,y ,_ebe .BytesPerLine ,_ebe .Data ,_ebe .Decode );
return _defg ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_cfged :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_cfged .Data =make ([]byte ,height *_cfged .BytesPerLine );};return _cfged ;};func (_acgaa *RGBA32 )ColorModel ()_f .Model {return _f .NRGBAModel };var _cbc [256]uint8 ;func (_dcfa monochromeModel )Convert (c _f .Color )_f .Color {_bgdc :=_f .GrayModel .Convert (c ).(_f .Gray );
return _feba (_bgdc ,_dcfa );};func _gffe (_cgfe _f .Gray )_f .Gray {_cgfe .Y >>=4;_cgfe .Y |=_cgfe .Y <<4;return _cgfe };func (_dbc *CMYK32 )CMYKAt (x ,y int )_f .CMYK {_bfe ,_ :=ColorAtCMYK (x ,y ,_dbc .Width ,_dbc .Data ,_dbc .Decode );return _bfe ;
};func _agea (_bgcf _be .Image )(Image ,error ){if _ccce ,_dgac :=_bgcf .(*NRGBA16 );_dgac {return _ccce .Copy (),nil ;};_dded :=_bgcf .Bounds ();_dacec ,_begb :=NewImage (_dded .Max .X ,_dded .Max .Y ,4,3,nil ,nil ,nil );if _begb !=nil {return nil ,_begb ;
};_bcfg (_bgcf ,_dacec ,_dded );return _dacec ,nil ;};func (_dbgc *Gray2 )ColorModel ()_f .Model {return Gray2Model };func (_aafd *NRGBA64 )At (x ,y int )_f .Color {_ccee ,_ :=_aafd .ColorAt (x ,y );return _ccee };func (_egac *NRGBA32 )NRGBAAt (x ,y int )_f .NRGBA {_ecab ,_ :=ColorAtNRGBA32 (x ,y ,_egac .Width ,_egac .Data ,_egac .Alpha ,_egac .Decode );
return _ecab ;};func ConverterFunc (converterFunc func (_gecb _be .Image )(Image ,error ))ColorConverter {return colorConverter {_edbc :converterFunc };};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_bc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_ebf *CMYK32 )ColorModel ()_f .Model {return _f .CMYKModel };func _aaee (_aeee uint )uint {var _aacgg uint ;for _aeee !=0{_aeee >>=1;_aacgg ++;};return _aacgg -1;};func GrayHistogram (g Gray )(_bddd [256]int ){switch _ebbg :=g .(type ){case Histogramer :return _ebbg .Histogram ();
case _be .Image :_eacf :=_ebbg .Bounds ();for _agdfd :=0;_agdfd < _eacf .Max .X ;_agdfd ++{for _ccbg :=0;_ccbg < _eacf .Max .Y ;_ccbg ++{_bddd [g .GrayAt (_agdfd ,_ccbg ).Y ]++;};};return _bddd ;default:return [256]int {};};};func (_bbda *Gray8 )Base ()*ImageBase {return &_bbda .ImageBase };
func (_edf *Gray16 )Validate ()error {if len (_edf .Data )!=_edf .Height *_edf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fbd *CMYK32 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_fbd .Width ,Y :_fbd .Height }};
};func _dac (_af ,_cgf *Monochrome )(_gfd error ){_afd :=_cgf .BytesPerLine ;_bfa :=_af .BytesPerLine ;var _dcf ,_dfg ,_ccec ,_cgc ,_db int ;for _ccec =0;_ccec < _cgf .Height ;_ccec ++{_dcf =_ccec *_afd ;_dfg =8*_ccec *_bfa ;for _cgc =0;_cgc < _afd ;_cgc ++{if _gfd =_af .setEightBytes (_dfg +_cgc *8,_ecc [_cgf .Data [_dcf +_cgc ]]);
_gfd !=nil {return _gfd ;};};for _db =1;_db < 8;_db ++{for _cgc =0;_cgc < _bfa ;_cgc ++{if _gfd =_af .setByte (_dfg +_db *_bfa +_cgc ,_af .Data [_dfg +_cgc ]);_gfd !=nil {return _gfd ;};};};};return nil ;};func _faef (_fgfc *_be .NYCbCrA ,_daaed RGBA ,_befda _be .Rectangle ){for _gcfb :=0;
_gcfb < _befda .Max .X ;_gcfb ++{for _bgce :=0;_bgce < _befda .Max .Y ;_bgce ++{_gagga :=_fgfc .NYCbCrAAt (_gcfb ,_bgce );_daaed .SetRGBA (_gcfb ,_bgce ,_gdfc (_gagga ));};};};func (_gggg *RGBA32 )SetRGBA (x ,y int ,c _f .RGBA ){_dbda :=y *_gggg .Width +x ;
_bbfdd :=3*_dbda ;if _bbfdd +2>=len (_gggg .Data ){return ;};_gggg .setRGBA (_dbda ,c );};var ErrInvalidImage =_a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_cca *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_a .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_bbdd :=_aad (width ,height );_dbce :=make ([]int ,height );_egd :=make ([]int ,width );_cec :=float64 (_cca .Width )/float64 (width );_dggea :=float64 (_cca .Height )/float64 (height );for _gdg :=0;_gdg < height ;_gdg ++{_dbce [_gdg ]=int (_b .Min (_dggea *float64 (_gdg )+0.5,float64 (_cca .Height -1)));
};for _gbcc :=0;_gbcc < width ;_gbcc ++{_egd [_gbcc ]=int (_b .Min (_cec *float64 (_gbcc )+0.5,float64 (_cca .Width -1)));};_dbg :=-1;_cdgbb :=byte (0);for _fabd :=0;_fabd < height ;_fabd ++{_befb :=_dbce [_fabd ]*_cca .BytesPerLine ;_baef :=_fabd *_bbdd .BytesPerLine ;
for _fgad :=0;_fgad < width ;_fgad ++{_dfcf :=_egd [_fgad ];if _dfcf !=_dbg {_cdgbb =_cca .getBit (_befb ,_dfcf );if _cdgbb !=0{_bbdd .setBit (_baef ,_fgad );};_dbg =_dfcf ;}else {if _cdgbb !=0{_bbdd .setBit (_baef ,_fgad );};};};};return _bbdd ,nil ;};
func (_feag *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _bggg bool ;_cdba :=scale ;if scale < 1{_cdba =1/scale ;_bggg =true ;};_bdb :=NextPowerOf2 (uint (_cdba ));if InDelta (float64 (_bdb ),_cdba ,0.001){if _bggg {return _feag .ReduceBinary (_cdba );
};return _feag .ExpandBinary (int (_bdb ));};_abcd :=int (_b .RoundToEven (float64 (_feag .Width )*scale ));_bcg :=int (_b .RoundToEven (float64 (_feag .Height )*scale ));return _feag .ScaleLow (_abcd ,_bcg );};func _dfgf (_fbbg Gray ,_aagc CMYK ,_fggd _be .Rectangle ){for _dcg :=0;
_dcg < _fggd .Max .X ;_dcg ++{for _gebf :=0;_gebf < _fggd .Max .Y ;_gebf ++{_cef :=_fbbg .GrayAt (_dcg ,_gebf );_aagc .SetCMYK (_dcg ,_gebf ,_fbbb (_cef ));};};};var _ Image =&Gray8 {};func _cced (_bcbcg _f .NRGBA )_f .NRGBA {_bcbcg .R =_bcbcg .R >>4|(_bcbcg .R >>4)<<4;
_bcbcg .G =_bcbcg .G >>4|(_bcbcg .G >>4)<<4;_bcbcg .B =_bcbcg .B >>4|(_bcbcg .B >>4)<<4;return _bcbcg ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_gfga *NRGBA16 )SetNRGBA (x ,y int ,c _f .NRGBA ){_baac :=y *_gfga .BytesPerLine +x *3/2;
if _baac +1>=len (_gfga .Data ){return ;};c =_cced (c );_gfga .setNRGBA (x ,y ,_baac ,c );};var _ Image =&RGBA32 {};func (_dgfdb *RGBA32 )setRGBA (_fagbb int ,_edac _f .RGBA ){_dcfaa :=3*_fagbb ;_dgfdb .Data [_dcfaa ]=_edac .R ;_dgfdb .Data [_dcfaa +1]=_edac .G ;
_dgfdb .Data [_dcfaa +2]=_edac .B ;if _fagbb < len (_dgfdb .Alpha ){_dgfdb .Alpha [_fagbb ]=_edac .A ;};};var _ RGBA =&RGBA32 {};var _ _be .Image =&NRGBA64 {};func (_dgcd *Monochrome )IsUnpadded ()bool {return (_dgcd .Width *_dgcd .Height )==len (_dgcd .Data )};
func (_aef *Gray16 )ColorModel ()_f .Model {return _f .Gray16Model };func (_cbdg *Gray4 )Validate ()error {if len (_cbdg .Data )!=_cbdg .Height *_cbdg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _eda (_efgd []byte ,_cdaa Image )error {_aaeea :=true ;
for _aabcb :=0;_aabcb < len (_efgd );_aabcb ++{if _efgd [_aabcb ]!=0xff{_aaeea =false ;break ;};};if _aaeea {switch _gafe :=_cdaa .(type ){case *NRGBA32 :_gafe .Alpha =nil ;case *NRGBA64 :_gafe .Alpha =nil ;default:return _bc .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_cdaa );
};};return nil ;};func (_cgce *NRGBA16 )ColorModel ()_f .Model {return NRGBA16Model };const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;
PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;
PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);var _ NRGBA =&NRGBA16 {};func _ebba (_efbdd _be .Image )(Image ,error ){if _fgee ,_edec :=_efbdd .(*NRGBA64 );
_edec {return _fgee .Copy (),nil ;};_edeg ,_gadd ,_ffcb :=_dgdbdd (_efbdd ,2);_gbgb ,_cdca :=NewImage (_edeg .Max .X ,_edeg .Max .Y ,16,3,nil ,_ffcb ,nil );if _cdca !=nil {return nil ,_cdca ;};_feea (_efbdd ,_gbgb ,_edeg );if len (_ffcb )!=0&&!_gadd {if _bbab :=_eda (_ffcb ,_gbgb );
_bbab !=nil {return nil ,_bbab ;};};return _gbgb ,nil ;};func (_ecf *Gray16 )GrayAt (x ,y int )_f .Gray {_adaca ,_ :=_ecf .ColorAt (x ,y );return _f .Gray {Y :uint8 (_adaca .(_f .Gray16 ).Y >>8)};};func _bagf (_ffdc *Monochrome ,_bcab ,_aegf ,_aadf ,_accg int ,_abedc RasterOperator ,_cadd *Monochrome ,_eag ,_dfbf int )error {var (_ddccd bool ;
_fdgca bool ;_facg byte ;_bdcd int ;_bceg int ;_agee int ;_fdced int ;_bbdc bool ;_gfaag int ;_fbdcd int ;_bcee int ;_gcdb bool ;_dbbacd byte ;_cdde int ;_dbd int ;_gde int ;_aeag byte ;_caaf int ;_gbae int ;_ddfb uint ;_dgfa uint ;_bbac byte ;_gafaa shift ;
_gadg bool ;_cegcb bool ;_abgf ,_baece int ;);if _eag &7!=0{_gbae =8-(_eag &7);};if _bcab &7!=0{_bceg =8-(_bcab &7);};if _gbae ==0&&_bceg ==0{_bbac =_edgc [0];}else {if _bceg > _gbae {_ddfb =uint (_bceg -_gbae );}else {_ddfb =uint (8-(_gbae -_bceg ));};
_dgfa =8-_ddfb ;_bbac =_edgc [_ddfb ];};if (_bcab &7)!=0{_ddccd =true ;_bdcd =8-(_bcab &7);_facg =_edgc [_bdcd ];_agee =_ffdc .BytesPerLine *_aegf +(_bcab >>3);_fdced =_cadd .BytesPerLine *_dfbf +(_eag >>3);_caaf =8-(_eag &7);if _bdcd > _caaf {_gafaa =_fecd ;
if _aadf >=_gbae {_gadg =true ;};}else {_gafaa =_gdffe ;};};if _aadf < _bdcd {_fdgca =true ;_facg &=_ebfd [8-_bdcd +_aadf ];};if !_fdgca {_gfaag =(_aadf -_bdcd )>>3;if _gfaag !=0{_bbdc =true ;_fbdcd =_ffdc .BytesPerLine *_aegf +((_bcab +_bceg )>>3);_bcee =_cadd .BytesPerLine *_dfbf +((_eag +_bceg )>>3);
};};_cdde =(_bcab +_aadf )&7;if !(_fdgca ||_cdde ==0){_gcdb =true ;_dbbacd =_ebfd [_cdde ];_dbd =_ffdc .BytesPerLine *_aegf +((_bcab +_bceg )>>3)+_gfaag ;_gde =_cadd .BytesPerLine *_dfbf +((_eag +_bceg )>>3)+_gfaag ;if _cdde > int (_dgfa ){_cegcb =true ;
};};switch _abedc {case PixSrc :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;
};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],_aeag ,_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );
_ffdc .Data [_fbdcd +_baece ]=_aeag ;};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );
};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],_aeag ,_dbbacd );_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};case PixNotSrc :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );
};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],^_aeag ,_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;
_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]=^_aeag ;};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;
if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],^_aeag ,_dbbacd );_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};case PixSrcOrDst :if _ddccd {for _abgf =0;_abgf < _accg ;
_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],_aeag |_ffdc .Data [_agee ],_facg );
_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]|=_aeag ;
};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],_aeag |_ffdc .Data [_dbd ],_dbbacd );
_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};case PixSrcAndDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );
};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],_aeag &_ffdc .Data [_agee ],_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;
_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]&=_aeag ;};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;
_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],_aeag &_ffdc .Data [_dbd ],_dbbacd );_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;
};};case PixSrcXorDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],_aeag ^_ffdc .Data [_agee ],_facg );
_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]^=_aeag ;
};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],_aeag ^_ffdc .Data [_dbd ],_dbbacd );
_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};case PixNotSrcOrDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );
};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],^_aeag |_ffdc .Data [_agee ],_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;
_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]|=^_aeag ;};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;
_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],^_aeag |_ffdc .Data [_dbd ],_dbbacd );_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;
};};case PixNotSrcAndDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],^_aeag &_ffdc .Data [_agee ],_facg );
_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]&=^_aeag ;
};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],^_aeag &_ffdc .Data [_dbd ],_dbbacd );
_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};case PixSrcOrNotDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );
};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],_aeag |^_ffdc .Data [_agee ],_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;
_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]=_aeag |^_ffdc .Data [_fbdcd +_baece ];};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;
};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],_aeag |^_ffdc .Data [_dbd ],_dbbacd );_dbd +=_ffdc .BytesPerLine ;
_gde +=_cadd .BytesPerLine ;};};case PixSrcAndNotDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;
};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],_aeag &^_ffdc .Data [_agee ],_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );
_ffdc .Data [_fbdcd +_baece ]=_aeag &^_ffdc .Data [_fbdcd +_baece ];};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );
};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],_aeag &^_ffdc .Data [_dbd ],_dbbacd );_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};case PixNotPixSrcOrDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;
if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],^(_aeag |_ffdc .Data [_agee ]),_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;
};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]=^(_aeag |_ffdc .Data [_fbdcd +_baece ]);
};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],^(_aeag |_ffdc .Data [_dbd ]),_dbbacd );
_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};case PixNotPixSrcAndDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );
};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],^(_aeag &_ffdc .Data [_agee ]),_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;
_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );_ffdc .Data [_fbdcd +_baece ]=^(_aeag &_ffdc .Data [_fbdcd +_baece ]);};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;
};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],^(_aeag &_ffdc .Data [_dbd ]),_dbbacd );_dbd +=_ffdc .BytesPerLine ;
_gde +=_cadd .BytesPerLine ;};};case PixNotPixSrcXorDst :if _ddccd {for _abgf =0;_abgf < _accg ;_abgf ++{if _gafaa ==_fecd {_aeag =_cadd .Data [_fdced ]<<_ddfb ;if _gadg {_aeag =_bebc (_aeag ,_cadd .Data [_fdced +1]>>_dgfa ,_bbac );};}else {_aeag =_cadd .Data [_fdced ]>>_dgfa ;
};_ffdc .Data [_agee ]=_bebc (_ffdc .Data [_agee ],^(_aeag ^_ffdc .Data [_agee ]),_facg );_agee +=_ffdc .BytesPerLine ;_fdced +=_cadd .BytesPerLine ;};};if _bbdc {for _abgf =0;_abgf < _accg ;_abgf ++{for _baece =0;_baece < _gfaag ;_baece ++{_aeag =_bebc (_cadd .Data [_bcee +_baece ]<<_ddfb ,_cadd .Data [_bcee +_baece +1]>>_dgfa ,_bbac );
_ffdc .Data [_fbdcd +_baece ]=^(_aeag ^_ffdc .Data [_fbdcd +_baece ]);};_fbdcd +=_ffdc .BytesPerLine ;_bcee +=_cadd .BytesPerLine ;};};if _gcdb {for _abgf =0;_abgf < _accg ;_abgf ++{_aeag =_cadd .Data [_gde ]<<_ddfb ;if _cegcb {_aeag =_bebc (_aeag ,_cadd .Data [_gde +1]>>_dgfa ,_bbac );
};_ffdc .Data [_dbd ]=_bebc (_ffdc .Data [_dbd ],^(_aeag ^_ffdc .Data [_dbd ]),_dbbacd );_dbd +=_ffdc .BytesPerLine ;_gde +=_cadd .BytesPerLine ;};};default:_fg .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_abedc );
return _a .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _gacc (_fcge Gray ,_dfgc NRGBA ,_cdef _be .Rectangle ){for _faba :=0;
_faba < _cdef .Max .X ;_faba ++{for _fbfd :=0;_fbfd < _cdef .Max .Y ;_fbfd ++{_dgc :=_ccc (_dfgc .NRGBAAt (_faba ,_fbfd ));_fcge .SetGray (_faba ,_fbfd ,_dgc );};};};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_g :=BytesPerLine (width ,8,1);
if len (data )< _g *height {return nil ,nil ;};_ef :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_ad ,_fgc :=MonochromeConverter .Convert (_ef );if _fgc !=nil {return nil ,_fgc ;};return _ad .Base ().Data ,nil ;};func (_faeb *Monochrome )clearBit (_cdeg ,_gaeab int ){_faeb .Data [_cdeg ]&=^(0x80>>uint (_gaeab &7))};
func _gf (_fgg *Monochrome ,_eb int ,_ac []uint )(*Monochrome ,error ){_fc :=_eb *_fgg .Width ;_efb :=_eb *_fgg .Height ;_beg :=_aad (_fc ,_efb );for _cc ,_ce :=range _ac {var _ccg error ;switch _ce {case 2:_ccg =_bef (_beg ,_fgg );case 4:_ccg =_de (_beg ,_fgg );
case 8:_ccg =_dac (_beg ,_fgg );};if _ccg !=nil {return nil ,_ccg ;};if _cc !=len (_ac )-1{_fgg =_beg .copy ();};};return _beg ,nil ;};func _acga (_ebfg Gray ,_aged NRGBA ,_ddfg _be .Rectangle ){for _addcf :=0;_addcf < _ddfg .Max .X ;_addcf ++{for _efgde :=0;
_efgde < _ddfg .Max .Y ;_efgde ++{_dgcdf :=_ebfg .GrayAt (_addcf ,_efgde );_aged .SetNRGBA (_addcf ,_efgde ,_cgef (_dgcdf ));};};};type ColorConverter interface{Convert (_dad _be .Image )(Image ,error );};func _ggda (_dcdea _be .Image ,_fagbf Image ,_aced _be .Rectangle ){if _eaa ,_ddged :=_dcdea .(SMasker );
_ddged &&_eaa .HasAlpha (){_fagbf .(SMasker ).MakeAlpha ();};switch _addf :=_dcdea .(type ){case Gray :_ggddf (_addf ,_fagbf .(RGBA ),_aced );case NRGBA :_gecf (_addf ,_fagbf .(RGBA ),_aced );case *_be .NYCbCrA :_faef (_addf ,_fagbf .(RGBA ),_aced );case CMYK :_gbdba (_addf ,_fagbf .(RGBA ),_aced );
case RGBA :_ecabd (_addf ,_fagbf .(RGBA ),_aced );case nrgba64 :_gedb (_addf ,_fagbf .(RGBA ),_aced );default:_egf (_dcdea ,_fagbf ,_aced );};};func (_fbbba *Gray8 )SetGray (x ,y int ,g _f .Gray ){_faeg :=y *_fbbba .BytesPerLine +x ;if _faeg > len (_fbbba .Data )-1{return ;
};_fbbba .Data [_faeg ]=g .Y ;};func _cfbd (_daged _f .Color )_f .Color {_cacb :=_f .GrayModel .Convert (_daged ).(_f .Gray );return _gffe (_cacb );};func (_aeb *Monochrome )At (x ,y int )_f .Color {_gda ,_ :=_aeb .ColorAt (x ,y );return _gda };func _ecba (_fcaa CMYK ,_egded NRGBA ,_gbff _be .Rectangle ){for _fafee :=0;
_fafee < _gbff .Max .X ;_fafee ++{for _addg :=0;_addg < _gbff .Max .Y ;_addg ++{_faee :=_fcaa .CMYKAt (_fafee ,_addg );_egded .SetNRGBA (_fafee ,_addg ,_cbff (_faee ));};};};func _gedb (_dbca nrgba64 ,_cfac RGBA ,_efcg _be .Rectangle ){for _faeef :=0;_faeef < _efcg .Max .X ;
_faeef ++{for _cged :=0;_cged < _efcg .Max .Y ;_cged ++{_dgdg :=_dbca .NRGBA64At (_faeef ,_cged );_cfac .SetRGBA (_faeef ,_cged ,_afeb (_dgdg ));};};};func (_gfab *NRGBA64 )Set (x ,y int ,c _f .Color ){_fccf :=(y *_gfab .Width +x )*2;_ddbg :=_fccf *3;if _ddbg +5>=len (_gfab .Data ){return ;
};_cbfa :=_f .NRGBA64Model .Convert (c ).(_f .NRGBA64 );_gfab .setNRGBA64 (_ddbg ,_cbfa ,_fccf );};func _adg (_egec _f .NRGBA )_f .Gray {_fab ,_dab ,_eac ,_ :=_egec .RGBA ();_defb :=(19595*_fab +38470*_dab +7471*_eac +1<<15)>>24;return _f .Gray {Y :uint8 (_defb )};
};var _ Image =&Gray4 {};func _acff (_ddbb *_be .Gray ,_bggf uint8 )*_be .Gray {_fded :=_ddbb .Bounds ();_dfea :=_be .NewGray (_fded );for _fgege :=0;_fgege < _fded .Dx ();_fgege ++{for _ecee :=0;_ecee < _fded .Dy ();_ecee ++{_cbce :=_ddbb .GrayAt (_fgege ,_ecee );
_dfea .SetGray (_fgege ,_ecee ,_f .Gray {Y :_gfbdf (_cbce .Y ,_bggf )});};};return _dfea ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _b .Abs (xmax -xmin )< 0.000001{return ymin ;};_ffce :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );
return _ffce ;};func _ccc (_gecd _f .NRGBA )_f .Gray {var _dea _f .NRGBA ;if _gecd ==_dea {return _f .Gray {Y :0xff};};_dgdb ,_ffa ,_bagg ,_ :=_gecd .RGBA ();_eegg :=(19595*_dgdb +38470*_ffa +7471*_bagg +1<<15)>>24;return _f .Gray {Y :uint8 (_eegg )};};
func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_adgb :=y *width +x ;_bcffa :=3*_adgb ;if _bcffa +2>=len (data ){return _f .NRGBA {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_aceg :=uint8 (0xff);if alpha !=nil &&len (alpha )> _adgb {_aceg =alpha [_adgb ];};_ecfa ,_cfgb ,_ddee :=data [_bcffa ],data [_bcffa +1],data [_bcffa +2];if len (decode )==6{_afgg :=LinearInterpolate (float64 (_ecfa ),0,255.0,decode [0],decode [1]);_egcd :=LinearInterpolate (float64 (_cfgb ),0,255.0,decode [2],decode [3]);
_cegb :=LinearInterpolate (float64 (_ddee ),0,255.0,decode [4],decode [5]);if _afgg <=1.0&&_egcd <=1.0&&_cegb <=1.0{_afgg *=255.0;_egcd *=255.0;_cegb *=255.0;};_ecfa =uint8 (_afgg )&0xff;_cfgb =uint8 (_egcd )&0xff;_ddee =uint8 (_cegb )&0xff;};return _f .NRGBA {R :_ecfa ,G :_cfgb ,B :_ddee ,A :_aceg },nil ;
};func _bffd (_abfe _be .Image )(Image ,error ){if _baggg ,_dgdbd :=_abfe .(*Gray8 );_dgdbd {return _baggg .Copy (),nil ;};_fbba :=_abfe .Bounds ();_bfbe ,_bbca :=NewImage (_fbba .Max .X ,_fbba .Max .Y ,8,1,nil ,nil ,nil );if _bbca !=nil {return nil ,_bbca ;
};_eead (_abfe ,_bfbe ,_fbba );return _bfbe ,nil ;};func (_cebag *Gray8 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray8BPC (x ,y ,_cebag .BytesPerLine ,_cebag .Data ,_cebag .Decode );};func _egf (_fdae _be .Image ,_abc Image ,_beb _be .Rectangle ){for _ebd :=0;
_ebd < _beb .Max .X ;_ebd ++{for _cba :=0;_cba < _beb .Max .Y ;_cba ++{_bac :=_fdae .At (_ebd ,_cba );_abc .Set (_ebd ,_cba ,_bac );};};};func (_aacc *NRGBA32 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_aacc .Width ,Y :_aacc .Height }};
};func (_gagg *NRGBA16 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_gagg .Width ,Y :_gagg .Height }};};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_bbfa :=y *bytesPerLine +x *3/2;
if _bbfa +1>=len (data ){return _f .NRGBA {},_cgbae (x ,y );};const (_cdbd =0xf;_bbge =uint8 (0xff););_ged :=_bbge ;if alpha !=nil {_gfge :=y *BytesPerLine (width ,4,1);if _gfge < len (alpha ){if x %2==0{_ged =(alpha [_gfge ]>>uint (4))&_cdbd ;}else {_ged =alpha [_gfge ]&_cdbd ;
};_ged |=_ged <<4;};};var _gdcb ,_eeb ,_bbddd uint8 ;if x *3%2==0{_gdcb =(data [_bbfa ]>>uint (4))&_cdbd ;_eeb =data [_bbfa ]&_cdbd ;_bbddd =(data [_bbfa +1]>>uint (4))&_cdbd ;}else {_gdcb =data [_bbfa ]&_cdbd ;_eeb =(data [_bbfa +1]>>uint (4))&_cdbd ;
_bbddd =data [_bbfa +1]&_cdbd ;};if len (decode )==6{_gdcb =uint8 (uint32 (LinearInterpolate (float64 (_gdcb ),0,15,decode [0],decode [1]))&0xf);_eeb =uint8 (uint32 (LinearInterpolate (float64 (_eeb ),0,15,decode [2],decode [3]))&0xf);_bbddd =uint8 (uint32 (LinearInterpolate (float64 (_bbddd ),0,15,decode [4],decode [5]))&0xf);
};return _f .NRGBA {R :(_gdcb <<4)|(_gdcb &0xf),G :(_eeb <<4)|(_eeb &0xf),B :(_bbddd <<4)|(_bbddd &0xf),A :_ged },nil ;};func (_bgda *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_bgda .copy ()}};func ImgToBinary (i _be .Image ,threshold uint8 )*_be .Gray {switch _bcfea :=i .(type ){case *_be .Gray :if _dfcb (_bcfea ){return _bcfea ;
};return _acff (_bcfea ,threshold );case *_be .Gray16 :return _cdfd (_bcfea ,threshold );default:return _ebgg (_bcfea ,threshold );};};func (_bdd *NRGBA32 )Base ()*ImageBase {return &_bdd .ImageBase };const (_fecd shift =iota ;_gdffe ;);func (_ace *Monochrome )ColorModel ()_f .Model {return MonochromeModel (_ace .ModelThreshold )};
type monochromeThresholdConverter struct{Threshold uint8 ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_f .CMYK ,error ){_cfd :=4*(y *width +x );if _cfd +3>=len (data ){return _f .CMYK {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_cfd ]&0xff;M :=data [_cfd +1]&0xff;Y :=data [_cfd +2]&0xff;K :=data [_cfd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _f .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_gdfa *NRGBA32 )At (x ,y int )_f .Color {_fdee ,_ :=_gdfa .ColorAt (x ,y );
return _fdee };func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_efgg *NRGBA16 )setNRGBA (_gece ,_fggc ,_bgaba int ,_fbbcg _f .NRGBA ){if _gece *3%2==0{_efgg .Data [_bgaba ]=(_fbbcg .R >>4)<<4|(_fbbcg .G >>4);
_efgg .Data [_bgaba +1]=(_fbbcg .B >>4)<<4|(_efgg .Data [_bgaba +1]&0xf);}else {_efgg .Data [_bgaba ]=(_efgg .Data [_bgaba ]&0xf0)|(_fbbcg .R >>4);_efgg .Data [_bgaba +1]=(_fbbcg .G >>4)<<4|(_fbbcg .B >>4);};if _efgg .Alpha !=nil {_agdd :=_fggc *BytesPerLine (_efgg .Width ,4,1);
if _agdd < len (_efgg .Alpha ){if _gece %2==0{_efgg .Alpha [_agdd ]=(_fbbcg .A >>uint (4))<<uint (4)|(_efgg .Alpha [_bgaba ]&0xf);}else {_efgg .Alpha [_agdd ]=(_efgg .Alpha [_agdd ]&0xf0)|(_fbbcg .A >>uint (4));};};};};func (_dbf *Gray4 )Histogram ()(_daabd [256]int ){for _dfff :=0;
_dfff < _dbf .Width ;_dfff ++{for _gfba :=0;_gfba < _dbf .Height ;_gfba ++{_daabd [_dbf .GrayAt (_dfff ,_gfba ).Y ]++;};};return _daabd ;};func _feea (_aaccf _be .Image ,_fgfd Image ,_ddffg _be .Rectangle ){if _feeag ,_aaef :=_aaccf .(SMasker );_aaef &&_feeag .HasAlpha (){_fgfd .(SMasker ).MakeAlpha ();
};_egf (_aaccf ,_fgfd ,_ddffg );};func (_fgd *ImageBase )HasAlpha ()bool {if _fgd .Alpha ==nil {return false ;};for _dgec :=range _fgd .Alpha {if _fgd .Alpha [_dgec ]!=0xff{return true ;};};return false ;};func (_dee *CMYK32 )Validate ()error {if len (_dee .Data )!=4*_dee .Width *_dee .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _ceb (_efe ,_bee *Monochrome ,_ccd []byte ,_aeec int )(_ccge error ){var (_ceba ,_feb ,_efbb ,_gdf ,_bgb ,_fcca ,_gga ,_ggac int ;_bgbd ,_daga ,_cag ,_eba uint32 ;_bbc ,_ecb byte ;_aagda uint16 ;);_gfaa :=make ([]byte ,4);_bagd :=make ([]byte ,4);
for _efbb =0;_efbb < _efe .Height -1;_efbb ,_gdf =_efbb +2,_gdf +1{_ceba =_efbb *_efe .BytesPerLine ;_feb =_gdf *_bee .BytesPerLine ;for _bgb ,_fcca =0,0;_bgb < _aeec ;_bgb ,_fcca =_bgb +4,_fcca +1{for _gga =0;_gga < 4;_gga ++{_ggac =_ceba +_bgb +_gga ;
if _ggac <=len (_efe .Data )-1&&_ggac < _ceba +_efe .BytesPerLine {_gfaa [_gga ]=_efe .Data [_ggac ];}else {_gfaa [_gga ]=0x00;};_ggac =_ceba +_efe .BytesPerLine +_bgb +_gga ;if _ggac <=len (_efe .Data )-1&&_ggac < _ceba +(2*_efe .BytesPerLine ){_bagd [_gga ]=_efe .Data [_ggac ];
}else {_bagd [_gga ]=0x00;};};_bgbd =_bb .BigEndian .Uint32 (_gfaa );_daga =_bb .BigEndian .Uint32 (_bagd );_cag =_bgbd &_daga ;_cag |=_cag <<1;_eba =_bgbd |_daga ;_eba &=_eba <<1;_daga =_cag &_eba ;_daga &=0xaaaaaaaa;_bgbd =_daga |(_daga <<7);_bbc =byte (_bgbd >>24);
_ecb =byte ((_bgbd >>8)&0xff);_ggac =_feb +_fcca ;if _ggac +1==len (_bee .Data )-1||_ggac +1>=_feb +_bee .BytesPerLine {if _ccge =_bee .setByte (_ggac ,_ccd [_bbc ]);_ccge !=nil {return _bc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ggac );
};}else {_aagda =(uint16 (_ccd [_bbc ])<<8)|uint16 (_ccd [_ecb ]);if _ccge =_bee .setTwoBytes (_ggac ,_aagda );_ccge !=nil {return _bc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ggac );
};_fcca ++;};};};return nil ;};func (_afbc *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_afbc .copy ()}};func (_ffff *Gray8 )Set (x ,y int ,c _f .Color ){_fgaa :=y *_ffff .BytesPerLine +x ;if _fgaa > len (_ffff .Data )-1{return ;};_gdfde :=_f .GrayModel .Convert (c );
_ffff .Data [_fgaa ]=_gdfde .(_f .Gray ).Y ;};func (_egbe *Monochrome )copy ()*Monochrome {_ccb :=_aad (_egbe .Width ,_egbe .Height );_ccb .ModelThreshold =_egbe .ModelThreshold ;_ccb .Data =make ([]byte ,len (_egbe .Data ));copy (_ccb .Data ,_egbe .Data );
if len (_egbe .Decode )!=0{_ccb .Decode =make ([]float64 ,len (_egbe .Decode ));copy (_ccb .Decode ,_egbe .Decode );};if len (_egbe .Alpha )!=0{_ccb .Alpha =make ([]byte ,len (_egbe .Alpha ));copy (_ccb .Alpha ,_egbe .Alpha );};return _ccb ;};var _ Image =&NRGBA16 {};
func _cgbae (_bcgab int ,_fdbg int )error {return _bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bcgab ,_fdbg );
};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .RGBA ,error ){_bfea :=y *width +x ;_egdd :=3*_bfea ;if _egdd +2>=len (data ){return _f .RGBA {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dbdaf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _bfea {_dbdaf =alpha [_bfea ];};_abcc ,_ebfda ,_fedeb :=data [_egdd ],data [_egdd +1],data [_egdd +2];if len (decode )==6{_abcc =uint8 (uint32 (LinearInterpolate (float64 (_abcc ),0,255,decode [0],decode [1]))&0xff);
_ebfda =uint8 (uint32 (LinearInterpolate (float64 (_ebfda ),0,255,decode [2],decode [3]))&0xff);_fedeb =uint8 (uint32 (LinearInterpolate (float64 (_fedeb ),0,255,decode [4],decode [5]))&0xff);};return _f .RGBA {R :_abcc ,G :_ebfda ,B :_fedeb ,A :_dbdaf },nil ;
};var _ _be .Image =&Gray4 {};func MonochromeModel (threshold uint8 )_f .Model {return monochromeModel (threshold )};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_fced :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _fced ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_aead :=width *colorComponents *bitsPerComponent ;_adgd :=_fced *8;_addb :=8-(_adgd -_aead );_adc :=_e .NewReader (data );_dbgb :=_fced -1;_gfdc :=make ([]byte ,_dbgb );_gfbf :=make ([]byte ,height *_fced );
_acb :=_e .NewWriterMSB (_gfbf );var _dgcb uint64 ;var _gebb error ;for _cfef :=0;_cfef < height ;_cfef ++{_ ,_gebb =_adc .Read (_gfdc );if _gebb !=nil {return nil ,_gebb ;};_ ,_gebb =_acb .Write (_gfdc );if _gebb !=nil {return nil ,_gebb ;};_dgcb ,_gebb =_adc .ReadBits (byte (_addb ));
if _gebb !=nil {return nil ,_gebb ;};_ ,_gebb =_acb .WriteBits (_dgcb ,_addb );if _gebb !=nil {return nil ,_gebb ;};_acb .FinishByte ();};return _gfbf ,nil ;};func (_fefag *CMYK32 )SetCMYK (x ,y int ,c _f .CMYK ){_bcf :=4*(y *_fefag .Width +x );if _bcf +3>=len (_fefag .Data ){return ;
};_fefag .Data [_bcf ]=c .C ;_fefag .Data [_bcf +1]=c .M ;_fefag .Data [_bcf +2]=c .Y ;_fefag .Data [_bcf +3]=c .K ;};type Image interface{_d .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_cbcb ,_bfede int )(_f .Color ,error );Validate ()error ;
};func (_agf *Gray2 )Validate ()error {if len (_agf .Data )!=_agf .Height *_agf .BytesPerLine {return ErrInvalidImage ;};return nil ;};var _ _be .Image =&Gray2 {};func _ddcc (_feec _f .Gray )_f .RGBA {return _f .RGBA {R :_feec .Y ,G :_feec .Y ,B :_feec .Y ,A :0xff}};
func (_dec *Monochrome )Histogram ()(_efbg [256]int ){for _ ,_bcfc :=range _dec .Data {_efbg [0xff]+=int (_cbc [_dec .Data [_bcfc ]]);};return _efbg ;};var _ Gray =&Gray2 {};func (_daf *Monochrome )setGrayBit (_eegb ,_fbgd int ){_daf .Data [_eegb ]|=0x80>>uint (_fbgd &7)};
func _afeb (_fad _f .NRGBA64 )_f .RGBA {_facc ,_agdf ,_fcfb ,_dge :=_fad .RGBA ();return _f .RGBA {R :uint8 (_facc >>8),G :uint8 (_agdf >>8),B :uint8 (_fcfb >>8),A :uint8 (_dge >>8)};};func _gdff (_eeff NRGBA ,_dda Gray ,_addc _be .Rectangle ){for _aacg :=0;
_aacg < _addc .Max .X ;_aacg ++{for _ggec :=0;_ggec < _addc .Max .Y ;_ggec ++{_ddgc :=_adg (_eeff .NRGBAAt (_aacg ,_ggec ));_dda .SetGray (_aacg ,_ggec ,_ddgc );};};};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_bc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _afa ()(_bgcb [256]uint32 ){for _efba :=0;_efba < 256;_efba ++{if _efba &0x01!=0{_bgcb [_efba ]|=0xf;};if _efba &0x02!=0{_bgcb [_efba ]|=0xf0;};if _efba &0x04!=0{_bgcb [_efba ]|=0xf00;};if _efba &0x08!=0{_bgcb [_efba ]|=0xf000;};if _efba &0x10!=0{_bgcb [_efba ]|=0xf0000;
};if _efba &0x20!=0{_bgcb [_efba ]|=0xf00000;};if _efba &0x40!=0{_bgcb [_efba ]|=0xf000000;};if _efba &0x80!=0{_bgcb [_efba ]|=0xf0000000;};};return _bgcb ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _ead ,_dgfc ,_dba ,_debe int ;for _ccbd :=0;
_ccbd < len (histogram );_ccbd ++{if histogram [_ccbd ]> 0{_ead =_ccbd ;break ;};};if _ead > 0{_ead --;};for _acge :=255;_acge > 0;_acge --{if histogram [_acge ]> 0{_debe =_acge ;break ;};};if _debe < 255{_debe ++;};for _defaf :=0;_defaf < 256;_defaf ++{if histogram [_defaf ]> _dgfc {_dba =_defaf ;
_dgfc =histogram [_defaf ];};};var _cfgc bool ;if (_dba -_ead )< (_debe -_dba ){_cfgc =true ;var _becd int ;_fgbb :=255;for _becd < _fgbb {_degc :=histogram [_becd ];histogram [_becd ]=histogram [_fgbb ];histogram [_fgbb ]=_degc ;_becd ++;_fgbb --;};_ead =255-_debe ;
_dba =255-_dba ;};if _ead ==_dba {return uint8 (_ead );};_afdb :=float64 (histogram [_dba ]);_gecg :=float64 (_ead -_dba );_acdaeg :=_b .Sqrt (_afdb *_afdb +_gecg *_gecg );_afdb /=_acdaeg ;_gecg /=_acdaeg ;_acdaeg =_afdb *float64 (_ead )+_gecg *float64 (histogram [_ead ]);
_bdfd :=_ead ;var _eaff float64 ;for _abfgc :=_ead +1;_abfgc <=_dba ;_abfgc ++{_facce :=_afdb *float64 (_abfgc )+_gecg *float64 (histogram [_abfgc ])-_acdaeg ;if _facce > _eaff {_bdfd =_abfgc ;_eaff =_facce ;};};_bdfd --;if _cfgc {var _agfe int ;_agc :=255;
for _agfe < _agc {_fgge :=histogram [_agfe ];histogram [_agfe ]=histogram [_agc ];histogram [_agc ]=_fgge ;_agfe ++;_agc --;};return uint8 (255-_bdfd );};return uint8 (_bdfd );};func (_cgd *Gray4 )SetGray (x ,y int ,g _f .Gray ){if x >=_cgd .Width ||y >=_cgd .Height {return ;
};g =_gffe (g );_cgd .setGray (x ,y ,g );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_bc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ Image =&Monochrome {};func _gecf (_bbdg NRGBA ,_fbda RGBA ,_eabg _be .Rectangle ){for _bbff :=0;_bbff < _eabg .Max .X ;_bbff ++{for _fabc :=0;_fabc < _eabg .Max .Y ;_fabc ++{_dfaf :=_bbdg .NRGBAAt (_bbff ,_fabc );_fbda .SetRGBA (_bbff ,_fabc ,_ccf (_dfaf ));
};};};func (_bbgg *Gray8 )Validate ()error {if len (_bbgg .Data )!=_bbgg .Height *_bbgg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gcbg *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_cgfd :=_aaee (uint (factor ));if !IsPowerOf2 (uint (factor )){_cgfd ++;
};_ccgd :=make ([]int ,_cgfd );for _adac :=range _ccgd {_ccgd [_adac ]=4;};_dabc ,_gbca :=_baaf (_gcbg ,_ccgd ...);if _gbca !=nil {return nil ,_gbca ;};return _dabc ,nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_ebca :=y *bytesPerLine +x ;
if _ebca >=len (data ){return _f .Gray {},_bc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_acee :=data [_ebca ];if len (decode )==2{_acee =uint8 (uint32 (LinearInterpolate (float64 (_acee ),0,255,decode [0],decode [1]))&0xff);};return _f .Gray {Y :_acee },nil ;};func _cdg (_ccgf ,_acfb CMYK ,_eea _be .Rectangle ){for _egb :=0;_egb < _eea .Max .X ;
_egb ++{for _cae :=0;_cae < _eea .Max .Y ;_cae ++{_acfb .SetCMYK (_egb ,_cae ,_ccgf .CMYKAt (_egb ,_cae ));};};};func (_cfea *Gray8 )Histogram ()(_gabd [256]int ){for _baag :=0;_baag < len (_cfea .Data );_baag ++{_gabd [_cfea .Data [_baag ]]++;};return _gabd ;
};type RGBA32 struct{ImageBase };func _fdb (_dgea ,_aafc Gray ,_dcfd _be .Rectangle ){for _gfdd :=0;_gfdd < _dcfd .Max .X ;_gfdd ++{for _agg :=0;_agg < _dcfd .Max .Y ;_agg ++{_aafc .SetGray (_gfdd ,_agg ,_dgea .GrayAt (_gfdd ,_agg ));};};};func _acf (_abf ,_dfa *Monochrome ,_bfgc []byte ,_ffg int )(_aee error ){var (_eed ,_gd ,_fgca ,_fcg ,_fgae ,_dagc ,_fbb ,_cbf int ;
_geb ,_aed ,_gbe ,_fbee uint32 ;_aagd ,_aeed byte ;_cac uint16 ;);_dbba :=make ([]byte ,4);_bff :=make ([]byte ,4);for _fgca =0;_fgca < _abf .Height -1;_fgca ,_fcg =_fgca +2,_fcg +1{_eed =_fgca *_abf .BytesPerLine ;_gd =_fcg *_dfa .BytesPerLine ;for _fgae ,_dagc =0,0;
_fgae < _ffg ;_fgae ,_dagc =_fgae +4,_dagc +1{for _fbb =0;_fbb < 4;_fbb ++{_cbf =_eed +_fgae +_fbb ;if _cbf <=len (_abf .Data )-1&&_cbf < _eed +_abf .BytesPerLine {_dbba [_fbb ]=_abf .Data [_cbf ];}else {_dbba [_fbb ]=0x00;};_cbf =_eed +_abf .BytesPerLine +_fgae +_fbb ;
if _cbf <=len (_abf .Data )-1&&_cbf < _eed +(2*_abf .BytesPerLine ){_bff [_fbb ]=_abf .Data [_cbf ];}else {_bff [_fbb ]=0x00;};};_geb =_bb .BigEndian .Uint32 (_dbba );_aed =_bb .BigEndian .Uint32 (_bff );_gbe =_geb &_aed ;_gbe |=_gbe <<1;_fbee =_geb |_aed ;
_fbee &=_fbee <<1;_aed =_gbe |_fbee ;_aed &=0xaaaaaaaa;_geb =_aed |(_aed <<7);_aagd =byte (_geb >>24);_aeed =byte ((_geb >>8)&0xff);_cbf =_gd +_dagc ;if _cbf +1==len (_dfa .Data )-1||_cbf +1>=_gd +_dfa .BytesPerLine {if _aee =_dfa .setByte (_cbf ,_bfgc [_aagd ]);
_aee !=nil {return _bc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_cbf );};}else {_cac =(uint16 (_bfgc [_aagd ])<<8)|uint16 (_bfgc [_aeed ]);if _aee =_dfa .setTwoBytes (_cbf ,_cac );_aee !=nil {return _bc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cbf );
};_dagc ++;};};};return nil ;};func _dfcb (_fcbe *_be .Gray )bool {for _bfcd :=0;_bfcd < len (_fcbe .Pix );_bfcd ++{if !_fdff (_fcbe .Pix [_bfcd ]){return false ;};};return true ;};func (_fade *ImageBase )setEightBytes (_ecfd int ,_fdfbg uint64 )error {_dce :=_fade .BytesPerLine -(_ecfd %_fade .BytesPerLine );
if _fade .BytesPerLine !=_fade .Width >>3{_dce --;};if _dce >=8{return _fade .setEightFullBytes (_ecfd ,_fdfbg );};return _fade .setEightPartlyBytes (_ecfd ,_dce ,_fdfbg );};func InDelta (expected ,current ,delta float64 )bool {_gbedd :=expected -current ;
if _gbedd <=-delta ||_gbedd >=delta {return false ;};return true ;};func (_agef *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_bc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _gb (_agef ,factor );};func (_cacd *Monochrome )getBitAt (_ecd ,_cgga int )bool {_gaab :=_cgga *_cacd .BytesPerLine +(_ecd >>3);_cad :=_ecd &0x07;_gcbb :=uint (7-_cad );if _gaab > len (_cacd .Data )-1{return false ;};if (_cacd .Data [_gaab ]>>_gcbb )&0x01>=1{return true ;
};return false ;};var _ Image =&Gray2 {};func (_ccabe *RGBA32 )Set (x ,y int ,c _f .Color ){_agfb :=y *_ccabe .Width +x ;_fbeb :=3*_agfb ;if _fbeb +2>=len (_ccabe .Data ){return ;};_gecbe :=_f .RGBAModel .Convert (c ).(_f .RGBA );_ccabe .setRGBA (_agfb ,_gecbe );
};func (_fdce *Gray8 )Bounds ()_be .Rectangle {return _be .Rectangle {Max :_be .Point {X :_fdce .Width ,Y :_fdce .Height }};};func (_ccca *NRGBA32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA32 (x ,y ,_ccca .Width ,_ccca .Data ,_ccca .Alpha ,_ccca .Decode );
};type nrgba64 interface{NRGBA64At (_bcd ,_baca int )_f .NRGBA64 ;SetNRGBA64 (_abcf ,_ffcg int ,_dffc _f .NRGBA64 );};func (_gbb *Gray16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray16BPC (x ,y ,_gbb .BytesPerLine ,_gbb .Data ,_gbb .Decode );
};func IsGrayImgBlackAndWhite (i *_be .Gray )bool {return _dfcb (i )};func (_bdeb *Gray16 )SetGray (x ,y int ,g _f .Gray ){_adba :=(y *_bdeb .BytesPerLine /2+x )*2;if _adba +1>=len (_bdeb .Data ){return ;};_bdeb .Data [_adba ]=g .Y ;_bdeb .Data [_adba +1]=g .Y ;
};func (_bcffg *NRGBA64 )ColorModel ()_f .Model {return _f .NRGBA64Model };func FromGoImage (i _be .Image )(Image ,error ){switch _ebee :=i .(type ){case Image :return _ebee .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_be .Gray16 :return Gray16Converter .Convert (i );
case CMYK :return CMYKConverter .Convert (i );case *_be .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};var _ Image =&NRGBA64 {};func (_gcbc *NRGBA64 )setNRGBA64 (_efdg int ,_ddgfa _f .NRGBA64 ,_fadg int ){_gcbc .Data [_efdg ]=uint8 (_ddgfa .R >>8);
_gcbc .Data [_efdg +1]=uint8 (_ddgfa .R &0xff);_gcbc .Data [_efdg +2]=uint8 (_ddgfa .G >>8);_gcbc .Data [_efdg +3]=uint8 (_ddgfa .G &0xff);_gcbc .Data [_efdg +4]=uint8 (_ddgfa .B >>8);_gcbc .Data [_efdg +5]=uint8 (_ddgfa .B &0xff);if _fadg +1< len (_gcbc .Alpha ){_gcbc .Alpha [_fadg ]=uint8 (_ddgfa .A >>8);
_gcbc .Alpha [_fadg +1]=uint8 (_ddgfa .A &0xff);};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_aagf *Monochrome )AddPadding ()(_aaf error ){if _egef :=((_aagf .Width *_aagf .Height )+7)>>3;
len (_aagf .Data )< _egef {return _bc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_aagf .Data ),_egef );
};_dgeg :=_aagf .Width %8;if _dgeg ==0{return nil ;};_fgga :=_aagf .Width /8;_bbfd :=_e .NewReader (_aagf .Data );_daabc :=make ([]byte ,_aagf .Height *_aagf .BytesPerLine );_gdd :=_e .NewWriterMSB (_daabc );_gabf :=make ([]byte ,_fgga );var (_fbcc int ;
_efa uint64 ;);for _fbcc =0;_fbcc < _aagf .Height ;_fbcc ++{if _ ,_aaf =_bbfd .Read (_gabf );_aaf !=nil {return _aaf ;};if _ ,_aaf =_gdd .Write (_gabf );_aaf !=nil {return _aaf ;};if _efa ,_aaf =_bbfd .ReadBits (byte (_dgeg ));_aaf !=nil {return _aaf ;
};if _aaf =_gdd .WriteByte (byte (_efa )<<uint (8-_dgeg ));_aaf !=nil {return _aaf ;};};_aagf .Data =_gdd .Data ();return nil ;};func (_cage *NRGBA32 )Set (x ,y int ,c _f .Color ){_acabe :=y *_cage .Width +x ;_gbcac :=3*_acabe ;if _gbcac +2>=len (_cage .Data ){return ;
};_gefd :=_f .NRGBAModel .Convert (c ).(_f .NRGBA );_cage .setRGBA (_acabe ,_gefd );};var _ _be .Image =&RGBA32 {};func (_fccad *ImageBase )setByte (_fegc int ,_abb byte )error {if _fegc > len (_fccad .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fccad .Data [_fegc ]=_abb ;return nil ;};