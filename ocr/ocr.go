//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package ocr ;import (_d "bytes";_de "context";_b "fmt";_da "github.com/unidoc/unipdf/v4/model";_eg "io";_c "mime/multipart";_g "net/http";_ee "os";_ce "path/filepath";_e "time";);

// ExtractText extracts text from an image reader.
// The filename parameter is used to set the filename in the multipart form data.
// If filename is empty, a default name based on content type will be used.
//
// Parameters:
//   - reader: Image data reader (e.g., file, buffer)
//   - filename: Optional filename for the uploaded file (used in multipart form)
func (_cfg *HTTPOCRService )ExtractText (ctx _de .Context ,reader _eg .Reader ,filename string )([]byte ,error ){if _cfg ._fa .Url ==""{return nil ,_b .Errorf ("n\u006f\u0020\u004f\u0043\u0052\u0020s\u0065\u0072\u0076\u0069\u0063\u0065\u0020\u0055\u0052L\u0020\u0070\u0072o\u0076i\u0064\u0065\u0064");
};if reader ==nil {return nil ,_b .Errorf ("r\u0065a\u0064\u0065\u0072\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065 n\u0069\u006c");};var _gc _d .Buffer ;_ddf :=_c .NewWriter (&_gc );if filename ==""{_gd :=make ([]byte ,512);_bfa ,_cdd :=reader .Read (_gd );
if _cdd !=nil &&_cdd !=_eg .EOF {return nil ,_b .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020r\u0065\u0061\u0064\u0020\u0066\u0072\u006fm\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u003a\u0020\u0025\u0077",_cdd );};_cbc :=_g .DetectContentType (_gd [:_bfa ]);
switch _cbc {case "\u0069\u006d\u0061\u0067\u0065\u002f\u006a\u0070\u0065\u0067":filename ="\u0069m\u0061\u0067\u0065\u002e\u006a\u0070g";case "\u0069m\u0061\u0067\u0065\u002f\u0070\u006eg":filename ="\u0069m\u0061\u0067\u0065\u002e\u0070\u006eg";case "\u0069m\u0061\u0067\u0065\u002f\u0067\u0069f":filename ="\u0069m\u0061\u0067\u0065\u002e\u0067\u0069f";
default:filename ="\u0069m\u0061\u0067\u0065\u002e\u006a\u0070g";};reader =_eg .MultiReader (_d .NewReader (_gd [:_bfa ]),reader );};_fbg ,_ebbg :=_ddf .CreateFormFile (_cfg ._fa .FileFieldName ,filename );if _ebbg !=nil {return nil ,_b .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020c\u0072\u0065\u0061\u0074\u0065\u0020\u0066o\u0072\u006d\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0077",_ebbg );
};_ ,_ebbg =_eg .Copy (_fbg ,reader );if _ebbg !=nil {return nil ,_b .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u006f\u0070\u0079\u0020\u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0077",_ebbg );};for _dga ,_bgg :=range _cfg ._fa .FormFields {_ebbg =_ddf .WriteField (_dga ,_bgg );
if _ebbg !=nil {return nil ,_b .Errorf ("\u0066\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0061\u0064\u0064\u0020\u0066\u006fr\u006d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073\u003a\u0020\u0025\u0077",_dga ,_ebbg );};};_ebbg =_ddf .Close ();
if _ebbg !=nil {return nil ,_b .Errorf ("\u0066\u0061il\u0065\u0064\u0020t\u006f\u0020\u0063\u006cose\u0020mu\u006c\u0074\u0069\u0070\u0061\u0072\u0074 w\u0072\u0069\u0074\u0065\u0072\u003a\u0020%\u0077",_ebbg );};_eca ,_ebbg :=_g .NewRequestWithContext (ctx ,_cfg ._fa .Method ,_cfg ._fa .Url ,&_gc );
if _ebbg !=nil {return nil ,_b .Errorf ("\u0066\u0061\u0069\u006ce\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061\u0074e\u0020r\u0065\u0071\u0075\u0065\u0073\u0074\u003a \u0025\u0077",_ebbg );};_eca .Header .Set ("\u0043\u006f\u006et\u0065\u006e\u0074\u002d\u0054\u0079\u0070\u0065",_ddf .FormDataContentType ());
for _ad ,_dbe :=range _cfg ._fa .Headers {_eca .Header .Set (_ad ,_dbe );};if _cfg ._fa .RequestModifier !=nil {if _cea :=_cfg ._fa .RequestModifier (_eca );_cea !=nil {return nil ,_b .Errorf ("r\u0065\u0071\u0075\u0065\u0073\u0074 \u006d\u006f\u0064\u0069\u0066\u0069\u0065\u0072\u0020f\u0061\u0069\u006ce\u0064:\u0020\u0025\u0077",_cea );
};};return _cfg .executeRequestWithRetry (ctx ,_eca );};

// HTTPOCRService implements OCRService using HTTP requests.
//
// This service is mainly designed to work with https://github.com/unidoc/ocrserver
// but can be adapted to other HTTP-based OCR services with similar APIs.
type HTTPOCRService struct{_fa OCROptions };

// OCROptions provides configuration for HTTP-based OCR services.
type OCROptions struct{

// URL for the OCR service.
Url string ;

// HTTP method to use for the OCR request (default: POST).
Method string ;

// Custom headers to add to the request.
Headers map[string ]string ;

// Form field name for the file upload (default: "file").
FileFieldName string ;

// Additional form fields to send with the request.
FormFields map[string ]string ;

// HTTP client timeout in seconds (default: 30).
TimeoutSeconds int ;

// Maximum number of retry attempts on failure (default: 0, no retry).
MaxRetries int ;

// Custom HTTP client (optional - if provided, TimeoutSeconds is ignored).
Client *_g .Client ;

// Custom request modifier function (called after request is created).
RequestModifier func (*_g .Request )error ;};

// Service returns the underlying OCR service.
func (_egf *Client )Service ()OCRService {return _egf ._cg };func (_fcf *HTTPOCRService )executeRequestWithRetry (_ff _de .Context ,_bcb *_g .Request )([]byte ,error ){_bge :=_fcf ._fa .Client ;if _bge ==nil {_bge =&_g .Client {Timeout :_e .Duration (_fcf ._fa .TimeoutSeconds )*_e .Second };
};_fb :=_fcf ._fa .MaxRetries +1;var _acb error ;for _gf :=0;_gf < _fb ;_gf ++{_ecd :=_bcb .Clone (_ff );_bfg ,_bb :=_bge .Do (_ecd );if _bb !=nil {_acb =_b .Errorf ("\u0066a\u0069\u006ce\u0064\u0020\u0074o\u0020\u0065\u0078\u0065\u0063\u0075\u0074e\u0020\u0072\u0065\u0071\u0075\u0065s\u0074\u0020\u0028\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0020%\u0064\u002f\u0025\u0064\u0029\u003a\u0020\u0025\u0077",_gf +1,_fb ,_bb );
if _gf < _fb -1{_e .Sleep (_e .Duration (_gf +1)*_e .Second );continue ;};break ;};defer _bfg .Body .Close ();_cae ,_bb :=_eg .ReadAll (_bfg .Body );if _bb !=nil {_acb =_b .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020t\u006f\u0020\u0072e\u0061\u0064\u0020\u0072e\u0073\u0070\u006f\u006e\u0073\u0065\u0020\u0028\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0025\u0064\u002f\u0025\u0064\u0029\u003a\u0020\u0025\u0077",_gf +1,_fb ,_bb );
if _gf < _fb -1{continue ;};break ;};if _bfg .StatusCode < 200||_bfg .StatusCode >=300{_acb =_b .Errorf ("\u0072\u0065\u0071\u0075\u0065\u0073t\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020%\u0073\u0020\u0028\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0025\u0064\u002f%\u0064)\u003a\u0020\u0025\u0073",_bfg .Status ,_gf +1,_fb ,string (_cae ));
if _gf < _fb -1{continue ;};break ;};return _cae ,nil ;};return nil ,_acb ;};

// ExtractText extracts text from an image reader
func (_ed *Client )ExtractText (ctx _de .Context ,reader _eg .Reader ,filename string )([]byte ,error ){if reader ==nil {return nil ,_b .Errorf ("r\u0065a\u0064\u0065\u0072\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065 n\u0069\u006c");};return _ed ._cg .ExtractText (ctx ,reader ,filename );
};

// BatchProcessFiles processes multiple image files concurrently from a list of file paths.
func (_ba *Client )BatchProcessFiles (ctx _de .Context ,filePaths []string )([][]byte ,[]error ){if len (filePaths )==0{return nil ,nil ;};_bca :=make ([][]byte ,len (filePaths ));_fc :=make ([]error ,len (filePaths ));_eag :=make (chan struct{},10);type result struct{_cb int ;
_cc []byte ;_ebb error ;};_bfe :=make (chan result ,len (filePaths ));for _dca ,_bg :=range filePaths {go func (_def int ,_defc string ){_eag <-struct{}{};defer func (){<-_eag }();_acc ,_df :=_ba .ExtractTextFromFile (ctx ,_defc );_bfe <-result {_cb :_def ,_cc :_acc ,_ebb :_df };
}(_dca ,_bg );};for _aae :=0;_aae < len (filePaths );_aae ++{_cbf :=<-_bfe ;_bca [_cbf ._cb ]=_cbf ._cc ;_fc [_cbf ._cb ]=_cbf ._ebb ;};return _bca ,_fc ;};

// NewOCRHTTPClient creates a new OCR client using HTTP service with the given options.
func NewOCRHTTPClient (options OCROptions )*Client {return &Client {_cg :NewHTTPOCRService (options )}};

// WithService returns a new client with the given service.
func (_aa *Client )WithService (service OCRService )*Client {return &Client {_cg :service }};

// CallEndpoint executes an HTTP request to the configured URL.
// This provides a general method for users to execute HTTP requests using
// the service's configured options (URL, method, headers, timeout, etc.).
//
// The URL, method, and headers are taken from the OCROptions used to create this service.
// To call different endpoints, create separate service instances with different URLs.
//
// Parameters:
//   - body: Request body (can be nil for GET requests or when no body is needed)
func (_aec *HTTPOCRService )CallEndpoint (ctx _de .Context ,body _eg .Reader )([]byte ,error ){if _aec ._fa .Url ==""{return nil ,_b .Errorf ("\u006e\u006f\u0020U\u0052\u004c\u0020\u0063o\u006e\u0066\u0069\u0067\u0075\u0072\u0065d\u0020\u0069\u006e\u0020\u004f\u0043\u0052\u004f\u0070\u0074\u0069\u006f\u006e\u0073");
};_gcg :=_aec ._fa .Method ;if _gcg ==""{_gcg ="\u0047\u0045\u0054";};_fag ,_gb :=_g .NewRequestWithContext (ctx ,_gcg ,_aec ._fa .Url ,body );if _gb !=nil {return nil ,_b .Errorf ("\u0066\u0061\u0069\u006ce\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061\u0074e\u0020r\u0065\u0071\u0075\u0065\u0073\u0074\u003a \u0025\u0077",_gb );
};for _cfb ,_bbd :=range _aec ._fa .Headers {_fag .Header .Set (_cfb ,_bbd );};if _aec ._fa .RequestModifier !=nil {if _bcd :=_aec ._fa .RequestModifier (_fag );_bcd !=nil {return nil ,_b .Errorf ("r\u0065\u0071\u0075\u0065\u0073\u0074 \u006d\u006f\u0064\u0069\u0066\u0069\u0065\u0072\u0020f\u0061\u0069\u006ce\u0064:\u0020\u0025\u0077",_bcd );
};};return _aec .executeRequestWithRetry (ctx ,_fag );};

// NewHTTPOCRService creates a new HTTP-based OCR service.
func NewHTTPOCRService (options OCROptions )*HTTPOCRService {if options .Method ==""{options .Method ="\u0050\u004f\u0053\u0054";};if options .FileFieldName ==""{options .FileFieldName ="\u0066\u0069\u006c\u0065";};if options .TimeoutSeconds ==0{options .TimeoutSeconds =30;
};if options .Headers ==nil {options .Headers =make (map[string ]string );};if options .FormFields ==nil {options .FormFields =make (map[string ]string );};return &HTTPOCRService {_fa :options };};

// ExtractTextFromImage extracts text from a UniPDF image
func (_dad *Client )ExtractTextFromImage (ctx _de .Context ,image *_da .Image )([]byte ,error ){if image ==nil {return nil ,_b .Errorf ("\u0069\u006d\u0061\u0067e \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c");};if len (image .Data )==0{return nil ,_b .Errorf ("\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u0069\u0073\u0020\u0065\u006d\u0070\u0074\u0079");
};_ca :=_d .NewReader (image .Data );_dc :="\u0069m\u0061\u0067\u0065\u002e\u006a\u0070g";return _dad ._cg .ExtractText (ctx ,_ca ,_dc );};

// OCRService defines the interface for OCR services.
type OCRService interface{

// ExtractText extracts text from an image reader.
// The filename parameter is used to set the filename in the multipart form data.
// If filename is empty, a default name based on content type will be used.
//
// Parameters:
//   - reader: Image data reader (e.g., file, buffer)
//   - filename: Optional filename for the uploaded file (used in multipart form)
ExtractText (_ebe _de .Context ,_bbc _eg .Reader ,_gff string )([]byte ,error );

// CallEndpoint executes an HTTP request using the service's configured URL and options.
CallEndpoint (_cff _de .Context ,_dgb _eg .Reader )([]byte ,error );};

// ExtractTextFromFile extracts text from an image file.
func (_daa *Client )ExtractTextFromFile (ctx _de .Context ,filePath string )([]byte ,error ){if filePath ==""{return nil ,_b .Errorf ("\u0066i\u006c\u0065\u0020\u0070a\u0074\u0068\u0020\u0063\u0061n\u006eo\u0074 \u0062\u0065\u0020\u0065\u006d\u0070\u0074y");
};_dd ,_f :=_ee .Open (filePath );if _f !=nil {return nil ,_b .Errorf ("\u0065r\u0072\u006f\u0072\u0020o\u0070\u0065\u006e\u0069\u006eg\u0020f\u0069l\u0065\u0020\u0025\u0073\u003a\u0020\u0025w",filePath ,_f );};defer _dd .Close ();_dg :=_ce .Base (filePath );
return _daa ._cg .ExtractText (ctx ,_dd ,_dg );};

// NewClient creates a new OCR client with the given service.
func NewClient (service OCRService )*Client {return &Client {_cg :service }};

// BatchProcess processes multiple images concurrently.
func (_bf *Client )BatchProcess (ctx _de .Context ,images []*_da .Image )([][]byte ,[]error ){if len (images )==0{return nil ,nil ;};_ae :=make ([][]byte ,len (images ));_edc :=make ([]error ,len (images ));_ea :=make (chan struct{},10);type result struct{_af int ;
_bc []byte ;_ge error ;};_cd :=make (chan result ,len (images ));for _afb ,_db :=range images {go func (_ced int ,_ceb *_da .Image ){_ea <-struct{}{};defer func (){<-_ea }();_aag ,_ac :=_bf .ExtractTextFromImage (ctx ,_ceb );_cd <-result {_af :_ced ,_bc :_aag ,_ge :_ac };
}(_afb ,_db );};for _cf :=0;_cf < len (images );_cf ++{_eb :=<-_cd ;_ae [_eb ._af ]=_eb ._bc ;_edc [_eb ._af ]=_eb ._ge ;};return _ae ,_edc ;};

// Client provides a high-level interface for OCR operations.
type Client struct{_cg OCRService };

// CallEndpoint executes an HTTP request using the underlying service's configured options.
// The URL, method, headers, and other settings are taken from the OCROptions
// used to create the service.
//
// To call different endpoints, create separate service instances with different URLs:
//
//	statusService := NewHTTPOCRService(OCROptions{Url: "http://localhost:8080/status", Method: "GET"})
//	ocrService := NewHTTPOCRService(OCROptions{Url: "http://localhost:8080/ocr", Method: "POST"})
//
// Parameters:
//   - body: Request body (can be nil for GET requests or when no body is needed)
//
// Example usage:
//
//	result, err := client.CallEndpoint(ctx, nil)              // GET request
//	result, err := client.CallEndpoint(ctx, requestBody)      // POST request with body
func (_ec *Client )CallEndpoint (ctx _de .Context ,body _eg .Reader )([]byte ,error ){return _ec ._cg .CallEndpoint (ctx ,body );};