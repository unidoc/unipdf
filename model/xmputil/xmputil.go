//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package xmputil provides abstraction used by the pdf document XMP Metadata.
package xmputil ;import (_fc "errors";_eg "fmt";_a "github.com/trimmer-io/go-xmp/models/pdf";_c "github.com/trimmer-io/go-xmp/models/xmp_base";_f "github.com/trimmer-io/go-xmp/models/xmp_mm";_eb "github.com/trimmer-io/go-xmp/xmp";_da "github.com/unidoc/unipdf/v4/core";
_cd "github.com/unidoc/unipdf/v4/internal/timeutils";_ab "github.com/unidoc/unipdf/v4/internal/uuid";_ad "github.com/unidoc/unipdf/v4/model/xmputil/pdfaextension";_d "github.com/unidoc/unipdf/v4/model/xmputil/pdfaid";_b "strconv";_g "time";);

// GetPdfaExtensionSchemas gets a pdfa extension schemas.
func (_ebc *Document )GetPdfaExtensionSchemas ()([]_ad .Schema ,error ){_cdd :=_ebc ._ec .FindModel (_ad .Namespace );if _cdd ==nil {return nil ,nil ;};_cb ,_ca :=_cdd .(*_ad .Model );if !_ca {return nil ,_eg .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u006d\u006f\u0064\u0065l f\u006fr \u0070\u0064\u0066\u0061\u0045\u0078\u0074en\u0073\u0069\u006f\u006e\u0073\u003a\u0020%\u0054",_cdd );
};return _cb .Schemas ,nil ;};

// PdfAID is the result of the XMP pdfaid metadata.
type PdfAID struct{Part int ;Conformance string ;};

// Document is an implementation of the xmp document.
// It is a wrapper over go-xmp/xmp.Document that provides some Pdf predefined functionality.
type Document struct{_ec *_eb .Document };

// MediaManagement are the values from the document media management metadata.
type MediaManagement struct{

// OriginalDocumentID  as media is imported and projects is started, an original-document ID
// must be created to identify a new document. This identifies a document as a conceptual entity.
OriginalDocumentID GUID ;

// DocumentID when a document is copied to a new file path or converted to a new format with
// Save As, another new document ID should usually be assigned. This identifies a general version or
// branch of a document. You can use it to track different versions or extracted portions of a document
// with the same original-document ID.
DocumentID GUID ;

// InstanceID to track a document’s editing history, you must assign a new instance ID
// whenever a document is saved after any changes. This uniquely identifies an exact version of a
// document. It is used in resource references (to identify both the document or part itself and the
// referenced or referencing documents), and in document-history resource events (to identify the
// document instance that resulted from the change).
InstanceID GUID ;

// DerivedFrom references the source document from which this one is derived,
// typically through a Save As operation that changes the file name or format. It is a minimal reference;
// missing components can be assumed to be unchanged. For example, a new version might only need
// to specify the instance ID and version number of the previous version, or a rendition might only need
// to specify the instance ID and rendition class of the original.
DerivedFrom *MediaManagementDerivedFrom ;

// VersionID are meant to associate the document with a product version that is part of a release process. They can be useful in tracking the
// document history, but should not be used to identify a document uniquely in any context.
// Usually it simply works by incrementing integers 1,2,3...
VersionID string ;

// Versions is the history of the document versions along with the comments, timestamps and issuers.
Versions []MediaManagementVersion ;};

// SetPdfInfo sets the pdf info into selected document.
func (_df *Document )SetPdfInfo (options *PdfInfoOptions )error {if options ==nil {return _fc .New ("\u006ei\u006c\u0020\u0070\u0064\u0066\u0020\u006f\u0070\u0074\u0069\u006fn\u0073\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064");};_cg ,_cf :=_a .MakeModel (_df ._ec );
if _cf !=nil {return _cf ;};if options .Overwrite {*_cg =_a .PDFInfo {};};if options .InfoDict !=nil {_gd ,_dd :=_da .GetDict (options .InfoDict );if !_dd {return _eg .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",options .InfoDict );
};var _ac *_da .PdfObjectString ;for _ ,_bfa :=range _gd .Keys (){switch _bfa {case "\u0054\u0069\u0074l\u0065":_ac ,_dd =_da .GetString (_gd .Get ("\u0054\u0069\u0074l\u0065"));if _dd {_cg .Title =_eb .NewAltString (_ac );};case "\u0041\u0075\u0074\u0068\u006f\u0072":_ac ,_dd =_da .GetString (_gd .Get ("\u0041\u0075\u0074\u0068\u006f\u0072"));
if _dd {_cg .Author =_eb .NewStringList (_ac .String ());};case "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073":_ac ,_dd =_da .GetString (_gd .Get ("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073"));if _dd {_cg .Keywords =_ac .String ();};case "\u0043r\u0065\u0061\u0074\u006f\u0072":_ac ,_dd =_da .GetString (_gd .Get ("\u0043r\u0065\u0061\u0074\u006f\u0072"));
if _dd {_cg .Creator =_eb .AgentName (_ac .String ());};case "\u0053u\u0062\u006a\u0065\u0063\u0074":_ac ,_dd =_da .GetString (_gd .Get ("\u0053u\u0062\u006a\u0065\u0063\u0074"));if _dd {_cg .Subject =_eb .NewAltString (_ac .String ());};case "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072":_ac ,_dd =_da .GetString (_gd .Get ("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072"));
if _dd {_cg .Producer =_eb .AgentName (_ac .String ());};case "\u0054r\u0061\u0070\u0070\u0065\u0064":_fab ,_caf :=_da .GetName (_gd .Get ("\u0054r\u0061\u0070\u0070\u0065\u0064"));if _caf {switch _fab .String (){case "\u0054\u0072\u0075\u0065":_cg .Trapped =true ;
case "\u0046\u0061\u006cs\u0065":_cg .Trapped =false ;default:_cg .Trapped =true ;};};case "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065":if _ff ,_dbg :=_da .GetString (_gd .Get ("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065"));
_dbg &&_ff .String ()!=""{_bcg ,_gg :=_cd .ParsePdfTime (_ff .String ());if _gg !=nil {return _eg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0072e\u0061\u0074\u0069\u006f\u006e\u0044\u0061t\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0077",_gg );
};_cg .CreationDate =_eb .NewDate (_bcg );};case "\u004do\u0064\u0044\u0061\u0074\u0065":if _eda ,_dg :=_da .GetString (_gd .Get ("\u004do\u0064\u0044\u0061\u0074\u0065"));_dg &&_eda .String ()!=""{_cbd ,_dae :=_cd .ParsePdfTime (_eda .String ());if _dae !=nil {return _eg .Errorf ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u004d\u006f\u0064\u0044a\u0074e\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025w",_dae );
};_cg .ModifyDate =_eb .NewDate (_cbd );};};};};if options .PdfVersion !=""{_cg .PDFVersion =options .PdfVersion ;};if options .Marked {_cg .Marked =_eb .Bool (options .Marked );};if options .Copyright !=""{_cg .Copyright =options .Copyright ;};if _cf =_cg .SyncToXMP (_df ._ec );
_cf !=nil {return _cf ;};return nil ;};

// Marshal the document into xml byte stream.
func (_dc *Document )Marshal ()([]byte ,error ){if _dc ._ec .IsDirty (){if _ea :=_dc ._ec .SyncModels ();_ea !=nil {return nil ,_ea ;};};return _eb .Marshal (_dc ._ec );};

// LoadDocument loads up the xmp document from provided input stream.
func LoadDocument (stream []byte )(*Document ,error ){_ge :=_eb .NewDocument ();if _bf :=_eb .Unmarshal (stream ,_ge );_bf !=nil {return nil ,_bf ;};return &Document {_ec :_ge },nil ;};

// PdfInfo is the xmp document pdf info.
type PdfInfo struct{InfoDict _da .PdfObject ;PdfVersion string ;Copyright string ;Marked bool ;};

// GetPdfInfo gets the document pdf info.
func (_daa *Document )GetPdfInfo ()(*PdfInfo ,bool ){_bbf :=PdfInfo {};var _fdd *_da .PdfObjectDictionary ;_cab :=func (_gc string ,_ag _da .PdfObject ){if _fdd ==nil {_fdd =_da .MakeDict ();};_fdd .Set (_da .PdfObjectName (_gc ),_ag );};_edd ,_dcb :=_daa ._ec .FindModel (_a .NsPDF ).(*_a .PDFInfo );
if !_dcb {_agd ,_ffd :=_daa ._ec .FindModel (_c .NsXmp ).(*_c .XmpBase );if !_ffd {return nil ,false ;};if _agd .CreatorTool !=""{_cab ("\u0043r\u0065\u0061\u0074\u006f\u0072",_da .MakeString (string (_agd .CreatorTool )));};if !_agd .CreateDate .IsZero (){_cab ("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065",_da .MakeString (_cd .FormatPdfTime (_agd .CreateDate .Value ())));
};if !_agd .ModifyDate .IsZero (){_cab ("\u004do\u0064\u0044\u0061\u0074\u0065",_da .MakeString (_cd .FormatPdfTime (_agd .ModifyDate .Value ())));};_bbf .InfoDict =_fdd ;return &_bbf ,true ;};_bbf .Copyright =_edd .Copyright ;_bbf .PdfVersion =_edd .PDFVersion ;
_bbf .Marked =bool (_edd .Marked );if len (_edd .Title )> 0{_cab ("\u0054\u0069\u0074l\u0065",_da .MakeString (_edd .Title .Default ()));};if len (_edd .Author )> 0{_cab ("\u0041\u0075\u0074\u0068\u006f\u0072",_da .MakeString (_edd .Author [0]));};if _edd .Keywords !=""{_cab ("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073",_da .MakeString (_edd .Keywords ));
};if len (_edd .Subject )> 0{_cab ("\u0053u\u0062\u006a\u0065\u0063\u0074",_da .MakeString (_edd .Subject .Default ()));};if _edd .Creator !=""{_cab ("\u0043r\u0065\u0061\u0074\u006f\u0072",_da .MakeString (string (_edd .Creator )));};if _edd .Producer !=""{_cab ("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072",_da .MakeString (string (_edd .Producer )));
};if _edd .Trapped {_cab ("\u0054r\u0061\u0070\u0070\u0065\u0064",_da .MakeName ("\u0054\u0072\u0075\u0065"));};if !_edd .CreationDate .IsZero (){_cab ("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065",_da .MakeString (_cd .FormatPdfTime (_edd .CreationDate .Value ())));
};if !_edd .ModifyDate .IsZero (){_cab ("\u004do\u0064\u0044\u0061\u0074\u0065",_da .MakeString (_cd .FormatPdfTime (_edd .ModifyDate .Value ())));};_bbf .InfoDict =_fdd ;return &_bbf ,true ;};

// GUID is a string representing a globally unique identifier.
type GUID string ;

// SetMediaManagement sets up XMP media management metadata: namespace xmpMM.
func (_bgf *Document )SetMediaManagement (options *MediaManagementOptions )error {_ga ,_acf :=_f .MakeModel (_bgf ._ec );if _acf !=nil {return _acf ;};if options ==nil {options =new (MediaManagementOptions );};_ce :=_f .ResourceRef {};switch {case options .DocumentID !="":_ga .DocumentID =_eb .GUID (options .DocumentID );
case options .NewDocumentID ||_ga .DocumentID .IsZero ():if !_ga .DocumentID .IsZero (){_ce .DocumentID =_ga .DocumentID ;};_aa ,_egg :=_ab .NewUUID ();if _egg !=nil {return _egg ;};_ga .DocumentID =_eb .GUID (_aa .String ());};if !_ga .InstanceID .IsZero (){_ce .InstanceID =_ga .InstanceID ;
};_ga .InstanceID =_eb .GUID (options .InstanceID );if _ga .InstanceID ==""{_ee ,_acff :=_ab .NewUUID ();if _acff !=nil {return _acff ;};_ga .InstanceID =_eb .GUID (_ee .String ());};if !_ce .IsZero (){_ga .DerivedFrom =&_ce ;};_cc :=options .VersionID ;
if _ga .VersionID !=""{_cddf ,_ebg :=_b .Atoi (_ga .VersionID );if _ebg !=nil {_cc =_b .Itoa (len (_ga .Versions )+1);}else {_cc =_b .Itoa (_cddf +1);};};if _cc ==""{_cc ="\u0031";};_ga .VersionID =_cc ;if _acf =_ga .SyncToXMP (_bgf ._ec );_acf !=nil {return _acf ;
};return nil ;};

// SetPdfAExtension sets the pdfaExtension XMP metadata.
func (_fa *Document )SetPdfAExtension ()error {_fd ,_bc :=_ad .MakeModel (_fa ._ec );if _bc !=nil {return _bc ;};if _bc =_ad .FillModel (_fa ._ec ,_fd );_bc !=nil {return _bc ;};if _bc =_fd .SyncToXMP (_fa ._ec );_bc !=nil {return _bc ;};return nil ;};


// NewDocument creates a new document without any previous xmp information.
func NewDocument ()*Document {_bb :=_eb .NewDocument ();return &Document {_ec :_bb }};

// GetPdfAID gets the pdfaid xmp metadata model.
func (_aag *Document )GetPdfAID ()(*PdfAID ,bool ){_bd ,_ecc :=_aag ._ec .FindModel (_d .Namespace ).(*_d .Model );if !_ecc {return nil ,false ;};return &PdfAID {Part :_bd .Part ,Conformance :_bd .Conformance },true ;};

// MediaManagementDerivedFrom is a structure that contains references of identifiers and versions
// from which given document was derived.
type MediaManagementDerivedFrom struct{OriginalDocumentID GUID ;DocumentID GUID ;InstanceID GUID ;VersionID string ;};

// GetMediaManagement gets the media management metadata from provided xmp document.
func (_gab *Document )GetMediaManagement ()(*MediaManagement ,bool ){_af :=_f .FindModel (_gab ._ec );if _af ==nil {return nil ,false ;};_ada :=make ([]MediaManagementVersion ,len (_af .Versions ));for _dag ,_ae :=range _af .Versions {_ada [_dag ]=MediaManagementVersion {VersionID :_ae .Version ,ModifyDate :_ae .ModifyDate .Value (),Comments :_ae .Comments ,Modifier :_ae .Modifier };
};_fad :=&MediaManagement {OriginalDocumentID :GUID (_af .OriginalDocumentID .Value ()),DocumentID :GUID (_af .DocumentID .Value ()),InstanceID :GUID (_af .InstanceID .Value ()),VersionID :_af .VersionID ,Versions :_ada };if _af .DerivedFrom !=nil {_fad .DerivedFrom =&MediaManagementDerivedFrom {OriginalDocumentID :GUID (_af .DerivedFrom .OriginalDocumentID ),DocumentID :GUID (_af .DerivedFrom .DocumentID ),InstanceID :GUID (_af .DerivedFrom .InstanceID ),VersionID :_af .DerivedFrom .VersionID };
};return _fad ,true ;};

// MediaManagementOptions are the options for the Media management xmp metadata.
type MediaManagementOptions struct{

// OriginalDocumentID  as media is imported and projects is started, an original-document ID
// must be created to identify a new document. This identifies a document as a conceptual entity.
// By default, this value is generated.
OriginalDocumentID string ;

// NewDocumentID is a flag which generates a new Document identifier while setting media management.
// This value should be set to true only if the document is stored and saved as new document.
// Otherwise, if the document is modified and overwrites previous file, it should be set to false.
NewDocumentID bool ;

// DocumentID when a document is copied to a new file path or converted to a new format with
// Save As, another new document ID should usually be assigned. This identifies a general version or
// branch of a document. You can use it to track different versions or extracted portions of a document
// with the same original-document ID.
// By default, this value is generated if NewDocumentID is true or previous doesn't exist.
DocumentID string ;

// InstanceID to track a document’s editing history, you must assign a new instance ID
// whenever a document is saved after any changes. This uniquely identifies an exact version of a
// document. It is used in resource references (to identify both the document or part itself and the
// referenced or referencing documents), and in document-history resource events (to identify the
// document instance that resulted from the change).
// By default, this value is generated.
InstanceID string ;

// DerivedFrom references the source document from which this one is derived,
// typically through a Save As operation that changes the file name or format. It is a minimal reference;
// missing components can be assumed to be unchanged. For example, a new version might only need
// to specify the instance ID and version number of the previous version, or a rendition might only need
// to specify the instance ID and rendition class of the original.
// By default, the derived from structure is filled from previous XMP metadata (if exists).
DerivedFrom string ;

// VersionID are meant to associate the document with a product version that is part of a release process. They can be useful in tracking the
// document history, but should not be used to identify a document uniquely in any context.
// Usually it simply works by incrementing integers 1,2,3...
// By default, this values is incremented or set to the next version number.
VersionID string ;

// ModifyComment is a comment to given modification
ModifyComment string ;

// ModifyDate is a custom modification date for the versions.
// By default, this would be set to time.Now().
ModifyDate _g .Time ;

// Modifier is a person who did the modification.
Modifier string ;};

// MarshalIndent the document into xml byte stream with predefined prefix and indent.
func (_ed *Document )MarshalIndent (prefix ,indent string )([]byte ,error ){if _ed ._ec .IsDirty (){if _db :=_ed ._ec .SyncModels ();_db !=nil {return nil ,_db ;};};return _eb .MarshalIndent (_ed ._ec ,prefix ,indent );};

// PdfInfoOptions are the options used for setting pdf info.
type PdfInfoOptions struct{InfoDict _da .PdfObject ;PdfVersion string ;Copyright string ;Marked bool ;

// Overwrite if set to true, overwrites all values found in the current pdf info xmp model to the ones provided.
Overwrite bool ;};

// SetPdfAID sets up pdfaid xmp metadata.
// In example: Part: '1' Conformance: 'B' states for PDF/A 1B.
func (_cfd *Document )SetPdfAID (part int ,conformance string )error {_cfg ,_fb :=_d .MakeModel (_cfd ._ec );if _fb !=nil {return _fb ;};_cfg .Part =part ;_cfg .Conformance =conformance ;if _ggb :=_cfg .SyncToXMP (_cfd ._ec );_ggb !=nil {return _ggb ;};
return nil ;};

// MediaManagementVersion is the version of the media management xmp metadata.
type MediaManagementVersion struct{VersionID string ;ModifyDate _g .Time ;Comments string ;Modifier string ;};

// GetGoXmpDocument gets direct access to the go-xmp.Document.
// All changes done to specified document would result in change of this document 'd'.
func (_ef *Document )GetGoXmpDocument ()*_eb .Document {return _ef ._ec };