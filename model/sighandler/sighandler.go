//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_ed "bytes";_cb "crypto";_cd "crypto/rand";_ad "crypto/rsa";_bd "crypto/x509";_ae "crypto/x509/pkix";_b "encoding/asn1";_ac "errors";_e "fmt";_ca "github.com/unidoc/pkcs7";_ge "github.com/unidoc/timestamp";_edb "github.com/unidoc/unipdf/v3/core";
_gd "github.com/unidoc/unipdf/v3/model";_ga "github.com/unidoc/unipdf/v3/model/mdp";_bg "github.com/unidoc/unipdf/v3/model/sigutil";_g "hash";_cf "math/big";_c "time";);

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_acca *adobeX509RSASHA1 )IsApplicable (sig *_gd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ad .PrivateKey ,certificate *_bd .Certificate )(_gd .SignatureHandler ,error ){return &adobePKCS7Detached {_dc :certificate ,_gce :privateKey },nil ;};

// Sign sets the Contents fields.
func (_gda *adobePKCS7Detached )Sign (sig *_gd .PdfSignature ,digest _gd .Hasher )error {if _gda ._bba {_eca :=_gda ._gcec ;if _eca <=0{_eca =8192;};sig .Contents =_edb .MakeHexString (string (make ([]byte ,_eca )));return nil ;};_fa :=digest .(*_ed .Buffer );
_ddc ,_adf :=_ca .NewSignedData (_fa .Bytes ());if _adf !=nil {return _adf ;};if _dg :=_ddc .AddSigner (_gda ._dc ,_gda ._gce ,_ca .SignerInfoConfig {});_dg !=nil {return _dg ;};_ddc .Detach ();_ecf ,_adf :=_ddc .Finish ();if _adf !=nil {return _adf ;};
_bc :=make ([]byte ,8192);copy (_bc ,_ecf );sig .Contents =_edb .MakeHexString (string (_bc ));return nil ;};type adobePKCS7Detached struct{_gce *_ad .PrivateKey ;_dc *_bd .Certificate ;_bba bool ;_gcec int ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _cb .Hash ;};type docTimeStamp struct{_ccb string ;_egec _cb .Hash ;_egc int ;_debc *_bg .TimestampClient ;};const _bee =_cb .SHA1 ;

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_fde *_gd .PdfSignature ,_edf _gd .Hasher )([]byte ,error );

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_bg .TimestampClient ;};func (_bfe *adobeX509RSASHA1 )sign (_fee *_gd .PdfSignature ,_cedg _gd .Hasher ,_cfg bool )error {if !_cfg {return _bfe .Sign (_fee ,_cedg );};_da ,_af :=_bfe ._ccg .PublicKey .(*_ad .PublicKey );if !_af {return _e .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_da );
};_gffd ,_cab :=_b .Marshal (make ([]byte ,_da .Size ()));if _cab !=nil {return _cab ;};_fee .Contents =_edb .MakeHexString (string (_gffd ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_ec *adobePKCS7Detached )InitSignature (sig *_gd .PdfSignature )error {if !_ec ._bba {if _ec ._dc ==nil {return _ac .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ec ._gce ==nil {return _ac .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fc :=*_ec ;sig .Handler =&_fc ;sig .Filter =_edb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_edb .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_eg ,_fd :=_fc .NewDigest (sig );if _fd !=nil {return _fd ;};_eg .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fc .Sign (sig ,_eg );};

// InitSignature initialises the PdfSignature.
func (_gadc *docTimeStamp )InitSignature (sig *_gd .PdfSignature )error {_gedf :=*_gadc ;sig .Handler =&_gedf ;sig .Filter =_edb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_edb .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");
sig .Reference =nil ;if _gadc ._egc > 0{sig .Contents =_edb .MakeHexString (string (make ([]byte ,_gadc ._egc )));}else {_gb ,_feac :=_gadc .NewDigest (sig );if _feac !=nil {return _feac ;};_gb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _feac =_gedf .Sign (sig ,_gb );_feac !=nil {return _feac ;};_gadc ._egc =_gedf ._egc ;};return nil ;};func (_ecaf *adobeX509RSASHA1 )getCertificate (_gfd *_gd .PdfSignature )(*_bd .Certificate ,error ){if _ecaf ._ccg !=nil {return _ecaf ._ccg ,nil ;
};_bgc ,_bde :=_gfd .GetCerts ();if _bde !=nil {return nil ,_bde ;};return _bgc [0],nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ea *docTimeStamp )IsApplicable (sig *_gd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};func _cfe (_cca _b .ObjectIdentifier )(_cb .Hash ,error ){switch {case _cca .Equal (_ca .OIDDigestAlgorithmSHA1 ),_cca .Equal (_ca .OIDDigestAlgorithmECDSASHA1 ),_cca .Equal (_ca .OIDDigestAlgorithmDSA ),_cca .Equal (_ca .OIDDigestAlgorithmDSASHA1 ),_cca .Equal (_ca .OIDEncryptionAlgorithmRSA ):return _cb .SHA1 ,nil ;
case _cca .Equal (_ca .OIDDigestAlgorithmSHA256 ),_cca .Equal (_ca .OIDDigestAlgorithmECDSASHA256 ):return _cb .SHA256 ,nil ;case _cca .Equal (_ca .OIDDigestAlgorithmSHA384 ),_cca .Equal (_ca .OIDDigestAlgorithmECDSASHA384 ):return _cb .SHA384 ,nil ;case _cca .Equal (_ca .OIDDigestAlgorithmSHA512 ),_cca .Equal (_ca .OIDDigestAlgorithmECDSASHA512 ):return _cb .SHA512 ,nil ;
};return _cb .Hash (0),_ca .ErrUnsupportedAlgorithm ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ad .PrivateKey ,certificate *_bd .Certificate )(_gd .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ccg :certificate ,_gef :privateKey },nil ;};func _cfb (_ged *_ad .PublicKey ,_gdg []byte )_cb .Hash {_eeea :=_ged .Size ();
if _eeea !=len (_gdg ){return 0;};_ecc :=func (_gge *_cf .Int ,_gage *_ad .PublicKey ,_daa *_cf .Int )*_cf .Int {_fdef :=_cf .NewInt (int64 (_gage .E ));_gge .Exp (_daa ,_fdef ,_gage .N );return _gge ;};_agf :=new (_cf .Int ).SetBytes (_gdg );_fba :=_ecc (new (_cf .Int ),_ged ,_agf );
_aee :=_ddf (_fba .Bytes (),_eeea );if _aee [0]!=0||_aee [1]!=1{return 0;};_afc :=[]struct{Hash _cb .Hash ;Prefix []byte ;}{{Hash :_cb .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_cb .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_cb .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_cb .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_cb .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_aae :=range _afc {_gdc :=_aae .Hash .Size ();_faf :=len (_aae .Prefix )+_gdc ;if _ed .Equal (_aee [_eeea -_faf :_eeea -_gdc ],_aae .Prefix ){return _aae .Hash ;};};return 0;};

// Sign adds a new reference to signature's references array.
func (_acc *DocMDPHandler )Sign (sig *_gd .PdfSignature ,digest _gd .Hasher )error {return _acc ._f .Sign (sig ,digest );};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_gd .SignatureHandler ,error ){return &adobePKCS7Detached {_bba :true ,_gcec :signatureLen },nil ;};

// InitSignature initialization of the DocMDP signature.
func (_cg *DocMDPHandler )InitSignature (sig *_gd .PdfSignature )error {_cbe :=_cg ._f .InitSignature (sig );if _cbe !=nil {return _cbe ;};sig .Handler =_cg ;if sig .Reference ==nil {sig .Reference =_edb .MakeArray ();};sig .Reference .Append (_gd .NewPdfSignatureReferenceDocMDP (_gd .NewPdfTransformParamsDocMDP (_cg .Permission )).ToPdfObject ());
return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_ced *adobePKCS7Detached )IsApplicable (sig *_gd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};type timestampInfo struct{Version int ;Policy _b .RawValue ;MessageImprint struct{HashAlgorithm _ae .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _b .RawValue ;GeneralizedTime _c .Time ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _cb .Hash ,opts *DocTimeStampOpts )(_gd .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_ccb :timestampServerURL ,_egec :hashAlgorithm ,_egc :opts .SignatureSize ,_debc :opts .Client },nil ;
};

// NewDigest creates a new digest.
func (_cef *adobeX509RSASHA1 )NewDigest (sig *_gd .PdfSignature )(_gd .Hasher ,error ){if _ceb ,_ccd :=_cef .getHashAlgorithm (sig );_ceb !=0&&_ccd ==nil {return _ceb .New (),nil ;};return _bee .New (),nil ;};type adobeX509RSASHA1 struct{_gef *_ad .PrivateKey ;
_ccg *_bd .Certificate ;_ffa SignFunc ;_dda bool ;_fcb _cb .Hash ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_gab *DocMDPHandler )Validate (sig *_gd .PdfSignature ,digest _gd .Hasher )(_gd .SignatureValidationResult ,error ){return _gd .SignatureValidationResult {},_ac .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// Validate validates PdfSignature.
func (_cgb *adobePKCS7Detached )Validate (sig *_gd .PdfSignature ,digest _gd .Hasher )(_gd .SignatureValidationResult ,error ){_fea :=sig .Contents .Bytes ();_gae ,_eed :=_ca .Parse (_fea );if _eed !=nil {return _gd .SignatureValidationResult {},_eed ;
};_df :=digest .(*_ed .Buffer );_gae .Content =_df .Bytes ();if _eed =_gae .Verify ();_eed !=nil {return _gd .SignatureValidationResult {},_eed ;};return _gd .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_gfdf *adobeX509RSASHA1 )Sign (sig *_gd .PdfSignature ,digest _gd .Hasher )error {var _ege []byte ;var _eba error ;if _gfdf ._ffa !=nil {_ege ,_eba =_gfdf ._ffa (sig ,digest );if _eba !=nil {return _eba ;};}else {_eff ,_eedd :=digest .(_g .Hash );
if !_eedd {return _ac .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fcc :=_bee ;if _gfdf ._fcb !=0{_fcc =_gfdf ._fcb ;};_ege ,_eba =_ad .SignPKCS1v15 (_cd .Reader ,_gfdf ._gef ,_fcc ,_eff .Sum (nil ));if _eba !=nil {return _eba ;
};};_ege ,_eba =_b .Marshal (_ege );if _eba !=nil {return _eba ;};sig .Contents =_edb .MakeHexString (string (_ege ));return nil ;};func (_gad *adobePKCS7Detached )getCertificate (_cc *_gd .PdfSignature )(*_bd .Certificate ,error ){if _gad ._dc !=nil {return _gad ._dc ,nil ;
};_eee ,_aaa :=_cc .GetCerts ();if _aaa !=nil {return nil ,_aaa ;};return _eee [0],nil ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_f _gd .SignatureHandler ;Permission _ga .DocMDPPermission ;};func _ddf (_gaa []byte ,_dcc int )(_cbaf []byte ){_fcba :=len (_gaa );if _fcba > _dcc {_fcba =_dcc ;};_cbaf =make ([]byte ,_dcc );copy (_cbaf [len (_cbaf )-_fcba :],_gaa );
return ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_bd .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_gd .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_ccg :certificate ,_ffa :signFunc ,_dda :opts .EstimateSize ,_fcb :opts .Algorithm },nil ;
};

// Sign sets the Contents fields for the PdfSignature.
func (_dbc *docTimeStamp )Sign (sig *_gd .PdfSignature ,digest _gd .Hasher )error {_geb ,_cgg :=_bg .NewTimestampRequest (digest .(*_ed .Buffer ),&_ge .RequestOptions {Hash :_dbc ._egec ,Certificates :true });if _cgg !=nil {return _cgg ;};_cabc :=_dbc ._debc ;
if _cabc ==nil {_cabc =_bg .NewTimestampClient ();};_cfbb ,_cgg :=_cabc .GetEncodedToken (_dbc ._ccb ,_geb );if _cgg !=nil {return _cgg ;};_efc :=len (_cfbb );if _dbc ._egc > 0&&_efc > _dbc ._egc {return _gd .ErrSignNotEnoughSpace ;};if _efc > 0{_dbc ._egc =_efc +128;
};if sig .Contents !=nil {_ddag :=sig .Contents .Bytes ();copy (_ddag ,_cfbb );_cfbb =_ddag ;};sig .Contents =_edb .MakeHexString (string (_cfbb ));return nil ;};

// NewDigest creates a new digest.
func (_bb *DocMDPHandler )NewDigest (sig *_gd .PdfSignature )(_gd .Hasher ,error ){return _bb ._f .NewDigest (sig );};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _gd .SignatureHandler ,permission _ga .DocMDPPermission )(_gd .SignatureHandler ,error ){return &DocMDPHandler {_f :handler ,Permission :permission },nil ;};

// InitSignature initialises the PdfSignature.
func (_adfc *adobeX509RSASHA1 )InitSignature (sig *_gd .PdfSignature )error {if _adfc ._ccg ==nil {return _ac .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _adfc ._gef ==nil &&_adfc ._ffa ==nil {return _ac .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_dcg :=*_adfc ;sig .Handler =&_dcg ;sig .Filter =_edb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_edb .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_edb .MakeString (string (_dcg ._ccg .Raw ));sig .Reference =nil ;_gea ,_adg :=_dcg .NewDigest (sig );if _adg !=nil {return _adg ;};_gea .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _dcg .sign (sig ,_gea ,_adfc ._dda );};

// NewDigest creates a new digest.
func (_cfbg *docTimeStamp )NewDigest (sig *_gd .PdfSignature )(_gd .Hasher ,error ){return _ed .NewBuffer (nil ),nil ;};

// Validate validates PdfSignature.
func (_bed *adobeX509RSASHA1 )Validate (sig *_gd .PdfSignature ,digest _gd .Hasher )(_gd .SignatureValidationResult ,error ){_aba ,_dfg :=_bed .getCertificate (sig );if _dfg !=nil {return _gd .SignatureValidationResult {},_dfg ;};_ef :=sig .Contents .Bytes ();
var _gff []byte ;if _ ,_ffb :=_b .Unmarshal (_ef ,&_gff );_ffb !=nil {return _gd .SignatureValidationResult {},_ffb ;};_db ,_ddg :=digest .(_g .Hash );if !_ddg {return _gd .SignatureValidationResult {},_ac .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gcd ,_ :=_bed .getHashAlgorithm (sig );if _gcd ==0{_gcd =_bee ;};if _ffbf :=_ad .VerifyPKCS1v15 (_aba .PublicKey .(*_ad .PublicKey ),_gcd ,_db .Sum (nil ),_gff );_ffbf !=nil {return _gd .SignatureValidationResult {},_ffbf ;};return _gd .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _cb .Hash )(_gd .SignatureHandler ,error ){return &docTimeStamp {_ccb :timestampServerURL ,_egec :hashAlgorithm },nil ;};

// Validate validates PdfSignature.
func (_egd *docTimeStamp )Validate (sig *_gd .PdfSignature ,digest _gd .Hasher )(_gd .SignatureValidationResult ,error ){_fce :=sig .Contents .Bytes ();_bgd ,_feg :=_ca .Parse (_fce );if _feg !=nil {return _gd .SignatureValidationResult {},_feg ;};if _feg =_bgd .Verify ();
_feg !=nil {return _gd .SignatureValidationResult {},_feg ;};var _bbc timestampInfo ;_ ,_feg =_b .Unmarshal (_bgd .Content ,&_bbc );if _feg !=nil {return _gd .SignatureValidationResult {},_feg ;};_faa ,_feg :=_cfe (_bbc .MessageImprint .HashAlgorithm .Algorithm );
if _feg !=nil {return _gd .SignatureValidationResult {},_feg ;};_cea :=_faa .New ();_bfda :=digest .(*_ed .Buffer );_cea .Write (_bfda .Bytes ());_ded :=_cea .Sum (nil );_dgd :=_gd .SignatureValidationResult {IsSigned :true ,IsVerified :_ed .Equal (_ded ,_bbc .MessageImprint .HashedMessage ),GeneralizedTime :_bbc .GeneralizedTime };
return _dgd ,nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_d *DocMDPHandler )IsApplicable (sig *_gd .PdfSignature )bool {_gf :=false ;for _ ,_bfd :=range sig .Reference .Elements (){if _ab ,_eb :=_edb .GetDict (_bfd );_eb {if _ba ,_ce :=_edb .GetNameVal (_ab .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_ce {if _ba !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _ebg ,_fg :=_edb .GetDict (_ab .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_fg {_ ,_gee :=_edb .GetNumberAsInt64 (_ebg .Get ("\u0050"));
if _gee !=nil {return false ;};_gf =true ;break ;};};};};return _gf &&_d ._f .IsApplicable (sig );};

// NewDigest creates a new digest.
func (_dd *adobePKCS7Detached )NewDigest (sig *_gd .PdfSignature )(_gd .Hasher ,error ){return _ed .NewBuffer (nil ),nil ;};func (_cbd *adobeX509RSASHA1 )getHashAlgorithm (_bbf *_gd .PdfSignature )(_cb .Hash ,error ){_ggg ,_acga :=_cbd .getCertificate (_bbf );
if _acga !=nil {if _cbd ._fcb !=0{return _cbd ._fcb ,nil ;};return _bee ,_acga ;};if _bbf .Contents !=nil {_adfb :=_bbf .Contents .Bytes ();var _ag []byte ;if _ ,_bbb :=_b .Unmarshal (_adfb ,&_ag );_bbb ==nil {_dgf :=_cfb (_ggg .PublicKey .(*_ad .PublicKey ),_ag );
if _dgf > 0{return _dgf ,nil ;};};};if _cbd ._fcb !=0{return _cbd ._fcb ,nil ;};return _bee ,nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_bd .Certificate ,signFunc SignFunc )(_gd .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ccg :certificate ,_ffa :signFunc },nil ;};func (_bdg *docTimeStamp )getCertificate (_bca *_gd .PdfSignature )(*_bd .Certificate ,error ){_abf ,_cag :=_bca .GetCerts ();
if _cag !=nil {return nil ,_cag ;};return _abf [0],nil ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_gdf *DocMDPHandler )ValidateWithOpts (sig *_gd .PdfSignature ,digest _gd .Hasher ,params _gd .SignatureHandlerDocMDPParams )(_gd .SignatureValidationResult ,error ){_de ,_aa :=_gdf ._f .Validate (sig ,digest );if _aa !=nil {return _de ,_aa ;};_cba :=params .Parser ;
if _cba ==nil {return _gd .SignatureValidationResult {},_ac .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_de .IsVerified {return _de ,nil ;};_edd :=params .DiffPolicy ;if _edd ==nil {_edd =_ga .NewDefaultDiffPolicy ();
};for _cddf :=0;_cddf <=_cba .GetRevisionNumber ();_cddf ++{_acg ,_ff :=_cba .GetRevision (_cddf );if _ff !=nil {return _gd .SignatureValidationResult {},_ff ;};_gg :=_acg .GetTrailer ();if _gg ==nil {return _gd .SignatureValidationResult {},_ac .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_fge ,_gc :=_edb .GetDict (_gg .Get ("\u0052\u006f\u006f\u0074"));if !_gc {return _gd .SignatureValidationResult {},_ac .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_be ,_gc :=_edb .GetDict (_fge .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_gc {continue ;};_fe ,_gc :=_edb .GetArray (_be .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_gc {continue ;};for _ ,_aef :=range _fe .Elements (){_abe ,_fb :=_edb .GetDict (_aef );
if !_fb {continue ;};_ee ,_fb :=_edb .GetDict (_abe .Get ("\u0056"));if !_fb {continue ;};if _edb .EqualObjects (_ee .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_de .DiffResults ,_ff =_edd .ReviewFile (_acg ,_cba ,&_ga .MDPParameters {DocMDPLevel :_gdf .Permission });
if _ff !=nil {return _gd .SignatureValidationResult {},_ff ;};_de .IsVerified =_de .DiffResults .IsPermitted ();return _de ,nil ;};};};return _gd .SignatureValidationResult {},_ac .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};