//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_ad "bytes";_bgf "crypto";_be "crypto/ecdsa";_ec "crypto/rand";_gd "crypto/rsa";_ga "crypto/x509";_e "crypto/x509/pkix";_a "encoding/asn1";_f "encoding/hex";_bd "errors";_dg "fmt";_bb "github.com/unidoc/pkcs7";_dgg "github.com/unidoc/timestamp";
_de "github.com/unidoc/unipdf/v4/common";_bgfa "github.com/unidoc/unipdf/v4/core";_cb "github.com/unidoc/unipdf/v4/model";_adc "github.com/unidoc/unipdf/v4/model/mdp";_dc "github.com/unidoc/unipdf/v4/model/sigutil";_g "hash";_c "math/big";_d "strings";
_bg "time";);

// GetCRLClient returns the client for retrieving CRLs.
func (_cf *etsiPAdES )GetCRLClient ()*_dc .CRLClient {return _cf .CRLClient };

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fbf *docTimeStamp )IsApplicable (sig *_cb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fba *DocMDPHandler )IsApplicable (sig *_cb .PdfSignature )bool {_fa :=false ;for _ ,_bde :=range sig .Reference .Elements (){if _ae ,_bf :=_bgfa .GetDict (_bde );_bf {if _bdg ,_da :=_bgfa .GetNameVal (_ae .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_da {if _bdg !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _ab ,_ac :=_bgfa .GetDict (_ae .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_ac {_ ,_cbe :=_bgfa .GetNumberAsInt64 (_ab .Get ("\u0050"));
if _cbe !=nil {return false ;};_fa =true ;break ;};};};};return _fa &&_fba ._fb .IsApplicable (sig );};func (_ccg *etsiPAdES )GetOCSPs (chain []*_ga .Certificate ,chainMap map[string ]*_ga .Certificate )([][]byte ,error ){_gde :=make ([][]byte ,0,len (chain ));
if _ccg .OCSPClient ==nil {_de .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u006e\u006f\u0020\u004f\u0043\u0053P\u0043\u006c\u0069\u0065\u006e\u0074\u0020\u0073\u0065\u0074");return _gde ,_cb .ErrNoOcspClient ;};for _ ,_ee :=range chain {for _ ,_gab :=range _ee .OCSPServer {if _ccg .CertClient .IsCA (_ee ){continue ;
};_gdc ,_fbb :=chainMap [_ee .Issuer .CommonName ];if !_fbb {_de .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_geg ,_abb :=_ccg .OCSPClient .MakeRequest (_gab ,_ee ,_gdc );if _abb !=nil {_de .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_abb );
continue ;};_gde =append (_gde ,_geg );};};return _gde ,nil ;};

// GetOCSPClient returns the client for retrieving OCSP responses.
func (_aaa *etsiPAdES )GetOCSPClient ()*_dc .OCSPClient {return _aaa .OCSPClient };

// GetCertificate returns the signing certificate for the signature handler.
func (_dbg *etsiPAdES )GetCertificate ()*_ga .Certificate {return _dbg ._ag };

// SetTimestampClient sets the HTTP client for timestamp requests.
func (_cce *etsiPAdES )SetTimestampClient (timestampClient *_dc .TimestampClient ){_cce .TimestampClient =timestampClient ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _bgf .Hash ;};func (_cedd *adobeX509RSASHA1 )sign (_dcee *_cb .PdfSignature ,_egd _cb .Hasher ,_bgfe bool )error {if !_bgfe {return _cedd .Sign (_dcee ,_egd );};_bcd ,_dbgd :=_cedd ._gdde .PublicKey .(*_gd .PublicKey );if !_dbgd {return _dg .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_bcd );
};_ebf ,_bfca :=_a .Marshal (make ([]byte ,_bcd .Size ()));if _bfca !=nil {return _bfca ;};_dcee .Contents =_bgfa .MakeHexString (string (_ebf ));return nil ;};func (_dae *etsiPAdES )addDss (_gf ,_cead []*_ga .Certificate ,_dce *RevocationInfoArchival )(int ,error ){_fcf ,_bage ,_cfg :=_dae .BuildCertChain (_gf ,_cead );
if _cfg !=nil {return 0,_cfg ;};_ffd ,_cfg :=_dae .GetCerts (_fcf );if _cfg !=nil {return 0,_cfg ;};var _gff ,_abagc [][]byte ;_gff ,_cfg =_dae .GetOCSPs (_fcf ,_bage );if _cfg !=nil {return 0,_cfg ;};_abagc ,_cfg =_dae .GetCRLs (_fcf );if _cfg !=nil {return 0,_cfg ;
};if !_dae ._cc {_ ,_cfg =_dae ._fda .AddCerts (_ffd );if _cfg !=nil {return 0,_cfg ;};_ ,_cfg =_dae ._fda .AddOCSPs (_gff );if _cfg !=nil {return 0,_cfg ;};_ ,_cfg =_dae ._fda .AddCRLs (_abagc );if _cfg !=nil {return 0,_cfg ;};};_fab :=0;for _ ,_bagea :=range _abagc {_fab +=len (_bagea );
_dce .Crl =append (_dce .Crl ,_a .RawValue {FullBytes :_bagea });};for _ ,_gadf :=range _gff {_fab +=len (_gadf );_dce .Ocsp =append (_dce .Ocsp ,_a .RawValue {FullBytes :_gadf });};return _fab ,nil ;};func (_bca *etsiPAdES )GetCRLs (chain []*_ga .Certificate )([][]byte ,error ){_bfe :=make ([][]byte ,0,len (chain ));
if _bca .CRLClient ==nil {_de .Log .Error ("\u0045\u0052\u0052OR\u003a\u0020\u006e\u006f\u0020\u0043\u0052\u004c\u0043\u006c\u0069\u0065\u006e\u0074\u0020\u0073\u0065\u0074");return _bfe ,_cb .ErrNoCrlClient ;};for _ ,_bcac :=range chain {for _ ,_eec :=range _bcac .CRLDistributionPoints {if _bca .CertClient .IsCA (_bcac ){continue ;
};_efd ,_bded :=_bca .CRLClient .MakeRequest (_eec ,_bcac );if _bded !=nil {_de .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_bded );continue ;};
_bfe =append (_bfe ,_efd );};};return _bfe ,nil ;};func _bec (_aada *_gd .PublicKey ,_afe []byte )_bgf .Hash {_dgc :=_aada .Size ();if _dgc !=len (_afe ){return 0;};_cgb :=func (_eea *_c .Int ,_deg *_gd .PublicKey ,_fae *_c .Int )*_c .Int {_faeg :=_c .NewInt (int64 (_deg .E ));
_eea .Exp (_fae ,_faeg ,_deg .N );return _eea ;};_eba :=new (_c .Int ).SetBytes (_afe );_dffa :=_cgb (new (_c .Int ),_aada ,_eba );_ddad :=_eefe (_dffa .Bytes (),_dgc );if _ddad [0]!=0||_ddad [1]!=1{return 0;};_gbb :=[]struct{Hash _bgf .Hash ;Prefix []byte ;
}{{Hash :_bgf .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_bgf .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_bgf .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_bgf .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_bgf .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_ebag :=range _gbb {_abaf :=_ebag .Hash .Size ();_befg :=len (_ebag .Prefix )+_abaf ;if _ad .Equal (_ddad [_dgc -_befg :_dgc -_abaf ],_ebag .Prefix ){return _ebag .Hash ;};};return 0;};

// GetPrivateKey returns the private key for the signature handler.
func (_eca *etsiPAdES )GetPrivateKey ()_bgf .PrivateKey {return _eca ._fd };

// SetAppender sets the PDF appender.
func (_ace *etsiPAdES )SetAppender (appender *_cb .PdfAppender ){_ace ._bc =appender };func (_aceg *adobeX509RSASHA1 )getCertificate (_gcf *_cb .PdfSignature )(*_ga .Certificate ,error ){if _aceg ._gdde !=nil {return _aceg ._gdde ,nil ;};_cdaf ,_ged :=_gcf .GetCerts ();
if _ged !=nil {return nil ,_ged ;};return _cdaf [0],nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_ga .Certificate ,signFunc SignFunc )(_cb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gdde :certificate ,_gea :signFunc },nil ;};func (_bgd *etsiPAdES )BuildCertChain (sigCerts ,extraCerts []*_ga .Certificate )([]*_ga .Certificate ,map[string ]*_ga .Certificate ,error ){if _bgd .CertClient ==nil {_de .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u006e\u006f\u0020\u0043\u0065\u0072t\u0043\u006c\u0069\u0065\u006e\u0074\u0020\u0073\u0065\u0074");
return nil ,nil ,_cb .ErrNoCertClient ;};_eb :=map[string ]*_ga .Certificate {};for _ ,_aga :=range sigCerts {_eb [_aga .Subject .CommonName ]=_aga ;};_bge :=sigCerts ;for _ ,_dfe :=range extraCerts {_bdf :=_dfe .Subject .CommonName ;if _ ,_beaf :=_eb [_bdf ];
_beaf {continue ;};_eb [_bdf ]=_dfe ;_bge =append (_bge ,_dfe );};if len (_bge )==0{return nil ,nil ,_cb .ErrSignNoCertificates ;};var _ega error ;for _bfd :=_bge [0];_bfd !=nil &&!_bgd .CertClient .IsCA (_bfd );{var _cbg *_ga .Certificate ;_ ,_fgb :=_eb [_bfd .Issuer .CommonName ];
if !_fgb {if _cbg ,_ega =_bgd .CertClient .GetIssuer (_bfd );_ega !=nil {_de .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_ega );
break ;};_eb [_bfd .Issuer .CommonName ]=_cbg ;_bge =append (_bge ,_cbg );}else {break ;};_bfd =_cbg ;};return _bge ,_eb ,nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_dc .TimestampClient ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_gd .PrivateKey ,certificate *_ga .Certificate )(_cb .SignatureHandler ,error ){return &adobePKCS7Detached {_gb :certificate ,_ebd :privateKey },nil ;};

// SetCertificate sets the signing certificate for the signature handler.
func (_fc *etsiPAdES )SetCertificate (certificate *_ga .Certificate ){_fc ._ag =certificate };

// InitSignature initialises the PdfSignature.
func (_aae *etsiPAdES )InitSignature (sig *_cb .PdfSignature )error {if _aae ._ag ==nil {return _bd .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _aae ._fd ==nil {return _bd .New ("p\u0072\u0069\u0076\u0061\u0074\u0065 \u006b\u0065\u0079\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _aae ._acd >=LevelT {if _aae ._fdc ==""{return _bd .New ("\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u0074i\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0073e\u0072\u0076\u0065\u0072\u0020\u0055\u0052\u004c\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0066\u006f\u0072\u0020\u004c\u0065\u0076\u0065\u006c\u0020\u0054\u0020\u0026\u0020\u004c\u0054\u0020\u0073i\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0068a\u006e\u0064l\u0065\u0072");
};if _aae .TimestampClient ==nil {_de .Log .Trace ("\u0054\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0063\u006c\u0069\u0065\u006et\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u002c\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0065fa\u0075\u006c\u0074\u0020\u0063\u006c\u0069\u0065\u006e\u0074");
_aae .TimestampClient =_dc .NewTimestampClient ();};};if _aae ._acd ==LevelLT {if _aae .CertClient ==nil {_de .Log .Trace ("\u0063\u0065\u0072\u0074\u0020\u0063l\u0069\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u002c\u0020u\u0073\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074 \u0063l\u0069\u0065\u006e\u0074");
_aae .CertClient =_dc .NewCertClient ();};if _aae .OCSPClient ==nil {_de .Log .Trace ("\u004f\u0043\u0053\u0050\u0020\u0063l\u0069\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u002c\u0020u\u0073\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074 \u0063l\u0069\u0065\u006e\u0074");
_aae .OCSPClient =_dc .NewOCSPClient ();};if _aae .CRLClient ==nil {_de .Log .Trace ("\u0043\u0052\u004c\u0020\u0063\u006c\u0069\u0065n\u0074\u0020\u006eot\u0020\u0073\u0070\u0065\u0063\u0069f\u0069\u0065\u0064\u002c\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0065f\u0061\u0075\u006c\u0074\u0020\u0063\u006c\u0069e\u006e\u0074");
_aae .CRLClient =_dc .NewCRLClient ();};if _aae ._bc ==nil {return _bd .New ("\u0061\u0070\u0070\u0065\u006e\u0064\u0065r\u0020\u006d\u0075s\u0074\u0020\u006eo\u0074\u0020b\u0065\u0020\u006e\u0069\u006c\u0020f\u006fr \u004c\u0065\u0076\u0065\u006c\u0020\u004c\u0054\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0068\u0061\u006e\u0064\u006c\u0065\u0072");
};if _aae ._fda ==nil {_egb :=_aae ._bc .Reader .DSS ;if _egb ==nil {_egb =_cb .NewDSS ();};if _ge :=_egb .GenerateHashMaps ();_ge !=nil {return _ge ;};_aae ._fda =_egb ;};};_aag :=*_aae ;sig .Handler =&_aag ;sig .Filter =_bgfa .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_bgfa .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_cda ,_dgde :=_aag .NewDigest (sig );if _dgde !=nil {return _dgde ;};_ ,_dgde =_cda .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _dgde !=nil {return _dgde ;};_aag ._cc =true ;_dgde =_aag .Sign (sig ,_cda );_aag ._cc =false ;return _dgde ;};

// SetPrivateKey sets the private key for the signature handler.
func (_dggb *etsiPAdES )SetPrivateKey (privateKey _bgf .PrivateKey ){_dggb ._fd =privateKey };

// SkipSigningCertificateAttribute skips adding signing certificate attribute during signing process.
// Generally, it is not recommended, call it only in case your signature validator requires it.
func (_ecbe *etsiPAdES )SkipSigningCertificateAttribute (){_ecbe ._acf =true };

// EtsiPAdESLevel represents the PAdES signature level.
type EtsiPAdESLevel int ;

// NewDigest creates a new digest.
func (_afa *etsiPAdES )NewDigest (_ *_cb .PdfSignature )(_cb .Hasher ,error ){return _ad .NewBuffer (nil ),nil ;};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _cb .SignatureHandler ,permission _adc .DocMDPPermission )(_cb .SignatureHandler ,error ){return &DocMDPHandler {_fb :handler ,Permission :permission },nil ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_gd .PrivateKey ,certificate *_ga .Certificate ,caCert *_ga .Certificate ,certificateTimestampServerURL string ,appender *_cb .PdfAppender )(_cb .SignatureHandler ,error ){_cea :=appender .Reader .DSS ;if _cea ==nil {_cea =_cb .NewDSS ();
};if _ecag :=_cea .GenerateHashMaps ();_ecag !=nil {return nil ,_ecag ;};return &etsiPAdES {_acd :LevelLT ,_ag :certificate ,_fd :privateKey ,_beg :caCert ,_fdc :certificateTimestampServerURL ,CertClient :_dc .NewCertClient (),OCSPClient :_dc .NewOCSPClient (),CRLClient :_dc .NewCRLClient (),_bc :appender ,_fda :_cea },nil ;
};

// InitSignature initialises the PdfSignature.
func (_bdea *docTimeStamp )InitSignature (sig *_cb .PdfSignature )error {_cbdd :=*_bdea ;sig .Type =_bgfa .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_cbdd ;sig .Filter =_bgfa .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_bgfa .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _bdea ._dga > 0{sig .Contents =_bgfa .MakeHexString (string (make ([]byte ,_bdea ._dga )));}else {_eae ,_gge :=_bdea .NewDigest (sig );
if _gge !=nil {return _gge ;};_eae .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gge =_cbdd .Sign (sig ,_eae );
_gge !=nil {return _gge ;};_bdea ._dga =_cbdd ._dga ;};return nil ;};

// NewAdobePKCS7DetachedEcdsa creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewAdobePKCS7Detached.
func NewAdobePKCS7DetachedEcdsa (privateKey *_be .PrivateKey ,certificate *_ga .Certificate )(_cb .SignatureHandler ,error ){return &adobePKCS7Detached {_gb :certificate ,_ebd :privateKey },nil ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_fb _cb .SignatureHandler ;Permission _adc .DocMDPPermission ;};

// SkipRevocationInfoAttribute skips adding revocation attribute during signing process.
// Generally, it is not recommended, call it only in case your signature validator requires it.
func (_ff *etsiPAdES )SkipRevocationInfoAttribute (){_ff ._ecb =true };

// Validate validates PdfSignature.
func (_dde *adobeX509RSASHA1 )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){_ddag ,_ada :=_dde .getCertificate (sig );if _ada !=nil {return _cb .SignatureValidationResult {},_ada ;};_ggff :=sig .Contents .Bytes ();
var _bafd []byte ;if _ ,_bddg :=_a .Unmarshal (_ggff ,&_bafd );_bddg !=nil {return _cb .SignatureValidationResult {},_bddg ;};_ebb ,_gag :=digest .(_g .Hash );if !_gag {return _cb .SignatureValidationResult {},_bd .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_dee ,_ :=_dde .getHashAlgorithm (sig );if _dee ==0{_dee =_ege ;};if _ecgcg :=_gd .VerifyPKCS1v15 (_ddag .PublicKey .(*_gd .PublicKey ),_dee ,_ebb .Sum (nil ),_bafd );_ecgcg !=nil {return _cb .SignatureValidationResult {},_ecgcg ;};return _cb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_cb .SignatureHandler ,error ){return &adobePKCS7Detached {_acab :true ,_ced :signatureLen },nil ;};

// InitSignature initialises the PdfSignature.
func (_gfd *adobePKCS7Detached )InitSignature (sig *_cb .PdfSignature )error {if !_gfd ._acab {if _gfd ._gb ==nil {return _bd .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _gfd ._ebd ==nil {return _bd .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_dcf :=*_gfd ;sig .Handler =&_dcf ;sig .Filter =_bgfa .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_bgfa .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_cefb ,_cbc :=_dcf .NewDigest (sig );if _cbc !=nil {return _cbc ;};_cefb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _dcf .Sign (sig ,_cefb );};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_agab *adobePKCS7Detached )IsApplicable (sig *_cb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// GetAppender returns the PDF appender.
func (_cdc *etsiPAdES )GetAppender ()*_cb .PdfAppender {return _cdc ._bc };

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_dec *etsiPAdES )IsApplicable (sig *_cb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// GetTimestampClient returns the HTTP client for timestamp requests.
func (_aa *etsiPAdES )GetTimestampClient ()*_dc .TimestampClient {return _aa .TimestampClient };

// Sign sets the Contents fields for the PdfSignature.
func (_gba *adobeX509RSASHA1 )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {var _cfcb []byte ;var _agc error ;if _gba ._gea !=nil {_cfcb ,_agc =_gba ._gea (sig ,digest );if _agc !=nil {return _agc ;};}else {_ecd ,_abdb :=digest .(_g .Hash );
if !_abdb {return _bd .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ebbc :=_ege ;if _gba ._aaga !=0{_ebbc =_gba ._aaga ;};_cfcb ,_agc =_gd .SignPKCS1v15 (_ec .Reader ,_gba ._eab ,_ebbc ,_ecd .Sum (nil ));if _agc !=nil {return _agc ;
};};_cfcb ,_agc =_a .Marshal (_cfcb );if _agc !=nil {return _agc ;};sig .Contents =_bgfa .MakeHexString (string (_cfcb ));return nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _bgf .Hash )(_cb .SignatureHandler ,error ){return &docTimeStamp {_fdad :timestampServerURL ,_adb :hashAlgorithm },nil ;};func (_abe *etsiPAdES )makeTimestampRequest (_dff []byte )(_a .RawValue ,error ){_fde :=_bgf .SHA512 .New ();
_fde .Write (_dff );_dd :=_fde .Sum (nil );_fe :=_dgg .Request {HashAlgorithm :_bgf .SHA512 ,HashedMessage :_dd ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };var _cbae *_dc .TimestampClient ;if _abe .TimestampClient !=nil {_cbae =_abe .TimestampClient ;
}else {_cbae =_dc .NewTimestampClient ();};_dgf ,_abgd :=_cbae .GetEncodedToken (_abe ._fdc ,&_fe );if _abgd !=nil {return _a .NullRawValue ,_abgd ;};return _a .RawValue {FullBytes :_dgf },nil ;};

// SetTimestampServerURL sets the URL of the timestamp server.
func (_ba *etsiPAdES )SetTimestampServerURL (timestampServerURL string ){_ba ._fdc =timestampServerURL };func (_gef *docTimeStamp )getCertificate (_fadg *_cb .PdfSignature )(*_ga .Certificate ,error ){_fcab ,_ebbg :=_fadg .GetCerts ();if _ebbg !=nil {return nil ,_ebbg ;
};return _fcab [0],nil ;};

// InitSignature initialization of the DocMDP signature.
func (_ce *DocMDPHandler )InitSignature (sig *_cb .PdfSignature )error {_ggf :=_ce ._fb .InitSignature (sig );if _ggf !=nil {return _ggf ;};sig .Handler =_ce ;if sig .Reference ==nil {sig .Reference =_bgfa .MakeArray ();};sig .Reference .Append (_cb .NewPdfSignatureReferenceDocMDP (_cb .NewPdfTransformParamsDocMDP (_ce .Permission )).ToPdfObject ());
return nil ;};

// SetCA sets the CA certificate for the signature handler.
func (_dbf *etsiPAdES )SetCA (certificate *_ga .Certificate ){_dbf ._beg =certificate };type adobeX509RSASHA1 struct{_eab *_gd .PrivateKey ;_gdde *_ga .Certificate ;_gea SignFunc ;_aef bool ;_aaga _bgf .Hash ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _bgf .Hash ,opts *DocTimeStampOpts )(_cb .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_fdad :timestampServerURL ,_adb :hashAlgorithm ,_dga :opts .SignatureSize ,_ggca :opts .Client },nil ;
};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_cca *_cb .PdfSignature ,_eef _cb .Hasher )([]byte ,error );

// SetCertClient sets the client for retrieving certificates.
func (_aac *etsiPAdES )SetCertClient (certClient *_dc .CertClient ){_aac .CertClient =certClient };

// Sign sets the Contents fields for the PdfSignature.
func (_bbd *etsiPAdES )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {_ebe ,_ecgc :=digest .(*_ad .Buffer );if !_ecgc {return _dg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bcg ,_egg :=_bb .NewSignedData (_ebe .Bytes ());
if _egg !=nil {return _egg ;};_bcg .SetDigestAlgorithm (_bb .OIDDigestAlgorithmSHA256 );_fed :=_bb .SignerInfoConfig {};_dfg :=_bgf .SHA256 .New ();_dfg .Write (_bbd ._ag .Raw );var _acge struct{Seq struct{Seq struct{Value []byte ;};};};_acge .Seq .Seq .Value =_dfg .Sum (nil );
var _ceg []*_ga .Certificate ;var _ddf []*_ga .Certificate ;if _bbd ._beg !=nil {_ddf =[]*_ga .Certificate {_bbd ._beg };};_dac :=RevocationInfoArchival {Crl :[]_a .RawValue {},Ocsp :[]_a .RawValue {},OtherRevInfo :[]_a .RawValue {}};_fgce :=0;if _bbd ._bc !=nil &&(len (_bbd ._fdc )> 0||_bbd .TimestampClient !=nil ){_fca ,_bfc :=_bbd .makeTimestampRequest (([]byte )(""));
if _bfc !=nil {return _bfc ;};_add ,_bfc :=_dgg .Parse (_fca .FullBytes );if _bfc !=nil {return _bfc ;};_ceg =append (_ceg ,_add .Certificates ...);};if _bbd ._bc !=nil {_dbge ,_baf :=_bbd .addDss ([]*_ga .Certificate {_bbd ._ag },_ddf ,&_dac );if _baf !=nil {return _baf ;
};_fgce +=_dbge ;if len (_ceg )> 0{_dbge ,_baf =_bbd .addDss (_ceg ,nil ,&_dac );if _baf !=nil {return _baf ;};_fgce +=_dbge ;};if !_bbd ._cc {_bbd ._bc .SetDSS (_bbd ._fda );};};if !_bbd ._acf {_fed .ExtraSignedAttributes =append (_fed .ExtraSignedAttributes ,_bb .Attribute {Type :_bb .OIDAttributeSigningCertificateV2 ,Value :_acge });
};if !_bbd ._ecb {_fed .ExtraSignedAttributes =append (_fed .ExtraSignedAttributes ,_bb .Attribute {Type :_bb .OIDAttributeAdobeRevocation ,Value :_dac });};if _bcc :=_bcg .AddSignerChainPAdES (_bbd ._ag ,_bbd ._fd ,_ddf ,_fed );_bcc !=nil {return _bcc ;
};_bcg .Detach ();if len (_bbd ._fdc )> 0{_fegf :=_bcg .GetSignedData ().SignerInfos [0].EncryptedDigest ;_ggg ,_bbf :=_bbd .makeTimestampRequest (_fegf );if _bbf !=nil {return _bbf ;};_bbf =_bcg .AddTimestampTokenToSigner (0,_ggg .FullBytes );if _bbf !=nil {return _bbf ;
};};_ffe ,_egg :=_bcg .Finish ();if _egg !=nil {return _egg ;};const _fcc =1024;_ca :=(len (_ffe )/_fcc )+2;_fcaf :=make ([]byte ,_fcc *_ca +_fgce );copy (_fcaf ,_ffe );sig .Contents =_bgfa .MakeHexString (string (_fcaf ));if !_bbd ._cc &&_bbd ._fda !=nil {_dfg =_bgf .SHA1 .New ();
_dfg .Write (_fcaf );_bfda :=_d .ToUpper (_f .EncodeToString (_dfg .Sum (nil )));if _bfda !=""{_bbd ._fda .VRI [_bfda ]=&_cb .VRI {Cert :_bbd ._fda .Certs ,OCSP :_bbd ._fda .OCSPs ,CRL :_bbd ._fda .CRLs };};_bbd ._bc .SetDSS (_bbd ._fda );};return nil ;
};type docTimeStamp struct{_fdad string ;_adb _bgf .Hash ;_dga int ;_ggca *_dc .TimestampClient ;};func _eff (_adef _a .ObjectIdentifier )(_bgf .Hash ,error ){switch {case _adef .Equal (_bb .OIDDigestAlgorithmSHA1 ),_adef .Equal (_bb .OIDDigestAlgorithmECDSASHA1 ),_adef .Equal (_bb .OIDDigestAlgorithmDSA ),_adef .Equal (_bb .OIDDigestAlgorithmDSASHA1 ),_adef .Equal (_bb .OIDEncryptionAlgorithmRSA ):return _bgf .SHA1 ,nil ;
case _adef .Equal (_bb .OIDDigestAlgorithmSHA256 ),_adef .Equal (_bb .OIDDigestAlgorithmECDSASHA256 ):return _bgf .SHA256 ,nil ;case _adef .Equal (_bb .OIDDigestAlgorithmSHA384 ),_adef .Equal (_bb .OIDDigestAlgorithmECDSASHA384 ):return _bgf .SHA384 ,nil ;
case _adef .Equal (_bb .OIDDigestAlgorithmSHA512 ),_adef .Equal (_bb .OIDDigestAlgorithmECDSASHA512 ):return _bgf .SHA512 ,nil ;};return _bgf .Hash (0),_bb .ErrUnsupportedAlgorithm ;};

// GetCA returns the CA certificate for the signature handler.
func (_bea *etsiPAdES )GetCA ()*_ga .Certificate {return _bea ._beg };

// NewDigest creates a new digest.
func (_aacd *docTimeStamp )NewDigest (sig *_cb .PdfSignature )(_cb .Hasher ,error ){return _ad .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields.
func (_fcac *adobePKCS7Detached )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {if _fcac ._acab {_cgdb :=_fcac ._ced ;if _cgdb <=0{_cgdb =8192;};sig .Contents =_bgfa .MakeHexString (string (make ([]byte ,_cgdb )));return nil ;};_fce ,_dacf :=digest .(*_ad .Buffer );
if !_dacf {return _dg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bgg ,_dcd :=_bb .NewSignedData (_fce .Bytes ());if _dcd !=nil {return _dcd ;};if _ffc :=_bgg .AddSigner (_fcac ._gb ,_fcac ._ebd ,_bb .SignerInfoConfig {});
_ffc !=nil {return _ffc ;};_bgg .Detach ();_ead ,_dcd :=_bgg .Finish ();if _dcd !=nil {return _dcd ;};_bdb :=make ([]byte ,8192);copy (_bdb ,_ead );sig .Contents =_bgfa .MakeHexString (string (_bdb ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_aaaf *docTimeStamp )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {_bcb ,_cdef :=_dc .NewTimestampRequest (digest .(*_ad .Buffer ),&_dgg .RequestOptions {Hash :_aaaf ._adb ,Certificates :true });if _cdef !=nil {return _cdef ;};_ggd :=_aaaf ._ggca ;
if _ggd ==nil {_ggd =_dc .NewTimestampClient ();};_bagf ,_cdef :=_ggd .GetEncodedToken (_aaaf ._fdad ,_bcb );if _cdef !=nil {return _cdef ;};_ecdb :=len (_bagf );if _aaaf ._dga > 0&&_ecdb > _aaaf ._dga {return _cb .ErrSignNotEnoughSpace ;};if _ecdb > 0{_aaaf ._dga =_ecdb +128;
};if sig .Contents !=nil {_ggde :=sig .Contents .Bytes ();copy (_ggde ,_bagf );_bagf =_ggde ;};sig .Contents =_bgfa .MakeHexString (string (_bagf ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fbc *adobeX509RSASHA1 )IsApplicable (sig *_cb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// Validate validates PdfSignature.
func (_bagee *adobePKCS7Detached )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){_bbc :=sig .Contents .Bytes ();_fec ,_cgd :=_bb .Parse (_bbc );if _cgd !=nil {return _cb .SignatureValidationResult {},_cgd ;
};_bfcg ,_bce :=digest .(*_ad .Buffer );if !_bce {return _cb .SignatureValidationResult {},_dg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_fec .Content =_bfcg .Bytes ();if _cgd =_fec .Verify ();
_cgd !=nil {return _cb .SignatureValidationResult {},_cgd ;};return _cb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewDigest creates a new digest.
func (_fad *adobePKCS7Detached )NewDigest (sig *_cb .PdfSignature )(_cb .Hasher ,error ){return _ad .NewBuffer (nil ),nil ;};

// NewDigest creates a new digest.
func (_gda *DocMDPHandler )NewDigest (sig *_cb .PdfSignature )(_cb .Hasher ,error ){return _gda ._fb .NewDigest (sig );};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_acaa *DocMDPHandler )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){return _cb .SignatureValidationResult {},_bd .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// NewEtsiPAdES creates a new PAdES signature handler with the specified algorithm and level.
// The handler should be further configured using the available setter methods.
func NewEtsiPAdES (level EtsiPAdESLevel )*etsiPAdES {return &etsiPAdES {_acd :level }};

// Validate validates PdfSignature.
func (_ecac *etsiPAdES )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){_dbgc :=sig .Contents .Bytes ();_aed ,_dbgce :=_bb .Parse (_dbgc );if _dbgce !=nil {return _cb .SignatureValidationResult {},_dbgce ;
};_cbf ,_dgga :=digest .(*_ad .Buffer );if !_dgga {return _cb .SignatureValidationResult {},_dg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_aed .Content =_cbf .Bytes ();if _dbgce =_aed .Verify ();
_dbgce !=nil {return _cb .SignatureValidationResult {},_dbgce ;};_afb :=false ;_ade :=false ;var _fga _bg .Time ;for _ ,_gdb :=range _aed .Signers {_age :=_gdb .EncryptedDigest ;var _bgc RevocationInfoArchival ;_dbgce =_aed .UnmarshalSignedAttribute (_bb .OIDAttributeAdobeRevocation ,&_bgc );
if _dbgce ==nil {if len (_bgc .Crl )> 0{_ade =true ;};if len (_bgc .Ocsp )> 0{_afb =true ;};};for _ ,_adf :=range _gdb .UnauthenticatedAttributes {if _adf .Type .Equal (_bb .OIDAttributeTimeStampToken ){_fgae ,_ggce :=_dgg .Parse (_adf .Value .Bytes );
if _ggce !=nil {return _cb .SignatureValidationResult {},_ggce ;};_fga =_fgae .Time ;_aad :=_fgae .HashAlgorithm .New ();_aad .Write (_age );if !_ad .Equal (_aad .Sum (nil ),_fgae .HashedMessage ){return _cb .SignatureValidationResult {},_bd .New ("\u0068\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_bef :=_cb .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_ade ,IsOcspFound :_afb ,GeneralizedTime :_fga };return _bef ,nil ;};

// InitSignature initialises the PdfSignature.
func (_bda *adobeX509RSASHA1 )InitSignature (sig *_cb .PdfSignature )error {if _bda ._gdde ==nil {return _bd .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _bda ._eab ==nil &&_bda ._gea ==nil {return _bd .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_bff :=*_bda ;sig .Handler =&_bff ;sig .Filter =_bgfa .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bgfa .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_bgfa .MakeString (string (_bff ._gdde .Raw ));sig .Reference =nil ;_cfc ,_adff :=_bff .NewDigest (sig );if _adff !=nil {return _adff ;};_cfc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _bff .sign (sig ,_cfc ,_bda ._aef );};

// NewEtsiPAdESLevelTEcdsa creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewEtsiPAdESLevelT.
func NewEtsiPAdESLevelTEcdsa (privateKey *_be .PrivateKey ,certificate *_ga .Certificate ,caCert *_ga .Certificate ,certificateTimestampServerURL string )(_cb .SignatureHandler ,error ){return &etsiPAdES {_acd :LevelT ,_ag :certificate ,_fd :privateKey ,_beg :caCert ,_fdc :certificateTimestampServerURL },nil ;
};

// GetTimestampServerURL returns the URL of the timestamp server.
func (_aeg *etsiPAdES )GetTimestampServerURL ()string {return _aeg ._fdc };

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_gd .PrivateKey ,certificate *_ga .Certificate ,caCert *_ga .Certificate )(_cb .SignatureHandler ,error ){return &etsiPAdES {_acd :LevelB ,_ag :certificate ,_fd :privateKey ,_beg :caCert },nil ;};func (_bcfe *adobeX509RSASHA1 )getHashAlgorithm (_bfeb *_cb .PdfSignature )(_bgf .Hash ,error ){_ebee ,_daa :=_bcfe .getCertificate (_bfeb );
if _daa !=nil {if _bcfe ._aaga !=0{return _bcfe ._aaga ,nil ;};return _ege ,_daa ;};if _bfeb .Contents !=nil {_dda :=_bfeb .Contents .Bytes ();var _bada []byte ;if _ ,_edff :=_a .Unmarshal (_dda ,&_bada );_edff ==nil {_baa :=_bec (_ebee .PublicKey .(*_gd .PublicKey ),_bada );
if _baa > 0{return _baa ,nil ;};};};if _bcfe ._aaga !=0{return _bcfe ._aaga ,nil ;};return _ege ,nil ;};

// GetDSS returns the Document Security Store (DSS) for the signature handler.
func (_aba *etsiPAdES )GetDSS ()*_cb .DSS {return _aba ._fda };

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_ga .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_cb .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_gdde :certificate ,_gea :signFunc ,_aef :opts .EstimateSize ,_aaga :opts .Algorithm },nil ;
};

// SetOCSPClient sets the client for retrieving OCSP responses.
func (_fg *etsiPAdES )SetOCSPClient (ocspClient *_dc .OCSPClient ){_fg .OCSPClient =ocspClient };type timestampInfo struct{Version int ;Policy _a .RawValue ;MessageImprint struct{HashAlgorithm _e .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _a .RawValue ;
GeneralizedTime _bg .Time ;};type etsiPAdES struct{_acd EtsiPAdESLevel ;_fd _bgf .PrivateKey ;_ag *_ga .Certificate ;_cc bool ;_beg *_ga .Certificate ;_fdc string ;

// TimestampClient an optional client used to connect to a timestamp server.
//
// If not defined then a default client would be used.
TimestampClient *_dc .TimestampClient ;

// CertClient is the client used to retrieve certificates.
CertClient *_dc .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_dc .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_dc .CRLClient ;_bc *_cb .PdfAppender ;_fda *_cb .DSS ;_acf bool ;_ecb bool ;};

// NewEtsiPAdESLevelBEcdsa creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewEtsiPAdESLevelB.
func NewEtsiPAdESLevelBEcdsa (privateKey *_be .PrivateKey ,certificate *_ga .Certificate ,caCert *_ga .Certificate )(_cb .SignatureHandler ,error ){return &etsiPAdES {_acd :LevelB ,_ag :certificate ,_fd :privateKey ,_beg :caCert },nil ;};

// SetCRLClient sets the client for retrieving CRLs.
func (_acg *etsiPAdES )SetCRLClient (crlClient *_dc .CRLClient ){_acg .CRLClient =crlClient };

// NewEtsiPAdESLevelLTEcdsa creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewEtsiPAdESLevelLT.
func NewEtsiPAdESLevelLTEcdsa (privateKey *_be .PrivateKey ,certificate *_ga .Certificate ,caCert *_ga .Certificate ,certificateTimestampServerURL string ,appender *_cb .PdfAppender )(_cb .SignatureHandler ,error ){_abag :=appender .Reader .DSS ;if _abag ==nil {_abag =_cb .NewDSS ();
};if _af :=_abag .GenerateHashMaps ();_af !=nil {return nil ,_af ;};return &etsiPAdES {_acd :LevelLT ,_ag :certificate ,_fd :privateKey ,_beg :caCert ,_fdc :certificateTimestampServerURL ,CertClient :_dc .NewCertClient (),OCSPClient :_dc .NewOCSPClient (),CRLClient :_dc .NewCRLClient (),_bc :appender ,_fda :_abag },nil ;
};type adobePKCS7Detached struct{_ebd _bgf .PrivateKey ;_gb *_ga .Certificate ;_acab bool ;_ced int ;};

// GetCertClient returns the client for retrieving certificates.
func (_ef *etsiPAdES )GetCertClient ()*_dc .CertClient {return _ef .CertClient };const _ege =_bgf .SHA1 ;const (LevelB EtsiPAdESLevel =iota ;LevelT ;LevelLT ;);

// Validate validates PdfSignature.
func (_cbff *docTimeStamp )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){_begf :=sig .Contents .Bytes ();_cfa ,_ebae :=_bb .Parse (_begf );if _ebae !=nil {return _cb .SignatureValidationResult {},_ebae ;
};if _ebae =_cfa .Verify ();_ebae !=nil {return _cb .SignatureValidationResult {},_ebae ;};var _gbbd timestampInfo ;_ ,_ebae =_a .Unmarshal (_cfa .Content ,&_gbbd );if _ebae !=nil {return _cb .SignatureValidationResult {},_ebae ;};_ecc ,_ebae :=_eff (_gbbd .MessageImprint .HashAlgorithm .Algorithm );
if _ebae !=nil {return _cb .SignatureValidationResult {},_ebae ;};_cde :=_ecc .New ();_eade ,_gbc :=digest .(*_ad .Buffer );if !_gbc {return _cb .SignatureValidationResult {},_dg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_cde .Write (_eade .Bytes ());_ddd :=_cde .Sum (nil );_cee :=_cb .SignatureValidationResult {IsSigned :true ,IsVerified :_ad .Equal (_ddd ,_gbbd .MessageImprint .HashedMessage ),GeneralizedTime :_gbbd .GeneralizedTime };return _cee ,nil ;};

// SetDSS sets the Document Security Store (DSS) for the signature handler.
// The DSS contains validation-related information such as certificates, CRLs, and OCSP responses.
func (_dgd *etsiPAdES )SetDSS (dss *_cb .DSS ){_dgd ._fda =dss };func (_ed *etsiPAdES )GetCerts (chain []*_ga .Certificate )([][]byte ,error ){_edf :=make ([][]byte ,0,len (chain ));for _ ,_cef :=range chain {_edf =append (_edf ,_cef .Raw );};return _edf ,nil ;
};

// NewDigest creates a new digest.
func (_egec *adobeX509RSASHA1 )NewDigest (sig *_cb .PdfSignature )(_cb .Hasher ,error ){if _fccd ,_ecbc :=_egec .getHashAlgorithm (sig );_fccd !=0&&_ecbc ==nil {return _fccd .New (),nil ;};return _ege .New (),nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_gd .PrivateKey ,certificate *_ga .Certificate )(_cb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gdde :certificate ,_eab :privateKey },nil ;};func _eefe (_dba []byte ,_dfff int )(_defa []byte ){_bdae :=len (_dba );
if _bdae > _dfff {_bdae =_dfff ;};_defa =make ([]byte ,_dfff );copy (_defa [len (_defa )-_bdae :],_dba );return ;};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_a .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_a .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_a .RawValue `asn1:"explicit,tag:2,optional"`;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_gd .PrivateKey ,certificate *_ga .Certificate ,caCert *_ga .Certificate ,certificateTimestampServerURL string )(_cb .SignatureHandler ,error ){return &etsiPAdES {_acd :LevelT ,_ag :certificate ,_fd :privateKey ,_beg :caCert ,_fdc :certificateTimestampServerURL },nil ;
};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_cg *DocMDPHandler )ValidateWithOpts (sig *_cb .PdfSignature ,digest _cb .Hasher ,params _cb .SignatureHandlerDocMDPParams )(_cb .SignatureValidationResult ,error ){_db ,_ea :=_cg ._fb .Validate (sig ,digest );if _ea !=nil {return _db ,_ea ;};_eg :=params .Parser ;
if _eg ==nil {return _cb .SignatureValidationResult {},_bd .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_db .IsVerified {return _db ,nil ;};_ecf :=params .DiffPolicy ;if _ecf ==nil {_ecf =_adc .NewDefaultDiffPolicy ();
};for _cgg :=0;_cgg <=_eg .GetRevisionNumber ();_cgg ++{_abd ,_cbd :=_eg .GetRevision (_cgg );if _cbd !=nil {return _cb .SignatureValidationResult {},_cbd ;};_gad :=_abd .GetTrailer ();if _gad ==nil {return _cb .SignatureValidationResult {},_bd .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_ecg ,_cd :=_bgfa .GetDict (_gad .Get ("\u0052\u006f\u006f\u0074"));if !_cd {return _cb .SignatureValidationResult {},_bd .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_gg ,_cd :=_bgfa .GetDict (_ecg .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_cd {continue ;};_beb ,_cd :=_bgfa .GetArray (_gg .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_cd {continue ;};for _ ,_eag :=range _beb .Elements (){_acb ,_bdd :=_bgfa .GetDict (_eag );
if !_bdd {continue ;};_gc ,_bdd :=_bgfa .GetDict (_acb .Get ("\u0056"));if !_bdd {continue ;};if _bgfa .EqualObjects (_gc .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_db .DiffResults ,_cbd =_ecf .ReviewFile (_abd ,_eg ,&_adc .MDPParameters {DocMDPLevel :_cg .Permission });
if _cbd !=nil {return _cb .SignatureValidationResult {},_cbd ;};_db .IsVerified =_db .DiffResults .IsPermitted ();return _db ,nil ;};};};return _cb .SignatureValidationResult {},_bd .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// Sign adds a new reference to signature's references array.
func (_aca *DocMDPHandler )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {return _aca ._fb .Sign (sig ,digest );};